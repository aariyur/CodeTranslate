/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["pages/index"],{

/***/ "./node_modules/@uiw/codemirror-extensions-basic-setup/esm/index.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@uiw/codemirror-extensions-basic-setup/esm/index.js ***!
  \**************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"basicSetup\": function() { return /* binding */ basicSetup; },\n/* harmony export */   \"minimalSetup\": function() { return /* binding */ minimalSetup; }\n/* harmony export */ });\n/* harmony import */ var _codemirror_view__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @codemirror/view */ \"./node_modules/@codemirror/view/dist/index.js\");\n/* harmony import */ var _codemirror_state__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @codemirror/state */ \"./node_modules/@codemirror/state/dist/index.js\");\n/* harmony import */ var _codemirror_commands__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @codemirror/commands */ \"./node_modules/@codemirror/commands/dist/index.js\");\n/* harmony import */ var _codemirror_search__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @codemirror/search */ \"./node_modules/@codemirror/search/dist/index.js\");\n/* harmony import */ var _codemirror_autocomplete__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @codemirror/autocomplete */ \"./node_modules/@codemirror/autocomplete/dist/index.js\");\n/* harmony import */ var _codemirror_language__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @codemirror/language */ \"./node_modules/@codemirror/language/dist/index.js\");\n/* harmony import */ var _codemirror_lint__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @codemirror/lint */ \"./node_modules/@codemirror/lint/dist/index.js\");\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\nThis is an extension value that just pulls together a number of\r\nextensions that you might want in a basic editor. It is meant as a\r\nconvenient helper to quickly set up CodeMirror without installing\r\nand importing a lot of separate packages.\r\n\r\nSpecifically, it includes...\r\n\r\n - [the default command bindings](https://codemirror.net/6/docs/ref/#commands.defaultKeymap)\r\n - [line numbers](https://codemirror.net/6/docs/ref/#view.lineNumbers)\r\n - [special character highlighting](https://codemirror.net/6/docs/ref/#view.highlightSpecialChars)\r\n - [the undo history](https://codemirror.net/6/docs/ref/#commands.history)\r\n - [a fold gutter](https://codemirror.net/6/docs/ref/#language.foldGutter)\r\n - [custom selection drawing](https://codemirror.net/6/docs/ref/#view.drawSelection)\r\n - [drop cursor](https://codemirror.net/6/docs/ref/#view.dropCursor)\r\n - [multiple selections](https://codemirror.net/6/docs/ref/#state.EditorState^allowMultipleSelections)\r\n - [reindentation on input](https://codemirror.net/6/docs/ref/#language.indentOnInput)\r\n - [the default highlight style](https://codemirror.net/6/docs/ref/#language.defaultHighlightStyle) (as fallback)\r\n - [bracket matching](https://codemirror.net/6/docs/ref/#language.bracketMatching)\r\n - [bracket closing](https://codemirror.net/6/docs/ref/#autocomplete.closeBrackets)\r\n - [autocompletion](https://codemirror.net/6/docs/ref/#autocomplete.autocompletion)\r\n - [rectangular selection](https://codemirror.net/6/docs/ref/#view.rectangularSelection) and [crosshair cursor](https://codemirror.net/6/docs/ref/#view.crosshairCursor)\r\n - [active line highlighting](https://codemirror.net/6/docs/ref/#view.highlightActiveLine)\r\n - [active line gutter highlighting](https://codemirror.net/6/docs/ref/#view.highlightActiveLineGutter)\r\n - [selection match highlighting](https://codemirror.net/6/docs/ref/#search.highlightSelectionMatches)\r\n - [search](https://codemirror.net/6/docs/ref/#search.searchKeymap)\r\n - [linting](https://codemirror.net/6/docs/ref/#lint.lintKeymap)\r\n\r\n(You'll probably want to add some language package to your setup\r\ntoo.)\r\n\r\nThis extension does not allow customization. The idea is that,\r\nonce you decide you want to configure your editor more precisely,\r\nyou take this package's source (which is just a bunch of imports\r\nand an array literal), copy it into your own code, and adjust it\r\nas desired.\r\n*/\r\nvar basicSetup = function basicSetup(options) {\r\n  if (options === void 0) {\r\n    options = {};\r\n  }\r\n  var keymaps = [];\r\n  if (options.closeBracketsKeymap !== false) {\r\n    keymaps = keymaps.concat(_codemirror_autocomplete__WEBPACK_IMPORTED_MODULE_0__.closeBracketsKeymap);\r\n  }\r\n  if (options.defaultKeymap !== false) {\r\n    keymaps = keymaps.concat(_codemirror_commands__WEBPACK_IMPORTED_MODULE_1__.defaultKeymap);\r\n  }\r\n  if (options.searchKeymap !== false) {\r\n    keymaps = keymaps.concat(_codemirror_search__WEBPACK_IMPORTED_MODULE_2__.searchKeymap);\r\n  }\r\n  if (options.historyKeymap !== false) {\r\n    keymaps = keymaps.concat(_codemirror_commands__WEBPACK_IMPORTED_MODULE_1__.historyKeymap);\r\n  }\r\n  if (options.foldKeymap !== false) {\r\n    keymaps = keymaps.concat(_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.foldKeymap);\r\n  }\r\n  if (options.completionKeymap !== false) {\r\n    keymaps = keymaps.concat(_codemirror_autocomplete__WEBPACK_IMPORTED_MODULE_0__.completionKeymap);\r\n  }\r\n  if (options.lintKeymap !== false) {\r\n    keymaps = keymaps.concat(_codemirror_lint__WEBPACK_IMPORTED_MODULE_4__.lintKeymap);\r\n  }\r\n  var extensions = [];\r\n  if (options.lineNumbers !== false) extensions.push((0,_codemirror_view__WEBPACK_IMPORTED_MODULE_5__.lineNumbers)());\r\n  if (options.highlightActiveLineGutter !== false) extensions.push((0,_codemirror_view__WEBPACK_IMPORTED_MODULE_5__.highlightActiveLineGutter)());\r\n  if (options.highlightSpecialChars !== false) extensions.push((0,_codemirror_view__WEBPACK_IMPORTED_MODULE_5__.highlightSpecialChars)());\r\n  if (options.history !== false) extensions.push((0,_codemirror_commands__WEBPACK_IMPORTED_MODULE_1__.history)());\r\n  if (options.foldGutter !== false) extensions.push((0,_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.foldGutter)());\r\n  if (options.drawSelection !== false) extensions.push((0,_codemirror_view__WEBPACK_IMPORTED_MODULE_5__.drawSelection)());\r\n  if (options.dropCursor !== false) extensions.push((0,_codemirror_view__WEBPACK_IMPORTED_MODULE_5__.dropCursor)());\r\n  if (options.allowMultipleSelections !== false) extensions.push(_codemirror_state__WEBPACK_IMPORTED_MODULE_6__.EditorState.allowMultipleSelections.of(true));\r\n  if (options.indentOnInput !== false) extensions.push((0,_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.indentOnInput)());\r\n  if (options.syntaxHighlighting !== false) extensions.push((0,_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.syntaxHighlighting)(_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.defaultHighlightStyle, {\r\n    fallback: true\r\n  }));\r\n  if (options.bracketMatching !== false) extensions.push((0,_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.bracketMatching)());\r\n  if (options.closeBrackets !== false) extensions.push((0,_codemirror_autocomplete__WEBPACK_IMPORTED_MODULE_0__.closeBrackets)());\r\n  if (options.autocompletion !== false) extensions.push((0,_codemirror_autocomplete__WEBPACK_IMPORTED_MODULE_0__.autocompletion)());\r\n  if (options.rectangularSelection !== false) extensions.push((0,_codemirror_view__WEBPACK_IMPORTED_MODULE_5__.rectangularSelection)());\r\n  if (options.crosshairCursor !== false) extensions.push((0,_codemirror_view__WEBPACK_IMPORTED_MODULE_5__.crosshairCursor)());\r\n  if (options.highlightActiveLine !== false) extensions.push((0,_codemirror_view__WEBPACK_IMPORTED_MODULE_5__.highlightActiveLine)());\r\n  if (options.highlightSelectionMatches !== false) extensions.push((0,_codemirror_search__WEBPACK_IMPORTED_MODULE_2__.highlightSelectionMatches)());\r\n  if (options.tabSize && typeof options.tabSize === 'number') extensions.push(_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.indentUnit.of(' '.repeat(options.tabSize)));\r\n  return extensions.concat([_codemirror_view__WEBPACK_IMPORTED_MODULE_5__.keymap.of(keymaps.flat())]).filter(Boolean);\r\n};\r\n/**\r\nA minimal set of extensions to create a functional editor. Only\r\nincludes [the default keymap](https://codemirror.net/6/docs/ref/#commands.defaultKeymap), [undo\r\nhistory](https://codemirror.net/6/docs/ref/#commands.history), [special character\r\nhighlighting](https://codemirror.net/6/docs/ref/#view.highlightSpecialChars), [custom selection\r\ndrawing](https://codemirror.net/6/docs/ref/#view.drawSelection), and [default highlight\r\nstyle](https://codemirror.net/6/docs/ref/#language.defaultHighlightStyle).\r\n*/\r\nvar minimalSetup = function minimalSetup(options) {\r\n  if (options === void 0) {\r\n    options = {};\r\n  }\r\n  var keymaps = [];\r\n  if (options.defaultKeymap !== false) {\r\n    keymaps = keymaps.concat(_codemirror_commands__WEBPACK_IMPORTED_MODULE_1__.defaultKeymap);\r\n  }\r\n  if (options.historyKeymap !== false) {\r\n    keymaps = keymaps.concat(_codemirror_commands__WEBPACK_IMPORTED_MODULE_1__.historyKeymap);\r\n  }\r\n  var extensions = [];\r\n  if (options.highlightSpecialChars !== false) extensions.push((0,_codemirror_view__WEBPACK_IMPORTED_MODULE_5__.highlightSpecialChars)());\r\n  if (options.history !== false) extensions.push((0,_codemirror_commands__WEBPACK_IMPORTED_MODULE_1__.history)());\r\n  if (options.drawSelection !== false) extensions.push((0,_codemirror_view__WEBPACK_IMPORTED_MODULE_5__.drawSelection)());\r\n  if (options.syntaxHighlighting !== false) extensions.push((0,_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.syntaxHighlighting)(_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.defaultHighlightStyle, {\r\n    fallback: true\r\n  }));\r\n  return extensions.concat([_codemirror_view__WEBPACK_IMPORTED_MODULE_5__.keymap.of(keymaps.flat())]).filter(Boolean);\r\n};\r\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHVpdy9jb2RlbWlycm9yLWV4dGVuc2lvbnMtYmFzaWMtc2V0dXAvZXNtL2luZGV4LmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztBQUFnTTtBQUNoSjtBQUM2QjtBQUNBO0FBQ21DO0FBQ3FDO0FBQ3ZHO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLHlFQUFtQjtBQUNoRDtBQUNBO0FBQ0EsNkJBQTZCLCtEQUFhO0FBQzFDO0FBQ0E7QUFDQSw2QkFBNkIsNERBQVk7QUFDekM7QUFDQTtBQUNBLDZCQUE2QiwrREFBYTtBQUMxQztBQUNBO0FBQ0EsNkJBQTZCLDREQUFVO0FBQ3ZDO0FBQ0E7QUFDQSw2QkFBNkIsc0VBQWdCO0FBQzdDO0FBQ0E7QUFDQSw2QkFBNkIsd0RBQVU7QUFDdkM7QUFDQTtBQUNBLHFEQUFxRCw2REFBVztBQUNoRSxtRUFBbUUsMkVBQXlCO0FBQzVGLCtEQUErRCx1RUFBcUI7QUFDcEYsaURBQWlELDZEQUFPO0FBQ3hELG9EQUFvRCxnRUFBVTtBQUM5RCx1REFBdUQsK0RBQWE7QUFDcEUsb0RBQW9ELDREQUFVO0FBQzlELGlFQUFpRSxxRkFBc0M7QUFDdkcsdURBQXVELG1FQUFhO0FBQ3BFLDREQUE0RCx3RUFBa0IsQ0FBQyx1RUFBcUI7QUFDcEc7QUFDQSxHQUFHO0FBQ0gseURBQXlELHFFQUFlO0FBQ3hFLHVEQUF1RCx1RUFBYTtBQUNwRSx3REFBd0Qsd0VBQWM7QUFDdEUsOERBQThELHNFQUFvQjtBQUNsRix5REFBeUQsaUVBQWU7QUFDeEUsNkRBQTZELHFFQUFtQjtBQUNoRixtRUFBbUUsNkVBQXlCO0FBQzVGLDhFQUE4RSwrREFBYTtBQUMzRiw0QkFBNEIsdURBQVM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLCtEQUFhO0FBQzFDO0FBQ0E7QUFDQSw2QkFBNkIsK0RBQWE7QUFDMUM7QUFDQTtBQUNBLCtEQUErRCx1RUFBcUI7QUFDcEYsaURBQWlELDZEQUFPO0FBQ3hELHVEQUF1RCwrREFBYTtBQUNwRSw0REFBNEQsd0VBQWtCLENBQUMsdUVBQXFCO0FBQ3BHO0FBQ0EsR0FBRztBQUNILDRCQUE0Qix1REFBUztBQUNyQztBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AdWl3L2NvZGVtaXJyb3ItZXh0ZW5zaW9ucy1iYXNpYy1zZXR1cC9lc20vaW5kZXguanM/ODBlMSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBsaW5lTnVtYmVycywgaGlnaGxpZ2h0QWN0aXZlTGluZUd1dHRlciwgaGlnaGxpZ2h0U3BlY2lhbENoYXJzLCBkcmF3U2VsZWN0aW9uLCBkcm9wQ3Vyc29yLCByZWN0YW5ndWxhclNlbGVjdGlvbiwgY3Jvc3NoYWlyQ3Vyc29yLCBoaWdobGlnaHRBY3RpdmVMaW5lLCBrZXltYXAgfSBmcm9tICdAY29kZW1pcnJvci92aWV3JztcclxuaW1wb3J0IHsgRWRpdG9yU3RhdGUgfSBmcm9tICdAY29kZW1pcnJvci9zdGF0ZSc7XHJcbmltcG9ydCB7IGhpc3RvcnksIGRlZmF1bHRLZXltYXAsIGhpc3RvcnlLZXltYXAgfSBmcm9tICdAY29kZW1pcnJvci9jb21tYW5kcyc7XHJcbmltcG9ydCB7IGhpZ2hsaWdodFNlbGVjdGlvbk1hdGNoZXMsIHNlYXJjaEtleW1hcCB9IGZyb20gJ0Bjb2RlbWlycm9yL3NlYXJjaCc7XHJcbmltcG9ydCB7IGNsb3NlQnJhY2tldHMsIGF1dG9jb21wbGV0aW9uLCBjbG9zZUJyYWNrZXRzS2V5bWFwLCBjb21wbGV0aW9uS2V5bWFwIH0gZnJvbSAnQGNvZGVtaXJyb3IvYXV0b2NvbXBsZXRlJztcclxuaW1wb3J0IHsgZm9sZEd1dHRlciwgaW5kZW50T25JbnB1dCwgc3ludGF4SGlnaGxpZ2h0aW5nLCBkZWZhdWx0SGlnaGxpZ2h0U3R5bGUsIGJyYWNrZXRNYXRjaGluZywgaW5kZW50VW5pdCwgZm9sZEtleW1hcCB9IGZyb20gJ0Bjb2RlbWlycm9yL2xhbmd1YWdlJztcclxuaW1wb3J0IHsgbGludEtleW1hcCB9IGZyb20gJ0Bjb2RlbWlycm9yL2xpbnQnO1xyXG4vKipcclxuVGhpcyBpcyBhbiBleHRlbnNpb24gdmFsdWUgdGhhdCBqdXN0IHB1bGxzIHRvZ2V0aGVyIGEgbnVtYmVyIG9mXHJcbmV4dGVuc2lvbnMgdGhhdCB5b3UgbWlnaHQgd2FudCBpbiBhIGJhc2ljIGVkaXRvci4gSXQgaXMgbWVhbnQgYXMgYVxyXG5jb252ZW5pZW50IGhlbHBlciB0byBxdWlja2x5IHNldCB1cCBDb2RlTWlycm9yIHdpdGhvdXQgaW5zdGFsbGluZ1xyXG5hbmQgaW1wb3J0aW5nIGEgbG90IG9mIHNlcGFyYXRlIHBhY2thZ2VzLlxyXG5cclxuU3BlY2lmaWNhbGx5LCBpdCBpbmNsdWRlcy4uLlxyXG5cclxuIC0gW3RoZSBkZWZhdWx0IGNvbW1hbmQgYmluZGluZ3NdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuZGVmYXVsdEtleW1hcClcclxuIC0gW2xpbmUgbnVtYmVyc10oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LmxpbmVOdW1iZXJzKVxyXG4gLSBbc3BlY2lhbCBjaGFyYWN0ZXIgaGlnaGxpZ2h0aW5nXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuaGlnaGxpZ2h0U3BlY2lhbENoYXJzKVxyXG4gLSBbdGhlIHVuZG8gaGlzdG9yeV0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5oaXN0b3J5KVxyXG4gLSBbYSBmb2xkIGd1dHRlcl0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNsYW5ndWFnZS5mb2xkR3V0dGVyKVxyXG4gLSBbY3VzdG9tIHNlbGVjdGlvbiBkcmF3aW5nXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuZHJhd1NlbGVjdGlvbilcclxuIC0gW2Ryb3AgY3Vyc29yXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuZHJvcEN1cnNvcilcclxuIC0gW211bHRpcGxlIHNlbGVjdGlvbnNdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuRWRpdG9yU3RhdGVeYWxsb3dNdWx0aXBsZVNlbGVjdGlvbnMpXHJcbiAtIFtyZWluZGVudGF0aW9uIG9uIGlucHV0XShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2xhbmd1YWdlLmluZGVudE9uSW5wdXQpXHJcbiAtIFt0aGUgZGVmYXVsdCBoaWdobGlnaHQgc3R5bGVdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jbGFuZ3VhZ2UuZGVmYXVsdEhpZ2hsaWdodFN0eWxlKSAoYXMgZmFsbGJhY2spXHJcbiAtIFticmFja2V0IG1hdGNoaW5nXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2xhbmd1YWdlLmJyYWNrZXRNYXRjaGluZylcclxuIC0gW2JyYWNrZXQgY2xvc2luZ10oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNhdXRvY29tcGxldGUuY2xvc2VCcmFja2V0cylcclxuIC0gW2F1dG9jb21wbGV0aW9uXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2F1dG9jb21wbGV0ZS5hdXRvY29tcGxldGlvbilcclxuIC0gW3JlY3Rhbmd1bGFyIHNlbGVjdGlvbl0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LnJlY3Rhbmd1bGFyU2VsZWN0aW9uKSBhbmQgW2Nyb3NzaGFpciBjdXJzb3JdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5jcm9zc2hhaXJDdXJzb3IpXHJcbiAtIFthY3RpdmUgbGluZSBoaWdobGlnaHRpbmddKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5oaWdobGlnaHRBY3RpdmVMaW5lKVxyXG4gLSBbYWN0aXZlIGxpbmUgZ3V0dGVyIGhpZ2hsaWdodGluZ10oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LmhpZ2hsaWdodEFjdGl2ZUxpbmVHdXR0ZXIpXHJcbiAtIFtzZWxlY3Rpb24gbWF0Y2ggaGlnaGxpZ2h0aW5nXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3NlYXJjaC5oaWdobGlnaHRTZWxlY3Rpb25NYXRjaGVzKVxyXG4gLSBbc2VhcmNoXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3NlYXJjaC5zZWFyY2hLZXltYXApXHJcbiAtIFtsaW50aW5nXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2xpbnQubGludEtleW1hcClcclxuXHJcbihZb3UnbGwgcHJvYmFibHkgd2FudCB0byBhZGQgc29tZSBsYW5ndWFnZSBwYWNrYWdlIHRvIHlvdXIgc2V0dXBcclxudG9vLilcclxuXHJcblRoaXMgZXh0ZW5zaW9uIGRvZXMgbm90IGFsbG93IGN1c3RvbWl6YXRpb24uIFRoZSBpZGVhIGlzIHRoYXQsXHJcbm9uY2UgeW91IGRlY2lkZSB5b3Ugd2FudCB0byBjb25maWd1cmUgeW91ciBlZGl0b3IgbW9yZSBwcmVjaXNlbHksXHJcbnlvdSB0YWtlIHRoaXMgcGFja2FnZSdzIHNvdXJjZSAod2hpY2ggaXMganVzdCBhIGJ1bmNoIG9mIGltcG9ydHNcclxuYW5kIGFuIGFycmF5IGxpdGVyYWwpLCBjb3B5IGl0IGludG8geW91ciBvd24gY29kZSwgYW5kIGFkanVzdCBpdFxyXG5hcyBkZXNpcmVkLlxyXG4qL1xyXG5leHBvcnQgdmFyIGJhc2ljU2V0dXAgPSBmdW5jdGlvbiBiYXNpY1NldHVwKG9wdGlvbnMpIHtcclxuICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XHJcbiAgICBvcHRpb25zID0ge307XHJcbiAgfVxyXG4gIHZhciBrZXltYXBzID0gW107XHJcbiAgaWYgKG9wdGlvbnMuY2xvc2VCcmFja2V0c0tleW1hcCAhPT0gZmFsc2UpIHtcclxuICAgIGtleW1hcHMgPSBrZXltYXBzLmNvbmNhdChjbG9zZUJyYWNrZXRzS2V5bWFwKTtcclxuICB9XHJcbiAgaWYgKG9wdGlvbnMuZGVmYXVsdEtleW1hcCAhPT0gZmFsc2UpIHtcclxuICAgIGtleW1hcHMgPSBrZXltYXBzLmNvbmNhdChkZWZhdWx0S2V5bWFwKTtcclxuICB9XHJcbiAgaWYgKG9wdGlvbnMuc2VhcmNoS2V5bWFwICE9PSBmYWxzZSkge1xyXG4gICAga2V5bWFwcyA9IGtleW1hcHMuY29uY2F0KHNlYXJjaEtleW1hcCk7XHJcbiAgfVxyXG4gIGlmIChvcHRpb25zLmhpc3RvcnlLZXltYXAgIT09IGZhbHNlKSB7XHJcbiAgICBrZXltYXBzID0ga2V5bWFwcy5jb25jYXQoaGlzdG9yeUtleW1hcCk7XHJcbiAgfVxyXG4gIGlmIChvcHRpb25zLmZvbGRLZXltYXAgIT09IGZhbHNlKSB7XHJcbiAgICBrZXltYXBzID0ga2V5bWFwcy5jb25jYXQoZm9sZEtleW1hcCk7XHJcbiAgfVxyXG4gIGlmIChvcHRpb25zLmNvbXBsZXRpb25LZXltYXAgIT09IGZhbHNlKSB7XHJcbiAgICBrZXltYXBzID0ga2V5bWFwcy5jb25jYXQoY29tcGxldGlvbktleW1hcCk7XHJcbiAgfVxyXG4gIGlmIChvcHRpb25zLmxpbnRLZXltYXAgIT09IGZhbHNlKSB7XHJcbiAgICBrZXltYXBzID0ga2V5bWFwcy5jb25jYXQobGludEtleW1hcCk7XHJcbiAgfVxyXG4gIHZhciBleHRlbnNpb25zID0gW107XHJcbiAgaWYgKG9wdGlvbnMubGluZU51bWJlcnMgIT09IGZhbHNlKSBleHRlbnNpb25zLnB1c2gobGluZU51bWJlcnMoKSk7XHJcbiAgaWYgKG9wdGlvbnMuaGlnaGxpZ2h0QWN0aXZlTGluZUd1dHRlciAhPT0gZmFsc2UpIGV4dGVuc2lvbnMucHVzaChoaWdobGlnaHRBY3RpdmVMaW5lR3V0dGVyKCkpO1xyXG4gIGlmIChvcHRpb25zLmhpZ2hsaWdodFNwZWNpYWxDaGFycyAhPT0gZmFsc2UpIGV4dGVuc2lvbnMucHVzaChoaWdobGlnaHRTcGVjaWFsQ2hhcnMoKSk7XHJcbiAgaWYgKG9wdGlvbnMuaGlzdG9yeSAhPT0gZmFsc2UpIGV4dGVuc2lvbnMucHVzaChoaXN0b3J5KCkpO1xyXG4gIGlmIChvcHRpb25zLmZvbGRHdXR0ZXIgIT09IGZhbHNlKSBleHRlbnNpb25zLnB1c2goZm9sZEd1dHRlcigpKTtcclxuICBpZiAob3B0aW9ucy5kcmF3U2VsZWN0aW9uICE9PSBmYWxzZSkgZXh0ZW5zaW9ucy5wdXNoKGRyYXdTZWxlY3Rpb24oKSk7XHJcbiAgaWYgKG9wdGlvbnMuZHJvcEN1cnNvciAhPT0gZmFsc2UpIGV4dGVuc2lvbnMucHVzaChkcm9wQ3Vyc29yKCkpO1xyXG4gIGlmIChvcHRpb25zLmFsbG93TXVsdGlwbGVTZWxlY3Rpb25zICE9PSBmYWxzZSkgZXh0ZW5zaW9ucy5wdXNoKEVkaXRvclN0YXRlLmFsbG93TXVsdGlwbGVTZWxlY3Rpb25zLm9mKHRydWUpKTtcclxuICBpZiAob3B0aW9ucy5pbmRlbnRPbklucHV0ICE9PSBmYWxzZSkgZXh0ZW5zaW9ucy5wdXNoKGluZGVudE9uSW5wdXQoKSk7XHJcbiAgaWYgKG9wdGlvbnMuc3ludGF4SGlnaGxpZ2h0aW5nICE9PSBmYWxzZSkgZXh0ZW5zaW9ucy5wdXNoKHN5bnRheEhpZ2hsaWdodGluZyhkZWZhdWx0SGlnaGxpZ2h0U3R5bGUsIHtcclxuICAgIGZhbGxiYWNrOiB0cnVlXHJcbiAgfSkpO1xyXG4gIGlmIChvcHRpb25zLmJyYWNrZXRNYXRjaGluZyAhPT0gZmFsc2UpIGV4dGVuc2lvbnMucHVzaChicmFja2V0TWF0Y2hpbmcoKSk7XHJcbiAgaWYgKG9wdGlvbnMuY2xvc2VCcmFja2V0cyAhPT0gZmFsc2UpIGV4dGVuc2lvbnMucHVzaChjbG9zZUJyYWNrZXRzKCkpO1xyXG4gIGlmIChvcHRpb25zLmF1dG9jb21wbGV0aW9uICE9PSBmYWxzZSkgZXh0ZW5zaW9ucy5wdXNoKGF1dG9jb21wbGV0aW9uKCkpO1xyXG4gIGlmIChvcHRpb25zLnJlY3Rhbmd1bGFyU2VsZWN0aW9uICE9PSBmYWxzZSkgZXh0ZW5zaW9ucy5wdXNoKHJlY3Rhbmd1bGFyU2VsZWN0aW9uKCkpO1xyXG4gIGlmIChvcHRpb25zLmNyb3NzaGFpckN1cnNvciAhPT0gZmFsc2UpIGV4dGVuc2lvbnMucHVzaChjcm9zc2hhaXJDdXJzb3IoKSk7XHJcbiAgaWYgKG9wdGlvbnMuaGlnaGxpZ2h0QWN0aXZlTGluZSAhPT0gZmFsc2UpIGV4dGVuc2lvbnMucHVzaChoaWdobGlnaHRBY3RpdmVMaW5lKCkpO1xyXG4gIGlmIChvcHRpb25zLmhpZ2hsaWdodFNlbGVjdGlvbk1hdGNoZXMgIT09IGZhbHNlKSBleHRlbnNpb25zLnB1c2goaGlnaGxpZ2h0U2VsZWN0aW9uTWF0Y2hlcygpKTtcclxuICBpZiAob3B0aW9ucy50YWJTaXplICYmIHR5cGVvZiBvcHRpb25zLnRhYlNpemUgPT09ICdudW1iZXInKSBleHRlbnNpb25zLnB1c2goaW5kZW50VW5pdC5vZignICcucmVwZWF0KG9wdGlvbnMudGFiU2l6ZSkpKTtcclxuICByZXR1cm4gZXh0ZW5zaW9ucy5jb25jYXQoW2tleW1hcC5vZihrZXltYXBzLmZsYXQoKSldKS5maWx0ZXIoQm9vbGVhbik7XHJcbn07XHJcbi8qKlxyXG5BIG1pbmltYWwgc2V0IG9mIGV4dGVuc2lvbnMgdG8gY3JlYXRlIGEgZnVuY3Rpb25hbCBlZGl0b3IuIE9ubHlcclxuaW5jbHVkZXMgW3RoZSBkZWZhdWx0IGtleW1hcF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5kZWZhdWx0S2V5bWFwKSwgW3VuZG9cclxuaGlzdG9yeV0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5oaXN0b3J5KSwgW3NwZWNpYWwgY2hhcmFjdGVyXHJcbmhpZ2hsaWdodGluZ10oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LmhpZ2hsaWdodFNwZWNpYWxDaGFycyksIFtjdXN0b20gc2VsZWN0aW9uXHJcbmRyYXdpbmddKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5kcmF3U2VsZWN0aW9uKSwgYW5kIFtkZWZhdWx0IGhpZ2hsaWdodFxyXG5zdHlsZV0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNsYW5ndWFnZS5kZWZhdWx0SGlnaGxpZ2h0U3R5bGUpLlxyXG4qL1xyXG5leHBvcnQgdmFyIG1pbmltYWxTZXR1cCA9IGZ1bmN0aW9uIG1pbmltYWxTZXR1cChvcHRpb25zKSB7XHJcbiAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xyXG4gICAgb3B0aW9ucyA9IHt9O1xyXG4gIH1cclxuICB2YXIga2V5bWFwcyA9IFtdO1xyXG4gIGlmIChvcHRpb25zLmRlZmF1bHRLZXltYXAgIT09IGZhbHNlKSB7XHJcbiAgICBrZXltYXBzID0ga2V5bWFwcy5jb25jYXQoZGVmYXVsdEtleW1hcCk7XHJcbiAgfVxyXG4gIGlmIChvcHRpb25zLmhpc3RvcnlLZXltYXAgIT09IGZhbHNlKSB7XHJcbiAgICBrZXltYXBzID0ga2V5bWFwcy5jb25jYXQoaGlzdG9yeUtleW1hcCk7XHJcbiAgfVxyXG4gIHZhciBleHRlbnNpb25zID0gW107XHJcbiAgaWYgKG9wdGlvbnMuaGlnaGxpZ2h0U3BlY2lhbENoYXJzICE9PSBmYWxzZSkgZXh0ZW5zaW9ucy5wdXNoKGhpZ2hsaWdodFNwZWNpYWxDaGFycygpKTtcclxuICBpZiAob3B0aW9ucy5oaXN0b3J5ICE9PSBmYWxzZSkgZXh0ZW5zaW9ucy5wdXNoKGhpc3RvcnkoKSk7XHJcbiAgaWYgKG9wdGlvbnMuZHJhd1NlbGVjdGlvbiAhPT0gZmFsc2UpIGV4dGVuc2lvbnMucHVzaChkcmF3U2VsZWN0aW9uKCkpO1xyXG4gIGlmIChvcHRpb25zLnN5bnRheEhpZ2hsaWdodGluZyAhPT0gZmFsc2UpIGV4dGVuc2lvbnMucHVzaChzeW50YXhIaWdobGlnaHRpbmcoZGVmYXVsdEhpZ2hsaWdodFN0eWxlLCB7XHJcbiAgICBmYWxsYmFjazogdHJ1ZVxyXG4gIH0pKTtcclxuICByZXR1cm4gZXh0ZW5zaW9ucy5jb25jYXQoW2tleW1hcC5vZihrZXltYXBzLmZsYXQoKSldKS5maWx0ZXIoQm9vbGVhbik7XHJcbn07XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@uiw/codemirror-extensions-basic-setup/esm/index.js\n"));

/***/ }),

/***/ "./node_modules/@uiw/react-codemirror/esm/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/@uiw/react-codemirror/esm/index.js ***!
  \*********************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _babel_runtime_helpers_extends__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/extends */ \"./node_modules/@babel/runtime/helpers/esm/extends.js\");\n/* harmony import */ var _babel_runtime_helpers_objectWithoutPropertiesLoose__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/objectWithoutPropertiesLoose */ \"./node_modules/@babel/runtime/helpers/esm/objectWithoutPropertiesLoose.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _useCodeMirror__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./useCodeMirror */ \"./node_modules/@uiw/react-codemirror/esm/useCodeMirror.js\");\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! react/jsx-runtime */ \"./node_modules/react/jsx-runtime.js\");\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var _uiw_codemirror_extensions_basic_setup__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @uiw/codemirror-extensions-basic-setup */ \"./node_modules/@uiw/codemirror-extensions-basic-setup/esm/index.js\");\n/* harmony reexport (unknown) */ var __WEBPACK_REEXPORT_OBJECT__ = {};\n/* harmony reexport (unknown) */ for(var __WEBPACK_IMPORT_KEY__ in _uiw_codemirror_extensions_basic_setup__WEBPACK_IMPORTED_MODULE_5__) if(__WEBPACK_IMPORT_KEY__ !== \"default\") __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = function(key) { return _uiw_codemirror_extensions_basic_setup__WEBPACK_IMPORTED_MODULE_5__[key]; }.bind(0, __WEBPACK_IMPORT_KEY__)\n/* harmony reexport (unknown) */ __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);\n/* harmony reexport (unknown) */ var __WEBPACK_REEXPORT_OBJECT__ = {};\n/* harmony reexport (unknown) */ for(var __WEBPACK_IMPORT_KEY__ in _useCodeMirror__WEBPACK_IMPORTED_MODULE_3__) if(__WEBPACK_IMPORT_KEY__ !== \"default\") __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = function(key) { return _useCodeMirror__WEBPACK_IMPORTED_MODULE_3__[key]; }.bind(0, __WEBPACK_IMPORT_KEY__)\n/* harmony reexport (unknown) */ __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./utils */ \"./node_modules/@uiw/react-codemirror/esm/utils.js\");\n/* harmony reexport (unknown) */ var __WEBPACK_REEXPORT_OBJECT__ = {};\n/* harmony reexport (unknown) */ for(var __WEBPACK_IMPORT_KEY__ in _utils__WEBPACK_IMPORTED_MODULE_6__) if(__WEBPACK_IMPORT_KEY__ !== \"default\") __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = function(key) { return _utils__WEBPACK_IMPORTED_MODULE_6__[key]; }.bind(0, __WEBPACK_IMPORT_KEY__)\n/* harmony reexport (unknown) */ __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);\n\r\n\r\nvar _excluded = [\"className\", \"value\", \"selection\", \"extensions\", \"onChange\", \"onStatistics\", \"onCreateEditor\", \"onUpdate\", \"autoFocus\", \"theme\", \"height\", \"minHeight\", \"maxHeight\", \"width\", \"minWidth\", \"maxWidth\", \"basicSetup\", \"placeholder\", \"indentWithTab\", \"editable\", \"readOnly\", \"root\", \"initialState\"];\r\n\r\n\r\n\r\n\r\n\r\n\r\nvar ReactCodeMirror = /*#__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_2__.forwardRef)((props, ref) => {\r\n  var {\r\n      className,\r\n      value = '',\r\n      selection,\r\n      extensions = [],\r\n      onChange,\r\n      onStatistics,\r\n      onCreateEditor,\r\n      onUpdate,\r\n      autoFocus,\r\n      theme = 'light',\r\n      height,\r\n      minHeight,\r\n      maxHeight,\r\n      width,\r\n      minWidth,\r\n      maxWidth,\r\n      basicSetup,\r\n      placeholder,\r\n      indentWithTab,\r\n      editable,\r\n      readOnly,\r\n      root,\r\n      initialState\r\n    } = props,\r\n    other = (0,_babel_runtime_helpers_objectWithoutPropertiesLoose__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(props, _excluded);\r\n  var editor = (0,react__WEBPACK_IMPORTED_MODULE_2__.useRef)(null);\r\n  var {\r\n    state,\r\n    view,\r\n    container,\r\n    setContainer\r\n  } = (0,_useCodeMirror__WEBPACK_IMPORTED_MODULE_3__.useCodeMirror)({\r\n    container: editor.current,\r\n    root,\r\n    value,\r\n    autoFocus,\r\n    theme,\r\n    height,\r\n    minHeight,\r\n    maxHeight,\r\n    width,\r\n    minWidth,\r\n    maxWidth,\r\n    basicSetup,\r\n    placeholder,\r\n    indentWithTab,\r\n    editable,\r\n    readOnly,\r\n    selection,\r\n    onChange,\r\n    onStatistics,\r\n    onCreateEditor,\r\n    onUpdate,\r\n    extensions,\r\n    initialState\r\n  });\r\n  (0,react__WEBPACK_IMPORTED_MODULE_2__.useImperativeHandle)(ref, () => ({\r\n    editor: editor.current,\r\n    state: state,\r\n    view: view\r\n  }), [editor, container, state, view]);\r\n\r\n  // check type of value\r\n  if (typeof value !== 'string') {\r\n    throw new Error(\"value must be typeof string but got \" + typeof value);\r\n  }\r\n  var defaultClassNames = typeof theme === 'string' ? \"cm-theme-\" + theme : 'cm-theme';\r\n  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(\"div\", (0,_babel_runtime_helpers_extends__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({\r\n    ref: editor,\r\n    className: \"\" + defaultClassNames + (className ? \" \" + className : '')\r\n  }, other));\r\n});\r\nReactCodeMirror.displayName = 'CodeMirror';\r\n/* harmony default export */ __webpack_exports__[\"default\"] = (ReactCodeMirror);\r\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHVpdy9yZWFjdC1jb2RlbWlycm9yL2VzbS9pbmRleC5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQXNEO0FBQzBDO0FBQ2hHO0FBQ3VFO0FBQ3ZCO0FBQ0E7QUFDTztBQUN2QjtBQUNSO0FBQ3hCLG1DQUFtQyxpREFBVTtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sWUFBWSwrRkFBNkI7QUFDekMsZUFBZSw2Q0FBTTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxFQUFFLDZEQUFhO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRSwwREFBbUI7QUFDckI7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixzREFBSSxRQUFRLDBFQUFRO0FBQzFDO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQztBQUNEO0FBQ0EsK0RBQWUsZUFBZSxFQUFDO0FBQy9CIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AdWl3L3JlYWN0LWNvZGVtaXJyb3IvZXNtL2luZGV4LmpzPzZiNjAiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IF9leHRlbmRzIGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2V4dGVuZHNcIjtcclxuaW1wb3J0IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlIGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2VcIjtcclxudmFyIF9leGNsdWRlZCA9IFtcImNsYXNzTmFtZVwiLCBcInZhbHVlXCIsIFwic2VsZWN0aW9uXCIsIFwiZXh0ZW5zaW9uc1wiLCBcIm9uQ2hhbmdlXCIsIFwib25TdGF0aXN0aWNzXCIsIFwib25DcmVhdGVFZGl0b3JcIiwgXCJvblVwZGF0ZVwiLCBcImF1dG9Gb2N1c1wiLCBcInRoZW1lXCIsIFwiaGVpZ2h0XCIsIFwibWluSGVpZ2h0XCIsIFwibWF4SGVpZ2h0XCIsIFwid2lkdGhcIiwgXCJtaW5XaWR0aFwiLCBcIm1heFdpZHRoXCIsIFwiYmFzaWNTZXR1cFwiLCBcInBsYWNlaG9sZGVyXCIsIFwiaW5kZW50V2l0aFRhYlwiLCBcImVkaXRhYmxlXCIsIFwicmVhZE9ubHlcIiwgXCJyb290XCIsIFwiaW5pdGlhbFN0YXRlXCJdO1xyXG5pbXBvcnQgUmVhY3QsIHsgdXNlUmVmLCBmb3J3YXJkUmVmLCB1c2VJbXBlcmF0aXZlSGFuZGxlIH0gZnJvbSAncmVhY3QnO1xyXG5pbXBvcnQgeyB1c2VDb2RlTWlycm9yIH0gZnJvbSAnLi91c2VDb2RlTWlycm9yJztcclxuaW1wb3J0IHsganN4IGFzIF9qc3ggfSBmcm9tIFwicmVhY3QvanN4LXJ1bnRpbWVcIjtcclxuZXhwb3J0ICogZnJvbSAnQHVpdy9jb2RlbWlycm9yLWV4dGVuc2lvbnMtYmFzaWMtc2V0dXAnO1xyXG5leHBvcnQgKiBmcm9tICcuL3VzZUNvZGVNaXJyb3InO1xyXG5leHBvcnQgKiBmcm9tICcuL3V0aWxzJztcclxudmFyIFJlYWN0Q29kZU1pcnJvciA9IC8qI19fUFVSRV9fKi9mb3J3YXJkUmVmKChwcm9wcywgcmVmKSA9PiB7XHJcbiAgdmFyIHtcclxuICAgICAgY2xhc3NOYW1lLFxyXG4gICAgICB2YWx1ZSA9ICcnLFxyXG4gICAgICBzZWxlY3Rpb24sXHJcbiAgICAgIGV4dGVuc2lvbnMgPSBbXSxcclxuICAgICAgb25DaGFuZ2UsXHJcbiAgICAgIG9uU3RhdGlzdGljcyxcclxuICAgICAgb25DcmVhdGVFZGl0b3IsXHJcbiAgICAgIG9uVXBkYXRlLFxyXG4gICAgICBhdXRvRm9jdXMsXHJcbiAgICAgIHRoZW1lID0gJ2xpZ2h0JyxcclxuICAgICAgaGVpZ2h0LFxyXG4gICAgICBtaW5IZWlnaHQsXHJcbiAgICAgIG1heEhlaWdodCxcclxuICAgICAgd2lkdGgsXHJcbiAgICAgIG1pbldpZHRoLFxyXG4gICAgICBtYXhXaWR0aCxcclxuICAgICAgYmFzaWNTZXR1cCxcclxuICAgICAgcGxhY2Vob2xkZXIsXHJcbiAgICAgIGluZGVudFdpdGhUYWIsXHJcbiAgICAgIGVkaXRhYmxlLFxyXG4gICAgICByZWFkT25seSxcclxuICAgICAgcm9vdCxcclxuICAgICAgaW5pdGlhbFN0YXRlXHJcbiAgICB9ID0gcHJvcHMsXHJcbiAgICBvdGhlciA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHByb3BzLCBfZXhjbHVkZWQpO1xyXG4gIHZhciBlZGl0b3IgPSB1c2VSZWYobnVsbCk7XHJcbiAgdmFyIHtcclxuICAgIHN0YXRlLFxyXG4gICAgdmlldyxcclxuICAgIGNvbnRhaW5lcixcclxuICAgIHNldENvbnRhaW5lclxyXG4gIH0gPSB1c2VDb2RlTWlycm9yKHtcclxuICAgIGNvbnRhaW5lcjogZWRpdG9yLmN1cnJlbnQsXHJcbiAgICByb290LFxyXG4gICAgdmFsdWUsXHJcbiAgICBhdXRvRm9jdXMsXHJcbiAgICB0aGVtZSxcclxuICAgIGhlaWdodCxcclxuICAgIG1pbkhlaWdodCxcclxuICAgIG1heEhlaWdodCxcclxuICAgIHdpZHRoLFxyXG4gICAgbWluV2lkdGgsXHJcbiAgICBtYXhXaWR0aCxcclxuICAgIGJhc2ljU2V0dXAsXHJcbiAgICBwbGFjZWhvbGRlcixcclxuICAgIGluZGVudFdpdGhUYWIsXHJcbiAgICBlZGl0YWJsZSxcclxuICAgIHJlYWRPbmx5LFxyXG4gICAgc2VsZWN0aW9uLFxyXG4gICAgb25DaGFuZ2UsXHJcbiAgICBvblN0YXRpc3RpY3MsXHJcbiAgICBvbkNyZWF0ZUVkaXRvcixcclxuICAgIG9uVXBkYXRlLFxyXG4gICAgZXh0ZW5zaW9ucyxcclxuICAgIGluaXRpYWxTdGF0ZVxyXG4gIH0pO1xyXG4gIHVzZUltcGVyYXRpdmVIYW5kbGUocmVmLCAoKSA9PiAoe1xyXG4gICAgZWRpdG9yOiBlZGl0b3IuY3VycmVudCxcclxuICAgIHN0YXRlOiBzdGF0ZSxcclxuICAgIHZpZXc6IHZpZXdcclxuICB9KSwgW2VkaXRvciwgY29udGFpbmVyLCBzdGF0ZSwgdmlld10pO1xyXG5cclxuICAvLyBjaGVjayB0eXBlIG9mIHZhbHVlXHJcbiAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycpIHtcclxuICAgIHRocm93IG5ldyBFcnJvcihcInZhbHVlIG11c3QgYmUgdHlwZW9mIHN0cmluZyBidXQgZ290IFwiICsgdHlwZW9mIHZhbHVlKTtcclxuICB9XHJcbiAgdmFyIGRlZmF1bHRDbGFzc05hbWVzID0gdHlwZW9mIHRoZW1lID09PSAnc3RyaW5nJyA/IFwiY20tdGhlbWUtXCIgKyB0aGVtZSA6ICdjbS10aGVtZSc7XHJcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9fanN4KFwiZGl2XCIsIF9leHRlbmRzKHtcclxuICAgIHJlZjogZWRpdG9yLFxyXG4gICAgY2xhc3NOYW1lOiBcIlwiICsgZGVmYXVsdENsYXNzTmFtZXMgKyAoY2xhc3NOYW1lID8gXCIgXCIgKyBjbGFzc05hbWUgOiAnJylcclxuICB9LCBvdGhlcikpO1xyXG59KTtcclxuUmVhY3RDb2RlTWlycm9yLmRpc3BsYXlOYW1lID0gJ0NvZGVNaXJyb3InO1xyXG5leHBvcnQgZGVmYXVsdCBSZWFjdENvZGVNaXJyb3I7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@uiw/react-codemirror/esm/index.js\n"));

/***/ }),

/***/ "./node_modules/@uiw/react-codemirror/esm/useCodeMirror.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@uiw/react-codemirror/esm/useCodeMirror.js ***!
  \*****************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"useCodeMirror\": function() { return /* binding */ useCodeMirror; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _codemirror_state__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @codemirror/state */ \"./node_modules/@codemirror/state/dist/index.js\");\n/* harmony import */ var _codemirror_commands__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @codemirror/commands */ \"./node_modules/@codemirror/commands/dist/index.js\");\n/* harmony import */ var _codemirror_view__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @codemirror/view */ \"./node_modules/@codemirror/view/dist/index.js\");\n/* harmony import */ var _uiw_codemirror_extensions_basic_setup__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @uiw/codemirror-extensions-basic-setup */ \"./node_modules/@uiw/codemirror-extensions-basic-setup/esm/index.js\");\n/* harmony import */ var _codemirror_theme_one_dark__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @codemirror/theme-one-dark */ \"./node_modules/@codemirror/theme-one-dark/dist/index.js\");\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils */ \"./node_modules/@uiw/react-codemirror/esm/utils.js\");\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nfunction useCodeMirror(props) {\r\n  var {\r\n    value,\r\n    selection,\r\n    onChange,\r\n    onStatistics,\r\n    onCreateEditor,\r\n    onUpdate,\r\n    extensions = [],\r\n    autoFocus,\r\n    theme = 'light',\r\n    height = '',\r\n    minHeight = '',\r\n    maxHeight = '',\r\n    placeholder: placeholderStr = '',\r\n    width = '',\r\n    minWidth = '',\r\n    maxWidth = '',\r\n    editable = true,\r\n    readOnly = false,\r\n    indentWithTab: defaultIndentWithTab = true,\r\n    basicSetup: defaultBasicSetup = true,\r\n    root,\r\n    initialState\r\n  } = props;\r\n  var [container, setContainer] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)();\r\n  var [view, setView] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)();\r\n  var [state, setState] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)();\r\n  var defaultLightThemeOption = _codemirror_view__WEBPACK_IMPORTED_MODULE_3__.EditorView.theme({\r\n    '&': {\r\n      backgroundColor: '#fff'\r\n    }\r\n  }, {\r\n    dark: false\r\n  });\r\n  var defaultThemeOption = _codemirror_view__WEBPACK_IMPORTED_MODULE_3__.EditorView.theme({\r\n    '&': {\r\n      height,\r\n      minHeight,\r\n      maxHeight,\r\n      width,\r\n      minWidth,\r\n      maxWidth\r\n    }\r\n  });\r\n  var updateListener = _codemirror_view__WEBPACK_IMPORTED_MODULE_3__.EditorView.updateListener.of(vu => {\r\n    if (vu.docChanged && typeof onChange === 'function') {\r\n      var doc = vu.state.doc;\r\n      var _value = doc.toString();\r\n      onChange(_value, vu);\r\n    }\r\n    onStatistics && onStatistics((0,_utils__WEBPACK_IMPORTED_MODULE_2__.getStatistics)(vu));\r\n  });\r\n  var getExtensions = [updateListener, defaultThemeOption];\r\n  if (defaultIndentWithTab) {\r\n    getExtensions.unshift(_codemirror_view__WEBPACK_IMPORTED_MODULE_3__.keymap.of([_codemirror_commands__WEBPACK_IMPORTED_MODULE_4__.indentWithTab]));\r\n  }\r\n  if (defaultBasicSetup) {\r\n    if (typeof defaultBasicSetup === 'boolean') {\r\n      getExtensions.unshift((0,_uiw_codemirror_extensions_basic_setup__WEBPACK_IMPORTED_MODULE_1__.basicSetup)());\r\n    } else {\r\n      getExtensions.unshift((0,_uiw_codemirror_extensions_basic_setup__WEBPACK_IMPORTED_MODULE_1__.basicSetup)(defaultBasicSetup));\r\n    }\r\n  }\r\n  if (placeholderStr) {\r\n    getExtensions.unshift((0,_codemirror_view__WEBPACK_IMPORTED_MODULE_3__.placeholder)(placeholderStr));\r\n  }\r\n  switch (theme) {\r\n    case 'light':\r\n      getExtensions.push(defaultLightThemeOption);\r\n      break;\r\n    case 'dark':\r\n      getExtensions.push(_codemirror_theme_one_dark__WEBPACK_IMPORTED_MODULE_5__.oneDark);\r\n      break;\r\n    case 'none':\r\n      break;\r\n    default:\r\n      getExtensions.push(theme);\r\n      break;\r\n  }\r\n  if (editable === false) {\r\n    getExtensions.push(_codemirror_view__WEBPACK_IMPORTED_MODULE_3__.EditorView.editable.of(false));\r\n  }\r\n  if (readOnly) {\r\n    getExtensions.push(_codemirror_state__WEBPACK_IMPORTED_MODULE_6__.EditorState.readOnly.of(true));\r\n  }\r\n  if (onUpdate && typeof onUpdate === 'function') {\r\n    getExtensions.push(_codemirror_view__WEBPACK_IMPORTED_MODULE_3__.EditorView.updateListener.of(onUpdate));\r\n  }\r\n  getExtensions = getExtensions.concat(extensions);\r\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\r\n    if (container && !state) {\r\n      var config = {\r\n        doc: value,\r\n        selection,\r\n        extensions: getExtensions\r\n      };\r\n      var stateCurrent = initialState ? _codemirror_state__WEBPACK_IMPORTED_MODULE_6__.EditorState.fromJSON(initialState.json, config, initialState.fields) : _codemirror_state__WEBPACK_IMPORTED_MODULE_6__.EditorState.create(config);\r\n      setState(stateCurrent);\r\n      if (!view) {\r\n        var viewCurrent = new _codemirror_view__WEBPACK_IMPORTED_MODULE_3__.EditorView({\r\n          state: stateCurrent,\r\n          parent: container,\r\n          root\r\n        });\r\n        setView(viewCurrent);\r\n        onCreateEditor && onCreateEditor(viewCurrent, stateCurrent);\r\n      }\r\n    }\r\n    return () => {\r\n      if (view) {\r\n        setState(undefined);\r\n        setView(undefined);\r\n      }\r\n    };\r\n  }, [container, state]);\r\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => setContainer(props.container), [props.container]);\r\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => () => {\r\n    if (view) {\r\n      view.destroy();\r\n      setView(undefined);\r\n    }\r\n  }, [view]);\r\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\r\n    if (autoFocus && view) {\r\n      view.focus();\r\n    }\r\n  }, [autoFocus, view]);\r\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\r\n    if (view) {\r\n      view.dispatch({\r\n        effects: _codemirror_state__WEBPACK_IMPORTED_MODULE_6__.StateEffect.reconfigure.of(getExtensions)\r\n      });\r\n    }\r\n    // eslint-disable-next-line react-hooks/exhaustive-deps\r\n  }, [theme, extensions, height, minHeight, maxHeight, width, minWidth, maxWidth, placeholderStr, editable, readOnly, defaultIndentWithTab, defaultBasicSetup, onChange, onUpdate]);\r\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\r\n    if (value === undefined) {\r\n      return;\r\n    }\r\n    var currentValue = view ? view.state.doc.toString() : '';\r\n    if (view && value !== currentValue) {\r\n      view.dispatch({\r\n        changes: {\r\n          from: 0,\r\n          to: currentValue.length,\r\n          insert: value || ''\r\n        }\r\n      });\r\n    }\r\n  }, [value, view]);\r\n  return {\r\n    state,\r\n    setState,\r\n    view,\r\n    setView,\r\n    container,\r\n    setContainer\r\n  };\r\n}\r\n//# sourceMappingURL=useCodeMirror.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHVpdy9yZWFjdC1jb2RlbWlycm9yL2VzbS91c2VDb2RlTWlycm9yLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztBQUE0QztBQUNpQjtBQUNSO0FBQ2M7QUFDQztBQUNmO0FBQ2I7QUFDakM7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLGtDQUFrQywrQ0FBUTtBQUMxQyx3QkFBd0IsK0NBQVE7QUFDaEMsMEJBQTBCLCtDQUFRO0FBQ2xDLGdDQUFnQyw4REFBZ0I7QUFDaEQ7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNILDJCQUEyQiw4REFBZ0I7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCx1QkFBdUIsMEVBQTRCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMscURBQWE7QUFDOUMsR0FBRztBQUNIO0FBQ0E7QUFDQSwwQkFBMEIsdURBQVMsRUFBRSwrREFBYTtBQUNsRDtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsa0ZBQVU7QUFDdEMsTUFBTTtBQUNOLDRCQUE0QixrRkFBVTtBQUN0QztBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsNkRBQVc7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLCtEQUFPO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsb0VBQXNCO0FBQzdDO0FBQ0E7QUFDQSx1QkFBdUIsc0VBQXVCO0FBQzlDO0FBQ0E7QUFDQSx1QkFBdUIsMEVBQTRCO0FBQ25EO0FBQ0E7QUFDQSxFQUFFLGdEQUFTO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLG1FQUFvQixtREFBbUQsaUVBQWtCO0FBQ2pJO0FBQ0E7QUFDQSw4QkFBOEIsd0RBQVU7QUFDeEM7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUUsZ0RBQVM7QUFDWCxFQUFFLGdEQUFTO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRSxnREFBUztBQUNYO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFLGdEQUFTO0FBQ1g7QUFDQTtBQUNBLGlCQUFpQix5RUFBMEI7QUFDM0MsT0FBTztBQUNQO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRSxnREFBUztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0B1aXcvcmVhY3QtY29kZW1pcnJvci9lc20vdXNlQ29kZU1pcnJvci5qcz80NzY1Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHVzZUVmZmVjdCwgdXNlU3RhdGUgfSBmcm9tICdyZWFjdCc7XHJcbmltcG9ydCB7IEVkaXRvclN0YXRlLCBTdGF0ZUVmZmVjdCB9IGZyb20gJ0Bjb2RlbWlycm9yL3N0YXRlJztcclxuaW1wb3J0IHsgaW5kZW50V2l0aFRhYiB9IGZyb20gJ0Bjb2RlbWlycm9yL2NvbW1hbmRzJztcclxuaW1wb3J0IHsgRWRpdG9yVmlldywga2V5bWFwLCBwbGFjZWhvbGRlciB9IGZyb20gJ0Bjb2RlbWlycm9yL3ZpZXcnO1xyXG5pbXBvcnQgeyBiYXNpY1NldHVwIH0gZnJvbSAnQHVpdy9jb2RlbWlycm9yLWV4dGVuc2lvbnMtYmFzaWMtc2V0dXAnO1xyXG5pbXBvcnQgeyBvbmVEYXJrIH0gZnJvbSAnQGNvZGVtaXJyb3IvdGhlbWUtb25lLWRhcmsnO1xyXG5pbXBvcnQgeyBnZXRTdGF0aXN0aWNzIH0gZnJvbSAnLi91dGlscyc7XHJcbmV4cG9ydCBmdW5jdGlvbiB1c2VDb2RlTWlycm9yKHByb3BzKSB7XHJcbiAgdmFyIHtcclxuICAgIHZhbHVlLFxyXG4gICAgc2VsZWN0aW9uLFxyXG4gICAgb25DaGFuZ2UsXHJcbiAgICBvblN0YXRpc3RpY3MsXHJcbiAgICBvbkNyZWF0ZUVkaXRvcixcclxuICAgIG9uVXBkYXRlLFxyXG4gICAgZXh0ZW5zaW9ucyA9IFtdLFxyXG4gICAgYXV0b0ZvY3VzLFxyXG4gICAgdGhlbWUgPSAnbGlnaHQnLFxyXG4gICAgaGVpZ2h0ID0gJycsXHJcbiAgICBtaW5IZWlnaHQgPSAnJyxcclxuICAgIG1heEhlaWdodCA9ICcnLFxyXG4gICAgcGxhY2Vob2xkZXI6IHBsYWNlaG9sZGVyU3RyID0gJycsXHJcbiAgICB3aWR0aCA9ICcnLFxyXG4gICAgbWluV2lkdGggPSAnJyxcclxuICAgIG1heFdpZHRoID0gJycsXHJcbiAgICBlZGl0YWJsZSA9IHRydWUsXHJcbiAgICByZWFkT25seSA9IGZhbHNlLFxyXG4gICAgaW5kZW50V2l0aFRhYjogZGVmYXVsdEluZGVudFdpdGhUYWIgPSB0cnVlLFxyXG4gICAgYmFzaWNTZXR1cDogZGVmYXVsdEJhc2ljU2V0dXAgPSB0cnVlLFxyXG4gICAgcm9vdCxcclxuICAgIGluaXRpYWxTdGF0ZVxyXG4gIH0gPSBwcm9wcztcclxuICB2YXIgW2NvbnRhaW5lciwgc2V0Q29udGFpbmVyXSA9IHVzZVN0YXRlKCk7XHJcbiAgdmFyIFt2aWV3LCBzZXRWaWV3XSA9IHVzZVN0YXRlKCk7XHJcbiAgdmFyIFtzdGF0ZSwgc2V0U3RhdGVdID0gdXNlU3RhdGUoKTtcclxuICB2YXIgZGVmYXVsdExpZ2h0VGhlbWVPcHRpb24gPSBFZGl0b3JWaWV3LnRoZW1lKHtcclxuICAgICcmJzoge1xyXG4gICAgICBiYWNrZ3JvdW5kQ29sb3I6ICcjZmZmJ1xyXG4gICAgfVxyXG4gIH0sIHtcclxuICAgIGRhcms6IGZhbHNlXHJcbiAgfSk7XHJcbiAgdmFyIGRlZmF1bHRUaGVtZU9wdGlvbiA9IEVkaXRvclZpZXcudGhlbWUoe1xyXG4gICAgJyYnOiB7XHJcbiAgICAgIGhlaWdodCxcclxuICAgICAgbWluSGVpZ2h0LFxyXG4gICAgICBtYXhIZWlnaHQsXHJcbiAgICAgIHdpZHRoLFxyXG4gICAgICBtaW5XaWR0aCxcclxuICAgICAgbWF4V2lkdGhcclxuICAgIH1cclxuICB9KTtcclxuICB2YXIgdXBkYXRlTGlzdGVuZXIgPSBFZGl0b3JWaWV3LnVwZGF0ZUxpc3RlbmVyLm9mKHZ1ID0+IHtcclxuICAgIGlmICh2dS5kb2NDaGFuZ2VkICYmIHR5cGVvZiBvbkNoYW5nZSA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICB2YXIgZG9jID0gdnUuc3RhdGUuZG9jO1xyXG4gICAgICB2YXIgX3ZhbHVlID0gZG9jLnRvU3RyaW5nKCk7XHJcbiAgICAgIG9uQ2hhbmdlKF92YWx1ZSwgdnUpO1xyXG4gICAgfVxyXG4gICAgb25TdGF0aXN0aWNzICYmIG9uU3RhdGlzdGljcyhnZXRTdGF0aXN0aWNzKHZ1KSk7XHJcbiAgfSk7XHJcbiAgdmFyIGdldEV4dGVuc2lvbnMgPSBbdXBkYXRlTGlzdGVuZXIsIGRlZmF1bHRUaGVtZU9wdGlvbl07XHJcbiAgaWYgKGRlZmF1bHRJbmRlbnRXaXRoVGFiKSB7XHJcbiAgICBnZXRFeHRlbnNpb25zLnVuc2hpZnQoa2V5bWFwLm9mKFtpbmRlbnRXaXRoVGFiXSkpO1xyXG4gIH1cclxuICBpZiAoZGVmYXVsdEJhc2ljU2V0dXApIHtcclxuICAgIGlmICh0eXBlb2YgZGVmYXVsdEJhc2ljU2V0dXAgPT09ICdib29sZWFuJykge1xyXG4gICAgICBnZXRFeHRlbnNpb25zLnVuc2hpZnQoYmFzaWNTZXR1cCgpKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGdldEV4dGVuc2lvbnMudW5zaGlmdChiYXNpY1NldHVwKGRlZmF1bHRCYXNpY1NldHVwKSk7XHJcbiAgICB9XHJcbiAgfVxyXG4gIGlmIChwbGFjZWhvbGRlclN0cikge1xyXG4gICAgZ2V0RXh0ZW5zaW9ucy51bnNoaWZ0KHBsYWNlaG9sZGVyKHBsYWNlaG9sZGVyU3RyKSk7XHJcbiAgfVxyXG4gIHN3aXRjaCAodGhlbWUpIHtcclxuICAgIGNhc2UgJ2xpZ2h0JzpcclxuICAgICAgZ2V0RXh0ZW5zaW9ucy5wdXNoKGRlZmF1bHRMaWdodFRoZW1lT3B0aW9uKTtcclxuICAgICAgYnJlYWs7XHJcbiAgICBjYXNlICdkYXJrJzpcclxuICAgICAgZ2V0RXh0ZW5zaW9ucy5wdXNoKG9uZURhcmspO1xyXG4gICAgICBicmVhaztcclxuICAgIGNhc2UgJ25vbmUnOlxyXG4gICAgICBicmVhaztcclxuICAgIGRlZmF1bHQ6XHJcbiAgICAgIGdldEV4dGVuc2lvbnMucHVzaCh0aGVtZSk7XHJcbiAgICAgIGJyZWFrO1xyXG4gIH1cclxuICBpZiAoZWRpdGFibGUgPT09IGZhbHNlKSB7XHJcbiAgICBnZXRFeHRlbnNpb25zLnB1c2goRWRpdG9yVmlldy5lZGl0YWJsZS5vZihmYWxzZSkpO1xyXG4gIH1cclxuICBpZiAocmVhZE9ubHkpIHtcclxuICAgIGdldEV4dGVuc2lvbnMucHVzaChFZGl0b3JTdGF0ZS5yZWFkT25seS5vZih0cnVlKSk7XHJcbiAgfVxyXG4gIGlmIChvblVwZGF0ZSAmJiB0eXBlb2Ygb25VcGRhdGUgPT09ICdmdW5jdGlvbicpIHtcclxuICAgIGdldEV4dGVuc2lvbnMucHVzaChFZGl0b3JWaWV3LnVwZGF0ZUxpc3RlbmVyLm9mKG9uVXBkYXRlKSk7XHJcbiAgfVxyXG4gIGdldEV4dGVuc2lvbnMgPSBnZXRFeHRlbnNpb25zLmNvbmNhdChleHRlbnNpb25zKTtcclxuICB1c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgaWYgKGNvbnRhaW5lciAmJiAhc3RhdGUpIHtcclxuICAgICAgdmFyIGNvbmZpZyA9IHtcclxuICAgICAgICBkb2M6IHZhbHVlLFxyXG4gICAgICAgIHNlbGVjdGlvbixcclxuICAgICAgICBleHRlbnNpb25zOiBnZXRFeHRlbnNpb25zXHJcbiAgICAgIH07XHJcbiAgICAgIHZhciBzdGF0ZUN1cnJlbnQgPSBpbml0aWFsU3RhdGUgPyBFZGl0b3JTdGF0ZS5mcm9tSlNPTihpbml0aWFsU3RhdGUuanNvbiwgY29uZmlnLCBpbml0aWFsU3RhdGUuZmllbGRzKSA6IEVkaXRvclN0YXRlLmNyZWF0ZShjb25maWcpO1xyXG4gICAgICBzZXRTdGF0ZShzdGF0ZUN1cnJlbnQpO1xyXG4gICAgICBpZiAoIXZpZXcpIHtcclxuICAgICAgICB2YXIgdmlld0N1cnJlbnQgPSBuZXcgRWRpdG9yVmlldyh7XHJcbiAgICAgICAgICBzdGF0ZTogc3RhdGVDdXJyZW50LFxyXG4gICAgICAgICAgcGFyZW50OiBjb250YWluZXIsXHJcbiAgICAgICAgICByb290XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgc2V0Vmlldyh2aWV3Q3VycmVudCk7XHJcbiAgICAgICAgb25DcmVhdGVFZGl0b3IgJiYgb25DcmVhdGVFZGl0b3Iodmlld0N1cnJlbnQsIHN0YXRlQ3VycmVudCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiAoKSA9PiB7XHJcbiAgICAgIGlmICh2aWV3KSB7XHJcbiAgICAgICAgc2V0U3RhdGUodW5kZWZpbmVkKTtcclxuICAgICAgICBzZXRWaWV3KHVuZGVmaW5lZCk7XHJcbiAgICAgIH1cclxuICAgIH07XHJcbiAgfSwgW2NvbnRhaW5lciwgc3RhdGVdKTtcclxuICB1c2VFZmZlY3QoKCkgPT4gc2V0Q29udGFpbmVyKHByb3BzLmNvbnRhaW5lciksIFtwcm9wcy5jb250YWluZXJdKTtcclxuICB1c2VFZmZlY3QoKCkgPT4gKCkgPT4ge1xyXG4gICAgaWYgKHZpZXcpIHtcclxuICAgICAgdmlldy5kZXN0cm95KCk7XHJcbiAgICAgIHNldFZpZXcodW5kZWZpbmVkKTtcclxuICAgIH1cclxuICB9LCBbdmlld10pO1xyXG4gIHVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICBpZiAoYXV0b0ZvY3VzICYmIHZpZXcpIHtcclxuICAgICAgdmlldy5mb2N1cygpO1xyXG4gICAgfVxyXG4gIH0sIFthdXRvRm9jdXMsIHZpZXddKTtcclxuICB1c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgaWYgKHZpZXcpIHtcclxuICAgICAgdmlldy5kaXNwYXRjaCh7XHJcbiAgICAgICAgZWZmZWN0czogU3RhdGVFZmZlY3QucmVjb25maWd1cmUub2YoZ2V0RXh0ZW5zaW9ucylcclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvZXhoYXVzdGl2ZS1kZXBzXHJcbiAgfSwgW3RoZW1lLCBleHRlbnNpb25zLCBoZWlnaHQsIG1pbkhlaWdodCwgbWF4SGVpZ2h0LCB3aWR0aCwgbWluV2lkdGgsIG1heFdpZHRoLCBwbGFjZWhvbGRlclN0ciwgZWRpdGFibGUsIHJlYWRPbmx5LCBkZWZhdWx0SW5kZW50V2l0aFRhYiwgZGVmYXVsdEJhc2ljU2V0dXAsIG9uQ2hhbmdlLCBvblVwZGF0ZV0pO1xyXG4gIHVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICB2YXIgY3VycmVudFZhbHVlID0gdmlldyA/IHZpZXcuc3RhdGUuZG9jLnRvU3RyaW5nKCkgOiAnJztcclxuICAgIGlmICh2aWV3ICYmIHZhbHVlICE9PSBjdXJyZW50VmFsdWUpIHtcclxuICAgICAgdmlldy5kaXNwYXRjaCh7XHJcbiAgICAgICAgY2hhbmdlczoge1xyXG4gICAgICAgICAgZnJvbTogMCxcclxuICAgICAgICAgIHRvOiBjdXJyZW50VmFsdWUubGVuZ3RoLFxyXG4gICAgICAgICAgaW5zZXJ0OiB2YWx1ZSB8fCAnJ1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgfSwgW3ZhbHVlLCB2aWV3XSk7XHJcbiAgcmV0dXJuIHtcclxuICAgIHN0YXRlLFxyXG4gICAgc2V0U3RhdGUsXHJcbiAgICB2aWV3LFxyXG4gICAgc2V0VmlldyxcclxuICAgIGNvbnRhaW5lcixcclxuICAgIHNldENvbnRhaW5lclxyXG4gIH07XHJcbn1cclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXNlQ29kZU1pcnJvci5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@uiw/react-codemirror/esm/useCodeMirror.js\n"));

/***/ }),

/***/ "./node_modules/@uiw/react-codemirror/esm/utils.js":
/*!*********************************************************!*\
  !*** ./node_modules/@uiw/react-codemirror/esm/utils.js ***!
  \*********************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"getStatistics\": function() { return /* binding */ getStatistics; }\n/* harmony export */ });\nvar getStatistics = view => {\r\n  return {\r\n    line: view.state.doc.lineAt(view.state.selection.main.from),\r\n    lineCount: view.state.doc.lines,\r\n    lineBreak: view.state.lineBreak,\r\n    length: view.state.doc.length,\r\n    readOnly: view.state.readOnly,\r\n    tabSize: view.state.tabSize,\r\n    selection: view.state.selection,\r\n    selectionAsSingle: view.state.selection.asSingle().main,\r\n    ranges: view.state.selection.ranges,\r\n    selectionCode: view.state.sliceDoc(view.state.selection.main.from, view.state.selection.main.to),\r\n    selections: view.state.selection.ranges.map(r => view.state.sliceDoc(r.from, r.to)),\r\n    selectedText: view.state.selection.ranges.some(r => !r.empty)\r\n  };\r\n};\r\n//# sourceMappingURL=utils.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHVpdy9yZWFjdC1jb2RlbWlycm9yL2VzbS91dGlscy5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQHVpdy9yZWFjdC1jb2RlbWlycm9yL2VzbS91dGlscy5qcz9iMzE5Il0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCB2YXIgZ2V0U3RhdGlzdGljcyA9IHZpZXcgPT4ge1xyXG4gIHJldHVybiB7XHJcbiAgICBsaW5lOiB2aWV3LnN0YXRlLmRvYy5saW5lQXQodmlldy5zdGF0ZS5zZWxlY3Rpb24ubWFpbi5mcm9tKSxcclxuICAgIGxpbmVDb3VudDogdmlldy5zdGF0ZS5kb2MubGluZXMsXHJcbiAgICBsaW5lQnJlYWs6IHZpZXcuc3RhdGUubGluZUJyZWFrLFxyXG4gICAgbGVuZ3RoOiB2aWV3LnN0YXRlLmRvYy5sZW5ndGgsXHJcbiAgICByZWFkT25seTogdmlldy5zdGF0ZS5yZWFkT25seSxcclxuICAgIHRhYlNpemU6IHZpZXcuc3RhdGUudGFiU2l6ZSxcclxuICAgIHNlbGVjdGlvbjogdmlldy5zdGF0ZS5zZWxlY3Rpb24sXHJcbiAgICBzZWxlY3Rpb25Bc1NpbmdsZTogdmlldy5zdGF0ZS5zZWxlY3Rpb24uYXNTaW5nbGUoKS5tYWluLFxyXG4gICAgcmFuZ2VzOiB2aWV3LnN0YXRlLnNlbGVjdGlvbi5yYW5nZXMsXHJcbiAgICBzZWxlY3Rpb25Db2RlOiB2aWV3LnN0YXRlLnNsaWNlRG9jKHZpZXcuc3RhdGUuc2VsZWN0aW9uLm1haW4uZnJvbSwgdmlldy5zdGF0ZS5zZWxlY3Rpb24ubWFpbi50byksXHJcbiAgICBzZWxlY3Rpb25zOiB2aWV3LnN0YXRlLnNlbGVjdGlvbi5yYW5nZXMubWFwKHIgPT4gdmlldy5zdGF0ZS5zbGljZURvYyhyLmZyb20sIHIudG8pKSxcclxuICAgIHNlbGVjdGVkVGV4dDogdmlldy5zdGF0ZS5zZWxlY3Rpb24ucmFuZ2VzLnNvbWUociA9PiAhci5lbXB0eSlcclxuICB9O1xyXG59O1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD11dGlscy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@uiw/react-codemirror/esm/utils.js\n"));

/***/ }),

/***/ "./node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[3].oneOf[4].use[1]!./node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[3].oneOf[4].use[2]!./pages/styles/index.module.css":
/*!*******************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[3].oneOf[4].use[1]!./node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[3].oneOf[4].use[2]!./pages/styles/index.module.css ***!
  \*******************************************************************************************************************************************************************************************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("// Imports\nvar ___CSS_LOADER_API_IMPORT___ = __webpack_require__(/*! ../../node_modules/next/dist/build/webpack/loaders/css-loader/src/runtime/api.js */ \"./node_modules/next/dist/build/webpack/loaders/css-loader/src/runtime/api.js\");\nvar ___CSS_LOADER_EXPORT___ = ___CSS_LOADER_API_IMPORT___(true);\n// Module\n___CSS_LOADER_EXPORT___.push([module.id, \"\\r\\n\\r\\n.styles_container__H_1Ob{\\r\\n  background-color: aqua;\\r\\n  width: 100%;\\r\\n  height: 75%;\\r\\n}\\r\\n\\r\\n.styles_main__ahLiv .styles_loading__p1JVB {\\r\\n  width: 50;\\r\\n}\\r\\n\\r\\n.styles_main__ahLiv h1{\\r\\n  display: block;\\r\\n  font-weight: bold;\\r\\n  font-family: Arial, Helvetica, sans-serif;\\r\\n  margin: auto;\\r\\n  width: 100%;\\r\\n\\r\\n}\\r\\n\\r\\n.styles_main__ahLiv label{\\r\\n  font-weight: bold;\\r\\n  font-family: Arial, Helvetica, sans-serif;\\r\\n\\r\\n}\\r\\n\\r\\n.styles_main__ahLiv select {\\r\\n  padding: 12px 16px;\\r\\n  border: 1px solid #000000;\\r\\n  border-radius: 4px;\\r\\n  margin: 20px;\\r\\n  margin-bottom: 12px;\\r\\n  margin-top: 4px;\\r\\n}\\r\\n\\r\\n.styles_main__ahLiv input{\\r\\n  padding: 10px;\\r\\n  color: rgb(217, 234, 232) !important;\\r\\n  margin: 10px;\\r\\n  display: block;\\r\\n  margin-top: 20px;\\r\\n  margin-bottom: 20px;\\r\\n  margin-left: auto;\\r\\n  margin-right: auto;\\r\\n  min-width: 200px;\\r\\n  background-color: rgb(70, 133, 222);\\r\\n  border: none;\\r\\n  border-radius: 4px;\\r\\n  outline: none;\\r\\n  font-family: Arial;\\r\\n  font-weight: bolder;\\r\\n  transition: all 0.2s;\\r\\n}\\r\\n\\r\\n.styles_main__ahLiv input:hover{\\r\\n  opacity: 0.8;\\r\\n}\\r\\n.styles_main__ahLiv input:active{\\r\\n  opacity: 0.7;\\r\\n}\\r\\n\\r\\n.styles_main__ahLiv textarea {\\r\\n  resize: none;\\r\\n  width: 99.75%;;\\r\\n}\\r\\n\", \"\",{\"version\":3,\"sources\":[\"webpack://pages/styles/index.module.css\"],\"names\":[],\"mappings\":\";;AAEA;EACE,sBAAsB;EACtB,WAAW;EACX,WAAW;AACb;;AAEA;EACE,SAAS;AACX;;AAEA;EACE,cAAc;EACd,iBAAiB;EACjB,yCAAyC;EACzC,YAAY;EACZ,WAAW;;AAEb;;AAEA;EACE,iBAAiB;EACjB,yCAAyC;;AAE3C;;AAEA;EACE,kBAAkB;EAClB,yBAAyB;EACzB,kBAAkB;EAClB,YAAY;EACZ,mBAAmB;EACnB,eAAe;AACjB;;AAEA;EACE,aAAa;EACb,oCAAoC;EACpC,YAAY;EACZ,cAAc;EACd,gBAAgB;EAChB,mBAAmB;EACnB,iBAAiB;EACjB,kBAAkB;EAClB,gBAAgB;EAChB,mCAAmC;EACnC,YAAY;EACZ,kBAAkB;EAClB,aAAa;EACb,kBAAkB;EAClB,mBAAmB;EACnB,oBAAoB;AACtB;;AAEA;EACE,YAAY;AACd;AACA;EACE,YAAY;AACd;;AAEA;EACE,YAAY;EACZ,aAAa;AACf\",\"sourcesContent\":[\"\\r\\n\\r\\n.container{\\r\\n  background-color: aqua;\\r\\n  width: 100%;\\r\\n  height: 75%;\\r\\n}\\r\\n\\r\\n.main .loading {\\r\\n  width: 50;\\r\\n}\\r\\n\\r\\n.main h1{\\r\\n  display: block;\\r\\n  font-weight: bold;\\r\\n  font-family: Arial, Helvetica, sans-serif;\\r\\n  margin: auto;\\r\\n  width: 100%;\\r\\n\\r\\n}\\r\\n\\r\\n.main label{\\r\\n  font-weight: bold;\\r\\n  font-family: Arial, Helvetica, sans-serif;\\r\\n\\r\\n}\\r\\n\\r\\n.main select {\\r\\n  padding: 12px 16px;\\r\\n  border: 1px solid #000000;\\r\\n  border-radius: 4px;\\r\\n  margin: 20px;\\r\\n  margin-bottom: 12px;\\r\\n  margin-top: 4px;\\r\\n}\\r\\n\\r\\n.main input{\\r\\n  padding: 10px;\\r\\n  color: rgb(217, 234, 232) !important;\\r\\n  margin: 10px;\\r\\n  display: block;\\r\\n  margin-top: 20px;\\r\\n  margin-bottom: 20px;\\r\\n  margin-left: auto;\\r\\n  margin-right: auto;\\r\\n  min-width: 200px;\\r\\n  background-color: rgb(70, 133, 222);\\r\\n  border: none;\\r\\n  border-radius: 4px;\\r\\n  outline: none;\\r\\n  font-family: Arial;\\r\\n  font-weight: bolder;\\r\\n  transition: all 0.2s;\\r\\n}\\r\\n\\r\\n.main input:hover{\\r\\n  opacity: 0.8;\\r\\n}\\r\\n.main input:active{\\r\\n  opacity: 0.7;\\r\\n}\\r\\n\\r\\n.main textarea {\\r\\n  resize: none;\\r\\n  width: 99.75%;;\\r\\n}\\r\\n\"],\"sourceRoot\":\"\"}]);\n// Exports\n___CSS_LOADER_EXPORT___.locals = {\n\t\"container\": \"styles_container__H_1Ob\",\n\t\"main\": \"styles_main__ahLiv\",\n\t\"loading\": \"styles_loading__p1JVB\"\n};\nmodule.exports = ___CSS_LOADER_EXPORT___;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9jc3MtbG9hZGVyL3NyYy9pbmRleC5qcz8/cnVsZVNldFsxXS5ydWxlc1szXS5vbmVPZls0XS51c2VbMV0hLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9wb3N0Y3NzLWxvYWRlci9zcmMvaW5kZXguanM/P3J1bGVTZXRbMV0ucnVsZXNbM10ub25lT2ZbNF0udXNlWzJdIS4vcGFnZXMvc3R5bGVzL2luZGV4Lm1vZHVsZS5jc3MuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQSxrQ0FBa0MsbUJBQU8sQ0FBQyxzS0FBa0Y7QUFDNUg7QUFDQTtBQUNBLDJFQUEyRSw2QkFBNkIsa0JBQWtCLGtCQUFrQixLQUFLLG9EQUFvRCxnQkFBZ0IsS0FBSywrQkFBK0IscUJBQXFCLHdCQUF3QixnREFBZ0QsbUJBQW1CLGtCQUFrQixTQUFTLGtDQUFrQyx3QkFBd0IsZ0RBQWdELFNBQVMsb0NBQW9DLHlCQUF5QixnQ0FBZ0MseUJBQXlCLG1CQUFtQiwwQkFBMEIsc0JBQXNCLEtBQUssa0NBQWtDLG9CQUFvQiwyQ0FBMkMsbUJBQW1CLHFCQUFxQix1QkFBdUIsMEJBQTBCLHdCQUF3Qix5QkFBeUIsdUJBQXVCLDBDQUEwQyxtQkFBbUIseUJBQXlCLG9CQUFvQix5QkFBeUIsMEJBQTBCLDJCQUEyQixLQUFLLHdDQUF3QyxtQkFBbUIsS0FBSyxxQ0FBcUMsbUJBQW1CLEtBQUssc0NBQXNDLG1CQUFtQixxQkFBcUIsS0FBSyxXQUFXLDJGQUEyRixLQUFLLFlBQVksV0FBVyxVQUFVLE1BQU0sS0FBSyxVQUFVLE1BQU0sS0FBSyxVQUFVLFlBQVksYUFBYSxXQUFXLFdBQVcsTUFBTSxLQUFLLFlBQVksY0FBYyxPQUFPLEtBQUssWUFBWSxhQUFhLGFBQWEsV0FBVyxZQUFZLFdBQVcsT0FBTyxLQUFLLFVBQVUsWUFBWSxXQUFXLFVBQVUsWUFBWSxhQUFhLGFBQWEsYUFBYSxhQUFhLGFBQWEsV0FBVyxZQUFZLFdBQVcsWUFBWSxhQUFhLGFBQWEsT0FBTyxLQUFLLFVBQVUsS0FBSyxLQUFLLFVBQVUsTUFBTSxLQUFLLFVBQVUsVUFBVSw0Q0FBNEMsNkJBQTZCLGtCQUFrQixrQkFBa0IsS0FBSyx3QkFBd0IsZ0JBQWdCLEtBQUssaUJBQWlCLHFCQUFxQix3QkFBd0IsZ0RBQWdELG1CQUFtQixrQkFBa0IsU0FBUyxvQkFBb0Isd0JBQXdCLGdEQUFnRCxTQUFTLHNCQUFzQix5QkFBeUIsZ0NBQWdDLHlCQUF5QixtQkFBbUIsMEJBQTBCLHNCQUFzQixLQUFLLG9CQUFvQixvQkFBb0IsMkNBQTJDLG1CQUFtQixxQkFBcUIsdUJBQXVCLDBCQUEwQix3QkFBd0IseUJBQXlCLHVCQUF1QiwwQ0FBMEMsbUJBQW1CLHlCQUF5QixvQkFBb0IseUJBQXlCLDBCQUEwQiwyQkFBMkIsS0FBSywwQkFBMEIsbUJBQW1CLEtBQUssdUJBQXVCLG1CQUFtQixLQUFLLHdCQUF3QixtQkFBbUIscUJBQXFCLEtBQUssdUJBQXVCO0FBQ3JuRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9wYWdlcy9zdHlsZXMvaW5kZXgubW9kdWxlLmNzcz83OTM1Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIEltcG9ydHNcbnZhciBfX19DU1NfTE9BREVSX0FQSV9JTVBPUlRfX18gPSByZXF1aXJlKFwiLi4vLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9idWlsZC93ZWJwYWNrL2xvYWRlcnMvY3NzLWxvYWRlci9zcmMvcnVudGltZS9hcGkuanNcIik7XG52YXIgX19fQ1NTX0xPQURFUl9FWFBPUlRfX18gPSBfX19DU1NfTE9BREVSX0FQSV9JTVBPUlRfX18odHJ1ZSk7XG4vLyBNb2R1bGVcbl9fX0NTU19MT0FERVJfRVhQT1JUX19fLnB1c2goW21vZHVsZS5pZCwgXCJcXHJcXG5cXHJcXG4uc3R5bGVzX2NvbnRhaW5lcl9fSF8xT2J7XFxyXFxuICBiYWNrZ3JvdW5kLWNvbG9yOiBhcXVhO1xcclxcbiAgd2lkdGg6IDEwMCU7XFxyXFxuICBoZWlnaHQ6IDc1JTtcXHJcXG59XFxyXFxuXFxyXFxuLnN0eWxlc19tYWluX19haExpdiAuc3R5bGVzX2xvYWRpbmdfX3AxSlZCIHtcXHJcXG4gIHdpZHRoOiA1MDtcXHJcXG59XFxyXFxuXFxyXFxuLnN0eWxlc19tYWluX19haExpdiBoMXtcXHJcXG4gIGRpc3BsYXk6IGJsb2NrO1xcclxcbiAgZm9udC13ZWlnaHQ6IGJvbGQ7XFxyXFxuICBmb250LWZhbWlseTogQXJpYWwsIEhlbHZldGljYSwgc2Fucy1zZXJpZjtcXHJcXG4gIG1hcmdpbjogYXV0bztcXHJcXG4gIHdpZHRoOiAxMDAlO1xcclxcblxcclxcbn1cXHJcXG5cXHJcXG4uc3R5bGVzX21haW5fX2FoTGl2IGxhYmVse1xcclxcbiAgZm9udC13ZWlnaHQ6IGJvbGQ7XFxyXFxuICBmb250LWZhbWlseTogQXJpYWwsIEhlbHZldGljYSwgc2Fucy1zZXJpZjtcXHJcXG5cXHJcXG59XFxyXFxuXFxyXFxuLnN0eWxlc19tYWluX19haExpdiBzZWxlY3Qge1xcclxcbiAgcGFkZGluZzogMTJweCAxNnB4O1xcclxcbiAgYm9yZGVyOiAxcHggc29saWQgIzAwMDAwMDtcXHJcXG4gIGJvcmRlci1yYWRpdXM6IDRweDtcXHJcXG4gIG1hcmdpbjogMjBweDtcXHJcXG4gIG1hcmdpbi1ib3R0b206IDEycHg7XFxyXFxuICBtYXJnaW4tdG9wOiA0cHg7XFxyXFxufVxcclxcblxcclxcbi5zdHlsZXNfbWFpbl9fYWhMaXYgaW5wdXR7XFxyXFxuICBwYWRkaW5nOiAxMHB4O1xcclxcbiAgY29sb3I6IHJnYigyMTcsIDIzNCwgMjMyKSAhaW1wb3J0YW50O1xcclxcbiAgbWFyZ2luOiAxMHB4O1xcclxcbiAgZGlzcGxheTogYmxvY2s7XFxyXFxuICBtYXJnaW4tdG9wOiAyMHB4O1xcclxcbiAgbWFyZ2luLWJvdHRvbTogMjBweDtcXHJcXG4gIG1hcmdpbi1sZWZ0OiBhdXRvO1xcclxcbiAgbWFyZ2luLXJpZ2h0OiBhdXRvO1xcclxcbiAgbWluLXdpZHRoOiAyMDBweDtcXHJcXG4gIGJhY2tncm91bmQtY29sb3I6IHJnYig3MCwgMTMzLCAyMjIpO1xcclxcbiAgYm9yZGVyOiBub25lO1xcclxcbiAgYm9yZGVyLXJhZGl1czogNHB4O1xcclxcbiAgb3V0bGluZTogbm9uZTtcXHJcXG4gIGZvbnQtZmFtaWx5OiBBcmlhbDtcXHJcXG4gIGZvbnQtd2VpZ2h0OiBib2xkZXI7XFxyXFxuICB0cmFuc2l0aW9uOiBhbGwgMC4ycztcXHJcXG59XFxyXFxuXFxyXFxuLnN0eWxlc19tYWluX19haExpdiBpbnB1dDpob3ZlcntcXHJcXG4gIG9wYWNpdHk6IDAuODtcXHJcXG59XFxyXFxuLnN0eWxlc19tYWluX19haExpdiBpbnB1dDphY3RpdmV7XFxyXFxuICBvcGFjaXR5OiAwLjc7XFxyXFxufVxcclxcblxcclxcbi5zdHlsZXNfbWFpbl9fYWhMaXYgdGV4dGFyZWEge1xcclxcbiAgcmVzaXplOiBub25lO1xcclxcbiAgd2lkdGg6IDk5Ljc1JTs7XFxyXFxufVxcclxcblwiLCBcIlwiLHtcInZlcnNpb25cIjozLFwic291cmNlc1wiOltcIndlYnBhY2s6Ly9wYWdlcy9zdHlsZXMvaW5kZXgubW9kdWxlLmNzc1wiXSxcIm5hbWVzXCI6W10sXCJtYXBwaW5nc1wiOlwiOztBQUVBO0VBQ0Usc0JBQXNCO0VBQ3RCLFdBQVc7RUFDWCxXQUFXO0FBQ2I7O0FBRUE7RUFDRSxTQUFTO0FBQ1g7O0FBRUE7RUFDRSxjQUFjO0VBQ2QsaUJBQWlCO0VBQ2pCLHlDQUF5QztFQUN6QyxZQUFZO0VBQ1osV0FBVzs7QUFFYjs7QUFFQTtFQUNFLGlCQUFpQjtFQUNqQix5Q0FBeUM7O0FBRTNDOztBQUVBO0VBQ0Usa0JBQWtCO0VBQ2xCLHlCQUF5QjtFQUN6QixrQkFBa0I7RUFDbEIsWUFBWTtFQUNaLG1CQUFtQjtFQUNuQixlQUFlO0FBQ2pCOztBQUVBO0VBQ0UsYUFBYTtFQUNiLG9DQUFvQztFQUNwQyxZQUFZO0VBQ1osY0FBYztFQUNkLGdCQUFnQjtFQUNoQixtQkFBbUI7RUFDbkIsaUJBQWlCO0VBQ2pCLGtCQUFrQjtFQUNsQixnQkFBZ0I7RUFDaEIsbUNBQW1DO0VBQ25DLFlBQVk7RUFDWixrQkFBa0I7RUFDbEIsYUFBYTtFQUNiLGtCQUFrQjtFQUNsQixtQkFBbUI7RUFDbkIsb0JBQW9CO0FBQ3RCOztBQUVBO0VBQ0UsWUFBWTtBQUNkO0FBQ0E7RUFDRSxZQUFZO0FBQ2Q7O0FBRUE7RUFDRSxZQUFZO0VBQ1osYUFBYTtBQUNmXCIsXCJzb3VyY2VzQ29udGVudFwiOltcIlxcclxcblxcclxcbi5jb250YWluZXJ7XFxyXFxuICBiYWNrZ3JvdW5kLWNvbG9yOiBhcXVhO1xcclxcbiAgd2lkdGg6IDEwMCU7XFxyXFxuICBoZWlnaHQ6IDc1JTtcXHJcXG59XFxyXFxuXFxyXFxuLm1haW4gLmxvYWRpbmcge1xcclxcbiAgd2lkdGg6IDUwO1xcclxcbn1cXHJcXG5cXHJcXG4ubWFpbiBoMXtcXHJcXG4gIGRpc3BsYXk6IGJsb2NrO1xcclxcbiAgZm9udC13ZWlnaHQ6IGJvbGQ7XFxyXFxuICBmb250LWZhbWlseTogQXJpYWwsIEhlbHZldGljYSwgc2Fucy1zZXJpZjtcXHJcXG4gIG1hcmdpbjogYXV0bztcXHJcXG4gIHdpZHRoOiAxMDAlO1xcclxcblxcclxcbn1cXHJcXG5cXHJcXG4ubWFpbiBsYWJlbHtcXHJcXG4gIGZvbnQtd2VpZ2h0OiBib2xkO1xcclxcbiAgZm9udC1mYW1pbHk6IEFyaWFsLCBIZWx2ZXRpY2EsIHNhbnMtc2VyaWY7XFxyXFxuXFxyXFxufVxcclxcblxcclxcbi5tYWluIHNlbGVjdCB7XFxyXFxuICBwYWRkaW5nOiAxMnB4IDE2cHg7XFxyXFxuICBib3JkZXI6IDFweCBzb2xpZCAjMDAwMDAwO1xcclxcbiAgYm9yZGVyLXJhZGl1czogNHB4O1xcclxcbiAgbWFyZ2luOiAyMHB4O1xcclxcbiAgbWFyZ2luLWJvdHRvbTogMTJweDtcXHJcXG4gIG1hcmdpbi10b3A6IDRweDtcXHJcXG59XFxyXFxuXFxyXFxuLm1haW4gaW5wdXR7XFxyXFxuICBwYWRkaW5nOiAxMHB4O1xcclxcbiAgY29sb3I6IHJnYigyMTcsIDIzNCwgMjMyKSAhaW1wb3J0YW50O1xcclxcbiAgbWFyZ2luOiAxMHB4O1xcclxcbiAgZGlzcGxheTogYmxvY2s7XFxyXFxuICBtYXJnaW4tdG9wOiAyMHB4O1xcclxcbiAgbWFyZ2luLWJvdHRvbTogMjBweDtcXHJcXG4gIG1hcmdpbi1sZWZ0OiBhdXRvO1xcclxcbiAgbWFyZ2luLXJpZ2h0OiBhdXRvO1xcclxcbiAgbWluLXdpZHRoOiAyMDBweDtcXHJcXG4gIGJhY2tncm91bmQtY29sb3I6IHJnYig3MCwgMTMzLCAyMjIpO1xcclxcbiAgYm9yZGVyOiBub25lO1xcclxcbiAgYm9yZGVyLXJhZGl1czogNHB4O1xcclxcbiAgb3V0bGluZTogbm9uZTtcXHJcXG4gIGZvbnQtZmFtaWx5OiBBcmlhbDtcXHJcXG4gIGZvbnQtd2VpZ2h0OiBib2xkZXI7XFxyXFxuICB0cmFuc2l0aW9uOiBhbGwgMC4ycztcXHJcXG59XFxyXFxuXFxyXFxuLm1haW4gaW5wdXQ6aG92ZXJ7XFxyXFxuICBvcGFjaXR5OiAwLjg7XFxyXFxufVxcclxcbi5tYWluIGlucHV0OmFjdGl2ZXtcXHJcXG4gIG9wYWNpdHk6IDAuNztcXHJcXG59XFxyXFxuXFxyXFxuLm1haW4gdGV4dGFyZWEge1xcclxcbiAgcmVzaXplOiBub25lO1xcclxcbiAgd2lkdGg6IDk5Ljc1JTs7XFxyXFxufVxcclxcblwiXSxcInNvdXJjZVJvb3RcIjpcIlwifV0pO1xuLy8gRXhwb3J0c1xuX19fQ1NTX0xPQURFUl9FWFBPUlRfX18ubG9jYWxzID0ge1xuXHRcImNvbnRhaW5lclwiOiBcInN0eWxlc19jb250YWluZXJfX0hfMU9iXCIsXG5cdFwibWFpblwiOiBcInN0eWxlc19tYWluX19haExpdlwiLFxuXHRcImxvYWRpbmdcIjogXCJzdHlsZXNfbG9hZGluZ19fcDFKVkJcIlxufTtcbm1vZHVsZS5leHBvcnRzID0gX19fQ1NTX0xPQURFUl9FWFBPUlRfX187XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[3].oneOf[4].use[1]!./node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[3].oneOf[4].use[2]!./pages/styles/index.module.css\n"));

/***/ }),

/***/ "./node_modules/next/dist/build/webpack/loaders/css-loader/src/runtime/api.js":
/*!************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/css-loader/src/runtime/api.js ***!
  \************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\r\n/*\r\n  MIT License http://www.opensource.org/licenses/mit-license.php\r\n  Author Tobias Koppers @sokra\r\n*/ // css base code, injected by the css-loader\r\n// eslint-disable-next-line func-names\r\nmodule.exports = function(useSourceMap) {\r\n    var list = [] // return the list of modules as css string\r\n    ;\r\n    list.toString = function toString() {\r\n        return this.map(function(item) {\r\n            var content = cssWithMappingToString(item, useSourceMap);\r\n            if (item[2]) {\r\n                return \"@media \".concat(item[2], \" {\").concat(content, \"}\");\r\n            }\r\n            return content;\r\n        }).join(\"\");\r\n    } // import a list of modules into the list\r\n    ;\r\n    // eslint-disable-next-line func-names\r\n    list.i = function(modules, mediaQuery, dedupe) {\r\n        if (typeof modules === \"string\") {\r\n            // eslint-disable-next-line no-param-reassign\r\n            modules = [\r\n                [\r\n                    null,\r\n                    modules,\r\n                    \"\"\r\n                ]\r\n            ];\r\n        }\r\n        var alreadyImportedModules = {};\r\n        if (dedupe) {\r\n            for(var i = 0; i < this.length; i++){\r\n                // eslint-disable-next-line prefer-destructuring\r\n                var id = this[i][0];\r\n                if (id != null) {\r\n                    alreadyImportedModules[id] = true;\r\n                }\r\n            }\r\n        }\r\n        for(var _i = 0; _i < modules.length; _i++){\r\n            var item = [].concat(modules[_i]);\r\n            if (dedupe && alreadyImportedModules[item[0]]) {\r\n                continue;\r\n            }\r\n            if (mediaQuery) {\r\n                if (!item[2]) {\r\n                    item[2] = mediaQuery;\r\n                } else {\r\n                    item[2] = \"\".concat(mediaQuery, \" and \").concat(item[2]);\r\n                }\r\n            }\r\n            list.push(item);\r\n        }\r\n    };\r\n    return list;\r\n};\r\nfunction cssWithMappingToString(item, useSourceMap) {\r\n    var content = item[1] || \"\" // eslint-disable-next-line prefer-destructuring\r\n    ;\r\n    var cssMapping = item[3];\r\n    if (!cssMapping) {\r\n        return content;\r\n    }\r\n    if (useSourceMap && typeof btoa === \"function\") {\r\n        var sourceMapping = toComment(cssMapping);\r\n        var sourceURLs = cssMapping.sources.map(function(source) {\r\n            return \"/*# sourceURL=\".concat(cssMapping.sourceRoot || \"\").concat(source, \" */\");\r\n        });\r\n        return [\r\n            content\r\n        ].concat(sourceURLs).concat([\r\n            sourceMapping\r\n        ]).join(\"\\n\");\r\n    }\r\n    return [\r\n        content\r\n    ].join(\"\\n\");\r\n} // Adapted from convert-source-map (MIT)\r\nfunction toComment(sourceMap) {\r\n    // eslint-disable-next-line no-undef\r\n    var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));\r\n    var data = \"sourceMappingURL=data:application/json;charset=utf-8;base64,\".concat(base64);\r\n    return \"/*# \".concat(data, \" */\");\r\n}\r\n\r\n//# sourceMappingURL=api.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9jc3MtbG9hZGVyL3NyYy9ydW50aW1lL2FwaS5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxxQkFBcUI7QUFDekU7QUFDQTtBQUNBLFNBQVM7QUFDVCxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGlCQUFpQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixxQkFBcUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RCxjQUFjO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL2Nzcy1sb2FkZXIvc3JjL3J1bnRpbWUvYXBpLmpzP2NhNGQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XHJcbi8qXHJcbiAgTUlUIExpY2Vuc2UgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcclxuICBBdXRob3IgVG9iaWFzIEtvcHBlcnMgQHNva3JhXHJcbiovIC8vIGNzcyBiYXNlIGNvZGUsIGluamVjdGVkIGJ5IHRoZSBjc3MtbG9hZGVyXHJcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBmdW5jLW5hbWVzXHJcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24odXNlU291cmNlTWFwKSB7XHJcbiAgICB2YXIgbGlzdCA9IFtdIC8vIHJldHVybiB0aGUgbGlzdCBvZiBtb2R1bGVzIGFzIGNzcyBzdHJpbmdcclxuICAgIDtcclxuICAgIGxpc3QudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5tYXAoZnVuY3Rpb24oaXRlbSkge1xyXG4gICAgICAgICAgICB2YXIgY29udGVudCA9IGNzc1dpdGhNYXBwaW5nVG9TdHJpbmcoaXRlbSwgdXNlU291cmNlTWFwKTtcclxuICAgICAgICAgICAgaWYgKGl0ZW1bMl0pIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBcIkBtZWRpYSBcIi5jb25jYXQoaXRlbVsyXSwgXCIge1wiKS5jb25jYXQoY29udGVudCwgXCJ9XCIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBjb250ZW50O1xyXG4gICAgICAgIH0pLmpvaW4oXCJcIik7XHJcbiAgICB9IC8vIGltcG9ydCBhIGxpc3Qgb2YgbW9kdWxlcyBpbnRvIHRoZSBsaXN0XHJcbiAgICA7XHJcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZnVuYy1uYW1lc1xyXG4gICAgbGlzdC5pID0gZnVuY3Rpb24obW9kdWxlcywgbWVkaWFRdWVyeSwgZGVkdXBlKSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBtb2R1bGVzID09PSBcInN0cmluZ1wiKSB7XHJcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxyXG4gICAgICAgICAgICBtb2R1bGVzID0gW1xyXG4gICAgICAgICAgICAgICAgW1xyXG4gICAgICAgICAgICAgICAgICAgIG51bGwsXHJcbiAgICAgICAgICAgICAgICAgICAgbW9kdWxlcyxcclxuICAgICAgICAgICAgICAgICAgICBcIlwiXHJcbiAgICAgICAgICAgICAgICBdXHJcbiAgICAgICAgICAgIF07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzID0ge307XHJcbiAgICAgICAgaWYgKGRlZHVwZSkge1xyXG4gICAgICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKyl7XHJcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcHJlZmVyLWRlc3RydWN0dXJpbmdcclxuICAgICAgICAgICAgICAgIHZhciBpZCA9IHRoaXNbaV1bMF07XHJcbiAgICAgICAgICAgICAgICBpZiAoaWQgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGFscmVhZHlJbXBvcnRlZE1vZHVsZXNbaWRdID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBmb3IodmFyIF9pID0gMDsgX2kgPCBtb2R1bGVzLmxlbmd0aDsgX2krKyl7XHJcbiAgICAgICAgICAgIHZhciBpdGVtID0gW10uY29uY2F0KG1vZHVsZXNbX2ldKTtcclxuICAgICAgICAgICAgaWYgKGRlZHVwZSAmJiBhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzW2l0ZW1bMF1dKSB7XHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAobWVkaWFRdWVyeSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFpdGVtWzJdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaXRlbVsyXSA9IG1lZGlhUXVlcnk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGl0ZW1bMl0gPSBcIlwiLmNvbmNhdChtZWRpYVF1ZXJ5LCBcIiBhbmQgXCIpLmNvbmNhdChpdGVtWzJdKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBsaXN0LnB1c2goaXRlbSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIHJldHVybiBsaXN0O1xyXG59O1xyXG5mdW5jdGlvbiBjc3NXaXRoTWFwcGluZ1RvU3RyaW5nKGl0ZW0sIHVzZVNvdXJjZU1hcCkge1xyXG4gICAgdmFyIGNvbnRlbnQgPSBpdGVtWzFdIHx8IFwiXCIgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHByZWZlci1kZXN0cnVjdHVyaW5nXHJcbiAgICA7XHJcbiAgICB2YXIgY3NzTWFwcGluZyA9IGl0ZW1bM107XHJcbiAgICBpZiAoIWNzc01hcHBpbmcpIHtcclxuICAgICAgICByZXR1cm4gY29udGVudDtcclxuICAgIH1cclxuICAgIGlmICh1c2VTb3VyY2VNYXAgJiYgdHlwZW9mIGJ0b2EgPT09IFwiZnVuY3Rpb25cIikge1xyXG4gICAgICAgIHZhciBzb3VyY2VNYXBwaW5nID0gdG9Db21tZW50KGNzc01hcHBpbmcpO1xyXG4gICAgICAgIHZhciBzb3VyY2VVUkxzID0gY3NzTWFwcGluZy5zb3VyY2VzLm1hcChmdW5jdGlvbihzb3VyY2UpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFwiLyojIHNvdXJjZVVSTD1cIi5jb25jYXQoY3NzTWFwcGluZy5zb3VyY2VSb290IHx8IFwiXCIpLmNvbmNhdChzb3VyY2UsIFwiICovXCIpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBbXHJcbiAgICAgICAgICAgIGNvbnRlbnRcclxuICAgICAgICBdLmNvbmNhdChzb3VyY2VVUkxzKS5jb25jYXQoW1xyXG4gICAgICAgICAgICBzb3VyY2VNYXBwaW5nXHJcbiAgICAgICAgXSkuam9pbihcIlxcblwiKTtcclxuICAgIH1cclxuICAgIHJldHVybiBbXHJcbiAgICAgICAgY29udGVudFxyXG4gICAgXS5qb2luKFwiXFxuXCIpO1xyXG59IC8vIEFkYXB0ZWQgZnJvbSBjb252ZXJ0LXNvdXJjZS1tYXAgKE1JVClcclxuZnVuY3Rpb24gdG9Db21tZW50KHNvdXJjZU1hcCkge1xyXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVuZGVmXHJcbiAgICB2YXIgYmFzZTY0ID0gYnRvYSh1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoSlNPTi5zdHJpbmdpZnkoc291cmNlTWFwKSkpKTtcclxuICAgIHZhciBkYXRhID0gXCJzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtjaGFyc2V0PXV0Zi04O2Jhc2U2NCxcIi5jb25jYXQoYmFzZTY0KTtcclxuICAgIHJldHVybiBcIi8qIyBcIi5jb25jYXQoZGF0YSwgXCIgKi9cIik7XHJcbn1cclxuXHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFwaS5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/next/dist/build/webpack/loaders/css-loader/src/runtime/api.js\n"));

/***/ }),

/***/ "./node_modules/next/dist/build/webpack/loaders/next-client-pages-loader.js?absolutePagePath=C%3A%5CUsers%5CPower%5COneDrive%5CDesktop%5CDemo%20Product%5CCodeTranslate%5Copenai-quickstart-node%5Cpages%5Cindex.js&page=%2F!":
/*!************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-client-pages-loader.js?absolutePagePath=C%3A%5CUsers%5CPower%5COneDrive%5CDesktop%5CDemo%20Product%5CCodeTranslate%5Copenai-quickstart-node%5Cpages%5Cindex.js&page=%2F! ***!
  \************************************************************************************************************************************************************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("\n    (window.__NEXT_P = window.__NEXT_P || []).push([\n      \"/\",\n      function () {\n        return __webpack_require__(/*! ./pages/index.js */ \"./pages/index.js\");\n      }\n    ]);\n    if(true) {\n      module.hot.dispose(function () {\n        window.__NEXT_P.push([\"/\"])\n      });\n    }\n  //# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9uZXh0LWNsaWVudC1wYWdlcy1sb2FkZXIuanM/YWJzb2x1dGVQYWdlUGF0aD1DJTNBJTVDVXNlcnMlNUNQb3dlciU1Q09uZURyaXZlJTVDRGVza3RvcCU1Q0RlbW8lMjBQcm9kdWN0JTVDQ29kZVRyYW5zbGF0ZSU1Q29wZW5haS1xdWlja3N0YXJ0LW5vZGUlNUNwYWdlcyU1Q2luZGV4LmpzJnBhZ2U9JTJGIS5qcyIsIm1hcHBpbmdzIjoiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxtQkFBTyxDQUFDLDBDQUFrQjtBQUN6QztBQUNBO0FBQ0EsT0FBTyxJQUFVO0FBQ2pCLE1BQU0sVUFBVTtBQUNoQjtBQUNBLE9BQU87QUFDUDtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8/YTQyNSJdLCJzb3VyY2VzQ29udGVudCI6WyJcbiAgICAod2luZG93Ll9fTkVYVF9QID0gd2luZG93Ll9fTkVYVF9QIHx8IFtdKS5wdXNoKFtcbiAgICAgIFwiL1wiLFxuICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gcmVxdWlyZShcIi4vcGFnZXMvaW5kZXguanNcIik7XG4gICAgICB9XG4gICAgXSk7XG4gICAgaWYobW9kdWxlLmhvdCkge1xuICAgICAgbW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgd2luZG93Ll9fTkVYVF9QLnB1c2goW1wiL1wiXSlcbiAgICAgIH0pO1xuICAgIH1cbiAgIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/next/dist/build/webpack/loaders/next-client-pages-loader.js?absolutePagePath=C%3A%5CUsers%5CPower%5COneDrive%5CDesktop%5CDemo%20Product%5CCodeTranslate%5Copenai-quickstart-node%5Cpages%5Cindex.js&page=%2F!\n"));

/***/ }),

/***/ "./pages/styles/index.module.css":
/*!***************************************!*\
  !*** ./pages/styles/index.module.css ***!
  \***************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("var api = __webpack_require__(/*! !../../node_modules/next/dist/build/webpack/loaders/next-style-loader/runtime/injectStylesIntoStyleTag.js */ \"./node_modules/next/dist/build/webpack/loaders/next-style-loader/runtime/injectStylesIntoStyleTag.js\");\n            var content = __webpack_require__(/*! !!../../node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[3].oneOf[4].use[1]!../../node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[3].oneOf[4].use[2]!./index.module.css */ \"./node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[3].oneOf[4].use[1]!./node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[3].oneOf[4].use[2]!./pages/styles/index.module.css\");\n\n            content = content.__esModule ? content.default : content;\n\n            if (typeof content === 'string') {\n              content = [[module.id, content, '']];\n            }\n\nvar options = {};\n\noptions.insert = function(element) {\r\n                    // By default, style-loader injects CSS into the bottom\r\n                    // of <head>. This causes ordering problems between dev\r\n                    // and prod. To fix this, we render a <noscript> tag as\r\n                    // an anchor for the styles to be placed before. These\r\n                    // styles will be applied _before_ <style jsx global>.\r\n                    // These elements should always exist. If they do not,\r\n                    // this code should fail.\r\n                    var anchorElement = document.querySelector(\"#__next_css__DO_NOT_USE__\");\r\n                    var parentNode = anchorElement.parentNode// Normally <head>\r\n                    ;\r\n                    // Each style tag should be placed right before our\r\n                    // anchor. By inserting before and not after, we do not\r\n                    // need to track the last inserted element.\r\n                    parentNode.insertBefore(element, anchorElement);\r\n                };\noptions.singleton = false;\n\nvar update = api(content, options);\n\n\nif (true) {\n  if (!content.locals || module.hot.invalidate) {\n    var isEqualLocals = function isEqualLocals(a, b, isNamedExport) {\r\n    if (!a && b || a && !b) {\r\n        return false;\r\n    }\r\n    let p;\r\n    for(p in a){\r\n        if (isNamedExport && p === \"default\") {\r\n            continue;\r\n        }\r\n        if (a[p] !== b[p]) {\r\n            return false;\r\n        }\r\n    }\r\n    for(p in b){\r\n        if (isNamedExport && p === \"default\") {\r\n            continue;\r\n        }\r\n        if (!a[p]) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n};\n    var oldLocals = content.locals;\n\n    module.hot.accept(\n      /*! !!../../node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[3].oneOf[4].use[1]!../../node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[3].oneOf[4].use[2]!./index.module.css */ \"./node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[3].oneOf[4].use[1]!./node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[3].oneOf[4].use[2]!./pages/styles/index.module.css\",\n      function () {\n        content = __webpack_require__(/*! !!../../node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[3].oneOf[4].use[1]!../../node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[3].oneOf[4].use[2]!./index.module.css */ \"./node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[3].oneOf[4].use[1]!./node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[3].oneOf[4].use[2]!./pages/styles/index.module.css\");\n\n              content = content.__esModule ? content.default : content;\n\n              if (typeof content === 'string') {\n                content = [[module.id, content, '']];\n              }\n\n              if (!isEqualLocals(oldLocals, content.locals)) {\n                module.hot.invalidate();\n\n                return;\n              }\n\n              oldLocals = content.locals;\n\n              update(content);\n      }\n    )\n  }\n\n  module.hot.dispose(function() {\n    update();\n  });\n}\n\nmodule.exports = content.locals || {};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9wYWdlcy9zdHlsZXMvaW5kZXgubW9kdWxlLmNzcy5qcyIsIm1hcHBpbmdzIjoiQUFBQSxVQUFVLG1CQUFPLENBQUMsdU5BQTJHO0FBQzdILDBCQUEwQixtQkFBTyxDQUFDLDZmQUEwUDs7QUFFNVI7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBLElBQUksSUFBVTtBQUNkLHlCQUF5QixVQUFVO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxJQUFJLGlCQUFpQjtBQUNyQixNQUFNLDZmQUEwUDtBQUNoUTtBQUNBLGtCQUFrQixtQkFBTyxDQUFDLDZmQUEwUDs7QUFFcFI7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0JBQWdCLFVBQVU7O0FBRTFCO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsRUFBRSxVQUFVO0FBQ1o7QUFDQSxHQUFHO0FBQ0g7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vcGFnZXMvc3R5bGVzL2luZGV4Lm1vZHVsZS5jc3M/NzViMiJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgYXBpID0gcmVxdWlyZShcIiEuLi8uLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9uZXh0LXN0eWxlLWxvYWRlci9ydW50aW1lL2luamVjdFN0eWxlc0ludG9TdHlsZVRhZy5qc1wiKTtcbiAgICAgICAgICAgIHZhciBjb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9idWlsZC93ZWJwYWNrL2xvYWRlcnMvY3NzLWxvYWRlci9zcmMvaW5kZXguanM/P3J1bGVTZXRbMV0ucnVsZXNbM10ub25lT2ZbNF0udXNlWzFdIS4uLy4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL3Bvc3Rjc3MtbG9hZGVyL3NyYy9pbmRleC5qcz8/cnVsZVNldFsxXS5ydWxlc1szXS5vbmVPZls0XS51c2VbMl0hLi9pbmRleC5tb2R1bGUuY3NzXCIpO1xuXG4gICAgICAgICAgICBjb250ZW50ID0gY29udGVudC5fX2VzTW9kdWxlID8gY29udGVudC5kZWZhdWx0IDogY29udGVudDtcblxuICAgICAgICAgICAgaWYgKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG4gICAgICAgICAgICB9XG5cbnZhciBvcHRpb25zID0ge307XG5cbm9wdGlvbnMuaW5zZXJ0ID0gZnVuY3Rpb24oZWxlbWVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIEJ5IGRlZmF1bHQsIHN0eWxlLWxvYWRlciBpbmplY3RzIENTUyBpbnRvIHRoZSBib3R0b21cclxuICAgICAgICAgICAgICAgICAgICAvLyBvZiA8aGVhZD4uIFRoaXMgY2F1c2VzIG9yZGVyaW5nIHByb2JsZW1zIGJldHdlZW4gZGV2XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gYW5kIHByb2QuIFRvIGZpeCB0aGlzLCB3ZSByZW5kZXIgYSA8bm9zY3JpcHQ+IHRhZyBhc1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGFuIGFuY2hvciBmb3IgdGhlIHN0eWxlcyB0byBiZSBwbGFjZWQgYmVmb3JlLiBUaGVzZVxyXG4gICAgICAgICAgICAgICAgICAgIC8vIHN0eWxlcyB3aWxsIGJlIGFwcGxpZWQgX2JlZm9yZV8gPHN0eWxlIGpzeCBnbG9iYWw+LlxyXG4gICAgICAgICAgICAgICAgICAgIC8vIFRoZXNlIGVsZW1lbnRzIHNob3VsZCBhbHdheXMgZXhpc3QuIElmIHRoZXkgZG8gbm90LFxyXG4gICAgICAgICAgICAgICAgICAgIC8vIHRoaXMgY29kZSBzaG91bGQgZmFpbC5cclxuICAgICAgICAgICAgICAgICAgICB2YXIgYW5jaG9yRWxlbWVudCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCIjX19uZXh0X2Nzc19fRE9fTk9UX1VTRV9fXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBwYXJlbnROb2RlID0gYW5jaG9yRWxlbWVudC5wYXJlbnROb2RlLy8gTm9ybWFsbHkgPGhlYWQ+XHJcbiAgICAgICAgICAgICAgICAgICAgO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIEVhY2ggc3R5bGUgdGFnIHNob3VsZCBiZSBwbGFjZWQgcmlnaHQgYmVmb3JlIG91clxyXG4gICAgICAgICAgICAgICAgICAgIC8vIGFuY2hvci4gQnkgaW5zZXJ0aW5nIGJlZm9yZSBhbmQgbm90IGFmdGVyLCB3ZSBkbyBub3RcclxuICAgICAgICAgICAgICAgICAgICAvLyBuZWVkIHRvIHRyYWNrIHRoZSBsYXN0IGluc2VydGVkIGVsZW1lbnQuXHJcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoZWxlbWVudCwgYW5jaG9yRWxlbWVudCk7XHJcbiAgICAgICAgICAgICAgICB9O1xub3B0aW9ucy5zaW5nbGV0b24gPSBmYWxzZTtcblxudmFyIHVwZGF0ZSA9IGFwaShjb250ZW50LCBvcHRpb25zKTtcblxuXG5pZiAobW9kdWxlLmhvdCkge1xuICBpZiAoIWNvbnRlbnQubG9jYWxzIHx8IG1vZHVsZS5ob3QuaW52YWxpZGF0ZSkge1xuICAgIHZhciBpc0VxdWFsTG9jYWxzID0gZnVuY3Rpb24gaXNFcXVhbExvY2FscyhhLCBiLCBpc05hbWVkRXhwb3J0KSB7XHJcbiAgICBpZiAoIWEgJiYgYiB8fCBhICYmICFiKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgbGV0IHA7XHJcbiAgICBmb3IocCBpbiBhKXtcclxuICAgICAgICBpZiAoaXNOYW1lZEV4cG9ydCAmJiBwID09PSBcImRlZmF1bHRcIikge1xyXG4gICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGFbcF0gIT09IGJbcF0pIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGZvcihwIGluIGIpe1xyXG4gICAgICAgIGlmIChpc05hbWVkRXhwb3J0ICYmIHAgPT09IFwiZGVmYXVsdFwiKSB7XHJcbiAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIWFbcF0pIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiB0cnVlO1xyXG59O1xuICAgIHZhciBvbGRMb2NhbHMgPSBjb250ZW50LmxvY2FscztcblxuICAgIG1vZHVsZS5ob3QuYWNjZXB0KFxuICAgICAgXCIhIS4uLy4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL2Nzcy1sb2FkZXIvc3JjL2luZGV4LmpzPz9ydWxlU2V0WzFdLnJ1bGVzWzNdLm9uZU9mWzRdLnVzZVsxXSEuLi8uLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9wb3N0Y3NzLWxvYWRlci9zcmMvaW5kZXguanM/P3J1bGVTZXRbMV0ucnVsZXNbM10ub25lT2ZbNF0udXNlWzJdIS4vaW5kZXgubW9kdWxlLmNzc1wiLFxuICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICBjb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9idWlsZC93ZWJwYWNrL2xvYWRlcnMvY3NzLWxvYWRlci9zcmMvaW5kZXguanM/P3J1bGVTZXRbMV0ucnVsZXNbM10ub25lT2ZbNF0udXNlWzFdIS4uLy4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL3Bvc3Rjc3MtbG9hZGVyL3NyYy9pbmRleC5qcz8/cnVsZVNldFsxXS5ydWxlc1szXS5vbmVPZls0XS51c2VbMl0hLi9pbmRleC5tb2R1bGUuY3NzXCIpO1xuXG4gICAgICAgICAgICAgIGNvbnRlbnQgPSBjb250ZW50Ll9fZXNNb2R1bGUgPyBjb250ZW50LmRlZmF1bHQgOiBjb250ZW50O1xuXG4gICAgICAgICAgICAgIGlmICh0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBpZiAoIWlzRXF1YWxMb2NhbHMob2xkTG9jYWxzLCBjb250ZW50LmxvY2FscykpIHtcbiAgICAgICAgICAgICAgICBtb2R1bGUuaG90LmludmFsaWRhdGUoKTtcblxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIG9sZExvY2FscyA9IGNvbnRlbnQubG9jYWxzO1xuXG4gICAgICAgICAgICAgIHVwZGF0ZShjb250ZW50KTtcbiAgICAgIH1cbiAgICApXG4gIH1cblxuICBtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24oKSB7XG4gICAgdXBkYXRlKCk7XG4gIH0pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNvbnRlbnQubG9jYWxzIHx8IHt9OyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./pages/styles/index.module.css\n"));

/***/ }),

/***/ "./node_modules/next/dist/build/webpack/loaders/next-style-loader/runtime/injectStylesIntoStyleTag.js":
/*!************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-style-loader/runtime/injectStylesIntoStyleTag.js ***!
  \************************************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\r\nconst isOldIE = function isOldIE() {\r\n    let memo;\r\n    return function memorize() {\r\n        if (typeof memo === \"undefined\") {\r\n            // Test for IE <= 9 as proposed by Browserhacks\r\n            // @see http://browserhacks.com/#hack-e71d8692f65334173fee715c222cb805\r\n            // Tests for existence of standard globals is to allow style-loader\r\n            // to operate correctly into non-standard environments\r\n            // @see https://github.com/webpack-contrib/style-loader/issues/177\r\n            memo = Boolean(window && document && document.all && !window.atob);\r\n        }\r\n        return memo;\r\n    };\r\n}();\r\nconst getTarget = function getTarget() {\r\n    const memo = {};\r\n    return function memorize(target) {\r\n        if (typeof memo[target] === \"undefined\") {\r\n            let styleTarget = document.querySelector(target);\r\n            // Special case to return head of iframe instead of iframe itself\r\n            if (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {\r\n                try {\r\n                    // This will throw an exception if access to iframe is blocked\r\n                    // due to cross-origin restrictions\r\n                    styleTarget = styleTarget.contentDocument.head;\r\n                } catch (e) {\r\n                    // istanbul ignore next\r\n                    styleTarget = null;\r\n                }\r\n            }\r\n            memo[target] = styleTarget;\r\n        }\r\n        return memo[target];\r\n    };\r\n}();\r\nconst stylesInDom = [];\r\nfunction getIndexByIdentifier(identifier) {\r\n    let result = -1;\r\n    for(let i = 0; i < stylesInDom.length; i++){\r\n        if (stylesInDom[i].identifier === identifier) {\r\n            result = i;\r\n            break;\r\n        }\r\n    }\r\n    return result;\r\n}\r\nfunction modulesToDom(list, options) {\r\n    const idCountMap = {};\r\n    const identifiers = [];\r\n    for(let i = 0; i < list.length; i++){\r\n        const item = list[i];\r\n        const id = options.base ? item[0] + options.base : item[0];\r\n        const count = idCountMap[id] || 0;\r\n        const identifier = id + \" \" + count.toString();\r\n        idCountMap[id] = count + 1;\r\n        const index = getIndexByIdentifier(identifier);\r\n        const obj = {\r\n            css: item[1],\r\n            media: item[2],\r\n            sourceMap: item[3]\r\n        };\r\n        if (index !== -1) {\r\n            stylesInDom[index].references++;\r\n            stylesInDom[index].updater(obj);\r\n        } else {\r\n            stylesInDom.push({\r\n                identifier: identifier,\r\n                updater: addStyle(obj, options),\r\n                references: 1\r\n            });\r\n        }\r\n        identifiers.push(identifier);\r\n    }\r\n    return identifiers;\r\n}\r\nfunction insertStyleElement(options) {\r\n    const style = document.createElement(\"style\");\r\n    const attributes = options.attributes || {};\r\n    if (typeof attributes.nonce === \"undefined\") {\r\n        const nonce = // eslint-disable-next-line no-undef\r\n         true ? __webpack_require__.nc : 0;\r\n        if (nonce) {\r\n            attributes.nonce = nonce;\r\n        }\r\n    }\r\n    Object.keys(attributes).forEach(function(key) {\r\n        style.setAttribute(key, attributes[key]);\r\n    });\r\n    if (typeof options.insert === \"function\") {\r\n        options.insert(style);\r\n    } else {\r\n        const target = getTarget(options.insert || \"head\");\r\n        if (!target) {\r\n            throw new Error(\"Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.\");\r\n        }\r\n        target.appendChild(style);\r\n    }\r\n    return style;\r\n}\r\nfunction removeStyleElement(style) {\r\n    // istanbul ignore if\r\n    if (style.parentNode === null) {\r\n        return false;\r\n    }\r\n    style.parentNode.removeChild(style);\r\n}\r\n/* istanbul ignore next  */ const replaceText = function replaceText() {\r\n    const textStore = [];\r\n    return function replace(index, replacement) {\r\n        textStore[index] = replacement;\r\n        return textStore.filter(Boolean).join(\"\\n\");\r\n    };\r\n}();\r\nfunction applyToSingletonTag(style, index, remove, obj) {\r\n    const css = remove ? \"\" : obj.media ? \"@media \" + obj.media + \" {\" + obj.css + \"}\" : obj.css;\r\n    // For old IE\r\n    /* istanbul ignore if  */ if (style.styleSheet) {\r\n        style.styleSheet.cssText = replaceText(index, css);\r\n    } else {\r\n        const cssNode = document.createTextNode(css);\r\n        const childNodes = style.childNodes;\r\n        if (childNodes[index]) {\r\n            style.removeChild(childNodes[index]);\r\n        }\r\n        if (childNodes.length) {\r\n            style.insertBefore(cssNode, childNodes[index]);\r\n        } else {\r\n            style.appendChild(cssNode);\r\n        }\r\n    }\r\n}\r\nfunction applyToTag(style, options, obj) {\r\n    let css = obj.css;\r\n    const media = obj.media;\r\n    const sourceMap = obj.sourceMap;\r\n    if (media) {\r\n        style.setAttribute(\"media\", media);\r\n    } else {\r\n        style.removeAttribute(\"media\");\r\n    }\r\n    if (sourceMap && typeof btoa !== \"undefined\") {\r\n        css += \"\\n/*# sourceMappingURL=data:application/json;base64,\" + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + \" */\";\r\n    }\r\n    // For old IE\r\n    /* istanbul ignore if  */ if (style.styleSheet) {\r\n        style.styleSheet.cssText = css;\r\n    } else {\r\n        while(style.firstChild){\r\n            style.removeChild(style.firstChild);\r\n        }\r\n        style.appendChild(document.createTextNode(css));\r\n    }\r\n}\r\nlet singleton = null;\r\nlet singletonCounter = 0;\r\nfunction addStyle(obj, options) {\r\n    let style;\r\n    let update;\r\n    let remove;\r\n    if (options.singleton) {\r\n        const styleIndex = singletonCounter++;\r\n        style = singleton || (singleton = insertStyleElement(options));\r\n        update = applyToSingletonTag.bind(null, style, styleIndex, false);\r\n        remove = applyToSingletonTag.bind(null, style, styleIndex, true);\r\n    } else {\r\n        style = insertStyleElement(options);\r\n        update = applyToTag.bind(null, style, options);\r\n        remove = function() {\r\n            removeStyleElement(style);\r\n        };\r\n    }\r\n    update(obj);\r\n    return function updateStyle(newObj) {\r\n        if (newObj) {\r\n            if (newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap) {\r\n                return;\r\n            }\r\n            update(obj = newObj);\r\n        } else {\r\n            remove();\r\n        }\r\n    };\r\n}\r\nmodule.exports = function(list, options) {\r\n    options = options || {};\r\n    // Force single-tag solution on IE6-9, which has a hard limit on the # of <style>\r\n    // tags it will allow on a page\r\n    if (!options.singleton && typeof options.singleton !== \"boolean\") {\r\n        options.singleton = isOldIE();\r\n    }\r\n    list = list || [];\r\n    let lastIdentifiers = modulesToDom(list, options);\r\n    return function update(newList) {\r\n        newList = newList || [];\r\n        if (Object.prototype.toString.call(newList) !== \"[object Array]\") {\r\n            return;\r\n        }\r\n        for(let i = 0; i < lastIdentifiers.length; i++){\r\n            const identifier = lastIdentifiers[i];\r\n            const index = getIndexByIdentifier(identifier);\r\n            stylesInDom[index].references--;\r\n        }\r\n        const newLastIdentifiers = modulesToDom(newList, options);\r\n        for(let i1 = 0; i1 < lastIdentifiers.length; i1++){\r\n            const identifier = lastIdentifiers[i1];\r\n            const index = getIndexByIdentifier(identifier);\r\n            if (stylesInDom[index].references === 0) {\r\n                stylesInDom[index].updater();\r\n                stylesInDom.splice(index, 1);\r\n            }\r\n        }\r\n        lastIdentifiers = newLastIdentifiers;\r\n    };\r\n};\r\n\r\n//# sourceMappingURL=injectStylesIntoStyleTag.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9uZXh0LXN0eWxlLWxvYWRlci9ydW50aW1lL2luamVjdFN0eWxlc0ludG9TdHlsZVRhZy5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsd0JBQXdCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGlCQUFpQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxLQUF3QyxHQUFHLHNCQUFpQixHQUFHLENBQUk7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EscUVBQXFFLGdCQUFnQjtBQUNyRjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsNkRBQTZEO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLDRCQUE0QjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLDZCQUE2QjtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9idWlsZC93ZWJwYWNrL2xvYWRlcnMvbmV4dC1zdHlsZS1sb2FkZXIvcnVudGltZS9pbmplY3RTdHlsZXNJbnRvU3R5bGVUYWcuanM/MjZlZCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcclxuY29uc3QgaXNPbGRJRSA9IGZ1bmN0aW9uIGlzT2xkSUUoKSB7XHJcbiAgICBsZXQgbWVtbztcclxuICAgIHJldHVybiBmdW5jdGlvbiBtZW1vcml6ZSgpIHtcclxuICAgICAgICBpZiAodHlwZW9mIG1lbW8gPT09IFwidW5kZWZpbmVkXCIpIHtcclxuICAgICAgICAgICAgLy8gVGVzdCBmb3IgSUUgPD0gOSBhcyBwcm9wb3NlZCBieSBCcm93c2VyaGFja3NcclxuICAgICAgICAgICAgLy8gQHNlZSBodHRwOi8vYnJvd3NlcmhhY2tzLmNvbS8jaGFjay1lNzFkODY5MmY2NTMzNDE3M2ZlZTcxNWMyMjJjYjgwNVxyXG4gICAgICAgICAgICAvLyBUZXN0cyBmb3IgZXhpc3RlbmNlIG9mIHN0YW5kYXJkIGdsb2JhbHMgaXMgdG8gYWxsb3cgc3R5bGUtbG9hZGVyXHJcbiAgICAgICAgICAgIC8vIHRvIG9wZXJhdGUgY29ycmVjdGx5IGludG8gbm9uLXN0YW5kYXJkIGVudmlyb25tZW50c1xyXG4gICAgICAgICAgICAvLyBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS93ZWJwYWNrLWNvbnRyaWIvc3R5bGUtbG9hZGVyL2lzc3Vlcy8xNzdcclxuICAgICAgICAgICAgbWVtbyA9IEJvb2xlYW4od2luZG93ICYmIGRvY3VtZW50ICYmIGRvY3VtZW50LmFsbCAmJiAhd2luZG93LmF0b2IpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbWVtbztcclxuICAgIH07XHJcbn0oKTtcclxuY29uc3QgZ2V0VGFyZ2V0ID0gZnVuY3Rpb24gZ2V0VGFyZ2V0KCkge1xyXG4gICAgY29uc3QgbWVtbyA9IHt9O1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIG1lbW9yaXplKHRhcmdldCkge1xyXG4gICAgICAgIGlmICh0eXBlb2YgbWVtb1t0YXJnZXRdID09PSBcInVuZGVmaW5lZFwiKSB7XHJcbiAgICAgICAgICAgIGxldCBzdHlsZVRhcmdldCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IodGFyZ2V0KTtcclxuICAgICAgICAgICAgLy8gU3BlY2lhbCBjYXNlIHRvIHJldHVybiBoZWFkIG9mIGlmcmFtZSBpbnN0ZWFkIG9mIGlmcmFtZSBpdHNlbGZcclxuICAgICAgICAgICAgaWYgKHdpbmRvdy5IVE1MSUZyYW1lRWxlbWVudCAmJiBzdHlsZVRhcmdldCBpbnN0YW5jZW9mIHdpbmRvdy5IVE1MSUZyYW1lRWxlbWVudCkge1xyXG4gICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIHdpbGwgdGhyb3cgYW4gZXhjZXB0aW9uIGlmIGFjY2VzcyB0byBpZnJhbWUgaXMgYmxvY2tlZFxyXG4gICAgICAgICAgICAgICAgICAgIC8vIGR1ZSB0byBjcm9zcy1vcmlnaW4gcmVzdHJpY3Rpb25zXHJcbiAgICAgICAgICAgICAgICAgICAgc3R5bGVUYXJnZXQgPSBzdHlsZVRhcmdldC5jb250ZW50RG9jdW1lbnQuaGVhZDtcclxuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBpc3RhbmJ1bCBpZ25vcmUgbmV4dFxyXG4gICAgICAgICAgICAgICAgICAgIHN0eWxlVGFyZ2V0ID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBtZW1vW3RhcmdldF0gPSBzdHlsZVRhcmdldDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG1lbW9bdGFyZ2V0XTtcclxuICAgIH07XHJcbn0oKTtcclxuY29uc3Qgc3R5bGVzSW5Eb20gPSBbXTtcclxuZnVuY3Rpb24gZ2V0SW5kZXhCeUlkZW50aWZpZXIoaWRlbnRpZmllcikge1xyXG4gICAgbGV0IHJlc3VsdCA9IC0xO1xyXG4gICAgZm9yKGxldCBpID0gMDsgaSA8IHN0eWxlc0luRG9tLmxlbmd0aDsgaSsrKXtcclxuICAgICAgICBpZiAoc3R5bGVzSW5Eb21baV0uaWRlbnRpZmllciA9PT0gaWRlbnRpZmllcikge1xyXG4gICAgICAgICAgICByZXN1bHQgPSBpO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59XHJcbmZ1bmN0aW9uIG1vZHVsZXNUb0RvbShsaXN0LCBvcHRpb25zKSB7XHJcbiAgICBjb25zdCBpZENvdW50TWFwID0ge307XHJcbiAgICBjb25zdCBpZGVudGlmaWVycyA9IFtdO1xyXG4gICAgZm9yKGxldCBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspe1xyXG4gICAgICAgIGNvbnN0IGl0ZW0gPSBsaXN0W2ldO1xyXG4gICAgICAgIGNvbnN0IGlkID0gb3B0aW9ucy5iYXNlID8gaXRlbVswXSArIG9wdGlvbnMuYmFzZSA6IGl0ZW1bMF07XHJcbiAgICAgICAgY29uc3QgY291bnQgPSBpZENvdW50TWFwW2lkXSB8fCAwO1xyXG4gICAgICAgIGNvbnN0IGlkZW50aWZpZXIgPSBpZCArIFwiIFwiICsgY291bnQudG9TdHJpbmcoKTtcclxuICAgICAgICBpZENvdW50TWFwW2lkXSA9IGNvdW50ICsgMTtcclxuICAgICAgICBjb25zdCBpbmRleCA9IGdldEluZGV4QnlJZGVudGlmaWVyKGlkZW50aWZpZXIpO1xyXG4gICAgICAgIGNvbnN0IG9iaiA9IHtcclxuICAgICAgICAgICAgY3NzOiBpdGVtWzFdLFxyXG4gICAgICAgICAgICBtZWRpYTogaXRlbVsyXSxcclxuICAgICAgICAgICAgc291cmNlTWFwOiBpdGVtWzNdXHJcbiAgICAgICAgfTtcclxuICAgICAgICBpZiAoaW5kZXggIT09IC0xKSB7XHJcbiAgICAgICAgICAgIHN0eWxlc0luRG9tW2luZGV4XS5yZWZlcmVuY2VzKys7XHJcbiAgICAgICAgICAgIHN0eWxlc0luRG9tW2luZGV4XS51cGRhdGVyKG9iaik7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgc3R5bGVzSW5Eb20ucHVzaCh7XHJcbiAgICAgICAgICAgICAgICBpZGVudGlmaWVyOiBpZGVudGlmaWVyLFxyXG4gICAgICAgICAgICAgICAgdXBkYXRlcjogYWRkU3R5bGUob2JqLCBvcHRpb25zKSxcclxuICAgICAgICAgICAgICAgIHJlZmVyZW5jZXM6IDFcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlkZW50aWZpZXJzLnB1c2goaWRlbnRpZmllcik7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gaWRlbnRpZmllcnM7XHJcbn1cclxuZnVuY3Rpb24gaW5zZXJ0U3R5bGVFbGVtZW50KG9wdGlvbnMpIHtcclxuICAgIGNvbnN0IHN0eWxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInN0eWxlXCIpO1xyXG4gICAgY29uc3QgYXR0cmlidXRlcyA9IG9wdGlvbnMuYXR0cmlidXRlcyB8fCB7fTtcclxuICAgIGlmICh0eXBlb2YgYXR0cmlidXRlcy5ub25jZSA9PT0gXCJ1bmRlZmluZWRcIikge1xyXG4gICAgICAgIGNvbnN0IG5vbmNlID0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVuZGVmXHJcbiAgICAgICAgdHlwZW9mIF9fd2VicGFja19ub25jZV9fICE9PSBcInVuZGVmaW5lZFwiID8gX193ZWJwYWNrX25vbmNlX18gOiBudWxsO1xyXG4gICAgICAgIGlmIChub25jZSkge1xyXG4gICAgICAgICAgICBhdHRyaWJ1dGVzLm5vbmNlID0gbm9uY2U7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgT2JqZWN0LmtleXMoYXR0cmlidXRlcykuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcclxuICAgICAgICBzdHlsZS5zZXRBdHRyaWJ1dGUoa2V5LCBhdHRyaWJ1dGVzW2tleV0pO1xyXG4gICAgfSk7XHJcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMuaW5zZXJ0ID09PSBcImZ1bmN0aW9uXCIpIHtcclxuICAgICAgICBvcHRpb25zLmluc2VydChzdHlsZSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIGNvbnN0IHRhcmdldCA9IGdldFRhcmdldChvcHRpb25zLmluc2VydCB8fCBcImhlYWRcIik7XHJcbiAgICAgICAgaWYgKCF0YXJnZXQpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ291bGRuJ3QgZmluZCBhIHN0eWxlIHRhcmdldC4gVGhpcyBwcm9iYWJseSBtZWFucyB0aGF0IHRoZSB2YWx1ZSBmb3IgdGhlICdpbnNlcnQnIHBhcmFtZXRlciBpcyBpbnZhbGlkLlwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGFyZ2V0LmFwcGVuZENoaWxkKHN0eWxlKTtcclxuICAgIH1cclxuICAgIHJldHVybiBzdHlsZTtcclxufVxyXG5mdW5jdGlvbiByZW1vdmVTdHlsZUVsZW1lbnQoc3R5bGUpIHtcclxuICAgIC8vIGlzdGFuYnVsIGlnbm9yZSBpZlxyXG4gICAgaWYgKHN0eWxlLnBhcmVudE5vZGUgPT09IG51bGwpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBzdHlsZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHN0eWxlKTtcclxufVxyXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAgKi8gY29uc3QgcmVwbGFjZVRleHQgPSBmdW5jdGlvbiByZXBsYWNlVGV4dCgpIHtcclxuICAgIGNvbnN0IHRleHRTdG9yZSA9IFtdO1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIHJlcGxhY2UoaW5kZXgsIHJlcGxhY2VtZW50KSB7XHJcbiAgICAgICAgdGV4dFN0b3JlW2luZGV4XSA9IHJlcGxhY2VtZW50O1xyXG4gICAgICAgIHJldHVybiB0ZXh0U3RvcmUuZmlsdGVyKEJvb2xlYW4pLmpvaW4oXCJcXG5cIik7XHJcbiAgICB9O1xyXG59KCk7XHJcbmZ1bmN0aW9uIGFwcGx5VG9TaW5nbGV0b25UYWcoc3R5bGUsIGluZGV4LCByZW1vdmUsIG9iaikge1xyXG4gICAgY29uc3QgY3NzID0gcmVtb3ZlID8gXCJcIiA6IG9iai5tZWRpYSA/IFwiQG1lZGlhIFwiICsgb2JqLm1lZGlhICsgXCIge1wiICsgb2JqLmNzcyArIFwifVwiIDogb2JqLmNzcztcclxuICAgIC8vIEZvciBvbGQgSUVcclxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAgKi8gaWYgKHN0eWxlLnN0eWxlU2hlZXQpIHtcclxuICAgICAgICBzdHlsZS5zdHlsZVNoZWV0LmNzc1RleHQgPSByZXBsYWNlVGV4dChpbmRleCwgY3NzKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgY29uc3QgY3NzTm9kZSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNzcyk7XHJcbiAgICAgICAgY29uc3QgY2hpbGROb2RlcyA9IHN0eWxlLmNoaWxkTm9kZXM7XHJcbiAgICAgICAgaWYgKGNoaWxkTm9kZXNbaW5kZXhdKSB7XHJcbiAgICAgICAgICAgIHN0eWxlLnJlbW92ZUNoaWxkKGNoaWxkTm9kZXNbaW5kZXhdKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGNoaWxkTm9kZXMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHN0eWxlLmluc2VydEJlZm9yZShjc3NOb2RlLCBjaGlsZE5vZGVzW2luZGV4XSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgc3R5bGUuYXBwZW5kQ2hpbGQoY3NzTm9kZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGFwcGx5VG9UYWcoc3R5bGUsIG9wdGlvbnMsIG9iaikge1xyXG4gICAgbGV0IGNzcyA9IG9iai5jc3M7XHJcbiAgICBjb25zdCBtZWRpYSA9IG9iai5tZWRpYTtcclxuICAgIGNvbnN0IHNvdXJjZU1hcCA9IG9iai5zb3VyY2VNYXA7XHJcbiAgICBpZiAobWVkaWEpIHtcclxuICAgICAgICBzdHlsZS5zZXRBdHRyaWJ1dGUoXCJtZWRpYVwiLCBtZWRpYSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIHN0eWxlLnJlbW92ZUF0dHJpYnV0ZShcIm1lZGlhXCIpO1xyXG4gICAgfVxyXG4gICAgaWYgKHNvdXJjZU1hcCAmJiB0eXBlb2YgYnRvYSAhPT0gXCJ1bmRlZmluZWRcIikge1xyXG4gICAgICAgIGNzcyArPSBcIlxcbi8qIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsXCIgKyBidG9hKHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChKU09OLnN0cmluZ2lmeShzb3VyY2VNYXApKSkpICsgXCIgKi9cIjtcclxuICAgIH1cclxuICAgIC8vIEZvciBvbGQgSUVcclxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAgKi8gaWYgKHN0eWxlLnN0eWxlU2hlZXQpIHtcclxuICAgICAgICBzdHlsZS5zdHlsZVNoZWV0LmNzc1RleHQgPSBjc3M7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIHdoaWxlKHN0eWxlLmZpcnN0Q2hpbGQpe1xyXG4gICAgICAgICAgICBzdHlsZS5yZW1vdmVDaGlsZChzdHlsZS5maXJzdENoaWxkKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgc3R5bGUuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY3NzKSk7XHJcbiAgICB9XHJcbn1cclxubGV0IHNpbmdsZXRvbiA9IG51bGw7XHJcbmxldCBzaW5nbGV0b25Db3VudGVyID0gMDtcclxuZnVuY3Rpb24gYWRkU3R5bGUob2JqLCBvcHRpb25zKSB7XHJcbiAgICBsZXQgc3R5bGU7XHJcbiAgICBsZXQgdXBkYXRlO1xyXG4gICAgbGV0IHJlbW92ZTtcclxuICAgIGlmIChvcHRpb25zLnNpbmdsZXRvbikge1xyXG4gICAgICAgIGNvbnN0IHN0eWxlSW5kZXggPSBzaW5nbGV0b25Db3VudGVyKys7XHJcbiAgICAgICAgc3R5bGUgPSBzaW5nbGV0b24gfHwgKHNpbmdsZXRvbiA9IGluc2VydFN0eWxlRWxlbWVudChvcHRpb25zKSk7XHJcbiAgICAgICAgdXBkYXRlID0gYXBwbHlUb1NpbmdsZXRvblRhZy5iaW5kKG51bGwsIHN0eWxlLCBzdHlsZUluZGV4LCBmYWxzZSk7XHJcbiAgICAgICAgcmVtb3ZlID0gYXBwbHlUb1NpbmdsZXRvblRhZy5iaW5kKG51bGwsIHN0eWxlLCBzdHlsZUluZGV4LCB0cnVlKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgc3R5bGUgPSBpbnNlcnRTdHlsZUVsZW1lbnQob3B0aW9ucyk7XHJcbiAgICAgICAgdXBkYXRlID0gYXBwbHlUb1RhZy5iaW5kKG51bGwsIHN0eWxlLCBvcHRpb25zKTtcclxuICAgICAgICByZW1vdmUgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgcmVtb3ZlU3R5bGVFbGVtZW50KHN0eWxlKTtcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgdXBkYXRlKG9iaik7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gdXBkYXRlU3R5bGUobmV3T2JqKSB7XHJcbiAgICAgICAgaWYgKG5ld09iaikge1xyXG4gICAgICAgICAgICBpZiAobmV3T2JqLmNzcyA9PT0gb2JqLmNzcyAmJiBuZXdPYmoubWVkaWEgPT09IG9iai5tZWRpYSAmJiBuZXdPYmouc291cmNlTWFwID09PSBvYmouc291cmNlTWFwKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdXBkYXRlKG9iaiA9IG5ld09iaik7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmVtb3ZlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxufVxyXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGxpc3QsIG9wdGlvbnMpIHtcclxuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xyXG4gICAgLy8gRm9yY2Ugc2luZ2xlLXRhZyBzb2x1dGlvbiBvbiBJRTYtOSwgd2hpY2ggaGFzIGEgaGFyZCBsaW1pdCBvbiB0aGUgIyBvZiA8c3R5bGU+XHJcbiAgICAvLyB0YWdzIGl0IHdpbGwgYWxsb3cgb24gYSBwYWdlXHJcbiAgICBpZiAoIW9wdGlvbnMuc2luZ2xldG9uICYmIHR5cGVvZiBvcHRpb25zLnNpbmdsZXRvbiAhPT0gXCJib29sZWFuXCIpIHtcclxuICAgICAgICBvcHRpb25zLnNpbmdsZXRvbiA9IGlzT2xkSUUoKTtcclxuICAgIH1cclxuICAgIGxpc3QgPSBsaXN0IHx8IFtdO1xyXG4gICAgbGV0IGxhc3RJZGVudGlmaWVycyA9IG1vZHVsZXNUb0RvbShsaXN0LCBvcHRpb25zKTtcclxuICAgIHJldHVybiBmdW5jdGlvbiB1cGRhdGUobmV3TGlzdCkge1xyXG4gICAgICAgIG5ld0xpc3QgPSBuZXdMaXN0IHx8IFtdO1xyXG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobmV3TGlzdCkgIT09IFwiW29iamVjdCBBcnJheV1cIikge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvcihsZXQgaSA9IDA7IGkgPCBsYXN0SWRlbnRpZmllcnMubGVuZ3RoOyBpKyspe1xyXG4gICAgICAgICAgICBjb25zdCBpZGVudGlmaWVyID0gbGFzdElkZW50aWZpZXJzW2ldO1xyXG4gICAgICAgICAgICBjb25zdCBpbmRleCA9IGdldEluZGV4QnlJZGVudGlmaWVyKGlkZW50aWZpZXIpO1xyXG4gICAgICAgICAgICBzdHlsZXNJbkRvbVtpbmRleF0ucmVmZXJlbmNlcy0tO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBuZXdMYXN0SWRlbnRpZmllcnMgPSBtb2R1bGVzVG9Eb20obmV3TGlzdCwgb3B0aW9ucyk7XHJcbiAgICAgICAgZm9yKGxldCBpMSA9IDA7IGkxIDwgbGFzdElkZW50aWZpZXJzLmxlbmd0aDsgaTErKyl7XHJcbiAgICAgICAgICAgIGNvbnN0IGlkZW50aWZpZXIgPSBsYXN0SWRlbnRpZmllcnNbaTFdO1xyXG4gICAgICAgICAgICBjb25zdCBpbmRleCA9IGdldEluZGV4QnlJZGVudGlmaWVyKGlkZW50aWZpZXIpO1xyXG4gICAgICAgICAgICBpZiAoc3R5bGVzSW5Eb21baW5kZXhdLnJlZmVyZW5jZXMgPT09IDApIHtcclxuICAgICAgICAgICAgICAgIHN0eWxlc0luRG9tW2luZGV4XS51cGRhdGVyKCk7XHJcbiAgICAgICAgICAgICAgICBzdHlsZXNJbkRvbS5zcGxpY2UoaW5kZXgsIDEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxhc3RJZGVudGlmaWVycyA9IG5ld0xhc3RJZGVudGlmaWVycztcclxuICAgIH07XHJcbn07XHJcblxyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmplY3RTdHlsZXNJbnRvU3R5bGVUYWcuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/next/dist/build/webpack/loaders/next-style-loader/runtime/injectStylesIntoStyleTag.js\n"));

/***/ }),

/***/ "./pages/index.js":
/*!************************!*\
  !*** ./pages/index.js ***!
  \************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ Home; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"./node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var next_head__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! next/head */ \"./node_modules/next/head.js\");\n/* harmony import */ var next_head__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(next_head__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _styles_index_module_css__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./styles/index.module.css */ \"./pages/styles/index.module.css\");\n/* harmony import */ var _styles_index_module_css__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_styles_index_module_css__WEBPACK_IMPORTED_MODULE_5__);\n/* harmony import */ var _textarea__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./textarea */ \"./pages/textarea.jsx\");\n/* harmony import */ var _uiw_react_codemirror__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @uiw/react-codemirror */ \"./node_modules/@uiw/react-codemirror/esm/index.js\");\n\nvar _s = $RefreshSig$();\n\n\n\n\n\n\nfunction Home() {\n    _s();\n    const [language, setLanguage] = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)(\"C++\");\n    const [code, setCode] = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)(\"\");\n    const [loading, setLoading] = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)(false);\n    const [result, setResult] = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)(\"\");\n    async function onSubmit(event) {\n        event.preventDefault();\n        if (code.trim().length == 0) {\n            setResult(\"Please enter your code!\");\n            return;\n        }\n        if (loading) {\n            return;\n        }\n        setLoading(true);\n        setResult(\"\");\n        const response = await fetch(\"/api/generate\", {\n            method: \"POST\",\n            headers: {\n                \"Content-Type\": \"application/json\"\n            },\n            body: JSON.stringify({\n                language,\n                code\n            })\n        });\n        const data = await response.json();\n        setResult(data.result);\n        setLoading(false);\n    }\n    ;\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)((next_head__WEBPACK_IMPORTED_MODULE_1___default()), {\n                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"title\", {\n                    children: \"Code Translator\"\n                }, void 0, false, {\n                    fileName: \"C:\\\\Users\\\\Power\\\\OneDrive\\\\Desktop\\\\Demo Product\\\\CodeTranslate\\\\openai-quickstart-node\\\\pages\\\\index.js\",\n                    lineNumber: 43,\n                    columnNumber: 9\n                }, this)\n            }, void 0, false, {\n                fileName: \"C:\\\\Users\\\\Power\\\\OneDrive\\\\Desktop\\\\Demo Product\\\\CodeTranslate\\\\openai-quickstart-node\\\\pages\\\\index.js\",\n                lineNumber: 42,\n                columnNumber: 7\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"container\",\n                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"main\", {\n                    className: (_styles_index_module_css__WEBPACK_IMPORTED_MODULE_5___default().main),\n                    children: [\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h1\", {\n                            children: \"Code Translator\"\n                        }, void 0, false, {\n                            fileName: \"C:\\\\Users\\\\Power\\\\OneDrive\\\\Desktop\\\\Demo Product\\\\CodeTranslate\\\\openai-quickstart-node\\\\pages\\\\index.js\",\n                            lineNumber: 47,\n                            columnNumber: 11\n                        }, this),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"form\", {\n                            onSubmit: onSubmit,\n                            children: [\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                    className: \"lang\",\n                                    children: [\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"label\", {\n                                            children: \"Programming Language\"\n                                        }, void 0, false, {\n                                            fileName: \"C:\\\\Users\\\\Power\\\\OneDrive\\\\Desktop\\\\Demo Product\\\\CodeTranslate\\\\openai-quickstart-node\\\\pages\\\\index.js\",\n                                            lineNumber: 51,\n                                            columnNumber: 15\n                                        }, this),\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"select\", {\n                                            name: \"Programming Language\",\n                                            value: language,\n                                            onChange: (e)=>setLanguage(e.target.value),\n                                            children: [\n                                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"option\", {\n                                                    value: \"c++\",\n                                                    children: \"C++\"\n                                                }, void 0, false, {\n                                                    fileName: \"C:\\\\Users\\\\Power\\\\OneDrive\\\\Desktop\\\\Demo Product\\\\CodeTranslate\\\\openai-quickstart-node\\\\pages\\\\index.js\",\n                                                    lineNumber: 57,\n                                                    columnNumber: 17\n                                                }, this),\n                                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"option\", {\n                                                    value: \"java\",\n                                                    children: \"Java\"\n                                                }, void 0, false, {\n                                                    fileName: \"C:\\\\Users\\\\Power\\\\OneDrive\\\\Desktop\\\\Demo Product\\\\CodeTranslate\\\\openai-quickstart-node\\\\pages\\\\index.js\",\n                                                    lineNumber: 58,\n                                                    columnNumber: 17\n                                                }, this),\n                                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"option\", {\n                                                    value: \"Python2\",\n                                                    children: \"Python\"\n                                                }, void 0, false, {\n                                                    fileName: \"C:\\\\Users\\\\Power\\\\OneDrive\\\\Desktop\\\\Demo Product\\\\CodeTranslate\\\\openai-quickstart-node\\\\pages\\\\index.js\",\n                                                    lineNumber: 59,\n                                                    columnNumber: 17\n                                                }, this),\n                                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"option\", {\n                                                    value: \"Python3\",\n                                                    children: \"Python3\"\n                                                }, void 0, false, {\n                                                    fileName: \"C:\\\\Users\\\\Power\\\\OneDrive\\\\Desktop\\\\Demo Product\\\\CodeTranslate\\\\openai-quickstart-node\\\\pages\\\\index.js\",\n                                                    lineNumber: 60,\n                                                    columnNumber: 17\n                                                }, this),\n                                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"option\", {\n                                                    value: \"C\",\n                                                    children: \"C\"\n                                                }, void 0, false, {\n                                                    fileName: \"C:\\\\Users\\\\Power\\\\OneDrive\\\\Desktop\\\\Demo Product\\\\CodeTranslate\\\\openai-quickstart-node\\\\pages\\\\index.js\",\n                                                    lineNumber: 61,\n                                                    columnNumber: 17\n                                                }, this),\n                                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"option\", {\n                                                    value: \"C#\",\n                                                    children: \"Java\"\n                                                }, void 0, false, {\n                                                    fileName: \"C:\\\\Users\\\\Power\\\\OneDrive\\\\Desktop\\\\Demo Product\\\\CodeTranslate\\\\openai-quickstart-node\\\\pages\\\\index.js\",\n                                                    lineNumber: 62,\n                                                    columnNumber: 17\n                                                }, this),\n                                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"option\", {\n                                                    value: \"Javascript\",\n                                                    children: \"Javascript\"\n                                                }, void 0, false, {\n                                                    fileName: \"C:\\\\Users\\\\Power\\\\OneDrive\\\\Desktop\\\\Demo Product\\\\CodeTranslate\\\\openai-quickstart-node\\\\pages\\\\index.js\",\n                                                    lineNumber: 63,\n                                                    columnNumber: 17\n                                                }, this),\n                                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"option\", {\n                                                    value: \"Ruby\",\n                                                    children: \"Ruby\"\n                                                }, void 0, false, {\n                                                    fileName: \"C:\\\\Users\\\\Power\\\\OneDrive\\\\Desktop\\\\Demo Product\\\\CodeTranslate\\\\openai-quickstart-node\\\\pages\\\\index.js\",\n                                                    lineNumber: 64,\n                                                    columnNumber: 17\n                                                }, this),\n                                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"option\", {\n                                                    value: \"Swift\",\n                                                    children: \"Swift\"\n                                                }, void 0, false, {\n                                                    fileName: \"C:\\\\Users\\\\Power\\\\OneDrive\\\\Desktop\\\\Demo Product\\\\CodeTranslate\\\\openai-quickstart-node\\\\pages\\\\index.js\",\n                                                    lineNumber: 65,\n                                                    columnNumber: 17\n                                                }, this),\n                                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"option\", {\n                                                    value: \"Go\",\n                                                    children: \"Go\"\n                                                }, void 0, false, {\n                                                    fileName: \"C:\\\\Users\\\\Power\\\\OneDrive\\\\Desktop\\\\Demo Product\\\\CodeTranslate\\\\openai-quickstart-node\\\\pages\\\\index.js\",\n                                                    lineNumber: 66,\n                                                    columnNumber: 17\n                                                }, this),\n                                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"option\", {\n                                                    value: \"Scala\",\n                                                    children: \"Scala\"\n                                                }, void 0, false, {\n                                                    fileName: \"C:\\\\Users\\\\Power\\\\OneDrive\\\\Desktop\\\\Demo Product\\\\CodeTranslate\\\\openai-quickstart-node\\\\pages\\\\index.js\",\n                                                    lineNumber: 67,\n                                                    columnNumber: 17\n                                                }, this),\n                                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"option\", {\n                                                    value: \"Kotlin\",\n                                                    children: \"Kotlin\"\n                                                }, void 0, false, {\n                                                    fileName: \"C:\\\\Users\\\\Power\\\\OneDrive\\\\Desktop\\\\Demo Product\\\\CodeTranslate\\\\openai-quickstart-node\\\\pages\\\\index.js\",\n                                                    lineNumber: 68,\n                                                    columnNumber: 17\n                                                }, this),\n                                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"option\", {\n                                                    value: \"PHP\",\n                                                    children: \"PHP\"\n                                                }, void 0, false, {\n                                                    fileName: \"C:\\\\Users\\\\Power\\\\OneDrive\\\\Desktop\\\\Demo Product\\\\CodeTranslate\\\\openai-quickstart-node\\\\pages\\\\index.js\",\n                                                    lineNumber: 69,\n                                                    columnNumber: 17\n                                                }, this),\n                                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"option\", {\n                                                    value: \"Rust\",\n                                                    children: \"Rust\"\n                                                }, void 0, false, {\n                                                    fileName: \"C:\\\\Users\\\\Power\\\\OneDrive\\\\Desktop\\\\Demo Product\\\\CodeTranslate\\\\openai-quickstart-node\\\\pages\\\\index.js\",\n                                                    lineNumber: 70,\n                                                    columnNumber: 17\n                                                }, this),\n                                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"option\", {\n                                                    value: \"Typescript\",\n                                                    children: \"Typescript\"\n                                                }, void 0, false, {\n                                                    fileName: \"C:\\\\Users\\\\Power\\\\OneDrive\\\\Desktop\\\\Demo Product\\\\CodeTranslate\\\\openai-quickstart-node\\\\pages\\\\index.js\",\n                                                    lineNumber: 71,\n                                                    columnNumber: 17\n                                                }, this),\n                                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"option\", {\n                                                    value: \"Erlang\",\n                                                    children: \"Erlang\"\n                                                }, void 0, false, {\n                                                    fileName: \"C:\\\\Users\\\\Power\\\\OneDrive\\\\Desktop\\\\Demo Product\\\\CodeTranslate\\\\openai-quickstart-node\\\\pages\\\\index.js\",\n                                                    lineNumber: 72,\n                                                    columnNumber: 17\n                                                }, this),\n                                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"option\", {\n                                                    value: \"Elixir\",\n                                                    children: \"Elixir\"\n                                                }, void 0, false, {\n                                                    fileName: \"C:\\\\Users\\\\Power\\\\OneDrive\\\\Desktop\\\\Demo Product\\\\CodeTranslate\\\\openai-quickstart-node\\\\pages\\\\index.js\",\n                                                    lineNumber: 73,\n                                                    columnNumber: 17\n                                                }, this),\n                                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"option\", {\n                                                    value: \"Racket\",\n                                                    children: \"Racket\"\n                                                }, void 0, false, {\n                                                    fileName: \"C:\\\\Users\\\\Power\\\\OneDrive\\\\Desktop\\\\Demo Product\\\\CodeTranslate\\\\openai-quickstart-node\\\\pages\\\\index.js\",\n                                                    lineNumber: 74,\n                                                    columnNumber: 17\n                                                }, this),\n                                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"option\", {\n                                                    value: \"Dart\",\n                                                    children: \"Dart\"\n                                                }, void 0, false, {\n                                                    fileName: \"C:\\\\Users\\\\Power\\\\OneDrive\\\\Desktop\\\\Demo Product\\\\CodeTranslate\\\\openai-quickstart-node\\\\pages\\\\index.js\",\n                                                    lineNumber: 75,\n                                                    columnNumber: 17\n                                                }, this)\n                                            ]\n                                        }, void 0, true, {\n                                            fileName: \"C:\\\\Users\\\\Power\\\\OneDrive\\\\Desktop\\\\Demo Product\\\\CodeTranslate\\\\openai-quickstart-node\\\\pages\\\\index.js\",\n                                            lineNumber: 52,\n                                            columnNumber: 15\n                                        }, this)\n                                    ]\n                                }, void 0, true, {\n                                    fileName: \"C:\\\\Users\\\\Power\\\\OneDrive\\\\Desktop\\\\Demo Product\\\\CodeTranslate\\\\openai-quickstart-node\\\\pages\\\\index.js\",\n                                    lineNumber: 50,\n                                    columnNumber: 13\n                                }, this),\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                    className: \"codebox\",\n                                    children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_uiw_react_codemirror__WEBPACK_IMPORTED_MODULE_4__[\"default\"], {\n                                        value: code,\n                                        options: {\n                                            theme: \"dracula\",\n                                            keyMap: \"sublime\",\n                                            mode: \"python\"\n                                        },\n                                        onChange: (editor, data, value)=>{\n                                            setCode(editor);\n                                        },\n                                        className: \"w-96 h-80\"\n                                    }, void 0, false, {\n                                        fileName: \"C:\\\\Users\\\\Power\\\\OneDrive\\\\Desktop\\\\Demo Product\\\\CodeTranslate\\\\openai-quickstart-node\\\\pages\\\\index.js\",\n                                        lineNumber: 80,\n                                        columnNumber: 15\n                                    }, this)\n                                }, void 0, false, {\n                                    fileName: \"C:\\\\Users\\\\Power\\\\OneDrive\\\\Desktop\\\\Demo Product\\\\CodeTranslate\\\\openai-quickstart-node\\\\pages\\\\index.js\",\n                                    lineNumber: 79,\n                                    columnNumber: 13\n                                }, this),\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"input\", {\n                                    className: \"btn\",\n                                    type: \"submit\",\n                                    value: \"Translate Code\"\n                                }, void 0, false, {\n                                    fileName: \"C:\\\\Users\\\\Power\\\\OneDrive\\\\Desktop\\\\Demo Product\\\\CodeTranslate\\\\openai-quickstart-node\\\\pages\\\\index.js\",\n                                    lineNumber: 96,\n                                    columnNumber: 13\n                                }, this)\n                            ]\n                        }, void 0, true, {\n                            fileName: \"C:\\\\Users\\\\Power\\\\OneDrive\\\\Desktop\\\\Demo Product\\\\CodeTranslate\\\\openai-quickstart-node\\\\pages\\\\index.js\",\n                            lineNumber: 49,\n                            columnNumber: 11\n                        }, this),\n                        loading && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            children: [\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h3\", {\n                                    children: \"Translating Code\"\n                                }, void 0, false, {\n                                    fileName: \"C:\\\\Users\\\\Power\\\\OneDrive\\\\Desktop\\\\Demo Product\\\\CodeTranslate\\\\openai-quickstart-node\\\\pages\\\\index.js\",\n                                    lineNumber: 100,\n                                    columnNumber: 15\n                                }, this),\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                                    children: \"Loading...\"\n                                }, void 0, false, {\n                                    fileName: \"C:\\\\Users\\\\Power\\\\OneDrive\\\\Desktop\\\\Demo Product\\\\CodeTranslate\\\\openai-quickstart-node\\\\pages\\\\index.js\",\n                                    lineNumber: 101,\n                                    columnNumber: 15\n                                }, this)\n                            ]\n                        }, void 0, true, {\n                            fileName: \"C:\\\\Users\\\\Power\\\\OneDrive\\\\Desktop\\\\Demo Product\\\\CodeTranslate\\\\openai-quickstart-node\\\\pages\\\\index.js\",\n                            lineNumber: 99,\n                            columnNumber: 13\n                        }, this),\n                        !loading && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_textarea__WEBPACK_IMPORTED_MODULE_3__[\"default\"], {\n                            value: result\n                        }, void 0, false, {\n                            fileName: \"C:\\\\Users\\\\Power\\\\OneDrive\\\\Desktop\\\\Demo Product\\\\CodeTranslate\\\\openai-quickstart-node\\\\pages\\\\index.js\",\n                            lineNumber: 105,\n                            columnNumber: 13\n                        }, this)\n                    ]\n                }, void 0, true, {\n                    fileName: \"C:\\\\Users\\\\Power\\\\OneDrive\\\\Desktop\\\\Demo Product\\\\CodeTranslate\\\\openai-quickstart-node\\\\pages\\\\index.js\",\n                    lineNumber: 46,\n                    columnNumber: 9\n                }, this)\n            }, void 0, false, {\n                fileName: \"C:\\\\Users\\\\Power\\\\OneDrive\\\\Desktop\\\\Demo Product\\\\CodeTranslate\\\\openai-quickstart-node\\\\pages\\\\index.js\",\n                lineNumber: 45,\n                columnNumber: 7\n            }, this)\n        ]\n    }, void 0, true, {\n        fileName: \"C:\\\\Users\\\\Power\\\\OneDrive\\\\Desktop\\\\Demo Product\\\\CodeTranslate\\\\openai-quickstart-node\\\\pages\\\\index.js\",\n        lineNumber: 41,\n        columnNumber: 5\n    }, this);\n}\n_s(Home, \"2qsoaHHMb1jWswbbwclDsVUWbbg=\");\n_c = Home;\nvar _c;\n$RefreshReg$(_c, \"Home\");\n\n\n;\r\n    // Wrapped in an IIFE to avoid polluting the global scope\r\n    ;\r\n    (function () {\r\n        var _a, _b;\r\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\r\n        // to extract CSS. For backwards compatibility, we need to check we're in a\r\n        // browser context before continuing.\r\n        if (typeof self !== 'undefined' &&\r\n            // AMP / No-JS mode does not inject these helpers:\r\n            '$RefreshHelpers$' in self) {\r\n            // @ts-ignore __webpack_module__ is global\r\n            var currentExports = module.exports;\r\n            // @ts-ignore __webpack_module__ is global\r\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\r\n            // This cannot happen in MainTemplate because the exports mismatch between\r\n            // templating and execution.\r\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\r\n            // A module can be accepted automatically based on its exports, e.g. when\r\n            // it is a Refresh Boundary.\r\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\r\n                // Save the previous exports on update so we can compare the boundary\r\n                // signatures.\r\n                module.hot.dispose(function (data) {\r\n                    data.prevExports = currentExports;\r\n                });\r\n                // Unconditionally accept an update to this module, we'll check if it's\r\n                // still a Refresh Boundary later.\r\n                // @ts-ignore importMeta is replaced in the loader\r\n                module.hot.accept();\r\n                // This field is set when the previous version of this module was a\r\n                // Refresh Boundary, letting us know we need to check for invalidation or\r\n                // enqueue an update.\r\n                if (prevExports !== null) {\r\n                    // A boundary can become ineligible if its exports are incompatible\r\n                    // with the previous exports.\r\n                    //\r\n                    // For example, if you add/remove/change exports, we'll want to\r\n                    // re-execute the importing modules, and force those components to\r\n                    // re-render. Similarly, if you convert a class component to a\r\n                    // function, we want to invalidate the boundary.\r\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\r\n                        module.hot.invalidate();\r\n                    }\r\n                    else {\r\n                        self.$RefreshHelpers$.scheduleUpdate();\r\n                    }\r\n                }\r\n            }\r\n            else {\r\n                // Since we just executed the code for the module, it's possible that the\r\n                // new exports made it ineligible for being a boundary.\r\n                // We only care about the case when we were _previously_ a boundary,\r\n                // because we already accepted this update (accidental side effect).\r\n                var isNoLongerABoundary = prevExports !== null;\r\n                if (isNoLongerABoundary) {\r\n                    module.hot.invalidate();\r\n                }\r\n            }\r\n        }\r\n    })();\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QU83Qjt3Q0FDUGtDLFNBQVM7NENBQ1BDLE9BQU87NENBQ1BDLFFBQVE7NENBQ1JDLE1BQU07d0NBQ1I7d0NBQ0FQLFVBQVUsQ0FBQ1EsUUFBUXBCLE1BQU1XLFFBQVU7NENBQ2pDNUIsUUFBUXFDO3dDQUNWO3dDQUNBaEIsV0FBVTs7Ozs7Ozs7Ozs7OENBTWQsOERBQUNpQjtvQ0FBTWpCLFdBQVc7b0NBQU1rQixNQUFLO29DQUFTWCxPQUFNOzs7Ozs7Ozs7Ozs7d0JBRTVDM0IseUJBQ0EsOERBQUNrQjs7OENBQ0MsOERBQUNxQjs4Q0FBRzs7Ozs7OzhDQUNKLDhEQUFDQzs4Q0FBRTs7Ozs7Ozs7Ozs7O3dCQUdOLENBQUN4Qyx5QkFDQSw4REFBQ1AsaURBQVFBOzRCQUFDa0MsT0FBT3pCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQVE3QixDQUFDO0dBekd1QlA7S0FBQUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vcGFnZXMvaW5kZXguanM/YmVlNyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgSGVhZCBmcm9tICduZXh0L2hlYWQnO1xyXG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xyXG5pbXBvcnQgeyB1c2VTdGF0ZSB9IGZyb20gJ3JlYWN0JztcclxuaW1wb3J0IHN0eWxlcyBmcm9tICcuL3N0eWxlcy9pbmRleC5tb2R1bGUuY3NzJztcclxuaW1wb3J0IFRleHRhcmVhIGZyb20gJy4vdGV4dGFyZWEnO1xyXG5pbXBvcnQgQ29kZU1pcnJvciBmcm9tICdAdWl3L3JlYWN0LWNvZGVtaXJyb3InO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gSG9tZSgpIHtcclxuICBjb25zdCBbbGFuZ3VhZ2UsIHNldExhbmd1YWdlXSA9IHVzZVN0YXRlKCdDKysnKTtcclxuICBjb25zdCBbY29kZSwgc2V0Q29kZV0gPSB1c2VTdGF0ZSgnJyk7XHJcbiAgY29uc3QgW2xvYWRpbmcsIHNldExvYWRpbmddID0gdXNlU3RhdGUoZmFsc2UpO1xyXG5cclxuICBjb25zdCBbcmVzdWx0LCBzZXRSZXN1bHRdID0gdXNlU3RhdGUoJycpO1xyXG5cclxuICBhc3luYyBmdW5jdGlvbiBvblN1Ym1pdChldmVudCkge1xyXG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcclxuICAgIGlmKGNvZGUudHJpbSgpLmxlbmd0aCA9PSAwKXtcclxuICAgICAgc2V0UmVzdWx0KCdQbGVhc2UgZW50ZXIgeW91ciBjb2RlIScpXHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGlmIChsb2FkaW5nKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIHNldExvYWRpbmcodHJ1ZSk7XHJcbiAgICBzZXRSZXN1bHQoJycpO1xyXG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCgnL2FwaS9nZW5lcmF0ZScsIHtcclxuICAgICAgbWV0aG9kOiAnUE9TVCcsXHJcbiAgICAgIGhlYWRlcnM6IHtcclxuICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxyXG4gICAgICB9LFxyXG4gICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7bGFuZ3VhZ2UsIGNvZGUgfSksXHJcbiAgICB9KTtcclxuICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XHJcbiAgICBzZXRSZXN1bHQoZGF0YS5yZXN1bHQpO1xyXG4gICAgc2V0TG9hZGluZyhmYWxzZSk7XHJcbiAgfTtcclxuXHJcbiAgXHJcblxyXG4gIHJldHVybiAoXHJcbiAgICA8ZGl2PlxyXG4gICAgICA8SGVhZD5cclxuICAgICAgICA8dGl0bGU+Q29kZSBUcmFuc2xhdG9yPC90aXRsZT5cclxuICAgICAgPC9IZWFkPlxyXG4gICAgICA8ZGl2IGNsYXNzTmFtZT0nY29udGFpbmVyJz5cclxuICAgICAgICA8bWFpbiBjbGFzc05hbWU9e3N0eWxlcy5tYWlufT5cclxuICAgICAgICAgIDxoMT5Db2RlIFRyYW5zbGF0b3I8L2gxPlxyXG4gICAgICAgICAgXHJcbiAgICAgICAgICA8Zm9ybSBvblN1Ym1pdD17b25TdWJtaXR9PlxyXG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImxhbmdcIj5cclxuICAgICAgICAgICAgICA8bGFiZWw+UHJvZ3JhbW1pbmcgTGFuZ3VhZ2U8L2xhYmVsPlxyXG4gICAgICAgICAgICAgIDxzZWxlY3RcclxuICAgICAgICAgICAgICAgIG5hbWU9XCJQcm9ncmFtbWluZyBMYW5ndWFnZVwiXHJcbiAgICAgICAgICAgICAgICB2YWx1ZT17bGFuZ3VhZ2V9XHJcbiAgICAgICAgICAgICAgICBvbkNoYW5nZT17KGUpID0+IHNldExhbmd1YWdlKGUudGFyZ2V0LnZhbHVlKX1cclxuICAgICAgICAgICAgICA+XHJcbiAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVwiYysrXCI+QysrPC9vcHRpb24+XHJcbiAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVwiamF2YVwiPkphdmE8L29wdGlvbj5cclxuICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCJQeXRob24yXCI+UHl0aG9uPC9vcHRpb24+XHJcbiAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVwiUHl0aG9uM1wiPlB5dGhvbjM8L29wdGlvbj5cclxuICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCJDXCI+Qzwvb3B0aW9uPlxyXG4gICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cIkMjXCI+SmF2YTwvb3B0aW9uPlxyXG4gICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cIkphdmFzY3JpcHRcIj5KYXZhc2NyaXB0PC9vcHRpb24+XHJcbiAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVwiUnVieVwiPlJ1Ynk8L29wdGlvbj5cclxuICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCJTd2lmdFwiPlN3aWZ0PC9vcHRpb24+XHJcbiAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVwiR29cIj5Hbzwvb3B0aW9uPlxyXG4gICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cIlNjYWxhXCI+U2NhbGE8L29wdGlvbj5cclxuICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCJLb3RsaW5cIj5Lb3RsaW48L29wdGlvbj5cclxuICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCJQSFBcIj5QSFA8L29wdGlvbj5cclxuICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCJSdXN0XCI+UnVzdDwvb3B0aW9uPlxyXG4gICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cIlR5cGVzY3JpcHRcIj5UeXBlc2NyaXB0PC9vcHRpb24+XHJcbiAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVwiRXJsYW5nXCI+RXJsYW5nPC9vcHRpb24+XHJcbiAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVwiRWxpeGlyXCI+RWxpeGlyPC9vcHRpb24+XHJcbiAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVwiUmFja2V0XCI+UmFja2V0PC9vcHRpb24+XHJcbiAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVwiRGFydFwiPkRhcnQ8L29wdGlvbj5cclxuXHJcbiAgICAgICAgICAgICAgPC9zZWxlY3Q+XHJcbiAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT0nY29kZWJveCc+XHJcbiAgICAgICAgICAgICAgPENvZGVNaXJyb3JcclxuICAgICAgICAgICAgICAgIHZhbHVlPXtjb2RlfVxyXG4gICAgICAgICAgICAgICAgb3B0aW9ucz17e1xyXG4gICAgICAgICAgICAgICAgICB0aGVtZTogJ2RyYWN1bGEnLFxyXG4gICAgICAgICAgICAgICAgICBrZXlNYXA6ICdzdWJsaW1lJyxcclxuICAgICAgICAgICAgICAgICAgbW9kZTogJ3B5dGhvbicsXHJcbiAgICAgICAgICAgICAgICB9fVxyXG4gICAgICAgICAgICAgICAgb25DaGFuZ2U9eyhlZGl0b3IsIGRhdGEsIHZhbHVlKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgIHNldENvZGUoZWRpdG9yKTtcclxuICAgICAgICAgICAgICAgIH19XHJcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU9XCJ3LTk2IGgtODBcIlxyXG4gICAgICAgICAgICAgIC8+XHJcbiAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICBcclxuXHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICA8aW5wdXQgY2xhc3NOYW1lID1cImJ0blwiIHR5cGU9XCJzdWJtaXRcIiB2YWx1ZT1cIlRyYW5zbGF0ZSBDb2RlXCIgLz5cclxuICAgICAgICAgIDwvZm9ybT5cclxuICAgICAgICAgIHsobG9hZGluZykgJiYgKFxyXG4gICAgICAgICAgICA8ZGl2PlxyXG4gICAgICAgICAgICAgIDxoMz5UcmFuc2xhdGluZyBDb2RlPC9oMz5cclxuICAgICAgICAgICAgICA8cD5Mb2FkaW5nLi4uPC9wPlxyXG4gICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICl9XHJcbiAgICAgICAgICB7IWxvYWRpbmcgJiYgKFxyXG4gICAgICAgICAgICA8VGV4dGFyZWEgdmFsdWU9e3Jlc3VsdH0+PC9UZXh0YXJlYT5cclxuICAgICAgICAgICl9XHJcbiAgICAgICAgICBcclxuICAgICAgICA8L21haW4+XHJcbiAgICAgIDwvZGl2PlxyXG4gICAgICBcclxuICAgIDwvZGl2PlxyXG4gICk7XHJcbn0iXSwibmFtZXMiOlsiSGVhZCIsIlJlYWN0IiwidXNlU3RhdGUiLCJzdHlsZXMiLCJUZXh0YXJlYSIsIkNvZGVNaXJyb3IiLCJIb21lIiwibGFuZ3VhZ2UiLCJzZXRMYW5ndWFnZSIsImNvZGUiLCJzZXRDb2RlIiwibG9hZGluZyIsInNldExvYWRpbmciLCJyZXN1bHQiLCJzZXRSZXN1bHQiLCJvblN1Ym1pdCIsImV2ZW50IiwicHJldmVudERlZmF1bHQiLCJ0cmltIiwibGVuZ3RoIiwicmVzcG9uc2UiLCJmZXRjaCIsIm1ldGhvZCIsImhlYWRlcnMiLCJib2R5IiwiSlNPTiIsInN0cmluZ2lmeSIsImRhdGEiLCJqc29uIiwiZGl2IiwidGl0bGUiLCJjbGFzc05hbWUiLCJtYWluIiwiaDEiLCJmb3JtIiwibGFiZWwiLCJzZWxlY3QiLCJuYW1lIiwidmFsdWUiLCJvbkNoYW5nZSIsImUiLCJ0YXJnZXQiLCJvcHRpb24iLCJvcHRpb25zIiwidGhlbWUiLCJrZXlNYXAiLCJtb2RlIiwiZWRpdG9yIiwiaW5wdXQiLCJ0eXBlIiwiaDMiLCJwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./pages/index.js\n"));

/***/ }),

/***/ "./pages/textarea.jsx":
/*!****************************!*\
  !*** ./pages/textarea.jsx ***!
  \****************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"./node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n\nvar _s = $RefreshSig$();\n\nfunction Textarea(param) {\n    let { value  } = param;\n    _s();\n    // Set the initial number of rows and columns to 1\n    const [rows, setRows] = react__WEBPACK_IMPORTED_MODULE_1___default().useState(1);\n    // Update the rows and columns when the component mounts\n    react__WEBPACK_IMPORTED_MODULE_1___default().useEffect(()=>{\n        updateTextarea();\n    }, []);\n    // Update the rows and columns when the value of the textarea changes\n    const handleChange = (event)=>{\n        updateTextarea();\n    };\n    const updateTextarea = ()=>{\n        // Set the number of rows and columns based on the length of the string\n        setRows(value.split(\"\\n\").length);\n    };\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"textarea\", {\n        style: {\n            resize: \"none\"\n        },\n        rows: rows,\n        onChange: handleChange,\n        value: value\n    }, void 0, false, {\n        fileName: \"C:\\\\Users\\\\Power\\\\OneDrive\\\\Desktop\\\\Demo Product\\\\CodeTranslate\\\\openai-quickstart-node\\\\pages\\\\textarea.jsx\",\n        lineNumber: 23,\n        columnNumber: 5\n    }, this);\n}\n_s(Textarea, \"LkWUcoETXy5rQCn3pFKLcIsVFUU=\");\n_c = Textarea;\n/* harmony default export */ __webpack_exports__[\"default\"] = (Textarea);\nvar _c;\n$RefreshReg$(_c, \"Textarea\");\n\n\n;\r\n    // Wrapped in an IIFE to avoid polluting the global scope\r\n    ;\r\n    (function () {\r\n        var _a, _b;\r\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\r\n        // to extract CSS. For backwards compatibility, we need to check we're in a\r\n        // browser context before continuing.\r\n        if (typeof self !== 'undefined' &&\r\n            // AMP / No-JS mode does not inject these helpers:\r\n            '$RefreshHelpers$' in self) {\r\n            // @ts-ignore __webpack_module__ is global\r\n            var currentExports = module.exports;\r\n            // @ts-ignore __webpack_module__ is global\r\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\r\n            // This cannot happen in MainTemplate because the exports mismatch between\r\n            // templating and execution.\r\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\r\n            // A module can be accepted automatically based on its exports, e.g. when\r\n            // it is a Refresh Boundary.\r\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\r\n                // Save the previous exports on update so we can compare the boundary\r\n                // signatures.\r\n                module.hot.dispose(function (data) {\r\n                    data.prevExports = currentExports;\r\n                });\r\n                // Unconditionally accept an update to this module, we'll check if it's\r\n                // still a Refresh Boundary later.\r\n                // @ts-ignore importMeta is replaced in the loader\r\n                module.hot.accept();\r\n                // This field is set when the previous version of this module was a\r\n                // Refresh Boundary, letting us know we need to check for invalidation or\r\n                // enqueue an update.\r\n                if (prevExports !== null) {\r\n                    // A boundary can become ineligible if its exports are incompatible\r\n                    // with the previous exports.\r\n                    //\r\n                    // For example, if you add/remove/change exports, we'll want to\r\n                    // re-execute the importing modules, and force those components to\r\n                    // re-render. Similarly, if you convert a class component to a\r\n                    // function, we want to invalidate the boundary.\r\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\r\n                        module.hot.invalidate();\r\n                    }\r\n                    else {\r\n                        self.$RefreshHelpers$.scheduleUpdate();\r\n                    }\r\n                }\r\n            }\r\n            else {\r\n                // Since we just executed the code for the module, it's possible that the\r\n                // new exports made it ineligible for being a boundary.\r\n                // We only care about the case when we were _previously_ a boundary,\r\n                // because we already accepted this update (accidental side effect).\r\n                var isNoLongerABoundary = prevExports !== null;\r\n                if (isNoLongerABoundary) {\r\n                    module.hot.invalidate();\r\n                }\r\n            }\r\n        }\r\n    })();\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9wYWdlcy90ZXh0YXJlYS5qc3guanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQTs7QUFBMEI7QUFFMUIsU0FBU0MsU0FBUyxLQUFTLEVBQUU7UUFBWCxFQUFFQyxNQUFLLEVBQUUsR0FBVDs7SUFDaEIsa0RBQWtEO0lBQ2xELE1BQU0sQ0FBQ0MsTUFBTUMsUUFBUSxHQUFHSixxREFBYyxDQUFDO0lBRXZDLHdEQUF3RDtJQUN4REEsc0RBQWUsQ0FBQyxJQUFNO1FBQ3BCTztJQUNGLEdBQUcsRUFBRTtJQUVMLHFFQUFxRTtJQUNyRSxNQUFNQyxlQUFlQyxDQUFBQSxRQUFTO1FBQzVCRjtJQUNGO0lBRUEsTUFBTUEsaUJBQWlCLElBQU07UUFDM0IsdUVBQXVFO1FBQ3ZFSCxRQUFRRixNQUFNUSxLQUFLLENBQUMsTUFBTUMsTUFBTTtJQUNsQztJQUVBLHFCQUNFLDhEQUFDQztRQUNDQyxPQUFPO1lBQUVDLFFBQVE7UUFBTztRQUN4QlgsTUFBTUE7UUFDTlksVUFBVVA7UUFDVk4sT0FBT0E7Ozs7OztBQUdiO0dBM0JTRDtLQUFBQTtBQTZCVCwrREFBZUEsUUFBUUEsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9wYWdlcy90ZXh0YXJlYS5qc3g/MDUyMCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xyXG5cclxuZnVuY3Rpb24gVGV4dGFyZWEoeyB2YWx1ZSB9KSB7XHJcbiAgLy8gU2V0IHRoZSBpbml0aWFsIG51bWJlciBvZiByb3dzIGFuZCBjb2x1bW5zIHRvIDFcclxuICBjb25zdCBbcm93cywgc2V0Um93c10gPSBSZWFjdC51c2VTdGF0ZSgxKTtcclxuXHJcbiAgLy8gVXBkYXRlIHRoZSByb3dzIGFuZCBjb2x1bW5zIHdoZW4gdGhlIGNvbXBvbmVudCBtb3VudHNcclxuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgdXBkYXRlVGV4dGFyZWEoKTtcclxuICB9LCBbXSk7XHJcblxyXG4gIC8vIFVwZGF0ZSB0aGUgcm93cyBhbmQgY29sdW1ucyB3aGVuIHRoZSB2YWx1ZSBvZiB0aGUgdGV4dGFyZWEgY2hhbmdlc1xyXG4gIGNvbnN0IGhhbmRsZUNoYW5nZSA9IGV2ZW50ID0+IHtcclxuICAgIHVwZGF0ZVRleHRhcmVhKCk7XHJcbiAgfTtcclxuXHJcbiAgY29uc3QgdXBkYXRlVGV4dGFyZWEgPSAoKSA9PiB7XHJcbiAgICAvLyBTZXQgdGhlIG51bWJlciBvZiByb3dzIGFuZCBjb2x1bW5zIGJhc2VkIG9uIHRoZSBsZW5ndGggb2YgdGhlIHN0cmluZ1xyXG4gICAgc2V0Um93cyh2YWx1ZS5zcGxpdCgnXFxuJykubGVuZ3RoKTtcclxuICB9O1xyXG5cclxuICByZXR1cm4gKFxyXG4gICAgPHRleHRhcmVhXHJcbiAgICAgIHN0eWxlPXt7IHJlc2l6ZTogJ25vbmUnIH19XHJcbiAgICAgIHJvd3M9e3Jvd3N9XHJcbiAgICAgIG9uQ2hhbmdlPXtoYW5kbGVDaGFuZ2V9XHJcbiAgICAgIHZhbHVlPXt2YWx1ZX1cclxuICAgIC8+XHJcbiAgKTtcclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgVGV4dGFyZWE7Il0sIm5hbWVzIjpbIlJlYWN0IiwiVGV4dGFyZWEiLCJ2YWx1ZSIsInJvd3MiLCJzZXRSb3dzIiwidXNlU3RhdGUiLCJ1c2VFZmZlY3QiLCJ1cGRhdGVUZXh0YXJlYSIsImhhbmRsZUNoYW5nZSIsImV2ZW50Iiwic3BsaXQiLCJsZW5ndGgiLCJ0ZXh0YXJlYSIsInN0eWxlIiwicmVzaXplIiwib25DaGFuZ2UiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./pages/textarea.jsx\n"));

/***/ }),

/***/ "./node_modules/next/head.js":
/*!***********************************!*\
  !*** ./node_modules/next/head.js ***!
  \***********************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("module.exports = __webpack_require__(/*! ./dist/shared/lib/head */ \"./node_modules/next/dist/shared/lib/head.js\")\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9oZWFkLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFBLGlIQUFrRCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9oZWFkLmpzPzg4NDkiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Rpc3Qvc2hhcmVkL2xpYi9oZWFkJylcclxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/next/head.js\n"));

/***/ }),

/***/ "./node_modules/react/cjs/react-jsx-dev-runtime.development.js":
/*!*********************************************************************!*\
  !*** ./node_modules/react/cjs/react-jsx-dev-runtime.development.js ***!
  \*********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/**\r\n * @license React\r\n * react-jsx-dev-runtime.development.js\r\n *\r\n * Copyright (c) Facebook, Inc. and its affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n */\r\n\r\n\r\n\r\nif (true) {\r\n  (function() {\r\n'use strict';\r\n\r\nvar React = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\r\n\r\n// ATTENTION\r\n// When adding new symbols to this file,\r\n// Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'\r\n// The Symbol used to tag the ReactElement-like types.\r\nvar REACT_ELEMENT_TYPE = Symbol.for('react.element');\r\nvar REACT_PORTAL_TYPE = Symbol.for('react.portal');\r\nvar REACT_FRAGMENT_TYPE = Symbol.for('react.fragment');\r\nvar REACT_STRICT_MODE_TYPE = Symbol.for('react.strict_mode');\r\nvar REACT_PROFILER_TYPE = Symbol.for('react.profiler');\r\nvar REACT_PROVIDER_TYPE = Symbol.for('react.provider');\r\nvar REACT_CONTEXT_TYPE = Symbol.for('react.context');\r\nvar REACT_FORWARD_REF_TYPE = Symbol.for('react.forward_ref');\r\nvar REACT_SUSPENSE_TYPE = Symbol.for('react.suspense');\r\nvar REACT_SUSPENSE_LIST_TYPE = Symbol.for('react.suspense_list');\r\nvar REACT_MEMO_TYPE = Symbol.for('react.memo');\r\nvar REACT_LAZY_TYPE = Symbol.for('react.lazy');\r\nvar REACT_OFFSCREEN_TYPE = Symbol.for('react.offscreen');\r\nvar MAYBE_ITERATOR_SYMBOL = Symbol.iterator;\r\nvar FAUX_ITERATOR_SYMBOL = '@@iterator';\r\nfunction getIteratorFn(maybeIterable) {\r\n  if (maybeIterable === null || typeof maybeIterable !== 'object') {\r\n    return null;\r\n  }\r\n\r\n  var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];\r\n\r\n  if (typeof maybeIterator === 'function') {\r\n    return maybeIterator;\r\n  }\r\n\r\n  return null;\r\n}\r\n\r\nvar ReactSharedInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;\r\n\r\nfunction error(format) {\r\n  {\r\n    {\r\n      for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\r\n        args[_key2 - 1] = arguments[_key2];\r\n      }\r\n\r\n      printWarning('error', format, args);\r\n    }\r\n  }\r\n}\r\n\r\nfunction printWarning(level, format, args) {\r\n  // When changing this logic, you might want to also\r\n  // update consoleWithStackDev.www.js as well.\r\n  {\r\n    var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\r\n    var stack = ReactDebugCurrentFrame.getStackAddendum();\r\n\r\n    if (stack !== '') {\r\n      format += '%s';\r\n      args = args.concat([stack]);\r\n    } // eslint-disable-next-line react-internal/safe-string-coercion\r\n\r\n\r\n    var argsWithFormat = args.map(function (item) {\r\n      return String(item);\r\n    }); // Careful: RN currently depends on this prefix\r\n\r\n    argsWithFormat.unshift('Warning: ' + format); // We intentionally don't use spread (or .apply) directly because it\r\n    // breaks IE9: https://github.com/facebook/react/issues/13610\r\n    // eslint-disable-next-line react-internal/no-production-logging\r\n\r\n    Function.prototype.apply.call(console[level], console, argsWithFormat);\r\n  }\r\n}\r\n\r\n// -----------------------------------------------------------------------------\r\n\r\nvar enableScopeAPI = false; // Experimental Create Event Handle API.\r\nvar enableCacheElement = false;\r\nvar enableTransitionTracing = false; // No known bugs, but needs performance testing\r\n\r\nvar enableLegacyHidden = false; // Enables unstable_avoidThisFallback feature in Fiber\r\n// stuff. Intended to enable React core members to more easily debug scheduling\r\n// issues in DEV builds.\r\n\r\nvar enableDebugTracing = false; // Track which Fiber(s) schedule render work.\r\n\r\nvar REACT_MODULE_REFERENCE;\r\n\r\n{\r\n  REACT_MODULE_REFERENCE = Symbol.for('react.module.reference');\r\n}\r\n\r\nfunction isValidElementType(type) {\r\n  if (typeof type === 'string' || typeof type === 'function') {\r\n    return true;\r\n  } // Note: typeof might be other than 'symbol' or 'number' (e.g. if it's a polyfill).\r\n\r\n\r\n  if (type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || enableDebugTracing  || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || enableLegacyHidden  || type === REACT_OFFSCREEN_TYPE || enableScopeAPI  || enableCacheElement  || enableTransitionTracing ) {\r\n    return true;\r\n  }\r\n\r\n  if (typeof type === 'object' && type !== null) {\r\n    if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || // This needs to include all possible module reference object\r\n    // types supported by any Flight configuration anywhere since\r\n    // we don't know which Flight build this will end up being used\r\n    // with.\r\n    type.$$typeof === REACT_MODULE_REFERENCE || type.getModuleId !== undefined) {\r\n      return true;\r\n    }\r\n  }\r\n\r\n  return false;\r\n}\r\n\r\nfunction getWrappedName(outerType, innerType, wrapperName) {\r\n  var displayName = outerType.displayName;\r\n\r\n  if (displayName) {\r\n    return displayName;\r\n  }\r\n\r\n  var functionName = innerType.displayName || innerType.name || '';\r\n  return functionName !== '' ? wrapperName + \"(\" + functionName + \")\" : wrapperName;\r\n} // Keep in sync with react-reconciler/getComponentNameFromFiber\r\n\r\n\r\nfunction getContextName(type) {\r\n  return type.displayName || 'Context';\r\n} // Note that the reconciler package should generally prefer to use getComponentNameFromFiber() instead.\r\n\r\n\r\nfunction getComponentNameFromType(type) {\r\n  if (type == null) {\r\n    // Host root, text node or just invalid type.\r\n    return null;\r\n  }\r\n\r\n  {\r\n    if (typeof type.tag === 'number') {\r\n      error('Received an unexpected object in getComponentNameFromType(). ' + 'This is likely a bug in React. Please file an issue.');\r\n    }\r\n  }\r\n\r\n  if (typeof type === 'function') {\r\n    return type.displayName || type.name || null;\r\n  }\r\n\r\n  if (typeof type === 'string') {\r\n    return type;\r\n  }\r\n\r\n  switch (type) {\r\n    case REACT_FRAGMENT_TYPE:\r\n      return 'Fragment';\r\n\r\n    case REACT_PORTAL_TYPE:\r\n      return 'Portal';\r\n\r\n    case REACT_PROFILER_TYPE:\r\n      return 'Profiler';\r\n\r\n    case REACT_STRICT_MODE_TYPE:\r\n      return 'StrictMode';\r\n\r\n    case REACT_SUSPENSE_TYPE:\r\n      return 'Suspense';\r\n\r\n    case REACT_SUSPENSE_LIST_TYPE:\r\n      return 'SuspenseList';\r\n\r\n  }\r\n\r\n  if (typeof type === 'object') {\r\n    switch (type.$$typeof) {\r\n      case REACT_CONTEXT_TYPE:\r\n        var context = type;\r\n        return getContextName(context) + '.Consumer';\r\n\r\n      case REACT_PROVIDER_TYPE:\r\n        var provider = type;\r\n        return getContextName(provider._context) + '.Provider';\r\n\r\n      case REACT_FORWARD_REF_TYPE:\r\n        return getWrappedName(type, type.render, 'ForwardRef');\r\n\r\n      case REACT_MEMO_TYPE:\r\n        var outerName = type.displayName || null;\r\n\r\n        if (outerName !== null) {\r\n          return outerName;\r\n        }\r\n\r\n        return getComponentNameFromType(type.type) || 'Memo';\r\n\r\n      case REACT_LAZY_TYPE:\r\n        {\r\n          var lazyComponent = type;\r\n          var payload = lazyComponent._payload;\r\n          var init = lazyComponent._init;\r\n\r\n          try {\r\n            return getComponentNameFromType(init(payload));\r\n          } catch (x) {\r\n            return null;\r\n          }\r\n        }\r\n\r\n      // eslint-disable-next-line no-fallthrough\r\n    }\r\n  }\r\n\r\n  return null;\r\n}\r\n\r\nvar assign = Object.assign;\r\n\r\n// Helpers to patch console.logs to avoid logging during side-effect free\r\n// replaying on render function. This currently only patches the object\r\n// lazily which won't cover if the log function was extracted eagerly.\r\n// We could also eagerly patch the method.\r\nvar disabledDepth = 0;\r\nvar prevLog;\r\nvar prevInfo;\r\nvar prevWarn;\r\nvar prevError;\r\nvar prevGroup;\r\nvar prevGroupCollapsed;\r\nvar prevGroupEnd;\r\n\r\nfunction disabledLog() {}\r\n\r\ndisabledLog.__reactDisabledLog = true;\r\nfunction disableLogs() {\r\n  {\r\n    if (disabledDepth === 0) {\r\n      /* eslint-disable react-internal/no-production-logging */\r\n      prevLog = console.log;\r\n      prevInfo = console.info;\r\n      prevWarn = console.warn;\r\n      prevError = console.error;\r\n      prevGroup = console.group;\r\n      prevGroupCollapsed = console.groupCollapsed;\r\n      prevGroupEnd = console.groupEnd; // https://github.com/facebook/react/issues/19099\r\n\r\n      var props = {\r\n        configurable: true,\r\n        enumerable: true,\r\n        value: disabledLog,\r\n        writable: true\r\n      }; // $FlowFixMe Flow thinks console is immutable.\r\n\r\n      Object.defineProperties(console, {\r\n        info: props,\r\n        log: props,\r\n        warn: props,\r\n        error: props,\r\n        group: props,\r\n        groupCollapsed: props,\r\n        groupEnd: props\r\n      });\r\n      /* eslint-enable react-internal/no-production-logging */\r\n    }\r\n\r\n    disabledDepth++;\r\n  }\r\n}\r\nfunction reenableLogs() {\r\n  {\r\n    disabledDepth--;\r\n\r\n    if (disabledDepth === 0) {\r\n      /* eslint-disable react-internal/no-production-logging */\r\n      var props = {\r\n        configurable: true,\r\n        enumerable: true,\r\n        writable: true\r\n      }; // $FlowFixMe Flow thinks console is immutable.\r\n\r\n      Object.defineProperties(console, {\r\n        log: assign({}, props, {\r\n          value: prevLog\r\n        }),\r\n        info: assign({}, props, {\r\n          value: prevInfo\r\n        }),\r\n        warn: assign({}, props, {\r\n          value: prevWarn\r\n        }),\r\n        error: assign({}, props, {\r\n          value: prevError\r\n        }),\r\n        group: assign({}, props, {\r\n          value: prevGroup\r\n        }),\r\n        groupCollapsed: assign({}, props, {\r\n          value: prevGroupCollapsed\r\n        }),\r\n        groupEnd: assign({}, props, {\r\n          value: prevGroupEnd\r\n        })\r\n      });\r\n      /* eslint-enable react-internal/no-production-logging */\r\n    }\r\n\r\n    if (disabledDepth < 0) {\r\n      error('disabledDepth fell below zero. ' + 'This is a bug in React. Please file an issue.');\r\n    }\r\n  }\r\n}\r\n\r\nvar ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;\r\nvar prefix;\r\nfunction describeBuiltInComponentFrame(name, source, ownerFn) {\r\n  {\r\n    if (prefix === undefined) {\r\n      // Extract the VM specific prefix used by each line.\r\n      try {\r\n        throw Error();\r\n      } catch (x) {\r\n        var match = x.stack.trim().match(/\\n( *(at )?)/);\r\n        prefix = match && match[1] || '';\r\n      }\r\n    } // We use the prefix to ensure our stacks line up with native stack frames.\r\n\r\n\r\n    return '\\n' + prefix + name;\r\n  }\r\n}\r\nvar reentry = false;\r\nvar componentFrameCache;\r\n\r\n{\r\n  var PossiblyWeakMap = typeof WeakMap === 'function' ? WeakMap : Map;\r\n  componentFrameCache = new PossiblyWeakMap();\r\n}\r\n\r\nfunction describeNativeComponentFrame(fn, construct) {\r\n  // If something asked for a stack inside a fake render, it should get ignored.\r\n  if ( !fn || reentry) {\r\n    return '';\r\n  }\r\n\r\n  {\r\n    var frame = componentFrameCache.get(fn);\r\n\r\n    if (frame !== undefined) {\r\n      return frame;\r\n    }\r\n  }\r\n\r\n  var control;\r\n  reentry = true;\r\n  var previousPrepareStackTrace = Error.prepareStackTrace; // $FlowFixMe It does accept undefined.\r\n\r\n  Error.prepareStackTrace = undefined;\r\n  var previousDispatcher;\r\n\r\n  {\r\n    previousDispatcher = ReactCurrentDispatcher.current; // Set the dispatcher in DEV because this might be call in the render function\r\n    // for warnings.\r\n\r\n    ReactCurrentDispatcher.current = null;\r\n    disableLogs();\r\n  }\r\n\r\n  try {\r\n    // This should throw.\r\n    if (construct) {\r\n      // Something should be setting the props in the constructor.\r\n      var Fake = function () {\r\n        throw Error();\r\n      }; // $FlowFixMe\r\n\r\n\r\n      Object.defineProperty(Fake.prototype, 'props', {\r\n        set: function () {\r\n          // We use a throwing setter instead of frozen or non-writable props\r\n          // because that won't throw in a non-strict mode function.\r\n          throw Error();\r\n        }\r\n      });\r\n\r\n      if (typeof Reflect === 'object' && Reflect.construct) {\r\n        // We construct a different control for this case to include any extra\r\n        // frames added by the construct call.\r\n        try {\r\n          Reflect.construct(Fake, []);\r\n        } catch (x) {\r\n          control = x;\r\n        }\r\n\r\n        Reflect.construct(fn, [], Fake);\r\n      } else {\r\n        try {\r\n          Fake.call();\r\n        } catch (x) {\r\n          control = x;\r\n        }\r\n\r\n        fn.call(Fake.prototype);\r\n      }\r\n    } else {\r\n      try {\r\n        throw Error();\r\n      } catch (x) {\r\n        control = x;\r\n      }\r\n\r\n      fn();\r\n    }\r\n  } catch (sample) {\r\n    // This is inlined manually because closure doesn't do it for us.\r\n    if (sample && control && typeof sample.stack === 'string') {\r\n      // This extracts the first frame from the sample that isn't also in the control.\r\n      // Skipping one frame that we assume is the frame that calls the two.\r\n      var sampleLines = sample.stack.split('\\n');\r\n      var controlLines = control.stack.split('\\n');\r\n      var s = sampleLines.length - 1;\r\n      var c = controlLines.length - 1;\r\n\r\n      while (s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]) {\r\n        // We expect at least one stack frame to be shared.\r\n        // Typically this will be the root most one. However, stack frames may be\r\n        // cut off due to maximum stack limits. In this case, one maybe cut off\r\n        // earlier than the other. We assume that the sample is longer or the same\r\n        // and there for cut off earlier. So we should find the root most frame in\r\n        // the sample somewhere in the control.\r\n        c--;\r\n      }\r\n\r\n      for (; s >= 1 && c >= 0; s--, c--) {\r\n        // Next we find the first one that isn't the same which should be the\r\n        // frame that called our sample function and the control.\r\n        if (sampleLines[s] !== controlLines[c]) {\r\n          // In V8, the first line is describing the message but other VMs don't.\r\n          // If we're about to return the first line, and the control is also on the same\r\n          // line, that's a pretty good indicator that our sample threw at same line as\r\n          // the control. I.e. before we entered the sample frame. So we ignore this result.\r\n          // This can happen if you passed a class to function component, or non-function.\r\n          if (s !== 1 || c !== 1) {\r\n            do {\r\n              s--;\r\n              c--; // We may still have similar intermediate frames from the construct call.\r\n              // The next one that isn't the same should be our match though.\r\n\r\n              if (c < 0 || sampleLines[s] !== controlLines[c]) {\r\n                // V8 adds a \"new\" prefix for native classes. Let's remove it to make it prettier.\r\n                var _frame = '\\n' + sampleLines[s].replace(' at new ', ' at '); // If our component frame is labeled \"<anonymous>\"\r\n                // but we have a user-provided \"displayName\"\r\n                // splice it in to make the stack more readable.\r\n\r\n\r\n                if (fn.displayName && _frame.includes('<anonymous>')) {\r\n                  _frame = _frame.replace('<anonymous>', fn.displayName);\r\n                }\r\n\r\n                {\r\n                  if (typeof fn === 'function') {\r\n                    componentFrameCache.set(fn, _frame);\r\n                  }\r\n                } // Return the line we found.\r\n\r\n\r\n                return _frame;\r\n              }\r\n            } while (s >= 1 && c >= 0);\r\n          }\r\n\r\n          break;\r\n        }\r\n      }\r\n    }\r\n  } finally {\r\n    reentry = false;\r\n\r\n    {\r\n      ReactCurrentDispatcher.current = previousDispatcher;\r\n      reenableLogs();\r\n    }\r\n\r\n    Error.prepareStackTrace = previousPrepareStackTrace;\r\n  } // Fallback to just using the name if we couldn't make it throw.\r\n\r\n\r\n  var name = fn ? fn.displayName || fn.name : '';\r\n  var syntheticFrame = name ? describeBuiltInComponentFrame(name) : '';\r\n\r\n  {\r\n    if (typeof fn === 'function') {\r\n      componentFrameCache.set(fn, syntheticFrame);\r\n    }\r\n  }\r\n\r\n  return syntheticFrame;\r\n}\r\nfunction describeFunctionComponentFrame(fn, source, ownerFn) {\r\n  {\r\n    return describeNativeComponentFrame(fn, false);\r\n  }\r\n}\r\n\r\nfunction shouldConstruct(Component) {\r\n  var prototype = Component.prototype;\r\n  return !!(prototype && prototype.isReactComponent);\r\n}\r\n\r\nfunction describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {\r\n\r\n  if (type == null) {\r\n    return '';\r\n  }\r\n\r\n  if (typeof type === 'function') {\r\n    {\r\n      return describeNativeComponentFrame(type, shouldConstruct(type));\r\n    }\r\n  }\r\n\r\n  if (typeof type === 'string') {\r\n    return describeBuiltInComponentFrame(type);\r\n  }\r\n\r\n  switch (type) {\r\n    case REACT_SUSPENSE_TYPE:\r\n      return describeBuiltInComponentFrame('Suspense');\r\n\r\n    case REACT_SUSPENSE_LIST_TYPE:\r\n      return describeBuiltInComponentFrame('SuspenseList');\r\n  }\r\n\r\n  if (typeof type === 'object') {\r\n    switch (type.$$typeof) {\r\n      case REACT_FORWARD_REF_TYPE:\r\n        return describeFunctionComponentFrame(type.render);\r\n\r\n      case REACT_MEMO_TYPE:\r\n        // Memo may contain any component type so we recursively resolve it.\r\n        return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);\r\n\r\n      case REACT_LAZY_TYPE:\r\n        {\r\n          var lazyComponent = type;\r\n          var payload = lazyComponent._payload;\r\n          var init = lazyComponent._init;\r\n\r\n          try {\r\n            // Lazy may contain any component type so we recursively resolve it.\r\n            return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);\r\n          } catch (x) {}\r\n        }\r\n    }\r\n  }\r\n\r\n  return '';\r\n}\r\n\r\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\r\n\r\nvar loggedTypeFailures = {};\r\nvar ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\r\n\r\nfunction setCurrentlyValidatingElement(element) {\r\n  {\r\n    if (element) {\r\n      var owner = element._owner;\r\n      var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);\r\n      ReactDebugCurrentFrame.setExtraStackFrame(stack);\r\n    } else {\r\n      ReactDebugCurrentFrame.setExtraStackFrame(null);\r\n    }\r\n  }\r\n}\r\n\r\nfunction checkPropTypes(typeSpecs, values, location, componentName, element) {\r\n  {\r\n    // $FlowFixMe This is okay but Flow doesn't know it.\r\n    var has = Function.call.bind(hasOwnProperty);\r\n\r\n    for (var typeSpecName in typeSpecs) {\r\n      if (has(typeSpecs, typeSpecName)) {\r\n        var error$1 = void 0; // Prop type validation may throw. In case they do, we don't want to\r\n        // fail the render phase where it didn't fail before. So we log it.\r\n        // After these have been cleaned up, we'll let them throw.\r\n\r\n        try {\r\n          // This is intentionally an invariant that gets caught. It's the same\r\n          // behavior as without this statement except with a better message.\r\n          if (typeof typeSpecs[typeSpecName] !== 'function') {\r\n            // eslint-disable-next-line react-internal/prod-error-codes\r\n            var err = Error((componentName || 'React class') + ': ' + location + ' type `' + typeSpecName + '` is invalid; ' + 'it must be a function, usually from the `prop-types` package, but received `' + typeof typeSpecs[typeSpecName] + '`.' + 'This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.');\r\n            err.name = 'Invariant Violation';\r\n            throw err;\r\n          }\r\n\r\n          error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED');\r\n        } catch (ex) {\r\n          error$1 = ex;\r\n        }\r\n\r\n        if (error$1 && !(error$1 instanceof Error)) {\r\n          setCurrentlyValidatingElement(element);\r\n\r\n          error('%s: type specification of %s' + ' `%s` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a %s. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).', componentName || 'React class', location, typeSpecName, typeof error$1);\r\n\r\n          setCurrentlyValidatingElement(null);\r\n        }\r\n\r\n        if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {\r\n          // Only monitor this failure once because there tends to be a lot of the\r\n          // same error.\r\n          loggedTypeFailures[error$1.message] = true;\r\n          setCurrentlyValidatingElement(element);\r\n\r\n          error('Failed %s type: %s', location, error$1.message);\r\n\r\n          setCurrentlyValidatingElement(null);\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nvar isArrayImpl = Array.isArray; // eslint-disable-next-line no-redeclare\r\n\r\nfunction isArray(a) {\r\n  return isArrayImpl(a);\r\n}\r\n\r\n/*\r\n * The `'' + value` pattern (used in in perf-sensitive code) throws for Symbol\r\n * and Temporal.* types. See https://github.com/facebook/react/pull/22064.\r\n *\r\n * The functions in this module will throw an easier-to-understand,\r\n * easier-to-debug exception with a clear errors message message explaining the\r\n * problem. (Instead of a confusing exception thrown inside the implementation\r\n * of the `value` object).\r\n */\r\n// $FlowFixMe only called in DEV, so void return is not possible.\r\nfunction typeName(value) {\r\n  {\r\n    // toStringTag is needed for namespaced types like Temporal.Instant\r\n    var hasToStringTag = typeof Symbol === 'function' && Symbol.toStringTag;\r\n    var type = hasToStringTag && value[Symbol.toStringTag] || value.constructor.name || 'Object';\r\n    return type;\r\n  }\r\n} // $FlowFixMe only called in DEV, so void return is not possible.\r\n\r\n\r\nfunction willCoercionThrow(value) {\r\n  {\r\n    try {\r\n      testStringCoercion(value);\r\n      return false;\r\n    } catch (e) {\r\n      return true;\r\n    }\r\n  }\r\n}\r\n\r\nfunction testStringCoercion(value) {\r\n  // If you ended up here by following an exception call stack, here's what's\r\n  // happened: you supplied an object or symbol value to React (as a prop, key,\r\n  // DOM attribute, CSS property, string ref, etc.) and when React tried to\r\n  // coerce it to a string using `'' + value`, an exception was thrown.\r\n  //\r\n  // The most common types that will cause this exception are `Symbol` instances\r\n  // and Temporal objects like `Temporal.Instant`. But any object that has a\r\n  // `valueOf` or `[Symbol.toPrimitive]` method that throws will also cause this\r\n  // exception. (Library authors do this to prevent users from using built-in\r\n  // numeric operators like `+` or comparison operators like `>=` because custom\r\n  // methods are needed to perform accurate arithmetic or comparison.)\r\n  //\r\n  // To fix the problem, coerce this object or symbol value to a string before\r\n  // passing it to React. The most reliable way is usually `String(value)`.\r\n  //\r\n  // To find which value is throwing, check the browser or debugger console.\r\n  // Before this exception was thrown, there should be `console.error` output\r\n  // that shows the type (Symbol, Temporal.PlainDate, etc.) that caused the\r\n  // problem and how that type was used: key, atrribute, input value prop, etc.\r\n  // In most cases, this console output also shows the component and its\r\n  // ancestor components where the exception happened.\r\n  //\r\n  // eslint-disable-next-line react-internal/safe-string-coercion\r\n  return '' + value;\r\n}\r\nfunction checkKeyStringCoercion(value) {\r\n  {\r\n    if (willCoercionThrow(value)) {\r\n      error('The provided key is an unsupported type %s.' + ' This value must be coerced to a string before before using it here.', typeName(value));\r\n\r\n      return testStringCoercion(value); // throw (to help callers find troubleshooting comments)\r\n    }\r\n  }\r\n}\r\n\r\nvar ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;\r\nvar RESERVED_PROPS = {\r\n  key: true,\r\n  ref: true,\r\n  __self: true,\r\n  __source: true\r\n};\r\nvar specialPropKeyWarningShown;\r\nvar specialPropRefWarningShown;\r\nvar didWarnAboutStringRefs;\r\n\r\n{\r\n  didWarnAboutStringRefs = {};\r\n}\r\n\r\nfunction hasValidRef(config) {\r\n  {\r\n    if (hasOwnProperty.call(config, 'ref')) {\r\n      var getter = Object.getOwnPropertyDescriptor(config, 'ref').get;\r\n\r\n      if (getter && getter.isReactWarning) {\r\n        return false;\r\n      }\r\n    }\r\n  }\r\n\r\n  return config.ref !== undefined;\r\n}\r\n\r\nfunction hasValidKey(config) {\r\n  {\r\n    if (hasOwnProperty.call(config, 'key')) {\r\n      var getter = Object.getOwnPropertyDescriptor(config, 'key').get;\r\n\r\n      if (getter && getter.isReactWarning) {\r\n        return false;\r\n      }\r\n    }\r\n  }\r\n\r\n  return config.key !== undefined;\r\n}\r\n\r\nfunction warnIfStringRefCannotBeAutoConverted(config, self) {\r\n  {\r\n    if (typeof config.ref === 'string' && ReactCurrentOwner.current && self && ReactCurrentOwner.current.stateNode !== self) {\r\n      var componentName = getComponentNameFromType(ReactCurrentOwner.current.type);\r\n\r\n      if (!didWarnAboutStringRefs[componentName]) {\r\n        error('Component \"%s\" contains the string ref \"%s\". ' + 'Support for string refs will be removed in a future major release. ' + 'This case cannot be automatically converted to an arrow function. ' + 'We ask you to manually fix this case by using useRef() or createRef() instead. ' + 'Learn more about using refs safely here: ' + 'https://reactjs.org/link/strict-mode-string-ref', getComponentNameFromType(ReactCurrentOwner.current.type), config.ref);\r\n\r\n        didWarnAboutStringRefs[componentName] = true;\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nfunction defineKeyPropWarningGetter(props, displayName) {\r\n  {\r\n    var warnAboutAccessingKey = function () {\r\n      if (!specialPropKeyWarningShown) {\r\n        specialPropKeyWarningShown = true;\r\n\r\n        error('%s: `key` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);\r\n      }\r\n    };\r\n\r\n    warnAboutAccessingKey.isReactWarning = true;\r\n    Object.defineProperty(props, 'key', {\r\n      get: warnAboutAccessingKey,\r\n      configurable: true\r\n    });\r\n  }\r\n}\r\n\r\nfunction defineRefPropWarningGetter(props, displayName) {\r\n  {\r\n    var warnAboutAccessingRef = function () {\r\n      if (!specialPropRefWarningShown) {\r\n        specialPropRefWarningShown = true;\r\n\r\n        error('%s: `ref` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);\r\n      }\r\n    };\r\n\r\n    warnAboutAccessingRef.isReactWarning = true;\r\n    Object.defineProperty(props, 'ref', {\r\n      get: warnAboutAccessingRef,\r\n      configurable: true\r\n    });\r\n  }\r\n}\r\n/**\r\n * Factory method to create a new React element. This no longer adheres to\r\n * the class pattern, so do not use new to call it. Also, instanceof check\r\n * will not work. Instead test $$typeof field against Symbol.for('react.element') to check\r\n * if something is a React Element.\r\n *\r\n * @param {*} type\r\n * @param {*} props\r\n * @param {*} key\r\n * @param {string|object} ref\r\n * @param {*} owner\r\n * @param {*} self A *temporary* helper to detect places where `this` is\r\n * different from the `owner` when React.createElement is called, so that we\r\n * can warn. We want to get rid of owner and replace string `ref`s with arrow\r\n * functions, and as long as `this` and owner are the same, there will be no\r\n * change in behavior.\r\n * @param {*} source An annotation object (added by a transpiler or otherwise)\r\n * indicating filename, line number, and/or other information.\r\n * @internal\r\n */\r\n\r\n\r\nvar ReactElement = function (type, key, ref, self, source, owner, props) {\r\n  var element = {\r\n    // This tag allows us to uniquely identify this as a React Element\r\n    $$typeof: REACT_ELEMENT_TYPE,\r\n    // Built-in properties that belong on the element\r\n    type: type,\r\n    key: key,\r\n    ref: ref,\r\n    props: props,\r\n    // Record the component responsible for creating this element.\r\n    _owner: owner\r\n  };\r\n\r\n  {\r\n    // The validation flag is currently mutative. We put it on\r\n    // an external backing store so that we can freeze the whole object.\r\n    // This can be replaced with a WeakMap once they are implemented in\r\n    // commonly used development environments.\r\n    element._store = {}; // To make comparing ReactElements easier for testing purposes, we make\r\n    // the validation flag non-enumerable (where possible, which should\r\n    // include every environment we run tests in), so the test framework\r\n    // ignores it.\r\n\r\n    Object.defineProperty(element._store, 'validated', {\r\n      configurable: false,\r\n      enumerable: false,\r\n      writable: true,\r\n      value: false\r\n    }); // self and source are DEV only properties.\r\n\r\n    Object.defineProperty(element, '_self', {\r\n      configurable: false,\r\n      enumerable: false,\r\n      writable: false,\r\n      value: self\r\n    }); // Two elements created in two different places should be considered\r\n    // equal for testing purposes and therefore we hide it from enumeration.\r\n\r\n    Object.defineProperty(element, '_source', {\r\n      configurable: false,\r\n      enumerable: false,\r\n      writable: false,\r\n      value: source\r\n    });\r\n\r\n    if (Object.freeze) {\r\n      Object.freeze(element.props);\r\n      Object.freeze(element);\r\n    }\r\n  }\r\n\r\n  return element;\r\n};\r\n/**\r\n * https://github.com/reactjs/rfcs/pull/107\r\n * @param {*} type\r\n * @param {object} props\r\n * @param {string} key\r\n */\r\n\r\nfunction jsxDEV(type, config, maybeKey, source, self) {\r\n  {\r\n    var propName; // Reserved names are extracted\r\n\r\n    var props = {};\r\n    var key = null;\r\n    var ref = null; // Currently, key can be spread in as a prop. This causes a potential\r\n    // issue if key is also explicitly declared (ie. <div {...props} key=\"Hi\" />\r\n    // or <div key=\"Hi\" {...props} /> ). We want to deprecate key spread,\r\n    // but as an intermediary step, we will use jsxDEV for everything except\r\n    // <div {...props} key=\"Hi\" />, because we aren't currently able to tell if\r\n    // key is explicitly declared to be undefined or not.\r\n\r\n    if (maybeKey !== undefined) {\r\n      {\r\n        checkKeyStringCoercion(maybeKey);\r\n      }\r\n\r\n      key = '' + maybeKey;\r\n    }\r\n\r\n    if (hasValidKey(config)) {\r\n      {\r\n        checkKeyStringCoercion(config.key);\r\n      }\r\n\r\n      key = '' + config.key;\r\n    }\r\n\r\n    if (hasValidRef(config)) {\r\n      ref = config.ref;\r\n      warnIfStringRefCannotBeAutoConverted(config, self);\r\n    } // Remaining properties are added to a new props object\r\n\r\n\r\n    for (propName in config) {\r\n      if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {\r\n        props[propName] = config[propName];\r\n      }\r\n    } // Resolve default props\r\n\r\n\r\n    if (type && type.defaultProps) {\r\n      var defaultProps = type.defaultProps;\r\n\r\n      for (propName in defaultProps) {\r\n        if (props[propName] === undefined) {\r\n          props[propName] = defaultProps[propName];\r\n        }\r\n      }\r\n    }\r\n\r\n    if (key || ref) {\r\n      var displayName = typeof type === 'function' ? type.displayName || type.name || 'Unknown' : type;\r\n\r\n      if (key) {\r\n        defineKeyPropWarningGetter(props, displayName);\r\n      }\r\n\r\n      if (ref) {\r\n        defineRefPropWarningGetter(props, displayName);\r\n      }\r\n    }\r\n\r\n    return ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);\r\n  }\r\n}\r\n\r\nvar ReactCurrentOwner$1 = ReactSharedInternals.ReactCurrentOwner;\r\nvar ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;\r\n\r\nfunction setCurrentlyValidatingElement$1(element) {\r\n  {\r\n    if (element) {\r\n      var owner = element._owner;\r\n      var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);\r\n      ReactDebugCurrentFrame$1.setExtraStackFrame(stack);\r\n    } else {\r\n      ReactDebugCurrentFrame$1.setExtraStackFrame(null);\r\n    }\r\n  }\r\n}\r\n\r\nvar propTypesMisspellWarningShown;\r\n\r\n{\r\n  propTypesMisspellWarningShown = false;\r\n}\r\n/**\r\n * Verifies the object is a ReactElement.\r\n * See https://reactjs.org/docs/react-api.html#isvalidelement\r\n * @param {?object} object\r\n * @return {boolean} True if `object` is a ReactElement.\r\n * @final\r\n */\r\n\r\n\r\nfunction isValidElement(object) {\r\n  {\r\n    return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;\r\n  }\r\n}\r\n\r\nfunction getDeclarationErrorAddendum() {\r\n  {\r\n    if (ReactCurrentOwner$1.current) {\r\n      var name = getComponentNameFromType(ReactCurrentOwner$1.current.type);\r\n\r\n      if (name) {\r\n        return '\\n\\nCheck the render method of `' + name + '`.';\r\n      }\r\n    }\r\n\r\n    return '';\r\n  }\r\n}\r\n\r\nfunction getSourceInfoErrorAddendum(source) {\r\n  {\r\n    if (source !== undefined) {\r\n      var fileName = source.fileName.replace(/^.*[\\\\\\/]/, '');\r\n      var lineNumber = source.lineNumber;\r\n      return '\\n\\nCheck your code at ' + fileName + ':' + lineNumber + '.';\r\n    }\r\n\r\n    return '';\r\n  }\r\n}\r\n/**\r\n * Warn if there's no key explicitly set on dynamic arrays of children or\r\n * object keys are not valid. This allows us to keep track of children between\r\n * updates.\r\n */\r\n\r\n\r\nvar ownerHasKeyUseWarning = {};\r\n\r\nfunction getCurrentComponentErrorInfo(parentType) {\r\n  {\r\n    var info = getDeclarationErrorAddendum();\r\n\r\n    if (!info) {\r\n      var parentName = typeof parentType === 'string' ? parentType : parentType.displayName || parentType.name;\r\n\r\n      if (parentName) {\r\n        info = \"\\n\\nCheck the top-level render call using <\" + parentName + \">.\";\r\n      }\r\n    }\r\n\r\n    return info;\r\n  }\r\n}\r\n/**\r\n * Warn if the element doesn't have an explicit key assigned to it.\r\n * This element is in an array. The array could grow and shrink or be\r\n * reordered. All children that haven't already been validated are required to\r\n * have a \"key\" property assigned to it. Error statuses are cached so a warning\r\n * will only be shown once.\r\n *\r\n * @internal\r\n * @param {ReactElement} element Element that requires a key.\r\n * @param {*} parentType element's parent's type.\r\n */\r\n\r\n\r\nfunction validateExplicitKey(element, parentType) {\r\n  {\r\n    if (!element._store || element._store.validated || element.key != null) {\r\n      return;\r\n    }\r\n\r\n    element._store.validated = true;\r\n    var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);\r\n\r\n    if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {\r\n      return;\r\n    }\r\n\r\n    ownerHasKeyUseWarning[currentComponentErrorInfo] = true; // Usually the current owner is the offender, but if it accepts children as a\r\n    // property, it may be the creator of the child that's responsible for\r\n    // assigning it a key.\r\n\r\n    var childOwner = '';\r\n\r\n    if (element && element._owner && element._owner !== ReactCurrentOwner$1.current) {\r\n      // Give the component that originally created this child.\r\n      childOwner = \" It was passed a child from \" + getComponentNameFromType(element._owner.type) + \".\";\r\n    }\r\n\r\n    setCurrentlyValidatingElement$1(element);\r\n\r\n    error('Each child in a list should have a unique \"key\" prop.' + '%s%s See https://reactjs.org/link/warning-keys for more information.', currentComponentErrorInfo, childOwner);\r\n\r\n    setCurrentlyValidatingElement$1(null);\r\n  }\r\n}\r\n/**\r\n * Ensure that every element either is passed in a static location, in an\r\n * array with an explicit keys property defined, or in an object literal\r\n * with valid key property.\r\n *\r\n * @internal\r\n * @param {ReactNode} node Statically passed child of any type.\r\n * @param {*} parentType node's parent's type.\r\n */\r\n\r\n\r\nfunction validateChildKeys(node, parentType) {\r\n  {\r\n    if (typeof node !== 'object') {\r\n      return;\r\n    }\r\n\r\n    if (isArray(node)) {\r\n      for (var i = 0; i < node.length; i++) {\r\n        var child = node[i];\r\n\r\n        if (isValidElement(child)) {\r\n          validateExplicitKey(child, parentType);\r\n        }\r\n      }\r\n    } else if (isValidElement(node)) {\r\n      // This element was passed in a valid location.\r\n      if (node._store) {\r\n        node._store.validated = true;\r\n      }\r\n    } else if (node) {\r\n      var iteratorFn = getIteratorFn(node);\r\n\r\n      if (typeof iteratorFn === 'function') {\r\n        // Entry iterators used to provide implicit keys,\r\n        // but now we print a separate warning for them later.\r\n        if (iteratorFn !== node.entries) {\r\n          var iterator = iteratorFn.call(node);\r\n          var step;\r\n\r\n          while (!(step = iterator.next()).done) {\r\n            if (isValidElement(step.value)) {\r\n              validateExplicitKey(step.value, parentType);\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n/**\r\n * Given an element, validate that its props follow the propTypes definition,\r\n * provided by the type.\r\n *\r\n * @param {ReactElement} element\r\n */\r\n\r\n\r\nfunction validatePropTypes(element) {\r\n  {\r\n    var type = element.type;\r\n\r\n    if (type === null || type === undefined || typeof type === 'string') {\r\n      return;\r\n    }\r\n\r\n    var propTypes;\r\n\r\n    if (typeof type === 'function') {\r\n      propTypes = type.propTypes;\r\n    } else if (typeof type === 'object' && (type.$$typeof === REACT_FORWARD_REF_TYPE || // Note: Memo only checks outer props here.\r\n    // Inner props are checked in the reconciler.\r\n    type.$$typeof === REACT_MEMO_TYPE)) {\r\n      propTypes = type.propTypes;\r\n    } else {\r\n      return;\r\n    }\r\n\r\n    if (propTypes) {\r\n      // Intentionally inside to avoid triggering lazy initializers:\r\n      var name = getComponentNameFromType(type);\r\n      checkPropTypes(propTypes, element.props, 'prop', name, element);\r\n    } else if (type.PropTypes !== undefined && !propTypesMisspellWarningShown) {\r\n      propTypesMisspellWarningShown = true; // Intentionally inside to avoid triggering lazy initializers:\r\n\r\n      var _name = getComponentNameFromType(type);\r\n\r\n      error('Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?', _name || 'Unknown');\r\n    }\r\n\r\n    if (typeof type.getDefaultProps === 'function' && !type.getDefaultProps.isReactClassApproved) {\r\n      error('getDefaultProps is only used on classic React.createClass ' + 'definitions. Use a static property named `defaultProps` instead.');\r\n    }\r\n  }\r\n}\r\n/**\r\n * Given a fragment, validate that it can only be provided with fragment props\r\n * @param {ReactElement} fragment\r\n */\r\n\r\n\r\nfunction validateFragmentProps(fragment) {\r\n  {\r\n    var keys = Object.keys(fragment.props);\r\n\r\n    for (var i = 0; i < keys.length; i++) {\r\n      var key = keys[i];\r\n\r\n      if (key !== 'children' && key !== 'key') {\r\n        setCurrentlyValidatingElement$1(fragment);\r\n\r\n        error('Invalid prop `%s` supplied to `React.Fragment`. ' + 'React.Fragment can only have `key` and `children` props.', key);\r\n\r\n        setCurrentlyValidatingElement$1(null);\r\n        break;\r\n      }\r\n    }\r\n\r\n    if (fragment.ref !== null) {\r\n      setCurrentlyValidatingElement$1(fragment);\r\n\r\n      error('Invalid attribute `ref` supplied to `React.Fragment`.');\r\n\r\n      setCurrentlyValidatingElement$1(null);\r\n    }\r\n  }\r\n}\r\n\r\nfunction jsxWithValidation(type, props, key, isStaticChildren, source, self) {\r\n  {\r\n    var validType = isValidElementType(type); // We warn in this case but don't throw. We expect the element creation to\r\n    // succeed and there will likely be errors in render.\r\n\r\n    if (!validType) {\r\n      var info = '';\r\n\r\n      if (type === undefined || typeof type === 'object' && type !== null && Object.keys(type).length === 0) {\r\n        info += ' You likely forgot to export your component from the file ' + \"it's defined in, or you might have mixed up default and named imports.\";\r\n      }\r\n\r\n      var sourceInfo = getSourceInfoErrorAddendum(source);\r\n\r\n      if (sourceInfo) {\r\n        info += sourceInfo;\r\n      } else {\r\n        info += getDeclarationErrorAddendum();\r\n      }\r\n\r\n      var typeString;\r\n\r\n      if (type === null) {\r\n        typeString = 'null';\r\n      } else if (isArray(type)) {\r\n        typeString = 'array';\r\n      } else if (type !== undefined && type.$$typeof === REACT_ELEMENT_TYPE) {\r\n        typeString = \"<\" + (getComponentNameFromType(type.type) || 'Unknown') + \" />\";\r\n        info = ' Did you accidentally export a JSX literal instead of a component?';\r\n      } else {\r\n        typeString = typeof type;\r\n      }\r\n\r\n      error('React.jsx: type is invalid -- expected a string (for ' + 'built-in components) or a class/function (for composite ' + 'components) but got: %s.%s', typeString, info);\r\n    }\r\n\r\n    var element = jsxDEV(type, props, key, source, self); // The result can be nullish if a mock or a custom function is used.\r\n    // TODO: Drop this when these are no longer allowed as the type argument.\r\n\r\n    if (element == null) {\r\n      return element;\r\n    } // Skip key warning if the type isn't valid since our key validation logic\r\n    // doesn't expect a non-string/function type and can throw confusing errors.\r\n    // We don't want exception behavior to differ between dev and prod.\r\n    // (Rendering will throw with a helpful message and as soon as the type is\r\n    // fixed, the key warnings will appear.)\r\n\r\n\r\n    if (validType) {\r\n      var children = props.children;\r\n\r\n      if (children !== undefined) {\r\n        if (isStaticChildren) {\r\n          if (isArray(children)) {\r\n            for (var i = 0; i < children.length; i++) {\r\n              validateChildKeys(children[i], type);\r\n            }\r\n\r\n            if (Object.freeze) {\r\n              Object.freeze(children);\r\n            }\r\n          } else {\r\n            error('React.jsx: Static children should always be an array. ' + 'You are likely explicitly calling React.jsxs or React.jsxDEV. ' + 'Use the Babel transform instead.');\r\n          }\r\n        } else {\r\n          validateChildKeys(children, type);\r\n        }\r\n      }\r\n    }\r\n\r\n    if (type === REACT_FRAGMENT_TYPE) {\r\n      validateFragmentProps(element);\r\n    } else {\r\n      validatePropTypes(element);\r\n    }\r\n\r\n    return element;\r\n  }\r\n} // These two functions exist to still get child warnings in dev\r\n\r\nvar jsxDEV$1 =  jsxWithValidation ;\r\n\r\nexports.Fragment = REACT_FRAGMENT_TYPE;\r\nexports.jsxDEV = jsxDEV$1;\r\n  })();\r\n}\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVhY3QvY2pzL3JlYWN0LWpzeC1kZXYtcnVudGltZS5kZXZlbG9wbWVudC5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNhO0FBQ2I7QUFDQSxJQUFJLElBQXFDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBLFlBQVksbUJBQU8sQ0FBQyw0Q0FBTztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpR0FBaUcsZUFBZTtBQUNoSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLEdBQUc7QUFDUjtBQUNBLGtEQUFrRDtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQSxTQUFTO0FBQ1QsdUJBQXVCO0FBQ3ZCO0FBQ0EsU0FBUztBQUNULHVCQUF1QjtBQUN2QjtB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cEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEdBQUc7QUFDZCxXQUFXLEdBQUc7QUFDZCxXQUFXLEdBQUc7QUFDZCxXQUFXLGVBQWU7QUFDMUIsV0FBVyxHQUFHO0FBQ2QsV0FBVyxHQUFHO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEdBQUc7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssR0FBRztBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssR0FBRztBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEdBQUc7QUFDZCxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQiwyREFBMkQsVUFBVTtBQUNyRSx5QkFBeUIsVUFBVTtBQUNuQztBQUNBLGFBQWEsVUFBVTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCLFlBQVksU0FBUztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsY0FBYztBQUN6QixXQUFXLEdBQUc7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RDtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxXQUFXO0FBQ3RCLFdBQVcsR0FBRztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGlCQUFpQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsY0FBYztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLDRDQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsY0FBYztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixpQkFBaUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBEO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixxQkFBcUI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEIsY0FBYztBQUNkLEdBQUc7QUFDSCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvcmVhY3QvY2pzL3JlYWN0LWpzeC1kZXYtcnVudGltZS5kZXZlbG9wbWVudC5qcz8xN2UxIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxyXG4gKiBAbGljZW5zZSBSZWFjdFxyXG4gKiByZWFjdC1qc3gtZGV2LXJ1bnRpbWUuZGV2ZWxvcG1lbnQuanNcclxuICpcclxuICogQ29weXJpZ2h0IChjKSBGYWNlYm9vaywgSW5jLiBhbmQgaXRzIGFmZmlsaWF0ZXMuXHJcbiAqXHJcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxyXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXHJcbiAqL1xyXG5cclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xyXG4gIChmdW5jdGlvbigpIHtcclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIFJlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcclxuXHJcbi8vIEFUVEVOVElPTlxyXG4vLyBXaGVuIGFkZGluZyBuZXcgc3ltYm9scyB0byB0aGlzIGZpbGUsXHJcbi8vIFBsZWFzZSBjb25zaWRlciBhbHNvIGFkZGluZyB0byAncmVhY3QtZGV2dG9vbHMtc2hhcmVkL3NyYy9iYWNrZW5kL1JlYWN0U3ltYm9scydcclxuLy8gVGhlIFN5bWJvbCB1c2VkIHRvIHRhZyB0aGUgUmVhY3RFbGVtZW50LWxpa2UgdHlwZXMuXHJcbnZhciBSRUFDVF9FTEVNRU5UX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5lbGVtZW50Jyk7XHJcbnZhciBSRUFDVF9QT1JUQUxfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LnBvcnRhbCcpO1xyXG52YXIgUkVBQ1RfRlJBR01FTlRfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmZyYWdtZW50Jyk7XHJcbnZhciBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFID0gU3ltYm9sLmZvcigncmVhY3Quc3RyaWN0X21vZGUnKTtcclxudmFyIFJFQUNUX1BST0ZJTEVSX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5wcm9maWxlcicpO1xyXG52YXIgUkVBQ1RfUFJPVklERVJfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LnByb3ZpZGVyJyk7XHJcbnZhciBSRUFDVF9DT05URVhUX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5jb250ZXh0Jyk7XHJcbnZhciBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QuZm9yd2FyZF9yZWYnKTtcclxudmFyIFJFQUNUX1NVU1BFTlNFX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5zdXNwZW5zZScpO1xyXG52YXIgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFID0gU3ltYm9sLmZvcigncmVhY3Quc3VzcGVuc2VfbGlzdCcpO1xyXG52YXIgUkVBQ1RfTUVNT19UWVBFID0gU3ltYm9sLmZvcigncmVhY3QubWVtbycpO1xyXG52YXIgUkVBQ1RfTEFaWV9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QubGF6eScpO1xyXG52YXIgUkVBQ1RfT0ZGU0NSRUVOX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5vZmZzY3JlZW4nKTtcclxudmFyIE1BWUJFX0lURVJBVE9SX1NZTUJPTCA9IFN5bWJvbC5pdGVyYXRvcjtcclxudmFyIEZBVVhfSVRFUkFUT1JfU1lNQk9MID0gJ0BAaXRlcmF0b3InO1xyXG5mdW5jdGlvbiBnZXRJdGVyYXRvckZuKG1heWJlSXRlcmFibGUpIHtcclxuICBpZiAobWF5YmVJdGVyYWJsZSA9PT0gbnVsbCB8fCB0eXBlb2YgbWF5YmVJdGVyYWJsZSAhPT0gJ29iamVjdCcpIHtcclxuICAgIHJldHVybiBudWxsO1xyXG4gIH1cclxuXHJcbiAgdmFyIG1heWJlSXRlcmF0b3IgPSBNQVlCRV9JVEVSQVRPUl9TWU1CT0wgJiYgbWF5YmVJdGVyYWJsZVtNQVlCRV9JVEVSQVRPUl9TWU1CT0xdIHx8IG1heWJlSXRlcmFibGVbRkFVWF9JVEVSQVRPUl9TWU1CT0xdO1xyXG5cclxuICBpZiAodHlwZW9mIG1heWJlSXRlcmF0b3IgPT09ICdmdW5jdGlvbicpIHtcclxuICAgIHJldHVybiBtYXliZUl0ZXJhdG9yO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIG51bGw7XHJcbn1cclxuXHJcbnZhciBSZWFjdFNoYXJlZEludGVybmFscyA9IFJlYWN0Ll9fU0VDUkVUX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1lPVV9XSUxMX0JFX0ZJUkVEO1xyXG5cclxuZnVuY3Rpb24gZXJyb3IoZm9ybWF0KSB7XHJcbiAge1xyXG4gICAge1xyXG4gICAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjIgPiAxID8gX2xlbjIgLSAxIDogMCksIF9rZXkyID0gMTsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xyXG4gICAgICAgIGFyZ3NbX2tleTIgLSAxXSA9IGFyZ3VtZW50c1tfa2V5Ml07XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHByaW50V2FybmluZygnZXJyb3InLCBmb3JtYXQsIGFyZ3MpO1xyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxuZnVuY3Rpb24gcHJpbnRXYXJuaW5nKGxldmVsLCBmb3JtYXQsIGFyZ3MpIHtcclxuICAvLyBXaGVuIGNoYW5naW5nIHRoaXMgbG9naWMsIHlvdSBtaWdodCB3YW50IHRvIGFsc29cclxuICAvLyB1cGRhdGUgY29uc29sZVdpdGhTdGFja0Rldi53d3cuanMgYXMgd2VsbC5cclxuICB7XHJcbiAgICB2YXIgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0RGVidWdDdXJyZW50RnJhbWU7XHJcbiAgICB2YXIgc3RhY2sgPSBSZWFjdERlYnVnQ3VycmVudEZyYW1lLmdldFN0YWNrQWRkZW5kdW0oKTtcclxuXHJcbiAgICBpZiAoc3RhY2sgIT09ICcnKSB7XHJcbiAgICAgIGZvcm1hdCArPSAnJXMnO1xyXG4gICAgICBhcmdzID0gYXJncy5jb25jYXQoW3N0YWNrXSk7XHJcbiAgICB9IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1pbnRlcm5hbC9zYWZlLXN0cmluZy1jb2VyY2lvblxyXG5cclxuXHJcbiAgICB2YXIgYXJnc1dpdGhGb3JtYXQgPSBhcmdzLm1hcChmdW5jdGlvbiAoaXRlbSkge1xyXG4gICAgICByZXR1cm4gU3RyaW5nKGl0ZW0pO1xyXG4gICAgfSk7IC8vIENhcmVmdWw6IFJOIGN1cnJlbnRseSBkZXBlbmRzIG9uIHRoaXMgcHJlZml4XHJcblxyXG4gICAgYXJnc1dpdGhGb3JtYXQudW5zaGlmdCgnV2FybmluZzogJyArIGZvcm1hdCk7IC8vIFdlIGludGVudGlvbmFsbHkgZG9uJ3QgdXNlIHNwcmVhZCAob3IgLmFwcGx5KSBkaXJlY3RseSBiZWNhdXNlIGl0XHJcbiAgICAvLyBicmVha3MgSUU5OiBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzEzNjEwXHJcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nXHJcblxyXG4gICAgRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5LmNhbGwoY29uc29sZVtsZXZlbF0sIGNvbnNvbGUsIGFyZ3NXaXRoRm9ybWF0KTtcclxuICB9XHJcbn1cclxuXHJcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcblxyXG52YXIgZW5hYmxlU2NvcGVBUEkgPSBmYWxzZTsgLy8gRXhwZXJpbWVudGFsIENyZWF0ZSBFdmVudCBIYW5kbGUgQVBJLlxyXG52YXIgZW5hYmxlQ2FjaGVFbGVtZW50ID0gZmFsc2U7XHJcbnZhciBlbmFibGVUcmFuc2l0aW9uVHJhY2luZyA9IGZhbHNlOyAvLyBObyBrbm93biBidWdzLCBidXQgbmVlZHMgcGVyZm9ybWFuY2UgdGVzdGluZ1xyXG5cclxudmFyIGVuYWJsZUxlZ2FjeUhpZGRlbiA9IGZhbHNlOyAvLyBFbmFibGVzIHVuc3RhYmxlX2F2b2lkVGhpc0ZhbGxiYWNrIGZlYXR1cmUgaW4gRmliZXJcclxuLy8gc3R1ZmYuIEludGVuZGVkIHRvIGVuYWJsZSBSZWFjdCBjb3JlIG1lbWJlcnMgdG8gbW9yZSBlYXNpbHkgZGVidWcgc2NoZWR1bGluZ1xyXG4vLyBpc3N1ZXMgaW4gREVWIGJ1aWxkcy5cclxuXHJcbnZhciBlbmFibGVEZWJ1Z1RyYWNpbmcgPSBmYWxzZTsgLy8gVHJhY2sgd2hpY2ggRmliZXIocykgc2NoZWR1bGUgcmVuZGVyIHdvcmsuXHJcblxyXG52YXIgUkVBQ1RfTU9EVUxFX1JFRkVSRU5DRTtcclxuXHJcbntcclxuICBSRUFDVF9NT0RVTEVfUkVGRVJFTkNFID0gU3ltYm9sLmZvcigncmVhY3QubW9kdWxlLnJlZmVyZW5jZScpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBpc1ZhbGlkRWxlbWVudFR5cGUodHlwZSkge1xyXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicpIHtcclxuICAgIHJldHVybiB0cnVlO1xyXG4gIH0gLy8gTm90ZTogdHlwZW9mIG1pZ2h0IGJlIG90aGVyIHRoYW4gJ3N5bWJvbCcgb3IgJ251bWJlcicgKGUuZy4gaWYgaXQncyBhIHBvbHlmaWxsKS5cclxuXHJcblxyXG4gIGlmICh0eXBlID09PSBSRUFDVF9GUkFHTUVOVF9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX1BST0ZJTEVSX1RZUEUgfHwgZW5hYmxlRGVidWdUcmFjaW5nICB8fCB0eXBlID09PSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX1NVU1BFTlNFX1RZUEUgfHwgdHlwZSA9PT0gUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFIHx8IGVuYWJsZUxlZ2FjeUhpZGRlbiAgfHwgdHlwZSA9PT0gUkVBQ1RfT0ZGU0NSRUVOX1RZUEUgfHwgZW5hYmxlU2NvcGVBUEkgIHx8IGVuYWJsZUNhY2hlRWxlbWVudCAgfHwgZW5hYmxlVHJhbnNpdGlvblRyYWNpbmcgKSB7XHJcbiAgICByZXR1cm4gdHJ1ZTtcclxuICB9XHJcblxyXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcgJiYgdHlwZSAhPT0gbnVsbCkge1xyXG4gICAgaWYgKHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0xBWllfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9NRU1PX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfUFJPVklERVJfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9DT05URVhUX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSB8fCAvLyBUaGlzIG5lZWRzIHRvIGluY2x1ZGUgYWxsIHBvc3NpYmxlIG1vZHVsZSByZWZlcmVuY2Ugb2JqZWN0XHJcbiAgICAvLyB0eXBlcyBzdXBwb3J0ZWQgYnkgYW55IEZsaWdodCBjb25maWd1cmF0aW9uIGFueXdoZXJlIHNpbmNlXHJcbiAgICAvLyB3ZSBkb24ndCBrbm93IHdoaWNoIEZsaWdodCBidWlsZCB0aGlzIHdpbGwgZW5kIHVwIGJlaW5nIHVzZWRcclxuICAgIC8vIHdpdGguXHJcbiAgICB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9NT0RVTEVfUkVGRVJFTkNFIHx8IHR5cGUuZ2V0TW9kdWxlSWQgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHJldHVybiBmYWxzZTtcclxufVxyXG5cclxuZnVuY3Rpb24gZ2V0V3JhcHBlZE5hbWUob3V0ZXJUeXBlLCBpbm5lclR5cGUsIHdyYXBwZXJOYW1lKSB7XHJcbiAgdmFyIGRpc3BsYXlOYW1lID0gb3V0ZXJUeXBlLmRpc3BsYXlOYW1lO1xyXG5cclxuICBpZiAoZGlzcGxheU5hbWUpIHtcclxuICAgIHJldHVybiBkaXNwbGF5TmFtZTtcclxuICB9XHJcblxyXG4gIHZhciBmdW5jdGlvbk5hbWUgPSBpbm5lclR5cGUuZGlzcGxheU5hbWUgfHwgaW5uZXJUeXBlLm5hbWUgfHwgJyc7XHJcbiAgcmV0dXJuIGZ1bmN0aW9uTmFtZSAhPT0gJycgPyB3cmFwcGVyTmFtZSArIFwiKFwiICsgZnVuY3Rpb25OYW1lICsgXCIpXCIgOiB3cmFwcGVyTmFtZTtcclxufSAvLyBLZWVwIGluIHN5bmMgd2l0aCByZWFjdC1yZWNvbmNpbGVyL2dldENvbXBvbmVudE5hbWVGcm9tRmliZXJcclxuXHJcblxyXG5mdW5jdGlvbiBnZXRDb250ZXh0TmFtZSh0eXBlKSB7XHJcbiAgcmV0dXJuIHR5cGUuZGlzcGxheU5hbWUgfHwgJ0NvbnRleHQnO1xyXG59IC8vIE5vdGUgdGhhdCB0aGUgcmVjb25jaWxlciBwYWNrYWdlIHNob3VsZCBnZW5lcmFsbHkgcHJlZmVyIHRvIHVzZSBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKCkgaW5zdGVhZC5cclxuXHJcblxyXG5mdW5jdGlvbiBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZSkge1xyXG4gIGlmICh0eXBlID09IG51bGwpIHtcclxuICAgIC8vIEhvc3Qgcm9vdCwgdGV4dCBub2RlIG9yIGp1c3QgaW52YWxpZCB0eXBlLlxyXG4gICAgcmV0dXJuIG51bGw7XHJcbiAgfVxyXG5cclxuICB7XHJcbiAgICBpZiAodHlwZW9mIHR5cGUudGFnID09PSAnbnVtYmVyJykge1xyXG4gICAgICBlcnJvcignUmVjZWl2ZWQgYW4gdW5leHBlY3RlZCBvYmplY3QgaW4gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKCkuICcgKyAnVGhpcyBpcyBsaWtlbHkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICByZXR1cm4gdHlwZS5kaXNwbGF5TmFtZSB8fCB0eXBlLm5hbWUgfHwgbnVsbDtcclxuICB9XHJcblxyXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycpIHtcclxuICAgIHJldHVybiB0eXBlO1xyXG4gIH1cclxuXHJcbiAgc3dpdGNoICh0eXBlKSB7XHJcbiAgICBjYXNlIFJFQUNUX0ZSQUdNRU5UX1RZUEU6XHJcbiAgICAgIHJldHVybiAnRnJhZ21lbnQnO1xyXG5cclxuICAgIGNhc2UgUkVBQ1RfUE9SVEFMX1RZUEU6XHJcbiAgICAgIHJldHVybiAnUG9ydGFsJztcclxuXHJcbiAgICBjYXNlIFJFQUNUX1BST0ZJTEVSX1RZUEU6XHJcbiAgICAgIHJldHVybiAnUHJvZmlsZXInO1xyXG5cclxuICAgIGNhc2UgUkVBQ1RfU1RSSUNUX01PREVfVFlQRTpcclxuICAgICAgcmV0dXJuICdTdHJpY3RNb2RlJztcclxuXHJcbiAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX1RZUEU6XHJcbiAgICAgIHJldHVybiAnU3VzcGVuc2UnO1xyXG5cclxuICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFOlxyXG4gICAgICByZXR1cm4gJ1N1c3BlbnNlTGlzdCc7XHJcblxyXG4gIH1cclxuXHJcbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnb2JqZWN0Jykge1xyXG4gICAgc3dpdGNoICh0eXBlLiQkdHlwZW9mKSB7XHJcbiAgICAgIGNhc2UgUkVBQ1RfQ09OVEVYVF9UWVBFOlxyXG4gICAgICAgIHZhciBjb250ZXh0ID0gdHlwZTtcclxuICAgICAgICByZXR1cm4gZ2V0Q29udGV4dE5hbWUoY29udGV4dCkgKyAnLkNvbnN1bWVyJztcclxuXHJcbiAgICAgIGNhc2UgUkVBQ1RfUFJPVklERVJfVFlQRTpcclxuICAgICAgICB2YXIgcHJvdmlkZXIgPSB0eXBlO1xyXG4gICAgICAgIHJldHVybiBnZXRDb250ZXh0TmFtZShwcm92aWRlci5fY29udGV4dCkgKyAnLlByb3ZpZGVyJztcclxuXHJcbiAgICAgIGNhc2UgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRTpcclxuICAgICAgICByZXR1cm4gZ2V0V3JhcHBlZE5hbWUodHlwZSwgdHlwZS5yZW5kZXIsICdGb3J3YXJkUmVmJyk7XHJcblxyXG4gICAgICBjYXNlIFJFQUNUX01FTU9fVFlQRTpcclxuICAgICAgICB2YXIgb3V0ZXJOYW1lID0gdHlwZS5kaXNwbGF5TmFtZSB8fCBudWxsO1xyXG5cclxuICAgICAgICBpZiAob3V0ZXJOYW1lICE9PSBudWxsKSB7XHJcbiAgICAgICAgICByZXR1cm4gb3V0ZXJOYW1lO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlLnR5cGUpIHx8ICdNZW1vJztcclxuXHJcbiAgICAgIGNhc2UgUkVBQ1RfTEFaWV9UWVBFOlxyXG4gICAgICAgIHtcclxuICAgICAgICAgIHZhciBsYXp5Q29tcG9uZW50ID0gdHlwZTtcclxuICAgICAgICAgIHZhciBwYXlsb2FkID0gbGF6eUNvbXBvbmVudC5fcGF5bG9hZDtcclxuICAgICAgICAgIHZhciBpbml0ID0gbGF6eUNvbXBvbmVudC5faW5pdDtcclxuXHJcbiAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICByZXR1cm4gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKGluaXQocGF5bG9hZCkpO1xyXG4gICAgICAgICAgfSBjYXRjaCAoeCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZmFsbHRocm91Z2hcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHJldHVybiBudWxsO1xyXG59XHJcblxyXG52YXIgYXNzaWduID0gT2JqZWN0LmFzc2lnbjtcclxuXHJcbi8vIEhlbHBlcnMgdG8gcGF0Y2ggY29uc29sZS5sb2dzIHRvIGF2b2lkIGxvZ2dpbmcgZHVyaW5nIHNpZGUtZWZmZWN0IGZyZWVcclxuLy8gcmVwbGF5aW5nIG9uIHJlbmRlciBmdW5jdGlvbi4gVGhpcyBjdXJyZW50bHkgb25seSBwYXRjaGVzIHRoZSBvYmplY3RcclxuLy8gbGF6aWx5IHdoaWNoIHdvbid0IGNvdmVyIGlmIHRoZSBsb2cgZnVuY3Rpb24gd2FzIGV4dHJhY3RlZCBlYWdlcmx5LlxyXG4vLyBXZSBjb3VsZCBhbHNvIGVhZ2VybHkgcGF0Y2ggdGhlIG1ldGhvZC5cclxudmFyIGRpc2FibGVkRGVwdGggPSAwO1xyXG52YXIgcHJldkxvZztcclxudmFyIHByZXZJbmZvO1xyXG52YXIgcHJldldhcm47XHJcbnZhciBwcmV2RXJyb3I7XHJcbnZhciBwcmV2R3JvdXA7XHJcbnZhciBwcmV2R3JvdXBDb2xsYXBzZWQ7XHJcbnZhciBwcmV2R3JvdXBFbmQ7XHJcblxyXG5mdW5jdGlvbiBkaXNhYmxlZExvZygpIHt9XHJcblxyXG5kaXNhYmxlZExvZy5fX3JlYWN0RGlzYWJsZWRMb2cgPSB0cnVlO1xyXG5mdW5jdGlvbiBkaXNhYmxlTG9ncygpIHtcclxuICB7XHJcbiAgICBpZiAoZGlzYWJsZWREZXB0aCA9PT0gMCkge1xyXG4gICAgICAvKiBlc2xpbnQtZGlzYWJsZSByZWFjdC1pbnRlcm5hbC9uby1wcm9kdWN0aW9uLWxvZ2dpbmcgKi9cclxuICAgICAgcHJldkxvZyA9IGNvbnNvbGUubG9nO1xyXG4gICAgICBwcmV2SW5mbyA9IGNvbnNvbGUuaW5mbztcclxuICAgICAgcHJldldhcm4gPSBjb25zb2xlLndhcm47XHJcbiAgICAgIHByZXZFcnJvciA9IGNvbnNvbGUuZXJyb3I7XHJcbiAgICAgIHByZXZHcm91cCA9IGNvbnNvbGUuZ3JvdXA7XHJcbiAgICAgIHByZXZHcm91cENvbGxhcHNlZCA9IGNvbnNvbGUuZ3JvdXBDb2xsYXBzZWQ7XHJcbiAgICAgIHByZXZHcm91cEVuZCA9IGNvbnNvbGUuZ3JvdXBFbmQ7IC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTkwOTlcclxuXHJcbiAgICAgIHZhciBwcm9wcyA9IHtcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICB2YWx1ZTogZGlzYWJsZWRMb2csXHJcbiAgICAgICAgd3JpdGFibGU6IHRydWVcclxuICAgICAgfTsgLy8gJEZsb3dGaXhNZSBGbG93IHRoaW5rcyBjb25zb2xlIGlzIGltbXV0YWJsZS5cclxuXHJcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGNvbnNvbGUsIHtcclxuICAgICAgICBpbmZvOiBwcm9wcyxcclxuICAgICAgICBsb2c6IHByb3BzLFxyXG4gICAgICAgIHdhcm46IHByb3BzLFxyXG4gICAgICAgIGVycm9yOiBwcm9wcyxcclxuICAgICAgICBncm91cDogcHJvcHMsXHJcbiAgICAgICAgZ3JvdXBDb2xsYXBzZWQ6IHByb3BzLFxyXG4gICAgICAgIGdyb3VwRW5kOiBwcm9wc1xyXG4gICAgICB9KTtcclxuICAgICAgLyogZXNsaW50LWVuYWJsZSByZWFjdC1pbnRlcm5hbC9uby1wcm9kdWN0aW9uLWxvZ2dpbmcgKi9cclxuICAgIH1cclxuXHJcbiAgICBkaXNhYmxlZERlcHRoKys7XHJcbiAgfVxyXG59XHJcbmZ1bmN0aW9uIHJlZW5hYmxlTG9ncygpIHtcclxuICB7XHJcbiAgICBkaXNhYmxlZERlcHRoLS07XHJcblxyXG4gICAgaWYgKGRpc2FibGVkRGVwdGggPT09IDApIHtcclxuICAgICAgLyogZXNsaW50LWRpc2FibGUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nICovXHJcbiAgICAgIHZhciBwcm9wcyA9IHtcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICB3cml0YWJsZTogdHJ1ZVxyXG4gICAgICB9OyAvLyAkRmxvd0ZpeE1lIEZsb3cgdGhpbmtzIGNvbnNvbGUgaXMgaW1tdXRhYmxlLlxyXG5cclxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoY29uc29sZSwge1xyXG4gICAgICAgIGxvZzogYXNzaWduKHt9LCBwcm9wcywge1xyXG4gICAgICAgICAgdmFsdWU6IHByZXZMb2dcclxuICAgICAgICB9KSxcclxuICAgICAgICBpbmZvOiBhc3NpZ24oe30sIHByb3BzLCB7XHJcbiAgICAgICAgICB2YWx1ZTogcHJldkluZm9cclxuICAgICAgICB9KSxcclxuICAgICAgICB3YXJuOiBhc3NpZ24oe30sIHByb3BzLCB7XHJcbiAgICAgICAgICB2YWx1ZTogcHJldldhcm5cclxuICAgICAgICB9KSxcclxuICAgICAgICBlcnJvcjogYXNzaWduKHt9LCBwcm9wcywge1xyXG4gICAgICAgICAgdmFsdWU6IHByZXZFcnJvclxyXG4gICAgICAgIH0pLFxyXG4gICAgICAgIGdyb3VwOiBhc3NpZ24oe30sIHByb3BzLCB7XHJcbiAgICAgICAgICB2YWx1ZTogcHJldkdyb3VwXHJcbiAgICAgICAgfSksXHJcbiAgICAgICAgZ3JvdXBDb2xsYXBzZWQ6IGFzc2lnbih7fSwgcHJvcHMsIHtcclxuICAgICAgICAgIHZhbHVlOiBwcmV2R3JvdXBDb2xsYXBzZWRcclxuICAgICAgICB9KSxcclxuICAgICAgICBncm91cEVuZDogYXNzaWduKHt9LCBwcm9wcywge1xyXG4gICAgICAgICAgdmFsdWU6IHByZXZHcm91cEVuZFxyXG4gICAgICAgIH0pXHJcbiAgICAgIH0pO1xyXG4gICAgICAvKiBlc2xpbnQtZW5hYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChkaXNhYmxlZERlcHRoIDwgMCkge1xyXG4gICAgICBlcnJvcignZGlzYWJsZWREZXB0aCBmZWxsIGJlbG93IHplcm8uICcgKyAnVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcblxyXG52YXIgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0Q3VycmVudERpc3BhdGNoZXI7XHJcbnZhciBwcmVmaXg7XHJcbmZ1bmN0aW9uIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKG5hbWUsIHNvdXJjZSwgb3duZXJGbikge1xyXG4gIHtcclxuICAgIGlmIChwcmVmaXggPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAvLyBFeHRyYWN0IHRoZSBWTSBzcGVjaWZpYyBwcmVmaXggdXNlZCBieSBlYWNoIGxpbmUuXHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgdGhyb3cgRXJyb3IoKTtcclxuICAgICAgfSBjYXRjaCAoeCkge1xyXG4gICAgICAgIHZhciBtYXRjaCA9IHguc3RhY2sudHJpbSgpLm1hdGNoKC9cXG4oICooYXQgKT8pLyk7XHJcbiAgICAgICAgcHJlZml4ID0gbWF0Y2ggJiYgbWF0Y2hbMV0gfHwgJyc7XHJcbiAgICAgIH1cclxuICAgIH0gLy8gV2UgdXNlIHRoZSBwcmVmaXggdG8gZW5zdXJlIG91ciBzdGFja3MgbGluZSB1cCB3aXRoIG5hdGl2ZSBzdGFjayBmcmFtZXMuXHJcblxyXG5cclxuICAgIHJldHVybiAnXFxuJyArIHByZWZpeCArIG5hbWU7XHJcbiAgfVxyXG59XHJcbnZhciByZWVudHJ5ID0gZmFsc2U7XHJcbnZhciBjb21wb25lbnRGcmFtZUNhY2hlO1xyXG5cclxue1xyXG4gIHZhciBQb3NzaWJseVdlYWtNYXAgPSB0eXBlb2YgV2Vha01hcCA9PT0gJ2Z1bmN0aW9uJyA/IFdlYWtNYXAgOiBNYXA7XHJcbiAgY29tcG9uZW50RnJhbWVDYWNoZSA9IG5ldyBQb3NzaWJseVdlYWtNYXAoKTtcclxufVxyXG5cclxuZnVuY3Rpb24gZGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZShmbiwgY29uc3RydWN0KSB7XHJcbiAgLy8gSWYgc29tZXRoaW5nIGFza2VkIGZvciBhIHN0YWNrIGluc2lkZSBhIGZha2UgcmVuZGVyLCBpdCBzaG91bGQgZ2V0IGlnbm9yZWQuXHJcbiAgaWYgKCAhZm4gfHwgcmVlbnRyeSkge1xyXG4gICAgcmV0dXJuICcnO1xyXG4gIH1cclxuXHJcbiAge1xyXG4gICAgdmFyIGZyYW1lID0gY29tcG9uZW50RnJhbWVDYWNoZS5nZXQoZm4pO1xyXG5cclxuICAgIGlmIChmcmFtZSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgIHJldHVybiBmcmFtZTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHZhciBjb250cm9sO1xyXG4gIHJlZW50cnkgPSB0cnVlO1xyXG4gIHZhciBwcmV2aW91c1ByZXBhcmVTdGFja1RyYWNlID0gRXJyb3IucHJlcGFyZVN0YWNrVHJhY2U7IC8vICRGbG93Rml4TWUgSXQgZG9lcyBhY2NlcHQgdW5kZWZpbmVkLlxyXG5cclxuICBFcnJvci5wcmVwYXJlU3RhY2tUcmFjZSA9IHVuZGVmaW5lZDtcclxuICB2YXIgcHJldmlvdXNEaXNwYXRjaGVyO1xyXG5cclxuICB7XHJcbiAgICBwcmV2aW91c0Rpc3BhdGNoZXIgPSBSZWFjdEN1cnJlbnREaXNwYXRjaGVyLmN1cnJlbnQ7IC8vIFNldCB0aGUgZGlzcGF0Y2hlciBpbiBERVYgYmVjYXVzZSB0aGlzIG1pZ2h0IGJlIGNhbGwgaW4gdGhlIHJlbmRlciBmdW5jdGlvblxyXG4gICAgLy8gZm9yIHdhcm5pbmdzLlxyXG5cclxuICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIuY3VycmVudCA9IG51bGw7XHJcbiAgICBkaXNhYmxlTG9ncygpO1xyXG4gIH1cclxuXHJcbiAgdHJ5IHtcclxuICAgIC8vIFRoaXMgc2hvdWxkIHRocm93LlxyXG4gICAgaWYgKGNvbnN0cnVjdCkge1xyXG4gICAgICAvLyBTb21ldGhpbmcgc2hvdWxkIGJlIHNldHRpbmcgdGhlIHByb3BzIGluIHRoZSBjb25zdHJ1Y3Rvci5cclxuICAgICAgdmFyIEZha2UgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhyb3cgRXJyb3IoKTtcclxuICAgICAgfTsgLy8gJEZsb3dGaXhNZVxyXG5cclxuXHJcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShGYWtlLnByb3RvdHlwZSwgJ3Byb3BzJywge1xyXG4gICAgICAgIHNldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgLy8gV2UgdXNlIGEgdGhyb3dpbmcgc2V0dGVyIGluc3RlYWQgb2YgZnJvemVuIG9yIG5vbi13cml0YWJsZSBwcm9wc1xyXG4gICAgICAgICAgLy8gYmVjYXVzZSB0aGF0IHdvbid0IHRocm93IGluIGEgbm9uLXN0cmljdCBtb2RlIGZ1bmN0aW9uLlxyXG4gICAgICAgICAgdGhyb3cgRXJyb3IoKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSAnb2JqZWN0JyAmJiBSZWZsZWN0LmNvbnN0cnVjdCkge1xyXG4gICAgICAgIC8vIFdlIGNvbnN0cnVjdCBhIGRpZmZlcmVudCBjb250cm9sIGZvciB0aGlzIGNhc2UgdG8gaW5jbHVkZSBhbnkgZXh0cmFcclxuICAgICAgICAvLyBmcmFtZXMgYWRkZWQgYnkgdGhlIGNvbnN0cnVjdCBjYWxsLlxyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICBSZWZsZWN0LmNvbnN0cnVjdChGYWtlLCBbXSk7XHJcbiAgICAgICAgfSBjYXRjaCAoeCkge1xyXG4gICAgICAgICAgY29udHJvbCA9IHg7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBSZWZsZWN0LmNvbnN0cnVjdChmbiwgW10sIEZha2UpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICBGYWtlLmNhbGwoKTtcclxuICAgICAgICB9IGNhdGNoICh4KSB7XHJcbiAgICAgICAgICBjb250cm9sID0geDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZuLmNhbGwoRmFrZS5wcm90b3R5cGUpO1xyXG4gICAgICB9XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB0cnkge1xyXG4gICAgICAgIHRocm93IEVycm9yKCk7XHJcbiAgICAgIH0gY2F0Y2ggKHgpIHtcclxuICAgICAgICBjb250cm9sID0geDtcclxuICAgICAgfVxyXG5cclxuICAgICAgZm4oKTtcclxuICAgIH1cclxuICB9IGNhdGNoIChzYW1wbGUpIHtcclxuICAgIC8vIFRoaXMgaXMgaW5saW5lZCBtYW51YWxseSBiZWNhdXNlIGNsb3N1cmUgZG9lc24ndCBkbyBpdCBmb3IgdXMuXHJcbiAgICBpZiAoc2FtcGxlICYmIGNvbnRyb2wgJiYgdHlwZW9mIHNhbXBsZS5zdGFjayA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgLy8gVGhpcyBleHRyYWN0cyB0aGUgZmlyc3QgZnJhbWUgZnJvbSB0aGUgc2FtcGxlIHRoYXQgaXNuJ3QgYWxzbyBpbiB0aGUgY29udHJvbC5cclxuICAgICAgLy8gU2tpcHBpbmcgb25lIGZyYW1lIHRoYXQgd2UgYXNzdW1lIGlzIHRoZSBmcmFtZSB0aGF0IGNhbGxzIHRoZSB0d28uXHJcbiAgICAgIHZhciBzYW1wbGVMaW5lcyA9IHNhbXBsZS5zdGFjay5zcGxpdCgnXFxuJyk7XHJcbiAgICAgIHZhciBjb250cm9sTGluZXMgPSBjb250cm9sLnN0YWNrLnNwbGl0KCdcXG4nKTtcclxuICAgICAgdmFyIHMgPSBzYW1wbGVMaW5lcy5sZW5ndGggLSAxO1xyXG4gICAgICB2YXIgYyA9IGNvbnRyb2xMaW5lcy5sZW5ndGggLSAxO1xyXG5cclxuICAgICAgd2hpbGUgKHMgPj0gMSAmJiBjID49IDAgJiYgc2FtcGxlTGluZXNbc10gIT09IGNvbnRyb2xMaW5lc1tjXSkge1xyXG4gICAgICAgIC8vIFdlIGV4cGVjdCBhdCBsZWFzdCBvbmUgc3RhY2sgZnJhbWUgdG8gYmUgc2hhcmVkLlxyXG4gICAgICAgIC8vIFR5cGljYWxseSB0aGlzIHdpbGwgYmUgdGhlIHJvb3QgbW9zdCBvbmUuIEhvd2V2ZXIsIHN0YWNrIGZyYW1lcyBtYXkgYmVcclxuICAgICAgICAvLyBjdXQgb2ZmIGR1ZSB0byBtYXhpbXVtIHN0YWNrIGxpbWl0cy4gSW4gdGhpcyBjYXNlLCBvbmUgbWF5YmUgY3V0IG9mZlxyXG4gICAgICAgIC8vIGVhcmxpZXIgdGhhbiB0aGUgb3RoZXIuIFdlIGFzc3VtZSB0aGF0IHRoZSBzYW1wbGUgaXMgbG9uZ2VyIG9yIHRoZSBzYW1lXHJcbiAgICAgICAgLy8gYW5kIHRoZXJlIGZvciBjdXQgb2ZmIGVhcmxpZXIuIFNvIHdlIHNob3VsZCBmaW5kIHRoZSByb290IG1vc3QgZnJhbWUgaW5cclxuICAgICAgICAvLyB0aGUgc2FtcGxlIHNvbWV3aGVyZSBpbiB0aGUgY29udHJvbC5cclxuICAgICAgICBjLS07XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGZvciAoOyBzID49IDEgJiYgYyA+PSAwOyBzLS0sIGMtLSkge1xyXG4gICAgICAgIC8vIE5leHQgd2UgZmluZCB0aGUgZmlyc3Qgb25lIHRoYXQgaXNuJ3QgdGhlIHNhbWUgd2hpY2ggc2hvdWxkIGJlIHRoZVxyXG4gICAgICAgIC8vIGZyYW1lIHRoYXQgY2FsbGVkIG91ciBzYW1wbGUgZnVuY3Rpb24gYW5kIHRoZSBjb250cm9sLlxyXG4gICAgICAgIGlmIChzYW1wbGVMaW5lc1tzXSAhPT0gY29udHJvbExpbmVzW2NdKSB7XHJcbiAgICAgICAgICAvLyBJbiBWOCwgdGhlIGZpcnN0IGxpbmUgaXMgZGVzY3JpYmluZyB0aGUgbWVzc2FnZSBidXQgb3RoZXIgVk1zIGRvbid0LlxyXG4gICAgICAgICAgLy8gSWYgd2UncmUgYWJvdXQgdG8gcmV0dXJuIHRoZSBmaXJzdCBsaW5lLCBhbmQgdGhlIGNvbnRyb2wgaXMgYWxzbyBvbiB0aGUgc2FtZVxyXG4gICAgICAgICAgLy8gbGluZSwgdGhhdCdzIGEgcHJldHR5IGdvb2QgaW5kaWNhdG9yIHRoYXQgb3VyIHNhbXBsZSB0aHJldyBhdCBzYW1lIGxpbmUgYXNcclxuICAgICAgICAgIC8vIHRoZSBjb250cm9sLiBJLmUuIGJlZm9yZSB3ZSBlbnRlcmVkIHRoZSBzYW1wbGUgZnJhbWUuIFNvIHdlIGlnbm9yZSB0aGlzIHJlc3VsdC5cclxuICAgICAgICAgIC8vIFRoaXMgY2FuIGhhcHBlbiBpZiB5b3UgcGFzc2VkIGEgY2xhc3MgdG8gZnVuY3Rpb24gY29tcG9uZW50LCBvciBub24tZnVuY3Rpb24uXHJcbiAgICAgICAgICBpZiAocyAhPT0gMSB8fCBjICE9PSAxKSB7XHJcbiAgICAgICAgICAgIGRvIHtcclxuICAgICAgICAgICAgICBzLS07XHJcbiAgICAgICAgICAgICAgYy0tOyAvLyBXZSBtYXkgc3RpbGwgaGF2ZSBzaW1pbGFyIGludGVybWVkaWF0ZSBmcmFtZXMgZnJvbSB0aGUgY29uc3RydWN0IGNhbGwuXHJcbiAgICAgICAgICAgICAgLy8gVGhlIG5leHQgb25lIHRoYXQgaXNuJ3QgdGhlIHNhbWUgc2hvdWxkIGJlIG91ciBtYXRjaCB0aG91Z2guXHJcblxyXG4gICAgICAgICAgICAgIGlmIChjIDwgMCB8fCBzYW1wbGVMaW5lc1tzXSAhPT0gY29udHJvbExpbmVzW2NdKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBWOCBhZGRzIGEgXCJuZXdcIiBwcmVmaXggZm9yIG5hdGl2ZSBjbGFzc2VzLiBMZXQncyByZW1vdmUgaXQgdG8gbWFrZSBpdCBwcmV0dGllci5cclxuICAgICAgICAgICAgICAgIHZhciBfZnJhbWUgPSAnXFxuJyArIHNhbXBsZUxpbmVzW3NdLnJlcGxhY2UoJyBhdCBuZXcgJywgJyBhdCAnKTsgLy8gSWYgb3VyIGNvbXBvbmVudCBmcmFtZSBpcyBsYWJlbGVkIFwiPGFub255bW91cz5cIlxyXG4gICAgICAgICAgICAgICAgLy8gYnV0IHdlIGhhdmUgYSB1c2VyLXByb3ZpZGVkIFwiZGlzcGxheU5hbWVcIlxyXG4gICAgICAgICAgICAgICAgLy8gc3BsaWNlIGl0IGluIHRvIG1ha2UgdGhlIHN0YWNrIG1vcmUgcmVhZGFibGUuXHJcblxyXG5cclxuICAgICAgICAgICAgICAgIGlmIChmbi5kaXNwbGF5TmFtZSAmJiBfZnJhbWUuaW5jbHVkZXMoJzxhbm9ueW1vdXM+JykpIHtcclxuICAgICAgICAgICAgICAgICAgX2ZyYW1lID0gX2ZyYW1lLnJlcGxhY2UoJzxhbm9ueW1vdXM+JywgZm4uZGlzcGxheU5hbWUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudEZyYW1lQ2FjaGUuc2V0KGZuLCBfZnJhbWUpO1xyXG4gICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9IC8vIFJldHVybiB0aGUgbGluZSB3ZSBmb3VuZC5cclxuXHJcblxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9mcmFtZTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gd2hpbGUgKHMgPj0gMSAmJiBjID49IDApO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH0gZmluYWxseSB7XHJcbiAgICByZWVudHJ5ID0gZmFsc2U7XHJcblxyXG4gICAge1xyXG4gICAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyLmN1cnJlbnQgPSBwcmV2aW91c0Rpc3BhdGNoZXI7XHJcbiAgICAgIHJlZW5hYmxlTG9ncygpO1xyXG4gICAgfVxyXG5cclxuICAgIEVycm9yLnByZXBhcmVTdGFja1RyYWNlID0gcHJldmlvdXNQcmVwYXJlU3RhY2tUcmFjZTtcclxuICB9IC8vIEZhbGxiYWNrIHRvIGp1c3QgdXNpbmcgdGhlIG5hbWUgaWYgd2UgY291bGRuJ3QgbWFrZSBpdCB0aHJvdy5cclxuXHJcblxyXG4gIHZhciBuYW1lID0gZm4gPyBmbi5kaXNwbGF5TmFtZSB8fCBmbi5uYW1lIDogJyc7XHJcbiAgdmFyIHN5bnRoZXRpY0ZyYW1lID0gbmFtZSA/IGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKG5hbWUpIDogJyc7XHJcblxyXG4gIHtcclxuICAgIGlmICh0eXBlb2YgZm4gPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgY29tcG9uZW50RnJhbWVDYWNoZS5zZXQoZm4sIHN5bnRoZXRpY0ZyYW1lKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHJldHVybiBzeW50aGV0aWNGcmFtZTtcclxufVxyXG5mdW5jdGlvbiBkZXNjcmliZUZ1bmN0aW9uQ29tcG9uZW50RnJhbWUoZm4sIHNvdXJjZSwgb3duZXJGbikge1xyXG4gIHtcclxuICAgIHJldHVybiBkZXNjcmliZU5hdGl2ZUNvbXBvbmVudEZyYW1lKGZuLCBmYWxzZSk7XHJcbiAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBzaG91bGRDb25zdHJ1Y3QoQ29tcG9uZW50KSB7XHJcbiAgdmFyIHByb3RvdHlwZSA9IENvbXBvbmVudC5wcm90b3R5cGU7XHJcbiAgcmV0dXJuICEhKHByb3RvdHlwZSAmJiBwcm90b3R5cGUuaXNSZWFjdENvbXBvbmVudCk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVih0eXBlLCBzb3VyY2UsIG93bmVyRm4pIHtcclxuXHJcbiAgaWYgKHR5cGUgPT0gbnVsbCkge1xyXG4gICAgcmV0dXJuICcnO1xyXG4gIH1cclxuXHJcbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICB7XHJcbiAgICAgIHJldHVybiBkZXNjcmliZU5hdGl2ZUNvbXBvbmVudEZyYW1lKHR5cGUsIHNob3VsZENvbnN0cnVjdCh0eXBlKSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnKSB7XHJcbiAgICByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUodHlwZSk7XHJcbiAgfVxyXG5cclxuICBzd2l0Y2ggKHR5cGUpIHtcclxuICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfVFlQRTpcclxuICAgICAgcmV0dXJuIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKCdTdXNwZW5zZScpO1xyXG5cclxuICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFOlxyXG4gICAgICByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUoJ1N1c3BlbnNlTGlzdCcpO1xyXG4gIH1cclxuXHJcbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnb2JqZWN0Jykge1xyXG4gICAgc3dpdGNoICh0eXBlLiQkdHlwZW9mKSB7XHJcbiAgICAgIGNhc2UgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRTpcclxuICAgICAgICByZXR1cm4gZGVzY3JpYmVGdW5jdGlvbkNvbXBvbmVudEZyYW1lKHR5cGUucmVuZGVyKTtcclxuXHJcbiAgICAgIGNhc2UgUkVBQ1RfTUVNT19UWVBFOlxyXG4gICAgICAgIC8vIE1lbW8gbWF5IGNvbnRhaW4gYW55IGNvbXBvbmVudCB0eXBlIHNvIHdlIHJlY3Vyc2l2ZWx5IHJlc29sdmUgaXQuXHJcbiAgICAgICAgcmV0dXJuIGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVih0eXBlLnR5cGUsIHNvdXJjZSwgb3duZXJGbik7XHJcblxyXG4gICAgICBjYXNlIFJFQUNUX0xBWllfVFlQRTpcclxuICAgICAgICB7XHJcbiAgICAgICAgICB2YXIgbGF6eUNvbXBvbmVudCA9IHR5cGU7XHJcbiAgICAgICAgICB2YXIgcGF5bG9hZCA9IGxhenlDb21wb25lbnQuX3BheWxvYWQ7XHJcbiAgICAgICAgICB2YXIgaW5pdCA9IGxhenlDb21wb25lbnQuX2luaXQ7XHJcblxyXG4gICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgLy8gTGF6eSBtYXkgY29udGFpbiBhbnkgY29tcG9uZW50IHR5cGUgc28gd2UgcmVjdXJzaXZlbHkgcmVzb2x2ZSBpdC5cclxuICAgICAgICAgICAgcmV0dXJuIGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVihpbml0KHBheWxvYWQpLCBzb3VyY2UsIG93bmVyRm4pO1xyXG4gICAgICAgICAgfSBjYXRjaCAoeCkge31cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICByZXR1cm4gJyc7XHJcbn1cclxuXHJcbnZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XHJcblxyXG52YXIgbG9nZ2VkVHlwZUZhaWx1cmVzID0ge307XHJcbnZhciBSZWFjdERlYnVnQ3VycmVudEZyYW1lID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZTtcclxuXHJcbmZ1bmN0aW9uIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KGVsZW1lbnQpIHtcclxuICB7XHJcbiAgICBpZiAoZWxlbWVudCkge1xyXG4gICAgICB2YXIgb3duZXIgPSBlbGVtZW50Ll9vd25lcjtcclxuICAgICAgdmFyIHN0YWNrID0gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKGVsZW1lbnQudHlwZSwgZWxlbWVudC5fc291cmNlLCBvd25lciA/IG93bmVyLnR5cGUgOiBudWxsKTtcclxuICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5zZXRFeHRyYVN0YWNrRnJhbWUoc3RhY2spO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5zZXRFeHRyYVN0YWNrRnJhbWUobnVsbCk7XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBjaGVja1Byb3BUeXBlcyh0eXBlU3BlY3MsIHZhbHVlcywgbG9jYXRpb24sIGNvbXBvbmVudE5hbWUsIGVsZW1lbnQpIHtcclxuICB7XHJcbiAgICAvLyAkRmxvd0ZpeE1lIFRoaXMgaXMgb2theSBidXQgRmxvdyBkb2Vzbid0IGtub3cgaXQuXHJcbiAgICB2YXIgaGFzID0gRnVuY3Rpb24uY2FsbC5iaW5kKGhhc093blByb3BlcnR5KTtcclxuXHJcbiAgICBmb3IgKHZhciB0eXBlU3BlY05hbWUgaW4gdHlwZVNwZWNzKSB7XHJcbiAgICAgIGlmIChoYXModHlwZVNwZWNzLCB0eXBlU3BlY05hbWUpKSB7XHJcbiAgICAgICAgdmFyIGVycm9yJDEgPSB2b2lkIDA7IC8vIFByb3AgdHlwZSB2YWxpZGF0aW9uIG1heSB0aHJvdy4gSW4gY2FzZSB0aGV5IGRvLCB3ZSBkb24ndCB3YW50IHRvXHJcbiAgICAgICAgLy8gZmFpbCB0aGUgcmVuZGVyIHBoYXNlIHdoZXJlIGl0IGRpZG4ndCBmYWlsIGJlZm9yZS4gU28gd2UgbG9nIGl0LlxyXG4gICAgICAgIC8vIEFmdGVyIHRoZXNlIGhhdmUgYmVlbiBjbGVhbmVkIHVwLCB3ZSdsbCBsZXQgdGhlbSB0aHJvdy5cclxuXHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgIC8vIFRoaXMgaXMgaW50ZW50aW9uYWxseSBhbiBpbnZhcmlhbnQgdGhhdCBnZXRzIGNhdWdodC4gSXQncyB0aGUgc2FtZVxyXG4gICAgICAgICAgLy8gYmVoYXZpb3IgYXMgd2l0aG91dCB0aGlzIHN0YXRlbWVudCBleGNlcHQgd2l0aCBhIGJldHRlciBtZXNzYWdlLlxyXG4gICAgICAgICAgaWYgKHR5cGVvZiB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSAhPT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvcHJvZC1lcnJvci1jb2Rlc1xyXG4gICAgICAgICAgICB2YXIgZXJyID0gRXJyb3IoKGNvbXBvbmVudE5hbWUgfHwgJ1JlYWN0IGNsYXNzJykgKyAnOiAnICsgbG9jYXRpb24gKyAnIHR5cGUgYCcgKyB0eXBlU3BlY05hbWUgKyAnYCBpcyBpbnZhbGlkOyAnICsgJ2l0IG11c3QgYmUgYSBmdW5jdGlvbiwgdXN1YWxseSBmcm9tIHRoZSBgcHJvcC10eXBlc2AgcGFja2FnZSwgYnV0IHJlY2VpdmVkIGAnICsgdHlwZW9mIHR5cGVTcGVjc1t0eXBlU3BlY05hbWVdICsgJ2AuJyArICdUaGlzIG9mdGVuIGhhcHBlbnMgYmVjYXVzZSBvZiB0eXBvcyBzdWNoIGFzIGBQcm9wVHlwZXMuZnVuY3Rpb25gIGluc3RlYWQgb2YgYFByb3BUeXBlcy5mdW5jYC4nKTtcclxuICAgICAgICAgICAgZXJyLm5hbWUgPSAnSW52YXJpYW50IFZpb2xhdGlvbic7XHJcbiAgICAgICAgICAgIHRocm93IGVycjtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICBlcnJvciQxID0gdHlwZVNwZWNzW3R5cGVTcGVjTmFtZV0odmFsdWVzLCB0eXBlU3BlY05hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBudWxsLCAnU0VDUkVUX0RPX05PVF9QQVNTX1RISVNfT1JfWU9VX1dJTExfQkVfRklSRUQnKTtcclxuICAgICAgICB9IGNhdGNoIChleCkge1xyXG4gICAgICAgICAgZXJyb3IkMSA9IGV4O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGVycm9yJDEgJiYgIShlcnJvciQxIGluc3RhbmNlb2YgRXJyb3IpKSB7XHJcbiAgICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChlbGVtZW50KTtcclxuXHJcbiAgICAgICAgICBlcnJvcignJXM6IHR5cGUgc3BlY2lmaWNhdGlvbiBvZiAlcycgKyAnIGAlc2AgaXMgaW52YWxpZDsgdGhlIHR5cGUgY2hlY2tlciAnICsgJ2Z1bmN0aW9uIG11c3QgcmV0dXJuIGBudWxsYCBvciBhbiBgRXJyb3JgIGJ1dCByZXR1cm5lZCBhICVzLiAnICsgJ1lvdSBtYXkgaGF2ZSBmb3Jnb3R0ZW4gdG8gcGFzcyBhbiBhcmd1bWVudCB0byB0aGUgdHlwZSBjaGVja2VyICcgKyAnY3JlYXRvciAoYXJyYXlPZiwgaW5zdGFuY2VPZiwgb2JqZWN0T2YsIG9uZU9mLCBvbmVPZlR5cGUsIGFuZCAnICsgJ3NoYXBlIGFsbCByZXF1aXJlIGFuIGFyZ3VtZW50KS4nLCBjb21wb25lbnROYW1lIHx8ICdSZWFjdCBjbGFzcycsIGxvY2F0aW9uLCB0eXBlU3BlY05hbWUsIHR5cGVvZiBlcnJvciQxKTtcclxuXHJcbiAgICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChudWxsKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChlcnJvciQxIGluc3RhbmNlb2YgRXJyb3IgJiYgIShlcnJvciQxLm1lc3NhZ2UgaW4gbG9nZ2VkVHlwZUZhaWx1cmVzKSkge1xyXG4gICAgICAgICAgLy8gT25seSBtb25pdG9yIHRoaXMgZmFpbHVyZSBvbmNlIGJlY2F1c2UgdGhlcmUgdGVuZHMgdG8gYmUgYSBsb3Qgb2YgdGhlXHJcbiAgICAgICAgICAvLyBzYW1lIGVycm9yLlxyXG4gICAgICAgICAgbG9nZ2VkVHlwZUZhaWx1cmVzW2Vycm9yJDEubWVzc2FnZV0gPSB0cnVlO1xyXG4gICAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQoZWxlbWVudCk7XHJcblxyXG4gICAgICAgICAgZXJyb3IoJ0ZhaWxlZCAlcyB0eXBlOiAlcycsIGxvY2F0aW9uLCBlcnJvciQxLm1lc3NhZ2UpO1xyXG5cclxuICAgICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KG51bGwpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxudmFyIGlzQXJyYXlJbXBsID0gQXJyYXkuaXNBcnJheTsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlZGVjbGFyZVxyXG5cclxuZnVuY3Rpb24gaXNBcnJheShhKSB7XHJcbiAgcmV0dXJuIGlzQXJyYXlJbXBsKGEpO1xyXG59XHJcblxyXG4vKlxyXG4gKiBUaGUgYCcnICsgdmFsdWVgIHBhdHRlcm4gKHVzZWQgaW4gaW4gcGVyZi1zZW5zaXRpdmUgY29kZSkgdGhyb3dzIGZvciBTeW1ib2xcclxuICogYW5kIFRlbXBvcmFsLiogdHlwZXMuIFNlZSBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvcHVsbC8yMjA2NC5cclxuICpcclxuICogVGhlIGZ1bmN0aW9ucyBpbiB0aGlzIG1vZHVsZSB3aWxsIHRocm93IGFuIGVhc2llci10by11bmRlcnN0YW5kLFxyXG4gKiBlYXNpZXItdG8tZGVidWcgZXhjZXB0aW9uIHdpdGggYSBjbGVhciBlcnJvcnMgbWVzc2FnZSBtZXNzYWdlIGV4cGxhaW5pbmcgdGhlXHJcbiAqIHByb2JsZW0uIChJbnN0ZWFkIG9mIGEgY29uZnVzaW5nIGV4Y2VwdGlvbiB0aHJvd24gaW5zaWRlIHRoZSBpbXBsZW1lbnRhdGlvblxyXG4gKiBvZiB0aGUgYHZhbHVlYCBvYmplY3QpLlxyXG4gKi9cclxuLy8gJEZsb3dGaXhNZSBvbmx5IGNhbGxlZCBpbiBERVYsIHNvIHZvaWQgcmV0dXJuIGlzIG5vdCBwb3NzaWJsZS5cclxuZnVuY3Rpb24gdHlwZU5hbWUodmFsdWUpIHtcclxuICB7XHJcbiAgICAvLyB0b1N0cmluZ1RhZyBpcyBuZWVkZWQgZm9yIG5hbWVzcGFjZWQgdHlwZXMgbGlrZSBUZW1wb3JhbC5JbnN0YW50XHJcbiAgICB2YXIgaGFzVG9TdHJpbmdUYWcgPSB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbC50b1N0cmluZ1RhZztcclxuICAgIHZhciB0eXBlID0gaGFzVG9TdHJpbmdUYWcgJiYgdmFsdWVbU3ltYm9sLnRvU3RyaW5nVGFnXSB8fCB2YWx1ZS5jb25zdHJ1Y3Rvci5uYW1lIHx8ICdPYmplY3QnO1xyXG4gICAgcmV0dXJuIHR5cGU7XHJcbiAgfVxyXG59IC8vICRGbG93Rml4TWUgb25seSBjYWxsZWQgaW4gREVWLCBzbyB2b2lkIHJldHVybiBpcyBub3QgcG9zc2libGUuXHJcblxyXG5cclxuZnVuY3Rpb24gd2lsbENvZXJjaW9uVGhyb3codmFsdWUpIHtcclxuICB7XHJcbiAgICB0cnkge1xyXG4gICAgICB0ZXN0U3RyaW5nQ29lcmNpb24odmFsdWUpO1xyXG4gICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxuZnVuY3Rpb24gdGVzdFN0cmluZ0NvZXJjaW9uKHZhbHVlKSB7XHJcbiAgLy8gSWYgeW91IGVuZGVkIHVwIGhlcmUgYnkgZm9sbG93aW5nIGFuIGV4Y2VwdGlvbiBjYWxsIHN0YWNrLCBoZXJlJ3Mgd2hhdCdzXHJcbiAgLy8gaGFwcGVuZWQ6IHlvdSBzdXBwbGllZCBhbiBvYmplY3Qgb3Igc3ltYm9sIHZhbHVlIHRvIFJlYWN0IChhcyBhIHByb3AsIGtleSxcclxuICAvLyBET00gYXR0cmlidXRlLCBDU1MgcHJvcGVydHksIHN0cmluZyByZWYsIGV0Yy4pIGFuZCB3aGVuIFJlYWN0IHRyaWVkIHRvXHJcbiAgLy8gY29lcmNlIGl0IHRvIGEgc3RyaW5nIHVzaW5nIGAnJyArIHZhbHVlYCwgYW4gZXhjZXB0aW9uIHdhcyB0aHJvd24uXHJcbiAgLy9cclxuICAvLyBUaGUgbW9zdCBjb21tb24gdHlwZXMgdGhhdCB3aWxsIGNhdXNlIHRoaXMgZXhjZXB0aW9uIGFyZSBgU3ltYm9sYCBpbnN0YW5jZXNcclxuICAvLyBhbmQgVGVtcG9yYWwgb2JqZWN0cyBsaWtlIGBUZW1wb3JhbC5JbnN0YW50YC4gQnV0IGFueSBvYmplY3QgdGhhdCBoYXMgYVxyXG4gIC8vIGB2YWx1ZU9mYCBvciBgW1N5bWJvbC50b1ByaW1pdGl2ZV1gIG1ldGhvZCB0aGF0IHRocm93cyB3aWxsIGFsc28gY2F1c2UgdGhpc1xyXG4gIC8vIGV4Y2VwdGlvbi4gKExpYnJhcnkgYXV0aG9ycyBkbyB0aGlzIHRvIHByZXZlbnQgdXNlcnMgZnJvbSB1c2luZyBidWlsdC1pblxyXG4gIC8vIG51bWVyaWMgb3BlcmF0b3JzIGxpa2UgYCtgIG9yIGNvbXBhcmlzb24gb3BlcmF0b3JzIGxpa2UgYD49YCBiZWNhdXNlIGN1c3RvbVxyXG4gIC8vIG1ldGhvZHMgYXJlIG5lZWRlZCB0byBwZXJmb3JtIGFjY3VyYXRlIGFyaXRobWV0aWMgb3IgY29tcGFyaXNvbi4pXHJcbiAgLy9cclxuICAvLyBUbyBmaXggdGhlIHByb2JsZW0sIGNvZXJjZSB0aGlzIG9iamVjdCBvciBzeW1ib2wgdmFsdWUgdG8gYSBzdHJpbmcgYmVmb3JlXHJcbiAgLy8gcGFzc2luZyBpdCB0byBSZWFjdC4gVGhlIG1vc3QgcmVsaWFibGUgd2F5IGlzIHVzdWFsbHkgYFN0cmluZyh2YWx1ZSlgLlxyXG4gIC8vXHJcbiAgLy8gVG8gZmluZCB3aGljaCB2YWx1ZSBpcyB0aHJvd2luZywgY2hlY2sgdGhlIGJyb3dzZXIgb3IgZGVidWdnZXIgY29uc29sZS5cclxuICAvLyBCZWZvcmUgdGhpcyBleGNlcHRpb24gd2FzIHRocm93biwgdGhlcmUgc2hvdWxkIGJlIGBjb25zb2xlLmVycm9yYCBvdXRwdXRcclxuICAvLyB0aGF0IHNob3dzIHRoZSB0eXBlIChTeW1ib2wsIFRlbXBvcmFsLlBsYWluRGF0ZSwgZXRjLikgdGhhdCBjYXVzZWQgdGhlXHJcbiAgLy8gcHJvYmxlbSBhbmQgaG93IHRoYXQgdHlwZSB3YXMgdXNlZDoga2V5LCBhdHJyaWJ1dGUsIGlucHV0IHZhbHVlIHByb3AsIGV0Yy5cclxuICAvLyBJbiBtb3N0IGNhc2VzLCB0aGlzIGNvbnNvbGUgb3V0cHV0IGFsc28gc2hvd3MgdGhlIGNvbXBvbmVudCBhbmQgaXRzXHJcbiAgLy8gYW5jZXN0b3IgY29tcG9uZW50cyB3aGVyZSB0aGUgZXhjZXB0aW9uIGhhcHBlbmVkLlxyXG4gIC8vXHJcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWludGVybmFsL3NhZmUtc3RyaW5nLWNvZXJjaW9uXHJcbiAgcmV0dXJuICcnICsgdmFsdWU7XHJcbn1cclxuZnVuY3Rpb24gY2hlY2tLZXlTdHJpbmdDb2VyY2lvbih2YWx1ZSkge1xyXG4gIHtcclxuICAgIGlmICh3aWxsQ29lcmNpb25UaHJvdyh2YWx1ZSkpIHtcclxuICAgICAgZXJyb3IoJ1RoZSBwcm92aWRlZCBrZXkgaXMgYW4gdW5zdXBwb3J0ZWQgdHlwZSAlcy4nICsgJyBUaGlzIHZhbHVlIG11c3QgYmUgY29lcmNlZCB0byBhIHN0cmluZyBiZWZvcmUgYmVmb3JlIHVzaW5nIGl0IGhlcmUuJywgdHlwZU5hbWUodmFsdWUpKTtcclxuXHJcbiAgICAgIHJldHVybiB0ZXN0U3RyaW5nQ29lcmNpb24odmFsdWUpOyAvLyB0aHJvdyAodG8gaGVscCBjYWxsZXJzIGZpbmQgdHJvdWJsZXNob290aW5nIGNvbW1lbnRzKVxyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxudmFyIFJlYWN0Q3VycmVudE93bmVyID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3RDdXJyZW50T3duZXI7XHJcbnZhciBSRVNFUlZFRF9QUk9QUyA9IHtcclxuICBrZXk6IHRydWUsXHJcbiAgcmVmOiB0cnVlLFxyXG4gIF9fc2VsZjogdHJ1ZSxcclxuICBfX3NvdXJjZTogdHJ1ZVxyXG59O1xyXG52YXIgc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd247XHJcbnZhciBzcGVjaWFsUHJvcFJlZldhcm5pbmdTaG93bjtcclxudmFyIGRpZFdhcm5BYm91dFN0cmluZ1JlZnM7XHJcblxyXG57XHJcbiAgZGlkV2FybkFib3V0U3RyaW5nUmVmcyA9IHt9O1xyXG59XHJcblxyXG5mdW5jdGlvbiBoYXNWYWxpZFJlZihjb25maWcpIHtcclxuICB7XHJcbiAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChjb25maWcsICdyZWYnKSkge1xyXG4gICAgICB2YXIgZ2V0dGVyID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihjb25maWcsICdyZWYnKS5nZXQ7XHJcblxyXG4gICAgICBpZiAoZ2V0dGVyICYmIGdldHRlci5pc1JlYWN0V2FybmluZykge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIGNvbmZpZy5yZWYgIT09IHVuZGVmaW5lZDtcclxufVxyXG5cclxuZnVuY3Rpb24gaGFzVmFsaWRLZXkoY29uZmlnKSB7XHJcbiAge1xyXG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCAna2V5JykpIHtcclxuICAgICAgdmFyIGdldHRlciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoY29uZmlnLCAna2V5JykuZ2V0O1xyXG5cclxuICAgICAgaWYgKGdldHRlciAmJiBnZXR0ZXIuaXNSZWFjdFdhcm5pbmcpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIHJldHVybiBjb25maWcua2V5ICE9PSB1bmRlZmluZWQ7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHdhcm5JZlN0cmluZ1JlZkNhbm5vdEJlQXV0b0NvbnZlcnRlZChjb25maWcsIHNlbGYpIHtcclxuICB7XHJcbiAgICBpZiAodHlwZW9mIGNvbmZpZy5yZWYgPT09ICdzdHJpbmcnICYmIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQgJiYgc2VsZiAmJiBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50LnN0YXRlTm9kZSAhPT0gc2VsZikge1xyXG4gICAgICB2YXIgY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50LnR5cGUpO1xyXG5cclxuICAgICAgaWYgKCFkaWRXYXJuQWJvdXRTdHJpbmdSZWZzW2NvbXBvbmVudE5hbWVdKSB7XHJcbiAgICAgICAgZXJyb3IoJ0NvbXBvbmVudCBcIiVzXCIgY29udGFpbnMgdGhlIHN0cmluZyByZWYgXCIlc1wiLiAnICsgJ1N1cHBvcnQgZm9yIHN0cmluZyByZWZzIHdpbGwgYmUgcmVtb3ZlZCBpbiBhIGZ1dHVyZSBtYWpvciByZWxlYXNlLiAnICsgJ1RoaXMgY2FzZSBjYW5ub3QgYmUgYXV0b21hdGljYWxseSBjb252ZXJ0ZWQgdG8gYW4gYXJyb3cgZnVuY3Rpb24uICcgKyAnV2UgYXNrIHlvdSB0byBtYW51YWxseSBmaXggdGhpcyBjYXNlIGJ5IHVzaW5nIHVzZVJlZigpIG9yIGNyZWF0ZVJlZigpIGluc3RlYWQuICcgKyAnTGVhcm4gbW9yZSBhYm91dCB1c2luZyByZWZzIHNhZmVseSBoZXJlOiAnICsgJ2h0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9zdHJpY3QtbW9kZS1zdHJpbmctcmVmJywgZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQudHlwZSksIGNvbmZpZy5yZWYpO1xyXG5cclxuICAgICAgICBkaWRXYXJuQWJvdXRTdHJpbmdSZWZzW2NvbXBvbmVudE5hbWVdID0gdHJ1ZTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxuZnVuY3Rpb24gZGVmaW5lS2V5UHJvcFdhcm5pbmdHZXR0ZXIocHJvcHMsIGRpc3BsYXlOYW1lKSB7XHJcbiAge1xyXG4gICAgdmFyIHdhcm5BYm91dEFjY2Vzc2luZ0tleSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgaWYgKCFzcGVjaWFsUHJvcEtleVdhcm5pbmdTaG93bikge1xyXG4gICAgICAgIHNwZWNpYWxQcm9wS2V5V2FybmluZ1Nob3duID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgZXJyb3IoJyVzOiBga2V5YCBpcyBub3QgYSBwcm9wLiBUcnlpbmcgdG8gYWNjZXNzIGl0IHdpbGwgcmVzdWx0ICcgKyAnaW4gYHVuZGVmaW5lZGAgYmVpbmcgcmV0dXJuZWQuIElmIHlvdSBuZWVkIHRvIGFjY2VzcyB0aGUgc2FtZSAnICsgJ3ZhbHVlIHdpdGhpbiB0aGUgY2hpbGQgY29tcG9uZW50LCB5b3Ugc2hvdWxkIHBhc3MgaXQgYXMgYSBkaWZmZXJlbnQgJyArICdwcm9wLiAoaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3NwZWNpYWwtcHJvcHMpJywgZGlzcGxheU5hbWUpO1xyXG4gICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIHdhcm5BYm91dEFjY2Vzc2luZ0tleS5pc1JlYWN0V2FybmluZyA9IHRydWU7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvcHMsICdrZXknLCB7XHJcbiAgICAgIGdldDogd2FybkFib3V0QWNjZXNzaW5nS2V5LFxyXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gIH1cclxufVxyXG5cclxuZnVuY3Rpb24gZGVmaW5lUmVmUHJvcFdhcm5pbmdHZXR0ZXIocHJvcHMsIGRpc3BsYXlOYW1lKSB7XHJcbiAge1xyXG4gICAgdmFyIHdhcm5BYm91dEFjY2Vzc2luZ1JlZiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgaWYgKCFzcGVjaWFsUHJvcFJlZldhcm5pbmdTaG93bikge1xyXG4gICAgICAgIHNwZWNpYWxQcm9wUmVmV2FybmluZ1Nob3duID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgZXJyb3IoJyVzOiBgcmVmYCBpcyBub3QgYSBwcm9wLiBUcnlpbmcgdG8gYWNjZXNzIGl0IHdpbGwgcmVzdWx0ICcgKyAnaW4gYHVuZGVmaW5lZGAgYmVpbmcgcmV0dXJuZWQuIElmIHlvdSBuZWVkIHRvIGFjY2VzcyB0aGUgc2FtZSAnICsgJ3ZhbHVlIHdpdGhpbiB0aGUgY2hpbGQgY29tcG9uZW50LCB5b3Ugc2hvdWxkIHBhc3MgaXQgYXMgYSBkaWZmZXJlbnQgJyArICdwcm9wLiAoaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3NwZWNpYWwtcHJvcHMpJywgZGlzcGxheU5hbWUpO1xyXG4gICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIHdhcm5BYm91dEFjY2Vzc2luZ1JlZi5pc1JlYWN0V2FybmluZyA9IHRydWU7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvcHMsICdyZWYnLCB7XHJcbiAgICAgIGdldDogd2FybkFib3V0QWNjZXNzaW5nUmVmLFxyXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gIH1cclxufVxyXG4vKipcclxuICogRmFjdG9yeSBtZXRob2QgdG8gY3JlYXRlIGEgbmV3IFJlYWN0IGVsZW1lbnQuIFRoaXMgbm8gbG9uZ2VyIGFkaGVyZXMgdG9cclxuICogdGhlIGNsYXNzIHBhdHRlcm4sIHNvIGRvIG5vdCB1c2UgbmV3IHRvIGNhbGwgaXQuIEFsc28sIGluc3RhbmNlb2YgY2hlY2tcclxuICogd2lsbCBub3Qgd29yay4gSW5zdGVhZCB0ZXN0ICQkdHlwZW9mIGZpZWxkIGFnYWluc3QgU3ltYm9sLmZvcigncmVhY3QuZWxlbWVudCcpIHRvIGNoZWNrXHJcbiAqIGlmIHNvbWV0aGluZyBpcyBhIFJlYWN0IEVsZW1lbnQuXHJcbiAqXHJcbiAqIEBwYXJhbSB7Kn0gdHlwZVxyXG4gKiBAcGFyYW0geyp9IHByb3BzXHJcbiAqIEBwYXJhbSB7Kn0ga2V5XHJcbiAqIEBwYXJhbSB7c3RyaW5nfG9iamVjdH0gcmVmXHJcbiAqIEBwYXJhbSB7Kn0gb3duZXJcclxuICogQHBhcmFtIHsqfSBzZWxmIEEgKnRlbXBvcmFyeSogaGVscGVyIHRvIGRldGVjdCBwbGFjZXMgd2hlcmUgYHRoaXNgIGlzXHJcbiAqIGRpZmZlcmVudCBmcm9tIHRoZSBgb3duZXJgIHdoZW4gUmVhY3QuY3JlYXRlRWxlbWVudCBpcyBjYWxsZWQsIHNvIHRoYXQgd2VcclxuICogY2FuIHdhcm4uIFdlIHdhbnQgdG8gZ2V0IHJpZCBvZiBvd25lciBhbmQgcmVwbGFjZSBzdHJpbmcgYHJlZmBzIHdpdGggYXJyb3dcclxuICogZnVuY3Rpb25zLCBhbmQgYXMgbG9uZyBhcyBgdGhpc2AgYW5kIG93bmVyIGFyZSB0aGUgc2FtZSwgdGhlcmUgd2lsbCBiZSBub1xyXG4gKiBjaGFuZ2UgaW4gYmVoYXZpb3IuXHJcbiAqIEBwYXJhbSB7Kn0gc291cmNlIEFuIGFubm90YXRpb24gb2JqZWN0IChhZGRlZCBieSBhIHRyYW5zcGlsZXIgb3Igb3RoZXJ3aXNlKVxyXG4gKiBpbmRpY2F0aW5nIGZpbGVuYW1lLCBsaW5lIG51bWJlciwgYW5kL29yIG90aGVyIGluZm9ybWF0aW9uLlxyXG4gKiBAaW50ZXJuYWxcclxuICovXHJcblxyXG5cclxudmFyIFJlYWN0RWxlbWVudCA9IGZ1bmN0aW9uICh0eXBlLCBrZXksIHJlZiwgc2VsZiwgc291cmNlLCBvd25lciwgcHJvcHMpIHtcclxuICB2YXIgZWxlbWVudCA9IHtcclxuICAgIC8vIFRoaXMgdGFnIGFsbG93cyB1cyB0byB1bmlxdWVseSBpZGVudGlmeSB0aGlzIGFzIGEgUmVhY3QgRWxlbWVudFxyXG4gICAgJCR0eXBlb2Y6IFJFQUNUX0VMRU1FTlRfVFlQRSxcclxuICAgIC8vIEJ1aWx0LWluIHByb3BlcnRpZXMgdGhhdCBiZWxvbmcgb24gdGhlIGVsZW1lbnRcclxuICAgIHR5cGU6IHR5cGUsXHJcbiAgICBrZXk6IGtleSxcclxuICAgIHJlZjogcmVmLFxyXG4gICAgcHJvcHM6IHByb3BzLFxyXG4gICAgLy8gUmVjb3JkIHRoZSBjb21wb25lbnQgcmVzcG9uc2libGUgZm9yIGNyZWF0aW5nIHRoaXMgZWxlbWVudC5cclxuICAgIF9vd25lcjogb3duZXJcclxuICB9O1xyXG5cclxuICB7XHJcbiAgICAvLyBUaGUgdmFsaWRhdGlvbiBmbGFnIGlzIGN1cnJlbnRseSBtdXRhdGl2ZS4gV2UgcHV0IGl0IG9uXHJcbiAgICAvLyBhbiBleHRlcm5hbCBiYWNraW5nIHN0b3JlIHNvIHRoYXQgd2UgY2FuIGZyZWV6ZSB0aGUgd2hvbGUgb2JqZWN0LlxyXG4gICAgLy8gVGhpcyBjYW4gYmUgcmVwbGFjZWQgd2l0aCBhIFdlYWtNYXAgb25jZSB0aGV5IGFyZSBpbXBsZW1lbnRlZCBpblxyXG4gICAgLy8gY29tbW9ubHkgdXNlZCBkZXZlbG9wbWVudCBlbnZpcm9ubWVudHMuXHJcbiAgICBlbGVtZW50Ll9zdG9yZSA9IHt9OyAvLyBUbyBtYWtlIGNvbXBhcmluZyBSZWFjdEVsZW1lbnRzIGVhc2llciBmb3IgdGVzdGluZyBwdXJwb3Nlcywgd2UgbWFrZVxyXG4gICAgLy8gdGhlIHZhbGlkYXRpb24gZmxhZyBub24tZW51bWVyYWJsZSAod2hlcmUgcG9zc2libGUsIHdoaWNoIHNob3VsZFxyXG4gICAgLy8gaW5jbHVkZSBldmVyeSBlbnZpcm9ubWVudCB3ZSBydW4gdGVzdHMgaW4pLCBzbyB0aGUgdGVzdCBmcmFtZXdvcmtcclxuICAgIC8vIGlnbm9yZXMgaXQuXHJcblxyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGVsZW1lbnQuX3N0b3JlLCAndmFsaWRhdGVkJywge1xyXG4gICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxyXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcclxuICAgICAgd3JpdGFibGU6IHRydWUsXHJcbiAgICAgIHZhbHVlOiBmYWxzZVxyXG4gICAgfSk7IC8vIHNlbGYgYW5kIHNvdXJjZSBhcmUgREVWIG9ubHkgcHJvcGVydGllcy5cclxuXHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxlbWVudCwgJ19zZWxmJywge1xyXG4gICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxyXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcclxuICAgICAgd3JpdGFibGU6IGZhbHNlLFxyXG4gICAgICB2YWx1ZTogc2VsZlxyXG4gICAgfSk7IC8vIFR3byBlbGVtZW50cyBjcmVhdGVkIGluIHR3byBkaWZmZXJlbnQgcGxhY2VzIHNob3VsZCBiZSBjb25zaWRlcmVkXHJcbiAgICAvLyBlcXVhbCBmb3IgdGVzdGluZyBwdXJwb3NlcyBhbmQgdGhlcmVmb3JlIHdlIGhpZGUgaXQgZnJvbSBlbnVtZXJhdGlvbi5cclxuXHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxlbWVudCwgJ19zb3VyY2UnLCB7XHJcbiAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXHJcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxyXG4gICAgICB3cml0YWJsZTogZmFsc2UsXHJcbiAgICAgIHZhbHVlOiBzb3VyY2VcclxuICAgIH0pO1xyXG5cclxuICAgIGlmIChPYmplY3QuZnJlZXplKSB7XHJcbiAgICAgIE9iamVjdC5mcmVlemUoZWxlbWVudC5wcm9wcyk7XHJcbiAgICAgIE9iamVjdC5mcmVlemUoZWxlbWVudCk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICByZXR1cm4gZWxlbWVudDtcclxufTtcclxuLyoqXHJcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9yZWFjdGpzL3JmY3MvcHVsbC8xMDdcclxuICogQHBhcmFtIHsqfSB0eXBlXHJcbiAqIEBwYXJhbSB7b2JqZWN0fSBwcm9wc1xyXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5XHJcbiAqL1xyXG5cclxuZnVuY3Rpb24ganN4REVWKHR5cGUsIGNvbmZpZywgbWF5YmVLZXksIHNvdXJjZSwgc2VsZikge1xyXG4gIHtcclxuICAgIHZhciBwcm9wTmFtZTsgLy8gUmVzZXJ2ZWQgbmFtZXMgYXJlIGV4dHJhY3RlZFxyXG5cclxuICAgIHZhciBwcm9wcyA9IHt9O1xyXG4gICAgdmFyIGtleSA9IG51bGw7XHJcbiAgICB2YXIgcmVmID0gbnVsbDsgLy8gQ3VycmVudGx5LCBrZXkgY2FuIGJlIHNwcmVhZCBpbiBhcyBhIHByb3AuIFRoaXMgY2F1c2VzIGEgcG90ZW50aWFsXHJcbiAgICAvLyBpc3N1ZSBpZiBrZXkgaXMgYWxzbyBleHBsaWNpdGx5IGRlY2xhcmVkIChpZS4gPGRpdiB7Li4ucHJvcHN9IGtleT1cIkhpXCIgLz5cclxuICAgIC8vIG9yIDxkaXYga2V5PVwiSGlcIiB7Li4ucHJvcHN9IC8+ICkuIFdlIHdhbnQgdG8gZGVwcmVjYXRlIGtleSBzcHJlYWQsXHJcbiAgICAvLyBidXQgYXMgYW4gaW50ZXJtZWRpYXJ5IHN0ZXAsIHdlIHdpbGwgdXNlIGpzeERFViBmb3IgZXZlcnl0aGluZyBleGNlcHRcclxuICAgIC8vIDxkaXYgey4uLnByb3BzfSBrZXk9XCJIaVwiIC8+LCBiZWNhdXNlIHdlIGFyZW4ndCBjdXJyZW50bHkgYWJsZSB0byB0ZWxsIGlmXHJcbiAgICAvLyBrZXkgaXMgZXhwbGljaXRseSBkZWNsYXJlZCB0byBiZSB1bmRlZmluZWQgb3Igbm90LlxyXG5cclxuICAgIGlmIChtYXliZUtleSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgIHtcclxuICAgICAgICBjaGVja0tleVN0cmluZ0NvZXJjaW9uKG1heWJlS2V5KTtcclxuICAgICAgfVxyXG5cclxuICAgICAga2V5ID0gJycgKyBtYXliZUtleTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoaGFzVmFsaWRLZXkoY29uZmlnKSkge1xyXG4gICAgICB7XHJcbiAgICAgICAgY2hlY2tLZXlTdHJpbmdDb2VyY2lvbihjb25maWcua2V5KTtcclxuICAgICAgfVxyXG5cclxuICAgICAga2V5ID0gJycgKyBjb25maWcua2V5O1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChoYXNWYWxpZFJlZihjb25maWcpKSB7XHJcbiAgICAgIHJlZiA9IGNvbmZpZy5yZWY7XHJcbiAgICAgIHdhcm5JZlN0cmluZ1JlZkNhbm5vdEJlQXV0b0NvbnZlcnRlZChjb25maWcsIHNlbGYpO1xyXG4gICAgfSAvLyBSZW1haW5pbmcgcHJvcGVydGllcyBhcmUgYWRkZWQgdG8gYSBuZXcgcHJvcHMgb2JqZWN0XHJcblxyXG5cclxuICAgIGZvciAocHJvcE5hbWUgaW4gY29uZmlnKSB7XHJcbiAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZywgcHJvcE5hbWUpICYmICFSRVNFUlZFRF9QUk9QUy5oYXNPd25Qcm9wZXJ0eShwcm9wTmFtZSkpIHtcclxuICAgICAgICBwcm9wc1twcm9wTmFtZV0gPSBjb25maWdbcHJvcE5hbWVdO1xyXG4gICAgICB9XHJcbiAgICB9IC8vIFJlc29sdmUgZGVmYXVsdCBwcm9wc1xyXG5cclxuXHJcbiAgICBpZiAodHlwZSAmJiB0eXBlLmRlZmF1bHRQcm9wcykge1xyXG4gICAgICB2YXIgZGVmYXVsdFByb3BzID0gdHlwZS5kZWZhdWx0UHJvcHM7XHJcblxyXG4gICAgICBmb3IgKHByb3BOYW1lIGluIGRlZmF1bHRQcm9wcykge1xyXG4gICAgICAgIGlmIChwcm9wc1twcm9wTmFtZV0gPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgcHJvcHNbcHJvcE5hbWVdID0gZGVmYXVsdFByb3BzW3Byb3BOYW1lXTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBpZiAoa2V5IHx8IHJlZikge1xyXG4gICAgICB2YXIgZGlzcGxheU5hbWUgPSB0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJyA/IHR5cGUuZGlzcGxheU5hbWUgfHwgdHlwZS5uYW1lIHx8ICdVbmtub3duJyA6IHR5cGU7XHJcblxyXG4gICAgICBpZiAoa2V5KSB7XHJcbiAgICAgICAgZGVmaW5lS2V5UHJvcFdhcm5pbmdHZXR0ZXIocHJvcHMsIGRpc3BsYXlOYW1lKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKHJlZikge1xyXG4gICAgICAgIGRlZmluZVJlZlByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gUmVhY3RFbGVtZW50KHR5cGUsIGtleSwgcmVmLCBzZWxmLCBzb3VyY2UsIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQsIHByb3BzKTtcclxuICB9XHJcbn1cclxuXHJcbnZhciBSZWFjdEN1cnJlbnRPd25lciQxID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3RDdXJyZW50T3duZXI7XHJcbnZhciBSZWFjdERlYnVnQ3VycmVudEZyYW1lJDEgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdERlYnVnQ3VycmVudEZyYW1lO1xyXG5cclxuZnVuY3Rpb24gc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShlbGVtZW50KSB7XHJcbiAge1xyXG4gICAgaWYgKGVsZW1lbnQpIHtcclxuICAgICAgdmFyIG93bmVyID0gZWxlbWVudC5fb3duZXI7XHJcbiAgICAgIHZhciBzdGFjayA9IGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVihlbGVtZW50LnR5cGUsIGVsZW1lbnQuX3NvdXJjZSwgb3duZXIgPyBvd25lci50eXBlIDogbnVsbCk7XHJcbiAgICAgIFJlYWN0RGVidWdDdXJyZW50RnJhbWUkMS5zZXRFeHRyYVN0YWNrRnJhbWUoc3RhY2spO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSQxLnNldEV4dHJhU3RhY2tGcmFtZShudWxsKTtcclxuICAgIH1cclxuICB9XHJcbn1cclxuXHJcbnZhciBwcm9wVHlwZXNNaXNzcGVsbFdhcm5pbmdTaG93bjtcclxuXHJcbntcclxuICBwcm9wVHlwZXNNaXNzcGVsbFdhcm5pbmdTaG93biA9IGZhbHNlO1xyXG59XHJcbi8qKlxyXG4gKiBWZXJpZmllcyB0aGUgb2JqZWN0IGlzIGEgUmVhY3RFbGVtZW50LlxyXG4gKiBTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9kb2NzL3JlYWN0LWFwaS5odG1sI2lzdmFsaWRlbGVtZW50XHJcbiAqIEBwYXJhbSB7P29iamVjdH0gb2JqZWN0XHJcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgYG9iamVjdGAgaXMgYSBSZWFjdEVsZW1lbnQuXHJcbiAqIEBmaW5hbFxyXG4gKi9cclxuXHJcblxyXG5mdW5jdGlvbiBpc1ZhbGlkRWxlbWVudChvYmplY3QpIHtcclxuICB7XHJcbiAgICByZXR1cm4gdHlwZW9mIG9iamVjdCA9PT0gJ29iamVjdCcgJiYgb2JqZWN0ICE9PSBudWxsICYmIG9iamVjdC4kJHR5cGVvZiA9PT0gUkVBQ1RfRUxFTUVOVF9UWVBFO1xyXG4gIH1cclxufVxyXG5cclxuZnVuY3Rpb24gZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKCkge1xyXG4gIHtcclxuICAgIGlmIChSZWFjdEN1cnJlbnRPd25lciQxLmN1cnJlbnQpIHtcclxuICAgICAgdmFyIG5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoUmVhY3RDdXJyZW50T3duZXIkMS5jdXJyZW50LnR5cGUpO1xyXG5cclxuICAgICAgaWYgKG5hbWUpIHtcclxuICAgICAgICByZXR1cm4gJ1xcblxcbkNoZWNrIHRoZSByZW5kZXIgbWV0aG9kIG9mIGAnICsgbmFtZSArICdgLic7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gJyc7XHJcbiAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBnZXRTb3VyY2VJbmZvRXJyb3JBZGRlbmR1bShzb3VyY2UpIHtcclxuICB7XHJcbiAgICBpZiAoc291cmNlICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgdmFyIGZpbGVOYW1lID0gc291cmNlLmZpbGVOYW1lLnJlcGxhY2UoL14uKltcXFxcXFwvXS8sICcnKTtcclxuICAgICAgdmFyIGxpbmVOdW1iZXIgPSBzb3VyY2UubGluZU51bWJlcjtcclxuICAgICAgcmV0dXJuICdcXG5cXG5DaGVjayB5b3VyIGNvZGUgYXQgJyArIGZpbGVOYW1lICsgJzonICsgbGluZU51bWJlciArICcuJztcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gJyc7XHJcbiAgfVxyXG59XHJcbi8qKlxyXG4gKiBXYXJuIGlmIHRoZXJlJ3Mgbm8ga2V5IGV4cGxpY2l0bHkgc2V0IG9uIGR5bmFtaWMgYXJyYXlzIG9mIGNoaWxkcmVuIG9yXHJcbiAqIG9iamVjdCBrZXlzIGFyZSBub3QgdmFsaWQuIFRoaXMgYWxsb3dzIHVzIHRvIGtlZXAgdHJhY2sgb2YgY2hpbGRyZW4gYmV0d2VlblxyXG4gKiB1cGRhdGVzLlxyXG4gKi9cclxuXHJcblxyXG52YXIgb3duZXJIYXNLZXlVc2VXYXJuaW5nID0ge307XHJcblxyXG5mdW5jdGlvbiBnZXRDdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvKHBhcmVudFR5cGUpIHtcclxuICB7XHJcbiAgICB2YXIgaW5mbyA9IGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bSgpO1xyXG5cclxuICAgIGlmICghaW5mbykge1xyXG4gICAgICB2YXIgcGFyZW50TmFtZSA9IHR5cGVvZiBwYXJlbnRUeXBlID09PSAnc3RyaW5nJyA/IHBhcmVudFR5cGUgOiBwYXJlbnRUeXBlLmRpc3BsYXlOYW1lIHx8IHBhcmVudFR5cGUubmFtZTtcclxuXHJcbiAgICAgIGlmIChwYXJlbnROYW1lKSB7XHJcbiAgICAgICAgaW5mbyA9IFwiXFxuXFxuQ2hlY2sgdGhlIHRvcC1sZXZlbCByZW5kZXIgY2FsbCB1c2luZyA8XCIgKyBwYXJlbnROYW1lICsgXCI+LlwiO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGluZm87XHJcbiAgfVxyXG59XHJcbi8qKlxyXG4gKiBXYXJuIGlmIHRoZSBlbGVtZW50IGRvZXNuJ3QgaGF2ZSBhbiBleHBsaWNpdCBrZXkgYXNzaWduZWQgdG8gaXQuXHJcbiAqIFRoaXMgZWxlbWVudCBpcyBpbiBhbiBhcnJheS4gVGhlIGFycmF5IGNvdWxkIGdyb3cgYW5kIHNocmluayBvciBiZVxyXG4gKiByZW9yZGVyZWQuIEFsbCBjaGlsZHJlbiB0aGF0IGhhdmVuJ3QgYWxyZWFkeSBiZWVuIHZhbGlkYXRlZCBhcmUgcmVxdWlyZWQgdG9cclxuICogaGF2ZSBhIFwia2V5XCIgcHJvcGVydHkgYXNzaWduZWQgdG8gaXQuIEVycm9yIHN0YXR1c2VzIGFyZSBjYWNoZWQgc28gYSB3YXJuaW5nXHJcbiAqIHdpbGwgb25seSBiZSBzaG93biBvbmNlLlxyXG4gKlxyXG4gKiBAaW50ZXJuYWxcclxuICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IGVsZW1lbnQgRWxlbWVudCB0aGF0IHJlcXVpcmVzIGEga2V5LlxyXG4gKiBAcGFyYW0geyp9IHBhcmVudFR5cGUgZWxlbWVudCdzIHBhcmVudCdzIHR5cGUuXHJcbiAqL1xyXG5cclxuXHJcbmZ1bmN0aW9uIHZhbGlkYXRlRXhwbGljaXRLZXkoZWxlbWVudCwgcGFyZW50VHlwZSkge1xyXG4gIHtcclxuICAgIGlmICghZWxlbWVudC5fc3RvcmUgfHwgZWxlbWVudC5fc3RvcmUudmFsaWRhdGVkIHx8IGVsZW1lbnQua2V5ICE9IG51bGwpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIGVsZW1lbnQuX3N0b3JlLnZhbGlkYXRlZCA9IHRydWU7XHJcbiAgICB2YXIgY3VycmVudENvbXBvbmVudEVycm9ySW5mbyA9IGdldEN1cnJlbnRDb21wb25lbnRFcnJvckluZm8ocGFyZW50VHlwZSk7XHJcblxyXG4gICAgaWYgKG93bmVySGFzS2V5VXNlV2FybmluZ1tjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvXSkge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgb3duZXJIYXNLZXlVc2VXYXJuaW5nW2N1cnJlbnRDb21wb25lbnRFcnJvckluZm9dID0gdHJ1ZTsgLy8gVXN1YWxseSB0aGUgY3VycmVudCBvd25lciBpcyB0aGUgb2ZmZW5kZXIsIGJ1dCBpZiBpdCBhY2NlcHRzIGNoaWxkcmVuIGFzIGFcclxuICAgIC8vIHByb3BlcnR5LCBpdCBtYXkgYmUgdGhlIGNyZWF0b3Igb2YgdGhlIGNoaWxkIHRoYXQncyByZXNwb25zaWJsZSBmb3JcclxuICAgIC8vIGFzc2lnbmluZyBpdCBhIGtleS5cclxuXHJcbiAgICB2YXIgY2hpbGRPd25lciA9ICcnO1xyXG5cclxuICAgIGlmIChlbGVtZW50ICYmIGVsZW1lbnQuX293bmVyICYmIGVsZW1lbnQuX293bmVyICE9PSBSZWFjdEN1cnJlbnRPd25lciQxLmN1cnJlbnQpIHtcclxuICAgICAgLy8gR2l2ZSB0aGUgY29tcG9uZW50IHRoYXQgb3JpZ2luYWxseSBjcmVhdGVkIHRoaXMgY2hpbGQuXHJcbiAgICAgIGNoaWxkT3duZXIgPSBcIiBJdCB3YXMgcGFzc2VkIGEgY2hpbGQgZnJvbSBcIiArIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShlbGVtZW50Ll9vd25lci50eXBlKSArIFwiLlwiO1xyXG4gICAgfVxyXG5cclxuICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50JDEoZWxlbWVudCk7XHJcblxyXG4gICAgZXJyb3IoJ0VhY2ggY2hpbGQgaW4gYSBsaXN0IHNob3VsZCBoYXZlIGEgdW5pcXVlIFwia2V5XCIgcHJvcC4nICsgJyVzJXMgU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay93YXJuaW5nLWtleXMgZm9yIG1vcmUgaW5mb3JtYXRpb24uJywgY3VycmVudENvbXBvbmVudEVycm9ySW5mbywgY2hpbGRPd25lcik7XHJcblxyXG4gICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShudWxsKTtcclxuICB9XHJcbn1cclxuLyoqXHJcbiAqIEVuc3VyZSB0aGF0IGV2ZXJ5IGVsZW1lbnQgZWl0aGVyIGlzIHBhc3NlZCBpbiBhIHN0YXRpYyBsb2NhdGlvbiwgaW4gYW5cclxuICogYXJyYXkgd2l0aCBhbiBleHBsaWNpdCBrZXlzIHByb3BlcnR5IGRlZmluZWQsIG9yIGluIGFuIG9iamVjdCBsaXRlcmFsXHJcbiAqIHdpdGggdmFsaWQga2V5IHByb3BlcnR5LlxyXG4gKlxyXG4gKiBAaW50ZXJuYWxcclxuICogQHBhcmFtIHtSZWFjdE5vZGV9IG5vZGUgU3RhdGljYWxseSBwYXNzZWQgY2hpbGQgb2YgYW55IHR5cGUuXHJcbiAqIEBwYXJhbSB7Kn0gcGFyZW50VHlwZSBub2RlJ3MgcGFyZW50J3MgdHlwZS5cclxuICovXHJcblxyXG5cclxuZnVuY3Rpb24gdmFsaWRhdGVDaGlsZEtleXMobm9kZSwgcGFyZW50VHlwZSkge1xyXG4gIHtcclxuICAgIGlmICh0eXBlb2Ygbm9kZSAhPT0gJ29iamVjdCcpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChpc0FycmF5KG5vZGUpKSB7XHJcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZS5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIHZhciBjaGlsZCA9IG5vZGVbaV07XHJcblxyXG4gICAgICAgIGlmIChpc1ZhbGlkRWxlbWVudChjaGlsZCkpIHtcclxuICAgICAgICAgIHZhbGlkYXRlRXhwbGljaXRLZXkoY2hpbGQsIHBhcmVudFR5cGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfSBlbHNlIGlmIChpc1ZhbGlkRWxlbWVudChub2RlKSkge1xyXG4gICAgICAvLyBUaGlzIGVsZW1lbnQgd2FzIHBhc3NlZCBpbiBhIHZhbGlkIGxvY2F0aW9uLlxyXG4gICAgICBpZiAobm9kZS5fc3RvcmUpIHtcclxuICAgICAgICBub2RlLl9zdG9yZS52YWxpZGF0ZWQgPSB0cnVlO1xyXG4gICAgICB9XHJcbiAgICB9IGVsc2UgaWYgKG5vZGUpIHtcclxuICAgICAgdmFyIGl0ZXJhdG9yRm4gPSBnZXRJdGVyYXRvckZuKG5vZGUpO1xyXG5cclxuICAgICAgaWYgKHR5cGVvZiBpdGVyYXRvckZuID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgLy8gRW50cnkgaXRlcmF0b3JzIHVzZWQgdG8gcHJvdmlkZSBpbXBsaWNpdCBrZXlzLFxyXG4gICAgICAgIC8vIGJ1dCBub3cgd2UgcHJpbnQgYSBzZXBhcmF0ZSB3YXJuaW5nIGZvciB0aGVtIGxhdGVyLlxyXG4gICAgICAgIGlmIChpdGVyYXRvckZuICE9PSBub2RlLmVudHJpZXMpIHtcclxuICAgICAgICAgIHZhciBpdGVyYXRvciA9IGl0ZXJhdG9yRm4uY2FsbChub2RlKTtcclxuICAgICAgICAgIHZhciBzdGVwO1xyXG5cclxuICAgICAgICAgIHdoaWxlICghKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmUpIHtcclxuICAgICAgICAgICAgaWYgKGlzVmFsaWRFbGVtZW50KHN0ZXAudmFsdWUpKSB7XHJcbiAgICAgICAgICAgICAgdmFsaWRhdGVFeHBsaWNpdEtleShzdGVwLnZhbHVlLCBwYXJlbnRUeXBlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxufVxyXG4vKipcclxuICogR2l2ZW4gYW4gZWxlbWVudCwgdmFsaWRhdGUgdGhhdCBpdHMgcHJvcHMgZm9sbG93IHRoZSBwcm9wVHlwZXMgZGVmaW5pdGlvbixcclxuICogcHJvdmlkZWQgYnkgdGhlIHR5cGUuXHJcbiAqXHJcbiAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBlbGVtZW50XHJcbiAqL1xyXG5cclxuXHJcbmZ1bmN0aW9uIHZhbGlkYXRlUHJvcFR5cGVzKGVsZW1lbnQpIHtcclxuICB7XHJcbiAgICB2YXIgdHlwZSA9IGVsZW1lbnQudHlwZTtcclxuXHJcbiAgICBpZiAodHlwZSA9PT0gbnVsbCB8fCB0eXBlID09PSB1bmRlZmluZWQgfHwgdHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgcHJvcFR5cGVzO1xyXG5cclxuICAgIGlmICh0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICBwcm9wVHlwZXMgPSB0eXBlLnByb3BUeXBlcztcclxuICAgIH0gZWxzZSBpZiAodHlwZW9mIHR5cGUgPT09ICdvYmplY3QnICYmICh0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFIHx8IC8vIE5vdGU6IE1lbW8gb25seSBjaGVja3Mgb3V0ZXIgcHJvcHMgaGVyZS5cclxuICAgIC8vIElubmVyIHByb3BzIGFyZSBjaGVja2VkIGluIHRoZSByZWNvbmNpbGVyLlxyXG4gICAgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfTUVNT19UWVBFKSkge1xyXG4gICAgICBwcm9wVHlwZXMgPSB0eXBlLnByb3BUeXBlcztcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBpZiAocHJvcFR5cGVzKSB7XHJcbiAgICAgIC8vIEludGVudGlvbmFsbHkgaW5zaWRlIHRvIGF2b2lkIHRyaWdnZXJpbmcgbGF6eSBpbml0aWFsaXplcnM6XHJcbiAgICAgIHZhciBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpO1xyXG4gICAgICBjaGVja1Byb3BUeXBlcyhwcm9wVHlwZXMsIGVsZW1lbnQucHJvcHMsICdwcm9wJywgbmFtZSwgZWxlbWVudCk7XHJcbiAgICB9IGVsc2UgaWYgKHR5cGUuUHJvcFR5cGVzICE9PSB1bmRlZmluZWQgJiYgIXByb3BUeXBlc01pc3NwZWxsV2FybmluZ1Nob3duKSB7XHJcbiAgICAgIHByb3BUeXBlc01pc3NwZWxsV2FybmluZ1Nob3duID0gdHJ1ZTsgLy8gSW50ZW50aW9uYWxseSBpbnNpZGUgdG8gYXZvaWQgdHJpZ2dlcmluZyBsYXp5IGluaXRpYWxpemVyczpcclxuXHJcbiAgICAgIHZhciBfbmFtZSA9IGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlKTtcclxuXHJcbiAgICAgIGVycm9yKCdDb21wb25lbnQgJXMgZGVjbGFyZWQgYFByb3BUeXBlc2AgaW5zdGVhZCBvZiBgcHJvcFR5cGVzYC4gRGlkIHlvdSBtaXNzcGVsbCB0aGUgcHJvcGVydHkgYXNzaWdubWVudD8nLCBfbmFtZSB8fCAnVW5rbm93bicpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICh0eXBlb2YgdHlwZS5nZXREZWZhdWx0UHJvcHMgPT09ICdmdW5jdGlvbicgJiYgIXR5cGUuZ2V0RGVmYXVsdFByb3BzLmlzUmVhY3RDbGFzc0FwcHJvdmVkKSB7XHJcbiAgICAgIGVycm9yKCdnZXREZWZhdWx0UHJvcHMgaXMgb25seSB1c2VkIG9uIGNsYXNzaWMgUmVhY3QuY3JlYXRlQ2xhc3MgJyArICdkZWZpbml0aW9ucy4gVXNlIGEgc3RhdGljIHByb3BlcnR5IG5hbWVkIGBkZWZhdWx0UHJvcHNgIGluc3RlYWQuJyk7XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcbi8qKlxyXG4gKiBHaXZlbiBhIGZyYWdtZW50LCB2YWxpZGF0ZSB0aGF0IGl0IGNhbiBvbmx5IGJlIHByb3ZpZGVkIHdpdGggZnJhZ21lbnQgcHJvcHNcclxuICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IGZyYWdtZW50XHJcbiAqL1xyXG5cclxuXHJcbmZ1bmN0aW9uIHZhbGlkYXRlRnJhZ21lbnRQcm9wcyhmcmFnbWVudCkge1xyXG4gIHtcclxuICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMoZnJhZ21lbnQucHJvcHMpO1xyXG5cclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICB2YXIga2V5ID0ga2V5c1tpXTtcclxuXHJcbiAgICAgIGlmIChrZXkgIT09ICdjaGlsZHJlbicgJiYga2V5ICE9PSAna2V5Jykge1xyXG4gICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50JDEoZnJhZ21lbnQpO1xyXG5cclxuICAgICAgICBlcnJvcignSW52YWxpZCBwcm9wIGAlc2Agc3VwcGxpZWQgdG8gYFJlYWN0LkZyYWdtZW50YC4gJyArICdSZWFjdC5GcmFnbWVudCBjYW4gb25seSBoYXZlIGBrZXlgIGFuZCBgY2hpbGRyZW5gIHByb3BzLicsIGtleSk7XHJcblxyXG4gICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50JDEobnVsbCk7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBpZiAoZnJhZ21lbnQucmVmICE9PSBudWxsKSB7XHJcbiAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50JDEoZnJhZ21lbnQpO1xyXG5cclxuICAgICAgZXJyb3IoJ0ludmFsaWQgYXR0cmlidXRlIGByZWZgIHN1cHBsaWVkIHRvIGBSZWFjdC5GcmFnbWVudGAuJyk7XHJcblxyXG4gICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxKG51bGwpO1xyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxuZnVuY3Rpb24ganN4V2l0aFZhbGlkYXRpb24odHlwZSwgcHJvcHMsIGtleSwgaXNTdGF0aWNDaGlsZHJlbiwgc291cmNlLCBzZWxmKSB7XHJcbiAge1xyXG4gICAgdmFyIHZhbGlkVHlwZSA9IGlzVmFsaWRFbGVtZW50VHlwZSh0eXBlKTsgLy8gV2Ugd2FybiBpbiB0aGlzIGNhc2UgYnV0IGRvbid0IHRocm93LiBXZSBleHBlY3QgdGhlIGVsZW1lbnQgY3JlYXRpb24gdG9cclxuICAgIC8vIHN1Y2NlZWQgYW5kIHRoZXJlIHdpbGwgbGlrZWx5IGJlIGVycm9ycyBpbiByZW5kZXIuXHJcblxyXG4gICAgaWYgKCF2YWxpZFR5cGUpIHtcclxuICAgICAgdmFyIGluZm8gPSAnJztcclxuXHJcbiAgICAgIGlmICh0eXBlID09PSB1bmRlZmluZWQgfHwgdHlwZW9mIHR5cGUgPT09ICdvYmplY3QnICYmIHR5cGUgIT09IG51bGwgJiYgT2JqZWN0LmtleXModHlwZSkubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgaW5mbyArPSAnIFlvdSBsaWtlbHkgZm9yZ290IHRvIGV4cG9ydCB5b3VyIGNvbXBvbmVudCBmcm9tIHRoZSBmaWxlICcgKyBcIml0J3MgZGVmaW5lZCBpbiwgb3IgeW91IG1pZ2h0IGhhdmUgbWl4ZWQgdXAgZGVmYXVsdCBhbmQgbmFtZWQgaW1wb3J0cy5cIjtcclxuICAgICAgfVxyXG5cclxuICAgICAgdmFyIHNvdXJjZUluZm8gPSBnZXRTb3VyY2VJbmZvRXJyb3JBZGRlbmR1bShzb3VyY2UpO1xyXG5cclxuICAgICAgaWYgKHNvdXJjZUluZm8pIHtcclxuICAgICAgICBpbmZvICs9IHNvdXJjZUluZm87XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgaW5mbyArPSBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgdmFyIHR5cGVTdHJpbmc7XHJcblxyXG4gICAgICBpZiAodHlwZSA9PT0gbnVsbCkge1xyXG4gICAgICAgIHR5cGVTdHJpbmcgPSAnbnVsbCc7XHJcbiAgICAgIH0gZWxzZSBpZiAoaXNBcnJheSh0eXBlKSkge1xyXG4gICAgICAgIHR5cGVTdHJpbmcgPSAnYXJyYXknO1xyXG4gICAgICB9IGVsc2UgaWYgKHR5cGUgIT09IHVuZGVmaW5lZCAmJiB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9FTEVNRU5UX1RZUEUpIHtcclxuICAgICAgICB0eXBlU3RyaW5nID0gXCI8XCIgKyAoZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUudHlwZSkgfHwgJ1Vua25vd24nKSArIFwiIC8+XCI7XHJcbiAgICAgICAgaW5mbyA9ICcgRGlkIHlvdSBhY2NpZGVudGFsbHkgZXhwb3J0IGEgSlNYIGxpdGVyYWwgaW5zdGVhZCBvZiBhIGNvbXBvbmVudD8nO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHR5cGVTdHJpbmcgPSB0eXBlb2YgdHlwZTtcclxuICAgICAgfVxyXG5cclxuICAgICAgZXJyb3IoJ1JlYWN0LmpzeDogdHlwZSBpcyBpbnZhbGlkIC0tIGV4cGVjdGVkIGEgc3RyaW5nIChmb3IgJyArICdidWlsdC1pbiBjb21wb25lbnRzKSBvciBhIGNsYXNzL2Z1bmN0aW9uIChmb3IgY29tcG9zaXRlICcgKyAnY29tcG9uZW50cykgYnV0IGdvdDogJXMuJXMnLCB0eXBlU3RyaW5nLCBpbmZvKTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgZWxlbWVudCA9IGpzeERFVih0eXBlLCBwcm9wcywga2V5LCBzb3VyY2UsIHNlbGYpOyAvLyBUaGUgcmVzdWx0IGNhbiBiZSBudWxsaXNoIGlmIGEgbW9jayBvciBhIGN1c3RvbSBmdW5jdGlvbiBpcyB1c2VkLlxyXG4gICAgLy8gVE9ETzogRHJvcCB0aGlzIHdoZW4gdGhlc2UgYXJlIG5vIGxvbmdlciBhbGxvd2VkIGFzIHRoZSB0eXBlIGFyZ3VtZW50LlxyXG5cclxuICAgIGlmIChlbGVtZW50ID09IG51bGwpIHtcclxuICAgICAgcmV0dXJuIGVsZW1lbnQ7XHJcbiAgICB9IC8vIFNraXAga2V5IHdhcm5pbmcgaWYgdGhlIHR5cGUgaXNuJ3QgdmFsaWQgc2luY2Ugb3VyIGtleSB2YWxpZGF0aW9uIGxvZ2ljXHJcbiAgICAvLyBkb2Vzbid0IGV4cGVjdCBhIG5vbi1zdHJpbmcvZnVuY3Rpb24gdHlwZSBhbmQgY2FuIHRocm93IGNvbmZ1c2luZyBlcnJvcnMuXHJcbiAgICAvLyBXZSBkb24ndCB3YW50IGV4Y2VwdGlvbiBiZWhhdmlvciB0byBkaWZmZXIgYmV0d2VlbiBkZXYgYW5kIHByb2QuXHJcbiAgICAvLyAoUmVuZGVyaW5nIHdpbGwgdGhyb3cgd2l0aCBhIGhlbHBmdWwgbWVzc2FnZSBhbmQgYXMgc29vbiBhcyB0aGUgdHlwZSBpc1xyXG4gICAgLy8gZml4ZWQsIHRoZSBrZXkgd2FybmluZ3Mgd2lsbCBhcHBlYXIuKVxyXG5cclxuXHJcbiAgICBpZiAodmFsaWRUeXBlKSB7XHJcbiAgICAgIHZhciBjaGlsZHJlbiA9IHByb3BzLmNoaWxkcmVuO1xyXG5cclxuICAgICAgaWYgKGNoaWxkcmVuICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICBpZiAoaXNTdGF0aWNDaGlsZHJlbikge1xyXG4gICAgICAgICAgaWYgKGlzQXJyYXkoY2hpbGRyZW4pKSB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICB2YWxpZGF0ZUNoaWxkS2V5cyhjaGlsZHJlbltpXSwgdHlwZSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChPYmplY3QuZnJlZXplKSB7XHJcbiAgICAgICAgICAgICAgT2JqZWN0LmZyZWV6ZShjaGlsZHJlbik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGVycm9yKCdSZWFjdC5qc3g6IFN0YXRpYyBjaGlsZHJlbiBzaG91bGQgYWx3YXlzIGJlIGFuIGFycmF5LiAnICsgJ1lvdSBhcmUgbGlrZWx5IGV4cGxpY2l0bHkgY2FsbGluZyBSZWFjdC5qc3hzIG9yIFJlYWN0LmpzeERFVi4gJyArICdVc2UgdGhlIEJhYmVsIHRyYW5zZm9ybSBpbnN0ZWFkLicpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICB2YWxpZGF0ZUNoaWxkS2V5cyhjaGlsZHJlbiwgdHlwZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHR5cGUgPT09IFJFQUNUX0ZSQUdNRU5UX1RZUEUpIHtcclxuICAgICAgdmFsaWRhdGVGcmFnbWVudFByb3BzKGVsZW1lbnQpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdmFsaWRhdGVQcm9wVHlwZXMoZWxlbWVudCk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGVsZW1lbnQ7XHJcbiAgfVxyXG59IC8vIFRoZXNlIHR3byBmdW5jdGlvbnMgZXhpc3QgdG8gc3RpbGwgZ2V0IGNoaWxkIHdhcm5pbmdzIGluIGRldlxyXG5cclxudmFyIGpzeERFViQxID0gIGpzeFdpdGhWYWxpZGF0aW9uIDtcclxuXHJcbmV4cG9ydHMuRnJhZ21lbnQgPSBSRUFDVF9GUkFHTUVOVF9UWVBFO1xyXG5leHBvcnRzLmpzeERFViA9IGpzeERFViQxO1xyXG4gIH0pKCk7XHJcbn1cclxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/react/cjs/react-jsx-dev-runtime.development.js\n"));

/***/ }),

/***/ "./node_modules/react/cjs/react-jsx-runtime.development.js":
/*!*****************************************************************!*\
  !*** ./node_modules/react/cjs/react-jsx-runtime.development.js ***!
  \*****************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/**\r\n * @license React\r\n * react-jsx-runtime.development.js\r\n *\r\n * Copyright (c) Facebook, Inc. and its affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n */\r\n\r\n\r\n\r\nif (true) {\r\n  (function() {\r\n'use strict';\r\n\r\nvar React = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\r\n\r\n// ATTENTION\r\n// When adding new symbols to this file,\r\n// Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'\r\n// The Symbol used to tag the ReactElement-like types.\r\nvar REACT_ELEMENT_TYPE = Symbol.for('react.element');\r\nvar REACT_PORTAL_TYPE = Symbol.for('react.portal');\r\nvar REACT_FRAGMENT_TYPE = Symbol.for('react.fragment');\r\nvar REACT_STRICT_MODE_TYPE = Symbol.for('react.strict_mode');\r\nvar REACT_PROFILER_TYPE = Symbol.for('react.profiler');\r\nvar REACT_PROVIDER_TYPE = Symbol.for('react.provider');\r\nvar REACT_CONTEXT_TYPE = Symbol.for('react.context');\r\nvar REACT_FORWARD_REF_TYPE = Symbol.for('react.forward_ref');\r\nvar REACT_SUSPENSE_TYPE = Symbol.for('react.suspense');\r\nvar REACT_SUSPENSE_LIST_TYPE = Symbol.for('react.suspense_list');\r\nvar REACT_MEMO_TYPE = Symbol.for('react.memo');\r\nvar REACT_LAZY_TYPE = Symbol.for('react.lazy');\r\nvar REACT_OFFSCREEN_TYPE = Symbol.for('react.offscreen');\r\nvar MAYBE_ITERATOR_SYMBOL = Symbol.iterator;\r\nvar FAUX_ITERATOR_SYMBOL = '@@iterator';\r\nfunction getIteratorFn(maybeIterable) {\r\n  if (maybeIterable === null || typeof maybeIterable !== 'object') {\r\n    return null;\r\n  }\r\n\r\n  var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];\r\n\r\n  if (typeof maybeIterator === 'function') {\r\n    return maybeIterator;\r\n  }\r\n\r\n  return null;\r\n}\r\n\r\nvar ReactSharedInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;\r\n\r\nfunction error(format) {\r\n  {\r\n    {\r\n      for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\r\n        args[_key2 - 1] = arguments[_key2];\r\n      }\r\n\r\n      printWarning('error', format, args);\r\n    }\r\n  }\r\n}\r\n\r\nfunction printWarning(level, format, args) {\r\n  // When changing this logic, you might want to also\r\n  // update consoleWithStackDev.www.js as well.\r\n  {\r\n    var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\r\n    var stack = ReactDebugCurrentFrame.getStackAddendum();\r\n\r\n    if (stack !== '') {\r\n      format += '%s';\r\n      args = args.concat([stack]);\r\n    } // eslint-disable-next-line react-internal/safe-string-coercion\r\n\r\n\r\n    var argsWithFormat = args.map(function (item) {\r\n      return String(item);\r\n    }); // Careful: RN currently depends on this prefix\r\n\r\n    argsWithFormat.unshift('Warning: ' + format); // We intentionally don't use spread (or .apply) directly because it\r\n    // breaks IE9: https://github.com/facebook/react/issues/13610\r\n    // eslint-disable-next-line react-internal/no-production-logging\r\n\r\n    Function.prototype.apply.call(console[level], console, argsWithFormat);\r\n  }\r\n}\r\n\r\n// -----------------------------------------------------------------------------\r\n\r\nvar enableScopeAPI = false; // Experimental Create Event Handle API.\r\nvar enableCacheElement = false;\r\nvar enableTransitionTracing = false; // No known bugs, but needs performance testing\r\n\r\nvar enableLegacyHidden = false; // Enables unstable_avoidThisFallback feature in Fiber\r\n// stuff. Intended to enable React core members to more easily debug scheduling\r\n// issues in DEV builds.\r\n\r\nvar enableDebugTracing = false; // Track which Fiber(s) schedule render work.\r\n\r\nvar REACT_MODULE_REFERENCE;\r\n\r\n{\r\n  REACT_MODULE_REFERENCE = Symbol.for('react.module.reference');\r\n}\r\n\r\nfunction isValidElementType(type) {\r\n  if (typeof type === 'string' || typeof type === 'function') {\r\n    return true;\r\n  } // Note: typeof might be other than 'symbol' or 'number' (e.g. if it's a polyfill).\r\n\r\n\r\n  if (type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || enableDebugTracing  || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || enableLegacyHidden  || type === REACT_OFFSCREEN_TYPE || enableScopeAPI  || enableCacheElement  || enableTransitionTracing ) {\r\n    return true;\r\n  }\r\n\r\n  if (typeof type === 'object' && type !== null) {\r\n    if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || // This needs to include all possible module reference object\r\n    // types supported by any Flight configuration anywhere since\r\n    // we don't know which Flight build this will end up being used\r\n    // with.\r\n    type.$$typeof === REACT_MODULE_REFERENCE || type.getModuleId !== undefined) {\r\n      return true;\r\n    }\r\n  }\r\n\r\n  return false;\r\n}\r\n\r\nfunction getWrappedName(outerType, innerType, wrapperName) {\r\n  var displayName = outerType.displayName;\r\n\r\n  if (displayName) {\r\n    return displayName;\r\n  }\r\n\r\n  var functionName = innerType.displayName || innerType.name || '';\r\n  return functionName !== '' ? wrapperName + \"(\" + functionName + \")\" : wrapperName;\r\n} // Keep in sync with react-reconciler/getComponentNameFromFiber\r\n\r\n\r\nfunction getContextName(type) {\r\n  return type.displayName || 'Context';\r\n} // Note that the reconciler package should generally prefer to use getComponentNameFromFiber() instead.\r\n\r\n\r\nfunction getComponentNameFromType(type) {\r\n  if (type == null) {\r\n    // Host root, text node or just invalid type.\r\n    return null;\r\n  }\r\n\r\n  {\r\n    if (typeof type.tag === 'number') {\r\n      error('Received an unexpected object in getComponentNameFromType(). ' + 'This is likely a bug in React. Please file an issue.');\r\n    }\r\n  }\r\n\r\n  if (typeof type === 'function') {\r\n    return type.displayName || type.name || null;\r\n  }\r\n\r\n  if (typeof type === 'string') {\r\n    return type;\r\n  }\r\n\r\n  switch (type) {\r\n    case REACT_FRAGMENT_TYPE:\r\n      return 'Fragment';\r\n\r\n    case REACT_PORTAL_TYPE:\r\n      return 'Portal';\r\n\r\n    case REACT_PROFILER_TYPE:\r\n      return 'Profiler';\r\n\r\n    case REACT_STRICT_MODE_TYPE:\r\n      return 'StrictMode';\r\n\r\n    case REACT_SUSPENSE_TYPE:\r\n      return 'Suspense';\r\n\r\n    case REACT_SUSPENSE_LIST_TYPE:\r\n      return 'SuspenseList';\r\n\r\n  }\r\n\r\n  if (typeof type === 'object') {\r\n    switch (type.$$typeof) {\r\n      case REACT_CONTEXT_TYPE:\r\n        var context = type;\r\n        return getContextName(context) + '.Consumer';\r\n\r\n      case REACT_PROVIDER_TYPE:\r\n        var provider = type;\r\n        return getContextName(provider._context) + '.Provider';\r\n\r\n      case REACT_FORWARD_REF_TYPE:\r\n        return getWrappedName(type, type.render, 'ForwardRef');\r\n\r\n      case REACT_MEMO_TYPE:\r\n        var outerName = type.displayName || null;\r\n\r\n        if (outerName !== null) {\r\n          return outerName;\r\n        }\r\n\r\n        return getComponentNameFromType(type.type) || 'Memo';\r\n\r\n      case REACT_LAZY_TYPE:\r\n        {\r\n          var lazyComponent = type;\r\n          var payload = lazyComponent._payload;\r\n          var init = lazyComponent._init;\r\n\r\n          try {\r\n            return getComponentNameFromType(init(payload));\r\n          } catch (x) {\r\n            return null;\r\n          }\r\n        }\r\n\r\n      // eslint-disable-next-line no-fallthrough\r\n    }\r\n  }\r\n\r\n  return null;\r\n}\r\n\r\nvar assign = Object.assign;\r\n\r\n// Helpers to patch console.logs to avoid logging during side-effect free\r\n// replaying on render function. This currently only patches the object\r\n// lazily which won't cover if the log function was extracted eagerly.\r\n// We could also eagerly patch the method.\r\nvar disabledDepth = 0;\r\nvar prevLog;\r\nvar prevInfo;\r\nvar prevWarn;\r\nvar prevError;\r\nvar prevGroup;\r\nvar prevGroupCollapsed;\r\nvar prevGroupEnd;\r\n\r\nfunction disabledLog() {}\r\n\r\ndisabledLog.__reactDisabledLog = true;\r\nfunction disableLogs() {\r\n  {\r\n    if (disabledDepth === 0) {\r\n      /* eslint-disable react-internal/no-production-logging */\r\n      prevLog = console.log;\r\n      prevInfo = console.info;\r\n      prevWarn = console.warn;\r\n      prevError = console.error;\r\n      prevGroup = console.group;\r\n      prevGroupCollapsed = console.groupCollapsed;\r\n      prevGroupEnd = console.groupEnd; // https://github.com/facebook/react/issues/19099\r\n\r\n      var props = {\r\n        configurable: true,\r\n        enumerable: true,\r\n        value: disabledLog,\r\n        writable: true\r\n      }; // $FlowFixMe Flow thinks console is immutable.\r\n\r\n      Object.defineProperties(console, {\r\n        info: props,\r\n        log: props,\r\n        warn: props,\r\n        error: props,\r\n        group: props,\r\n        groupCollapsed: props,\r\n        groupEnd: props\r\n      });\r\n      /* eslint-enable react-internal/no-production-logging */\r\n    }\r\n\r\n    disabledDepth++;\r\n  }\r\n}\r\nfunction reenableLogs() {\r\n  {\r\n    disabledDepth--;\r\n\r\n    if (disabledDepth === 0) {\r\n      /* eslint-disable react-internal/no-production-logging */\r\n      var props = {\r\n        configurable: true,\r\n        enumerable: true,\r\n        writable: true\r\n      }; // $FlowFixMe Flow thinks console is immutable.\r\n\r\n      Object.defineProperties(console, {\r\n        log: assign({}, props, {\r\n          value: prevLog\r\n        }),\r\n        info: assign({}, props, {\r\n          value: prevInfo\r\n        }),\r\n        warn: assign({}, props, {\r\n          value: prevWarn\r\n        }),\r\n        error: assign({}, props, {\r\n          value: prevError\r\n        }),\r\n        group: assign({}, props, {\r\n          value: prevGroup\r\n        }),\r\n        groupCollapsed: assign({}, props, {\r\n          value: prevGroupCollapsed\r\n        }),\r\n        groupEnd: assign({}, props, {\r\n          value: prevGroupEnd\r\n        })\r\n      });\r\n      /* eslint-enable react-internal/no-production-logging */\r\n    }\r\n\r\n    if (disabledDepth < 0) {\r\n      error('disabledDepth fell below zero. ' + 'This is a bug in React. Please file an issue.');\r\n    }\r\n  }\r\n}\r\n\r\nvar ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;\r\nvar prefix;\r\nfunction describeBuiltInComponentFrame(name, source, ownerFn) {\r\n  {\r\n    if (prefix === undefined) {\r\n      // Extract the VM specific prefix used by each line.\r\n      try {\r\n        throw Error();\r\n      } catch (x) {\r\n        var match = x.stack.trim().match(/\\n( *(at )?)/);\r\n        prefix = match && match[1] || '';\r\n      }\r\n    } // We use the prefix to ensure our stacks line up with native stack frames.\r\n\r\n\r\n    return '\\n' + prefix + name;\r\n  }\r\n}\r\nvar reentry = false;\r\nvar componentFrameCache;\r\n\r\n{\r\n  var PossiblyWeakMap = typeof WeakMap === 'function' ? WeakMap : Map;\r\n  componentFrameCache = new PossiblyWeakMap();\r\n}\r\n\r\nfunction describeNativeComponentFrame(fn, construct) {\r\n  // If something asked for a stack inside a fake render, it should get ignored.\r\n  if ( !fn || reentry) {\r\n    return '';\r\n  }\r\n\r\n  {\r\n    var frame = componentFrameCache.get(fn);\r\n\r\n    if (frame !== undefined) {\r\n      return frame;\r\n    }\r\n  }\r\n\r\n  var control;\r\n  reentry = true;\r\n  var previousPrepareStackTrace = Error.prepareStackTrace; // $FlowFixMe It does accept undefined.\r\n\r\n  Error.prepareStackTrace = undefined;\r\n  var previousDispatcher;\r\n\r\n  {\r\n    previousDispatcher = ReactCurrentDispatcher.current; // Set the dispatcher in DEV because this might be call in the render function\r\n    // for warnings.\r\n\r\n    ReactCurrentDispatcher.current = null;\r\n    disableLogs();\r\n  }\r\n\r\n  try {\r\n    // This should throw.\r\n    if (construct) {\r\n      // Something should be setting the props in the constructor.\r\n      var Fake = function () {\r\n        throw Error();\r\n      }; // $FlowFixMe\r\n\r\n\r\n      Object.defineProperty(Fake.prototype, 'props', {\r\n        set: function () {\r\n          // We use a throwing setter instead of frozen or non-writable props\r\n          // because that won't throw in a non-strict mode function.\r\n          throw Error();\r\n        }\r\n      });\r\n\r\n      if (typeof Reflect === 'object' && Reflect.construct) {\r\n        // We construct a different control for this case to include any extra\r\n        // frames added by the construct call.\r\n        try {\r\n          Reflect.construct(Fake, []);\r\n        } catch (x) {\r\n          control = x;\r\n        }\r\n\r\n        Reflect.construct(fn, [], Fake);\r\n      } else {\r\n        try {\r\n          Fake.call();\r\n        } catch (x) {\r\n          control = x;\r\n        }\r\n\r\n        fn.call(Fake.prototype);\r\n      }\r\n    } else {\r\n      try {\r\n        throw Error();\r\n      } catch (x) {\r\n        control = x;\r\n      }\r\n\r\n      fn();\r\n    }\r\n  } catch (sample) {\r\n    // This is inlined manually because closure doesn't do it for us.\r\n    if (sample && control && typeof sample.stack === 'string') {\r\n      // This extracts the first frame from the sample that isn't also in the control.\r\n      // Skipping one frame that we assume is the frame that calls the two.\r\n      var sampleLines = sample.stack.split('\\n');\r\n      var controlLines = control.stack.split('\\n');\r\n      var s = sampleLines.length - 1;\r\n      var c = controlLines.length - 1;\r\n\r\n      while (s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]) {\r\n        // We expect at least one stack frame to be shared.\r\n        // Typically this will be the root most one. However, stack frames may be\r\n        // cut off due to maximum stack limits. In this case, one maybe cut off\r\n        // earlier than the other. We assume that the sample is longer or the same\r\n        // and there for cut off earlier. So we should find the root most frame in\r\n        // the sample somewhere in the control.\r\n        c--;\r\n      }\r\n\r\n      for (; s >= 1 && c >= 0; s--, c--) {\r\n        // Next we find the first one that isn't the same which should be the\r\n        // frame that called our sample function and the control.\r\n        if (sampleLines[s] !== controlLines[c]) {\r\n          // In V8, the first line is describing the message but other VMs don't.\r\n          // If we're about to return the first line, and the control is also on the same\r\n          // line, that's a pretty good indicator that our sample threw at same line as\r\n          // the control. I.e. before we entered the sample frame. So we ignore this result.\r\n          // This can happen if you passed a class to function component, or non-function.\r\n          if (s !== 1 || c !== 1) {\r\n            do {\r\n              s--;\r\n              c--; // We may still have similar intermediate frames from the construct call.\r\n              // The next one that isn't the same should be our match though.\r\n\r\n              if (c < 0 || sampleLines[s] !== controlLines[c]) {\r\n                // V8 adds a \"new\" prefix for native classes. Let's remove it to make it prettier.\r\n                var _frame = '\\n' + sampleLines[s].replace(' at new ', ' at '); // If our component frame is labeled \"<anonymous>\"\r\n                // but we have a user-provided \"displayName\"\r\n                // splice it in to make the stack more readable.\r\n\r\n\r\n                if (fn.displayName && _frame.includes('<anonymous>')) {\r\n                  _frame = _frame.replace('<anonymous>', fn.displayName);\r\n                }\r\n\r\n                {\r\n                  if (typeof fn === 'function') {\r\n                    componentFrameCache.set(fn, _frame);\r\n                  }\r\n                } // Return the line we found.\r\n\r\n\r\n                return _frame;\r\n              }\r\n            } while (s >= 1 && c >= 0);\r\n          }\r\n\r\n          break;\r\n        }\r\n      }\r\n    }\r\n  } finally {\r\n    reentry = false;\r\n\r\n    {\r\n      ReactCurrentDispatcher.current = previousDispatcher;\r\n      reenableLogs();\r\n    }\r\n\r\n    Error.prepareStackTrace = previousPrepareStackTrace;\r\n  } // Fallback to just using the name if we couldn't make it throw.\r\n\r\n\r\n  var name = fn ? fn.displayName || fn.name : '';\r\n  var syntheticFrame = name ? describeBuiltInComponentFrame(name) : '';\r\n\r\n  {\r\n    if (typeof fn === 'function') {\r\n      componentFrameCache.set(fn, syntheticFrame);\r\n    }\r\n  }\r\n\r\n  return syntheticFrame;\r\n}\r\nfunction describeFunctionComponentFrame(fn, source, ownerFn) {\r\n  {\r\n    return describeNativeComponentFrame(fn, false);\r\n  }\r\n}\r\n\r\nfunction shouldConstruct(Component) {\r\n  var prototype = Component.prototype;\r\n  return !!(prototype && prototype.isReactComponent);\r\n}\r\n\r\nfunction describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {\r\n\r\n  if (type == null) {\r\n    return '';\r\n  }\r\n\r\n  if (typeof type === 'function') {\r\n    {\r\n      return describeNativeComponentFrame(type, shouldConstruct(type));\r\n    }\r\n  }\r\n\r\n  if (typeof type === 'string') {\r\n    return describeBuiltInComponentFrame(type);\r\n  }\r\n\r\n  switch (type) {\r\n    case REACT_SUSPENSE_TYPE:\r\n      return describeBuiltInComponentFrame('Suspense');\r\n\r\n    case REACT_SUSPENSE_LIST_TYPE:\r\n      return describeBuiltInComponentFrame('SuspenseList');\r\n  }\r\n\r\n  if (typeof type === 'object') {\r\n    switch (type.$$typeof) {\r\n      case REACT_FORWARD_REF_TYPE:\r\n        return describeFunctionComponentFrame(type.render);\r\n\r\n      case REACT_MEMO_TYPE:\r\n        // Memo may contain any component type so we recursively resolve it.\r\n        return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);\r\n\r\n      case REACT_LAZY_TYPE:\r\n        {\r\n          var lazyComponent = type;\r\n          var payload = lazyComponent._payload;\r\n          var init = lazyComponent._init;\r\n\r\n          try {\r\n            // Lazy may contain any component type so we recursively resolve it.\r\n            return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);\r\n          } catch (x) {}\r\n        }\r\n    }\r\n  }\r\n\r\n  return '';\r\n}\r\n\r\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\r\n\r\nvar loggedTypeFailures = {};\r\nvar ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\r\n\r\nfunction setCurrentlyValidatingElement(element) {\r\n  {\r\n    if (element) {\r\n      var owner = element._owner;\r\n      var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);\r\n      ReactDebugCurrentFrame.setExtraStackFrame(stack);\r\n    } else {\r\n      ReactDebugCurrentFrame.setExtraStackFrame(null);\r\n    }\r\n  }\r\n}\r\n\r\nfunction checkPropTypes(typeSpecs, values, location, componentName, element) {\r\n  {\r\n    // $FlowFixMe This is okay but Flow doesn't know it.\r\n    var has = Function.call.bind(hasOwnProperty);\r\n\r\n    for (var typeSpecName in typeSpecs) {\r\n      if (has(typeSpecs, typeSpecName)) {\r\n        var error$1 = void 0; // Prop type validation may throw. In case they do, we don't want to\r\n        // fail the render phase where it didn't fail before. So we log it.\r\n        // After these have been cleaned up, we'll let them throw.\r\n\r\n        try {\r\n          // This is intentionally an invariant that gets caught. It's the same\r\n          // behavior as without this statement except with a better message.\r\n          if (typeof typeSpecs[typeSpecName] !== 'function') {\r\n            // eslint-disable-next-line react-internal/prod-error-codes\r\n            var err = Error((componentName || 'React class') + ': ' + location + ' type `' + typeSpecName + '` is invalid; ' + 'it must be a function, usually from the `prop-types` package, but received `' + typeof typeSpecs[typeSpecName] + '`.' + 'This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.');\r\n            err.name = 'Invariant Violation';\r\n            throw err;\r\n          }\r\n\r\n          error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED');\r\n        } catch (ex) {\r\n          error$1 = ex;\r\n        }\r\n\r\n        if (error$1 && !(error$1 instanceof Error)) {\r\n          setCurrentlyValidatingElement(element);\r\n\r\n          error('%s: type specification of %s' + ' `%s` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a %s. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).', componentName || 'React class', location, typeSpecName, typeof error$1);\r\n\r\n          setCurrentlyValidatingElement(null);\r\n        }\r\n\r\n        if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {\r\n          // Only monitor this failure once because there tends to be a lot of the\r\n          // same error.\r\n          loggedTypeFailures[error$1.message] = true;\r\n          setCurrentlyValidatingElement(element);\r\n\r\n          error('Failed %s type: %s', location, error$1.message);\r\n\r\n          setCurrentlyValidatingElement(null);\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nvar isArrayImpl = Array.isArray; // eslint-disable-next-line no-redeclare\r\n\r\nfunction isArray(a) {\r\n  return isArrayImpl(a);\r\n}\r\n\r\n/*\r\n * The `'' + value` pattern (used in in perf-sensitive code) throws for Symbol\r\n * and Temporal.* types. See https://github.com/facebook/react/pull/22064.\r\n *\r\n * The functions in this module will throw an easier-to-understand,\r\n * easier-to-debug exception with a clear errors message message explaining the\r\n * problem. (Instead of a confusing exception thrown inside the implementation\r\n * of the `value` object).\r\n */\r\n// $FlowFixMe only called in DEV, so void return is not possible.\r\nfunction typeName(value) {\r\n  {\r\n    // toStringTag is needed for namespaced types like Temporal.Instant\r\n    var hasToStringTag = typeof Symbol === 'function' && Symbol.toStringTag;\r\n    var type = hasToStringTag && value[Symbol.toStringTag] || value.constructor.name || 'Object';\r\n    return type;\r\n  }\r\n} // $FlowFixMe only called in DEV, so void return is not possible.\r\n\r\n\r\nfunction willCoercionThrow(value) {\r\n  {\r\n    try {\r\n      testStringCoercion(value);\r\n      return false;\r\n    } catch (e) {\r\n      return true;\r\n    }\r\n  }\r\n}\r\n\r\nfunction testStringCoercion(value) {\r\n  // If you ended up here by following an exception call stack, here's what's\r\n  // happened: you supplied an object or symbol value to React (as a prop, key,\r\n  // DOM attribute, CSS property, string ref, etc.) and when React tried to\r\n  // coerce it to a string using `'' + value`, an exception was thrown.\r\n  //\r\n  // The most common types that will cause this exception are `Symbol` instances\r\n  // and Temporal objects like `Temporal.Instant`. But any object that has a\r\n  // `valueOf` or `[Symbol.toPrimitive]` method that throws will also cause this\r\n  // exception. (Library authors do this to prevent users from using built-in\r\n  // numeric operators like `+` or comparison operators like `>=` because custom\r\n  // methods are needed to perform accurate arithmetic or comparison.)\r\n  //\r\n  // To fix the problem, coerce this object or symbol value to a string before\r\n  // passing it to React. The most reliable way is usually `String(value)`.\r\n  //\r\n  // To find which value is throwing, check the browser or debugger console.\r\n  // Before this exception was thrown, there should be `console.error` output\r\n  // that shows the type (Symbol, Temporal.PlainDate, etc.) that caused the\r\n  // problem and how that type was used: key, atrribute, input value prop, etc.\r\n  // In most cases, this console output also shows the component and its\r\n  // ancestor components where the exception happened.\r\n  //\r\n  // eslint-disable-next-line react-internal/safe-string-coercion\r\n  return '' + value;\r\n}\r\nfunction checkKeyStringCoercion(value) {\r\n  {\r\n    if (willCoercionThrow(value)) {\r\n      error('The provided key is an unsupported type %s.' + ' This value must be coerced to a string before before using it here.', typeName(value));\r\n\r\n      return testStringCoercion(value); // throw (to help callers find troubleshooting comments)\r\n    }\r\n  }\r\n}\r\n\r\nvar ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;\r\nvar RESERVED_PROPS = {\r\n  key: true,\r\n  ref: true,\r\n  __self: true,\r\n  __source: true\r\n};\r\nvar specialPropKeyWarningShown;\r\nvar specialPropRefWarningShown;\r\nvar didWarnAboutStringRefs;\r\n\r\n{\r\n  didWarnAboutStringRefs = {};\r\n}\r\n\r\nfunction hasValidRef(config) {\r\n  {\r\n    if (hasOwnProperty.call(config, 'ref')) {\r\n      var getter = Object.getOwnPropertyDescriptor(config, 'ref').get;\r\n\r\n      if (getter && getter.isReactWarning) {\r\n        return false;\r\n      }\r\n    }\r\n  }\r\n\r\n  return config.ref !== undefined;\r\n}\r\n\r\nfunction hasValidKey(config) {\r\n  {\r\n    if (hasOwnProperty.call(config, 'key')) {\r\n      var getter = Object.getOwnPropertyDescriptor(config, 'key').get;\r\n\r\n      if (getter && getter.isReactWarning) {\r\n        return false;\r\n      }\r\n    }\r\n  }\r\n\r\n  return config.key !== undefined;\r\n}\r\n\r\nfunction warnIfStringRefCannotBeAutoConverted(config, self) {\r\n  {\r\n    if (typeof config.ref === 'string' && ReactCurrentOwner.current && self && ReactCurrentOwner.current.stateNode !== self) {\r\n      var componentName = getComponentNameFromType(ReactCurrentOwner.current.type);\r\n\r\n      if (!didWarnAboutStringRefs[componentName]) {\r\n        error('Component \"%s\" contains the string ref \"%s\". ' + 'Support for string refs will be removed in a future major release. ' + 'This case cannot be automatically converted to an arrow function. ' + 'We ask you to manually fix this case by using useRef() or createRef() instead. ' + 'Learn more about using refs safely here: ' + 'https://reactjs.org/link/strict-mode-string-ref', getComponentNameFromType(ReactCurrentOwner.current.type), config.ref);\r\n\r\n        didWarnAboutStringRefs[componentName] = true;\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nfunction defineKeyPropWarningGetter(props, displayName) {\r\n  {\r\n    var warnAboutAccessingKey = function () {\r\n      if (!specialPropKeyWarningShown) {\r\n        specialPropKeyWarningShown = true;\r\n\r\n        error('%s: `key` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);\r\n      }\r\n    };\r\n\r\n    warnAboutAccessingKey.isReactWarning = true;\r\n    Object.defineProperty(props, 'key', {\r\n      get: warnAboutAccessingKey,\r\n      configurable: true\r\n    });\r\n  }\r\n}\r\n\r\nfunction defineRefPropWarningGetter(props, displayName) {\r\n  {\r\n    var warnAboutAccessingRef = function () {\r\n      if (!specialPropRefWarningShown) {\r\n        specialPropRefWarningShown = true;\r\n\r\n        error('%s: `ref` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);\r\n      }\r\n    };\r\n\r\n    warnAboutAccessingRef.isReactWarning = true;\r\n    Object.defineProperty(props, 'ref', {\r\n      get: warnAboutAccessingRef,\r\n      configurable: true\r\n    });\r\n  }\r\n}\r\n/**\r\n * Factory method to create a new React element. This no longer adheres to\r\n * the class pattern, so do not use new to call it. Also, instanceof check\r\n * will not work. Instead test $$typeof field against Symbol.for('react.element') to check\r\n * if something is a React Element.\r\n *\r\n * @param {*} type\r\n * @param {*} props\r\n * @param {*} key\r\n * @param {string|object} ref\r\n * @param {*} owner\r\n * @param {*} self A *temporary* helper to detect places where `this` is\r\n * different from the `owner` when React.createElement is called, so that we\r\n * can warn. We want to get rid of owner and replace string `ref`s with arrow\r\n * functions, and as long as `this` and owner are the same, there will be no\r\n * change in behavior.\r\n * @param {*} source An annotation object (added by a transpiler or otherwise)\r\n * indicating filename, line number, and/or other information.\r\n * @internal\r\n */\r\n\r\n\r\nvar ReactElement = function (type, key, ref, self, source, owner, props) {\r\n  var element = {\r\n    // This tag allows us to uniquely identify this as a React Element\r\n    $$typeof: REACT_ELEMENT_TYPE,\r\n    // Built-in properties that belong on the element\r\n    type: type,\r\n    key: key,\r\n    ref: ref,\r\n    props: props,\r\n    // Record the component responsible for creating this element.\r\n    _owner: owner\r\n  };\r\n\r\n  {\r\n    // The validation flag is currently mutative. We put it on\r\n    // an external backing store so that we can freeze the whole object.\r\n    // This can be replaced with a WeakMap once they are implemented in\r\n    // commonly used development environments.\r\n    element._store = {}; // To make comparing ReactElements easier for testing purposes, we make\r\n    // the validation flag non-enumerable (where possible, which should\r\n    // include every environment we run tests in), so the test framework\r\n    // ignores it.\r\n\r\n    Object.defineProperty(element._store, 'validated', {\r\n      configurable: false,\r\n      enumerable: false,\r\n      writable: true,\r\n      value: false\r\n    }); // self and source are DEV only properties.\r\n\r\n    Object.defineProperty(element, '_self', {\r\n      configurable: false,\r\n      enumerable: false,\r\n      writable: false,\r\n      value: self\r\n    }); // Two elements created in two different places should be considered\r\n    // equal for testing purposes and therefore we hide it from enumeration.\r\n\r\n    Object.defineProperty(element, '_source', {\r\n      configurable: false,\r\n      enumerable: false,\r\n      writable: false,\r\n      value: source\r\n    });\r\n\r\n    if (Object.freeze) {\r\n      Object.freeze(element.props);\r\n      Object.freeze(element);\r\n    }\r\n  }\r\n\r\n  return element;\r\n};\r\n/**\r\n * https://github.com/reactjs/rfcs/pull/107\r\n * @param {*} type\r\n * @param {object} props\r\n * @param {string} key\r\n */\r\n\r\nfunction jsxDEV(type, config, maybeKey, source, self) {\r\n  {\r\n    var propName; // Reserved names are extracted\r\n\r\n    var props = {};\r\n    var key = null;\r\n    var ref = null; // Currently, key can be spread in as a prop. This causes a potential\r\n    // issue if key is also explicitly declared (ie. <div {...props} key=\"Hi\" />\r\n    // or <div key=\"Hi\" {...props} /> ). We want to deprecate key spread,\r\n    // but as an intermediary step, we will use jsxDEV for everything except\r\n    // <div {...props} key=\"Hi\" />, because we aren't currently able to tell if\r\n    // key is explicitly declared to be undefined or not.\r\n\r\n    if (maybeKey !== undefined) {\r\n      {\r\n        checkKeyStringCoercion(maybeKey);\r\n      }\r\n\r\n      key = '' + maybeKey;\r\n    }\r\n\r\n    if (hasValidKey(config)) {\r\n      {\r\n        checkKeyStringCoercion(config.key);\r\n      }\r\n\r\n      key = '' + config.key;\r\n    }\r\n\r\n    if (hasValidRef(config)) {\r\n      ref = config.ref;\r\n      warnIfStringRefCannotBeAutoConverted(config, self);\r\n    } // Remaining properties are added to a new props object\r\n\r\n\r\n    for (propName in config) {\r\n      if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {\r\n        props[propName] = config[propName];\r\n      }\r\n    } // Resolve default props\r\n\r\n\r\n    if (type && type.defaultProps) {\r\n      var defaultProps = type.defaultProps;\r\n\r\n      for (propName in defaultProps) {\r\n        if (props[propName] === undefined) {\r\n          props[propName] = defaultProps[propName];\r\n        }\r\n      }\r\n    }\r\n\r\n    if (key || ref) {\r\n      var displayName = typeof type === 'function' ? type.displayName || type.name || 'Unknown' : type;\r\n\r\n      if (key) {\r\n        defineKeyPropWarningGetter(props, displayName);\r\n      }\r\n\r\n      if (ref) {\r\n        defineRefPropWarningGetter(props, displayName);\r\n      }\r\n    }\r\n\r\n    return ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);\r\n  }\r\n}\r\n\r\nvar ReactCurrentOwner$1 = ReactSharedInternals.ReactCurrentOwner;\r\nvar ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;\r\n\r\nfunction setCurrentlyValidatingElement$1(element) {\r\n  {\r\n    if (element) {\r\n      var owner = element._owner;\r\n      var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);\r\n      ReactDebugCurrentFrame$1.setExtraStackFrame(stack);\r\n    } else {\r\n      ReactDebugCurrentFrame$1.setExtraStackFrame(null);\r\n    }\r\n  }\r\n}\r\n\r\nvar propTypesMisspellWarningShown;\r\n\r\n{\r\n  propTypesMisspellWarningShown = false;\r\n}\r\n/**\r\n * Verifies the object is a ReactElement.\r\n * See https://reactjs.org/docs/react-api.html#isvalidelement\r\n * @param {?object} object\r\n * @return {boolean} True if `object` is a ReactElement.\r\n * @final\r\n */\r\n\r\n\r\nfunction isValidElement(object) {\r\n  {\r\n    return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;\r\n  }\r\n}\r\n\r\nfunction getDeclarationErrorAddendum() {\r\n  {\r\n    if (ReactCurrentOwner$1.current) {\r\n      var name = getComponentNameFromType(ReactCurrentOwner$1.current.type);\r\n\r\n      if (name) {\r\n        return '\\n\\nCheck the render method of `' + name + '`.';\r\n      }\r\n    }\r\n\r\n    return '';\r\n  }\r\n}\r\n\r\nfunction getSourceInfoErrorAddendum(source) {\r\n  {\r\n    if (source !== undefined) {\r\n      var fileName = source.fileName.replace(/^.*[\\\\\\/]/, '');\r\n      var lineNumber = source.lineNumber;\r\n      return '\\n\\nCheck your code at ' + fileName + ':' + lineNumber + '.';\r\n    }\r\n\r\n    return '';\r\n  }\r\n}\r\n/**\r\n * Warn if there's no key explicitly set on dynamic arrays of children or\r\n * object keys are not valid. This allows us to keep track of children between\r\n * updates.\r\n */\r\n\r\n\r\nvar ownerHasKeyUseWarning = {};\r\n\r\nfunction getCurrentComponentErrorInfo(parentType) {\r\n  {\r\n    var info = getDeclarationErrorAddendum();\r\n\r\n    if (!info) {\r\n      var parentName = typeof parentType === 'string' ? parentType : parentType.displayName || parentType.name;\r\n\r\n      if (parentName) {\r\n        info = \"\\n\\nCheck the top-level render call using <\" + parentName + \">.\";\r\n      }\r\n    }\r\n\r\n    return info;\r\n  }\r\n}\r\n/**\r\n * Warn if the element doesn't have an explicit key assigned to it.\r\n * This element is in an array. The array could grow and shrink or be\r\n * reordered. All children that haven't already been validated are required to\r\n * have a \"key\" property assigned to it. Error statuses are cached so a warning\r\n * will only be shown once.\r\n *\r\n * @internal\r\n * @param {ReactElement} element Element that requires a key.\r\n * @param {*} parentType element's parent's type.\r\n */\r\n\r\n\r\nfunction validateExplicitKey(element, parentType) {\r\n  {\r\n    if (!element._store || element._store.validated || element.key != null) {\r\n      return;\r\n    }\r\n\r\n    element._store.validated = true;\r\n    var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);\r\n\r\n    if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {\r\n      return;\r\n    }\r\n\r\n    ownerHasKeyUseWarning[currentComponentErrorInfo] = true; // Usually the current owner is the offender, but if it accepts children as a\r\n    // property, it may be the creator of the child that's responsible for\r\n    // assigning it a key.\r\n\r\n    var childOwner = '';\r\n\r\n    if (element && element._owner && element._owner !== ReactCurrentOwner$1.current) {\r\n      // Give the component that originally created this child.\r\n      childOwner = \" It was passed a child from \" + getComponentNameFromType(element._owner.type) + \".\";\r\n    }\r\n\r\n    setCurrentlyValidatingElement$1(element);\r\n\r\n    error('Each child in a list should have a unique \"key\" prop.' + '%s%s See https://reactjs.org/link/warning-keys for more information.', currentComponentErrorInfo, childOwner);\r\n\r\n    setCurrentlyValidatingElement$1(null);\r\n  }\r\n}\r\n/**\r\n * Ensure that every element either is passed in a static location, in an\r\n * array with an explicit keys property defined, or in an object literal\r\n * with valid key property.\r\n *\r\n * @internal\r\n * @param {ReactNode} node Statically passed child of any type.\r\n * @param {*} parentType node's parent's type.\r\n */\r\n\r\n\r\nfunction validateChildKeys(node, parentType) {\r\n  {\r\n    if (typeof node !== 'object') {\r\n      return;\r\n    }\r\n\r\n    if (isArray(node)) {\r\n      for (var i = 0; i < node.length; i++) {\r\n        var child = node[i];\r\n\r\n        if (isValidElement(child)) {\r\n          validateExplicitKey(child, parentType);\r\n        }\r\n      }\r\n    } else if (isValidElement(node)) {\r\n      // This element was passed in a valid location.\r\n      if (node._store) {\r\n        node._store.validated = true;\r\n      }\r\n    } else if (node) {\r\n      var iteratorFn = getIteratorFn(node);\r\n\r\n      if (typeof iteratorFn === 'function') {\r\n        // Entry iterators used to provide implicit keys,\r\n        // but now we print a separate warning for them later.\r\n        if (iteratorFn !== node.entries) {\r\n          var iterator = iteratorFn.call(node);\r\n          var step;\r\n\r\n          while (!(step = iterator.next()).done) {\r\n            if (isValidElement(step.value)) {\r\n              validateExplicitKey(step.value, parentType);\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n/**\r\n * Given an element, validate that its props follow the propTypes definition,\r\n * provided by the type.\r\n *\r\n * @param {ReactElement} element\r\n */\r\n\r\n\r\nfunction validatePropTypes(element) {\r\n  {\r\n    var type = element.type;\r\n\r\n    if (type === null || type === undefined || typeof type === 'string') {\r\n      return;\r\n    }\r\n\r\n    var propTypes;\r\n\r\n    if (typeof type === 'function') {\r\n      propTypes = type.propTypes;\r\n    } else if (typeof type === 'object' && (type.$$typeof === REACT_FORWARD_REF_TYPE || // Note: Memo only checks outer props here.\r\n    // Inner props are checked in the reconciler.\r\n    type.$$typeof === REACT_MEMO_TYPE)) {\r\n      propTypes = type.propTypes;\r\n    } else {\r\n      return;\r\n    }\r\n\r\n    if (propTypes) {\r\n      // Intentionally inside to avoid triggering lazy initializers:\r\n      var name = getComponentNameFromType(type);\r\n      checkPropTypes(propTypes, element.props, 'prop', name, element);\r\n    } else if (type.PropTypes !== undefined && !propTypesMisspellWarningShown) {\r\n      propTypesMisspellWarningShown = true; // Intentionally inside to avoid triggering lazy initializers:\r\n\r\n      var _name = getComponentNameFromType(type);\r\n\r\n      error('Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?', _name || 'Unknown');\r\n    }\r\n\r\n    if (typeof type.getDefaultProps === 'function' && !type.getDefaultProps.isReactClassApproved) {\r\n      error('getDefaultProps is only used on classic React.createClass ' + 'definitions. Use a static property named `defaultProps` instead.');\r\n    }\r\n  }\r\n}\r\n/**\r\n * Given a fragment, validate that it can only be provided with fragment props\r\n * @param {ReactElement} fragment\r\n */\r\n\r\n\r\nfunction validateFragmentProps(fragment) {\r\n  {\r\n    var keys = Object.keys(fragment.props);\r\n\r\n    for (var i = 0; i < keys.length; i++) {\r\n      var key = keys[i];\r\n\r\n      if (key !== 'children' && key !== 'key') {\r\n        setCurrentlyValidatingElement$1(fragment);\r\n\r\n        error('Invalid prop `%s` supplied to `React.Fragment`. ' + 'React.Fragment can only have `key` and `children` props.', key);\r\n\r\n        setCurrentlyValidatingElement$1(null);\r\n        break;\r\n      }\r\n    }\r\n\r\n    if (fragment.ref !== null) {\r\n      setCurrentlyValidatingElement$1(fragment);\r\n\r\n      error('Invalid attribute `ref` supplied to `React.Fragment`.');\r\n\r\n      setCurrentlyValidatingElement$1(null);\r\n    }\r\n  }\r\n}\r\n\r\nfunction jsxWithValidation(type, props, key, isStaticChildren, source, self) {\r\n  {\r\n    var validType = isValidElementType(type); // We warn in this case but don't throw. We expect the element creation to\r\n    // succeed and there will likely be errors in render.\r\n\r\n    if (!validType) {\r\n      var info = '';\r\n\r\n      if (type === undefined || typeof type === 'object' && type !== null && Object.keys(type).length === 0) {\r\n        info += ' You likely forgot to export your component from the file ' + \"it's defined in, or you might have mixed up default and named imports.\";\r\n      }\r\n\r\n      var sourceInfo = getSourceInfoErrorAddendum(source);\r\n\r\n      if (sourceInfo) {\r\n        info += sourceInfo;\r\n      } else {\r\n        info += getDeclarationErrorAddendum();\r\n      }\r\n\r\n      var typeString;\r\n\r\n      if (type === null) {\r\n        typeString = 'null';\r\n      } else if (isArray(type)) {\r\n        typeString = 'array';\r\n      } else if (type !== undefined && type.$$typeof === REACT_ELEMENT_TYPE) {\r\n        typeString = \"<\" + (getComponentNameFromType(type.type) || 'Unknown') + \" />\";\r\n        info = ' Did you accidentally export a JSX literal instead of a component?';\r\n      } else {\r\n        typeString = typeof type;\r\n      }\r\n\r\n      error('React.jsx: type is invalid -- expected a string (for ' + 'built-in components) or a class/function (for composite ' + 'components) but got: %s.%s', typeString, info);\r\n    }\r\n\r\n    var element = jsxDEV(type, props, key, source, self); // The result can be nullish if a mock or a custom function is used.\r\n    // TODO: Drop this when these are no longer allowed as the type argument.\r\n\r\n    if (element == null) {\r\n      return element;\r\n    } // Skip key warning if the type isn't valid since our key validation logic\r\n    // doesn't expect a non-string/function type and can throw confusing errors.\r\n    // We don't want exception behavior to differ between dev and prod.\r\n    // (Rendering will throw with a helpful message and as soon as the type is\r\n    // fixed, the key warnings will appear.)\r\n\r\n\r\n    if (validType) {\r\n      var children = props.children;\r\n\r\n      if (children !== undefined) {\r\n        if (isStaticChildren) {\r\n          if (isArray(children)) {\r\n            for (var i = 0; i < children.length; i++) {\r\n              validateChildKeys(children[i], type);\r\n            }\r\n\r\n            if (Object.freeze) {\r\n              Object.freeze(children);\r\n            }\r\n          } else {\r\n            error('React.jsx: Static children should always be an array. ' + 'You are likely explicitly calling React.jsxs or React.jsxDEV. ' + 'Use the Babel transform instead.');\r\n          }\r\n        } else {\r\n          validateChildKeys(children, type);\r\n        }\r\n      }\r\n    }\r\n\r\n    if (type === REACT_FRAGMENT_TYPE) {\r\n      validateFragmentProps(element);\r\n    } else {\r\n      validatePropTypes(element);\r\n    }\r\n\r\n    return element;\r\n  }\r\n} // These two functions exist to still get child warnings in dev\r\n// even with the prod transform. This means that jsxDEV is purely\r\n// opt-in behavior for better messages but that we won't stop\r\n// giving you warnings if you use production apis.\r\n\r\nfunction jsxWithValidationStatic(type, props, key) {\r\n  {\r\n    return jsxWithValidation(type, props, key, true);\r\n  }\r\n}\r\nfunction jsxWithValidationDynamic(type, props, key) {\r\n  {\r\n    return jsxWithValidation(type, props, key, false);\r\n  }\r\n}\r\n\r\nvar jsx =  jsxWithValidationDynamic ; // we may want to special case jsxs internally to take advantage of static children.\r\n// for now we can ship identical prod functions\r\n\r\nvar jsxs =  jsxWithValidationStatic ;\r\n\r\nexports.Fragment = REACT_FRAGMENT_TYPE;\r\nexports.jsx = jsx;\r\nexports.jsxs = jsxs;\r\n  })();\r\n}\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVhY3QvY2pzL3JlYWN0LWpzeC1ydW50aW1lLmRldmVsb3BtZW50LmpzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ2E7QUFDYjtBQUNBLElBQUksSUFBcUM7QUFDekM7QUFDQTtBQUNBO0FBQ0EsWUFBWSxtQkFBTyxDQUFDLDRDQUFPO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlHQUFpRyxlQUFlO0FBQ2hIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssR0FBRztBQUNSO0FBQ0Esa0RBQWtEO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBLHFDQUFxQztBQUNyQztBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBLFNBQVM7QUFDVCx1QkFBdUI7QUFDdkI7QUFDQSxTQUFTO0FBQ1QsdUJBQXVCO0FBQ3ZCO0FBQ0EsU0FBUztBQUNULHdCQUF3QjtBQUN4QjtBQUNBLFNBQVM7QUFDVCx3QkFBd0I7QUFDeEI7QUFDQSxTQUFTO0FBQ1QsaUNBQWlDO0FBQ2pDO0FBQ0EsU0FBUztBQUNULDJCQUEyQjtBQUMzQjtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRDtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlEO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxrQkFBa0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdGQUFnRjtBQUNoRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJIQUEySDtBQUMzSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9FQUFvRTtBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsR0FBRztBQUNkLFdBQVcsR0FBRztBQUNkLFdBQVcsR0FBRztBQUNkLFdBQVcsZUFBZTtBQUMxQixXQUFXLEdBQUc7QUFDZCxXQUFXLEdBQUc7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsR0FBRztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxHQUFHO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxHQUFHO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsR0FBRztBQUNkLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCLDJEQUEyRCxVQUFVO0FBQ3JFLHlCQUF5QixVQUFVO0FBQ25DO0FBQ0EsYUFBYSxVQUFVO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEIsWUFBWSxTQUFTO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxjQUFjO0FBQ3pCLFdBQVcsR0FBRztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZEO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFdBQVc7QUFDdEIsV0FBVyxHQUFHO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsaUJBQWlCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxjQUFjO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sNENBQTRDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxjQUFjO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGlCQUFpQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQ7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHFCQUFxQjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQixXQUFXO0FBQ1gsWUFBWTtBQUNaLEdBQUc7QUFDSCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvcmVhY3QvY2pzL3JlYWN0LWpzeC1ydW50aW1lLmRldmVsb3BtZW50LmpzPzJmYzAiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXHJcbiAqIEBsaWNlbnNlIFJlYWN0XHJcbiAqIHJlYWN0LWpzeC1ydW50aW1lLmRldmVsb3BtZW50LmpzXHJcbiAqXHJcbiAqIENvcHlyaWdodCAoYykgRmFjZWJvb2ssIEluYy4gYW5kIGl0cyBhZmZpbGlhdGVzLlxyXG4gKlxyXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcclxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxyXG4gKi9cclxuXHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcclxuICAoZnVuY3Rpb24oKSB7XHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciBSZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XHJcblxyXG4vLyBBVFRFTlRJT05cclxuLy8gV2hlbiBhZGRpbmcgbmV3IHN5bWJvbHMgdG8gdGhpcyBmaWxlLFxyXG4vLyBQbGVhc2UgY29uc2lkZXIgYWxzbyBhZGRpbmcgdG8gJ3JlYWN0LWRldnRvb2xzLXNoYXJlZC9zcmMvYmFja2VuZC9SZWFjdFN5bWJvbHMnXHJcbi8vIFRoZSBTeW1ib2wgdXNlZCB0byB0YWcgdGhlIFJlYWN0RWxlbWVudC1saWtlIHR5cGVzLlxyXG52YXIgUkVBQ1RfRUxFTUVOVF9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QuZWxlbWVudCcpO1xyXG52YXIgUkVBQ1RfUE9SVEFMX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5wb3J0YWwnKTtcclxudmFyIFJFQUNUX0ZSQUdNRU5UX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5mcmFnbWVudCcpO1xyXG52YXIgUkVBQ1RfU1RSSUNUX01PREVfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LnN0cmljdF9tb2RlJyk7XHJcbnZhciBSRUFDVF9QUk9GSUxFUl9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QucHJvZmlsZXInKTtcclxudmFyIFJFQUNUX1BST1ZJREVSX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5wcm92aWRlcicpO1xyXG52YXIgUkVBQ1RfQ09OVEVYVF9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QuY29udGV4dCcpO1xyXG52YXIgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmZvcndhcmRfcmVmJyk7XHJcbnZhciBSRUFDVF9TVVNQRU5TRV9UWVBFID0gU3ltYm9sLmZvcigncmVhY3Quc3VzcGVuc2UnKTtcclxudmFyIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LnN1c3BlbnNlX2xpc3QnKTtcclxudmFyIFJFQUNUX01FTU9fVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0Lm1lbW8nKTtcclxudmFyIFJFQUNUX0xBWllfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmxhenknKTtcclxudmFyIFJFQUNUX09GRlNDUkVFTl9UWVBFID0gU3ltYm9sLmZvcigncmVhY3Qub2Zmc2NyZWVuJyk7XHJcbnZhciBNQVlCRV9JVEVSQVRPUl9TWU1CT0wgPSBTeW1ib2wuaXRlcmF0b3I7XHJcbnZhciBGQVVYX0lURVJBVE9SX1NZTUJPTCA9ICdAQGl0ZXJhdG9yJztcclxuZnVuY3Rpb24gZ2V0SXRlcmF0b3JGbihtYXliZUl0ZXJhYmxlKSB7XHJcbiAgaWYgKG1heWJlSXRlcmFibGUgPT09IG51bGwgfHwgdHlwZW9mIG1heWJlSXRlcmFibGUgIT09ICdvYmplY3QnKSB7XHJcbiAgICByZXR1cm4gbnVsbDtcclxuICB9XHJcblxyXG4gIHZhciBtYXliZUl0ZXJhdG9yID0gTUFZQkVfSVRFUkFUT1JfU1lNQk9MICYmIG1heWJlSXRlcmFibGVbTUFZQkVfSVRFUkFUT1JfU1lNQk9MXSB8fCBtYXliZUl0ZXJhYmxlW0ZBVVhfSVRFUkFUT1JfU1lNQk9MXTtcclxuXHJcbiAgaWYgKHR5cGVvZiBtYXliZUl0ZXJhdG9yID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICByZXR1cm4gbWF5YmVJdGVyYXRvcjtcclxuICB9XHJcblxyXG4gIHJldHVybiBudWxsO1xyXG59XHJcblxyXG52YXIgUmVhY3RTaGFyZWRJbnRlcm5hbHMgPSBSZWFjdC5fX1NFQ1JFVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9ZT1VfV0lMTF9CRV9GSVJFRDtcclxuXHJcbmZ1bmN0aW9uIGVycm9yKGZvcm1hdCkge1xyXG4gIHtcclxuICAgIHtcclxuICAgICAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4yID4gMSA/IF9sZW4yIC0gMSA6IDApLCBfa2V5MiA9IDE7IF9rZXkyIDwgX2xlbjI7IF9rZXkyKyspIHtcclxuICAgICAgICBhcmdzW19rZXkyIC0gMV0gPSBhcmd1bWVudHNbX2tleTJdO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBwcmludFdhcm5pbmcoJ2Vycm9yJywgZm9ybWF0LCBhcmdzKTtcclxuICAgIH1cclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHByaW50V2FybmluZyhsZXZlbCwgZm9ybWF0LCBhcmdzKSB7XHJcbiAgLy8gV2hlbiBjaGFuZ2luZyB0aGlzIGxvZ2ljLCB5b3UgbWlnaHQgd2FudCB0byBhbHNvXHJcbiAgLy8gdXBkYXRlIGNvbnNvbGVXaXRoU3RhY2tEZXYud3d3LmpzIGFzIHdlbGwuXHJcbiAge1xyXG4gICAgdmFyIFJlYWN0RGVidWdDdXJyZW50RnJhbWUgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdERlYnVnQ3VycmVudEZyYW1lO1xyXG4gICAgdmFyIHN0YWNrID0gUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5nZXRTdGFja0FkZGVuZHVtKCk7XHJcblxyXG4gICAgaWYgKHN0YWNrICE9PSAnJykge1xyXG4gICAgICBmb3JtYXQgKz0gJyVzJztcclxuICAgICAgYXJncyA9IGFyZ3MuY29uY2F0KFtzdGFja10pO1xyXG4gICAgfSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvc2FmZS1zdHJpbmctY29lcmNpb25cclxuXHJcblxyXG4gICAgdmFyIGFyZ3NXaXRoRm9ybWF0ID0gYXJncy5tYXAoZnVuY3Rpb24gKGl0ZW0pIHtcclxuICAgICAgcmV0dXJuIFN0cmluZyhpdGVtKTtcclxuICAgIH0pOyAvLyBDYXJlZnVsOiBSTiBjdXJyZW50bHkgZGVwZW5kcyBvbiB0aGlzIHByZWZpeFxyXG5cclxuICAgIGFyZ3NXaXRoRm9ybWF0LnVuc2hpZnQoJ1dhcm5pbmc6ICcgKyBmb3JtYXQpOyAvLyBXZSBpbnRlbnRpb25hbGx5IGRvbid0IHVzZSBzcHJlYWQgKG9yIC5hcHBseSkgZGlyZWN0bHkgYmVjYXVzZSBpdFxyXG4gICAgLy8gYnJlYWtzIElFOTogaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xMzYxMFxyXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZ1xyXG5cclxuICAgIEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseS5jYWxsKGNvbnNvbGVbbGV2ZWxdLCBjb25zb2xlLCBhcmdzV2l0aEZvcm1hdCk7XHJcbiAgfVxyXG59XHJcblxyXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG5cclxudmFyIGVuYWJsZVNjb3BlQVBJID0gZmFsc2U7IC8vIEV4cGVyaW1lbnRhbCBDcmVhdGUgRXZlbnQgSGFuZGxlIEFQSS5cclxudmFyIGVuYWJsZUNhY2hlRWxlbWVudCA9IGZhbHNlO1xyXG52YXIgZW5hYmxlVHJhbnNpdGlvblRyYWNpbmcgPSBmYWxzZTsgLy8gTm8ga25vd24gYnVncywgYnV0IG5lZWRzIHBlcmZvcm1hbmNlIHRlc3RpbmdcclxuXHJcbnZhciBlbmFibGVMZWdhY3lIaWRkZW4gPSBmYWxzZTsgLy8gRW5hYmxlcyB1bnN0YWJsZV9hdm9pZFRoaXNGYWxsYmFjayBmZWF0dXJlIGluIEZpYmVyXHJcbi8vIHN0dWZmLiBJbnRlbmRlZCB0byBlbmFibGUgUmVhY3QgY29yZSBtZW1iZXJzIHRvIG1vcmUgZWFzaWx5IGRlYnVnIHNjaGVkdWxpbmdcclxuLy8gaXNzdWVzIGluIERFViBidWlsZHMuXHJcblxyXG52YXIgZW5hYmxlRGVidWdUcmFjaW5nID0gZmFsc2U7IC8vIFRyYWNrIHdoaWNoIEZpYmVyKHMpIHNjaGVkdWxlIHJlbmRlciB3b3JrLlxyXG5cclxudmFyIFJFQUNUX01PRFVMRV9SRUZFUkVOQ0U7XHJcblxyXG57XHJcbiAgUkVBQ1RfTU9EVUxFX1JFRkVSRU5DRSA9IFN5bWJvbC5mb3IoJ3JlYWN0Lm1vZHVsZS5yZWZlcmVuY2UnKTtcclxufVxyXG5cclxuZnVuY3Rpb24gaXNWYWxpZEVsZW1lbnRUeXBlKHR5cGUpIHtcclxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICByZXR1cm4gdHJ1ZTtcclxuICB9IC8vIE5vdGU6IHR5cGVvZiBtaWdodCBiZSBvdGhlciB0aGFuICdzeW1ib2wnIG9yICdudW1iZXInIChlLmcuIGlmIGl0J3MgYSBwb2x5ZmlsbCkuXHJcblxyXG5cclxuICBpZiAodHlwZSA9PT0gUkVBQ1RfRlJBR01FTlRfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9QUk9GSUxFUl9UWVBFIHx8IGVuYWJsZURlYnVnVHJhY2luZyAgfHwgdHlwZSA9PT0gUkVBQ1RfU1RSSUNUX01PREVfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9TVVNQRU5TRV9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRSB8fCBlbmFibGVMZWdhY3lIaWRkZW4gIHx8IHR5cGUgPT09IFJFQUNUX09GRlNDUkVFTl9UWVBFIHx8IGVuYWJsZVNjb3BlQVBJICB8fCBlbmFibGVDYWNoZUVsZW1lbnQgIHx8IGVuYWJsZVRyYW5zaXRpb25UcmFjaW5nICkge1xyXG4gICAgcmV0dXJuIHRydWU7XHJcbiAgfVxyXG5cclxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdvYmplY3QnICYmIHR5cGUgIT09IG51bGwpIHtcclxuICAgIGlmICh0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9MQVpZX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfTUVNT19UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX1BST1ZJREVSX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfQ09OVEVYVF9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgfHwgLy8gVGhpcyBuZWVkcyB0byBpbmNsdWRlIGFsbCBwb3NzaWJsZSBtb2R1bGUgcmVmZXJlbmNlIG9iamVjdFxyXG4gICAgLy8gdHlwZXMgc3VwcG9ydGVkIGJ5IGFueSBGbGlnaHQgY29uZmlndXJhdGlvbiBhbnl3aGVyZSBzaW5jZVxyXG4gICAgLy8gd2UgZG9uJ3Qga25vdyB3aGljaCBGbGlnaHQgYnVpbGQgdGhpcyB3aWxsIGVuZCB1cCBiZWluZyB1c2VkXHJcbiAgICAvLyB3aXRoLlxyXG4gICAgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfTU9EVUxFX1JFRkVSRU5DRSB8fCB0eXBlLmdldE1vZHVsZUlkICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICByZXR1cm4gZmFsc2U7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGdldFdyYXBwZWROYW1lKG91dGVyVHlwZSwgaW5uZXJUeXBlLCB3cmFwcGVyTmFtZSkge1xyXG4gIHZhciBkaXNwbGF5TmFtZSA9IG91dGVyVHlwZS5kaXNwbGF5TmFtZTtcclxuXHJcbiAgaWYgKGRpc3BsYXlOYW1lKSB7XHJcbiAgICByZXR1cm4gZGlzcGxheU5hbWU7XHJcbiAgfVxyXG5cclxuICB2YXIgZnVuY3Rpb25OYW1lID0gaW5uZXJUeXBlLmRpc3BsYXlOYW1lIHx8IGlubmVyVHlwZS5uYW1lIHx8ICcnO1xyXG4gIHJldHVybiBmdW5jdGlvbk5hbWUgIT09ICcnID8gd3JhcHBlck5hbWUgKyBcIihcIiArIGZ1bmN0aW9uTmFtZSArIFwiKVwiIDogd3JhcHBlck5hbWU7XHJcbn0gLy8gS2VlcCBpbiBzeW5jIHdpdGggcmVhY3QtcmVjb25jaWxlci9nZXRDb21wb25lbnROYW1lRnJvbUZpYmVyXHJcblxyXG5cclxuZnVuY3Rpb24gZ2V0Q29udGV4dE5hbWUodHlwZSkge1xyXG4gIHJldHVybiB0eXBlLmRpc3BsYXlOYW1lIHx8ICdDb250ZXh0JztcclxufSAvLyBOb3RlIHRoYXQgdGhlIHJlY29uY2lsZXIgcGFja2FnZSBzaG91bGQgZ2VuZXJhbGx5IHByZWZlciB0byB1c2UgZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcigpIGluc3RlYWQuXHJcblxyXG5cclxuZnVuY3Rpb24gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpIHtcclxuICBpZiAodHlwZSA9PSBudWxsKSB7XHJcbiAgICAvLyBIb3N0IHJvb3QsIHRleHQgbm9kZSBvciBqdXN0IGludmFsaWQgdHlwZS5cclxuICAgIHJldHVybiBudWxsO1xyXG4gIH1cclxuXHJcbiAge1xyXG4gICAgaWYgKHR5cGVvZiB0eXBlLnRhZyA9PT0gJ251bWJlcicpIHtcclxuICAgICAgZXJyb3IoJ1JlY2VpdmVkIGFuIHVuZXhwZWN0ZWQgb2JqZWN0IGluIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSgpLiAnICsgJ1RoaXMgaXMgbGlrZWx5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgcmV0dXJuIHR5cGUuZGlzcGxheU5hbWUgfHwgdHlwZS5uYW1lIHx8IG51bGw7XHJcbiAgfVxyXG5cclxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnKSB7XHJcbiAgICByZXR1cm4gdHlwZTtcclxuICB9XHJcblxyXG4gIHN3aXRjaCAodHlwZSkge1xyXG4gICAgY2FzZSBSRUFDVF9GUkFHTUVOVF9UWVBFOlxyXG4gICAgICByZXR1cm4gJ0ZyYWdtZW50JztcclxuXHJcbiAgICBjYXNlIFJFQUNUX1BPUlRBTF9UWVBFOlxyXG4gICAgICByZXR1cm4gJ1BvcnRhbCc7XHJcblxyXG4gICAgY2FzZSBSRUFDVF9QUk9GSUxFUl9UWVBFOlxyXG4gICAgICByZXR1cm4gJ1Byb2ZpbGVyJztcclxuXHJcbiAgICBjYXNlIFJFQUNUX1NUUklDVF9NT0RFX1RZUEU6XHJcbiAgICAgIHJldHVybiAnU3RyaWN0TW9kZSc7XHJcblxyXG4gICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9UWVBFOlxyXG4gICAgICByZXR1cm4gJ1N1c3BlbnNlJztcclxuXHJcbiAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRTpcclxuICAgICAgcmV0dXJuICdTdXNwZW5zZUxpc3QnO1xyXG5cclxuICB9XHJcblxyXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcpIHtcclxuICAgIHN3aXRjaCAodHlwZS4kJHR5cGVvZikge1xyXG4gICAgICBjYXNlIFJFQUNUX0NPTlRFWFRfVFlQRTpcclxuICAgICAgICB2YXIgY29udGV4dCA9IHR5cGU7XHJcbiAgICAgICAgcmV0dXJuIGdldENvbnRleHROYW1lKGNvbnRleHQpICsgJy5Db25zdW1lcic7XHJcblxyXG4gICAgICBjYXNlIFJFQUNUX1BST1ZJREVSX1RZUEU6XHJcbiAgICAgICAgdmFyIHByb3ZpZGVyID0gdHlwZTtcclxuICAgICAgICByZXR1cm4gZ2V0Q29udGV4dE5hbWUocHJvdmlkZXIuX2NvbnRleHQpICsgJy5Qcm92aWRlcic7XHJcblxyXG4gICAgICBjYXNlIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEU6XHJcbiAgICAgICAgcmV0dXJuIGdldFdyYXBwZWROYW1lKHR5cGUsIHR5cGUucmVuZGVyLCAnRm9yd2FyZFJlZicpO1xyXG5cclxuICAgICAgY2FzZSBSRUFDVF9NRU1PX1RZUEU6XHJcbiAgICAgICAgdmFyIG91dGVyTmFtZSA9IHR5cGUuZGlzcGxheU5hbWUgfHwgbnVsbDtcclxuXHJcbiAgICAgICAgaWYgKG91dGVyTmFtZSAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgcmV0dXJuIG91dGVyTmFtZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZS50eXBlKSB8fCAnTWVtbyc7XHJcblxyXG4gICAgICBjYXNlIFJFQUNUX0xBWllfVFlQRTpcclxuICAgICAgICB7XHJcbiAgICAgICAgICB2YXIgbGF6eUNvbXBvbmVudCA9IHR5cGU7XHJcbiAgICAgICAgICB2YXIgcGF5bG9hZCA9IGxhenlDb21wb25lbnQuX3BheWxvYWQ7XHJcbiAgICAgICAgICB2YXIgaW5pdCA9IGxhenlDb21wb25lbnQuX2luaXQ7XHJcblxyXG4gICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgcmV0dXJuIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShpbml0KHBheWxvYWQpKTtcclxuICAgICAgICAgIH0gY2F0Y2ggKHgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWZhbGx0aHJvdWdoXHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICByZXR1cm4gbnVsbDtcclxufVxyXG5cclxudmFyIGFzc2lnbiA9IE9iamVjdC5hc3NpZ247XHJcblxyXG4vLyBIZWxwZXJzIHRvIHBhdGNoIGNvbnNvbGUubG9ncyB0byBhdm9pZCBsb2dnaW5nIGR1cmluZyBzaWRlLWVmZmVjdCBmcmVlXHJcbi8vIHJlcGxheWluZyBvbiByZW5kZXIgZnVuY3Rpb24uIFRoaXMgY3VycmVudGx5IG9ubHkgcGF0Y2hlcyB0aGUgb2JqZWN0XHJcbi8vIGxhemlseSB3aGljaCB3b24ndCBjb3ZlciBpZiB0aGUgbG9nIGZ1bmN0aW9uIHdhcyBleHRyYWN0ZWQgZWFnZXJseS5cclxuLy8gV2UgY291bGQgYWxzbyBlYWdlcmx5IHBhdGNoIHRoZSBtZXRob2QuXHJcbnZhciBkaXNhYmxlZERlcHRoID0gMDtcclxudmFyIHByZXZMb2c7XHJcbnZhciBwcmV2SW5mbztcclxudmFyIHByZXZXYXJuO1xyXG52YXIgcHJldkVycm9yO1xyXG52YXIgcHJldkdyb3VwO1xyXG52YXIgcHJldkdyb3VwQ29sbGFwc2VkO1xyXG52YXIgcHJldkdyb3VwRW5kO1xyXG5cclxuZnVuY3Rpb24gZGlzYWJsZWRMb2coKSB7fVxyXG5cclxuZGlzYWJsZWRMb2cuX19yZWFjdERpc2FibGVkTG9nID0gdHJ1ZTtcclxuZnVuY3Rpb24gZGlzYWJsZUxvZ3MoKSB7XHJcbiAge1xyXG4gICAgaWYgKGRpc2FibGVkRGVwdGggPT09IDApIHtcclxuICAgICAgLyogZXNsaW50LWRpc2FibGUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nICovXHJcbiAgICAgIHByZXZMb2cgPSBjb25zb2xlLmxvZztcclxuICAgICAgcHJldkluZm8gPSBjb25zb2xlLmluZm87XHJcbiAgICAgIHByZXZXYXJuID0gY29uc29sZS53YXJuO1xyXG4gICAgICBwcmV2RXJyb3IgPSBjb25zb2xlLmVycm9yO1xyXG4gICAgICBwcmV2R3JvdXAgPSBjb25zb2xlLmdyb3VwO1xyXG4gICAgICBwcmV2R3JvdXBDb2xsYXBzZWQgPSBjb25zb2xlLmdyb3VwQ29sbGFwc2VkO1xyXG4gICAgICBwcmV2R3JvdXBFbmQgPSBjb25zb2xlLmdyb3VwRW5kOyAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzE5MDk5XHJcblxyXG4gICAgICB2YXIgcHJvcHMgPSB7XHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgdmFsdWU6IGRpc2FibGVkTG9nLFxyXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlXHJcbiAgICAgIH07IC8vICRGbG93Rml4TWUgRmxvdyB0aGlua3MgY29uc29sZSBpcyBpbW11dGFibGUuXHJcblxyXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhjb25zb2xlLCB7XHJcbiAgICAgICAgaW5mbzogcHJvcHMsXHJcbiAgICAgICAgbG9nOiBwcm9wcyxcclxuICAgICAgICB3YXJuOiBwcm9wcyxcclxuICAgICAgICBlcnJvcjogcHJvcHMsXHJcbiAgICAgICAgZ3JvdXA6IHByb3BzLFxyXG4gICAgICAgIGdyb3VwQ29sbGFwc2VkOiBwcm9wcyxcclxuICAgICAgICBncm91cEVuZDogcHJvcHNcclxuICAgICAgfSk7XHJcbiAgICAgIC8qIGVzbGludC1lbmFibGUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nICovXHJcbiAgICB9XHJcblxyXG4gICAgZGlzYWJsZWREZXB0aCsrO1xyXG4gIH1cclxufVxyXG5mdW5jdGlvbiByZWVuYWJsZUxvZ3MoKSB7XHJcbiAge1xyXG4gICAgZGlzYWJsZWREZXB0aC0tO1xyXG5cclxuICAgIGlmIChkaXNhYmxlZERlcHRoID09PSAwKSB7XHJcbiAgICAgIC8qIGVzbGludC1kaXNhYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xyXG4gICAgICB2YXIgcHJvcHMgPSB7XHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgd3JpdGFibGU6IHRydWVcclxuICAgICAgfTsgLy8gJEZsb3dGaXhNZSBGbG93IHRoaW5rcyBjb25zb2xlIGlzIGltbXV0YWJsZS5cclxuXHJcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGNvbnNvbGUsIHtcclxuICAgICAgICBsb2c6IGFzc2lnbih7fSwgcHJvcHMsIHtcclxuICAgICAgICAgIHZhbHVlOiBwcmV2TG9nXHJcbiAgICAgICAgfSksXHJcbiAgICAgICAgaW5mbzogYXNzaWduKHt9LCBwcm9wcywge1xyXG4gICAgICAgICAgdmFsdWU6IHByZXZJbmZvXHJcbiAgICAgICAgfSksXHJcbiAgICAgICAgd2FybjogYXNzaWduKHt9LCBwcm9wcywge1xyXG4gICAgICAgICAgdmFsdWU6IHByZXZXYXJuXHJcbiAgICAgICAgfSksXHJcbiAgICAgICAgZXJyb3I6IGFzc2lnbih7fSwgcHJvcHMsIHtcclxuICAgICAgICAgIHZhbHVlOiBwcmV2RXJyb3JcclxuICAgICAgICB9KSxcclxuICAgICAgICBncm91cDogYXNzaWduKHt9LCBwcm9wcywge1xyXG4gICAgICAgICAgdmFsdWU6IHByZXZHcm91cFxyXG4gICAgICAgIH0pLFxyXG4gICAgICAgIGdyb3VwQ29sbGFwc2VkOiBhc3NpZ24oe30sIHByb3BzLCB7XHJcbiAgICAgICAgICB2YWx1ZTogcHJldkdyb3VwQ29sbGFwc2VkXHJcbiAgICAgICAgfSksXHJcbiAgICAgICAgZ3JvdXBFbmQ6IGFzc2lnbih7fSwgcHJvcHMsIHtcclxuICAgICAgICAgIHZhbHVlOiBwcmV2R3JvdXBFbmRcclxuICAgICAgICB9KVxyXG4gICAgICB9KTtcclxuICAgICAgLyogZXNsaW50LWVuYWJsZSByZWFjdC1pbnRlcm5hbC9uby1wcm9kdWN0aW9uLWxvZ2dpbmcgKi9cclxuICAgIH1cclxuXHJcbiAgICBpZiAoZGlzYWJsZWREZXB0aCA8IDApIHtcclxuICAgICAgZXJyb3IoJ2Rpc2FibGVkRGVwdGggZmVsbCBiZWxvdyB6ZXJvLiAnICsgJ1RoaXMgaXMgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxudmFyIFJlYWN0Q3VycmVudERpc3BhdGNoZXIgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdEN1cnJlbnREaXNwYXRjaGVyO1xyXG52YXIgcHJlZml4O1xyXG5mdW5jdGlvbiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZShuYW1lLCBzb3VyY2UsIG93bmVyRm4pIHtcclxuICB7XHJcbiAgICBpZiAocHJlZml4ID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgLy8gRXh0cmFjdCB0aGUgVk0gc3BlY2lmaWMgcHJlZml4IHVzZWQgYnkgZWFjaCBsaW5lLlxyXG4gICAgICB0cnkge1xyXG4gICAgICAgIHRocm93IEVycm9yKCk7XHJcbiAgICAgIH0gY2F0Y2ggKHgpIHtcclxuICAgICAgICB2YXIgbWF0Y2ggPSB4LnN0YWNrLnRyaW0oKS5tYXRjaCgvXFxuKCAqKGF0ICk/KS8pO1xyXG4gICAgICAgIHByZWZpeCA9IG1hdGNoICYmIG1hdGNoWzFdIHx8ICcnO1xyXG4gICAgICB9XHJcbiAgICB9IC8vIFdlIHVzZSB0aGUgcHJlZml4IHRvIGVuc3VyZSBvdXIgc3RhY2tzIGxpbmUgdXAgd2l0aCBuYXRpdmUgc3RhY2sgZnJhbWVzLlxyXG5cclxuXHJcbiAgICByZXR1cm4gJ1xcbicgKyBwcmVmaXggKyBuYW1lO1xyXG4gIH1cclxufVxyXG52YXIgcmVlbnRyeSA9IGZhbHNlO1xyXG52YXIgY29tcG9uZW50RnJhbWVDYWNoZTtcclxuXHJcbntcclxuICB2YXIgUG9zc2libHlXZWFrTWFwID0gdHlwZW9mIFdlYWtNYXAgPT09ICdmdW5jdGlvbicgPyBXZWFrTWFwIDogTWFwO1xyXG4gIGNvbXBvbmVudEZyYW1lQ2FjaGUgPSBuZXcgUG9zc2libHlXZWFrTWFwKCk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUoZm4sIGNvbnN0cnVjdCkge1xyXG4gIC8vIElmIHNvbWV0aGluZyBhc2tlZCBmb3IgYSBzdGFjayBpbnNpZGUgYSBmYWtlIHJlbmRlciwgaXQgc2hvdWxkIGdldCBpZ25vcmVkLlxyXG4gIGlmICggIWZuIHx8IHJlZW50cnkpIHtcclxuICAgIHJldHVybiAnJztcclxuICB9XHJcblxyXG4gIHtcclxuICAgIHZhciBmcmFtZSA9IGNvbXBvbmVudEZyYW1lQ2FjaGUuZ2V0KGZuKTtcclxuXHJcbiAgICBpZiAoZnJhbWUgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICByZXR1cm4gZnJhbWU7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICB2YXIgY29udHJvbDtcclxuICByZWVudHJ5ID0gdHJ1ZTtcclxuICB2YXIgcHJldmlvdXNQcmVwYXJlU3RhY2tUcmFjZSA9IEVycm9yLnByZXBhcmVTdGFja1RyYWNlOyAvLyAkRmxvd0ZpeE1lIEl0IGRvZXMgYWNjZXB0IHVuZGVmaW5lZC5cclxuXHJcbiAgRXJyb3IucHJlcGFyZVN0YWNrVHJhY2UgPSB1bmRlZmluZWQ7XHJcbiAgdmFyIHByZXZpb3VzRGlzcGF0Y2hlcjtcclxuXHJcbiAge1xyXG4gICAgcHJldmlvdXNEaXNwYXRjaGVyID0gUmVhY3RDdXJyZW50RGlzcGF0Y2hlci5jdXJyZW50OyAvLyBTZXQgdGhlIGRpc3BhdGNoZXIgaW4gREVWIGJlY2F1c2UgdGhpcyBtaWdodCBiZSBjYWxsIGluIHRoZSByZW5kZXIgZnVuY3Rpb25cclxuICAgIC8vIGZvciB3YXJuaW5ncy5cclxuXHJcbiAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyLmN1cnJlbnQgPSBudWxsO1xyXG4gICAgZGlzYWJsZUxvZ3MoKTtcclxuICB9XHJcblxyXG4gIHRyeSB7XHJcbiAgICAvLyBUaGlzIHNob3VsZCB0aHJvdy5cclxuICAgIGlmIChjb25zdHJ1Y3QpIHtcclxuICAgICAgLy8gU29tZXRoaW5nIHNob3VsZCBiZSBzZXR0aW5nIHRoZSBwcm9wcyBpbiB0aGUgY29uc3RydWN0b3IuXHJcbiAgICAgIHZhciBGYWtlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRocm93IEVycm9yKCk7XHJcbiAgICAgIH07IC8vICRGbG93Rml4TWVcclxuXHJcblxyXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRmFrZS5wcm90b3R5cGUsICdwcm9wcycsIHtcclxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgIC8vIFdlIHVzZSBhIHRocm93aW5nIHNldHRlciBpbnN0ZWFkIG9mIGZyb3plbiBvciBub24td3JpdGFibGUgcHJvcHNcclxuICAgICAgICAgIC8vIGJlY2F1c2UgdGhhdCB3b24ndCB0aHJvdyBpbiBhIG5vbi1zdHJpY3QgbW9kZSBmdW5jdGlvbi5cclxuICAgICAgICAgIHRocm93IEVycm9yKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gJ29iamVjdCcgJiYgUmVmbGVjdC5jb25zdHJ1Y3QpIHtcclxuICAgICAgICAvLyBXZSBjb25zdHJ1Y3QgYSBkaWZmZXJlbnQgY29udHJvbCBmb3IgdGhpcyBjYXNlIHRvIGluY2x1ZGUgYW55IGV4dHJhXHJcbiAgICAgICAgLy8gZnJhbWVzIGFkZGVkIGJ5IHRoZSBjb25zdHJ1Y3QgY2FsbC5cclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgUmVmbGVjdC5jb25zdHJ1Y3QoRmFrZSwgW10pO1xyXG4gICAgICAgIH0gY2F0Y2ggKHgpIHtcclxuICAgICAgICAgIGNvbnRyb2wgPSB4O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgUmVmbGVjdC5jb25zdHJ1Y3QoZm4sIFtdLCBGYWtlKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgRmFrZS5jYWxsKCk7XHJcbiAgICAgICAgfSBjYXRjaCAoeCkge1xyXG4gICAgICAgICAgY29udHJvbCA9IHg7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmbi5jYWxsKEZha2UucHJvdG90eXBlKTtcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdHJ5IHtcclxuICAgICAgICB0aHJvdyBFcnJvcigpO1xyXG4gICAgICB9IGNhdGNoICh4KSB7XHJcbiAgICAgICAgY29udHJvbCA9IHg7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGZuKCk7XHJcbiAgICB9XHJcbiAgfSBjYXRjaCAoc2FtcGxlKSB7XHJcbiAgICAvLyBUaGlzIGlzIGlubGluZWQgbWFudWFsbHkgYmVjYXVzZSBjbG9zdXJlIGRvZXNuJ3QgZG8gaXQgZm9yIHVzLlxyXG4gICAgaWYgKHNhbXBsZSAmJiBjb250cm9sICYmIHR5cGVvZiBzYW1wbGUuc3RhY2sgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgIC8vIFRoaXMgZXh0cmFjdHMgdGhlIGZpcnN0IGZyYW1lIGZyb20gdGhlIHNhbXBsZSB0aGF0IGlzbid0IGFsc28gaW4gdGhlIGNvbnRyb2wuXHJcbiAgICAgIC8vIFNraXBwaW5nIG9uZSBmcmFtZSB0aGF0IHdlIGFzc3VtZSBpcyB0aGUgZnJhbWUgdGhhdCBjYWxscyB0aGUgdHdvLlxyXG4gICAgICB2YXIgc2FtcGxlTGluZXMgPSBzYW1wbGUuc3RhY2suc3BsaXQoJ1xcbicpO1xyXG4gICAgICB2YXIgY29udHJvbExpbmVzID0gY29udHJvbC5zdGFjay5zcGxpdCgnXFxuJyk7XHJcbiAgICAgIHZhciBzID0gc2FtcGxlTGluZXMubGVuZ3RoIC0gMTtcclxuICAgICAgdmFyIGMgPSBjb250cm9sTGluZXMubGVuZ3RoIC0gMTtcclxuXHJcbiAgICAgIHdoaWxlIChzID49IDEgJiYgYyA+PSAwICYmIHNhbXBsZUxpbmVzW3NdICE9PSBjb250cm9sTGluZXNbY10pIHtcclxuICAgICAgICAvLyBXZSBleHBlY3QgYXQgbGVhc3Qgb25lIHN0YWNrIGZyYW1lIHRvIGJlIHNoYXJlZC5cclxuICAgICAgICAvLyBUeXBpY2FsbHkgdGhpcyB3aWxsIGJlIHRoZSByb290IG1vc3Qgb25lLiBIb3dldmVyLCBzdGFjayBmcmFtZXMgbWF5IGJlXHJcbiAgICAgICAgLy8gY3V0IG9mZiBkdWUgdG8gbWF4aW11bSBzdGFjayBsaW1pdHMuIEluIHRoaXMgY2FzZSwgb25lIG1heWJlIGN1dCBvZmZcclxuICAgICAgICAvLyBlYXJsaWVyIHRoYW4gdGhlIG90aGVyLiBXZSBhc3N1bWUgdGhhdCB0aGUgc2FtcGxlIGlzIGxvbmdlciBvciB0aGUgc2FtZVxyXG4gICAgICAgIC8vIGFuZCB0aGVyZSBmb3IgY3V0IG9mZiBlYXJsaWVyLiBTbyB3ZSBzaG91bGQgZmluZCB0aGUgcm9vdCBtb3N0IGZyYW1lIGluXHJcbiAgICAgICAgLy8gdGhlIHNhbXBsZSBzb21ld2hlcmUgaW4gdGhlIGNvbnRyb2wuXHJcbiAgICAgICAgYy0tO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBmb3IgKDsgcyA+PSAxICYmIGMgPj0gMDsgcy0tLCBjLS0pIHtcclxuICAgICAgICAvLyBOZXh0IHdlIGZpbmQgdGhlIGZpcnN0IG9uZSB0aGF0IGlzbid0IHRoZSBzYW1lIHdoaWNoIHNob3VsZCBiZSB0aGVcclxuICAgICAgICAvLyBmcmFtZSB0aGF0IGNhbGxlZCBvdXIgc2FtcGxlIGZ1bmN0aW9uIGFuZCB0aGUgY29udHJvbC5cclxuICAgICAgICBpZiAoc2FtcGxlTGluZXNbc10gIT09IGNvbnRyb2xMaW5lc1tjXSkge1xyXG4gICAgICAgICAgLy8gSW4gVjgsIHRoZSBmaXJzdCBsaW5lIGlzIGRlc2NyaWJpbmcgdGhlIG1lc3NhZ2UgYnV0IG90aGVyIFZNcyBkb24ndC5cclxuICAgICAgICAgIC8vIElmIHdlJ3JlIGFib3V0IHRvIHJldHVybiB0aGUgZmlyc3QgbGluZSwgYW5kIHRoZSBjb250cm9sIGlzIGFsc28gb24gdGhlIHNhbWVcclxuICAgICAgICAgIC8vIGxpbmUsIHRoYXQncyBhIHByZXR0eSBnb29kIGluZGljYXRvciB0aGF0IG91ciBzYW1wbGUgdGhyZXcgYXQgc2FtZSBsaW5lIGFzXHJcbiAgICAgICAgICAvLyB0aGUgY29udHJvbC4gSS5lLiBiZWZvcmUgd2UgZW50ZXJlZCB0aGUgc2FtcGxlIGZyYW1lLiBTbyB3ZSBpZ25vcmUgdGhpcyByZXN1bHQuXHJcbiAgICAgICAgICAvLyBUaGlzIGNhbiBoYXBwZW4gaWYgeW91IHBhc3NlZCBhIGNsYXNzIHRvIGZ1bmN0aW9uIGNvbXBvbmVudCwgb3Igbm9uLWZ1bmN0aW9uLlxyXG4gICAgICAgICAgaWYgKHMgIT09IDEgfHwgYyAhPT0gMSkge1xyXG4gICAgICAgICAgICBkbyB7XHJcbiAgICAgICAgICAgICAgcy0tO1xyXG4gICAgICAgICAgICAgIGMtLTsgLy8gV2UgbWF5IHN0aWxsIGhhdmUgc2ltaWxhciBpbnRlcm1lZGlhdGUgZnJhbWVzIGZyb20gdGhlIGNvbnN0cnVjdCBjYWxsLlxyXG4gICAgICAgICAgICAgIC8vIFRoZSBuZXh0IG9uZSB0aGF0IGlzbid0IHRoZSBzYW1lIHNob3VsZCBiZSBvdXIgbWF0Y2ggdGhvdWdoLlxyXG5cclxuICAgICAgICAgICAgICBpZiAoYyA8IDAgfHwgc2FtcGxlTGluZXNbc10gIT09IGNvbnRyb2xMaW5lc1tjXSkge1xyXG4gICAgICAgICAgICAgICAgLy8gVjggYWRkcyBhIFwibmV3XCIgcHJlZml4IGZvciBuYXRpdmUgY2xhc3Nlcy4gTGV0J3MgcmVtb3ZlIGl0IHRvIG1ha2UgaXQgcHJldHRpZXIuXHJcbiAgICAgICAgICAgICAgICB2YXIgX2ZyYW1lID0gJ1xcbicgKyBzYW1wbGVMaW5lc1tzXS5yZXBsYWNlKCcgYXQgbmV3ICcsICcgYXQgJyk7IC8vIElmIG91ciBjb21wb25lbnQgZnJhbWUgaXMgbGFiZWxlZCBcIjxhbm9ueW1vdXM+XCJcclxuICAgICAgICAgICAgICAgIC8vIGJ1dCB3ZSBoYXZlIGEgdXNlci1wcm92aWRlZCBcImRpc3BsYXlOYW1lXCJcclxuICAgICAgICAgICAgICAgIC8vIHNwbGljZSBpdCBpbiB0byBtYWtlIHRoZSBzdGFjayBtb3JlIHJlYWRhYmxlLlxyXG5cclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoZm4uZGlzcGxheU5hbWUgJiYgX2ZyYW1lLmluY2x1ZGVzKCc8YW5vbnltb3VzPicpKSB7XHJcbiAgICAgICAgICAgICAgICAgIF9mcmFtZSA9IF9mcmFtZS5yZXBsYWNlKCc8YW5vbnltb3VzPicsIGZuLmRpc3BsYXlOYW1lKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZm4gPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb21wb25lbnRGcmFtZUNhY2hlLnNldChmbiwgX2ZyYW1lKTtcclxuICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSAvLyBSZXR1cm4gdGhlIGxpbmUgd2UgZm91bmQuXHJcblxyXG5cclxuICAgICAgICAgICAgICAgIHJldHVybiBfZnJhbWU7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IHdoaWxlIChzID49IDEgJiYgYyA+PSAwKTtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9IGZpbmFsbHkge1xyXG4gICAgcmVlbnRyeSA9IGZhbHNlO1xyXG5cclxuICAgIHtcclxuICAgICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlci5jdXJyZW50ID0gcHJldmlvdXNEaXNwYXRjaGVyO1xyXG4gICAgICByZWVuYWJsZUxvZ3MoKTtcclxuICAgIH1cclxuXHJcbiAgICBFcnJvci5wcmVwYXJlU3RhY2tUcmFjZSA9IHByZXZpb3VzUHJlcGFyZVN0YWNrVHJhY2U7XHJcbiAgfSAvLyBGYWxsYmFjayB0byBqdXN0IHVzaW5nIHRoZSBuYW1lIGlmIHdlIGNvdWxkbid0IG1ha2UgaXQgdGhyb3cuXHJcblxyXG5cclxuICB2YXIgbmFtZSA9IGZuID8gZm4uZGlzcGxheU5hbWUgfHwgZm4ubmFtZSA6ICcnO1xyXG4gIHZhciBzeW50aGV0aWNGcmFtZSA9IG5hbWUgPyBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZShuYW1lKSA6ICcnO1xyXG5cclxuICB7XHJcbiAgICBpZiAodHlwZW9mIGZuID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgIGNvbXBvbmVudEZyYW1lQ2FjaGUuc2V0KGZuLCBzeW50aGV0aWNGcmFtZSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICByZXR1cm4gc3ludGhldGljRnJhbWU7XHJcbn1cclxuZnVuY3Rpb24gZGVzY3JpYmVGdW5jdGlvbkNvbXBvbmVudEZyYW1lKGZuLCBzb3VyY2UsIG93bmVyRm4pIHtcclxuICB7XHJcbiAgICByZXR1cm4gZGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZShmbiwgZmFsc2UpO1xyXG4gIH1cclxufVxyXG5cclxuZnVuY3Rpb24gc2hvdWxkQ29uc3RydWN0KENvbXBvbmVudCkge1xyXG4gIHZhciBwcm90b3R5cGUgPSBDb21wb25lbnQucHJvdG90eXBlO1xyXG4gIHJldHVybiAhIShwcm90b3R5cGUgJiYgcHJvdG90eXBlLmlzUmVhY3RDb21wb25lbnQpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYodHlwZSwgc291cmNlLCBvd25lckZuKSB7XHJcblxyXG4gIGlmICh0eXBlID09IG51bGwpIHtcclxuICAgIHJldHVybiAnJztcclxuICB9XHJcblxyXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAge1xyXG4gICAgICByZXR1cm4gZGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZSh0eXBlLCBzaG91bGRDb25zdHJ1Y3QodHlwZSkpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJykge1xyXG4gICAgcmV0dXJuIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKHR5cGUpO1xyXG4gIH1cclxuXHJcbiAgc3dpdGNoICh0eXBlKSB7XHJcbiAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX1RZUEU6XHJcbiAgICAgIHJldHVybiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZSgnU3VzcGVuc2UnKTtcclxuXHJcbiAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRTpcclxuICAgICAgcmV0dXJuIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKCdTdXNwZW5zZUxpc3QnKTtcclxuICB9XHJcblxyXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcpIHtcclxuICAgIHN3aXRjaCAodHlwZS4kJHR5cGVvZikge1xyXG4gICAgICBjYXNlIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEU6XHJcbiAgICAgICAgcmV0dXJuIGRlc2NyaWJlRnVuY3Rpb25Db21wb25lbnRGcmFtZSh0eXBlLnJlbmRlcik7XHJcblxyXG4gICAgICBjYXNlIFJFQUNUX01FTU9fVFlQRTpcclxuICAgICAgICAvLyBNZW1vIG1heSBjb250YWluIGFueSBjb21wb25lbnQgdHlwZSBzbyB3ZSByZWN1cnNpdmVseSByZXNvbHZlIGl0LlxyXG4gICAgICAgIHJldHVybiBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYodHlwZS50eXBlLCBzb3VyY2UsIG93bmVyRm4pO1xyXG5cclxuICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XHJcbiAgICAgICAge1xyXG4gICAgICAgICAgdmFyIGxhenlDb21wb25lbnQgPSB0eXBlO1xyXG4gICAgICAgICAgdmFyIHBheWxvYWQgPSBsYXp5Q29tcG9uZW50Ll9wYXlsb2FkO1xyXG4gICAgICAgICAgdmFyIGluaXQgPSBsYXp5Q29tcG9uZW50Ll9pbml0O1xyXG5cclxuICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIC8vIExhenkgbWF5IGNvbnRhaW4gYW55IGNvbXBvbmVudCB0eXBlIHNvIHdlIHJlY3Vyc2l2ZWx5IHJlc29sdmUgaXQuXHJcbiAgICAgICAgICAgIHJldHVybiBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYoaW5pdChwYXlsb2FkKSwgc291cmNlLCBvd25lckZuKTtcclxuICAgICAgICAgIH0gY2F0Y2ggKHgpIHt9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcmV0dXJuICcnO1xyXG59XHJcblxyXG52YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xyXG5cclxudmFyIGxvZ2dlZFR5cGVGYWlsdXJlcyA9IHt9O1xyXG52YXIgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0RGVidWdDdXJyZW50RnJhbWU7XHJcblxyXG5mdW5jdGlvbiBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChlbGVtZW50KSB7XHJcbiAge1xyXG4gICAgaWYgKGVsZW1lbnQpIHtcclxuICAgICAgdmFyIG93bmVyID0gZWxlbWVudC5fb3duZXI7XHJcbiAgICAgIHZhciBzdGFjayA9IGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVihlbGVtZW50LnR5cGUsIGVsZW1lbnQuX3NvdXJjZSwgb3duZXIgPyBvd25lci50eXBlIDogbnVsbCk7XHJcbiAgICAgIFJlYWN0RGVidWdDdXJyZW50RnJhbWUuc2V0RXh0cmFTdGFja0ZyYW1lKHN0YWNrKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIFJlYWN0RGVidWdDdXJyZW50RnJhbWUuc2V0RXh0cmFTdGFja0ZyYW1lKG51bGwpO1xyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxuZnVuY3Rpb24gY2hlY2tQcm9wVHlwZXModHlwZVNwZWNzLCB2YWx1ZXMsIGxvY2F0aW9uLCBjb21wb25lbnROYW1lLCBlbGVtZW50KSB7XHJcbiAge1xyXG4gICAgLy8gJEZsb3dGaXhNZSBUaGlzIGlzIG9rYXkgYnV0IEZsb3cgZG9lc24ndCBrbm93IGl0LlxyXG4gICAgdmFyIGhhcyA9IEZ1bmN0aW9uLmNhbGwuYmluZChoYXNPd25Qcm9wZXJ0eSk7XHJcblxyXG4gICAgZm9yICh2YXIgdHlwZVNwZWNOYW1lIGluIHR5cGVTcGVjcykge1xyXG4gICAgICBpZiAoaGFzKHR5cGVTcGVjcywgdHlwZVNwZWNOYW1lKSkge1xyXG4gICAgICAgIHZhciBlcnJvciQxID0gdm9pZCAwOyAvLyBQcm9wIHR5cGUgdmFsaWRhdGlvbiBtYXkgdGhyb3cuIEluIGNhc2UgdGhleSBkbywgd2UgZG9uJ3Qgd2FudCB0b1xyXG4gICAgICAgIC8vIGZhaWwgdGhlIHJlbmRlciBwaGFzZSB3aGVyZSBpdCBkaWRuJ3QgZmFpbCBiZWZvcmUuIFNvIHdlIGxvZyBpdC5cclxuICAgICAgICAvLyBBZnRlciB0aGVzZSBoYXZlIGJlZW4gY2xlYW5lZCB1cCwgd2UnbGwgbGV0IHRoZW0gdGhyb3cuXHJcblxyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAvLyBUaGlzIGlzIGludGVudGlvbmFsbHkgYW4gaW52YXJpYW50IHRoYXQgZ2V0cyBjYXVnaHQuIEl0J3MgdGhlIHNhbWVcclxuICAgICAgICAgIC8vIGJlaGF2aW9yIGFzIHdpdGhvdXQgdGhpcyBzdGF0ZW1lbnQgZXhjZXB0IHdpdGggYSBiZXR0ZXIgbWVzc2FnZS5cclxuICAgICAgICAgIGlmICh0eXBlb2YgdHlwZVNwZWNzW3R5cGVTcGVjTmFtZV0gIT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWludGVybmFsL3Byb2QtZXJyb3ItY29kZXNcclxuICAgICAgICAgICAgdmFyIGVyciA9IEVycm9yKChjb21wb25lbnROYW1lIHx8ICdSZWFjdCBjbGFzcycpICsgJzogJyArIGxvY2F0aW9uICsgJyB0eXBlIGAnICsgdHlwZVNwZWNOYW1lICsgJ2AgaXMgaW52YWxpZDsgJyArICdpdCBtdXN0IGJlIGEgZnVuY3Rpb24sIHVzdWFsbHkgZnJvbSB0aGUgYHByb3AtdHlwZXNgIHBhY2thZ2UsIGJ1dCByZWNlaXZlZCBgJyArIHR5cGVvZiB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSArICdgLicgKyAnVGhpcyBvZnRlbiBoYXBwZW5zIGJlY2F1c2Ugb2YgdHlwb3Mgc3VjaCBhcyBgUHJvcFR5cGVzLmZ1bmN0aW9uYCBpbnN0ZWFkIG9mIGBQcm9wVHlwZXMuZnVuY2AuJyk7XHJcbiAgICAgICAgICAgIGVyci5uYW1lID0gJ0ludmFyaWFudCBWaW9sYXRpb24nO1xyXG4gICAgICAgICAgICB0aHJvdyBlcnI7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgZXJyb3IkMSA9IHR5cGVTcGVjc1t0eXBlU3BlY05hbWVdKHZhbHVlcywgdHlwZVNwZWNOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgbnVsbCwgJ1NFQ1JFVF9ET19OT1RfUEFTU19USElTX09SX1lPVV9XSUxMX0JFX0ZJUkVEJyk7XHJcbiAgICAgICAgfSBjYXRjaCAoZXgpIHtcclxuICAgICAgICAgIGVycm9yJDEgPSBleDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChlcnJvciQxICYmICEoZXJyb3IkMSBpbnN0YW5jZW9mIEVycm9yKSkge1xyXG4gICAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQoZWxlbWVudCk7XHJcblxyXG4gICAgICAgICAgZXJyb3IoJyVzOiB0eXBlIHNwZWNpZmljYXRpb24gb2YgJXMnICsgJyBgJXNgIGlzIGludmFsaWQ7IHRoZSB0eXBlIGNoZWNrZXIgJyArICdmdW5jdGlvbiBtdXN0IHJldHVybiBgbnVsbGAgb3IgYW4gYEVycm9yYCBidXQgcmV0dXJuZWQgYSAlcy4gJyArICdZb3UgbWF5IGhhdmUgZm9yZ290dGVuIHRvIHBhc3MgYW4gYXJndW1lbnQgdG8gdGhlIHR5cGUgY2hlY2tlciAnICsgJ2NyZWF0b3IgKGFycmF5T2YsIGluc3RhbmNlT2YsIG9iamVjdE9mLCBvbmVPZiwgb25lT2ZUeXBlLCBhbmQgJyArICdzaGFwZSBhbGwgcmVxdWlyZSBhbiBhcmd1bWVudCkuJywgY29tcG9uZW50TmFtZSB8fCAnUmVhY3QgY2xhc3MnLCBsb2NhdGlvbiwgdHlwZVNwZWNOYW1lLCB0eXBlb2YgZXJyb3IkMSk7XHJcblxyXG4gICAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQobnVsbCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoZXJyb3IkMSBpbnN0YW5jZW9mIEVycm9yICYmICEoZXJyb3IkMS5tZXNzYWdlIGluIGxvZ2dlZFR5cGVGYWlsdXJlcykpIHtcclxuICAgICAgICAgIC8vIE9ubHkgbW9uaXRvciB0aGlzIGZhaWx1cmUgb25jZSBiZWNhdXNlIHRoZXJlIHRlbmRzIHRvIGJlIGEgbG90IG9mIHRoZVxyXG4gICAgICAgICAgLy8gc2FtZSBlcnJvci5cclxuICAgICAgICAgIGxvZ2dlZFR5cGVGYWlsdXJlc1tlcnJvciQxLm1lc3NhZ2VdID0gdHJ1ZTtcclxuICAgICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KGVsZW1lbnQpO1xyXG5cclxuICAgICAgICAgIGVycm9yKCdGYWlsZWQgJXMgdHlwZTogJXMnLCBsb2NhdGlvbiwgZXJyb3IkMS5tZXNzYWdlKTtcclxuXHJcbiAgICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChudWxsKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcbn1cclxuXHJcbnZhciBpc0FycmF5SW1wbCA9IEFycmF5LmlzQXJyYXk7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZWRlY2xhcmVcclxuXHJcbmZ1bmN0aW9uIGlzQXJyYXkoYSkge1xyXG4gIHJldHVybiBpc0FycmF5SW1wbChhKTtcclxufVxyXG5cclxuLypcclxuICogVGhlIGAnJyArIHZhbHVlYCBwYXR0ZXJuICh1c2VkIGluIGluIHBlcmYtc2Vuc2l0aXZlIGNvZGUpIHRocm93cyBmb3IgU3ltYm9sXHJcbiAqIGFuZCBUZW1wb3JhbC4qIHR5cGVzLiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L3B1bGwvMjIwNjQuXHJcbiAqXHJcbiAqIFRoZSBmdW5jdGlvbnMgaW4gdGhpcyBtb2R1bGUgd2lsbCB0aHJvdyBhbiBlYXNpZXItdG8tdW5kZXJzdGFuZCxcclxuICogZWFzaWVyLXRvLWRlYnVnIGV4Y2VwdGlvbiB3aXRoIGEgY2xlYXIgZXJyb3JzIG1lc3NhZ2UgbWVzc2FnZSBleHBsYWluaW5nIHRoZVxyXG4gKiBwcm9ibGVtLiAoSW5zdGVhZCBvZiBhIGNvbmZ1c2luZyBleGNlcHRpb24gdGhyb3duIGluc2lkZSB0aGUgaW1wbGVtZW50YXRpb25cclxuICogb2YgdGhlIGB2YWx1ZWAgb2JqZWN0KS5cclxuICovXHJcbi8vICRGbG93Rml4TWUgb25seSBjYWxsZWQgaW4gREVWLCBzbyB2b2lkIHJldHVybiBpcyBub3QgcG9zc2libGUuXHJcbmZ1bmN0aW9uIHR5cGVOYW1lKHZhbHVlKSB7XHJcbiAge1xyXG4gICAgLy8gdG9TdHJpbmdUYWcgaXMgbmVlZGVkIGZvciBuYW1lc3BhY2VkIHR5cGVzIGxpa2UgVGVtcG9yYWwuSW5zdGFudFxyXG4gICAgdmFyIGhhc1RvU3RyaW5nVGFnID0gdHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBTeW1ib2wudG9TdHJpbmdUYWc7XHJcbiAgICB2YXIgdHlwZSA9IGhhc1RvU3RyaW5nVGFnICYmIHZhbHVlW1N5bWJvbC50b1N0cmluZ1RhZ10gfHwgdmFsdWUuY29uc3RydWN0b3IubmFtZSB8fCAnT2JqZWN0JztcclxuICAgIHJldHVybiB0eXBlO1xyXG4gIH1cclxufSAvLyAkRmxvd0ZpeE1lIG9ubHkgY2FsbGVkIGluIERFViwgc28gdm9pZCByZXR1cm4gaXMgbm90IHBvc3NpYmxlLlxyXG5cclxuXHJcbmZ1bmN0aW9uIHdpbGxDb2VyY2lvblRocm93KHZhbHVlKSB7XHJcbiAge1xyXG4gICAgdHJ5IHtcclxuICAgICAgdGVzdFN0cmluZ0NvZXJjaW9uKHZhbHVlKTtcclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHRlc3RTdHJpbmdDb2VyY2lvbih2YWx1ZSkge1xyXG4gIC8vIElmIHlvdSBlbmRlZCB1cCBoZXJlIGJ5IGZvbGxvd2luZyBhbiBleGNlcHRpb24gY2FsbCBzdGFjaywgaGVyZSdzIHdoYXQnc1xyXG4gIC8vIGhhcHBlbmVkOiB5b3Ugc3VwcGxpZWQgYW4gb2JqZWN0IG9yIHN5bWJvbCB2YWx1ZSB0byBSZWFjdCAoYXMgYSBwcm9wLCBrZXksXHJcbiAgLy8gRE9NIGF0dHJpYnV0ZSwgQ1NTIHByb3BlcnR5LCBzdHJpbmcgcmVmLCBldGMuKSBhbmQgd2hlbiBSZWFjdCB0cmllZCB0b1xyXG4gIC8vIGNvZXJjZSBpdCB0byBhIHN0cmluZyB1c2luZyBgJycgKyB2YWx1ZWAsIGFuIGV4Y2VwdGlvbiB3YXMgdGhyb3duLlxyXG4gIC8vXHJcbiAgLy8gVGhlIG1vc3QgY29tbW9uIHR5cGVzIHRoYXQgd2lsbCBjYXVzZSB0aGlzIGV4Y2VwdGlvbiBhcmUgYFN5bWJvbGAgaW5zdGFuY2VzXHJcbiAgLy8gYW5kIFRlbXBvcmFsIG9iamVjdHMgbGlrZSBgVGVtcG9yYWwuSW5zdGFudGAuIEJ1dCBhbnkgb2JqZWN0IHRoYXQgaGFzIGFcclxuICAvLyBgdmFsdWVPZmAgb3IgYFtTeW1ib2wudG9QcmltaXRpdmVdYCBtZXRob2QgdGhhdCB0aHJvd3Mgd2lsbCBhbHNvIGNhdXNlIHRoaXNcclxuICAvLyBleGNlcHRpb24uIChMaWJyYXJ5IGF1dGhvcnMgZG8gdGhpcyB0byBwcmV2ZW50IHVzZXJzIGZyb20gdXNpbmcgYnVpbHQtaW5cclxuICAvLyBudW1lcmljIG9wZXJhdG9ycyBsaWtlIGArYCBvciBjb21wYXJpc29uIG9wZXJhdG9ycyBsaWtlIGA+PWAgYmVjYXVzZSBjdXN0b21cclxuICAvLyBtZXRob2RzIGFyZSBuZWVkZWQgdG8gcGVyZm9ybSBhY2N1cmF0ZSBhcml0aG1ldGljIG9yIGNvbXBhcmlzb24uKVxyXG4gIC8vXHJcbiAgLy8gVG8gZml4IHRoZSBwcm9ibGVtLCBjb2VyY2UgdGhpcyBvYmplY3Qgb3Igc3ltYm9sIHZhbHVlIHRvIGEgc3RyaW5nIGJlZm9yZVxyXG4gIC8vIHBhc3NpbmcgaXQgdG8gUmVhY3QuIFRoZSBtb3N0IHJlbGlhYmxlIHdheSBpcyB1c3VhbGx5IGBTdHJpbmcodmFsdWUpYC5cclxuICAvL1xyXG4gIC8vIFRvIGZpbmQgd2hpY2ggdmFsdWUgaXMgdGhyb3dpbmcsIGNoZWNrIHRoZSBicm93c2VyIG9yIGRlYnVnZ2VyIGNvbnNvbGUuXHJcbiAgLy8gQmVmb3JlIHRoaXMgZXhjZXB0aW9uIHdhcyB0aHJvd24sIHRoZXJlIHNob3VsZCBiZSBgY29uc29sZS5lcnJvcmAgb3V0cHV0XHJcbiAgLy8gdGhhdCBzaG93cyB0aGUgdHlwZSAoU3ltYm9sLCBUZW1wb3JhbC5QbGFpbkRhdGUsIGV0Yy4pIHRoYXQgY2F1c2VkIHRoZVxyXG4gIC8vIHByb2JsZW0gYW5kIGhvdyB0aGF0IHR5cGUgd2FzIHVzZWQ6IGtleSwgYXRycmlidXRlLCBpbnB1dCB2YWx1ZSBwcm9wLCBldGMuXHJcbiAgLy8gSW4gbW9zdCBjYXNlcywgdGhpcyBjb25zb2xlIG91dHB1dCBhbHNvIHNob3dzIHRoZSBjb21wb25lbnQgYW5kIGl0c1xyXG4gIC8vIGFuY2VzdG9yIGNvbXBvbmVudHMgd2hlcmUgdGhlIGV4Y2VwdGlvbiBoYXBwZW5lZC5cclxuICAvL1xyXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1pbnRlcm5hbC9zYWZlLXN0cmluZy1jb2VyY2lvblxyXG4gIHJldHVybiAnJyArIHZhbHVlO1xyXG59XHJcbmZ1bmN0aW9uIGNoZWNrS2V5U3RyaW5nQ29lcmNpb24odmFsdWUpIHtcclxuICB7XHJcbiAgICBpZiAod2lsbENvZXJjaW9uVGhyb3codmFsdWUpKSB7XHJcbiAgICAgIGVycm9yKCdUaGUgcHJvdmlkZWQga2V5IGlzIGFuIHVuc3VwcG9ydGVkIHR5cGUgJXMuJyArICcgVGhpcyB2YWx1ZSBtdXN0IGJlIGNvZXJjZWQgdG8gYSBzdHJpbmcgYmVmb3JlIGJlZm9yZSB1c2luZyBpdCBoZXJlLicsIHR5cGVOYW1lKHZhbHVlKSk7XHJcblxyXG4gICAgICByZXR1cm4gdGVzdFN0cmluZ0NvZXJjaW9uKHZhbHVlKTsgLy8gdGhyb3cgKHRvIGhlbHAgY2FsbGVycyBmaW5kIHRyb3VibGVzaG9vdGluZyBjb21tZW50cylcclxuICAgIH1cclxuICB9XHJcbn1cclxuXHJcbnZhciBSZWFjdEN1cnJlbnRPd25lciA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0Q3VycmVudE93bmVyO1xyXG52YXIgUkVTRVJWRURfUFJPUFMgPSB7XHJcbiAga2V5OiB0cnVlLFxyXG4gIHJlZjogdHJ1ZSxcclxuICBfX3NlbGY6IHRydWUsXHJcbiAgX19zb3VyY2U6IHRydWVcclxufTtcclxudmFyIHNwZWNpYWxQcm9wS2V5V2FybmluZ1Nob3duO1xyXG52YXIgc3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd247XHJcbnZhciBkaWRXYXJuQWJvdXRTdHJpbmdSZWZzO1xyXG5cclxue1xyXG4gIGRpZFdhcm5BYm91dFN0cmluZ1JlZnMgPSB7fTtcclxufVxyXG5cclxuZnVuY3Rpb24gaGFzVmFsaWRSZWYoY29uZmlnKSB7XHJcbiAge1xyXG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCAncmVmJykpIHtcclxuICAgICAgdmFyIGdldHRlciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoY29uZmlnLCAncmVmJykuZ2V0O1xyXG5cclxuICAgICAgaWYgKGdldHRlciAmJiBnZXR0ZXIuaXNSZWFjdFdhcm5pbmcpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIHJldHVybiBjb25maWcucmVmICE9PSB1bmRlZmluZWQ7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGhhc1ZhbGlkS2V5KGNvbmZpZykge1xyXG4gIHtcclxuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZywgJ2tleScpKSB7XHJcbiAgICAgIHZhciBnZXR0ZXIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGNvbmZpZywgJ2tleScpLmdldDtcclxuXHJcbiAgICAgIGlmIChnZXR0ZXIgJiYgZ2V0dGVyLmlzUmVhY3RXYXJuaW5nKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICByZXR1cm4gY29uZmlnLmtleSAhPT0gdW5kZWZpbmVkO1xyXG59XHJcblxyXG5mdW5jdGlvbiB3YXJuSWZTdHJpbmdSZWZDYW5ub3RCZUF1dG9Db252ZXJ0ZWQoY29uZmlnLCBzZWxmKSB7XHJcbiAge1xyXG4gICAgaWYgKHR5cGVvZiBjb25maWcucmVmID09PSAnc3RyaW5nJyAmJiBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50ICYmIHNlbGYgJiYgUmVhY3RDdXJyZW50T3duZXIuY3VycmVudC5zdGF0ZU5vZGUgIT09IHNlbGYpIHtcclxuICAgICAgdmFyIGNvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoUmVhY3RDdXJyZW50T3duZXIuY3VycmVudC50eXBlKTtcclxuXHJcbiAgICAgIGlmICghZGlkV2FybkFib3V0U3RyaW5nUmVmc1tjb21wb25lbnROYW1lXSkge1xyXG4gICAgICAgIGVycm9yKCdDb21wb25lbnQgXCIlc1wiIGNvbnRhaW5zIHRoZSBzdHJpbmcgcmVmIFwiJXNcIi4gJyArICdTdXBwb3J0IGZvciBzdHJpbmcgcmVmcyB3aWxsIGJlIHJlbW92ZWQgaW4gYSBmdXR1cmUgbWFqb3IgcmVsZWFzZS4gJyArICdUaGlzIGNhc2UgY2Fubm90IGJlIGF1dG9tYXRpY2FsbHkgY29udmVydGVkIHRvIGFuIGFycm93IGZ1bmN0aW9uLiAnICsgJ1dlIGFzayB5b3UgdG8gbWFudWFsbHkgZml4IHRoaXMgY2FzZSBieSB1c2luZyB1c2VSZWYoKSBvciBjcmVhdGVSZWYoKSBpbnN0ZWFkLiAnICsgJ0xlYXJuIG1vcmUgYWJvdXQgdXNpbmcgcmVmcyBzYWZlbHkgaGVyZTogJyArICdodHRwczovL3JlYWN0anMub3JnL2xpbmsvc3RyaWN0LW1vZGUtc3RyaW5nLXJlZicsIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50LnR5cGUpLCBjb25maWcucmVmKTtcclxuXHJcbiAgICAgICAgZGlkV2FybkFib3V0U3RyaW5nUmVmc1tjb21wb25lbnROYW1lXSA9IHRydWU7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGRlZmluZUtleVByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSkge1xyXG4gIHtcclxuICAgIHZhciB3YXJuQWJvdXRBY2Nlc3NpbmdLZXkgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIGlmICghc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd24pIHtcclxuICAgICAgICBzcGVjaWFsUHJvcEtleVdhcm5pbmdTaG93biA9IHRydWU7XHJcblxyXG4gICAgICAgIGVycm9yKCclczogYGtleWAgaXMgbm90IGEgcHJvcC4gVHJ5aW5nIHRvIGFjY2VzcyBpdCB3aWxsIHJlc3VsdCAnICsgJ2luIGB1bmRlZmluZWRgIGJlaW5nIHJldHVybmVkLiBJZiB5b3UgbmVlZCB0byBhY2Nlc3MgdGhlIHNhbWUgJyArICd2YWx1ZSB3aXRoaW4gdGhlIGNoaWxkIGNvbXBvbmVudCwgeW91IHNob3VsZCBwYXNzIGl0IGFzIGEgZGlmZmVyZW50ICcgKyAncHJvcC4gKGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9zcGVjaWFsLXByb3BzKScsIGRpc3BsYXlOYW1lKTtcclxuICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICB3YXJuQWJvdXRBY2Nlc3NpbmdLZXkuaXNSZWFjdFdhcm5pbmcgPSB0cnVlO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3BzLCAna2V5Jywge1xyXG4gICAgICBnZXQ6IHdhcm5BYm91dEFjY2Vzc2luZ0tleSxcclxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGRlZmluZVJlZlByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSkge1xyXG4gIHtcclxuICAgIHZhciB3YXJuQWJvdXRBY2Nlc3NpbmdSZWYgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIGlmICghc3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd24pIHtcclxuICAgICAgICBzcGVjaWFsUHJvcFJlZldhcm5pbmdTaG93biA9IHRydWU7XHJcblxyXG4gICAgICAgIGVycm9yKCclczogYHJlZmAgaXMgbm90IGEgcHJvcC4gVHJ5aW5nIHRvIGFjY2VzcyBpdCB3aWxsIHJlc3VsdCAnICsgJ2luIGB1bmRlZmluZWRgIGJlaW5nIHJldHVybmVkLiBJZiB5b3UgbmVlZCB0byBhY2Nlc3MgdGhlIHNhbWUgJyArICd2YWx1ZSB3aXRoaW4gdGhlIGNoaWxkIGNvbXBvbmVudCwgeW91IHNob3VsZCBwYXNzIGl0IGFzIGEgZGlmZmVyZW50ICcgKyAncHJvcC4gKGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9zcGVjaWFsLXByb3BzKScsIGRpc3BsYXlOYW1lKTtcclxuICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICB3YXJuQWJvdXRBY2Nlc3NpbmdSZWYuaXNSZWFjdFdhcm5pbmcgPSB0cnVlO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3BzLCAncmVmJywge1xyXG4gICAgICBnZXQ6IHdhcm5BYm91dEFjY2Vzc2luZ1JlZixcclxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICB9XHJcbn1cclxuLyoqXHJcbiAqIEZhY3RvcnkgbWV0aG9kIHRvIGNyZWF0ZSBhIG5ldyBSZWFjdCBlbGVtZW50LiBUaGlzIG5vIGxvbmdlciBhZGhlcmVzIHRvXHJcbiAqIHRoZSBjbGFzcyBwYXR0ZXJuLCBzbyBkbyBub3QgdXNlIG5ldyB0byBjYWxsIGl0LiBBbHNvLCBpbnN0YW5jZW9mIGNoZWNrXHJcbiAqIHdpbGwgbm90IHdvcmsuIEluc3RlYWQgdGVzdCAkJHR5cGVvZiBmaWVsZCBhZ2FpbnN0IFN5bWJvbC5mb3IoJ3JlYWN0LmVsZW1lbnQnKSB0byBjaGVja1xyXG4gKiBpZiBzb21ldGhpbmcgaXMgYSBSZWFjdCBFbGVtZW50LlxyXG4gKlxyXG4gKiBAcGFyYW0geyp9IHR5cGVcclxuICogQHBhcmFtIHsqfSBwcm9wc1xyXG4gKiBAcGFyYW0geyp9IGtleVxyXG4gKiBAcGFyYW0ge3N0cmluZ3xvYmplY3R9IHJlZlxyXG4gKiBAcGFyYW0geyp9IG93bmVyXHJcbiAqIEBwYXJhbSB7Kn0gc2VsZiBBICp0ZW1wb3JhcnkqIGhlbHBlciB0byBkZXRlY3QgcGxhY2VzIHdoZXJlIGB0aGlzYCBpc1xyXG4gKiBkaWZmZXJlbnQgZnJvbSB0aGUgYG93bmVyYCB3aGVuIFJlYWN0LmNyZWF0ZUVsZW1lbnQgaXMgY2FsbGVkLCBzbyB0aGF0IHdlXHJcbiAqIGNhbiB3YXJuLiBXZSB3YW50IHRvIGdldCByaWQgb2Ygb3duZXIgYW5kIHJlcGxhY2Ugc3RyaW5nIGByZWZgcyB3aXRoIGFycm93XHJcbiAqIGZ1bmN0aW9ucywgYW5kIGFzIGxvbmcgYXMgYHRoaXNgIGFuZCBvd25lciBhcmUgdGhlIHNhbWUsIHRoZXJlIHdpbGwgYmUgbm9cclxuICogY2hhbmdlIGluIGJlaGF2aW9yLlxyXG4gKiBAcGFyYW0geyp9IHNvdXJjZSBBbiBhbm5vdGF0aW9uIG9iamVjdCAoYWRkZWQgYnkgYSB0cmFuc3BpbGVyIG9yIG90aGVyd2lzZSlcclxuICogaW5kaWNhdGluZyBmaWxlbmFtZSwgbGluZSBudW1iZXIsIGFuZC9vciBvdGhlciBpbmZvcm1hdGlvbi5cclxuICogQGludGVybmFsXHJcbiAqL1xyXG5cclxuXHJcbnZhciBSZWFjdEVsZW1lbnQgPSBmdW5jdGlvbiAodHlwZSwga2V5LCByZWYsIHNlbGYsIHNvdXJjZSwgb3duZXIsIHByb3BzKSB7XHJcbiAgdmFyIGVsZW1lbnQgPSB7XHJcbiAgICAvLyBUaGlzIHRhZyBhbGxvd3MgdXMgdG8gdW5pcXVlbHkgaWRlbnRpZnkgdGhpcyBhcyBhIFJlYWN0IEVsZW1lbnRcclxuICAgICQkdHlwZW9mOiBSRUFDVF9FTEVNRU5UX1RZUEUsXHJcbiAgICAvLyBCdWlsdC1pbiBwcm9wZXJ0aWVzIHRoYXQgYmVsb25nIG9uIHRoZSBlbGVtZW50XHJcbiAgICB0eXBlOiB0eXBlLFxyXG4gICAga2V5OiBrZXksXHJcbiAgICByZWY6IHJlZixcclxuICAgIHByb3BzOiBwcm9wcyxcclxuICAgIC8vIFJlY29yZCB0aGUgY29tcG9uZW50IHJlc3BvbnNpYmxlIGZvciBjcmVhdGluZyB0aGlzIGVsZW1lbnQuXHJcbiAgICBfb3duZXI6IG93bmVyXHJcbiAgfTtcclxuXHJcbiAge1xyXG4gICAgLy8gVGhlIHZhbGlkYXRpb24gZmxhZyBpcyBjdXJyZW50bHkgbXV0YXRpdmUuIFdlIHB1dCBpdCBvblxyXG4gICAgLy8gYW4gZXh0ZXJuYWwgYmFja2luZyBzdG9yZSBzbyB0aGF0IHdlIGNhbiBmcmVlemUgdGhlIHdob2xlIG9iamVjdC5cclxuICAgIC8vIFRoaXMgY2FuIGJlIHJlcGxhY2VkIHdpdGggYSBXZWFrTWFwIG9uY2UgdGhleSBhcmUgaW1wbGVtZW50ZWQgaW5cclxuICAgIC8vIGNvbW1vbmx5IHVzZWQgZGV2ZWxvcG1lbnQgZW52aXJvbm1lbnRzLlxyXG4gICAgZWxlbWVudC5fc3RvcmUgPSB7fTsgLy8gVG8gbWFrZSBjb21wYXJpbmcgUmVhY3RFbGVtZW50cyBlYXNpZXIgZm9yIHRlc3RpbmcgcHVycG9zZXMsIHdlIG1ha2VcclxuICAgIC8vIHRoZSB2YWxpZGF0aW9uIGZsYWcgbm9uLWVudW1lcmFibGUgKHdoZXJlIHBvc3NpYmxlLCB3aGljaCBzaG91bGRcclxuICAgIC8vIGluY2x1ZGUgZXZlcnkgZW52aXJvbm1lbnQgd2UgcnVuIHRlc3RzIGluKSwgc28gdGhlIHRlc3QgZnJhbWV3b3JrXHJcbiAgICAvLyBpZ25vcmVzIGl0LlxyXG5cclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbGVtZW50Ll9zdG9yZSwgJ3ZhbGlkYXRlZCcsIHtcclxuICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcclxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXHJcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgICB2YWx1ZTogZmFsc2VcclxuICAgIH0pOyAvLyBzZWxmIGFuZCBzb3VyY2UgYXJlIERFViBvbmx5IHByb3BlcnRpZXMuXHJcblxyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGVsZW1lbnQsICdfc2VsZicsIHtcclxuICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcclxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXHJcbiAgICAgIHdyaXRhYmxlOiBmYWxzZSxcclxuICAgICAgdmFsdWU6IHNlbGZcclxuICAgIH0pOyAvLyBUd28gZWxlbWVudHMgY3JlYXRlZCBpbiB0d28gZGlmZmVyZW50IHBsYWNlcyBzaG91bGQgYmUgY29uc2lkZXJlZFxyXG4gICAgLy8gZXF1YWwgZm9yIHRlc3RpbmcgcHVycG9zZXMgYW5kIHRoZXJlZm9yZSB3ZSBoaWRlIGl0IGZyb20gZW51bWVyYXRpb24uXHJcblxyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGVsZW1lbnQsICdfc291cmNlJywge1xyXG4gICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxyXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcclxuICAgICAgd3JpdGFibGU6IGZhbHNlLFxyXG4gICAgICB2YWx1ZTogc291cmNlXHJcbiAgICB9KTtcclxuXHJcbiAgICBpZiAoT2JqZWN0LmZyZWV6ZSkge1xyXG4gICAgICBPYmplY3QuZnJlZXplKGVsZW1lbnQucHJvcHMpO1xyXG4gICAgICBPYmplY3QuZnJlZXplKGVsZW1lbnQpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIGVsZW1lbnQ7XHJcbn07XHJcbi8qKlxyXG4gKiBodHRwczovL2dpdGh1Yi5jb20vcmVhY3Rqcy9yZmNzL3B1bGwvMTA3XHJcbiAqIEBwYXJhbSB7Kn0gdHlwZVxyXG4gKiBAcGFyYW0ge29iamVjdH0gcHJvcHNcclxuICogQHBhcmFtIHtzdHJpbmd9IGtleVxyXG4gKi9cclxuXHJcbmZ1bmN0aW9uIGpzeERFVih0eXBlLCBjb25maWcsIG1heWJlS2V5LCBzb3VyY2UsIHNlbGYpIHtcclxuICB7XHJcbiAgICB2YXIgcHJvcE5hbWU7IC8vIFJlc2VydmVkIG5hbWVzIGFyZSBleHRyYWN0ZWRcclxuXHJcbiAgICB2YXIgcHJvcHMgPSB7fTtcclxuICAgIHZhciBrZXkgPSBudWxsO1xyXG4gICAgdmFyIHJlZiA9IG51bGw7IC8vIEN1cnJlbnRseSwga2V5IGNhbiBiZSBzcHJlYWQgaW4gYXMgYSBwcm9wLiBUaGlzIGNhdXNlcyBhIHBvdGVudGlhbFxyXG4gICAgLy8gaXNzdWUgaWYga2V5IGlzIGFsc28gZXhwbGljaXRseSBkZWNsYXJlZCAoaWUuIDxkaXYgey4uLnByb3BzfSBrZXk9XCJIaVwiIC8+XHJcbiAgICAvLyBvciA8ZGl2IGtleT1cIkhpXCIgey4uLnByb3BzfSAvPiApLiBXZSB3YW50IHRvIGRlcHJlY2F0ZSBrZXkgc3ByZWFkLFxyXG4gICAgLy8gYnV0IGFzIGFuIGludGVybWVkaWFyeSBzdGVwLCB3ZSB3aWxsIHVzZSBqc3hERVYgZm9yIGV2ZXJ5dGhpbmcgZXhjZXB0XHJcbiAgICAvLyA8ZGl2IHsuLi5wcm9wc30ga2V5PVwiSGlcIiAvPiwgYmVjYXVzZSB3ZSBhcmVuJ3QgY3VycmVudGx5IGFibGUgdG8gdGVsbCBpZlxyXG4gICAgLy8ga2V5IGlzIGV4cGxpY2l0bHkgZGVjbGFyZWQgdG8gYmUgdW5kZWZpbmVkIG9yIG5vdC5cclxuXHJcbiAgICBpZiAobWF5YmVLZXkgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICB7XHJcbiAgICAgICAgY2hlY2tLZXlTdHJpbmdDb2VyY2lvbihtYXliZUtleSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGtleSA9ICcnICsgbWF5YmVLZXk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGhhc1ZhbGlkS2V5KGNvbmZpZykpIHtcclxuICAgICAge1xyXG4gICAgICAgIGNoZWNrS2V5U3RyaW5nQ29lcmNpb24oY29uZmlnLmtleSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGtleSA9ICcnICsgY29uZmlnLmtleTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoaGFzVmFsaWRSZWYoY29uZmlnKSkge1xyXG4gICAgICByZWYgPSBjb25maWcucmVmO1xyXG4gICAgICB3YXJuSWZTdHJpbmdSZWZDYW5ub3RCZUF1dG9Db252ZXJ0ZWQoY29uZmlnLCBzZWxmKTtcclxuICAgIH0gLy8gUmVtYWluaW5nIHByb3BlcnRpZXMgYXJlIGFkZGVkIHRvIGEgbmV3IHByb3BzIG9iamVjdFxyXG5cclxuXHJcbiAgICBmb3IgKHByb3BOYW1lIGluIGNvbmZpZykge1xyXG4gICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChjb25maWcsIHByb3BOYW1lKSAmJiAhUkVTRVJWRURfUFJPUFMuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpKSB7XHJcbiAgICAgICAgcHJvcHNbcHJvcE5hbWVdID0gY29uZmlnW3Byb3BOYW1lXTtcclxuICAgICAgfVxyXG4gICAgfSAvLyBSZXNvbHZlIGRlZmF1bHQgcHJvcHNcclxuXHJcblxyXG4gICAgaWYgKHR5cGUgJiYgdHlwZS5kZWZhdWx0UHJvcHMpIHtcclxuICAgICAgdmFyIGRlZmF1bHRQcm9wcyA9IHR5cGUuZGVmYXVsdFByb3BzO1xyXG5cclxuICAgICAgZm9yIChwcm9wTmFtZSBpbiBkZWZhdWx0UHJvcHMpIHtcclxuICAgICAgICBpZiAocHJvcHNbcHJvcE5hbWVdID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgIHByb3BzW3Byb3BOYW1lXSA9IGRlZmF1bHRQcm9wc1twcm9wTmFtZV07XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGtleSB8fCByZWYpIHtcclxuICAgICAgdmFyIGRpc3BsYXlOYW1lID0gdHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicgPyB0eXBlLmRpc3BsYXlOYW1lIHx8IHR5cGUubmFtZSB8fCAnVW5rbm93bicgOiB0eXBlO1xyXG5cclxuICAgICAgaWYgKGtleSkge1xyXG4gICAgICAgIGRlZmluZUtleVByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChyZWYpIHtcclxuICAgICAgICBkZWZpbmVSZWZQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIFJlYWN0RWxlbWVudCh0eXBlLCBrZXksIHJlZiwgc2VsZiwgc291cmNlLCBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50LCBwcm9wcyk7XHJcbiAgfVxyXG59XHJcblxyXG52YXIgUmVhY3RDdXJyZW50T3duZXIkMSA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0Q3VycmVudE93bmVyO1xyXG52YXIgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSQxID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZTtcclxuXHJcbmZ1bmN0aW9uIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50JDEoZWxlbWVudCkge1xyXG4gIHtcclxuICAgIGlmIChlbGVtZW50KSB7XHJcbiAgICAgIHZhciBvd25lciA9IGVsZW1lbnQuX293bmVyO1xyXG4gICAgICB2YXIgc3RhY2sgPSBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYoZWxlbWVudC50eXBlLCBlbGVtZW50Ll9zb3VyY2UsIG93bmVyID8gb3duZXIudHlwZSA6IG51bGwpO1xyXG4gICAgICBSZWFjdERlYnVnQ3VycmVudEZyYW1lJDEuc2V0RXh0cmFTdGFja0ZyYW1lKHN0YWNrKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIFJlYWN0RGVidWdDdXJyZW50RnJhbWUkMS5zZXRFeHRyYVN0YWNrRnJhbWUobnVsbCk7XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcblxyXG52YXIgcHJvcFR5cGVzTWlzc3BlbGxXYXJuaW5nU2hvd247XHJcblxyXG57XHJcbiAgcHJvcFR5cGVzTWlzc3BlbGxXYXJuaW5nU2hvd24gPSBmYWxzZTtcclxufVxyXG4vKipcclxuICogVmVyaWZpZXMgdGhlIG9iamVjdCBpcyBhIFJlYWN0RWxlbWVudC5cclxuICogU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvZG9jcy9yZWFjdC1hcGkuaHRtbCNpc3ZhbGlkZWxlbWVudFxyXG4gKiBAcGFyYW0gez9vYmplY3R9IG9iamVjdFxyXG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIGBvYmplY3RgIGlzIGEgUmVhY3RFbGVtZW50LlxyXG4gKiBAZmluYWxcclxuICovXHJcblxyXG5cclxuZnVuY3Rpb24gaXNWYWxpZEVsZW1lbnQob2JqZWN0KSB7XHJcbiAge1xyXG4gICAgcmV0dXJuIHR5cGVvZiBvYmplY3QgPT09ICdvYmplY3QnICYmIG9iamVjdCAhPT0gbnVsbCAmJiBvYmplY3QuJCR0eXBlb2YgPT09IFJFQUNUX0VMRU1FTlRfVFlQRTtcclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bSgpIHtcclxuICB7XHJcbiAgICBpZiAoUmVhY3RDdXJyZW50T3duZXIkMS5jdXJyZW50KSB7XHJcbiAgICAgIHZhciBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKFJlYWN0Q3VycmVudE93bmVyJDEuY3VycmVudC50eXBlKTtcclxuXHJcbiAgICAgIGlmIChuYW1lKSB7XHJcbiAgICAgICAgcmV0dXJuICdcXG5cXG5DaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiBgJyArIG5hbWUgKyAnYC4nO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuICcnO1xyXG4gIH1cclxufVxyXG5cclxuZnVuY3Rpb24gZ2V0U291cmNlSW5mb0Vycm9yQWRkZW5kdW0oc291cmNlKSB7XHJcbiAge1xyXG4gICAgaWYgKHNvdXJjZSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgIHZhciBmaWxlTmFtZSA9IHNvdXJjZS5maWxlTmFtZS5yZXBsYWNlKC9eLipbXFxcXFxcL10vLCAnJyk7XHJcbiAgICAgIHZhciBsaW5lTnVtYmVyID0gc291cmNlLmxpbmVOdW1iZXI7XHJcbiAgICAgIHJldHVybiAnXFxuXFxuQ2hlY2sgeW91ciBjb2RlIGF0ICcgKyBmaWxlTmFtZSArICc6JyArIGxpbmVOdW1iZXIgKyAnLic7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuICcnO1xyXG4gIH1cclxufVxyXG4vKipcclxuICogV2FybiBpZiB0aGVyZSdzIG5vIGtleSBleHBsaWNpdGx5IHNldCBvbiBkeW5hbWljIGFycmF5cyBvZiBjaGlsZHJlbiBvclxyXG4gKiBvYmplY3Qga2V5cyBhcmUgbm90IHZhbGlkLiBUaGlzIGFsbG93cyB1cyB0byBrZWVwIHRyYWNrIG9mIGNoaWxkcmVuIGJldHdlZW5cclxuICogdXBkYXRlcy5cclxuICovXHJcblxyXG5cclxudmFyIG93bmVySGFzS2V5VXNlV2FybmluZyA9IHt9O1xyXG5cclxuZnVuY3Rpb24gZ2V0Q3VycmVudENvbXBvbmVudEVycm9ySW5mbyhwYXJlbnRUeXBlKSB7XHJcbiAge1xyXG4gICAgdmFyIGluZm8gPSBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKTtcclxuXHJcbiAgICBpZiAoIWluZm8pIHtcclxuICAgICAgdmFyIHBhcmVudE5hbWUgPSB0eXBlb2YgcGFyZW50VHlwZSA9PT0gJ3N0cmluZycgPyBwYXJlbnRUeXBlIDogcGFyZW50VHlwZS5kaXNwbGF5TmFtZSB8fCBwYXJlbnRUeXBlLm5hbWU7XHJcblxyXG4gICAgICBpZiAocGFyZW50TmFtZSkge1xyXG4gICAgICAgIGluZm8gPSBcIlxcblxcbkNoZWNrIHRoZSB0b3AtbGV2ZWwgcmVuZGVyIGNhbGwgdXNpbmcgPFwiICsgcGFyZW50TmFtZSArIFwiPi5cIjtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBpbmZvO1xyXG4gIH1cclxufVxyXG4vKipcclxuICogV2FybiBpZiB0aGUgZWxlbWVudCBkb2Vzbid0IGhhdmUgYW4gZXhwbGljaXQga2V5IGFzc2lnbmVkIHRvIGl0LlxyXG4gKiBUaGlzIGVsZW1lbnQgaXMgaW4gYW4gYXJyYXkuIFRoZSBhcnJheSBjb3VsZCBncm93IGFuZCBzaHJpbmsgb3IgYmVcclxuICogcmVvcmRlcmVkLiBBbGwgY2hpbGRyZW4gdGhhdCBoYXZlbid0IGFscmVhZHkgYmVlbiB2YWxpZGF0ZWQgYXJlIHJlcXVpcmVkIHRvXHJcbiAqIGhhdmUgYSBcImtleVwiIHByb3BlcnR5IGFzc2lnbmVkIHRvIGl0LiBFcnJvciBzdGF0dXNlcyBhcmUgY2FjaGVkIHNvIGEgd2FybmluZ1xyXG4gKiB3aWxsIG9ubHkgYmUgc2hvd24gb25jZS5cclxuICpcclxuICogQGludGVybmFsXHJcbiAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBlbGVtZW50IEVsZW1lbnQgdGhhdCByZXF1aXJlcyBhIGtleS5cclxuICogQHBhcmFtIHsqfSBwYXJlbnRUeXBlIGVsZW1lbnQncyBwYXJlbnQncyB0eXBlLlxyXG4gKi9cclxuXHJcblxyXG5mdW5jdGlvbiB2YWxpZGF0ZUV4cGxpY2l0S2V5KGVsZW1lbnQsIHBhcmVudFR5cGUpIHtcclxuICB7XHJcbiAgICBpZiAoIWVsZW1lbnQuX3N0b3JlIHx8IGVsZW1lbnQuX3N0b3JlLnZhbGlkYXRlZCB8fCBlbGVtZW50LmtleSAhPSBudWxsKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBlbGVtZW50Ll9zdG9yZS52YWxpZGF0ZWQgPSB0cnVlO1xyXG4gICAgdmFyIGN1cnJlbnRDb21wb25lbnRFcnJvckluZm8gPSBnZXRDdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvKHBhcmVudFR5cGUpO1xyXG5cclxuICAgIGlmIChvd25lckhhc0tleVVzZVdhcm5pbmdbY3VycmVudENvbXBvbmVudEVycm9ySW5mb10pIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIG93bmVySGFzS2V5VXNlV2FybmluZ1tjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvXSA9IHRydWU7IC8vIFVzdWFsbHkgdGhlIGN1cnJlbnQgb3duZXIgaXMgdGhlIG9mZmVuZGVyLCBidXQgaWYgaXQgYWNjZXB0cyBjaGlsZHJlbiBhcyBhXHJcbiAgICAvLyBwcm9wZXJ0eSwgaXQgbWF5IGJlIHRoZSBjcmVhdG9yIG9mIHRoZSBjaGlsZCB0aGF0J3MgcmVzcG9uc2libGUgZm9yXHJcbiAgICAvLyBhc3NpZ25pbmcgaXQgYSBrZXkuXHJcblxyXG4gICAgdmFyIGNoaWxkT3duZXIgPSAnJztcclxuXHJcbiAgICBpZiAoZWxlbWVudCAmJiBlbGVtZW50Ll9vd25lciAmJiBlbGVtZW50Ll9vd25lciAhPT0gUmVhY3RDdXJyZW50T3duZXIkMS5jdXJyZW50KSB7XHJcbiAgICAgIC8vIEdpdmUgdGhlIGNvbXBvbmVudCB0aGF0IG9yaWdpbmFsbHkgY3JlYXRlZCB0aGlzIGNoaWxkLlxyXG4gICAgICBjaGlsZE93bmVyID0gXCIgSXQgd2FzIHBhc3NlZCBhIGNoaWxkIGZyb20gXCIgKyBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoZWxlbWVudC5fb3duZXIudHlwZSkgKyBcIi5cIjtcclxuICAgIH1cclxuXHJcbiAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxKGVsZW1lbnQpO1xyXG5cclxuICAgIGVycm9yKCdFYWNoIGNoaWxkIGluIGEgbGlzdCBzaG91bGQgaGF2ZSBhIHVuaXF1ZSBcImtleVwiIHByb3AuJyArICclcyVzIFNlZSBodHRwczovL3JlYWN0anMub3JnL2xpbmsvd2FybmluZy1rZXlzIGZvciBtb3JlIGluZm9ybWF0aW9uLicsIGN1cnJlbnRDb21wb25lbnRFcnJvckluZm8sIGNoaWxkT3duZXIpO1xyXG5cclxuICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50JDEobnVsbCk7XHJcbiAgfVxyXG59XHJcbi8qKlxyXG4gKiBFbnN1cmUgdGhhdCBldmVyeSBlbGVtZW50IGVpdGhlciBpcyBwYXNzZWQgaW4gYSBzdGF0aWMgbG9jYXRpb24sIGluIGFuXHJcbiAqIGFycmF5IHdpdGggYW4gZXhwbGljaXQga2V5cyBwcm9wZXJ0eSBkZWZpbmVkLCBvciBpbiBhbiBvYmplY3QgbGl0ZXJhbFxyXG4gKiB3aXRoIHZhbGlkIGtleSBwcm9wZXJ0eS5cclxuICpcclxuICogQGludGVybmFsXHJcbiAqIEBwYXJhbSB7UmVhY3ROb2RlfSBub2RlIFN0YXRpY2FsbHkgcGFzc2VkIGNoaWxkIG9mIGFueSB0eXBlLlxyXG4gKiBAcGFyYW0geyp9IHBhcmVudFR5cGUgbm9kZSdzIHBhcmVudCdzIHR5cGUuXHJcbiAqL1xyXG5cclxuXHJcbmZ1bmN0aW9uIHZhbGlkYXRlQ2hpbGRLZXlzKG5vZGUsIHBhcmVudFR5cGUpIHtcclxuICB7XHJcbiAgICBpZiAodHlwZW9mIG5vZGUgIT09ICdvYmplY3QnKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoaXNBcnJheShub2RlKSkge1xyXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGUubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICB2YXIgY2hpbGQgPSBub2RlW2ldO1xyXG5cclxuICAgICAgICBpZiAoaXNWYWxpZEVsZW1lbnQoY2hpbGQpKSB7XHJcbiAgICAgICAgICB2YWxpZGF0ZUV4cGxpY2l0S2V5KGNoaWxkLCBwYXJlbnRUeXBlKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSBpZiAoaXNWYWxpZEVsZW1lbnQobm9kZSkpIHtcclxuICAgICAgLy8gVGhpcyBlbGVtZW50IHdhcyBwYXNzZWQgaW4gYSB2YWxpZCBsb2NhdGlvbi5cclxuICAgICAgaWYgKG5vZGUuX3N0b3JlKSB7XHJcbiAgICAgICAgbm9kZS5fc3RvcmUudmFsaWRhdGVkID0gdHJ1ZTtcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIGlmIChub2RlKSB7XHJcbiAgICAgIHZhciBpdGVyYXRvckZuID0gZ2V0SXRlcmF0b3JGbihub2RlKTtcclxuXHJcbiAgICAgIGlmICh0eXBlb2YgaXRlcmF0b3JGbiA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgIC8vIEVudHJ5IGl0ZXJhdG9ycyB1c2VkIHRvIHByb3ZpZGUgaW1wbGljaXQga2V5cyxcclxuICAgICAgICAvLyBidXQgbm93IHdlIHByaW50IGEgc2VwYXJhdGUgd2FybmluZyBmb3IgdGhlbSBsYXRlci5cclxuICAgICAgICBpZiAoaXRlcmF0b3JGbiAhPT0gbm9kZS5lbnRyaWVzKSB7XHJcbiAgICAgICAgICB2YXIgaXRlcmF0b3IgPSBpdGVyYXRvckZuLmNhbGwobm9kZSk7XHJcbiAgICAgICAgICB2YXIgc3RlcDtcclxuXHJcbiAgICAgICAgICB3aGlsZSAoIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lKSB7XHJcbiAgICAgICAgICAgIGlmIChpc1ZhbGlkRWxlbWVudChzdGVwLnZhbHVlKSkge1xyXG4gICAgICAgICAgICAgIHZhbGlkYXRlRXhwbGljaXRLZXkoc3RlcC52YWx1ZSwgcGFyZW50VHlwZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcbn1cclxuLyoqXHJcbiAqIEdpdmVuIGFuIGVsZW1lbnQsIHZhbGlkYXRlIHRoYXQgaXRzIHByb3BzIGZvbGxvdyB0aGUgcHJvcFR5cGVzIGRlZmluaXRpb24sXHJcbiAqIHByb3ZpZGVkIGJ5IHRoZSB0eXBlLlxyXG4gKlxyXG4gKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gZWxlbWVudFxyXG4gKi9cclxuXHJcblxyXG5mdW5jdGlvbiB2YWxpZGF0ZVByb3BUeXBlcyhlbGVtZW50KSB7XHJcbiAge1xyXG4gICAgdmFyIHR5cGUgPSBlbGVtZW50LnR5cGU7XHJcblxyXG4gICAgaWYgKHR5cGUgPT09IG51bGwgfHwgdHlwZSA9PT0gdW5kZWZpbmVkIHx8IHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJykge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIHByb3BUeXBlcztcclxuXHJcbiAgICBpZiAodHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgcHJvcFR5cGVzID0gdHlwZS5wcm9wVHlwZXM7XHJcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiB0eXBlID09PSAnb2JqZWN0JyAmJiAodHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSB8fCAvLyBOb3RlOiBNZW1vIG9ubHkgY2hlY2tzIG91dGVyIHByb3BzIGhlcmUuXHJcbiAgICAvLyBJbm5lciBwcm9wcyBhcmUgY2hlY2tlZCBpbiB0aGUgcmVjb25jaWxlci5cclxuICAgIHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX01FTU9fVFlQRSkpIHtcclxuICAgICAgcHJvcFR5cGVzID0gdHlwZS5wcm9wVHlwZXM7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHByb3BUeXBlcykge1xyXG4gICAgICAvLyBJbnRlbnRpb25hbGx5IGluc2lkZSB0byBhdm9pZCB0cmlnZ2VyaW5nIGxhenkgaW5pdGlhbGl6ZXJzOlxyXG4gICAgICB2YXIgbmFtZSA9IGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlKTtcclxuICAgICAgY2hlY2tQcm9wVHlwZXMocHJvcFR5cGVzLCBlbGVtZW50LnByb3BzLCAncHJvcCcsIG5hbWUsIGVsZW1lbnQpO1xyXG4gICAgfSBlbHNlIGlmICh0eXBlLlByb3BUeXBlcyAhPT0gdW5kZWZpbmVkICYmICFwcm9wVHlwZXNNaXNzcGVsbFdhcm5pbmdTaG93bikge1xyXG4gICAgICBwcm9wVHlwZXNNaXNzcGVsbFdhcm5pbmdTaG93biA9IHRydWU7IC8vIEludGVudGlvbmFsbHkgaW5zaWRlIHRvIGF2b2lkIHRyaWdnZXJpbmcgbGF6eSBpbml0aWFsaXplcnM6XHJcblxyXG4gICAgICB2YXIgX25hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZSk7XHJcblxyXG4gICAgICBlcnJvcignQ29tcG9uZW50ICVzIGRlY2xhcmVkIGBQcm9wVHlwZXNgIGluc3RlYWQgb2YgYHByb3BUeXBlc2AuIERpZCB5b3UgbWlzc3BlbGwgdGhlIHByb3BlcnR5IGFzc2lnbm1lbnQ/JywgX25hbWUgfHwgJ1Vua25vd24nKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAodHlwZW9mIHR5cGUuZ2V0RGVmYXVsdFByb3BzID09PSAnZnVuY3Rpb24nICYmICF0eXBlLmdldERlZmF1bHRQcm9wcy5pc1JlYWN0Q2xhc3NBcHByb3ZlZCkge1xyXG4gICAgICBlcnJvcignZ2V0RGVmYXVsdFByb3BzIGlzIG9ubHkgdXNlZCBvbiBjbGFzc2ljIFJlYWN0LmNyZWF0ZUNsYXNzICcgKyAnZGVmaW5pdGlvbnMuIFVzZSBhIHN0YXRpYyBwcm9wZXJ0eSBuYW1lZCBgZGVmYXVsdFByb3BzYCBpbnN0ZWFkLicpO1xyXG4gICAgfVxyXG4gIH1cclxufVxyXG4vKipcclxuICogR2l2ZW4gYSBmcmFnbWVudCwgdmFsaWRhdGUgdGhhdCBpdCBjYW4gb25seSBiZSBwcm92aWRlZCB3aXRoIGZyYWdtZW50IHByb3BzXHJcbiAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBmcmFnbWVudFxyXG4gKi9cclxuXHJcblxyXG5mdW5jdGlvbiB2YWxpZGF0ZUZyYWdtZW50UHJvcHMoZnJhZ21lbnQpIHtcclxuICB7XHJcbiAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGZyYWdtZW50LnByb3BzKTtcclxuXHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgdmFyIGtleSA9IGtleXNbaV07XHJcblxyXG4gICAgICBpZiAoa2V5ICE9PSAnY2hpbGRyZW4nICYmIGtleSAhPT0gJ2tleScpIHtcclxuICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxKGZyYWdtZW50KTtcclxuXHJcbiAgICAgICAgZXJyb3IoJ0ludmFsaWQgcHJvcCBgJXNgIHN1cHBsaWVkIHRvIGBSZWFjdC5GcmFnbWVudGAuICcgKyAnUmVhY3QuRnJhZ21lbnQgY2FuIG9ubHkgaGF2ZSBga2V5YCBhbmQgYGNoaWxkcmVuYCBwcm9wcy4nLCBrZXkpO1xyXG5cclxuICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxKG51bGwpO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGZyYWdtZW50LnJlZiAhPT0gbnVsbCkge1xyXG4gICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxKGZyYWdtZW50KTtcclxuXHJcbiAgICAgIGVycm9yKCdJbnZhbGlkIGF0dHJpYnV0ZSBgcmVmYCBzdXBwbGllZCB0byBgUmVhY3QuRnJhZ21lbnRgLicpO1xyXG5cclxuICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShudWxsKTtcclxuICAgIH1cclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGpzeFdpdGhWYWxpZGF0aW9uKHR5cGUsIHByb3BzLCBrZXksIGlzU3RhdGljQ2hpbGRyZW4sIHNvdXJjZSwgc2VsZikge1xyXG4gIHtcclxuICAgIHZhciB2YWxpZFR5cGUgPSBpc1ZhbGlkRWxlbWVudFR5cGUodHlwZSk7IC8vIFdlIHdhcm4gaW4gdGhpcyBjYXNlIGJ1dCBkb24ndCB0aHJvdy4gV2UgZXhwZWN0IHRoZSBlbGVtZW50IGNyZWF0aW9uIHRvXHJcbiAgICAvLyBzdWNjZWVkIGFuZCB0aGVyZSB3aWxsIGxpa2VseSBiZSBlcnJvcnMgaW4gcmVuZGVyLlxyXG5cclxuICAgIGlmICghdmFsaWRUeXBlKSB7XHJcbiAgICAgIHZhciBpbmZvID0gJyc7XHJcblxyXG4gICAgICBpZiAodHlwZSA9PT0gdW5kZWZpbmVkIHx8IHR5cGVvZiB0eXBlID09PSAnb2JqZWN0JyAmJiB0eXBlICE9PSBudWxsICYmIE9iamVjdC5rZXlzKHR5cGUpLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgIGluZm8gKz0gJyBZb3UgbGlrZWx5IGZvcmdvdCB0byBleHBvcnQgeW91ciBjb21wb25lbnQgZnJvbSB0aGUgZmlsZSAnICsgXCJpdCdzIGRlZmluZWQgaW4sIG9yIHlvdSBtaWdodCBoYXZlIG1peGVkIHVwIGRlZmF1bHQgYW5kIG5hbWVkIGltcG9ydHMuXCI7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHZhciBzb3VyY2VJbmZvID0gZ2V0U291cmNlSW5mb0Vycm9yQWRkZW5kdW0oc291cmNlKTtcclxuXHJcbiAgICAgIGlmIChzb3VyY2VJbmZvKSB7XHJcbiAgICAgICAgaW5mbyArPSBzb3VyY2VJbmZvO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGluZm8gKz0gZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHZhciB0eXBlU3RyaW5nO1xyXG5cclxuICAgICAgaWYgKHR5cGUgPT09IG51bGwpIHtcclxuICAgICAgICB0eXBlU3RyaW5nID0gJ251bGwnO1xyXG4gICAgICB9IGVsc2UgaWYgKGlzQXJyYXkodHlwZSkpIHtcclxuICAgICAgICB0eXBlU3RyaW5nID0gJ2FycmF5JztcclxuICAgICAgfSBlbHNlIGlmICh0eXBlICE9PSB1bmRlZmluZWQgJiYgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfRUxFTUVOVF9UWVBFKSB7XHJcbiAgICAgICAgdHlwZVN0cmluZyA9IFwiPFwiICsgKGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlLnR5cGUpIHx8ICdVbmtub3duJykgKyBcIiAvPlwiO1xyXG4gICAgICAgIGluZm8gPSAnIERpZCB5b3UgYWNjaWRlbnRhbGx5IGV4cG9ydCBhIEpTWCBsaXRlcmFsIGluc3RlYWQgb2YgYSBjb21wb25lbnQ/JztcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB0eXBlU3RyaW5nID0gdHlwZW9mIHR5cGU7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGVycm9yKCdSZWFjdC5qc3g6IHR5cGUgaXMgaW52YWxpZCAtLSBleHBlY3RlZCBhIHN0cmluZyAoZm9yICcgKyAnYnVpbHQtaW4gY29tcG9uZW50cykgb3IgYSBjbGFzcy9mdW5jdGlvbiAoZm9yIGNvbXBvc2l0ZSAnICsgJ2NvbXBvbmVudHMpIGJ1dCBnb3Q6ICVzLiVzJywgdHlwZVN0cmluZywgaW5mbyk7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIGVsZW1lbnQgPSBqc3hERVYodHlwZSwgcHJvcHMsIGtleSwgc291cmNlLCBzZWxmKTsgLy8gVGhlIHJlc3VsdCBjYW4gYmUgbnVsbGlzaCBpZiBhIG1vY2sgb3IgYSBjdXN0b20gZnVuY3Rpb24gaXMgdXNlZC5cclxuICAgIC8vIFRPRE86IERyb3AgdGhpcyB3aGVuIHRoZXNlIGFyZSBubyBsb25nZXIgYWxsb3dlZCBhcyB0aGUgdHlwZSBhcmd1bWVudC5cclxuXHJcbiAgICBpZiAoZWxlbWVudCA9PSBudWxsKSB7XHJcbiAgICAgIHJldHVybiBlbGVtZW50O1xyXG4gICAgfSAvLyBTa2lwIGtleSB3YXJuaW5nIGlmIHRoZSB0eXBlIGlzbid0IHZhbGlkIHNpbmNlIG91ciBrZXkgdmFsaWRhdGlvbiBsb2dpY1xyXG4gICAgLy8gZG9lc24ndCBleHBlY3QgYSBub24tc3RyaW5nL2Z1bmN0aW9uIHR5cGUgYW5kIGNhbiB0aHJvdyBjb25mdXNpbmcgZXJyb3JzLlxyXG4gICAgLy8gV2UgZG9uJ3Qgd2FudCBleGNlcHRpb24gYmVoYXZpb3IgdG8gZGlmZmVyIGJldHdlZW4gZGV2IGFuZCBwcm9kLlxyXG4gICAgLy8gKFJlbmRlcmluZyB3aWxsIHRocm93IHdpdGggYSBoZWxwZnVsIG1lc3NhZ2UgYW5kIGFzIHNvb24gYXMgdGhlIHR5cGUgaXNcclxuICAgIC8vIGZpeGVkLCB0aGUga2V5IHdhcm5pbmdzIHdpbGwgYXBwZWFyLilcclxuXHJcblxyXG4gICAgaWYgKHZhbGlkVHlwZSkge1xyXG4gICAgICB2YXIgY2hpbGRyZW4gPSBwcm9wcy5jaGlsZHJlbjtcclxuXHJcbiAgICAgIGlmIChjaGlsZHJlbiAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgaWYgKGlzU3RhdGljQ2hpbGRyZW4pIHtcclxuICAgICAgICAgIGlmIChpc0FycmF5KGNoaWxkcmVuKSkge1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgdmFsaWRhdGVDaGlsZEtleXMoY2hpbGRyZW5baV0sIHR5cGUpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoT2JqZWN0LmZyZWV6ZSkge1xyXG4gICAgICAgICAgICAgIE9iamVjdC5mcmVlemUoY2hpbGRyZW4pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBlcnJvcignUmVhY3QuanN4OiBTdGF0aWMgY2hpbGRyZW4gc2hvdWxkIGFsd2F5cyBiZSBhbiBhcnJheS4gJyArICdZb3UgYXJlIGxpa2VseSBleHBsaWNpdGx5IGNhbGxpbmcgUmVhY3QuanN4cyBvciBSZWFjdC5qc3hERVYuICcgKyAnVXNlIHRoZSBCYWJlbCB0cmFuc2Zvcm0gaW5zdGVhZC4nKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgdmFsaWRhdGVDaGlsZEtleXMoY2hpbGRyZW4sIHR5cGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGlmICh0eXBlID09PSBSRUFDVF9GUkFHTUVOVF9UWVBFKSB7XHJcbiAgICAgIHZhbGlkYXRlRnJhZ21lbnRQcm9wcyhlbGVtZW50KTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHZhbGlkYXRlUHJvcFR5cGVzKGVsZW1lbnQpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBlbGVtZW50O1xyXG4gIH1cclxufSAvLyBUaGVzZSB0d28gZnVuY3Rpb25zIGV4aXN0IHRvIHN0aWxsIGdldCBjaGlsZCB3YXJuaW5ncyBpbiBkZXZcclxuLy8gZXZlbiB3aXRoIHRoZSBwcm9kIHRyYW5zZm9ybS4gVGhpcyBtZWFucyB0aGF0IGpzeERFViBpcyBwdXJlbHlcclxuLy8gb3B0LWluIGJlaGF2aW9yIGZvciBiZXR0ZXIgbWVzc2FnZXMgYnV0IHRoYXQgd2Ugd29uJ3Qgc3RvcFxyXG4vLyBnaXZpbmcgeW91IHdhcm5pbmdzIGlmIHlvdSB1c2UgcHJvZHVjdGlvbiBhcGlzLlxyXG5cclxuZnVuY3Rpb24ganN4V2l0aFZhbGlkYXRpb25TdGF0aWModHlwZSwgcHJvcHMsIGtleSkge1xyXG4gIHtcclxuICAgIHJldHVybiBqc3hXaXRoVmFsaWRhdGlvbih0eXBlLCBwcm9wcywga2V5LCB0cnVlKTtcclxuICB9XHJcbn1cclxuZnVuY3Rpb24ganN4V2l0aFZhbGlkYXRpb25EeW5hbWljKHR5cGUsIHByb3BzLCBrZXkpIHtcclxuICB7XHJcbiAgICByZXR1cm4ganN4V2l0aFZhbGlkYXRpb24odHlwZSwgcHJvcHMsIGtleSwgZmFsc2UpO1xyXG4gIH1cclxufVxyXG5cclxudmFyIGpzeCA9ICBqc3hXaXRoVmFsaWRhdGlvbkR5bmFtaWMgOyAvLyB3ZSBtYXkgd2FudCB0byBzcGVjaWFsIGNhc2UganN4cyBpbnRlcm5hbGx5IHRvIHRha2UgYWR2YW50YWdlIG9mIHN0YXRpYyBjaGlsZHJlbi5cclxuLy8gZm9yIG5vdyB3ZSBjYW4gc2hpcCBpZGVudGljYWwgcHJvZCBmdW5jdGlvbnNcclxuXHJcbnZhciBqc3hzID0gIGpzeFdpdGhWYWxpZGF0aW9uU3RhdGljIDtcclxuXHJcbmV4cG9ydHMuRnJhZ21lbnQgPSBSRUFDVF9GUkFHTUVOVF9UWVBFO1xyXG5leHBvcnRzLmpzeCA9IGpzeDtcclxuZXhwb3J0cy5qc3hzID0ganN4cztcclxuICB9KSgpO1xyXG59XHJcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/react/cjs/react-jsx-runtime.development.js\n"));

/***/ }),

/***/ "./node_modules/react/jsx-dev-runtime.js":
/*!***********************************************!*\
  !*** ./node_modules/react/jsx-dev-runtime.js ***!
  \***********************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\r\n\r\nif (false) {} else {\r\n  module.exports = __webpack_require__(/*! ./cjs/react-jsx-dev-runtime.development.js */ \"./node_modules/react/cjs/react-jsx-dev-runtime.development.js\");\r\n}\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVhY3QvanN4LWRldi1ydW50aW1lLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQSxJQUFJLEtBQXFDLEVBQUUsRUFFMUMsQ0FBQztBQUNGLEVBQUUsdUpBQXNFO0FBQ3hFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9yZWFjdC9qc3gtZGV2LXJ1bnRpbWUuanM/NTc3NyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XHJcblxyXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJykge1xyXG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtanN4LWRldi1ydW50aW1lLnByb2R1Y3Rpb24ubWluLmpzJyk7XHJcbn0gZWxzZSB7XHJcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9yZWFjdC1qc3gtZGV2LXJ1bnRpbWUuZGV2ZWxvcG1lbnQuanMnKTtcclxufVxyXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/react/jsx-dev-runtime.js\n"));

/***/ }),

/***/ "./node_modules/react/jsx-runtime.js":
/*!*******************************************!*\
  !*** ./node_modules/react/jsx-runtime.js ***!
  \*******************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\r\n\r\nif (false) {} else {\r\n  module.exports = __webpack_require__(/*! ./cjs/react-jsx-runtime.development.js */ \"./node_modules/react/cjs/react-jsx-runtime.development.js\");\r\n}\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVhY3QvanN4LXJ1bnRpbWUuanMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBLElBQUksS0FBcUMsRUFBRSxFQUUxQyxDQUFDO0FBQ0YsRUFBRSwrSUFBa0U7QUFDcEUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3JlYWN0L2pzeC1ydW50aW1lLmpzPzM0ZDAiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xyXG5cclxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicpIHtcclxuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY2pzL3JlYWN0LWpzeC1ydW50aW1lLnByb2R1Y3Rpb24ubWluLmpzJyk7XHJcbn0gZWxzZSB7XHJcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9yZWFjdC1qc3gtcnVudGltZS5kZXZlbG9wbWVudC5qcycpO1xyXG59XHJcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/react/jsx-runtime.js\n"));

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/extends.js":
/*!************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/extends.js ***!
  \************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ _extends; }\n/* harmony export */ });\nfunction _extends() {\r\n  _extends = Object.assign ? Object.assign.bind() : function (target) {\r\n    for (var i = 1; i < arguments.length; i++) {\r\n      var source = arguments[i];\r\n      for (var key in source) {\r\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\r\n          target[key] = source[key];\r\n        }\r\n      }\r\n    }\r\n    return target;\r\n  };\r\n  return _extends.apply(this, arguments);\r\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vZXh0ZW5kcy5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQWU7QUFDZjtBQUNBLG9CQUFvQixzQkFBc0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vZXh0ZW5kcy5qcz81NWViIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIF9leHRlbmRzKCkge1xyXG4gIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiA/IE9iamVjdC5hc3NpZ24uYmluZCgpIDogZnVuY3Rpb24gKHRhcmdldCkge1xyXG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTtcclxuICAgICAgZm9yICh2YXIga2V5IGluIHNvdXJjZSkge1xyXG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7XHJcbiAgICAgICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRhcmdldDtcclxuICB9O1xyXG4gIHJldHVybiBfZXh0ZW5kcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG59Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@babel/runtime/helpers/esm/extends.js\n"));

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/objectWithoutPropertiesLoose.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/objectWithoutPropertiesLoose.js ***!
  \*********************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ _objectWithoutPropertiesLoose; }\n/* harmony export */ });\nfunction _objectWithoutPropertiesLoose(source, excluded) {\r\n  if (source == null) return {};\r\n  var target = {};\r\n  var sourceKeys = Object.keys(source);\r\n  var key, i;\r\n  for (i = 0; i < sourceKeys.length; i++) {\r\n    key = sourceKeys[i];\r\n    if (excluded.indexOf(key) >= 0) continue;\r\n    target[key] = source[key];\r\n  }\r\n  return target;\r\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZS5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsdUJBQXVCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZS5qcz9hMDRjIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHNvdXJjZSwgZXhjbHVkZWQpIHtcclxuICBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTtcclxuICB2YXIgdGFyZ2V0ID0ge307XHJcbiAgdmFyIHNvdXJjZUtleXMgPSBPYmplY3Qua2V5cyhzb3VyY2UpO1xyXG4gIHZhciBrZXksIGk7XHJcbiAgZm9yIChpID0gMDsgaSA8IHNvdXJjZUtleXMubGVuZ3RoOyBpKyspIHtcclxuICAgIGtleSA9IHNvdXJjZUtleXNbaV07XHJcbiAgICBpZiAoZXhjbHVkZWQuaW5kZXhPZihrZXkpID49IDApIGNvbnRpbnVlO1xyXG4gICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcclxuICB9XHJcbiAgcmV0dXJuIHRhcmdldDtcclxufSJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@babel/runtime/helpers/esm/objectWithoutPropertiesLoose.js\n"));

/***/ }),

/***/ "./node_modules/@codemirror/autocomplete/dist/index.js":
/*!*************************************************************!*\
  !*** ./node_modules/@codemirror/autocomplete/dist/index.js ***!
  \*************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"CompletionContext\": function() { return /* binding */ CompletionContext; },\n/* harmony export */   \"acceptCompletion\": function() { return /* binding */ acceptCompletion; },\n/* harmony export */   \"autocompletion\": function() { return /* binding */ autocompletion; },\n/* harmony export */   \"clearSnippet\": function() { return /* binding */ clearSnippet; },\n/* harmony export */   \"closeBrackets\": function() { return /* binding */ closeBrackets; },\n/* harmony export */   \"closeBracketsKeymap\": function() { return /* binding */ closeBracketsKeymap; },\n/* harmony export */   \"closeCompletion\": function() { return /* binding */ closeCompletion; },\n/* harmony export */   \"completeAnyWord\": function() { return /* binding */ completeAnyWord; },\n/* harmony export */   \"completeFromList\": function() { return /* binding */ completeFromList; },\n/* harmony export */   \"completionKeymap\": function() { return /* binding */ completionKeymap; },\n/* harmony export */   \"completionStatus\": function() { return /* binding */ completionStatus; },\n/* harmony export */   \"currentCompletions\": function() { return /* binding */ currentCompletions; },\n/* harmony export */   \"deleteBracketPair\": function() { return /* binding */ deleteBracketPair; },\n/* harmony export */   \"ifIn\": function() { return /* binding */ ifIn; },\n/* harmony export */   \"ifNotIn\": function() { return /* binding */ ifNotIn; },\n/* harmony export */   \"insertBracket\": function() { return /* binding */ insertBracket; },\n/* harmony export */   \"insertCompletionText\": function() { return /* binding */ insertCompletionText; },\n/* harmony export */   \"moveCompletionSelection\": function() { return /* binding */ moveCompletionSelection; },\n/* harmony export */   \"nextSnippetField\": function() { return /* binding */ nextSnippetField; },\n/* harmony export */   \"pickedCompletion\": function() { return /* binding */ pickedCompletion; },\n/* harmony export */   \"prevSnippetField\": function() { return /* binding */ prevSnippetField; },\n/* harmony export */   \"selectedCompletion\": function() { return /* binding */ selectedCompletion; },\n/* harmony export */   \"selectedCompletionIndex\": function() { return /* binding */ selectedCompletionIndex; },\n/* harmony export */   \"setSelectedCompletion\": function() { return /* binding */ setSelectedCompletion; },\n/* harmony export */   \"snippet\": function() { return /* binding */ snippet; },\n/* harmony export */   \"snippetCompletion\": function() { return /* binding */ snippetCompletion; },\n/* harmony export */   \"snippetKeymap\": function() { return /* binding */ snippetKeymap; },\n/* harmony export */   \"startCompletion\": function() { return /* binding */ startCompletion; }\n/* harmony export */ });\n/* harmony import */ var _codemirror_state__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @codemirror/state */ \"./node_modules/@codemirror/state/dist/index.js\");\n/* harmony import */ var _codemirror_view__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @codemirror/view */ \"./node_modules/@codemirror/view/dist/index.js\");\n/* harmony import */ var _codemirror_language__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @codemirror/language */ \"./node_modules/@codemirror/language/dist/index.js\");\n\r\n\r\n\r\n\r\n/**\r\nAn instance of this is passed to completion source functions.\r\n*/\r\nclass CompletionContext {\r\n    /**\r\n    Create a new completion context. (Mostly useful for testing\r\n    completion sources—in the editor, the extension will create\r\n    these for you.)\r\n    */\r\n    constructor(\r\n    /**\r\n    The editor state that the completion happens in.\r\n    */\r\n    state, \r\n    /**\r\n    The position at which the completion is happening.\r\n    */\r\n    pos, \r\n    /**\r\n    Indicates whether completion was activated explicitly, or\r\n    implicitly by typing. The usual way to respond to this is to\r\n    only return completions when either there is part of a\r\n    completable entity before the cursor, or `explicit` is true.\r\n    */\r\n    explicit) {\r\n        this.state = state;\r\n        this.pos = pos;\r\n        this.explicit = explicit;\r\n        /**\r\n        @internal\r\n        */\r\n        this.abortListeners = [];\r\n    }\r\n    /**\r\n    Get the extent, content, and (if there is a token) type of the\r\n    token before `this.pos`.\r\n    */\r\n    tokenBefore(types) {\r\n        let token = (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_0__.syntaxTree)(this.state).resolveInner(this.pos, -1);\r\n        while (token && types.indexOf(token.name) < 0)\r\n            token = token.parent;\r\n        return token ? { from: token.from, to: this.pos,\r\n            text: this.state.sliceDoc(token.from, this.pos),\r\n            type: token.type } : null;\r\n    }\r\n    /**\r\n    Get the match of the given expression directly before the\r\n    cursor.\r\n    */\r\n    matchBefore(expr) {\r\n        let line = this.state.doc.lineAt(this.pos);\r\n        let start = Math.max(line.from, this.pos - 250);\r\n        let str = line.text.slice(start - line.from, this.pos - line.from);\r\n        let found = str.search(ensureAnchor(expr, false));\r\n        return found < 0 ? null : { from: start + found, to: this.pos, text: str.slice(found) };\r\n    }\r\n    /**\r\n    Yields true when the query has been aborted. Can be useful in\r\n    asynchronous queries to avoid doing work that will be ignored.\r\n    */\r\n    get aborted() { return this.abortListeners == null; }\r\n    /**\r\n    Allows you to register abort handlers, which will be called when\r\n    the query is\r\n    [aborted](https://codemirror.net/6/docs/ref/#autocomplete.CompletionContext.aborted).\r\n    */\r\n    addEventListener(type, listener) {\r\n        if (type == \"abort\" && this.abortListeners)\r\n            this.abortListeners.push(listener);\r\n    }\r\n}\r\nfunction toSet(chars) {\r\n    let flat = Object.keys(chars).join(\"\");\r\n    let words = /\\w/.test(flat);\r\n    if (words)\r\n        flat = flat.replace(/\\w/g, \"\");\r\n    return `[${words ? \"\\\\w\" : \"\"}${flat.replace(/[^\\w\\s]/g, \"\\\\$&\")}]`;\r\n}\r\nfunction prefixMatch(options) {\r\n    let first = Object.create(null), rest = Object.create(null);\r\n    for (let { label } of options) {\r\n        first[label[0]] = true;\r\n        for (let i = 1; i < label.length; i++)\r\n            rest[label[i]] = true;\r\n    }\r\n    let source = toSet(first) + toSet(rest) + \"*$\";\r\n    return [new RegExp(\"^\" + source), new RegExp(source)];\r\n}\r\n/**\r\nGiven a a fixed array of options, return an autocompleter that\r\ncompletes them.\r\n*/\r\nfunction completeFromList(list) {\r\n    let options = list.map(o => typeof o == \"string\" ? { label: o } : o);\r\n    let [validFor, match] = options.every(o => /^\\w+$/.test(o.label)) ? [/\\w*$/, /\\w+$/] : prefixMatch(options);\r\n    return (context) => {\r\n        let token = context.matchBefore(match);\r\n        return token || context.explicit ? { from: token ? token.from : context.pos, options, validFor } : null;\r\n    };\r\n}\r\n/**\r\nWrap the given completion source so that it will only fire when the\r\ncursor is in a syntax node with one of the given names.\r\n*/\r\nfunction ifIn(nodes, source) {\r\n    return (context) => {\r\n        for (let pos = (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_0__.syntaxTree)(context.state).resolveInner(context.pos, -1); pos; pos = pos.parent)\r\n            if (nodes.indexOf(pos.name) > -1)\r\n                return source(context);\r\n        return null;\r\n    };\r\n}\r\n/**\r\nWrap the given completion source so that it will not fire when the\r\ncursor is in a syntax node with one of the given names.\r\n*/\r\nfunction ifNotIn(nodes, source) {\r\n    return (context) => {\r\n        for (let pos = (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_0__.syntaxTree)(context.state).resolveInner(context.pos, -1); pos; pos = pos.parent)\r\n            if (nodes.indexOf(pos.name) > -1)\r\n                return null;\r\n        return source(context);\r\n    };\r\n}\r\nclass Option {\r\n    constructor(completion, source, match) {\r\n        this.completion = completion;\r\n        this.source = source;\r\n        this.match = match;\r\n    }\r\n}\r\nfunction cur(state) { return state.selection.main.head; }\r\n// Make sure the given regexp has a $ at its end and, if `start` is\r\n// true, a ^ at its start.\r\nfunction ensureAnchor(expr, start) {\r\n    var _a;\r\n    let { source } = expr;\r\n    let addStart = start && source[0] != \"^\", addEnd = source[source.length - 1] != \"$\";\r\n    if (!addStart && !addEnd)\r\n        return expr;\r\n    return new RegExp(`${addStart ? \"^\" : \"\"}(?:${source})${addEnd ? \"$\" : \"\"}`, (_a = expr.flags) !== null && _a !== void 0 ? _a : (expr.ignoreCase ? \"i\" : \"\"));\r\n}\r\n/**\r\nThis annotation is added to transactions that are produced by\r\npicking a completion.\r\n*/\r\nconst pickedCompletion = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.Annotation.define();\r\n/**\r\nHelper function that returns a transaction spec which inserts a\r\ncompletion's text in the main selection range, and any other\r\nselection range that has the same text in front of it.\r\n*/\r\nfunction insertCompletionText(state, text, from, to) {\r\n    return Object.assign(Object.assign({}, state.changeByRange(range => {\r\n        if (range == state.selection.main)\r\n            return {\r\n                changes: { from: from, to: to, insert: text },\r\n                range: _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.cursor(from + text.length)\r\n            };\r\n        let len = to - from;\r\n        if (!range.empty ||\r\n            len && state.sliceDoc(range.from - len, range.from) != state.sliceDoc(from, to))\r\n            return { range };\r\n        return {\r\n            changes: { from: range.from - len, to: range.from, insert: text },\r\n            range: _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.cursor(range.from - len + text.length)\r\n        };\r\n    })), { userEvent: \"input.complete\" });\r\n}\r\nfunction applyCompletion(view, option) {\r\n    const apply = option.completion.apply || option.completion.label;\r\n    let result = option.source;\r\n    if (typeof apply == \"string\")\r\n        view.dispatch(Object.assign(Object.assign({}, insertCompletionText(view.state, apply, result.from, result.to)), { annotations: pickedCompletion.of(option.completion) }));\r\n    else\r\n        apply(view, option.completion, result.from, result.to);\r\n}\r\nconst SourceCache = /*@__PURE__*/new WeakMap();\r\nfunction asSource(source) {\r\n    if (!Array.isArray(source))\r\n        return source;\r\n    let known = SourceCache.get(source);\r\n    if (!known)\r\n        SourceCache.set(source, known = completeFromList(source));\r\n    return known;\r\n}\r\n\r\n// A pattern matcher for fuzzy completion matching. Create an instance\r\n// once for a pattern, and then use that to match any number of\r\n// completions.\r\nclass FuzzyMatcher {\r\n    constructor(pattern) {\r\n        this.pattern = pattern;\r\n        this.chars = [];\r\n        this.folded = [];\r\n        // Buffers reused by calls to `match` to track matched character\r\n        // positions.\r\n        this.any = [];\r\n        this.precise = [];\r\n        this.byWord = [];\r\n        for (let p = 0; p < pattern.length;) {\r\n            let char = (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.codePointAt)(pattern, p), size = (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.codePointSize)(char);\r\n            this.chars.push(char);\r\n            let part = pattern.slice(p, p + size), upper = part.toUpperCase();\r\n            this.folded.push((0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.codePointAt)(upper == part ? part.toLowerCase() : upper, 0));\r\n            p += size;\r\n        }\r\n        this.astral = pattern.length != this.chars.length;\r\n    }\r\n    // Matches a given word (completion) against the pattern (input).\r\n    // Will return null for no match, and otherwise an array that starts\r\n    // with the match score, followed by any number of `from, to` pairs\r\n    // indicating the matched parts of `word`.\r\n    //\r\n    // The score is a number that is more negative the worse the match\r\n    // is. See `Penalty` above.\r\n    match(word) {\r\n        if (this.pattern.length == 0)\r\n            return [0];\r\n        if (word.length < this.pattern.length)\r\n            return null;\r\n        let { chars, folded, any, precise, byWord } = this;\r\n        // For single-character queries, only match when they occur right\r\n        // at the start\r\n        if (chars.length == 1) {\r\n            let first = (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.codePointAt)(word, 0);\r\n            return first == chars[0] ? [0, 0, (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.codePointSize)(first)]\r\n                : first == folded[0] ? [-200 /* Penalty.CaseFold */, 0, (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.codePointSize)(first)] : null;\r\n        }\r\n        let direct = word.indexOf(this.pattern);\r\n        if (direct == 0)\r\n            return [0, 0, this.pattern.length];\r\n        let len = chars.length, anyTo = 0;\r\n        if (direct < 0) {\r\n            for (let i = 0, e = Math.min(word.length, 200); i < e && anyTo < len;) {\r\n                let next = (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.codePointAt)(word, i);\r\n                if (next == chars[anyTo] || next == folded[anyTo])\r\n                    any[anyTo++] = i;\r\n                i += (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.codePointSize)(next);\r\n            }\r\n            // No match, exit immediately\r\n            if (anyTo < len)\r\n                return null;\r\n        }\r\n        // This tracks the extent of the precise (non-folded, not\r\n        // necessarily adjacent) match\r\n        let preciseTo = 0;\r\n        // Tracks whether there is a match that hits only characters that\r\n        // appear to be starting words. `byWordFolded` is set to true when\r\n        // a case folded character is encountered in such a match\r\n        let byWordTo = 0, byWordFolded = false;\r\n        // If we've found a partial adjacent match, these track its state\r\n        let adjacentTo = 0, adjacentStart = -1, adjacentEnd = -1;\r\n        let hasLower = /[a-z]/.test(word), wordAdjacent = true;\r\n        // Go over the option's text, scanning for the various kinds of matches\r\n        for (let i = 0, e = Math.min(word.length, 200), prevType = 0 /* Tp.NonWord */; i < e && byWordTo < len;) {\r\n            let next = (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.codePointAt)(word, i);\r\n            if (direct < 0) {\r\n                if (preciseTo < len && next == chars[preciseTo])\r\n                    precise[preciseTo++] = i;\r\n                if (adjacentTo < len) {\r\n                    if (next == chars[adjacentTo] || next == folded[adjacentTo]) {\r\n                        if (adjacentTo == 0)\r\n                            adjacentStart = i;\r\n                        adjacentEnd = i + 1;\r\n                        adjacentTo++;\r\n                    }\r\n                    else {\r\n                        adjacentTo = 0;\r\n                    }\r\n                }\r\n            }\r\n            let ch, type = next < 0xff\r\n                ? (next >= 48 && next <= 57 || next >= 97 && next <= 122 ? 2 /* Tp.Lower */ : next >= 65 && next <= 90 ? 1 /* Tp.Upper */ : 0 /* Tp.NonWord */)\r\n                : ((ch = (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.fromCodePoint)(next)) != ch.toLowerCase() ? 1 /* Tp.Upper */ : ch != ch.toUpperCase() ? 2 /* Tp.Lower */ : 0 /* Tp.NonWord */);\r\n            if (!i || type == 1 /* Tp.Upper */ && hasLower || prevType == 0 /* Tp.NonWord */ && type != 0 /* Tp.NonWord */) {\r\n                if (chars[byWordTo] == next || (folded[byWordTo] == next && (byWordFolded = true)))\r\n                    byWord[byWordTo++] = i;\r\n                else if (byWord.length)\r\n                    wordAdjacent = false;\r\n            }\r\n            prevType = type;\r\n            i += (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.codePointSize)(next);\r\n        }\r\n        if (byWordTo == len && byWord[0] == 0 && wordAdjacent)\r\n            return this.result(-100 /* Penalty.ByWord */ + (byWordFolded ? -200 /* Penalty.CaseFold */ : 0), byWord, word);\r\n        if (adjacentTo == len && adjacentStart == 0)\r\n            return [-200 /* Penalty.CaseFold */ - word.length, 0, adjacentEnd];\r\n        if (direct > -1)\r\n            return [-700 /* Penalty.NotStart */ - word.length, direct, direct + this.pattern.length];\r\n        if (adjacentTo == len)\r\n            return [-200 /* Penalty.CaseFold */ + -700 /* Penalty.NotStart */ - word.length, adjacentStart, adjacentEnd];\r\n        if (byWordTo == len)\r\n            return this.result(-100 /* Penalty.ByWord */ + (byWordFolded ? -200 /* Penalty.CaseFold */ : 0) + -700 /* Penalty.NotStart */ +\r\n                (wordAdjacent ? 0 : -1100 /* Penalty.Gap */), byWord, word);\r\n        return chars.length == 2 ? null : this.result((any[0] ? -700 /* Penalty.NotStart */ : 0) + -200 /* Penalty.CaseFold */ + -1100 /* Penalty.Gap */, any, word);\r\n    }\r\n    result(score, positions, word) {\r\n        let result = [score - word.length], i = 1;\r\n        for (let pos of positions) {\r\n            let to = pos + (this.astral ? (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.codePointSize)((0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.codePointAt)(word, pos)) : 1);\r\n            if (i > 1 && result[i - 1] == pos)\r\n                result[i - 1] = to;\r\n            else {\r\n                result[i++] = pos;\r\n                result[i++] = to;\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n}\r\n\r\nconst completionConfig = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.Facet.define({\r\n    combine(configs) {\r\n        return (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.combineConfig)(configs, {\r\n            activateOnTyping: true,\r\n            selectOnOpen: true,\r\n            override: null,\r\n            closeOnBlur: true,\r\n            maxRenderedOptions: 100,\r\n            defaultKeymap: true,\r\n            tooltipClass: () => \"\",\r\n            optionClass: () => \"\",\r\n            aboveCursor: false,\r\n            icons: true,\r\n            addToOptions: [],\r\n            compareCompletions: (a, b) => a.label.localeCompare(b.label),\r\n            interactionDelay: 75\r\n        }, {\r\n            defaultKeymap: (a, b) => a && b,\r\n            closeOnBlur: (a, b) => a && b,\r\n            icons: (a, b) => a && b,\r\n            tooltipClass: (a, b) => c => joinClass(a(c), b(c)),\r\n            optionClass: (a, b) => c => joinClass(a(c), b(c)),\r\n            addToOptions: (a, b) => a.concat(b)\r\n        });\r\n    }\r\n});\r\nfunction joinClass(a, b) {\r\n    return a ? b ? a + \" \" + b : a : b;\r\n}\r\n\r\nfunction optionContent(config) {\r\n    let content = config.addToOptions.slice();\r\n    if (config.icons)\r\n        content.push({\r\n            render(completion) {\r\n                let icon = document.createElement(\"div\");\r\n                icon.classList.add(\"cm-completionIcon\");\r\n                if (completion.type)\r\n                    icon.classList.add(...completion.type.split(/\\s+/g).map(cls => \"cm-completionIcon-\" + cls));\r\n                icon.setAttribute(\"aria-hidden\", \"true\");\r\n                return icon;\r\n            },\r\n            position: 20\r\n        });\r\n    content.push({\r\n        render(completion, _s, match) {\r\n            let labelElt = document.createElement(\"span\");\r\n            labelElt.className = \"cm-completionLabel\";\r\n            let { label } = completion, off = 0;\r\n            for (let j = 1; j < match.length;) {\r\n                let from = match[j++], to = match[j++];\r\n                if (from > off)\r\n                    labelElt.appendChild(document.createTextNode(label.slice(off, from)));\r\n                let span = labelElt.appendChild(document.createElement(\"span\"));\r\n                span.appendChild(document.createTextNode(label.slice(from, to)));\r\n                span.className = \"cm-completionMatchedText\";\r\n                off = to;\r\n            }\r\n            if (off < label.length)\r\n                labelElt.appendChild(document.createTextNode(label.slice(off)));\r\n            return labelElt;\r\n        },\r\n        position: 50\r\n    }, {\r\n        render(completion) {\r\n            if (!completion.detail)\r\n                return null;\r\n            let detailElt = document.createElement(\"span\");\r\n            detailElt.className = \"cm-completionDetail\";\r\n            detailElt.textContent = completion.detail;\r\n            return detailElt;\r\n        },\r\n        position: 80\r\n    });\r\n    return content.sort((a, b) => a.position - b.position).map(a => a.render);\r\n}\r\nfunction rangeAroundSelected(total, selected, max) {\r\n    if (total <= max)\r\n        return { from: 0, to: total };\r\n    if (selected < 0)\r\n        selected = 0;\r\n    if (selected <= (total >> 1)) {\r\n        let off = Math.floor(selected / max);\r\n        return { from: off * max, to: (off + 1) * max };\r\n    }\r\n    let off = Math.floor((total - selected) / max);\r\n    return { from: total - (off + 1) * max, to: total - off * max };\r\n}\r\nclass CompletionTooltip {\r\n    constructor(view, stateField) {\r\n        this.view = view;\r\n        this.stateField = stateField;\r\n        this.info = null;\r\n        this.placeInfo = {\r\n            read: () => this.measureInfo(),\r\n            write: (pos) => this.positionInfo(pos),\r\n            key: this\r\n        };\r\n        this.space = null;\r\n        this.currentClass = \"\";\r\n        let cState = view.state.field(stateField);\r\n        let { options, selected } = cState.open;\r\n        let config = view.state.facet(completionConfig);\r\n        this.optionContent = optionContent(config);\r\n        this.optionClass = config.optionClass;\r\n        this.tooltipClass = config.tooltipClass;\r\n        this.range = rangeAroundSelected(options.length, selected, config.maxRenderedOptions);\r\n        this.dom = document.createElement(\"div\");\r\n        this.dom.className = \"cm-tooltip-autocomplete\";\r\n        this.updateTooltipClass(view.state);\r\n        this.dom.addEventListener(\"mousedown\", (e) => {\r\n            for (let dom = e.target, match; dom && dom != this.dom; dom = dom.parentNode) {\r\n                if (dom.nodeName == \"LI\" && (match = /-(\\d+)$/.exec(dom.id)) && +match[1] < options.length) {\r\n                    applyCompletion(view, options[+match[1]]);\r\n                    e.preventDefault();\r\n                    return;\r\n                }\r\n            }\r\n        });\r\n        this.list = this.dom.appendChild(this.createListBox(options, cState.id, this.range));\r\n        this.list.addEventListener(\"scroll\", () => {\r\n            if (this.info)\r\n                this.view.requestMeasure(this.placeInfo);\r\n        });\r\n    }\r\n    mount() { this.updateSel(); }\r\n    update(update) {\r\n        var _a, _b, _c;\r\n        let cState = update.state.field(this.stateField);\r\n        let prevState = update.startState.field(this.stateField);\r\n        this.updateTooltipClass(update.state);\r\n        if (cState != prevState) {\r\n            this.updateSel();\r\n            if (((_a = cState.open) === null || _a === void 0 ? void 0 : _a.disabled) != ((_b = prevState.open) === null || _b === void 0 ? void 0 : _b.disabled))\r\n                this.dom.classList.toggle(\"cm-tooltip-autocomplete-disabled\", !!((_c = cState.open) === null || _c === void 0 ? void 0 : _c.disabled));\r\n        }\r\n    }\r\n    updateTooltipClass(state) {\r\n        let cls = this.tooltipClass(state);\r\n        if (cls != this.currentClass) {\r\n            for (let c of this.currentClass.split(\" \"))\r\n                if (c)\r\n                    this.dom.classList.remove(c);\r\n            for (let c of cls.split(\" \"))\r\n                if (c)\r\n                    this.dom.classList.add(c);\r\n            this.currentClass = cls;\r\n        }\r\n    }\r\n    positioned(space) {\r\n        this.space = space;\r\n        if (this.info)\r\n            this.view.requestMeasure(this.placeInfo);\r\n    }\r\n    updateSel() {\r\n        let cState = this.view.state.field(this.stateField), open = cState.open;\r\n        if (open.selected > -1 && open.selected < this.range.from || open.selected >= this.range.to) {\r\n            this.range = rangeAroundSelected(open.options.length, open.selected, this.view.state.facet(completionConfig).maxRenderedOptions);\r\n            this.list.remove();\r\n            this.list = this.dom.appendChild(this.createListBox(open.options, cState.id, this.range));\r\n            this.list.addEventListener(\"scroll\", () => {\r\n                if (this.info)\r\n                    this.view.requestMeasure(this.placeInfo);\r\n            });\r\n        }\r\n        if (this.updateSelectedOption(open.selected)) {\r\n            if (this.info) {\r\n                this.info.remove();\r\n                this.info = null;\r\n            }\r\n            let { completion } = open.options[open.selected];\r\n            let { info } = completion;\r\n            if (!info)\r\n                return;\r\n            let infoResult = typeof info === 'string' ? document.createTextNode(info) : info(completion);\r\n            if (!infoResult)\r\n                return;\r\n            if ('then' in infoResult) {\r\n                infoResult.then(node => {\r\n                    if (node && this.view.state.field(this.stateField, false) == cState)\r\n                        this.addInfoPane(node);\r\n                }).catch(e => (0,_codemirror_view__WEBPACK_IMPORTED_MODULE_2__.logException)(this.view.state, e, \"completion info\"));\r\n            }\r\n            else {\r\n                this.addInfoPane(infoResult);\r\n            }\r\n        }\r\n    }\r\n    addInfoPane(content) {\r\n        let dom = this.info = document.createElement(\"div\");\r\n        dom.className = \"cm-tooltip cm-completionInfo\";\r\n        dom.appendChild(content);\r\n        this.dom.appendChild(dom);\r\n        this.view.requestMeasure(this.placeInfo);\r\n    }\r\n    updateSelectedOption(selected) {\r\n        let set = null;\r\n        for (let opt = this.list.firstChild, i = this.range.from; opt; opt = opt.nextSibling, i++) {\r\n            if (i == selected) {\r\n                if (!opt.hasAttribute(\"aria-selected\")) {\r\n                    opt.setAttribute(\"aria-selected\", \"true\");\r\n                    set = opt;\r\n                }\r\n            }\r\n            else {\r\n                if (opt.hasAttribute(\"aria-selected\"))\r\n                    opt.removeAttribute(\"aria-selected\");\r\n            }\r\n        }\r\n        if (set)\r\n            scrollIntoView(this.list, set);\r\n        return set;\r\n    }\r\n    measureInfo() {\r\n        let sel = this.dom.querySelector(\"[aria-selected]\");\r\n        if (!sel || !this.info)\r\n            return null;\r\n        let listRect = this.dom.getBoundingClientRect();\r\n        let infoRect = this.info.getBoundingClientRect();\r\n        let selRect = sel.getBoundingClientRect();\r\n        let space = this.space;\r\n        if (!space) {\r\n            let win = this.dom.ownerDocument.defaultView || window;\r\n            space = { left: 0, top: 0, right: win.innerWidth, bottom: win.innerHeight };\r\n        }\r\n        if (selRect.top > Math.min(space.bottom, listRect.bottom) - 10 ||\r\n            selRect.bottom < Math.max(space.top, listRect.top) + 10)\r\n            return null;\r\n        let rtl = this.view.textDirection == _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.Direction.RTL, left = rtl, narrow = false, maxWidth;\r\n        let top = \"\", bottom = \"\";\r\n        let spaceLeft = listRect.left - space.left, spaceRight = space.right - listRect.right;\r\n        if (left && spaceLeft < Math.min(infoRect.width, spaceRight))\r\n            left = false;\r\n        else if (!left && spaceRight < Math.min(infoRect.width, spaceLeft))\r\n            left = true;\r\n        if (infoRect.width <= (left ? spaceLeft : spaceRight)) {\r\n            top = (Math.max(space.top, Math.min(selRect.top, space.bottom - infoRect.height)) - listRect.top) + \"px\";\r\n            maxWidth = Math.min(400 /* Info.Width */, left ? spaceLeft : spaceRight) + \"px\";\r\n        }\r\n        else {\r\n            narrow = true;\r\n            maxWidth = Math.min(400 /* Info.Width */, (rtl ? listRect.right : space.right - listRect.left) - 30 /* Info.Margin */) + \"px\";\r\n            let spaceBelow = space.bottom - listRect.bottom;\r\n            if (spaceBelow >= infoRect.height || spaceBelow > listRect.top) // Below the completion\r\n                top = (selRect.bottom - listRect.top) + \"px\";\r\n            else // Above it\r\n                bottom = (listRect.bottom - selRect.top) + \"px\";\r\n        }\r\n        return {\r\n            top, bottom, maxWidth,\r\n            class: narrow ? (rtl ? \"left-narrow\" : \"right-narrow\") : left ? \"left\" : \"right\",\r\n        };\r\n    }\r\n    positionInfo(pos) {\r\n        if (this.info) {\r\n            if (pos) {\r\n                this.info.style.top = pos.top;\r\n                this.info.style.bottom = pos.bottom;\r\n                this.info.style.maxWidth = pos.maxWidth;\r\n                this.info.className = \"cm-tooltip cm-completionInfo cm-completionInfo-\" + pos.class;\r\n            }\r\n            else {\r\n                this.info.style.top = \"-1e6px\";\r\n            }\r\n        }\r\n    }\r\n    createListBox(options, id, range) {\r\n        const ul = document.createElement(\"ul\");\r\n        ul.id = id;\r\n        ul.setAttribute(\"role\", \"listbox\");\r\n        ul.setAttribute(\"aria-expanded\", \"true\");\r\n        ul.setAttribute(\"aria-label\", this.view.state.phrase(\"Completions\"));\r\n        for (let i = range.from; i < range.to; i++) {\r\n            let { completion, match } = options[i];\r\n            const li = ul.appendChild(document.createElement(\"li\"));\r\n            li.id = id + \"-\" + i;\r\n            li.setAttribute(\"role\", \"option\");\r\n            let cls = this.optionClass(completion);\r\n            if (cls)\r\n                li.className = cls;\r\n            for (let source of this.optionContent) {\r\n                let node = source(completion, this.view.state, match);\r\n                if (node)\r\n                    li.appendChild(node);\r\n            }\r\n        }\r\n        if (range.from)\r\n            ul.classList.add(\"cm-completionListIncompleteTop\");\r\n        if (range.to < options.length)\r\n            ul.classList.add(\"cm-completionListIncompleteBottom\");\r\n        return ul;\r\n    }\r\n}\r\n// We allocate a new function instance every time the completion\r\n// changes to force redrawing/repositioning of the tooltip\r\nfunction completionTooltip(stateField) {\r\n    return (view) => new CompletionTooltip(view, stateField);\r\n}\r\nfunction scrollIntoView(container, element) {\r\n    let parent = container.getBoundingClientRect();\r\n    let self = element.getBoundingClientRect();\r\n    if (self.top < parent.top)\r\n        container.scrollTop -= parent.top - self.top;\r\n    else if (self.bottom > parent.bottom)\r\n        container.scrollTop += self.bottom - parent.bottom;\r\n}\r\n\r\n// Used to pick a preferred option when two options with the same\r\n// label occur in the result.\r\nfunction score(option) {\r\n    return (option.boost || 0) * 100 + (option.apply ? 10 : 0) + (option.info ? 5 : 0) +\r\n        (option.type ? 1 : 0);\r\n}\r\nfunction sortOptions(active, state) {\r\n    let options = [], i = 0;\r\n    for (let a of active)\r\n        if (a.hasResult()) {\r\n            if (a.result.filter === false) {\r\n                let getMatch = a.result.getMatch;\r\n                for (let option of a.result.options) {\r\n                    let match = [1e9 - i++];\r\n                    if (getMatch)\r\n                        for (let n of getMatch(option))\r\n                            match.push(n);\r\n                    options.push(new Option(option, a, match));\r\n                }\r\n            }\r\n            else {\r\n                let matcher = new FuzzyMatcher(state.sliceDoc(a.from, a.to)), match;\r\n                for (let option of a.result.options)\r\n                    if (match = matcher.match(option.label)) {\r\n                        if (option.boost != null)\r\n                            match[0] += option.boost;\r\n                        options.push(new Option(option, a, match));\r\n                    }\r\n            }\r\n        }\r\n    let result = [], prev = null;\r\n    let compare = state.facet(completionConfig).compareCompletions;\r\n    for (let opt of options.sort((a, b) => (b.match[0] - a.match[0]) || compare(a.completion, b.completion))) {\r\n        if (!prev || prev.label != opt.completion.label || prev.detail != opt.completion.detail ||\r\n            (prev.type != null && opt.completion.type != null && prev.type != opt.completion.type) ||\r\n            prev.apply != opt.completion.apply)\r\n            result.push(opt);\r\n        else if (score(opt.completion) > score(prev))\r\n            result[result.length - 1] = opt;\r\n        prev = opt.completion;\r\n    }\r\n    return result;\r\n}\r\nclass CompletionDialog {\r\n    constructor(options, attrs, tooltip, timestamp, selected, disabled) {\r\n        this.options = options;\r\n        this.attrs = attrs;\r\n        this.tooltip = tooltip;\r\n        this.timestamp = timestamp;\r\n        this.selected = selected;\r\n        this.disabled = disabled;\r\n    }\r\n    setSelected(selected, id) {\r\n        return selected == this.selected || selected >= this.options.length ? this\r\n            : new CompletionDialog(this.options, makeAttrs(id, selected), this.tooltip, this.timestamp, selected, this.disabled);\r\n    }\r\n    static build(active, state, id, prev, conf) {\r\n        let options = sortOptions(active, state);\r\n        if (!options.length) {\r\n            return prev && active.some(a => a.state == 1 /* State.Pending */) ?\r\n                new CompletionDialog(prev.options, prev.attrs, prev.tooltip, prev.timestamp, prev.selected, true) : null;\r\n        }\r\n        let selected = state.facet(completionConfig).selectOnOpen ? 0 : -1;\r\n        if (prev && prev.selected != selected && prev.selected != -1) {\r\n            let selectedValue = prev.options[prev.selected].completion;\r\n            for (let i = 0; i < options.length; i++)\r\n                if (options[i].completion == selectedValue) {\r\n                    selected = i;\r\n                    break;\r\n                }\r\n        }\r\n        return new CompletionDialog(options, makeAttrs(id, selected), {\r\n            pos: active.reduce((a, b) => b.hasResult() ? Math.min(a, b.from) : a, 1e8),\r\n            create: completionTooltip(completionState),\r\n            above: conf.aboveCursor,\r\n        }, prev ? prev.timestamp : Date.now(), selected, false);\r\n    }\r\n    map(changes) {\r\n        return new CompletionDialog(this.options, this.attrs, Object.assign(Object.assign({}, this.tooltip), { pos: changes.mapPos(this.tooltip.pos) }), this.timestamp, this.selected, this.disabled);\r\n    }\r\n}\r\nclass CompletionState {\r\n    constructor(active, id, open) {\r\n        this.active = active;\r\n        this.id = id;\r\n        this.open = open;\r\n    }\r\n    static start() {\r\n        return new CompletionState(none, \"cm-ac-\" + Math.floor(Math.random() * 2e6).toString(36), null);\r\n    }\r\n    update(tr) {\r\n        let { state } = tr, conf = state.facet(completionConfig);\r\n        let sources = conf.override ||\r\n            state.languageDataAt(\"autocomplete\", cur(state)).map(asSource);\r\n        let active = sources.map(source => {\r\n            let value = this.active.find(s => s.source == source) ||\r\n                new ActiveSource(source, this.active.some(a => a.state != 0 /* State.Inactive */) ? 1 /* State.Pending */ : 0 /* State.Inactive */);\r\n            return value.update(tr, conf);\r\n        });\r\n        if (active.length == this.active.length && active.every((a, i) => a == this.active[i]))\r\n            active = this.active;\r\n        let open = this.open;\r\n        if (open && tr.docChanged)\r\n            open = open.map(tr.changes);\r\n        if (tr.selection || active.some(a => a.hasResult() && tr.changes.touchesRange(a.from, a.to)) ||\r\n            !sameResults(active, this.active))\r\n            open = CompletionDialog.build(active, state, this.id, open, conf);\r\n        else if (open && open.disabled && !active.some(a => a.state == 1 /* State.Pending */))\r\n            open = null;\r\n        if (!open && active.every(a => a.state != 1 /* State.Pending */) && active.some(a => a.hasResult()))\r\n            active = active.map(a => a.hasResult() ? new ActiveSource(a.source, 0 /* State.Inactive */) : a);\r\n        for (let effect of tr.effects)\r\n            if (effect.is(setSelectedEffect))\r\n                open = open && open.setSelected(effect.value, this.id);\r\n        return active == this.active && open == this.open ? this : new CompletionState(active, this.id, open);\r\n    }\r\n    get tooltip() { return this.open ? this.open.tooltip : null; }\r\n    get attrs() { return this.open ? this.open.attrs : baseAttrs; }\r\n}\r\nfunction sameResults(a, b) {\r\n    if (a == b)\r\n        return true;\r\n    for (let iA = 0, iB = 0;;) {\r\n        while (iA < a.length && !a[iA].hasResult)\r\n            iA++;\r\n        while (iB < b.length && !b[iB].hasResult)\r\n            iB++;\r\n        let endA = iA == a.length, endB = iB == b.length;\r\n        if (endA || endB)\r\n            return endA == endB;\r\n        if (a[iA++].result != b[iB++].result)\r\n            return false;\r\n    }\r\n}\r\nconst baseAttrs = {\r\n    \"aria-autocomplete\": \"list\"\r\n};\r\nfunction makeAttrs(id, selected) {\r\n    let result = {\r\n        \"aria-autocomplete\": \"list\",\r\n        \"aria-haspopup\": \"listbox\",\r\n        \"aria-controls\": id\r\n    };\r\n    if (selected > -1)\r\n        result[\"aria-activedescendant\"] = id + \"-\" + selected;\r\n    return result;\r\n}\r\nconst none = [];\r\nfunction getUserEvent(tr) {\r\n    return tr.isUserEvent(\"input.type\") ? \"input\" : tr.isUserEvent(\"delete.backward\") ? \"delete\" : null;\r\n}\r\nclass ActiveSource {\r\n    constructor(source, state, explicitPos = -1) {\r\n        this.source = source;\r\n        this.state = state;\r\n        this.explicitPos = explicitPos;\r\n    }\r\n    hasResult() { return false; }\r\n    update(tr, conf) {\r\n        let event = getUserEvent(tr), value = this;\r\n        if (event)\r\n            value = value.handleUserEvent(tr, event, conf);\r\n        else if (tr.docChanged)\r\n            value = value.handleChange(tr);\r\n        else if (tr.selection && value.state != 0 /* State.Inactive */)\r\n            value = new ActiveSource(value.source, 0 /* State.Inactive */);\r\n        for (let effect of tr.effects) {\r\n            if (effect.is(startCompletionEffect))\r\n                value = new ActiveSource(value.source, 1 /* State.Pending */, effect.value ? cur(tr.state) : -1);\r\n            else if (effect.is(closeCompletionEffect))\r\n                value = new ActiveSource(value.source, 0 /* State.Inactive */);\r\n            else if (effect.is(setActiveEffect))\r\n                for (let active of effect.value)\r\n                    if (active.source == value.source)\r\n                        value = active;\r\n        }\r\n        return value;\r\n    }\r\n    handleUserEvent(tr, type, conf) {\r\n        return type == \"delete\" || !conf.activateOnTyping ? this.map(tr.changes) : new ActiveSource(this.source, 1 /* State.Pending */);\r\n    }\r\n    handleChange(tr) {\r\n        return tr.changes.touchesRange(cur(tr.startState)) ? new ActiveSource(this.source, 0 /* State.Inactive */) : this.map(tr.changes);\r\n    }\r\n    map(changes) {\r\n        return changes.empty || this.explicitPos < 0 ? this : new ActiveSource(this.source, this.state, changes.mapPos(this.explicitPos));\r\n    }\r\n}\r\nclass ActiveResult extends ActiveSource {\r\n    constructor(source, explicitPos, result, from, to) {\r\n        super(source, 2 /* State.Result */, explicitPos);\r\n        this.result = result;\r\n        this.from = from;\r\n        this.to = to;\r\n    }\r\n    hasResult() { return true; }\r\n    handleUserEvent(tr, type, conf) {\r\n        var _a;\r\n        let from = tr.changes.mapPos(this.from), to = tr.changes.mapPos(this.to, 1);\r\n        let pos = cur(tr.state);\r\n        if ((this.explicitPos < 0 ? pos <= from : pos < this.from) ||\r\n            pos > to ||\r\n            type == \"delete\" && cur(tr.startState) == this.from)\r\n            return new ActiveSource(this.source, type == \"input\" && conf.activateOnTyping ? 1 /* State.Pending */ : 0 /* State.Inactive */);\r\n        let explicitPos = this.explicitPos < 0 ? -1 : tr.changes.mapPos(this.explicitPos), updated;\r\n        if (checkValid(this.result.validFor, tr.state, from, to))\r\n            return new ActiveResult(this.source, explicitPos, this.result, from, to);\r\n        if (this.result.update &&\r\n            (updated = this.result.update(this.result, from, to, new CompletionContext(tr.state, pos, explicitPos >= 0))))\r\n            return new ActiveResult(this.source, explicitPos, updated, updated.from, (_a = updated.to) !== null && _a !== void 0 ? _a : cur(tr.state));\r\n        return new ActiveSource(this.source, 1 /* State.Pending */, explicitPos);\r\n    }\r\n    handleChange(tr) {\r\n        return tr.changes.touchesRange(this.from, this.to) ? new ActiveSource(this.source, 0 /* State.Inactive */) : this.map(tr.changes);\r\n    }\r\n    map(mapping) {\r\n        return mapping.empty ? this :\r\n            new ActiveResult(this.source, this.explicitPos < 0 ? -1 : mapping.mapPos(this.explicitPos), this.result, mapping.mapPos(this.from), mapping.mapPos(this.to, 1));\r\n    }\r\n}\r\nfunction checkValid(validFor, state, from, to) {\r\n    if (!validFor)\r\n        return false;\r\n    let text = state.sliceDoc(from, to);\r\n    return typeof validFor == \"function\" ? validFor(text, from, to, state) : ensureAnchor(validFor, true).test(text);\r\n}\r\nconst startCompletionEffect = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.StateEffect.define();\r\nconst closeCompletionEffect = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.StateEffect.define();\r\nconst setActiveEffect = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.StateEffect.define({\r\n    map(sources, mapping) { return sources.map(s => s.map(mapping)); }\r\n});\r\nconst setSelectedEffect = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.StateEffect.define();\r\nconst completionState = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.StateField.define({\r\n    create() { return CompletionState.start(); },\r\n    update(value, tr) { return value.update(tr); },\r\n    provide: f => [\r\n        _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.showTooltip.from(f, val => val.tooltip),\r\n        _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.EditorView.contentAttributes.from(f, state => state.attrs)\r\n    ]\r\n});\r\n\r\n/**\r\nReturns a command that moves the completion selection forward or\r\nbackward by the given amount.\r\n*/\r\nfunction moveCompletionSelection(forward, by = \"option\") {\r\n    return (view) => {\r\n        let cState = view.state.field(completionState, false);\r\n        if (!cState || !cState.open || cState.open.disabled ||\r\n            Date.now() - cState.open.timestamp < view.state.facet(completionConfig).interactionDelay)\r\n            return false;\r\n        let step = 1, tooltip;\r\n        if (by == \"page\" && (tooltip = (0,_codemirror_view__WEBPACK_IMPORTED_MODULE_2__.getTooltip)(view, cState.open.tooltip)))\r\n            step = Math.max(2, Math.floor(tooltip.dom.offsetHeight /\r\n                tooltip.dom.querySelector(\"li\").offsetHeight) - 1);\r\n        let { length } = cState.open.options;\r\n        let selected = cState.open.selected > -1 ? cState.open.selected + step * (forward ? 1 : -1) : forward ? 0 : length - 1;\r\n        if (selected < 0)\r\n            selected = by == \"page\" ? 0 : length - 1;\r\n        else if (selected >= length)\r\n            selected = by == \"page\" ? length - 1 : 0;\r\n        view.dispatch({ effects: setSelectedEffect.of(selected) });\r\n        return true;\r\n    };\r\n}\r\n/**\r\nAccept the current completion.\r\n*/\r\nconst acceptCompletion = (view) => {\r\n    let cState = view.state.field(completionState, false);\r\n    if (view.state.readOnly || !cState || !cState.open || cState.open.selected < 0 ||\r\n        Date.now() - cState.open.timestamp < view.state.facet(completionConfig).interactionDelay)\r\n        return false;\r\n    if (!cState.open.disabled)\r\n        applyCompletion(view, cState.open.options[cState.open.selected]);\r\n    return true;\r\n};\r\n/**\r\nExplicitly start autocompletion.\r\n*/\r\nconst startCompletion = (view) => {\r\n    let cState = view.state.field(completionState, false);\r\n    if (!cState)\r\n        return false;\r\n    view.dispatch({ effects: startCompletionEffect.of(true) });\r\n    return true;\r\n};\r\n/**\r\nClose the currently active completion.\r\n*/\r\nconst closeCompletion = (view) => {\r\n    let cState = view.state.field(completionState, false);\r\n    if (!cState || !cState.active.some(a => a.state != 0 /* State.Inactive */))\r\n        return false;\r\n    view.dispatch({ effects: closeCompletionEffect.of(null) });\r\n    return true;\r\n};\r\nclass RunningQuery {\r\n    constructor(active, context) {\r\n        this.active = active;\r\n        this.context = context;\r\n        this.time = Date.now();\r\n        this.updates = [];\r\n        // Note that 'undefined' means 'not done yet', whereas 'null' means\r\n        // 'query returned null'.\r\n        this.done = undefined;\r\n    }\r\n}\r\nconst DebounceTime = 50, MaxUpdateCount = 50, MinAbortTime = 1000;\r\nconst completionPlugin = /*@__PURE__*/_codemirror_view__WEBPACK_IMPORTED_MODULE_2__.ViewPlugin.fromClass(class {\r\n    constructor(view) {\r\n        this.view = view;\r\n        this.debounceUpdate = -1;\r\n        this.running = [];\r\n        this.debounceAccept = -1;\r\n        this.composing = 0 /* CompositionState.None */;\r\n        for (let active of view.state.field(completionState).active)\r\n            if (active.state == 1 /* State.Pending */)\r\n                this.startQuery(active);\r\n    }\r\n    update(update) {\r\n        let cState = update.state.field(completionState);\r\n        if (!update.selectionSet && !update.docChanged && update.startState.field(completionState) == cState)\r\n            return;\r\n        let doesReset = update.transactions.some(tr => {\r\n            return (tr.selection || tr.docChanged) && !getUserEvent(tr);\r\n        });\r\n        for (let i = 0; i < this.running.length; i++) {\r\n            let query = this.running[i];\r\n            if (doesReset ||\r\n                query.updates.length + update.transactions.length > MaxUpdateCount && Date.now() - query.time > MinAbortTime) {\r\n                for (let handler of query.context.abortListeners) {\r\n                    try {\r\n                        handler();\r\n                    }\r\n                    catch (e) {\r\n                        (0,_codemirror_view__WEBPACK_IMPORTED_MODULE_2__.logException)(this.view.state, e);\r\n                    }\r\n                }\r\n                query.context.abortListeners = null;\r\n                this.running.splice(i--, 1);\r\n            }\r\n            else {\r\n                query.updates.push(...update.transactions);\r\n            }\r\n        }\r\n        if (this.debounceUpdate > -1)\r\n            clearTimeout(this.debounceUpdate);\r\n        this.debounceUpdate = cState.active.some(a => a.state == 1 /* State.Pending */ && !this.running.some(q => q.active.source == a.source))\r\n            ? setTimeout(() => this.startUpdate(), DebounceTime) : -1;\r\n        if (this.composing != 0 /* CompositionState.None */)\r\n            for (let tr of update.transactions) {\r\n                if (getUserEvent(tr) == \"input\")\r\n                    this.composing = 2 /* CompositionState.Changed */;\r\n                else if (this.composing == 2 /* CompositionState.Changed */ && tr.selection)\r\n                    this.composing = 3 /* CompositionState.ChangedAndMoved */;\r\n            }\r\n    }\r\n    startUpdate() {\r\n        this.debounceUpdate = -1;\r\n        let { state } = this.view, cState = state.field(completionState);\r\n        for (let active of cState.active) {\r\n            if (active.state == 1 /* State.Pending */ && !this.running.some(r => r.active.source == active.source))\r\n                this.startQuery(active);\r\n        }\r\n    }\r\n    startQuery(active) {\r\n        let { state } = this.view, pos = cur(state);\r\n        let context = new CompletionContext(state, pos, active.explicitPos == pos);\r\n        let pending = new RunningQuery(active, context);\r\n        this.running.push(pending);\r\n        Promise.resolve(active.source(context)).then(result => {\r\n            if (!pending.context.aborted) {\r\n                pending.done = result || null;\r\n                this.scheduleAccept();\r\n            }\r\n        }, err => {\r\n            this.view.dispatch({ effects: closeCompletionEffect.of(null) });\r\n            (0,_codemirror_view__WEBPACK_IMPORTED_MODULE_2__.logException)(this.view.state, err);\r\n        });\r\n    }\r\n    scheduleAccept() {\r\n        if (this.running.every(q => q.done !== undefined))\r\n            this.accept();\r\n        else if (this.debounceAccept < 0)\r\n            this.debounceAccept = setTimeout(() => this.accept(), DebounceTime);\r\n    }\r\n    // For each finished query in this.running, try to create a result\r\n    // or, if appropriate, restart the query.\r\n    accept() {\r\n        var _a;\r\n        if (this.debounceAccept > -1)\r\n            clearTimeout(this.debounceAccept);\r\n        this.debounceAccept = -1;\r\n        let updated = [];\r\n        let conf = this.view.state.facet(completionConfig);\r\n        for (let i = 0; i < this.running.length; i++) {\r\n            let query = this.running[i];\r\n            if (query.done === undefined)\r\n                continue;\r\n            this.running.splice(i--, 1);\r\n            if (query.done) {\r\n                let active = new ActiveResult(query.active.source, query.active.explicitPos, query.done, query.done.from, (_a = query.done.to) !== null && _a !== void 0 ? _a : cur(query.updates.length ? query.updates[0].startState : this.view.state));\r\n                // Replay the transactions that happened since the start of\r\n                // the request and see if that preserves the result\r\n                for (let tr of query.updates)\r\n                    active = active.update(tr, conf);\r\n                if (active.hasResult()) {\r\n                    updated.push(active);\r\n                    continue;\r\n                }\r\n            }\r\n            let current = this.view.state.field(completionState).active.find(a => a.source == query.active.source);\r\n            if (current && current.state == 1 /* State.Pending */) {\r\n                if (query.done == null) {\r\n                    // Explicitly failed. Should clear the pending status if it\r\n                    // hasn't been re-set in the meantime.\r\n                    let active = new ActiveSource(query.active.source, 0 /* State.Inactive */);\r\n                    for (let tr of query.updates)\r\n                        active = active.update(tr, conf);\r\n                    if (active.state != 1 /* State.Pending */)\r\n                        updated.push(active);\r\n                }\r\n                else {\r\n                    // Cleared by subsequent transactions. Restart.\r\n                    this.startQuery(current);\r\n                }\r\n            }\r\n        }\r\n        if (updated.length)\r\n            this.view.dispatch({ effects: setActiveEffect.of(updated) });\r\n    }\r\n}, {\r\n    eventHandlers: {\r\n        blur() {\r\n            let state = this.view.state.field(completionState, false);\r\n            if (state && state.tooltip && this.view.state.facet(completionConfig).closeOnBlur)\r\n                this.view.dispatch({ effects: closeCompletionEffect.of(null) });\r\n        },\r\n        compositionstart() {\r\n            this.composing = 1 /* CompositionState.Started */;\r\n        },\r\n        compositionend() {\r\n            if (this.composing == 3 /* CompositionState.ChangedAndMoved */) {\r\n                // Safari fires compositionend events synchronously, possibly\r\n                // from inside an update, so dispatch asynchronously to avoid reentrancy\r\n                setTimeout(() => this.view.dispatch({ effects: startCompletionEffect.of(false) }), 20);\r\n            }\r\n            this.composing = 0 /* CompositionState.None */;\r\n        }\r\n    }\r\n});\r\n\r\nconst baseTheme = /*@__PURE__*/_codemirror_view__WEBPACK_IMPORTED_MODULE_2__.EditorView.baseTheme({\r\n    \".cm-tooltip.cm-tooltip-autocomplete\": {\r\n        \"& > ul\": {\r\n            fontFamily: \"monospace\",\r\n            whiteSpace: \"nowrap\",\r\n            overflow: \"hidden auto\",\r\n            maxWidth_fallback: \"700px\",\r\n            maxWidth: \"min(700px, 95vw)\",\r\n            minWidth: \"250px\",\r\n            maxHeight: \"10em\",\r\n            height: \"100%\",\r\n            listStyle: \"none\",\r\n            margin: 0,\r\n            padding: 0,\r\n            \"& > li\": {\r\n                overflowX: \"hidden\",\r\n                textOverflow: \"ellipsis\",\r\n                cursor: \"pointer\",\r\n                padding: \"1px 3px\",\r\n                lineHeight: 1.2\r\n            },\r\n        }\r\n    },\r\n    \"&light .cm-tooltip-autocomplete ul li[aria-selected]\": {\r\n        background: \"#17c\",\r\n        color: \"white\",\r\n    },\r\n    \"&light .cm-tooltip-autocomplete-disabled ul li[aria-selected]\": {\r\n        background: \"#777\",\r\n    },\r\n    \"&dark .cm-tooltip-autocomplete ul li[aria-selected]\": {\r\n        background: \"#347\",\r\n        color: \"white\",\r\n    },\r\n    \"&dark .cm-tooltip-autocomplete-disabled ul li[aria-selected]\": {\r\n        background: \"#444\",\r\n    },\r\n    \".cm-completionListIncompleteTop:before, .cm-completionListIncompleteBottom:after\": {\r\n        content: '\"···\"',\r\n        opacity: 0.5,\r\n        display: \"block\",\r\n        textAlign: \"center\"\r\n    },\r\n    \".cm-tooltip.cm-completionInfo\": {\r\n        position: \"absolute\",\r\n        padding: \"3px 9px\",\r\n        width: \"max-content\",\r\n        maxWidth: `${400 /* Info.Width */}px`,\r\n        boxSizing: \"border-box\"\r\n    },\r\n    \".cm-completionInfo.cm-completionInfo-left\": { right: \"100%\" },\r\n    \".cm-completionInfo.cm-completionInfo-right\": { left: \"100%\" },\r\n    \".cm-completionInfo.cm-completionInfo-left-narrow\": { right: `${30 /* Info.Margin */}px` },\r\n    \".cm-completionInfo.cm-completionInfo-right-narrow\": { left: `${30 /* Info.Margin */}px` },\r\n    \"&light .cm-snippetField\": { backgroundColor: \"#00000022\" },\r\n    \"&dark .cm-snippetField\": { backgroundColor: \"#ffffff22\" },\r\n    \".cm-snippetFieldPosition\": {\r\n        verticalAlign: \"text-top\",\r\n        width: 0,\r\n        height: \"1.15em\",\r\n        display: \"inline-block\",\r\n        margin: \"0 -0.7px -.7em\",\r\n        borderLeft: \"1.4px dotted #888\"\r\n    },\r\n    \".cm-completionMatchedText\": {\r\n        textDecoration: \"underline\"\r\n    },\r\n    \".cm-completionDetail\": {\r\n        marginLeft: \"0.5em\",\r\n        fontStyle: \"italic\"\r\n    },\r\n    \".cm-completionIcon\": {\r\n        fontSize: \"90%\",\r\n        width: \".8em\",\r\n        display: \"inline-block\",\r\n        textAlign: \"center\",\r\n        paddingRight: \".6em\",\r\n        opacity: \"0.6\",\r\n        boxSizing: \"content-box\"\r\n    },\r\n    \".cm-completionIcon-function, .cm-completionIcon-method\": {\r\n        \"&:after\": { content: \"'ƒ'\" }\r\n    },\r\n    \".cm-completionIcon-class\": {\r\n        \"&:after\": { content: \"'○'\" }\r\n    },\r\n    \".cm-completionIcon-interface\": {\r\n        \"&:after\": { content: \"'◌'\" }\r\n    },\r\n    \".cm-completionIcon-variable\": {\r\n        \"&:after\": { content: \"'𝑥'\" }\r\n    },\r\n    \".cm-completionIcon-constant\": {\r\n        \"&:after\": { content: \"'𝐶'\" }\r\n    },\r\n    \".cm-completionIcon-type\": {\r\n        \"&:after\": { content: \"'𝑡'\" }\r\n    },\r\n    \".cm-completionIcon-enum\": {\r\n        \"&:after\": { content: \"'∪'\" }\r\n    },\r\n    \".cm-completionIcon-property\": {\r\n        \"&:after\": { content: \"'□'\" }\r\n    },\r\n    \".cm-completionIcon-keyword\": {\r\n        \"&:after\": { content: \"'🔑\\uFE0E'\" } // Disable emoji rendering\r\n    },\r\n    \".cm-completionIcon-namespace\": {\r\n        \"&:after\": { content: \"'▢'\" }\r\n    },\r\n    \".cm-completionIcon-text\": {\r\n        \"&:after\": { content: \"'abc'\", fontSize: \"50%\", verticalAlign: \"middle\" }\r\n    }\r\n});\r\n\r\nclass FieldPos {\r\n    constructor(field, line, from, to) {\r\n        this.field = field;\r\n        this.line = line;\r\n        this.from = from;\r\n        this.to = to;\r\n    }\r\n}\r\nclass FieldRange {\r\n    constructor(field, from, to) {\r\n        this.field = field;\r\n        this.from = from;\r\n        this.to = to;\r\n    }\r\n    map(changes) {\r\n        let from = changes.mapPos(this.from, -1, _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.MapMode.TrackDel);\r\n        let to = changes.mapPos(this.to, 1, _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.MapMode.TrackDel);\r\n        return from == null || to == null ? null : new FieldRange(this.field, from, to);\r\n    }\r\n}\r\nclass Snippet {\r\n    constructor(lines, fieldPositions) {\r\n        this.lines = lines;\r\n        this.fieldPositions = fieldPositions;\r\n    }\r\n    instantiate(state, pos) {\r\n        let text = [], lineStart = [pos];\r\n        let lineObj = state.doc.lineAt(pos), baseIndent = /^\\s*/.exec(lineObj.text)[0];\r\n        for (let line of this.lines) {\r\n            if (text.length) {\r\n                let indent = baseIndent, tabs = /^\\t*/.exec(line)[0].length;\r\n                for (let i = 0; i < tabs; i++)\r\n                    indent += state.facet(_codemirror_language__WEBPACK_IMPORTED_MODULE_0__.indentUnit);\r\n                lineStart.push(pos + indent.length - tabs);\r\n                line = indent + line.slice(tabs);\r\n            }\r\n            text.push(line);\r\n            pos += line.length + 1;\r\n        }\r\n        let ranges = this.fieldPositions.map(pos => new FieldRange(pos.field, lineStart[pos.line] + pos.from, lineStart[pos.line] + pos.to));\r\n        return { text, ranges };\r\n    }\r\n    static parse(template) {\r\n        let fields = [];\r\n        let lines = [], positions = [], m;\r\n        for (let line of template.split(/\\r\\n?|\\n/)) {\r\n            while (m = /[#$]\\{(?:(\\d+)(?::([^}]*))?|([^}]*))\\}/.exec(line)) {\r\n                let seq = m[1] ? +m[1] : null, name = m[2] || m[3] || \"\", found = -1;\r\n                for (let i = 0; i < fields.length; i++) {\r\n                    if (seq != null ? fields[i].seq == seq : name ? fields[i].name == name : false)\r\n                        found = i;\r\n                }\r\n                if (found < 0) {\r\n                    let i = 0;\r\n                    while (i < fields.length && (seq == null || (fields[i].seq != null && fields[i].seq < seq)))\r\n                        i++;\r\n                    fields.splice(i, 0, { seq, name });\r\n                    found = i;\r\n                    for (let pos of positions)\r\n                        if (pos.field >= found)\r\n                            pos.field++;\r\n                }\r\n                positions.push(new FieldPos(found, lines.length, m.index, m.index + name.length));\r\n                line = line.slice(0, m.index) + name + line.slice(m.index + m[0].length);\r\n            }\r\n            for (let esc; esc = /\\\\([{}])/.exec(line);) {\r\n                line = line.slice(0, esc.index) + esc[1] + line.slice(esc.index + esc[0].length);\r\n                for (let pos of positions)\r\n                    if (pos.line == lines.length && pos.from > esc.index) {\r\n                        pos.from--;\r\n                        pos.to--;\r\n                    }\r\n            }\r\n            lines.push(line);\r\n        }\r\n        return new Snippet(lines, positions);\r\n    }\r\n}\r\nlet fieldMarker = /*@__PURE__*/_codemirror_view__WEBPACK_IMPORTED_MODULE_2__.Decoration.widget({ widget: /*@__PURE__*/new class extends _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.WidgetType {\r\n        toDOM() {\r\n            let span = document.createElement(\"span\");\r\n            span.className = \"cm-snippetFieldPosition\";\r\n            return span;\r\n        }\r\n        ignoreEvent() { return false; }\r\n    } });\r\nlet fieldRange = /*@__PURE__*/_codemirror_view__WEBPACK_IMPORTED_MODULE_2__.Decoration.mark({ class: \"cm-snippetField\" });\r\nclass ActiveSnippet {\r\n    constructor(ranges, active) {\r\n        this.ranges = ranges;\r\n        this.active = active;\r\n        this.deco = _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.Decoration.set(ranges.map(r => (r.from == r.to ? fieldMarker : fieldRange).range(r.from, r.to)));\r\n    }\r\n    map(changes) {\r\n        let ranges = [];\r\n        for (let r of this.ranges) {\r\n            let mapped = r.map(changes);\r\n            if (!mapped)\r\n                return null;\r\n            ranges.push(mapped);\r\n        }\r\n        return new ActiveSnippet(ranges, this.active);\r\n    }\r\n    selectionInsideField(sel) {\r\n        return sel.ranges.every(range => this.ranges.some(r => r.field == this.active && r.from <= range.from && r.to >= range.to));\r\n    }\r\n}\r\nconst setActive = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.StateEffect.define({\r\n    map(value, changes) { return value && value.map(changes); }\r\n});\r\nconst moveToField = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.StateEffect.define();\r\nconst snippetState = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.StateField.define({\r\n    create() { return null; },\r\n    update(value, tr) {\r\n        for (let effect of tr.effects) {\r\n            if (effect.is(setActive))\r\n                return effect.value;\r\n            if (effect.is(moveToField) && value)\r\n                return new ActiveSnippet(value.ranges, effect.value);\r\n        }\r\n        if (value && tr.docChanged)\r\n            value = value.map(tr.changes);\r\n        if (value && tr.selection && !value.selectionInsideField(tr.selection))\r\n            value = null;\r\n        return value;\r\n    },\r\n    provide: f => _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.EditorView.decorations.from(f, val => val ? val.deco : _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.Decoration.none)\r\n});\r\nfunction fieldSelection(ranges, field) {\r\n    return _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.create(ranges.filter(r => r.field == field).map(r => _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.range(r.from, r.to)));\r\n}\r\n/**\r\nConvert a snippet template to a function that can\r\n[apply](https://codemirror.net/6/docs/ref/#autocomplete.Completion.apply) it. Snippets are written\r\nusing syntax like this:\r\n\r\n    \"for (let ${index} = 0; ${index} < ${end}; ${index}++) {\\n\\t${}\\n}\"\r\n\r\nEach `${}` placeholder (you may also use `#{}`) indicates a field\r\nthat the user can fill in. Its name, if any, will be the default\r\ncontent for the field.\r\n\r\nWhen the snippet is activated by calling the returned function,\r\nthe code is inserted at the given position. Newlines in the\r\ntemplate are indented by the indentation of the start line, plus\r\none [indent unit](https://codemirror.net/6/docs/ref/#language.indentUnit) per tab character after\r\nthe newline.\r\n\r\nOn activation, (all instances of) the first field are selected.\r\nThe user can move between fields with Tab and Shift-Tab as long as\r\nthe fields are active. Moving to the last field or moving the\r\ncursor out of the current field deactivates the fields.\r\n\r\nThe order of fields defaults to textual order, but you can add\r\nnumbers to placeholders (`${1}` or `${1:defaultText}`) to provide\r\na custom order.\r\n\r\nTo include a literal `{` or `}` in your template, put a backslash\r\nin front of it. This will be removed and the brace will not be\r\ninterpreted as indicating a placeholder.\r\n*/\r\nfunction snippet(template) {\r\n    let snippet = Snippet.parse(template);\r\n    return (editor, _completion, from, to) => {\r\n        let { text, ranges } = snippet.instantiate(editor.state, from);\r\n        let spec = {\r\n            changes: { from, to, insert: _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.Text.of(text) },\r\n            scrollIntoView: true\r\n        };\r\n        if (ranges.length)\r\n            spec.selection = fieldSelection(ranges, 0);\r\n        if (ranges.length > 1) {\r\n            let active = new ActiveSnippet(ranges, 0);\r\n            let effects = spec.effects = [setActive.of(active)];\r\n            if (editor.state.field(snippetState, false) === undefined)\r\n                effects.push(_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.StateEffect.appendConfig.of([snippetState, addSnippetKeymap, snippetPointerHandler, baseTheme]));\r\n        }\r\n        editor.dispatch(editor.state.update(spec));\r\n    };\r\n}\r\nfunction moveField(dir) {\r\n    return ({ state, dispatch }) => {\r\n        let active = state.field(snippetState, false);\r\n        if (!active || dir < 0 && active.active == 0)\r\n            return false;\r\n        let next = active.active + dir, last = dir > 0 && !active.ranges.some(r => r.field == next + dir);\r\n        dispatch(state.update({\r\n            selection: fieldSelection(active.ranges, next),\r\n            effects: setActive.of(last ? null : new ActiveSnippet(active.ranges, next))\r\n        }));\r\n        return true;\r\n    };\r\n}\r\n/**\r\nA command that clears the active snippet, if any.\r\n*/\r\nconst clearSnippet = ({ state, dispatch }) => {\r\n    let active = state.field(snippetState, false);\r\n    if (!active)\r\n        return false;\r\n    dispatch(state.update({ effects: setActive.of(null) }));\r\n    return true;\r\n};\r\n/**\r\nMove to the next snippet field, if available.\r\n*/\r\nconst nextSnippetField = /*@__PURE__*/moveField(1);\r\n/**\r\nMove to the previous snippet field, if available.\r\n*/\r\nconst prevSnippetField = /*@__PURE__*/moveField(-1);\r\nconst defaultSnippetKeymap = [\r\n    { key: \"Tab\", run: nextSnippetField, shift: prevSnippetField },\r\n    { key: \"Escape\", run: clearSnippet }\r\n];\r\n/**\r\nA facet that can be used to configure the key bindings used by\r\nsnippets. The default binds Tab to\r\n[`nextSnippetField`](https://codemirror.net/6/docs/ref/#autocomplete.nextSnippetField), Shift-Tab to\r\n[`prevSnippetField`](https://codemirror.net/6/docs/ref/#autocomplete.prevSnippetField), and Escape\r\nto [`clearSnippet`](https://codemirror.net/6/docs/ref/#autocomplete.clearSnippet).\r\n*/\r\nconst snippetKeymap = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.Facet.define({\r\n    combine(maps) { return maps.length ? maps[0] : defaultSnippetKeymap; }\r\n});\r\nconst addSnippetKeymap = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.Prec.highest(/*@__PURE__*/_codemirror_view__WEBPACK_IMPORTED_MODULE_2__.keymap.compute([snippetKeymap], state => state.facet(snippetKeymap)));\r\n/**\r\nCreate a completion from a snippet. Returns an object with the\r\nproperties from `completion`, plus an `apply` function that\r\napplies the snippet.\r\n*/\r\nfunction snippetCompletion(template, completion) {\r\n    return Object.assign(Object.assign({}, completion), { apply: snippet(template) });\r\n}\r\nconst snippetPointerHandler = /*@__PURE__*/_codemirror_view__WEBPACK_IMPORTED_MODULE_2__.EditorView.domEventHandlers({\r\n    mousedown(event, view) {\r\n        let active = view.state.field(snippetState, false), pos;\r\n        if (!active || (pos = view.posAtCoords({ x: event.clientX, y: event.clientY })) == null)\r\n            return false;\r\n        let match = active.ranges.find(r => r.from <= pos && r.to >= pos);\r\n        if (!match || match.field == active.active)\r\n            return false;\r\n        view.dispatch({\r\n            selection: fieldSelection(active.ranges, match.field),\r\n            effects: setActive.of(active.ranges.some(r => r.field > match.field) ? new ActiveSnippet(active.ranges, match.field) : null)\r\n        });\r\n        return true;\r\n    }\r\n});\r\n\r\nfunction wordRE(wordChars) {\r\n    let escaped = wordChars.replace(/[\\\\[.+*?(){|^$]/g, \"\\\\$&\");\r\n    try {\r\n        return new RegExp(`[\\\\p{Alphabetic}\\\\p{Number}_${escaped}]+`, \"ug\");\r\n    }\r\n    catch (_a) {\r\n        return new RegExp(`[\\w${escaped}]`, \"g\");\r\n    }\r\n}\r\nfunction mapRE(re, f) {\r\n    return new RegExp(f(re.source), re.unicode ? \"u\" : \"\");\r\n}\r\nconst wordCaches = /*@__PURE__*/Object.create(null);\r\nfunction wordCache(wordChars) {\r\n    return wordCaches[wordChars] || (wordCaches[wordChars] = new WeakMap);\r\n}\r\nfunction storeWords(doc, wordRE, result, seen, ignoreAt) {\r\n    for (let lines = doc.iterLines(), pos = 0; !lines.next().done;) {\r\n        let { value } = lines, m;\r\n        wordRE.lastIndex = 0;\r\n        while (m = wordRE.exec(value)) {\r\n            if (!seen[m[0]] && pos + m.index != ignoreAt) {\r\n                result.push({ type: \"text\", label: m[0] });\r\n                seen[m[0]] = true;\r\n                if (result.length >= 2000 /* C.MaxList */)\r\n                    return;\r\n            }\r\n        }\r\n        pos += value.length + 1;\r\n    }\r\n}\r\nfunction collectWords(doc, cache, wordRE, to, ignoreAt) {\r\n    let big = doc.length >= 1000 /* C.MinCacheLen */;\r\n    let cached = big && cache.get(doc);\r\n    if (cached)\r\n        return cached;\r\n    let result = [], seen = Object.create(null);\r\n    if (doc.children) {\r\n        let pos = 0;\r\n        for (let ch of doc.children) {\r\n            if (ch.length >= 1000 /* C.MinCacheLen */) {\r\n                for (let c of collectWords(ch, cache, wordRE, to - pos, ignoreAt - pos)) {\r\n                    if (!seen[c.label]) {\r\n                        seen[c.label] = true;\r\n                        result.push(c);\r\n                    }\r\n                }\r\n            }\r\n            else {\r\n                storeWords(ch, wordRE, result, seen, ignoreAt - pos);\r\n            }\r\n            pos += ch.length + 1;\r\n        }\r\n    }\r\n    else {\r\n        storeWords(doc, wordRE, result, seen, ignoreAt);\r\n    }\r\n    if (big && result.length < 2000 /* C.MaxList */)\r\n        cache.set(doc, result);\r\n    return result;\r\n}\r\n/**\r\nA completion source that will scan the document for words (using a\r\n[character categorizer](https://codemirror.net/6/docs/ref/#state.EditorState.charCategorizer)), and\r\nreturn those as completions.\r\n*/\r\nconst completeAnyWord = context => {\r\n    let wordChars = context.state.languageDataAt(\"wordChars\", context.pos).join(\"\");\r\n    let re = wordRE(wordChars);\r\n    let token = context.matchBefore(mapRE(re, s => s + \"$\"));\r\n    if (!token && !context.explicit)\r\n        return null;\r\n    let from = token ? token.from : context.pos;\r\n    let options = collectWords(context.state.doc, wordCache(wordChars), re, 50000 /* C.Range */, from);\r\n    return { from, options, validFor: mapRE(re, s => \"^\" + s) };\r\n};\r\n\r\nconst defaults = {\r\n    brackets: [\"(\", \"[\", \"{\", \"'\", '\"'],\r\n    before: \")]}:;>\",\r\n    stringPrefixes: []\r\n};\r\nconst closeBracketEffect = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.StateEffect.define({\r\n    map(value, mapping) {\r\n        let mapped = mapping.mapPos(value, -1, _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.MapMode.TrackAfter);\r\n        return mapped == null ? undefined : mapped;\r\n    }\r\n});\r\nconst skipBracketEffect = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.StateEffect.define({\r\n    map(value, mapping) { return mapping.mapPos(value); }\r\n});\r\nconst closedBracket = /*@__PURE__*/new class extends _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.RangeValue {\r\n};\r\nclosedBracket.startSide = 1;\r\nclosedBracket.endSide = -1;\r\nconst bracketState = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.StateField.define({\r\n    create() { return _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.RangeSet.empty; },\r\n    update(value, tr) {\r\n        if (tr.selection) {\r\n            let lineStart = tr.state.doc.lineAt(tr.selection.main.head).from;\r\n            let prevLineStart = tr.startState.doc.lineAt(tr.startState.selection.main.head).from;\r\n            if (lineStart != tr.changes.mapPos(prevLineStart, -1))\r\n                value = _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.RangeSet.empty;\r\n        }\r\n        value = value.map(tr.changes);\r\n        for (let effect of tr.effects) {\r\n            if (effect.is(closeBracketEffect))\r\n                value = value.update({ add: [closedBracket.range(effect.value, effect.value + 1)] });\r\n            else if (effect.is(skipBracketEffect))\r\n                value = value.update({ filter: from => from != effect.value });\r\n        }\r\n        return value;\r\n    }\r\n});\r\n/**\r\nExtension to enable bracket-closing behavior. When a closeable\r\nbracket is typed, its closing bracket is immediately inserted\r\nafter the cursor. When closing a bracket directly in front of a\r\nclosing bracket inserted by the extension, the cursor moves over\r\nthat bracket.\r\n*/\r\nfunction closeBrackets() {\r\n    return [inputHandler, bracketState];\r\n}\r\nconst definedClosing = \"()[]{}<>\";\r\nfunction closing(ch) {\r\n    for (let i = 0; i < definedClosing.length; i += 2)\r\n        if (definedClosing.charCodeAt(i) == ch)\r\n            return definedClosing.charAt(i + 1);\r\n    return (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.fromCodePoint)(ch < 128 ? ch : ch + 1);\r\n}\r\nfunction config(state, pos) {\r\n    return state.languageDataAt(\"closeBrackets\", pos)[0] || defaults;\r\n}\r\nconst android = typeof navigator == \"object\" && /*@__PURE__*//Android\\b/.test(navigator.userAgent);\r\nconst inputHandler = /*@__PURE__*/_codemirror_view__WEBPACK_IMPORTED_MODULE_2__.EditorView.inputHandler.of((view, from, to, insert) => {\r\n    if ((android ? view.composing : view.compositionStarted) || view.state.readOnly)\r\n        return false;\r\n    let sel = view.state.selection.main;\r\n    if (insert.length > 2 || insert.length == 2 && (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.codePointSize)((0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.codePointAt)(insert, 0)) == 1 ||\r\n        from != sel.from || to != sel.to)\r\n        return false;\r\n    let tr = insertBracket(view.state, insert);\r\n    if (!tr)\r\n        return false;\r\n    view.dispatch(tr);\r\n    return true;\r\n});\r\n/**\r\nCommand that implements deleting a pair of matching brackets when\r\nthe cursor is between them.\r\n*/\r\nconst deleteBracketPair = ({ state, dispatch }) => {\r\n    if (state.readOnly)\r\n        return false;\r\n    let conf = config(state, state.selection.main.head);\r\n    let tokens = conf.brackets || defaults.brackets;\r\n    let dont = null, changes = state.changeByRange(range => {\r\n        if (range.empty) {\r\n            let before = prevChar(state.doc, range.head);\r\n            for (let token of tokens) {\r\n                if (token == before && nextChar(state.doc, range.head) == closing((0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.codePointAt)(token, 0)))\r\n                    return { changes: { from: range.head - token.length, to: range.head + token.length },\r\n                        range: _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.cursor(range.head - token.length) };\r\n            }\r\n        }\r\n        return { range: dont = range };\r\n    });\r\n    if (!dont)\r\n        dispatch(state.update(changes, { scrollIntoView: true, userEvent: \"delete.backward\" }));\r\n    return !dont;\r\n};\r\n/**\r\nClose-brackets related key bindings. Binds Backspace to\r\n[`deleteBracketPair`](https://codemirror.net/6/docs/ref/#autocomplete.deleteBracketPair).\r\n*/\r\nconst closeBracketsKeymap = [\r\n    { key: \"Backspace\", run: deleteBracketPair }\r\n];\r\n/**\r\nImplements the extension's behavior on text insertion. If the\r\ngiven string counts as a bracket in the language around the\r\nselection, and replacing the selection with it requires custom\r\nbehavior (inserting a closing version or skipping past a\r\npreviously-closed bracket), this function returns a transaction\r\nrepresenting that custom behavior. (You only need this if you want\r\nto programmatically insert brackets—the\r\n[`closeBrackets`](https://codemirror.net/6/docs/ref/#autocomplete.closeBrackets) extension will\r\ntake care of running this for user input.)\r\n*/\r\nfunction insertBracket(state, bracket) {\r\n    let conf = config(state, state.selection.main.head);\r\n    let tokens = conf.brackets || defaults.brackets;\r\n    for (let tok of tokens) {\r\n        let closed = closing((0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.codePointAt)(tok, 0));\r\n        if (bracket == tok)\r\n            return closed == tok ? handleSame(state, tok, tokens.indexOf(tok + tok + tok) > -1, conf)\r\n                : handleOpen(state, tok, closed, conf.before || defaults.before);\r\n        if (bracket == closed && closedBracketAt(state, state.selection.main.from))\r\n            return handleClose(state, tok, closed);\r\n    }\r\n    return null;\r\n}\r\nfunction closedBracketAt(state, pos) {\r\n    let found = false;\r\n    state.field(bracketState).between(0, state.doc.length, from => {\r\n        if (from == pos)\r\n            found = true;\r\n    });\r\n    return found;\r\n}\r\nfunction nextChar(doc, pos) {\r\n    let next = doc.sliceString(pos, pos + 2);\r\n    return next.slice(0, (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.codePointSize)((0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.codePointAt)(next, 0)));\r\n}\r\nfunction prevChar(doc, pos) {\r\n    let prev = doc.sliceString(pos - 2, pos);\r\n    return (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.codePointSize)((0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.codePointAt)(prev, 0)) == prev.length ? prev : prev.slice(1);\r\n}\r\nfunction handleOpen(state, open, close, closeBefore) {\r\n    let dont = null, changes = state.changeByRange(range => {\r\n        if (!range.empty)\r\n            return { changes: [{ insert: open, from: range.from }, { insert: close, from: range.to }],\r\n                effects: closeBracketEffect.of(range.to + open.length),\r\n                range: _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.range(range.anchor + open.length, range.head + open.length) };\r\n        let next = nextChar(state.doc, range.head);\r\n        if (!next || /\\s/.test(next) || closeBefore.indexOf(next) > -1)\r\n            return { changes: { insert: open + close, from: range.head },\r\n                effects: closeBracketEffect.of(range.head + open.length),\r\n                range: _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.cursor(range.head + open.length) };\r\n        return { range: dont = range };\r\n    });\r\n    return dont ? null : state.update(changes, {\r\n        scrollIntoView: true,\r\n        userEvent: \"input.type\"\r\n    });\r\n}\r\nfunction handleClose(state, _open, close) {\r\n    let dont = null, moved = state.selection.ranges.map(range => {\r\n        if (range.empty && nextChar(state.doc, range.head) == close)\r\n            return _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.cursor(range.head + close.length);\r\n        return dont = range;\r\n    });\r\n    return dont ? null : state.update({\r\n        selection: _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.create(moved, state.selection.mainIndex),\r\n        scrollIntoView: true,\r\n        effects: state.selection.ranges.map(({ from }) => skipBracketEffect.of(from))\r\n    });\r\n}\r\n// Handles cases where the open and close token are the same, and\r\n// possibly triple quotes (as in `\"\"\"abc\"\"\"`-style quoting).\r\nfunction handleSame(state, token, allowTriple, config) {\r\n    let stringPrefixes = config.stringPrefixes || defaults.stringPrefixes;\r\n    let dont = null, changes = state.changeByRange(range => {\r\n        if (!range.empty)\r\n            return { changes: [{ insert: token, from: range.from }, { insert: token, from: range.to }],\r\n                effects: closeBracketEffect.of(range.to + token.length),\r\n                range: _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.range(range.anchor + token.length, range.head + token.length) };\r\n        let pos = range.head, next = nextChar(state.doc, pos), start;\r\n        if (next == token) {\r\n            if (nodeStart(state, pos)) {\r\n                return { changes: { insert: token + token, from: pos },\r\n                    effects: closeBracketEffect.of(pos + token.length),\r\n                    range: _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.cursor(pos + token.length) };\r\n            }\r\n            else if (closedBracketAt(state, pos)) {\r\n                let isTriple = allowTriple && state.sliceDoc(pos, pos + token.length * 3) == token + token + token;\r\n                return { range: _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.cursor(pos + token.length * (isTriple ? 3 : 1)),\r\n                    effects: skipBracketEffect.of(pos) };\r\n            }\r\n        }\r\n        else if (allowTriple && state.sliceDoc(pos - 2 * token.length, pos) == token + token &&\r\n            (start = canStartStringAt(state, pos - 2 * token.length, stringPrefixes)) > -1 &&\r\n            nodeStart(state, start)) {\r\n            return { changes: { insert: token + token + token + token, from: pos },\r\n                effects: closeBracketEffect.of(pos + token.length),\r\n                range: _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.cursor(pos + token.length) };\r\n        }\r\n        else if (state.charCategorizer(pos)(next) != _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.CharCategory.Word) {\r\n            if (canStartStringAt(state, pos, stringPrefixes) > -1 && !probablyInString(state, pos, token, stringPrefixes))\r\n                return { changes: { insert: token + token, from: pos },\r\n                    effects: closeBracketEffect.of(pos + token.length),\r\n                    range: _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.cursor(pos + token.length) };\r\n        }\r\n        return { range: dont = range };\r\n    });\r\n    return dont ? null : state.update(changes, {\r\n        scrollIntoView: true,\r\n        userEvent: \"input.type\"\r\n    });\r\n}\r\nfunction nodeStart(state, pos) {\r\n    let tree = (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_0__.syntaxTree)(state).resolveInner(pos + 1);\r\n    return tree.parent && tree.from == pos;\r\n}\r\nfunction probablyInString(state, pos, quoteToken, prefixes) {\r\n    let node = (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_0__.syntaxTree)(state).resolveInner(pos, -1);\r\n    let maxPrefix = prefixes.reduce((m, p) => Math.max(m, p.length), 0);\r\n    for (let i = 0; i < 5; i++) {\r\n        let start = state.sliceDoc(node.from, Math.min(node.to, node.from + quoteToken.length + maxPrefix));\r\n        let quotePos = start.indexOf(quoteToken);\r\n        if (!quotePos || quotePos > -1 && prefixes.indexOf(start.slice(0, quotePos)) > -1) {\r\n            let first = node.firstChild;\r\n            while (first && first.from == node.from && first.to - first.from > quoteToken.length + quotePos) {\r\n                if (state.sliceDoc(first.to - quoteToken.length, first.to) == quoteToken)\r\n                    return false;\r\n                first = first.firstChild;\r\n            }\r\n            return true;\r\n        }\r\n        let parent = node.to == pos && node.parent;\r\n        if (!parent)\r\n            break;\r\n        node = parent;\r\n    }\r\n    return false;\r\n}\r\nfunction canStartStringAt(state, pos, prefixes) {\r\n    let charCat = state.charCategorizer(pos);\r\n    if (charCat(state.sliceDoc(pos - 1, pos)) != _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.CharCategory.Word)\r\n        return pos;\r\n    for (let prefix of prefixes) {\r\n        let start = pos - prefix.length;\r\n        if (state.sliceDoc(start, pos) == prefix && charCat(state.sliceDoc(start - 1, start)) != _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.CharCategory.Word)\r\n            return start;\r\n    }\r\n    return -1;\r\n}\r\n\r\n/**\r\nReturns an extension that enables autocompletion.\r\n*/\r\nfunction autocompletion(config = {}) {\r\n    return [\r\n        completionState,\r\n        completionConfig.of(config),\r\n        completionPlugin,\r\n        completionKeymapExt,\r\n        baseTheme\r\n    ];\r\n}\r\n/**\r\nBasic keybindings for autocompletion.\r\n\r\n - Ctrl-Space: [`startCompletion`](https://codemirror.net/6/docs/ref/#autocomplete.startCompletion)\r\n - Escape: [`closeCompletion`](https://codemirror.net/6/docs/ref/#autocomplete.closeCompletion)\r\n - ArrowDown: [`moveCompletionSelection`](https://codemirror.net/6/docs/ref/#autocomplete.moveCompletionSelection)`(true)`\r\n - ArrowUp: [`moveCompletionSelection`](https://codemirror.net/6/docs/ref/#autocomplete.moveCompletionSelection)`(false)`\r\n - PageDown: [`moveCompletionSelection`](https://codemirror.net/6/docs/ref/#autocomplete.moveCompletionSelection)`(true, \"page\")`\r\n - PageDown: [`moveCompletionSelection`](https://codemirror.net/6/docs/ref/#autocomplete.moveCompletionSelection)`(true, \"page\")`\r\n - Enter: [`acceptCompletion`](https://codemirror.net/6/docs/ref/#autocomplete.acceptCompletion)\r\n*/\r\nconst completionKeymap = [\r\n    { key: \"Ctrl-Space\", run: startCompletion },\r\n    { key: \"Escape\", run: closeCompletion },\r\n    { key: \"ArrowDown\", run: /*@__PURE__*/moveCompletionSelection(true) },\r\n    { key: \"ArrowUp\", run: /*@__PURE__*/moveCompletionSelection(false) },\r\n    { key: \"PageDown\", run: /*@__PURE__*/moveCompletionSelection(true, \"page\") },\r\n    { key: \"PageUp\", run: /*@__PURE__*/moveCompletionSelection(false, \"page\") },\r\n    { key: \"Enter\", run: acceptCompletion }\r\n];\r\nconst completionKeymapExt = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.Prec.highest(/*@__PURE__*/_codemirror_view__WEBPACK_IMPORTED_MODULE_2__.keymap.computeN([completionConfig], state => state.facet(completionConfig).defaultKeymap ? [completionKeymap] : []));\r\n/**\r\nGet the current completion status. When completions are available,\r\nthis will return `\"active\"`. When completions are pending (in the\r\nprocess of being queried), this returns `\"pending\"`. Otherwise, it\r\nreturns `null`.\r\n*/\r\nfunction completionStatus(state) {\r\n    let cState = state.field(completionState, false);\r\n    return cState && cState.active.some(a => a.state == 1 /* State.Pending */) ? \"pending\"\r\n        : cState && cState.active.some(a => a.state != 0 /* State.Inactive */) ? \"active\" : null;\r\n}\r\nconst completionArrayCache = /*@__PURE__*/new WeakMap;\r\n/**\r\nReturns the available completions as an array.\r\n*/\r\nfunction currentCompletions(state) {\r\n    var _a;\r\n    let open = (_a = state.field(completionState, false)) === null || _a === void 0 ? void 0 : _a.open;\r\n    if (!open || open.disabled)\r\n        return [];\r\n    let completions = completionArrayCache.get(open.options);\r\n    if (!completions)\r\n        completionArrayCache.set(open.options, completions = open.options.map(o => o.completion));\r\n    return completions;\r\n}\r\n/**\r\nReturn the currently selected completion, if any.\r\n*/\r\nfunction selectedCompletion(state) {\r\n    var _a;\r\n    let open = (_a = state.field(completionState, false)) === null || _a === void 0 ? void 0 : _a.open;\r\n    return open && !open.disabled && open.selected >= 0 ? open.options[open.selected].completion : null;\r\n}\r\n/**\r\nReturns the currently selected position in the active completion\r\nlist, or null if no completions are active.\r\n*/\r\nfunction selectedCompletionIndex(state) {\r\n    var _a;\r\n    let open = (_a = state.field(completionState, false)) === null || _a === void 0 ? void 0 : _a.open;\r\n    return open && !open.disabled && open.selected >= 0 ? open.selected : null;\r\n}\r\n/**\r\nCreate an effect that can be attached to a transaction to change\r\nthe currently selected completion.\r\n*/\r\nfunction setSelectedCompletion(index) {\r\n    return setSelectedEffect.of(index);\r\n}\r\n\r\n\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGNvZGVtaXJyb3IvYXV0b2NvbXBsZXRlL2Rpc3QvaW5kZXguanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFtTjtBQUN2RTtBQUM5RTtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsZ0VBQVU7QUFDOUI7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsbUJBQW1CLEVBQUUsaUNBQWlDO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBLHdCQUF3QixrQkFBa0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQsV0FBVztBQUNwRTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsNERBQTREO0FBQ3pHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsZ0VBQVUsK0NBQStDLEtBQUs7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QywyREFBYTtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxjQUFjO0FBQy9DLGtCQUFrQixvQkFBb0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixvQkFBb0I7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QU07QUFDTjtBQUNBLHlDQUF5QywyREFBWSxjQUFjLDZEQUFlO0FBQ2xGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDbWYiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0Bjb2RlbWlycm9yL2F1dG9jb21wbGV0ZS9kaXN0L2luZGV4LmpzPzAzOTMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQW5ub3RhdGlvbiwgRWRpdG9yU2VsZWN0aW9uLCBjb2RlUG9pbnRBdCwgY29kZVBvaW50U2l6ZSwgZnJvbUNvZGVQb2ludCwgRmFjZXQsIGNvbWJpbmVDb25maWcsIFN0YXRlRWZmZWN0LCBTdGF0ZUZpZWxkLCBQcmVjLCBUZXh0LCBNYXBNb2RlLCBSYW5nZVZhbHVlLCBSYW5nZVNldCwgQ2hhckNhdGVnb3J5IH0gZnJvbSAnQGNvZGVtaXJyb3Ivc3RhdGUnO1xyXG5pbXBvcnQgeyBsb2dFeGNlcHRpb24sIERpcmVjdGlvbiwgc2hvd1Rvb2x0aXAsIEVkaXRvclZpZXcsIFZpZXdQbHVnaW4sIGdldFRvb2x0aXAsIERlY29yYXRpb24sIFdpZGdldFR5cGUsIGtleW1hcCB9IGZyb20gJ0Bjb2RlbWlycm9yL3ZpZXcnO1xyXG5pbXBvcnQgeyBzeW50YXhUcmVlLCBpbmRlbnRVbml0IH0gZnJvbSAnQGNvZGVtaXJyb3IvbGFuZ3VhZ2UnO1xyXG5cclxuLyoqXHJcbkFuIGluc3RhbmNlIG9mIHRoaXMgaXMgcGFzc2VkIHRvIGNvbXBsZXRpb24gc291cmNlIGZ1bmN0aW9ucy5cclxuKi9cclxuY2xhc3MgQ29tcGxldGlvbkNvbnRleHQge1xyXG4gICAgLyoqXHJcbiAgICBDcmVhdGUgYSBuZXcgY29tcGxldGlvbiBjb250ZXh0LiAoTW9zdGx5IHVzZWZ1bCBmb3IgdGVzdGluZ1xyXG4gICAgY29tcGxldGlvbiBzb3VyY2Vz4oCUaW4gdGhlIGVkaXRvciwgdGhlIGV4dGVuc2lvbiB3aWxsIGNyZWF0ZVxyXG4gICAgdGhlc2UgZm9yIHlvdS4pXHJcbiAgICAqL1xyXG4gICAgY29uc3RydWN0b3IoXHJcbiAgICAvKipcclxuICAgIFRoZSBlZGl0b3Igc3RhdGUgdGhhdCB0aGUgY29tcGxldGlvbiBoYXBwZW5zIGluLlxyXG4gICAgKi9cclxuICAgIHN0YXRlLCBcclxuICAgIC8qKlxyXG4gICAgVGhlIHBvc2l0aW9uIGF0IHdoaWNoIHRoZSBjb21wbGV0aW9uIGlzIGhhcHBlbmluZy5cclxuICAgICovXHJcbiAgICBwb3MsIFxyXG4gICAgLyoqXHJcbiAgICBJbmRpY2F0ZXMgd2hldGhlciBjb21wbGV0aW9uIHdhcyBhY3RpdmF0ZWQgZXhwbGljaXRseSwgb3JcclxuICAgIGltcGxpY2l0bHkgYnkgdHlwaW5nLiBUaGUgdXN1YWwgd2F5IHRvIHJlc3BvbmQgdG8gdGhpcyBpcyB0b1xyXG4gICAgb25seSByZXR1cm4gY29tcGxldGlvbnMgd2hlbiBlaXRoZXIgdGhlcmUgaXMgcGFydCBvZiBhXHJcbiAgICBjb21wbGV0YWJsZSBlbnRpdHkgYmVmb3JlIHRoZSBjdXJzb3IsIG9yIGBleHBsaWNpdGAgaXMgdHJ1ZS5cclxuICAgICovXHJcbiAgICBleHBsaWNpdCkge1xyXG4gICAgICAgIHRoaXMuc3RhdGUgPSBzdGF0ZTtcclxuICAgICAgICB0aGlzLnBvcyA9IHBvcztcclxuICAgICAgICB0aGlzLmV4cGxpY2l0ID0gZXhwbGljaXQ7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgQGludGVybmFsXHJcbiAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmFib3J0TGlzdGVuZXJzID0gW107XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgIEdldCB0aGUgZXh0ZW50LCBjb250ZW50LCBhbmQgKGlmIHRoZXJlIGlzIGEgdG9rZW4pIHR5cGUgb2YgdGhlXHJcbiAgICB0b2tlbiBiZWZvcmUgYHRoaXMucG9zYC5cclxuICAgICovXHJcbiAgICB0b2tlbkJlZm9yZSh0eXBlcykge1xyXG4gICAgICAgIGxldCB0b2tlbiA9IHN5bnRheFRyZWUodGhpcy5zdGF0ZSkucmVzb2x2ZUlubmVyKHRoaXMucG9zLCAtMSk7XHJcbiAgICAgICAgd2hpbGUgKHRva2VuICYmIHR5cGVzLmluZGV4T2YodG9rZW4ubmFtZSkgPCAwKVxyXG4gICAgICAgICAgICB0b2tlbiA9IHRva2VuLnBhcmVudDtcclxuICAgICAgICByZXR1cm4gdG9rZW4gPyB7IGZyb206IHRva2VuLmZyb20sIHRvOiB0aGlzLnBvcyxcclxuICAgICAgICAgICAgdGV4dDogdGhpcy5zdGF0ZS5zbGljZURvYyh0b2tlbi5mcm9tLCB0aGlzLnBvcyksXHJcbiAgICAgICAgICAgIHR5cGU6IHRva2VuLnR5cGUgfSA6IG51bGw7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgIEdldCB0aGUgbWF0Y2ggb2YgdGhlIGdpdmVuIGV4cHJlc3Npb24gZGlyZWN0bHkgYmVmb3JlIHRoZVxyXG4gICAgY3Vyc29yLlxyXG4gICAgKi9cclxuICAgIG1hdGNoQmVmb3JlKGV4cHIpIHtcclxuICAgICAgICBsZXQgbGluZSA9IHRoaXMuc3RhdGUuZG9jLmxpbmVBdCh0aGlzLnBvcyk7XHJcbiAgICAgICAgbGV0IHN0YXJ0ID0gTWF0aC5tYXgobGluZS5mcm9tLCB0aGlzLnBvcyAtIDI1MCk7XHJcbiAgICAgICAgbGV0IHN0ciA9IGxpbmUudGV4dC5zbGljZShzdGFydCAtIGxpbmUuZnJvbSwgdGhpcy5wb3MgLSBsaW5lLmZyb20pO1xyXG4gICAgICAgIGxldCBmb3VuZCA9IHN0ci5zZWFyY2goZW5zdXJlQW5jaG9yKGV4cHIsIGZhbHNlKSk7XHJcbiAgICAgICAgcmV0dXJuIGZvdW5kIDwgMCA/IG51bGwgOiB7IGZyb206IHN0YXJ0ICsgZm91bmQsIHRvOiB0aGlzLnBvcywgdGV4dDogc3RyLnNsaWNlKGZvdW5kKSB9O1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICBZaWVsZHMgdHJ1ZSB3aGVuIHRoZSBxdWVyeSBoYXMgYmVlbiBhYm9ydGVkLiBDYW4gYmUgdXNlZnVsIGluXHJcbiAgICBhc3luY2hyb25vdXMgcXVlcmllcyB0byBhdm9pZCBkb2luZyB3b3JrIHRoYXQgd2lsbCBiZSBpZ25vcmVkLlxyXG4gICAgKi9cclxuICAgIGdldCBhYm9ydGVkKCkgeyByZXR1cm4gdGhpcy5hYm9ydExpc3RlbmVycyA9PSBudWxsOyB9XHJcbiAgICAvKipcclxuICAgIEFsbG93cyB5b3UgdG8gcmVnaXN0ZXIgYWJvcnQgaGFuZGxlcnMsIHdoaWNoIHdpbGwgYmUgY2FsbGVkIHdoZW5cclxuICAgIHRoZSBxdWVyeSBpc1xyXG4gICAgW2Fib3J0ZWRdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jYXV0b2NvbXBsZXRlLkNvbXBsZXRpb25Db250ZXh0LmFib3J0ZWQpLlxyXG4gICAgKi9cclxuICAgIGFkZEV2ZW50TGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpIHtcclxuICAgICAgICBpZiAodHlwZSA9PSBcImFib3J0XCIgJiYgdGhpcy5hYm9ydExpc3RlbmVycylcclxuICAgICAgICAgICAgdGhpcy5hYm9ydExpc3RlbmVycy5wdXNoKGxpc3RlbmVyKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiB0b1NldChjaGFycykge1xyXG4gICAgbGV0IGZsYXQgPSBPYmplY3Qua2V5cyhjaGFycykuam9pbihcIlwiKTtcclxuICAgIGxldCB3b3JkcyA9IC9cXHcvLnRlc3QoZmxhdCk7XHJcbiAgICBpZiAod29yZHMpXHJcbiAgICAgICAgZmxhdCA9IGZsYXQucmVwbGFjZSgvXFx3L2csIFwiXCIpO1xyXG4gICAgcmV0dXJuIGBbJHt3b3JkcyA/IFwiXFxcXHdcIiA6IFwiXCJ9JHtmbGF0LnJlcGxhY2UoL1teXFx3XFxzXS9nLCBcIlxcXFwkJlwiKX1dYDtcclxufVxyXG5mdW5jdGlvbiBwcmVmaXhNYXRjaChvcHRpb25zKSB7XHJcbiAgICBsZXQgZmlyc3QgPSBPYmplY3QuY3JlYXRlKG51bGwpLCByZXN0ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcclxuICAgIGZvciAobGV0IHsgbGFiZWwgfSBvZiBvcHRpb25zKSB7XHJcbiAgICAgICAgZmlyc3RbbGFiZWxbMF1dID0gdHJ1ZTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IGxhYmVsLmxlbmd0aDsgaSsrKVxyXG4gICAgICAgICAgICByZXN0W2xhYmVsW2ldXSA9IHRydWU7XHJcbiAgICB9XHJcbiAgICBsZXQgc291cmNlID0gdG9TZXQoZmlyc3QpICsgdG9TZXQocmVzdCkgKyBcIiokXCI7XHJcbiAgICByZXR1cm4gW25ldyBSZWdFeHAoXCJeXCIgKyBzb3VyY2UpLCBuZXcgUmVnRXhwKHNvdXJjZSldO1xyXG59XHJcbi8qKlxyXG5HaXZlbiBhIGEgZml4ZWQgYXJyYXkgb2Ygb3B0aW9ucywgcmV0dXJuIGFuIGF1dG9jb21wbGV0ZXIgdGhhdFxyXG5jb21wbGV0ZXMgdGhlbS5cclxuKi9cclxuZnVuY3Rpb24gY29tcGxldGVGcm9tTGlzdChsaXN0KSB7XHJcbiAgICBsZXQgb3B0aW9ucyA9IGxpc3QubWFwKG8gPT4gdHlwZW9mIG8gPT0gXCJzdHJpbmdcIiA/IHsgbGFiZWw6IG8gfSA6IG8pO1xyXG4gICAgbGV0IFt2YWxpZEZvciwgbWF0Y2hdID0gb3B0aW9ucy5ldmVyeShvID0+IC9eXFx3KyQvLnRlc3Qoby5sYWJlbCkpID8gWy9cXHcqJC8sIC9cXHcrJC9dIDogcHJlZml4TWF0Y2gob3B0aW9ucyk7XHJcbiAgICByZXR1cm4gKGNvbnRleHQpID0+IHtcclxuICAgICAgICBsZXQgdG9rZW4gPSBjb250ZXh0Lm1hdGNoQmVmb3JlKG1hdGNoKTtcclxuICAgICAgICByZXR1cm4gdG9rZW4gfHwgY29udGV4dC5leHBsaWNpdCA/IHsgZnJvbTogdG9rZW4gPyB0b2tlbi5mcm9tIDogY29udGV4dC5wb3MsIG9wdGlvbnMsIHZhbGlkRm9yIH0gOiBudWxsO1xyXG4gICAgfTtcclxufVxyXG4vKipcclxuV3JhcCB0aGUgZ2l2ZW4gY29tcGxldGlvbiBzb3VyY2Ugc28gdGhhdCBpdCB3aWxsIG9ubHkgZmlyZSB3aGVuIHRoZVxyXG5jdXJzb3IgaXMgaW4gYSBzeW50YXggbm9kZSB3aXRoIG9uZSBvZiB0aGUgZ2l2ZW4gbmFtZXMuXHJcbiovXHJcbmZ1bmN0aW9uIGlmSW4obm9kZXMsIHNvdXJjZSkge1xyXG4gICAgcmV0dXJuIChjb250ZXh0KSA9PiB7XHJcbiAgICAgICAgZm9yIChsZXQgcG9zID0gc3ludGF4VHJlZShjb250ZXh0LnN0YXRlKS5yZXNvbHZlSW5uZXIoY29udGV4dC5wb3MsIC0xKTsgcG9zOyBwb3MgPSBwb3MucGFyZW50KVxyXG4gICAgICAgICAgICBpZiAobm9kZXMuaW5kZXhPZihwb3MubmFtZSkgPiAtMSlcclxuICAgICAgICAgICAgICAgIHJldHVybiBzb3VyY2UoY29udGV4dCk7XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9O1xyXG59XHJcbi8qKlxyXG5XcmFwIHRoZSBnaXZlbiBjb21wbGV0aW9uIHNvdXJjZSBzbyB0aGF0IGl0IHdpbGwgbm90IGZpcmUgd2hlbiB0aGVcclxuY3Vyc29yIGlzIGluIGEgc3ludGF4IG5vZGUgd2l0aCBvbmUgb2YgdGhlIGdpdmVuIG5hbWVzLlxyXG4qL1xyXG5mdW5jdGlvbiBpZk5vdEluKG5vZGVzLCBzb3VyY2UpIHtcclxuICAgIHJldHVybiAoY29udGV4dCkgPT4ge1xyXG4gICAgICAgIGZvciAobGV0IHBvcyA9IHN5bnRheFRyZWUoY29udGV4dC5zdGF0ZSkucmVzb2x2ZUlubmVyKGNvbnRleHQucG9zLCAtMSk7IHBvczsgcG9zID0gcG9zLnBhcmVudClcclxuICAgICAgICAgICAgaWYgKG5vZGVzLmluZGV4T2YocG9zLm5hbWUpID4gLTEpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICByZXR1cm4gc291cmNlKGNvbnRleHQpO1xyXG4gICAgfTtcclxufVxyXG5jbGFzcyBPcHRpb24ge1xyXG4gICAgY29uc3RydWN0b3IoY29tcGxldGlvbiwgc291cmNlLCBtYXRjaCkge1xyXG4gICAgICAgIHRoaXMuY29tcGxldGlvbiA9IGNvbXBsZXRpb247XHJcbiAgICAgICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XHJcbiAgICAgICAgdGhpcy5tYXRjaCA9IG1hdGNoO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGN1cihzdGF0ZSkgeyByZXR1cm4gc3RhdGUuc2VsZWN0aW9uLm1haW4uaGVhZDsgfVxyXG4vLyBNYWtlIHN1cmUgdGhlIGdpdmVuIHJlZ2V4cCBoYXMgYSAkIGF0IGl0cyBlbmQgYW5kLCBpZiBgc3RhcnRgIGlzXHJcbi8vIHRydWUsIGEgXiBhdCBpdHMgc3RhcnQuXHJcbmZ1bmN0aW9uIGVuc3VyZUFuY2hvcihleHByLCBzdGFydCkge1xyXG4gICAgdmFyIF9hO1xyXG4gICAgbGV0IHsgc291cmNlIH0gPSBleHByO1xyXG4gICAgbGV0IGFkZFN0YXJ0ID0gc3RhcnQgJiYgc291cmNlWzBdICE9IFwiXlwiLCBhZGRFbmQgPSBzb3VyY2Vbc291cmNlLmxlbmd0aCAtIDFdICE9IFwiJFwiO1xyXG4gICAgaWYgKCFhZGRTdGFydCAmJiAhYWRkRW5kKVxyXG4gICAgICAgIHJldHVybiBleHByO1xyXG4gICAgcmV0dXJuIG5ldyBSZWdFeHAoYCR7YWRkU3RhcnQgPyBcIl5cIiA6IFwiXCJ9KD86JHtzb3VyY2V9KSR7YWRkRW5kID8gXCIkXCIgOiBcIlwifWAsIChfYSA9IGV4cHIuZmxhZ3MpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IChleHByLmlnbm9yZUNhc2UgPyBcImlcIiA6IFwiXCIpKTtcclxufVxyXG4vKipcclxuVGhpcyBhbm5vdGF0aW9uIGlzIGFkZGVkIHRvIHRyYW5zYWN0aW9ucyB0aGF0IGFyZSBwcm9kdWNlZCBieVxyXG5waWNraW5nIGEgY29tcGxldGlvbi5cclxuKi9cclxuY29uc3QgcGlja2VkQ29tcGxldGlvbiA9IC8qQF9fUFVSRV9fKi9Bbm5vdGF0aW9uLmRlZmluZSgpO1xyXG4vKipcclxuSGVscGVyIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhIHRyYW5zYWN0aW9uIHNwZWMgd2hpY2ggaW5zZXJ0cyBhXHJcbmNvbXBsZXRpb24ncyB0ZXh0IGluIHRoZSBtYWluIHNlbGVjdGlvbiByYW5nZSwgYW5kIGFueSBvdGhlclxyXG5zZWxlY3Rpb24gcmFuZ2UgdGhhdCBoYXMgdGhlIHNhbWUgdGV4dCBpbiBmcm9udCBvZiBpdC5cclxuKi9cclxuZnVuY3Rpb24gaW5zZXJ0Q29tcGxldGlvblRleHQoc3RhdGUsIHRleHQsIGZyb20sIHRvKSB7XHJcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBzdGF0ZS5jaGFuZ2VCeVJhbmdlKHJhbmdlID0+IHtcclxuICAgICAgICBpZiAocmFuZ2UgPT0gc3RhdGUuc2VsZWN0aW9uLm1haW4pXHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICBjaGFuZ2VzOiB7IGZyb206IGZyb20sIHRvOiB0bywgaW5zZXJ0OiB0ZXh0IH0sXHJcbiAgICAgICAgICAgICAgICByYW5nZTogRWRpdG9yU2VsZWN0aW9uLmN1cnNvcihmcm9tICsgdGV4dC5sZW5ndGgpXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgbGV0IGxlbiA9IHRvIC0gZnJvbTtcclxuICAgICAgICBpZiAoIXJhbmdlLmVtcHR5IHx8XHJcbiAgICAgICAgICAgIGxlbiAmJiBzdGF0ZS5zbGljZURvYyhyYW5nZS5mcm9tIC0gbGVuLCByYW5nZS5mcm9tKSAhPSBzdGF0ZS5zbGljZURvYyhmcm9tLCB0bykpXHJcbiAgICAgICAgICAgIHJldHVybiB7IHJhbmdlIH07XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgY2hhbmdlczogeyBmcm9tOiByYW5nZS5mcm9tIC0gbGVuLCB0bzogcmFuZ2UuZnJvbSwgaW5zZXJ0OiB0ZXh0IH0sXHJcbiAgICAgICAgICAgIHJhbmdlOiBFZGl0b3JTZWxlY3Rpb24uY3Vyc29yKHJhbmdlLmZyb20gLSBsZW4gKyB0ZXh0Lmxlbmd0aClcclxuICAgICAgICB9O1xyXG4gICAgfSkpLCB7IHVzZXJFdmVudDogXCJpbnB1dC5jb21wbGV0ZVwiIH0pO1xyXG59XHJcbmZ1bmN0aW9uIGFwcGx5Q29tcGxldGlvbih2aWV3LCBvcHRpb24pIHtcclxuICAgIGNvbnN0IGFwcGx5ID0gb3B0aW9uLmNvbXBsZXRpb24uYXBwbHkgfHwgb3B0aW9uLmNvbXBsZXRpb24ubGFiZWw7XHJcbiAgICBsZXQgcmVzdWx0ID0gb3B0aW9uLnNvdXJjZTtcclxuICAgIGlmICh0eXBlb2YgYXBwbHkgPT0gXCJzdHJpbmdcIilcclxuICAgICAgICB2aWV3LmRpc3BhdGNoKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgaW5zZXJ0Q29tcGxldGlvblRleHQodmlldy5zdGF0ZSwgYXBwbHksIHJlc3VsdC5mcm9tLCByZXN1bHQudG8pKSwgeyBhbm5vdGF0aW9uczogcGlja2VkQ29tcGxldGlvbi5vZihvcHRpb24uY29tcGxldGlvbikgfSkpO1xyXG4gICAgZWxzZVxyXG4gICAgICAgIGFwcGx5KHZpZXcsIG9wdGlvbi5jb21wbGV0aW9uLCByZXN1bHQuZnJvbSwgcmVzdWx0LnRvKTtcclxufVxyXG5jb25zdCBTb3VyY2VDYWNoZSA9IC8qQF9fUFVSRV9fKi9uZXcgV2Vha01hcCgpO1xyXG5mdW5jdGlvbiBhc1NvdXJjZShzb3VyY2UpIHtcclxuICAgIGlmICghQXJyYXkuaXNBcnJheShzb3VyY2UpKVxyXG4gICAgICAgIHJldHVybiBzb3VyY2U7XHJcbiAgICBsZXQga25vd24gPSBTb3VyY2VDYWNoZS5nZXQoc291cmNlKTtcclxuICAgIGlmICgha25vd24pXHJcbiAgICAgICAgU291cmNlQ2FjaGUuc2V0KHNvdXJjZSwga25vd24gPSBjb21wbGV0ZUZyb21MaXN0KHNvdXJjZSkpO1xyXG4gICAgcmV0dXJuIGtub3duO1xyXG59XHJcblxyXG4vLyBBIHBhdHRlcm4gbWF0Y2hlciBmb3IgZnV6enkgY29tcGxldGlvbiBtYXRjaGluZy4gQ3JlYXRlIGFuIGluc3RhbmNlXHJcbi8vIG9uY2UgZm9yIGEgcGF0dGVybiwgYW5kIHRoZW4gdXNlIHRoYXQgdG8gbWF0Y2ggYW55IG51bWJlciBvZlxyXG4vLyBjb21wbGV0aW9ucy5cclxuY2xhc3MgRnV6enlNYXRjaGVyIHtcclxuICAgIGNvbnN0cnVjdG9yKHBhdHRlcm4pIHtcclxuICAgICAgICB0aGlzLnBhdHRlcm4gPSBwYXR0ZXJuO1xyXG4gICAgICAgIHRoaXMuY2hhcnMgPSBbXTtcclxuICAgICAgICB0aGlzLmZvbGRlZCA9IFtdO1xyXG4gICAgICAgIC8vIEJ1ZmZlcnMgcmV1c2VkIGJ5IGNhbGxzIHRvIGBtYXRjaGAgdG8gdHJhY2sgbWF0Y2hlZCBjaGFyYWN0ZXJcclxuICAgICAgICAvLyBwb3NpdGlvbnMuXHJcbiAgICAgICAgdGhpcy5hbnkgPSBbXTtcclxuICAgICAgICB0aGlzLnByZWNpc2UgPSBbXTtcclxuICAgICAgICB0aGlzLmJ5V29yZCA9IFtdO1xyXG4gICAgICAgIGZvciAobGV0IHAgPSAwOyBwIDwgcGF0dGVybi5sZW5ndGg7KSB7XHJcbiAgICAgICAgICAgIGxldCBjaGFyID0gY29kZVBvaW50QXQocGF0dGVybiwgcCksIHNpemUgPSBjb2RlUG9pbnRTaXplKGNoYXIpO1xyXG4gICAgICAgICAgICB0aGlzLmNoYXJzLnB1c2goY2hhcik7XHJcbiAgICAgICAgICAgIGxldCBwYXJ0ID0gcGF0dGVybi5zbGljZShwLCBwICsgc2l6ZSksIHVwcGVyID0gcGFydC50b1VwcGVyQ2FzZSgpO1xyXG4gICAgICAgICAgICB0aGlzLmZvbGRlZC5wdXNoKGNvZGVQb2ludEF0KHVwcGVyID09IHBhcnQgPyBwYXJ0LnRvTG93ZXJDYXNlKCkgOiB1cHBlciwgMCkpO1xyXG4gICAgICAgICAgICBwICs9IHNpemU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuYXN0cmFsID0gcGF0dGVybi5sZW5ndGggIT0gdGhpcy5jaGFycy5sZW5ndGg7XHJcbiAgICB9XHJcbiAgICAvLyBNYXRjaGVzIGEgZ2l2ZW4gd29yZCAoY29tcGxldGlvbikgYWdhaW5zdCB0aGUgcGF0dGVybiAoaW5wdXQpLlxyXG4gICAgLy8gV2lsbCByZXR1cm4gbnVsbCBmb3Igbm8gbWF0Y2gsIGFuZCBvdGhlcndpc2UgYW4gYXJyYXkgdGhhdCBzdGFydHNcclxuICAgIC8vIHdpdGggdGhlIG1hdGNoIHNjb3JlLCBmb2xsb3dlZCBieSBhbnkgbnVtYmVyIG9mIGBmcm9tLCB0b2AgcGFpcnNcclxuICAgIC8vIGluZGljYXRpbmcgdGhlIG1hdGNoZWQgcGFydHMgb2YgYHdvcmRgLlxyXG4gICAgLy9cclxuICAgIC8vIFRoZSBzY29yZSBpcyBhIG51bWJlciB0aGF0IGlzIG1vcmUgbmVnYXRpdmUgdGhlIHdvcnNlIHRoZSBtYXRjaFxyXG4gICAgLy8gaXMuIFNlZSBgUGVuYWx0eWAgYWJvdmUuXHJcbiAgICBtYXRjaCh3b3JkKSB7XHJcbiAgICAgICAgaWYgKHRoaXMucGF0dGVybi5sZW5ndGggPT0gMClcclxuICAgICAgICAgICAgcmV0dXJuIFswXTtcclxuICAgICAgICBpZiAod29yZC5sZW5ndGggPCB0aGlzLnBhdHRlcm4ubGVuZ3RoKVxyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICBsZXQgeyBjaGFycywgZm9sZGVkLCBhbnksIHByZWNpc2UsIGJ5V29yZCB9ID0gdGhpcztcclxuICAgICAgICAvLyBGb3Igc2luZ2xlLWNoYXJhY3RlciBxdWVyaWVzLCBvbmx5IG1hdGNoIHdoZW4gdGhleSBvY2N1ciByaWdodFxyXG4gICAgICAgIC8vIGF0IHRoZSBzdGFydFxyXG4gICAgICAgIGlmIChjaGFycy5sZW5ndGggPT0gMSkge1xyXG4gICAgICAgICAgICBsZXQgZmlyc3QgPSBjb2RlUG9pbnRBdCh3b3JkLCAwKTtcclxuICAgICAgICAgICAgcmV0dXJuIGZpcnN0ID09IGNoYXJzWzBdID8gWzAsIDAsIGNvZGVQb2ludFNpemUoZmlyc3QpXVxyXG4gICAgICAgICAgICAgICAgOiBmaXJzdCA9PSBmb2xkZWRbMF0gPyBbLTIwMCAvKiBQZW5hbHR5LkNhc2VGb2xkICovLCAwLCBjb2RlUG9pbnRTaXplKGZpcnN0KV0gOiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgZGlyZWN0ID0gd29yZC5pbmRleE9mKHRoaXMucGF0dGVybik7XHJcbiAgICAgICAgaWYgKGRpcmVjdCA9PSAwKVxyXG4gICAgICAgICAgICByZXR1cm4gWzAsIDAsIHRoaXMucGF0dGVybi5sZW5ndGhdO1xyXG4gICAgICAgIGxldCBsZW4gPSBjaGFycy5sZW5ndGgsIGFueVRvID0gMDtcclxuICAgICAgICBpZiAoZGlyZWN0IDwgMCkge1xyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMCwgZSA9IE1hdGgubWluKHdvcmQubGVuZ3RoLCAyMDApOyBpIDwgZSAmJiBhbnlUbyA8IGxlbjspIHtcclxuICAgICAgICAgICAgICAgIGxldCBuZXh0ID0gY29kZVBvaW50QXQod29yZCwgaSk7XHJcbiAgICAgICAgICAgICAgICBpZiAobmV4dCA9PSBjaGFyc1thbnlUb10gfHwgbmV4dCA9PSBmb2xkZWRbYW55VG9dKVxyXG4gICAgICAgICAgICAgICAgICAgIGFueVthbnlUbysrXSA9IGk7XHJcbiAgICAgICAgICAgICAgICBpICs9IGNvZGVQb2ludFNpemUobmV4dCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gTm8gbWF0Y2gsIGV4aXQgaW1tZWRpYXRlbHlcclxuICAgICAgICAgICAgaWYgKGFueVRvIDwgbGVuKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFRoaXMgdHJhY2tzIHRoZSBleHRlbnQgb2YgdGhlIHByZWNpc2UgKG5vbi1mb2xkZWQsIG5vdFxyXG4gICAgICAgIC8vIG5lY2Vzc2FyaWx5IGFkamFjZW50KSBtYXRjaFxyXG4gICAgICAgIGxldCBwcmVjaXNlVG8gPSAwO1xyXG4gICAgICAgIC8vIFRyYWNrcyB3aGV0aGVyIHRoZXJlIGlzIGEgbWF0Y2ggdGhhdCBoaXRzIG9ubHkgY2hhcmFjdGVycyB0aGF0XHJcbiAgICAgICAgLy8gYXBwZWFyIHRvIGJlIHN0YXJ0aW5nIHdvcmRzLiBgYnlXb3JkRm9sZGVkYCBpcyBzZXQgdG8gdHJ1ZSB3aGVuXHJcbiAgICAgICAgLy8gYSBjYXNlIGZvbGRlZCBjaGFyYWN0ZXIgaXMgZW5jb3VudGVyZWQgaW4gc3VjaCBhIG1hdGNoXHJcbiAgICAgICAgbGV0IGJ5V29yZFRvID0gMCwgYnlXb3JkRm9sZGVkID0gZmFsc2U7XHJcbiAgICAgICAgLy8gSWYgd2UndmUgZm91bmQgYSBwYXJ0aWFsIGFkamFjZW50IG1hdGNoLCB0aGVzZSB0cmFjayBpdHMgc3RhdGVcclxuICAgICAgICBsZXQgYWRqYWNlbnRUbyA9IDAsIGFkamFjZW50U3RhcnQgPSAtMSwgYWRqYWNlbnRFbmQgPSAtMTtcclxuICAgICAgICBsZXQgaGFzTG93ZXIgPSAvW2Etel0vLnRlc3Qod29yZCksIHdvcmRBZGphY2VudCA9IHRydWU7XHJcbiAgICAgICAgLy8gR28gb3ZlciB0aGUgb3B0aW9uJ3MgdGV4dCwgc2Nhbm5pbmcgZm9yIHRoZSB2YXJpb3VzIGtpbmRzIG9mIG1hdGNoZXNcclxuICAgICAgICBmb3IgKGxldCBpID0gMCwgZSA9IE1hdGgubWluKHdvcmQubGVuZ3RoLCAyMDApLCBwcmV2VHlwZSA9IDAgLyogVHAuTm9uV29yZCAqLzsgaSA8IGUgJiYgYnlXb3JkVG8gPCBsZW47KSB7XHJcbiAgICAgICAgICAgIGxldCBuZXh0ID0gY29kZVBvaW50QXQod29yZCwgaSk7XHJcbiAgICAgICAgICAgIGlmIChkaXJlY3QgPCAwKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAocHJlY2lzZVRvIDwgbGVuICYmIG5leHQgPT0gY2hhcnNbcHJlY2lzZVRvXSlcclxuICAgICAgICAgICAgICAgICAgICBwcmVjaXNlW3ByZWNpc2VUbysrXSA9IGk7XHJcbiAgICAgICAgICAgICAgICBpZiAoYWRqYWNlbnRUbyA8IGxlbikge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChuZXh0ID09IGNoYXJzW2FkamFjZW50VG9dIHx8IG5leHQgPT0gZm9sZGVkW2FkamFjZW50VG9dKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhZGphY2VudFRvID09IDApXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZGphY2VudFN0YXJ0ID0gaTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYWRqYWNlbnRFbmQgPSBpICsgMTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYWRqYWNlbnRUbysrO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYWRqYWNlbnRUbyA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGxldCBjaCwgdHlwZSA9IG5leHQgPCAweGZmXHJcbiAgICAgICAgICAgICAgICA/IChuZXh0ID49IDQ4ICYmIG5leHQgPD0gNTcgfHwgbmV4dCA+PSA5NyAmJiBuZXh0IDw9IDEyMiA/IDIgLyogVHAuTG93ZXIgKi8gOiBuZXh0ID49IDY1ICYmIG5leHQgPD0gOTAgPyAxIC8qIFRwLlVwcGVyICovIDogMCAvKiBUcC5Ob25Xb3JkICovKVxyXG4gICAgICAgICAgICAgICAgOiAoKGNoID0gZnJvbUNvZGVQb2ludChuZXh0KSkgIT0gY2gudG9Mb3dlckNhc2UoKSA/IDEgLyogVHAuVXBwZXIgKi8gOiBjaCAhPSBjaC50b1VwcGVyQ2FzZSgpID8gMiAvKiBUcC5Mb3dlciAqLyA6IDAgLyogVHAuTm9uV29yZCAqLyk7XHJcbiAgICAgICAgICAgIGlmICghaSB8fCB0eXBlID09IDEgLyogVHAuVXBwZXIgKi8gJiYgaGFzTG93ZXIgfHwgcHJldlR5cGUgPT0gMCAvKiBUcC5Ob25Xb3JkICovICYmIHR5cGUgIT0gMCAvKiBUcC5Ob25Xb3JkICovKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoY2hhcnNbYnlXb3JkVG9dID09IG5leHQgfHwgKGZvbGRlZFtieVdvcmRUb10gPT0gbmV4dCAmJiAoYnlXb3JkRm9sZGVkID0gdHJ1ZSkpKVxyXG4gICAgICAgICAgICAgICAgICAgIGJ5V29yZFtieVdvcmRUbysrXSA9IGk7XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChieVdvcmQubGVuZ3RoKVxyXG4gICAgICAgICAgICAgICAgICAgIHdvcmRBZGphY2VudCA9IGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHByZXZUeXBlID0gdHlwZTtcclxuICAgICAgICAgICAgaSArPSBjb2RlUG9pbnRTaXplKG5leHQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoYnlXb3JkVG8gPT0gbGVuICYmIGJ5V29yZFswXSA9PSAwICYmIHdvcmRBZGphY2VudClcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVzdWx0KC0xMDAgLyogUGVuYWx0eS5CeVdvcmQgKi8gKyAoYnlXb3JkRm9sZGVkID8gLTIwMCAvKiBQZW5hbHR5LkNhc2VGb2xkICovIDogMCksIGJ5V29yZCwgd29yZCk7XHJcbiAgICAgICAgaWYgKGFkamFjZW50VG8gPT0gbGVuICYmIGFkamFjZW50U3RhcnQgPT0gMClcclxuICAgICAgICAgICAgcmV0dXJuIFstMjAwIC8qIFBlbmFsdHkuQ2FzZUZvbGQgKi8gLSB3b3JkLmxlbmd0aCwgMCwgYWRqYWNlbnRFbmRdO1xyXG4gICAgICAgIGlmIChkaXJlY3QgPiAtMSlcclxuICAgICAgICAgICAgcmV0dXJuIFstNzAwIC8qIFBlbmFsdHkuTm90U3RhcnQgKi8gLSB3b3JkLmxlbmd0aCwgZGlyZWN0LCBkaXJlY3QgKyB0aGlzLnBhdHRlcm4ubGVuZ3RoXTtcclxuICAgICAgICBpZiAoYWRqYWNlbnRUbyA9PSBsZW4pXHJcbiAgICAgICAgICAgIHJldHVybiBbLTIwMCAvKiBQZW5hbHR5LkNhc2VGb2xkICovICsgLTcwMCAvKiBQZW5hbHR5Lk5vdFN0YXJ0ICovIC0gd29yZC5sZW5ndGgsIGFkamFjZW50U3RhcnQsIGFkamFjZW50RW5kXTtcclxuICAgICAgICBpZiAoYnlXb3JkVG8gPT0gbGVuKVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZXN1bHQoLTEwMCAvKiBQZW5hbHR5LkJ5V29yZCAqLyArIChieVdvcmRGb2xkZWQgPyAtMjAwIC8qIFBlbmFsdHkuQ2FzZUZvbGQgKi8gOiAwKSArIC03MDAgLyogUGVuYWx0eS5Ob3RTdGFydCAqLyArXHJcbiAgICAgICAgICAgICAgICAod29yZEFkamFjZW50ID8gMCA6IC0xMTAwIC8qIFBlbmFsdHkuR2FwICovKSwgYnlXb3JkLCB3b3JkKTtcclxuICAgICAgICByZXR1cm4gY2hhcnMubGVuZ3RoID09IDIgPyBudWxsIDogdGhpcy5yZXN1bHQoKGFueVswXSA/IC03MDAgLyogUGVuYWx0eS5Ob3RTdGFydCAqLyA6IDApICsgLTIwMCAvKiBQZW5hbHR5LkNhc2VGb2xkICovICsgLTExMDAgLyogUGVuYWx0eS5HYXAgKi8sIGFueSwgd29yZCk7XHJcbiAgICB9XHJcbiAgICByZXN1bHQoc2NvcmUsIHBvc2l0aW9ucywgd29yZCkge1xyXG4gICAgICAgIGxldCByZXN1bHQgPSBbc2NvcmUgLSB3b3JkLmxlbmd0aF0sIGkgPSAxO1xyXG4gICAgICAgIGZvciAobGV0IHBvcyBvZiBwb3NpdGlvbnMpIHtcclxuICAgICAgICAgICAgbGV0IHRvID0gcG9zICsgKHRoaXMuYXN0cmFsID8gY29kZVBvaW50U2l6ZShjb2RlUG9pbnRBdCh3b3JkLCBwb3MpKSA6IDEpO1xyXG4gICAgICAgICAgICBpZiAoaSA+IDEgJiYgcmVzdWx0W2kgLSAxXSA9PSBwb3MpXHJcbiAgICAgICAgICAgICAgICByZXN1bHRbaSAtIDFdID0gdG87XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0W2krK10gPSBwb3M7XHJcbiAgICAgICAgICAgICAgICByZXN1bHRbaSsrXSA9IHRvO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcbn1cclxuXHJcbmNvbnN0IGNvbXBsZXRpb25Db25maWcgPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKHtcclxuICAgIGNvbWJpbmUoY29uZmlncykge1xyXG4gICAgICAgIHJldHVybiBjb21iaW5lQ29uZmlnKGNvbmZpZ3MsIHtcclxuICAgICAgICAgICAgYWN0aXZhdGVPblR5cGluZzogdHJ1ZSxcclxuICAgICAgICAgICAgc2VsZWN0T25PcGVuOiB0cnVlLFxyXG4gICAgICAgICAgICBvdmVycmlkZTogbnVsbCxcclxuICAgICAgICAgICAgY2xvc2VPbkJsdXI6IHRydWUsXHJcbiAgICAgICAgICAgIG1heFJlbmRlcmVkT3B0aW9uczogMTAwLFxyXG4gICAgICAgICAgICBkZWZhdWx0S2V5bWFwOiB0cnVlLFxyXG4gICAgICAgICAgICB0b29sdGlwQ2xhc3M6ICgpID0+IFwiXCIsXHJcbiAgICAgICAgICAgIG9wdGlvbkNsYXNzOiAoKSA9PiBcIlwiLFxyXG4gICAgICAgICAgICBhYm92ZUN1cnNvcjogZmFsc2UsXHJcbiAgICAgICAgICAgIGljb25zOiB0cnVlLFxyXG4gICAgICAgICAgICBhZGRUb09wdGlvbnM6IFtdLFxyXG4gICAgICAgICAgICBjb21wYXJlQ29tcGxldGlvbnM6IChhLCBiKSA9PiBhLmxhYmVsLmxvY2FsZUNvbXBhcmUoYi5sYWJlbCksXHJcbiAgICAgICAgICAgIGludGVyYWN0aW9uRGVsYXk6IDc1XHJcbiAgICAgICAgfSwge1xyXG4gICAgICAgICAgICBkZWZhdWx0S2V5bWFwOiAoYSwgYikgPT4gYSAmJiBiLFxyXG4gICAgICAgICAgICBjbG9zZU9uQmx1cjogKGEsIGIpID0+IGEgJiYgYixcclxuICAgICAgICAgICAgaWNvbnM6IChhLCBiKSA9PiBhICYmIGIsXHJcbiAgICAgICAgICAgIHRvb2x0aXBDbGFzczogKGEsIGIpID0+IGMgPT4gam9pbkNsYXNzKGEoYyksIGIoYykpLFxyXG4gICAgICAgICAgICBvcHRpb25DbGFzczogKGEsIGIpID0+IGMgPT4gam9pbkNsYXNzKGEoYyksIGIoYykpLFxyXG4gICAgICAgICAgICBhZGRUb09wdGlvbnM6IChhLCBiKSA9PiBhLmNvbmNhdChiKVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG59KTtcclxuZnVuY3Rpb24gam9pbkNsYXNzKGEsIGIpIHtcclxuICAgIHJldHVybiBhID8gYiA/IGEgKyBcIiBcIiArIGIgOiBhIDogYjtcclxufVxyXG5cclxuZnVuY3Rpb24gb3B0aW9uQ29udGVudChjb25maWcpIHtcclxuICAgIGxldCBjb250ZW50ID0gY29uZmlnLmFkZFRvT3B0aW9ucy5zbGljZSgpO1xyXG4gICAgaWYgKGNvbmZpZy5pY29ucylcclxuICAgICAgICBjb250ZW50LnB1c2goe1xyXG4gICAgICAgICAgICByZW5kZXIoY29tcGxldGlvbikge1xyXG4gICAgICAgICAgICAgICAgbGV0IGljb24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xyXG4gICAgICAgICAgICAgICAgaWNvbi5jbGFzc0xpc3QuYWRkKFwiY20tY29tcGxldGlvbkljb25cIik7XHJcbiAgICAgICAgICAgICAgICBpZiAoY29tcGxldGlvbi50eXBlKVxyXG4gICAgICAgICAgICAgICAgICAgIGljb24uY2xhc3NMaXN0LmFkZCguLi5jb21wbGV0aW9uLnR5cGUuc3BsaXQoL1xccysvZykubWFwKGNscyA9PiBcImNtLWNvbXBsZXRpb25JY29uLVwiICsgY2xzKSk7XHJcbiAgICAgICAgICAgICAgICBpY29uLnNldEF0dHJpYnV0ZShcImFyaWEtaGlkZGVuXCIsIFwidHJ1ZVwiKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBpY29uO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBwb3NpdGlvbjogMjBcclxuICAgICAgICB9KTtcclxuICAgIGNvbnRlbnQucHVzaCh7XHJcbiAgICAgICAgcmVuZGVyKGNvbXBsZXRpb24sIF9zLCBtYXRjaCkge1xyXG4gICAgICAgICAgICBsZXQgbGFiZWxFbHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3BhblwiKTtcclxuICAgICAgICAgICAgbGFiZWxFbHQuY2xhc3NOYW1lID0gXCJjbS1jb21wbGV0aW9uTGFiZWxcIjtcclxuICAgICAgICAgICAgbGV0IHsgbGFiZWwgfSA9IGNvbXBsZXRpb24sIG9mZiA9IDA7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGogPSAxOyBqIDwgbWF0Y2gubGVuZ3RoOykge1xyXG4gICAgICAgICAgICAgICAgbGV0IGZyb20gPSBtYXRjaFtqKytdLCB0byA9IG1hdGNoW2orK107XHJcbiAgICAgICAgICAgICAgICBpZiAoZnJvbSA+IG9mZilcclxuICAgICAgICAgICAgICAgICAgICBsYWJlbEVsdC5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShsYWJlbC5zbGljZShvZmYsIGZyb20pKSk7XHJcbiAgICAgICAgICAgICAgICBsZXQgc3BhbiA9IGxhYmVsRWx0LmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpKTtcclxuICAgICAgICAgICAgICAgIHNwYW4uYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUobGFiZWwuc2xpY2UoZnJvbSwgdG8pKSk7XHJcbiAgICAgICAgICAgICAgICBzcGFuLmNsYXNzTmFtZSA9IFwiY20tY29tcGxldGlvbk1hdGNoZWRUZXh0XCI7XHJcbiAgICAgICAgICAgICAgICBvZmYgPSB0bztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAob2ZmIDwgbGFiZWwubGVuZ3RoKVxyXG4gICAgICAgICAgICAgICAgbGFiZWxFbHQuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUobGFiZWwuc2xpY2Uob2ZmKSkpO1xyXG4gICAgICAgICAgICByZXR1cm4gbGFiZWxFbHQ7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBwb3NpdGlvbjogNTBcclxuICAgIH0sIHtcclxuICAgICAgICByZW5kZXIoY29tcGxldGlvbikge1xyXG4gICAgICAgICAgICBpZiAoIWNvbXBsZXRpb24uZGV0YWlsKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgIGxldCBkZXRhaWxFbHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3BhblwiKTtcclxuICAgICAgICAgICAgZGV0YWlsRWx0LmNsYXNzTmFtZSA9IFwiY20tY29tcGxldGlvbkRldGFpbFwiO1xyXG4gICAgICAgICAgICBkZXRhaWxFbHQudGV4dENvbnRlbnQgPSBjb21wbGV0aW9uLmRldGFpbDtcclxuICAgICAgICAgICAgcmV0dXJuIGRldGFpbEVsdDtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHBvc2l0aW9uOiA4MFxyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gY29udGVudC5zb3J0KChhLCBiKSA9PiBhLnBvc2l0aW9uIC0gYi5wb3NpdGlvbikubWFwKGEgPT4gYS5yZW5kZXIpO1xyXG59XHJcbmZ1bmN0aW9uIHJhbmdlQXJvdW5kU2VsZWN0ZWQodG90YWwsIHNlbGVjdGVkLCBtYXgpIHtcclxuICAgIGlmICh0b3RhbCA8PSBtYXgpXHJcbiAgICAgICAgcmV0dXJuIHsgZnJvbTogMCwgdG86IHRvdGFsIH07XHJcbiAgICBpZiAoc2VsZWN0ZWQgPCAwKVxyXG4gICAgICAgIHNlbGVjdGVkID0gMDtcclxuICAgIGlmIChzZWxlY3RlZCA8PSAodG90YWwgPj4gMSkpIHtcclxuICAgICAgICBsZXQgb2ZmID0gTWF0aC5mbG9vcihzZWxlY3RlZCAvIG1heCk7XHJcbiAgICAgICAgcmV0dXJuIHsgZnJvbTogb2ZmICogbWF4LCB0bzogKG9mZiArIDEpICogbWF4IH07XHJcbiAgICB9XHJcbiAgICBsZXQgb2ZmID0gTWF0aC5mbG9vcigodG90YWwgLSBzZWxlY3RlZCkgLyBtYXgpO1xyXG4gICAgcmV0dXJuIHsgZnJvbTogdG90YWwgLSAob2ZmICsgMSkgKiBtYXgsIHRvOiB0b3RhbCAtIG9mZiAqIG1heCB9O1xyXG59XHJcbmNsYXNzIENvbXBsZXRpb25Ub29sdGlwIHtcclxuICAgIGNvbnN0cnVjdG9yKHZpZXcsIHN0YXRlRmllbGQpIHtcclxuICAgICAgICB0aGlzLnZpZXcgPSB2aWV3O1xyXG4gICAgICAgIHRoaXMuc3RhdGVGaWVsZCA9IHN0YXRlRmllbGQ7XHJcbiAgICAgICAgdGhpcy5pbmZvID0gbnVsbDtcclxuICAgICAgICB0aGlzLnBsYWNlSW5mbyA9IHtcclxuICAgICAgICAgICAgcmVhZDogKCkgPT4gdGhpcy5tZWFzdXJlSW5mbygpLFxyXG4gICAgICAgICAgICB3cml0ZTogKHBvcykgPT4gdGhpcy5wb3NpdGlvbkluZm8ocG9zKSxcclxuICAgICAgICAgICAga2V5OiB0aGlzXHJcbiAgICAgICAgfTtcclxuICAgICAgICB0aGlzLnNwYWNlID0gbnVsbDtcclxuICAgICAgICB0aGlzLmN1cnJlbnRDbGFzcyA9IFwiXCI7XHJcbiAgICAgICAgbGV0IGNTdGF0ZSA9IHZpZXcuc3RhdGUuZmllbGQoc3RhdGVGaWVsZCk7XHJcbiAgICAgICAgbGV0IHsgb3B0aW9ucywgc2VsZWN0ZWQgfSA9IGNTdGF0ZS5vcGVuO1xyXG4gICAgICAgIGxldCBjb25maWcgPSB2aWV3LnN0YXRlLmZhY2V0KGNvbXBsZXRpb25Db25maWcpO1xyXG4gICAgICAgIHRoaXMub3B0aW9uQ29udGVudCA9IG9wdGlvbkNvbnRlbnQoY29uZmlnKTtcclxuICAgICAgICB0aGlzLm9wdGlvbkNsYXNzID0gY29uZmlnLm9wdGlvbkNsYXNzO1xyXG4gICAgICAgIHRoaXMudG9vbHRpcENsYXNzID0gY29uZmlnLnRvb2x0aXBDbGFzcztcclxuICAgICAgICB0aGlzLnJhbmdlID0gcmFuZ2VBcm91bmRTZWxlY3RlZChvcHRpb25zLmxlbmd0aCwgc2VsZWN0ZWQsIGNvbmZpZy5tYXhSZW5kZXJlZE9wdGlvbnMpO1xyXG4gICAgICAgIHRoaXMuZG9tID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcclxuICAgICAgICB0aGlzLmRvbS5jbGFzc05hbWUgPSBcImNtLXRvb2x0aXAtYXV0b2NvbXBsZXRlXCI7XHJcbiAgICAgICAgdGhpcy51cGRhdGVUb29sdGlwQ2xhc3Modmlldy5zdGF0ZSk7XHJcbiAgICAgICAgdGhpcy5kb20uYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlZG93blwiLCAoZSkgPT4ge1xyXG4gICAgICAgICAgICBmb3IgKGxldCBkb20gPSBlLnRhcmdldCwgbWF0Y2g7IGRvbSAmJiBkb20gIT0gdGhpcy5kb207IGRvbSA9IGRvbS5wYXJlbnROb2RlKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZG9tLm5vZGVOYW1lID09IFwiTElcIiAmJiAobWF0Y2ggPSAvLShcXGQrKSQvLmV4ZWMoZG9tLmlkKSkgJiYgK21hdGNoWzFdIDwgb3B0aW9ucy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgICAgICBhcHBseUNvbXBsZXRpb24odmlldywgb3B0aW9uc1srbWF0Y2hbMV1dKTtcclxuICAgICAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5saXN0ID0gdGhpcy5kb20uYXBwZW5kQ2hpbGQodGhpcy5jcmVhdGVMaXN0Qm94KG9wdGlvbnMsIGNTdGF0ZS5pZCwgdGhpcy5yYW5nZSkpO1xyXG4gICAgICAgIHRoaXMubGlzdC5hZGRFdmVudExpc3RlbmVyKFwic2Nyb2xsXCIsICgpID0+IHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuaW5mbylcclxuICAgICAgICAgICAgICAgIHRoaXMudmlldy5yZXF1ZXN0TWVhc3VyZSh0aGlzLnBsYWNlSW5mbyk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBtb3VudCgpIHsgdGhpcy51cGRhdGVTZWwoKTsgfVxyXG4gICAgdXBkYXRlKHVwZGF0ZSkge1xyXG4gICAgICAgIHZhciBfYSwgX2IsIF9jO1xyXG4gICAgICAgIGxldCBjU3RhdGUgPSB1cGRhdGUuc3RhdGUuZmllbGQodGhpcy5zdGF0ZUZpZWxkKTtcclxuICAgICAgICBsZXQgcHJldlN0YXRlID0gdXBkYXRlLnN0YXJ0U3RhdGUuZmllbGQodGhpcy5zdGF0ZUZpZWxkKTtcclxuICAgICAgICB0aGlzLnVwZGF0ZVRvb2x0aXBDbGFzcyh1cGRhdGUuc3RhdGUpO1xyXG4gICAgICAgIGlmIChjU3RhdGUgIT0gcHJldlN0YXRlKSB7XHJcbiAgICAgICAgICAgIHRoaXMudXBkYXRlU2VsKCk7XHJcbiAgICAgICAgICAgIGlmICgoKF9hID0gY1N0YXRlLm9wZW4pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5kaXNhYmxlZCkgIT0gKChfYiA9IHByZXZTdGF0ZS5vcGVuKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuZGlzYWJsZWQpKVxyXG4gICAgICAgICAgICAgICAgdGhpcy5kb20uY2xhc3NMaXN0LnRvZ2dsZShcImNtLXRvb2x0aXAtYXV0b2NvbXBsZXRlLWRpc2FibGVkXCIsICEhKChfYyA9IGNTdGF0ZS5vcGVuKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuZGlzYWJsZWQpKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICB1cGRhdGVUb29sdGlwQ2xhc3Moc3RhdGUpIHtcclxuICAgICAgICBsZXQgY2xzID0gdGhpcy50b29sdGlwQ2xhc3Moc3RhdGUpO1xyXG4gICAgICAgIGlmIChjbHMgIT0gdGhpcy5jdXJyZW50Q2xhc3MpIHtcclxuICAgICAgICAgICAgZm9yIChsZXQgYyBvZiB0aGlzLmN1cnJlbnRDbGFzcy5zcGxpdChcIiBcIikpXHJcbiAgICAgICAgICAgICAgICBpZiAoYylcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRvbS5jbGFzc0xpc3QucmVtb3ZlKGMpO1xyXG4gICAgICAgICAgICBmb3IgKGxldCBjIG9mIGNscy5zcGxpdChcIiBcIikpXHJcbiAgICAgICAgICAgICAgICBpZiAoYylcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRvbS5jbGFzc0xpc3QuYWRkKGMpO1xyXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRDbGFzcyA9IGNscztcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBwb3NpdGlvbmVkKHNwYWNlKSB7XHJcbiAgICAgICAgdGhpcy5zcGFjZSA9IHNwYWNlO1xyXG4gICAgICAgIGlmICh0aGlzLmluZm8pXHJcbiAgICAgICAgICAgIHRoaXMudmlldy5yZXF1ZXN0TWVhc3VyZSh0aGlzLnBsYWNlSW5mbyk7XHJcbiAgICB9XHJcbiAgICB1cGRhdGVTZWwoKSB7XHJcbiAgICAgICAgbGV0IGNTdGF0ZSA9IHRoaXMudmlldy5zdGF0ZS5maWVsZCh0aGlzLnN0YXRlRmllbGQpLCBvcGVuID0gY1N0YXRlLm9wZW47XHJcbiAgICAgICAgaWYgKG9wZW4uc2VsZWN0ZWQgPiAtMSAmJiBvcGVuLnNlbGVjdGVkIDwgdGhpcy5yYW5nZS5mcm9tIHx8IG9wZW4uc2VsZWN0ZWQgPj0gdGhpcy5yYW5nZS50bykge1xyXG4gICAgICAgICAgICB0aGlzLnJhbmdlID0gcmFuZ2VBcm91bmRTZWxlY3RlZChvcGVuLm9wdGlvbnMubGVuZ3RoLCBvcGVuLnNlbGVjdGVkLCB0aGlzLnZpZXcuc3RhdGUuZmFjZXQoY29tcGxldGlvbkNvbmZpZykubWF4UmVuZGVyZWRPcHRpb25zKTtcclxuICAgICAgICAgICAgdGhpcy5saXN0LnJlbW92ZSgpO1xyXG4gICAgICAgICAgICB0aGlzLmxpc3QgPSB0aGlzLmRvbS5hcHBlbmRDaGlsZCh0aGlzLmNyZWF0ZUxpc3RCb3gob3Blbi5vcHRpb25zLCBjU3RhdGUuaWQsIHRoaXMucmFuZ2UpKTtcclxuICAgICAgICAgICAgdGhpcy5saXN0LmFkZEV2ZW50TGlzdGVuZXIoXCJzY3JvbGxcIiwgKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaW5mbylcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnZpZXcucmVxdWVzdE1lYXN1cmUodGhpcy5wbGFjZUluZm8pO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMudXBkYXRlU2VsZWN0ZWRPcHRpb24ob3Blbi5zZWxlY3RlZCkpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuaW5mbykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5pbmZvLnJlbW92ZSgpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5pbmZvID0gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBsZXQgeyBjb21wbGV0aW9uIH0gPSBvcGVuLm9wdGlvbnNbb3Blbi5zZWxlY3RlZF07XHJcbiAgICAgICAgICAgIGxldCB7IGluZm8gfSA9IGNvbXBsZXRpb247XHJcbiAgICAgICAgICAgIGlmICghaW5mbylcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgbGV0IGluZm9SZXN1bHQgPSB0eXBlb2YgaW5mbyA9PT0gJ3N0cmluZycgPyBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShpbmZvKSA6IGluZm8oY29tcGxldGlvbik7XHJcbiAgICAgICAgICAgIGlmICghaW5mb1Jlc3VsdClcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgaWYgKCd0aGVuJyBpbiBpbmZvUmVzdWx0KSB7XHJcbiAgICAgICAgICAgICAgICBpbmZvUmVzdWx0LnRoZW4obm9kZSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUgJiYgdGhpcy52aWV3LnN0YXRlLmZpZWxkKHRoaXMuc3RhdGVGaWVsZCwgZmFsc2UpID09IGNTdGF0ZSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hZGRJbmZvUGFuZShub2RlKTtcclxuICAgICAgICAgICAgICAgIH0pLmNhdGNoKGUgPT4gbG9nRXhjZXB0aW9uKHRoaXMudmlldy5zdGF0ZSwgZSwgXCJjb21wbGV0aW9uIGluZm9cIikpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5hZGRJbmZvUGFuZShpbmZvUmVzdWx0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGFkZEluZm9QYW5lKGNvbnRlbnQpIHtcclxuICAgICAgICBsZXQgZG9tID0gdGhpcy5pbmZvID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcclxuICAgICAgICBkb20uY2xhc3NOYW1lID0gXCJjbS10b29sdGlwIGNtLWNvbXBsZXRpb25JbmZvXCI7XHJcbiAgICAgICAgZG9tLmFwcGVuZENoaWxkKGNvbnRlbnQpO1xyXG4gICAgICAgIHRoaXMuZG9tLmFwcGVuZENoaWxkKGRvbSk7XHJcbiAgICAgICAgdGhpcy52aWV3LnJlcXVlc3RNZWFzdXJlKHRoaXMucGxhY2VJbmZvKTtcclxuICAgIH1cclxuICAgIHVwZGF0ZVNlbGVjdGVkT3B0aW9uKHNlbGVjdGVkKSB7XHJcbiAgICAgICAgbGV0IHNldCA9IG51bGw7XHJcbiAgICAgICAgZm9yIChsZXQgb3B0ID0gdGhpcy5saXN0LmZpcnN0Q2hpbGQsIGkgPSB0aGlzLnJhbmdlLmZyb207IG9wdDsgb3B0ID0gb3B0Lm5leHRTaWJsaW5nLCBpKyspIHtcclxuICAgICAgICAgICAgaWYgKGkgPT0gc2VsZWN0ZWQpIHtcclxuICAgICAgICAgICAgICAgIGlmICghb3B0Lmhhc0F0dHJpYnV0ZShcImFyaWEtc2VsZWN0ZWRcIikpIHtcclxuICAgICAgICAgICAgICAgICAgICBvcHQuc2V0QXR0cmlidXRlKFwiYXJpYS1zZWxlY3RlZFwiLCBcInRydWVcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgc2V0ID0gb3B0O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgaWYgKG9wdC5oYXNBdHRyaWJ1dGUoXCJhcmlhLXNlbGVjdGVkXCIpKVxyXG4gICAgICAgICAgICAgICAgICAgIG9wdC5yZW1vdmVBdHRyaWJ1dGUoXCJhcmlhLXNlbGVjdGVkXCIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChzZXQpXHJcbiAgICAgICAgICAgIHNjcm9sbEludG9WaWV3KHRoaXMubGlzdCwgc2V0KTtcclxuICAgICAgICByZXR1cm4gc2V0O1xyXG4gICAgfVxyXG4gICAgbWVhc3VyZUluZm8oKSB7XHJcbiAgICAgICAgbGV0IHNlbCA9IHRoaXMuZG9tLnF1ZXJ5U2VsZWN0b3IoXCJbYXJpYS1zZWxlY3RlZF1cIik7XHJcbiAgICAgICAgaWYgKCFzZWwgfHwgIXRoaXMuaW5mbylcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgbGV0IGxpc3RSZWN0ID0gdGhpcy5kb20uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XHJcbiAgICAgICAgbGV0IGluZm9SZWN0ID0gdGhpcy5pbmZvLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xyXG4gICAgICAgIGxldCBzZWxSZWN0ID0gc2VsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xyXG4gICAgICAgIGxldCBzcGFjZSA9IHRoaXMuc3BhY2U7XHJcbiAgICAgICAgaWYgKCFzcGFjZSkge1xyXG4gICAgICAgICAgICBsZXQgd2luID0gdGhpcy5kb20ub3duZXJEb2N1bWVudC5kZWZhdWx0VmlldyB8fCB3aW5kb3c7XHJcbiAgICAgICAgICAgIHNwYWNlID0geyBsZWZ0OiAwLCB0b3A6IDAsIHJpZ2h0OiB3aW4uaW5uZXJXaWR0aCwgYm90dG9tOiB3aW4uaW5uZXJIZWlnaHQgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHNlbFJlY3QudG9wID4gTWF0aC5taW4oc3BhY2UuYm90dG9tLCBsaXN0UmVjdC5ib3R0b20pIC0gMTAgfHxcclxuICAgICAgICAgICAgc2VsUmVjdC5ib3R0b20gPCBNYXRoLm1heChzcGFjZS50b3AsIGxpc3RSZWN0LnRvcCkgKyAxMClcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgbGV0IHJ0bCA9IHRoaXMudmlldy50ZXh0RGlyZWN0aW9uID09IERpcmVjdGlvbi5SVEwsIGxlZnQgPSBydGwsIG5hcnJvdyA9IGZhbHNlLCBtYXhXaWR0aDtcclxuICAgICAgICBsZXQgdG9wID0gXCJcIiwgYm90dG9tID0gXCJcIjtcclxuICAgICAgICBsZXQgc3BhY2VMZWZ0ID0gbGlzdFJlY3QubGVmdCAtIHNwYWNlLmxlZnQsIHNwYWNlUmlnaHQgPSBzcGFjZS5yaWdodCAtIGxpc3RSZWN0LnJpZ2h0O1xyXG4gICAgICAgIGlmIChsZWZ0ICYmIHNwYWNlTGVmdCA8IE1hdGgubWluKGluZm9SZWN0LndpZHRoLCBzcGFjZVJpZ2h0KSlcclxuICAgICAgICAgICAgbGVmdCA9IGZhbHNlO1xyXG4gICAgICAgIGVsc2UgaWYgKCFsZWZ0ICYmIHNwYWNlUmlnaHQgPCBNYXRoLm1pbihpbmZvUmVjdC53aWR0aCwgc3BhY2VMZWZ0KSlcclxuICAgICAgICAgICAgbGVmdCA9IHRydWU7XHJcbiAgICAgICAgaWYgKGluZm9SZWN0LndpZHRoIDw9IChsZWZ0ID8gc3BhY2VMZWZ0IDogc3BhY2VSaWdodCkpIHtcclxuICAgICAgICAgICAgdG9wID0gKE1hdGgubWF4KHNwYWNlLnRvcCwgTWF0aC5taW4oc2VsUmVjdC50b3AsIHNwYWNlLmJvdHRvbSAtIGluZm9SZWN0LmhlaWdodCkpIC0gbGlzdFJlY3QudG9wKSArIFwicHhcIjtcclxuICAgICAgICAgICAgbWF4V2lkdGggPSBNYXRoLm1pbig0MDAgLyogSW5mby5XaWR0aCAqLywgbGVmdCA/IHNwYWNlTGVmdCA6IHNwYWNlUmlnaHQpICsgXCJweFwiO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgbmFycm93ID0gdHJ1ZTtcclxuICAgICAgICAgICAgbWF4V2lkdGggPSBNYXRoLm1pbig0MDAgLyogSW5mby5XaWR0aCAqLywgKHJ0bCA/IGxpc3RSZWN0LnJpZ2h0IDogc3BhY2UucmlnaHQgLSBsaXN0UmVjdC5sZWZ0KSAtIDMwIC8qIEluZm8uTWFyZ2luICovKSArIFwicHhcIjtcclxuICAgICAgICAgICAgbGV0IHNwYWNlQmVsb3cgPSBzcGFjZS5ib3R0b20gLSBsaXN0UmVjdC5ib3R0b207XHJcbiAgICAgICAgICAgIGlmIChzcGFjZUJlbG93ID49IGluZm9SZWN0LmhlaWdodCB8fCBzcGFjZUJlbG93ID4gbGlzdFJlY3QudG9wKSAvLyBCZWxvdyB0aGUgY29tcGxldGlvblxyXG4gICAgICAgICAgICAgICAgdG9wID0gKHNlbFJlY3QuYm90dG9tIC0gbGlzdFJlY3QudG9wKSArIFwicHhcIjtcclxuICAgICAgICAgICAgZWxzZSAvLyBBYm92ZSBpdFxyXG4gICAgICAgICAgICAgICAgYm90dG9tID0gKGxpc3RSZWN0LmJvdHRvbSAtIHNlbFJlY3QudG9wKSArIFwicHhcIjtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgdG9wLCBib3R0b20sIG1heFdpZHRoLFxyXG4gICAgICAgICAgICBjbGFzczogbmFycm93ID8gKHJ0bCA/IFwibGVmdC1uYXJyb3dcIiA6IFwicmlnaHQtbmFycm93XCIpIDogbGVmdCA/IFwibGVmdFwiIDogXCJyaWdodFwiLFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICBwb3NpdGlvbkluZm8ocG9zKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuaW5mbykge1xyXG4gICAgICAgICAgICBpZiAocG9zKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmluZm8uc3R5bGUudG9wID0gcG9zLnRvcDtcclxuICAgICAgICAgICAgICAgIHRoaXMuaW5mby5zdHlsZS5ib3R0b20gPSBwb3MuYm90dG9tO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5pbmZvLnN0eWxlLm1heFdpZHRoID0gcG9zLm1heFdpZHRoO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5pbmZvLmNsYXNzTmFtZSA9IFwiY20tdG9vbHRpcCBjbS1jb21wbGV0aW9uSW5mbyBjbS1jb21wbGV0aW9uSW5mby1cIiArIHBvcy5jbGFzcztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuaW5mby5zdHlsZS50b3AgPSBcIi0xZTZweFwiO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgY3JlYXRlTGlzdEJveChvcHRpb25zLCBpZCwgcmFuZ2UpIHtcclxuICAgICAgICBjb25zdCB1bCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJ1bFwiKTtcclxuICAgICAgICB1bC5pZCA9IGlkO1xyXG4gICAgICAgIHVsLnNldEF0dHJpYnV0ZShcInJvbGVcIiwgXCJsaXN0Ym94XCIpO1xyXG4gICAgICAgIHVsLnNldEF0dHJpYnV0ZShcImFyaWEtZXhwYW5kZWRcIiwgXCJ0cnVlXCIpO1xyXG4gICAgICAgIHVsLnNldEF0dHJpYnV0ZShcImFyaWEtbGFiZWxcIiwgdGhpcy52aWV3LnN0YXRlLnBocmFzZShcIkNvbXBsZXRpb25zXCIpKTtcclxuICAgICAgICBmb3IgKGxldCBpID0gcmFuZ2UuZnJvbTsgaSA8IHJhbmdlLnRvOyBpKyspIHtcclxuICAgICAgICAgICAgbGV0IHsgY29tcGxldGlvbiwgbWF0Y2ggfSA9IG9wdGlvbnNbaV07XHJcbiAgICAgICAgICAgIGNvbnN0IGxpID0gdWwuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImxpXCIpKTtcclxuICAgICAgICAgICAgbGkuaWQgPSBpZCArIFwiLVwiICsgaTtcclxuICAgICAgICAgICAgbGkuc2V0QXR0cmlidXRlKFwicm9sZVwiLCBcIm9wdGlvblwiKTtcclxuICAgICAgICAgICAgbGV0IGNscyA9IHRoaXMub3B0aW9uQ2xhc3MoY29tcGxldGlvbik7XHJcbiAgICAgICAgICAgIGlmIChjbHMpXHJcbiAgICAgICAgICAgICAgICBsaS5jbGFzc05hbWUgPSBjbHM7XHJcbiAgICAgICAgICAgIGZvciAobGV0IHNvdXJjZSBvZiB0aGlzLm9wdGlvbkNvbnRlbnQpIHtcclxuICAgICAgICAgICAgICAgIGxldCBub2RlID0gc291cmNlKGNvbXBsZXRpb24sIHRoaXMudmlldy5zdGF0ZSwgbWF0Y2gpO1xyXG4gICAgICAgICAgICAgICAgaWYgKG5vZGUpXHJcbiAgICAgICAgICAgICAgICAgICAgbGkuYXBwZW5kQ2hpbGQobm9kZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHJhbmdlLmZyb20pXHJcbiAgICAgICAgICAgIHVsLmNsYXNzTGlzdC5hZGQoXCJjbS1jb21wbGV0aW9uTGlzdEluY29tcGxldGVUb3BcIik7XHJcbiAgICAgICAgaWYgKHJhbmdlLnRvIDwgb3B0aW9ucy5sZW5ndGgpXHJcbiAgICAgICAgICAgIHVsLmNsYXNzTGlzdC5hZGQoXCJjbS1jb21wbGV0aW9uTGlzdEluY29tcGxldGVCb3R0b21cIik7XHJcbiAgICAgICAgcmV0dXJuIHVsO1xyXG4gICAgfVxyXG59XHJcbi8vIFdlIGFsbG9jYXRlIGEgbmV3IGZ1bmN0aW9uIGluc3RhbmNlIGV2ZXJ5IHRpbWUgdGhlIGNvbXBsZXRpb25cclxuLy8gY2hhbmdlcyB0byBmb3JjZSByZWRyYXdpbmcvcmVwb3NpdGlvbmluZyBvZiB0aGUgdG9vbHRpcFxyXG5mdW5jdGlvbiBjb21wbGV0aW9uVG9vbHRpcChzdGF0ZUZpZWxkKSB7XHJcbiAgICByZXR1cm4gKHZpZXcpID0+IG5ldyBDb21wbGV0aW9uVG9vbHRpcCh2aWV3LCBzdGF0ZUZpZWxkKTtcclxufVxyXG5mdW5jdGlvbiBzY3JvbGxJbnRvVmlldyhjb250YWluZXIsIGVsZW1lbnQpIHtcclxuICAgIGxldCBwYXJlbnQgPSBjb250YWluZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XHJcbiAgICBsZXQgc2VsZiA9IGVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XHJcbiAgICBpZiAoc2VsZi50b3AgPCBwYXJlbnQudG9wKVxyXG4gICAgICAgIGNvbnRhaW5lci5zY3JvbGxUb3AgLT0gcGFyZW50LnRvcCAtIHNlbGYudG9wO1xyXG4gICAgZWxzZSBpZiAoc2VsZi5ib3R0b20gPiBwYXJlbnQuYm90dG9tKVxyXG4gICAgICAgIGNvbnRhaW5lci5zY3JvbGxUb3AgKz0gc2VsZi5ib3R0b20gLSBwYXJlbnQuYm90dG9tO1xyXG59XHJcblxyXG4vLyBVc2VkIHRvIHBpY2sgYSBwcmVmZXJyZWQgb3B0aW9uIHdoZW4gdHdvIG9wdGlvbnMgd2l0aCB0aGUgc2FtZVxyXG4vLyBsYWJlbCBvY2N1ciBpbiB0aGUgcmVzdWx0LlxyXG5mdW5jdGlvbiBzY29yZShvcHRpb24pIHtcclxuICAgIHJldHVybiAob3B0aW9uLmJvb3N0IHx8IDApICogMTAwICsgKG9wdGlvbi5hcHBseSA/IDEwIDogMCkgKyAob3B0aW9uLmluZm8gPyA1IDogMCkgK1xyXG4gICAgICAgIChvcHRpb24udHlwZSA/IDEgOiAwKTtcclxufVxyXG5mdW5jdGlvbiBzb3J0T3B0aW9ucyhhY3RpdmUsIHN0YXRlKSB7XHJcbiAgICBsZXQgb3B0aW9ucyA9IFtdLCBpID0gMDtcclxuICAgIGZvciAobGV0IGEgb2YgYWN0aXZlKVxyXG4gICAgICAgIGlmIChhLmhhc1Jlc3VsdCgpKSB7XHJcbiAgICAgICAgICAgIGlmIChhLnJlc3VsdC5maWx0ZXIgPT09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgZ2V0TWF0Y2ggPSBhLnJlc3VsdC5nZXRNYXRjaDtcclxuICAgICAgICAgICAgICAgIGZvciAobGV0IG9wdGlvbiBvZiBhLnJlc3VsdC5vcHRpb25zKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IG1hdGNoID0gWzFlOSAtIGkrK107XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGdldE1hdGNoKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBuIG9mIGdldE1hdGNoKG9wdGlvbikpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRjaC5wdXNoKG4pO1xyXG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMucHVzaChuZXcgT3B0aW9uKG9wdGlvbiwgYSwgbWF0Y2gpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGxldCBtYXRjaGVyID0gbmV3IEZ1enp5TWF0Y2hlcihzdGF0ZS5zbGljZURvYyhhLmZyb20sIGEudG8pKSwgbWF0Y2g7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBvcHRpb24gb2YgYS5yZXN1bHQub3B0aW9ucylcclxuICAgICAgICAgICAgICAgICAgICBpZiAobWF0Y2ggPSBtYXRjaGVyLm1hdGNoKG9wdGlvbi5sYWJlbCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbi5ib29zdCAhPSBudWxsKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hbMF0gKz0gb3B0aW9uLmJvb3N0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLnB1c2gobmV3IE9wdGlvbihvcHRpb24sIGEsIG1hdGNoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgbGV0IHJlc3VsdCA9IFtdLCBwcmV2ID0gbnVsbDtcclxuICAgIGxldCBjb21wYXJlID0gc3RhdGUuZmFjZXQoY29tcGxldGlvbkNvbmZpZykuY29tcGFyZUNvbXBsZXRpb25zO1xyXG4gICAgZm9yIChsZXQgb3B0IG9mIG9wdGlvbnMuc29ydCgoYSwgYikgPT4gKGIubWF0Y2hbMF0gLSBhLm1hdGNoWzBdKSB8fCBjb21wYXJlKGEuY29tcGxldGlvbiwgYi5jb21wbGV0aW9uKSkpIHtcclxuICAgICAgICBpZiAoIXByZXYgfHwgcHJldi5sYWJlbCAhPSBvcHQuY29tcGxldGlvbi5sYWJlbCB8fCBwcmV2LmRldGFpbCAhPSBvcHQuY29tcGxldGlvbi5kZXRhaWwgfHxcclxuICAgICAgICAgICAgKHByZXYudHlwZSAhPSBudWxsICYmIG9wdC5jb21wbGV0aW9uLnR5cGUgIT0gbnVsbCAmJiBwcmV2LnR5cGUgIT0gb3B0LmNvbXBsZXRpb24udHlwZSkgfHxcclxuICAgICAgICAgICAgcHJldi5hcHBseSAhPSBvcHQuY29tcGxldGlvbi5hcHBseSlcclxuICAgICAgICAgICAgcmVzdWx0LnB1c2gob3B0KTtcclxuICAgICAgICBlbHNlIGlmIChzY29yZShvcHQuY29tcGxldGlvbikgPiBzY29yZShwcmV2KSlcclxuICAgICAgICAgICAgcmVzdWx0W3Jlc3VsdC5sZW5ndGggLSAxXSA9IG9wdDtcclxuICAgICAgICBwcmV2ID0gb3B0LmNvbXBsZXRpb247XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59XHJcbmNsYXNzIENvbXBsZXRpb25EaWFsb2cge1xyXG4gICAgY29uc3RydWN0b3Iob3B0aW9ucywgYXR0cnMsIHRvb2x0aXAsIHRpbWVzdGFtcCwgc2VsZWN0ZWQsIGRpc2FibGVkKSB7XHJcbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcclxuICAgICAgICB0aGlzLmF0dHJzID0gYXR0cnM7XHJcbiAgICAgICAgdGhpcy50b29sdGlwID0gdG9vbHRpcDtcclxuICAgICAgICB0aGlzLnRpbWVzdGFtcCA9IHRpbWVzdGFtcDtcclxuICAgICAgICB0aGlzLnNlbGVjdGVkID0gc2VsZWN0ZWQ7XHJcbiAgICAgICAgdGhpcy5kaXNhYmxlZCA9IGRpc2FibGVkO1xyXG4gICAgfVxyXG4gICAgc2V0U2VsZWN0ZWQoc2VsZWN0ZWQsIGlkKSB7XHJcbiAgICAgICAgcmV0dXJuIHNlbGVjdGVkID09IHRoaXMuc2VsZWN0ZWQgfHwgc2VsZWN0ZWQgPj0gdGhpcy5vcHRpb25zLmxlbmd0aCA/IHRoaXNcclxuICAgICAgICAgICAgOiBuZXcgQ29tcGxldGlvbkRpYWxvZyh0aGlzLm9wdGlvbnMsIG1ha2VBdHRycyhpZCwgc2VsZWN0ZWQpLCB0aGlzLnRvb2x0aXAsIHRoaXMudGltZXN0YW1wLCBzZWxlY3RlZCwgdGhpcy5kaXNhYmxlZCk7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgYnVpbGQoYWN0aXZlLCBzdGF0ZSwgaWQsIHByZXYsIGNvbmYpIHtcclxuICAgICAgICBsZXQgb3B0aW9ucyA9IHNvcnRPcHRpb25zKGFjdGl2ZSwgc3RhdGUpO1xyXG4gICAgICAgIGlmICghb3B0aW9ucy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHByZXYgJiYgYWN0aXZlLnNvbWUoYSA9PiBhLnN0YXRlID09IDEgLyogU3RhdGUuUGVuZGluZyAqLykgP1xyXG4gICAgICAgICAgICAgICAgbmV3IENvbXBsZXRpb25EaWFsb2cocHJldi5vcHRpb25zLCBwcmV2LmF0dHJzLCBwcmV2LnRvb2x0aXAsIHByZXYudGltZXN0YW1wLCBwcmV2LnNlbGVjdGVkLCB0cnVlKSA6IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCBzZWxlY3RlZCA9IHN0YXRlLmZhY2V0KGNvbXBsZXRpb25Db25maWcpLnNlbGVjdE9uT3BlbiA/IDAgOiAtMTtcclxuICAgICAgICBpZiAocHJldiAmJiBwcmV2LnNlbGVjdGVkICE9IHNlbGVjdGVkICYmIHByZXYuc2VsZWN0ZWQgIT0gLTEpIHtcclxuICAgICAgICAgICAgbGV0IHNlbGVjdGVkVmFsdWUgPSBwcmV2Lm9wdGlvbnNbcHJldi5zZWxlY3RlZF0uY29tcGxldGlvbjtcclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvcHRpb25zLmxlbmd0aDsgaSsrKVxyXG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnNbaV0uY29tcGxldGlvbiA9PSBzZWxlY3RlZFZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0ZWQgPSBpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbmV3IENvbXBsZXRpb25EaWFsb2cob3B0aW9ucywgbWFrZUF0dHJzKGlkLCBzZWxlY3RlZCksIHtcclxuICAgICAgICAgICAgcG9zOiBhY3RpdmUucmVkdWNlKChhLCBiKSA9PiBiLmhhc1Jlc3VsdCgpID8gTWF0aC5taW4oYSwgYi5mcm9tKSA6IGEsIDFlOCksXHJcbiAgICAgICAgICAgIGNyZWF0ZTogY29tcGxldGlvblRvb2x0aXAoY29tcGxldGlvblN0YXRlKSxcclxuICAgICAgICAgICAgYWJvdmU6IGNvbmYuYWJvdmVDdXJzb3IsXHJcbiAgICAgICAgfSwgcHJldiA/IHByZXYudGltZXN0YW1wIDogRGF0ZS5ub3coKSwgc2VsZWN0ZWQsIGZhbHNlKTtcclxuICAgIH1cclxuICAgIG1hcChjaGFuZ2VzKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBDb21wbGV0aW9uRGlhbG9nKHRoaXMub3B0aW9ucywgdGhpcy5hdHRycywgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLnRvb2x0aXApLCB7IHBvczogY2hhbmdlcy5tYXBQb3ModGhpcy50b29sdGlwLnBvcykgfSksIHRoaXMudGltZXN0YW1wLCB0aGlzLnNlbGVjdGVkLCB0aGlzLmRpc2FibGVkKTtcclxuICAgIH1cclxufVxyXG5jbGFzcyBDb21wbGV0aW9uU3RhdGUge1xyXG4gICAgY29uc3RydWN0b3IoYWN0aXZlLCBpZCwgb3Blbikge1xyXG4gICAgICAgIHRoaXMuYWN0aXZlID0gYWN0aXZlO1xyXG4gICAgICAgIHRoaXMuaWQgPSBpZDtcclxuICAgICAgICB0aGlzLm9wZW4gPSBvcGVuO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIHN0YXJ0KCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgQ29tcGxldGlvblN0YXRlKG5vbmUsIFwiY20tYWMtXCIgKyBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAyZTYpLnRvU3RyaW5nKDM2KSwgbnVsbCk7XHJcbiAgICB9XHJcbiAgICB1cGRhdGUodHIpIHtcclxuICAgICAgICBsZXQgeyBzdGF0ZSB9ID0gdHIsIGNvbmYgPSBzdGF0ZS5mYWNldChjb21wbGV0aW9uQ29uZmlnKTtcclxuICAgICAgICBsZXQgc291cmNlcyA9IGNvbmYub3ZlcnJpZGUgfHxcclxuICAgICAgICAgICAgc3RhdGUubGFuZ3VhZ2VEYXRhQXQoXCJhdXRvY29tcGxldGVcIiwgY3VyKHN0YXRlKSkubWFwKGFzU291cmNlKTtcclxuICAgICAgICBsZXQgYWN0aXZlID0gc291cmNlcy5tYXAoc291cmNlID0+IHtcclxuICAgICAgICAgICAgbGV0IHZhbHVlID0gdGhpcy5hY3RpdmUuZmluZChzID0+IHMuc291cmNlID09IHNvdXJjZSkgfHxcclxuICAgICAgICAgICAgICAgIG5ldyBBY3RpdmVTb3VyY2Uoc291cmNlLCB0aGlzLmFjdGl2ZS5zb21lKGEgPT4gYS5zdGF0ZSAhPSAwIC8qIFN0YXRlLkluYWN0aXZlICovKSA/IDEgLyogU3RhdGUuUGVuZGluZyAqLyA6IDAgLyogU3RhdGUuSW5hY3RpdmUgKi8pO1xyXG4gICAgICAgICAgICByZXR1cm4gdmFsdWUudXBkYXRlKHRyLCBjb25mKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICBpZiAoYWN0aXZlLmxlbmd0aCA9PSB0aGlzLmFjdGl2ZS5sZW5ndGggJiYgYWN0aXZlLmV2ZXJ5KChhLCBpKSA9PiBhID09IHRoaXMuYWN0aXZlW2ldKSlcclxuICAgICAgICAgICAgYWN0aXZlID0gdGhpcy5hY3RpdmU7XHJcbiAgICAgICAgbGV0IG9wZW4gPSB0aGlzLm9wZW47XHJcbiAgICAgICAgaWYgKG9wZW4gJiYgdHIuZG9jQ2hhbmdlZClcclxuICAgICAgICAgICAgb3BlbiA9IG9wZW4ubWFwKHRyLmNoYW5nZXMpO1xyXG4gICAgICAgIGlmICh0ci5zZWxlY3Rpb24gfHwgYWN0aXZlLnNvbWUoYSA9PiBhLmhhc1Jlc3VsdCgpICYmIHRyLmNoYW5nZXMudG91Y2hlc1JhbmdlKGEuZnJvbSwgYS50bykpIHx8XHJcbiAgICAgICAgICAgICFzYW1lUmVzdWx0cyhhY3RpdmUsIHRoaXMuYWN0aXZlKSlcclxuICAgICAgICAgICAgb3BlbiA9IENvbXBsZXRpb25EaWFsb2cuYnVpbGQoYWN0aXZlLCBzdGF0ZSwgdGhpcy5pZCwgb3BlbiwgY29uZik7XHJcbiAgICAgICAgZWxzZSBpZiAob3BlbiAmJiBvcGVuLmRpc2FibGVkICYmICFhY3RpdmUuc29tZShhID0+IGEuc3RhdGUgPT0gMSAvKiBTdGF0ZS5QZW5kaW5nICovKSlcclxuICAgICAgICAgICAgb3BlbiA9IG51bGw7XHJcbiAgICAgICAgaWYgKCFvcGVuICYmIGFjdGl2ZS5ldmVyeShhID0+IGEuc3RhdGUgIT0gMSAvKiBTdGF0ZS5QZW5kaW5nICovKSAmJiBhY3RpdmUuc29tZShhID0+IGEuaGFzUmVzdWx0KCkpKVxyXG4gICAgICAgICAgICBhY3RpdmUgPSBhY3RpdmUubWFwKGEgPT4gYS5oYXNSZXN1bHQoKSA/IG5ldyBBY3RpdmVTb3VyY2UoYS5zb3VyY2UsIDAgLyogU3RhdGUuSW5hY3RpdmUgKi8pIDogYSk7XHJcbiAgICAgICAgZm9yIChsZXQgZWZmZWN0IG9mIHRyLmVmZmVjdHMpXHJcbiAgICAgICAgICAgIGlmIChlZmZlY3QuaXMoc2V0U2VsZWN0ZWRFZmZlY3QpKVxyXG4gICAgICAgICAgICAgICAgb3BlbiA9IG9wZW4gJiYgb3Blbi5zZXRTZWxlY3RlZChlZmZlY3QudmFsdWUsIHRoaXMuaWQpO1xyXG4gICAgICAgIHJldHVybiBhY3RpdmUgPT0gdGhpcy5hY3RpdmUgJiYgb3BlbiA9PSB0aGlzLm9wZW4gPyB0aGlzIDogbmV3IENvbXBsZXRpb25TdGF0ZShhY3RpdmUsIHRoaXMuaWQsIG9wZW4pO1xyXG4gICAgfVxyXG4gICAgZ2V0IHRvb2x0aXAoKSB7IHJldHVybiB0aGlzLm9wZW4gPyB0aGlzLm9wZW4udG9vbHRpcCA6IG51bGw7IH1cclxuICAgIGdldCBhdHRycygpIHsgcmV0dXJuIHRoaXMub3BlbiA/IHRoaXMub3Blbi5hdHRycyA6IGJhc2VBdHRyczsgfVxyXG59XHJcbmZ1bmN0aW9uIHNhbWVSZXN1bHRzKGEsIGIpIHtcclxuICAgIGlmIChhID09IGIpXHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICBmb3IgKGxldCBpQSA9IDAsIGlCID0gMDs7KSB7XHJcbiAgICAgICAgd2hpbGUgKGlBIDwgYS5sZW5ndGggJiYgIWFbaUFdLmhhc1Jlc3VsdClcclxuICAgICAgICAgICAgaUErKztcclxuICAgICAgICB3aGlsZSAoaUIgPCBiLmxlbmd0aCAmJiAhYltpQl0uaGFzUmVzdWx0KVxyXG4gICAgICAgICAgICBpQisrO1xyXG4gICAgICAgIGxldCBlbmRBID0gaUEgPT0gYS5sZW5ndGgsIGVuZEIgPSBpQiA9PSBiLmxlbmd0aDtcclxuICAgICAgICBpZiAoZW5kQSB8fCBlbmRCKVxyXG4gICAgICAgICAgICByZXR1cm4gZW5kQSA9PSBlbmRCO1xyXG4gICAgICAgIGlmIChhW2lBKytdLnJlc3VsdCAhPSBiW2lCKytdLnJlc3VsdClcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG59XHJcbmNvbnN0IGJhc2VBdHRycyA9IHtcclxuICAgIFwiYXJpYS1hdXRvY29tcGxldGVcIjogXCJsaXN0XCJcclxufTtcclxuZnVuY3Rpb24gbWFrZUF0dHJzKGlkLCBzZWxlY3RlZCkge1xyXG4gICAgbGV0IHJlc3VsdCA9IHtcclxuICAgICAgICBcImFyaWEtYXV0b2NvbXBsZXRlXCI6IFwibGlzdFwiLFxyXG4gICAgICAgIFwiYXJpYS1oYXNwb3B1cFwiOiBcImxpc3Rib3hcIixcclxuICAgICAgICBcImFyaWEtY29udHJvbHNcIjogaWRcclxuICAgIH07XHJcbiAgICBpZiAoc2VsZWN0ZWQgPiAtMSlcclxuICAgICAgICByZXN1bHRbXCJhcmlhLWFjdGl2ZWRlc2NlbmRhbnRcIl0gPSBpZCArIFwiLVwiICsgc2VsZWN0ZWQ7XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59XHJcbmNvbnN0IG5vbmUgPSBbXTtcclxuZnVuY3Rpb24gZ2V0VXNlckV2ZW50KHRyKSB7XHJcbiAgICByZXR1cm4gdHIuaXNVc2VyRXZlbnQoXCJpbnB1dC50eXBlXCIpID8gXCJpbnB1dFwiIDogdHIuaXNVc2VyRXZlbnQoXCJkZWxldGUuYmFja3dhcmRcIikgPyBcImRlbGV0ZVwiIDogbnVsbDtcclxufVxyXG5jbGFzcyBBY3RpdmVTb3VyY2Uge1xyXG4gICAgY29uc3RydWN0b3Ioc291cmNlLCBzdGF0ZSwgZXhwbGljaXRQb3MgPSAtMSkge1xyXG4gICAgICAgIHRoaXMuc291cmNlID0gc291cmNlO1xyXG4gICAgICAgIHRoaXMuc3RhdGUgPSBzdGF0ZTtcclxuICAgICAgICB0aGlzLmV4cGxpY2l0UG9zID0gZXhwbGljaXRQb3M7XHJcbiAgICB9XHJcbiAgICBoYXNSZXN1bHQoKSB7IHJldHVybiBmYWxzZTsgfVxyXG4gICAgdXBkYXRlKHRyLCBjb25mKSB7XHJcbiAgICAgICAgbGV0IGV2ZW50ID0gZ2V0VXNlckV2ZW50KHRyKSwgdmFsdWUgPSB0aGlzO1xyXG4gICAgICAgIGlmIChldmVudClcclxuICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS5oYW5kbGVVc2VyRXZlbnQodHIsIGV2ZW50LCBjb25mKTtcclxuICAgICAgICBlbHNlIGlmICh0ci5kb2NDaGFuZ2VkKVxyXG4gICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLmhhbmRsZUNoYW5nZSh0cik7XHJcbiAgICAgICAgZWxzZSBpZiAodHIuc2VsZWN0aW9uICYmIHZhbHVlLnN0YXRlICE9IDAgLyogU3RhdGUuSW5hY3RpdmUgKi8pXHJcbiAgICAgICAgICAgIHZhbHVlID0gbmV3IEFjdGl2ZVNvdXJjZSh2YWx1ZS5zb3VyY2UsIDAgLyogU3RhdGUuSW5hY3RpdmUgKi8pO1xyXG4gICAgICAgIGZvciAobGV0IGVmZmVjdCBvZiB0ci5lZmZlY3RzKSB7XHJcbiAgICAgICAgICAgIGlmIChlZmZlY3QuaXMoc3RhcnRDb21wbGV0aW9uRWZmZWN0KSlcclxuICAgICAgICAgICAgICAgIHZhbHVlID0gbmV3IEFjdGl2ZVNvdXJjZSh2YWx1ZS5zb3VyY2UsIDEgLyogU3RhdGUuUGVuZGluZyAqLywgZWZmZWN0LnZhbHVlID8gY3VyKHRyLnN0YXRlKSA6IC0xKTtcclxuICAgICAgICAgICAgZWxzZSBpZiAoZWZmZWN0LmlzKGNsb3NlQ29tcGxldGlvbkVmZmVjdCkpXHJcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IG5ldyBBY3RpdmVTb3VyY2UodmFsdWUuc291cmNlLCAwIC8qIFN0YXRlLkluYWN0aXZlICovKTtcclxuICAgICAgICAgICAgZWxzZSBpZiAoZWZmZWN0LmlzKHNldEFjdGl2ZUVmZmVjdCkpXHJcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBhY3RpdmUgb2YgZWZmZWN0LnZhbHVlKVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChhY3RpdmUuc291cmNlID09IHZhbHVlLnNvdXJjZSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBhY3RpdmU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgIH1cclxuICAgIGhhbmRsZVVzZXJFdmVudCh0ciwgdHlwZSwgY29uZikge1xyXG4gICAgICAgIHJldHVybiB0eXBlID09IFwiZGVsZXRlXCIgfHwgIWNvbmYuYWN0aXZhdGVPblR5cGluZyA/IHRoaXMubWFwKHRyLmNoYW5nZXMpIDogbmV3IEFjdGl2ZVNvdXJjZSh0aGlzLnNvdXJjZSwgMSAvKiBTdGF0ZS5QZW5kaW5nICovKTtcclxuICAgIH1cclxuICAgIGhhbmRsZUNoYW5nZSh0cikge1xyXG4gICAgICAgIHJldHVybiB0ci5jaGFuZ2VzLnRvdWNoZXNSYW5nZShjdXIodHIuc3RhcnRTdGF0ZSkpID8gbmV3IEFjdGl2ZVNvdXJjZSh0aGlzLnNvdXJjZSwgMCAvKiBTdGF0ZS5JbmFjdGl2ZSAqLykgOiB0aGlzLm1hcCh0ci5jaGFuZ2VzKTtcclxuICAgIH1cclxuICAgIG1hcChjaGFuZ2VzKSB7XHJcbiAgICAgICAgcmV0dXJuIGNoYW5nZXMuZW1wdHkgfHwgdGhpcy5leHBsaWNpdFBvcyA8IDAgPyB0aGlzIDogbmV3IEFjdGl2ZVNvdXJjZSh0aGlzLnNvdXJjZSwgdGhpcy5zdGF0ZSwgY2hhbmdlcy5tYXBQb3ModGhpcy5leHBsaWNpdFBvcykpO1xyXG4gICAgfVxyXG59XHJcbmNsYXNzIEFjdGl2ZVJlc3VsdCBleHRlbmRzIEFjdGl2ZVNvdXJjZSB7XHJcbiAgICBjb25zdHJ1Y3Rvcihzb3VyY2UsIGV4cGxpY2l0UG9zLCByZXN1bHQsIGZyb20sIHRvKSB7XHJcbiAgICAgICAgc3VwZXIoc291cmNlLCAyIC8qIFN0YXRlLlJlc3VsdCAqLywgZXhwbGljaXRQb3MpO1xyXG4gICAgICAgIHRoaXMucmVzdWx0ID0gcmVzdWx0O1xyXG4gICAgICAgIHRoaXMuZnJvbSA9IGZyb207XHJcbiAgICAgICAgdGhpcy50byA9IHRvO1xyXG4gICAgfVxyXG4gICAgaGFzUmVzdWx0KCkgeyByZXR1cm4gdHJ1ZTsgfVxyXG4gICAgaGFuZGxlVXNlckV2ZW50KHRyLCB0eXBlLCBjb25mKSB7XHJcbiAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgIGxldCBmcm9tID0gdHIuY2hhbmdlcy5tYXBQb3ModGhpcy5mcm9tKSwgdG8gPSB0ci5jaGFuZ2VzLm1hcFBvcyh0aGlzLnRvLCAxKTtcclxuICAgICAgICBsZXQgcG9zID0gY3VyKHRyLnN0YXRlKTtcclxuICAgICAgICBpZiAoKHRoaXMuZXhwbGljaXRQb3MgPCAwID8gcG9zIDw9IGZyb20gOiBwb3MgPCB0aGlzLmZyb20pIHx8XHJcbiAgICAgICAgICAgIHBvcyA+IHRvIHx8XHJcbiAgICAgICAgICAgIHR5cGUgPT0gXCJkZWxldGVcIiAmJiBjdXIodHIuc3RhcnRTdGF0ZSkgPT0gdGhpcy5mcm9tKVxyXG4gICAgICAgICAgICByZXR1cm4gbmV3IEFjdGl2ZVNvdXJjZSh0aGlzLnNvdXJjZSwgdHlwZSA9PSBcImlucHV0XCIgJiYgY29uZi5hY3RpdmF0ZU9uVHlwaW5nID8gMSAvKiBTdGF0ZS5QZW5kaW5nICovIDogMCAvKiBTdGF0ZS5JbmFjdGl2ZSAqLyk7XHJcbiAgICAgICAgbGV0IGV4cGxpY2l0UG9zID0gdGhpcy5leHBsaWNpdFBvcyA8IDAgPyAtMSA6IHRyLmNoYW5nZXMubWFwUG9zKHRoaXMuZXhwbGljaXRQb3MpLCB1cGRhdGVkO1xyXG4gICAgICAgIGlmIChjaGVja1ZhbGlkKHRoaXMucmVzdWx0LnZhbGlkRm9yLCB0ci5zdGF0ZSwgZnJvbSwgdG8pKVxyXG4gICAgICAgICAgICByZXR1cm4gbmV3IEFjdGl2ZVJlc3VsdCh0aGlzLnNvdXJjZSwgZXhwbGljaXRQb3MsIHRoaXMucmVzdWx0LCBmcm9tLCB0byk7XHJcbiAgICAgICAgaWYgKHRoaXMucmVzdWx0LnVwZGF0ZSAmJlxyXG4gICAgICAgICAgICAodXBkYXRlZCA9IHRoaXMucmVzdWx0LnVwZGF0ZSh0aGlzLnJlc3VsdCwgZnJvbSwgdG8sIG5ldyBDb21wbGV0aW9uQ29udGV4dCh0ci5zdGF0ZSwgcG9zLCBleHBsaWNpdFBvcyA+PSAwKSkpKVxyXG4gICAgICAgICAgICByZXR1cm4gbmV3IEFjdGl2ZVJlc3VsdCh0aGlzLnNvdXJjZSwgZXhwbGljaXRQb3MsIHVwZGF0ZWQsIHVwZGF0ZWQuZnJvbSwgKF9hID0gdXBkYXRlZC50bykgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogY3VyKHRyLnN0YXRlKSk7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBBY3RpdmVTb3VyY2UodGhpcy5zb3VyY2UsIDEgLyogU3RhdGUuUGVuZGluZyAqLywgZXhwbGljaXRQb3MpO1xyXG4gICAgfVxyXG4gICAgaGFuZGxlQ2hhbmdlKHRyKSB7XHJcbiAgICAgICAgcmV0dXJuIHRyLmNoYW5nZXMudG91Y2hlc1JhbmdlKHRoaXMuZnJvbSwgdGhpcy50bykgPyBuZXcgQWN0aXZlU291cmNlKHRoaXMuc291cmNlLCAwIC8qIFN0YXRlLkluYWN0aXZlICovKSA6IHRoaXMubWFwKHRyLmNoYW5nZXMpO1xyXG4gICAgfVxyXG4gICAgbWFwKG1hcHBpbmcpIHtcclxuICAgICAgICByZXR1cm4gbWFwcGluZy5lbXB0eSA/IHRoaXMgOlxyXG4gICAgICAgICAgICBuZXcgQWN0aXZlUmVzdWx0KHRoaXMuc291cmNlLCB0aGlzLmV4cGxpY2l0UG9zIDwgMCA/IC0xIDogbWFwcGluZy5tYXBQb3ModGhpcy5leHBsaWNpdFBvcyksIHRoaXMucmVzdWx0LCBtYXBwaW5nLm1hcFBvcyh0aGlzLmZyb20pLCBtYXBwaW5nLm1hcFBvcyh0aGlzLnRvLCAxKSk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gY2hlY2tWYWxpZCh2YWxpZEZvciwgc3RhdGUsIGZyb20sIHRvKSB7XHJcbiAgICBpZiAoIXZhbGlkRm9yKVxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIGxldCB0ZXh0ID0gc3RhdGUuc2xpY2VEb2MoZnJvbSwgdG8pO1xyXG4gICAgcmV0dXJuIHR5cGVvZiB2YWxpZEZvciA9PSBcImZ1bmN0aW9uXCIgPyB2YWxpZEZvcih0ZXh0LCBmcm9tLCB0bywgc3RhdGUpIDogZW5zdXJlQW5jaG9yKHZhbGlkRm9yLCB0cnVlKS50ZXN0KHRleHQpO1xyXG59XHJcbmNvbnN0IHN0YXJ0Q29tcGxldGlvbkVmZmVjdCA9IC8qQF9fUFVSRV9fKi9TdGF0ZUVmZmVjdC5kZWZpbmUoKTtcclxuY29uc3QgY2xvc2VDb21wbGV0aW9uRWZmZWN0ID0gLypAX19QVVJFX18qL1N0YXRlRWZmZWN0LmRlZmluZSgpO1xyXG5jb25zdCBzZXRBY3RpdmVFZmZlY3QgPSAvKkBfX1BVUkVfXyovU3RhdGVFZmZlY3QuZGVmaW5lKHtcclxuICAgIG1hcChzb3VyY2VzLCBtYXBwaW5nKSB7IHJldHVybiBzb3VyY2VzLm1hcChzID0+IHMubWFwKG1hcHBpbmcpKTsgfVxyXG59KTtcclxuY29uc3Qgc2V0U2VsZWN0ZWRFZmZlY3QgPSAvKkBfX1BVUkVfXyovU3RhdGVFZmZlY3QuZGVmaW5lKCk7XHJcbmNvbnN0IGNvbXBsZXRpb25TdGF0ZSA9IC8qQF9fUFVSRV9fKi9TdGF0ZUZpZWxkLmRlZmluZSh7XHJcbiAgICBjcmVhdGUoKSB7IHJldHVybiBDb21wbGV0aW9uU3RhdGUuc3RhcnQoKTsgfSxcclxuICAgIHVwZGF0ZSh2YWx1ZSwgdHIpIHsgcmV0dXJuIHZhbHVlLnVwZGF0ZSh0cik7IH0sXHJcbiAgICBwcm92aWRlOiBmID0+IFtcclxuICAgICAgICBzaG93VG9vbHRpcC5mcm9tKGYsIHZhbCA9PiB2YWwudG9vbHRpcCksXHJcbiAgICAgICAgRWRpdG9yVmlldy5jb250ZW50QXR0cmlidXRlcy5mcm9tKGYsIHN0YXRlID0+IHN0YXRlLmF0dHJzKVxyXG4gICAgXVxyXG59KTtcclxuXHJcbi8qKlxyXG5SZXR1cm5zIGEgY29tbWFuZCB0aGF0IG1vdmVzIHRoZSBjb21wbGV0aW9uIHNlbGVjdGlvbiBmb3J3YXJkIG9yXHJcbmJhY2t3YXJkIGJ5IHRoZSBnaXZlbiBhbW91bnQuXHJcbiovXHJcbmZ1bmN0aW9uIG1vdmVDb21wbGV0aW9uU2VsZWN0aW9uKGZvcndhcmQsIGJ5ID0gXCJvcHRpb25cIikge1xyXG4gICAgcmV0dXJuICh2aWV3KSA9PiB7XHJcbiAgICAgICAgbGV0IGNTdGF0ZSA9IHZpZXcuc3RhdGUuZmllbGQoY29tcGxldGlvblN0YXRlLCBmYWxzZSk7XHJcbiAgICAgICAgaWYgKCFjU3RhdGUgfHwgIWNTdGF0ZS5vcGVuIHx8IGNTdGF0ZS5vcGVuLmRpc2FibGVkIHx8XHJcbiAgICAgICAgICAgIERhdGUubm93KCkgLSBjU3RhdGUub3Blbi50aW1lc3RhbXAgPCB2aWV3LnN0YXRlLmZhY2V0KGNvbXBsZXRpb25Db25maWcpLmludGVyYWN0aW9uRGVsYXkpXHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICBsZXQgc3RlcCA9IDEsIHRvb2x0aXA7XHJcbiAgICAgICAgaWYgKGJ5ID09IFwicGFnZVwiICYmICh0b29sdGlwID0gZ2V0VG9vbHRpcCh2aWV3LCBjU3RhdGUub3Blbi50b29sdGlwKSkpXHJcbiAgICAgICAgICAgIHN0ZXAgPSBNYXRoLm1heCgyLCBNYXRoLmZsb29yKHRvb2x0aXAuZG9tLm9mZnNldEhlaWdodCAvXHJcbiAgICAgICAgICAgICAgICB0b29sdGlwLmRvbS5xdWVyeVNlbGVjdG9yKFwibGlcIikub2Zmc2V0SGVpZ2h0KSAtIDEpO1xyXG4gICAgICAgIGxldCB7IGxlbmd0aCB9ID0gY1N0YXRlLm9wZW4ub3B0aW9ucztcclxuICAgICAgICBsZXQgc2VsZWN0ZWQgPSBjU3RhdGUub3Blbi5zZWxlY3RlZCA+IC0xID8gY1N0YXRlLm9wZW4uc2VsZWN0ZWQgKyBzdGVwICogKGZvcndhcmQgPyAxIDogLTEpIDogZm9yd2FyZCA/IDAgOiBsZW5ndGggLSAxO1xyXG4gICAgICAgIGlmIChzZWxlY3RlZCA8IDApXHJcbiAgICAgICAgICAgIHNlbGVjdGVkID0gYnkgPT0gXCJwYWdlXCIgPyAwIDogbGVuZ3RoIC0gMTtcclxuICAgICAgICBlbHNlIGlmIChzZWxlY3RlZCA+PSBsZW5ndGgpXHJcbiAgICAgICAgICAgIHNlbGVjdGVkID0gYnkgPT0gXCJwYWdlXCIgPyBsZW5ndGggLSAxIDogMDtcclxuICAgICAgICB2aWV3LmRpc3BhdGNoKHsgZWZmZWN0czogc2V0U2VsZWN0ZWRFZmZlY3Qub2Yoc2VsZWN0ZWQpIH0pO1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfTtcclxufVxyXG4vKipcclxuQWNjZXB0IHRoZSBjdXJyZW50IGNvbXBsZXRpb24uXHJcbiovXHJcbmNvbnN0IGFjY2VwdENvbXBsZXRpb24gPSAodmlldykgPT4ge1xyXG4gICAgbGV0IGNTdGF0ZSA9IHZpZXcuc3RhdGUuZmllbGQoY29tcGxldGlvblN0YXRlLCBmYWxzZSk7XHJcbiAgICBpZiAodmlldy5zdGF0ZS5yZWFkT25seSB8fCAhY1N0YXRlIHx8ICFjU3RhdGUub3BlbiB8fCBjU3RhdGUub3Blbi5zZWxlY3RlZCA8IDAgfHxcclxuICAgICAgICBEYXRlLm5vdygpIC0gY1N0YXRlLm9wZW4udGltZXN0YW1wIDwgdmlldy5zdGF0ZS5mYWNldChjb21wbGV0aW9uQ29uZmlnKS5pbnRlcmFjdGlvbkRlbGF5KVxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIGlmICghY1N0YXRlLm9wZW4uZGlzYWJsZWQpXHJcbiAgICAgICAgYXBwbHlDb21wbGV0aW9uKHZpZXcsIGNTdGF0ZS5vcGVuLm9wdGlvbnNbY1N0YXRlLm9wZW4uc2VsZWN0ZWRdKTtcclxuICAgIHJldHVybiB0cnVlO1xyXG59O1xyXG4vKipcclxuRXhwbGljaXRseSBzdGFydCBhdXRvY29tcGxldGlvbi5cclxuKi9cclxuY29uc3Qgc3RhcnRDb21wbGV0aW9uID0gKHZpZXcpID0+IHtcclxuICAgIGxldCBjU3RhdGUgPSB2aWV3LnN0YXRlLmZpZWxkKGNvbXBsZXRpb25TdGF0ZSwgZmFsc2UpO1xyXG4gICAgaWYgKCFjU3RhdGUpXHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgdmlldy5kaXNwYXRjaCh7IGVmZmVjdHM6IHN0YXJ0Q29tcGxldGlvbkVmZmVjdC5vZih0cnVlKSB9KTtcclxuICAgIHJldHVybiB0cnVlO1xyXG59O1xyXG4vKipcclxuQ2xvc2UgdGhlIGN1cnJlbnRseSBhY3RpdmUgY29tcGxldGlvbi5cclxuKi9cclxuY29uc3QgY2xvc2VDb21wbGV0aW9uID0gKHZpZXcpID0+IHtcclxuICAgIGxldCBjU3RhdGUgPSB2aWV3LnN0YXRlLmZpZWxkKGNvbXBsZXRpb25TdGF0ZSwgZmFsc2UpO1xyXG4gICAgaWYgKCFjU3RhdGUgfHwgIWNTdGF0ZS5hY3RpdmUuc29tZShhID0+IGEuc3RhdGUgIT0gMCAvKiBTdGF0ZS5JbmFjdGl2ZSAqLykpXHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgdmlldy5kaXNwYXRjaCh7IGVmZmVjdHM6IGNsb3NlQ29tcGxldGlvbkVmZmVjdC5vZihudWxsKSB9KTtcclxuICAgIHJldHVybiB0cnVlO1xyXG59O1xyXG5jbGFzcyBSdW5uaW5nUXVlcnkge1xyXG4gICAgY29uc3RydWN0b3IoYWN0aXZlLCBjb250ZXh0KSB7XHJcbiAgICAgICAgdGhpcy5hY3RpdmUgPSBhY3RpdmU7XHJcbiAgICAgICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcclxuICAgICAgICB0aGlzLnRpbWUgPSBEYXRlLm5vdygpO1xyXG4gICAgICAgIHRoaXMudXBkYXRlcyA9IFtdO1xyXG4gICAgICAgIC8vIE5vdGUgdGhhdCAndW5kZWZpbmVkJyBtZWFucyAnbm90IGRvbmUgeWV0Jywgd2hlcmVhcyAnbnVsbCcgbWVhbnNcclxuICAgICAgICAvLyAncXVlcnkgcmV0dXJuZWQgbnVsbCcuXHJcbiAgICAgICAgdGhpcy5kb25lID0gdW5kZWZpbmVkO1xyXG4gICAgfVxyXG59XHJcbmNvbnN0IERlYm91bmNlVGltZSA9IDUwLCBNYXhVcGRhdGVDb3VudCA9IDUwLCBNaW5BYm9ydFRpbWUgPSAxMDAwO1xyXG5jb25zdCBjb21wbGV0aW9uUGx1Z2luID0gLypAX19QVVJFX18qL1ZpZXdQbHVnaW4uZnJvbUNsYXNzKGNsYXNzIHtcclxuICAgIGNvbnN0cnVjdG9yKHZpZXcpIHtcclxuICAgICAgICB0aGlzLnZpZXcgPSB2aWV3O1xyXG4gICAgICAgIHRoaXMuZGVib3VuY2VVcGRhdGUgPSAtMTtcclxuICAgICAgICB0aGlzLnJ1bm5pbmcgPSBbXTtcclxuICAgICAgICB0aGlzLmRlYm91bmNlQWNjZXB0ID0gLTE7XHJcbiAgICAgICAgdGhpcy5jb21wb3NpbmcgPSAwIC8qIENvbXBvc2l0aW9uU3RhdGUuTm9uZSAqLztcclxuICAgICAgICBmb3IgKGxldCBhY3RpdmUgb2Ygdmlldy5zdGF0ZS5maWVsZChjb21wbGV0aW9uU3RhdGUpLmFjdGl2ZSlcclxuICAgICAgICAgICAgaWYgKGFjdGl2ZS5zdGF0ZSA9PSAxIC8qIFN0YXRlLlBlbmRpbmcgKi8pXHJcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXJ0UXVlcnkoYWN0aXZlKTtcclxuICAgIH1cclxuICAgIHVwZGF0ZSh1cGRhdGUpIHtcclxuICAgICAgICBsZXQgY1N0YXRlID0gdXBkYXRlLnN0YXRlLmZpZWxkKGNvbXBsZXRpb25TdGF0ZSk7XHJcbiAgICAgICAgaWYgKCF1cGRhdGUuc2VsZWN0aW9uU2V0ICYmICF1cGRhdGUuZG9jQ2hhbmdlZCAmJiB1cGRhdGUuc3RhcnRTdGF0ZS5maWVsZChjb21wbGV0aW9uU3RhdGUpID09IGNTdGF0ZSlcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIGxldCBkb2VzUmVzZXQgPSB1cGRhdGUudHJhbnNhY3Rpb25zLnNvbWUodHIgPT4ge1xyXG4gICAgICAgICAgICByZXR1cm4gKHRyLnNlbGVjdGlvbiB8fCB0ci5kb2NDaGFuZ2VkKSAmJiAhZ2V0VXNlckV2ZW50KHRyKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMucnVubmluZy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBsZXQgcXVlcnkgPSB0aGlzLnJ1bm5pbmdbaV07XHJcbiAgICAgICAgICAgIGlmIChkb2VzUmVzZXQgfHxcclxuICAgICAgICAgICAgICAgIHF1ZXJ5LnVwZGF0ZXMubGVuZ3RoICsgdXBkYXRlLnRyYW5zYWN0aW9ucy5sZW5ndGggPiBNYXhVcGRhdGVDb3VudCAmJiBEYXRlLm5vdygpIC0gcXVlcnkudGltZSA+IE1pbkFib3J0VGltZSkge1xyXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaGFuZGxlciBvZiBxdWVyeS5jb250ZXh0LmFib3J0TGlzdGVuZXJzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaGFuZGxlcigpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsb2dFeGNlcHRpb24odGhpcy52aWV3LnN0YXRlLCBlKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBxdWVyeS5jb250ZXh0LmFib3J0TGlzdGVuZXJzID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIHRoaXMucnVubmluZy5zcGxpY2UoaS0tLCAxKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHF1ZXJ5LnVwZGF0ZXMucHVzaCguLi51cGRhdGUudHJhbnNhY3Rpb25zKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5kZWJvdW5jZVVwZGF0ZSA+IC0xKVxyXG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5kZWJvdW5jZVVwZGF0ZSk7XHJcbiAgICAgICAgdGhpcy5kZWJvdW5jZVVwZGF0ZSA9IGNTdGF0ZS5hY3RpdmUuc29tZShhID0+IGEuc3RhdGUgPT0gMSAvKiBTdGF0ZS5QZW5kaW5nICovICYmICF0aGlzLnJ1bm5pbmcuc29tZShxID0+IHEuYWN0aXZlLnNvdXJjZSA9PSBhLnNvdXJjZSkpXHJcbiAgICAgICAgICAgID8gc2V0VGltZW91dCgoKSA9PiB0aGlzLnN0YXJ0VXBkYXRlKCksIERlYm91bmNlVGltZSkgOiAtMTtcclxuICAgICAgICBpZiAodGhpcy5jb21wb3NpbmcgIT0gMCAvKiBDb21wb3NpdGlvblN0YXRlLk5vbmUgKi8pXHJcbiAgICAgICAgICAgIGZvciAobGV0IHRyIG9mIHVwZGF0ZS50cmFuc2FjdGlvbnMpIHtcclxuICAgICAgICAgICAgICAgIGlmIChnZXRVc2VyRXZlbnQodHIpID09IFwiaW5wdXRcIilcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbXBvc2luZyA9IDIgLyogQ29tcG9zaXRpb25TdGF0ZS5DaGFuZ2VkICovO1xyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5jb21wb3NpbmcgPT0gMiAvKiBDb21wb3NpdGlvblN0YXRlLkNoYW5nZWQgKi8gJiYgdHIuc2VsZWN0aW9uKVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29tcG9zaW5nID0gMyAvKiBDb21wb3NpdGlvblN0YXRlLkNoYW5nZWRBbmRNb3ZlZCAqLztcclxuICAgICAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgc3RhcnRVcGRhdGUoKSB7XHJcbiAgICAgICAgdGhpcy5kZWJvdW5jZVVwZGF0ZSA9IC0xO1xyXG4gICAgICAgIGxldCB7IHN0YXRlIH0gPSB0aGlzLnZpZXcsIGNTdGF0ZSA9IHN0YXRlLmZpZWxkKGNvbXBsZXRpb25TdGF0ZSk7XHJcbiAgICAgICAgZm9yIChsZXQgYWN0aXZlIG9mIGNTdGF0ZS5hY3RpdmUpIHtcclxuICAgICAgICAgICAgaWYgKGFjdGl2ZS5zdGF0ZSA9PSAxIC8qIFN0YXRlLlBlbmRpbmcgKi8gJiYgIXRoaXMucnVubmluZy5zb21lKHIgPT4gci5hY3RpdmUuc291cmNlID09IGFjdGl2ZS5zb3VyY2UpKVxyXG4gICAgICAgICAgICAgICAgdGhpcy5zdGFydFF1ZXJ5KGFjdGl2ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgc3RhcnRRdWVyeShhY3RpdmUpIHtcclxuICAgICAgICBsZXQgeyBzdGF0ZSB9ID0gdGhpcy52aWV3LCBwb3MgPSBjdXIoc3RhdGUpO1xyXG4gICAgICAgIGxldCBjb250ZXh0ID0gbmV3IENvbXBsZXRpb25Db250ZXh0KHN0YXRlLCBwb3MsIGFjdGl2ZS5leHBsaWNpdFBvcyA9PSBwb3MpO1xyXG4gICAgICAgIGxldCBwZW5kaW5nID0gbmV3IFJ1bm5pbmdRdWVyeShhY3RpdmUsIGNvbnRleHQpO1xyXG4gICAgICAgIHRoaXMucnVubmluZy5wdXNoKHBlbmRpbmcpO1xyXG4gICAgICAgIFByb21pc2UucmVzb2x2ZShhY3RpdmUuc291cmNlKGNvbnRleHQpKS50aGVuKHJlc3VsdCA9PiB7XHJcbiAgICAgICAgICAgIGlmICghcGVuZGluZy5jb250ZXh0LmFib3J0ZWQpIHtcclxuICAgICAgICAgICAgICAgIHBlbmRpbmcuZG9uZSA9IHJlc3VsdCB8fCBudWxsO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zY2hlZHVsZUFjY2VwdCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSwgZXJyID0+IHtcclxuICAgICAgICAgICAgdGhpcy52aWV3LmRpc3BhdGNoKHsgZWZmZWN0czogY2xvc2VDb21wbGV0aW9uRWZmZWN0Lm9mKG51bGwpIH0pO1xyXG4gICAgICAgICAgICBsb2dFeGNlcHRpb24odGhpcy52aWV3LnN0YXRlLCBlcnIpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgc2NoZWR1bGVBY2NlcHQoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMucnVubmluZy5ldmVyeShxID0+IHEuZG9uZSAhPT0gdW5kZWZpbmVkKSlcclxuICAgICAgICAgICAgdGhpcy5hY2NlcHQoKTtcclxuICAgICAgICBlbHNlIGlmICh0aGlzLmRlYm91bmNlQWNjZXB0IDwgMClcclxuICAgICAgICAgICAgdGhpcy5kZWJvdW5jZUFjY2VwdCA9IHNldFRpbWVvdXQoKCkgPT4gdGhpcy5hY2NlcHQoKSwgRGVib3VuY2VUaW1lKTtcclxuICAgIH1cclxuICAgIC8vIEZvciBlYWNoIGZpbmlzaGVkIHF1ZXJ5IGluIHRoaXMucnVubmluZywgdHJ5IHRvIGNyZWF0ZSBhIHJlc3VsdFxyXG4gICAgLy8gb3IsIGlmIGFwcHJvcHJpYXRlLCByZXN0YXJ0IHRoZSBxdWVyeS5cclxuICAgIGFjY2VwdCgpIHtcclxuICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgaWYgKHRoaXMuZGVib3VuY2VBY2NlcHQgPiAtMSlcclxuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuZGVib3VuY2VBY2NlcHQpO1xyXG4gICAgICAgIHRoaXMuZGVib3VuY2VBY2NlcHQgPSAtMTtcclxuICAgICAgICBsZXQgdXBkYXRlZCA9IFtdO1xyXG4gICAgICAgIGxldCBjb25mID0gdGhpcy52aWV3LnN0YXRlLmZhY2V0KGNvbXBsZXRpb25Db25maWcpO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5ydW5uaW5nLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGxldCBxdWVyeSA9IHRoaXMucnVubmluZ1tpXTtcclxuICAgICAgICAgICAgaWYgKHF1ZXJ5LmRvbmUgPT09IHVuZGVmaW5lZClcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB0aGlzLnJ1bm5pbmcuc3BsaWNlKGktLSwgMSk7XHJcbiAgICAgICAgICAgIGlmIChxdWVyeS5kb25lKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgYWN0aXZlID0gbmV3IEFjdGl2ZVJlc3VsdChxdWVyeS5hY3RpdmUuc291cmNlLCBxdWVyeS5hY3RpdmUuZXhwbGljaXRQb3MsIHF1ZXJ5LmRvbmUsIHF1ZXJ5LmRvbmUuZnJvbSwgKF9hID0gcXVlcnkuZG9uZS50bykgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogY3VyKHF1ZXJ5LnVwZGF0ZXMubGVuZ3RoID8gcXVlcnkudXBkYXRlc1swXS5zdGFydFN0YXRlIDogdGhpcy52aWV3LnN0YXRlKSk7XHJcbiAgICAgICAgICAgICAgICAvLyBSZXBsYXkgdGhlIHRyYW5zYWN0aW9ucyB0aGF0IGhhcHBlbmVkIHNpbmNlIHRoZSBzdGFydCBvZlxyXG4gICAgICAgICAgICAgICAgLy8gdGhlIHJlcXVlc3QgYW5kIHNlZSBpZiB0aGF0IHByZXNlcnZlcyB0aGUgcmVzdWx0XHJcbiAgICAgICAgICAgICAgICBmb3IgKGxldCB0ciBvZiBxdWVyeS51cGRhdGVzKVxyXG4gICAgICAgICAgICAgICAgICAgIGFjdGl2ZSA9IGFjdGl2ZS51cGRhdGUodHIsIGNvbmYpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGFjdGl2ZS5oYXNSZXN1bHQoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZWQucHVzaChhY3RpdmUpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGxldCBjdXJyZW50ID0gdGhpcy52aWV3LnN0YXRlLmZpZWxkKGNvbXBsZXRpb25TdGF0ZSkuYWN0aXZlLmZpbmQoYSA9PiBhLnNvdXJjZSA9PSBxdWVyeS5hY3RpdmUuc291cmNlKTtcclxuICAgICAgICAgICAgaWYgKGN1cnJlbnQgJiYgY3VycmVudC5zdGF0ZSA9PSAxIC8qIFN0YXRlLlBlbmRpbmcgKi8pIHtcclxuICAgICAgICAgICAgICAgIGlmIChxdWVyeS5kb25lID09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBFeHBsaWNpdGx5IGZhaWxlZC4gU2hvdWxkIGNsZWFyIHRoZSBwZW5kaW5nIHN0YXR1cyBpZiBpdFxyXG4gICAgICAgICAgICAgICAgICAgIC8vIGhhc24ndCBiZWVuIHJlLXNldCBpbiB0aGUgbWVhbnRpbWUuXHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IGFjdGl2ZSA9IG5ldyBBY3RpdmVTb3VyY2UocXVlcnkuYWN0aXZlLnNvdXJjZSwgMCAvKiBTdGF0ZS5JbmFjdGl2ZSAqLyk7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgdHIgb2YgcXVlcnkudXBkYXRlcylcclxuICAgICAgICAgICAgICAgICAgICAgICAgYWN0aXZlID0gYWN0aXZlLnVwZGF0ZSh0ciwgY29uZik7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFjdGl2ZS5zdGF0ZSAhPSAxIC8qIFN0YXRlLlBlbmRpbmcgKi8pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHVwZGF0ZWQucHVzaChhY3RpdmUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gQ2xlYXJlZCBieSBzdWJzZXF1ZW50IHRyYW5zYWN0aW9ucy4gUmVzdGFydC5cclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXJ0UXVlcnkoY3VycmVudCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHVwZGF0ZWQubGVuZ3RoKVxyXG4gICAgICAgICAgICB0aGlzLnZpZXcuZGlzcGF0Y2goeyBlZmZlY3RzOiBzZXRBY3RpdmVFZmZlY3Qub2YodXBkYXRlZCkgfSk7XHJcbiAgICB9XHJcbn0sIHtcclxuICAgIGV2ZW50SGFuZGxlcnM6IHtcclxuICAgICAgICBibHVyKCkge1xyXG4gICAgICAgICAgICBsZXQgc3RhdGUgPSB0aGlzLnZpZXcuc3RhdGUuZmllbGQoY29tcGxldGlvblN0YXRlLCBmYWxzZSk7XHJcbiAgICAgICAgICAgIGlmIChzdGF0ZSAmJiBzdGF0ZS50b29sdGlwICYmIHRoaXMudmlldy5zdGF0ZS5mYWNldChjb21wbGV0aW9uQ29uZmlnKS5jbG9zZU9uQmx1cilcclxuICAgICAgICAgICAgICAgIHRoaXMudmlldy5kaXNwYXRjaCh7IGVmZmVjdHM6IGNsb3NlQ29tcGxldGlvbkVmZmVjdC5vZihudWxsKSB9KTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGNvbXBvc2l0aW9uc3RhcnQoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY29tcG9zaW5nID0gMSAvKiBDb21wb3NpdGlvblN0YXRlLlN0YXJ0ZWQgKi87XHJcbiAgICAgICAgfSxcclxuICAgICAgICBjb21wb3NpdGlvbmVuZCgpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuY29tcG9zaW5nID09IDMgLyogQ29tcG9zaXRpb25TdGF0ZS5DaGFuZ2VkQW5kTW92ZWQgKi8pIHtcclxuICAgICAgICAgICAgICAgIC8vIFNhZmFyaSBmaXJlcyBjb21wb3NpdGlvbmVuZCBldmVudHMgc3luY2hyb25vdXNseSwgcG9zc2libHlcclxuICAgICAgICAgICAgICAgIC8vIGZyb20gaW5zaWRlIGFuIHVwZGF0ZSwgc28gZGlzcGF0Y2ggYXN5bmNocm9ub3VzbHkgdG8gYXZvaWQgcmVlbnRyYW5jeVxyXG4gICAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB0aGlzLnZpZXcuZGlzcGF0Y2goeyBlZmZlY3RzOiBzdGFydENvbXBsZXRpb25FZmZlY3Qub2YoZmFsc2UpIH0pLCAyMCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5jb21wb3NpbmcgPSAwIC8qIENvbXBvc2l0aW9uU3RhdGUuTm9uZSAqLztcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn0pO1xyXG5cclxuY29uc3QgYmFzZVRoZW1lID0gLypAX19QVVJFX18qL0VkaXRvclZpZXcuYmFzZVRoZW1lKHtcclxuICAgIFwiLmNtLXRvb2x0aXAuY20tdG9vbHRpcC1hdXRvY29tcGxldGVcIjoge1xyXG4gICAgICAgIFwiJiA+IHVsXCI6IHtcclxuICAgICAgICAgICAgZm9udEZhbWlseTogXCJtb25vc3BhY2VcIixcclxuICAgICAgICAgICAgd2hpdGVTcGFjZTogXCJub3dyYXBcIixcclxuICAgICAgICAgICAgb3ZlcmZsb3c6IFwiaGlkZGVuIGF1dG9cIixcclxuICAgICAgICAgICAgbWF4V2lkdGhfZmFsbGJhY2s6IFwiNzAwcHhcIixcclxuICAgICAgICAgICAgbWF4V2lkdGg6IFwibWluKDcwMHB4LCA5NXZ3KVwiLFxyXG4gICAgICAgICAgICBtaW5XaWR0aDogXCIyNTBweFwiLFxyXG4gICAgICAgICAgICBtYXhIZWlnaHQ6IFwiMTBlbVwiLFxyXG4gICAgICAgICAgICBoZWlnaHQ6IFwiMTAwJVwiLFxyXG4gICAgICAgICAgICBsaXN0U3R5bGU6IFwibm9uZVwiLFxyXG4gICAgICAgICAgICBtYXJnaW46IDAsXHJcbiAgICAgICAgICAgIHBhZGRpbmc6IDAsXHJcbiAgICAgICAgICAgIFwiJiA+IGxpXCI6IHtcclxuICAgICAgICAgICAgICAgIG92ZXJmbG93WDogXCJoaWRkZW5cIixcclxuICAgICAgICAgICAgICAgIHRleHRPdmVyZmxvdzogXCJlbGxpcHNpc1wiLFxyXG4gICAgICAgICAgICAgICAgY3Vyc29yOiBcInBvaW50ZXJcIixcclxuICAgICAgICAgICAgICAgIHBhZGRpbmc6IFwiMXB4IDNweFwiLFxyXG4gICAgICAgICAgICAgICAgbGluZUhlaWdodDogMS4yXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIFwiJmxpZ2h0IC5jbS10b29sdGlwLWF1dG9jb21wbGV0ZSB1bCBsaVthcmlhLXNlbGVjdGVkXVwiOiB7XHJcbiAgICAgICAgYmFja2dyb3VuZDogXCIjMTdjXCIsXHJcbiAgICAgICAgY29sb3I6IFwid2hpdGVcIixcclxuICAgIH0sXHJcbiAgICBcIiZsaWdodCAuY20tdG9vbHRpcC1hdXRvY29tcGxldGUtZGlzYWJsZWQgdWwgbGlbYXJpYS1zZWxlY3RlZF1cIjoge1xyXG4gICAgICAgIGJhY2tncm91bmQ6IFwiIzc3N1wiLFxyXG4gICAgfSxcclxuICAgIFwiJmRhcmsgLmNtLXRvb2x0aXAtYXV0b2NvbXBsZXRlIHVsIGxpW2FyaWEtc2VsZWN0ZWRdXCI6IHtcclxuICAgICAgICBiYWNrZ3JvdW5kOiBcIiMzNDdcIixcclxuICAgICAgICBjb2xvcjogXCJ3aGl0ZVwiLFxyXG4gICAgfSxcclxuICAgIFwiJmRhcmsgLmNtLXRvb2x0aXAtYXV0b2NvbXBsZXRlLWRpc2FibGVkIHVsIGxpW2FyaWEtc2VsZWN0ZWRdXCI6IHtcclxuICAgICAgICBiYWNrZ3JvdW5kOiBcIiM0NDRcIixcclxuICAgIH0sXHJcbiAgICBcIi5jbS1jb21wbGV0aW9uTGlzdEluY29tcGxldGVUb3A6YmVmb3JlLCAuY20tY29tcGxldGlvbkxpc3RJbmNvbXBsZXRlQm90dG9tOmFmdGVyXCI6IHtcclxuICAgICAgICBjb250ZW50OiAnXCLCt8K3wrdcIicsXHJcbiAgICAgICAgb3BhY2l0eTogMC41LFxyXG4gICAgICAgIGRpc3BsYXk6IFwiYmxvY2tcIixcclxuICAgICAgICB0ZXh0QWxpZ246IFwiY2VudGVyXCJcclxuICAgIH0sXHJcbiAgICBcIi5jbS10b29sdGlwLmNtLWNvbXBsZXRpb25JbmZvXCI6IHtcclxuICAgICAgICBwb3NpdGlvbjogXCJhYnNvbHV0ZVwiLFxyXG4gICAgICAgIHBhZGRpbmc6IFwiM3B4IDlweFwiLFxyXG4gICAgICAgIHdpZHRoOiBcIm1heC1jb250ZW50XCIsXHJcbiAgICAgICAgbWF4V2lkdGg6IGAkezQwMCAvKiBJbmZvLldpZHRoICovfXB4YCxcclxuICAgICAgICBib3hTaXppbmc6IFwiYm9yZGVyLWJveFwiXHJcbiAgICB9LFxyXG4gICAgXCIuY20tY29tcGxldGlvbkluZm8uY20tY29tcGxldGlvbkluZm8tbGVmdFwiOiB7IHJpZ2h0OiBcIjEwMCVcIiB9LFxyXG4gICAgXCIuY20tY29tcGxldGlvbkluZm8uY20tY29tcGxldGlvbkluZm8tcmlnaHRcIjogeyBsZWZ0OiBcIjEwMCVcIiB9LFxyXG4gICAgXCIuY20tY29tcGxldGlvbkluZm8uY20tY29tcGxldGlvbkluZm8tbGVmdC1uYXJyb3dcIjogeyByaWdodDogYCR7MzAgLyogSW5mby5NYXJnaW4gKi99cHhgIH0sXHJcbiAgICBcIi5jbS1jb21wbGV0aW9uSW5mby5jbS1jb21wbGV0aW9uSW5mby1yaWdodC1uYXJyb3dcIjogeyBsZWZ0OiBgJHszMCAvKiBJbmZvLk1hcmdpbiAqL31weGAgfSxcclxuICAgIFwiJmxpZ2h0IC5jbS1zbmlwcGV0RmllbGRcIjogeyBiYWNrZ3JvdW5kQ29sb3I6IFwiIzAwMDAwMDIyXCIgfSxcclxuICAgIFwiJmRhcmsgLmNtLXNuaXBwZXRGaWVsZFwiOiB7IGJhY2tncm91bmRDb2xvcjogXCIjZmZmZmZmMjJcIiB9LFxyXG4gICAgXCIuY20tc25pcHBldEZpZWxkUG9zaXRpb25cIjoge1xyXG4gICAgICAgIHZlcnRpY2FsQWxpZ246IFwidGV4dC10b3BcIixcclxuICAgICAgICB3aWR0aDogMCxcclxuICAgICAgICBoZWlnaHQ6IFwiMS4xNWVtXCIsXHJcbiAgICAgICAgZGlzcGxheTogXCJpbmxpbmUtYmxvY2tcIixcclxuICAgICAgICBtYXJnaW46IFwiMCAtMC43cHggLS43ZW1cIixcclxuICAgICAgICBib3JkZXJMZWZ0OiBcIjEuNHB4IGRvdHRlZCAjODg4XCJcclxuICAgIH0sXHJcbiAgICBcIi5jbS1jb21wbGV0aW9uTWF0Y2hlZFRleHRcIjoge1xyXG4gICAgICAgIHRleHREZWNvcmF0aW9uOiBcInVuZGVybGluZVwiXHJcbiAgICB9LFxyXG4gICAgXCIuY20tY29tcGxldGlvbkRldGFpbFwiOiB7XHJcbiAgICAgICAgbWFyZ2luTGVmdDogXCIwLjVlbVwiLFxyXG4gICAgICAgIGZvbnRTdHlsZTogXCJpdGFsaWNcIlxyXG4gICAgfSxcclxuICAgIFwiLmNtLWNvbXBsZXRpb25JY29uXCI6IHtcclxuICAgICAgICBmb250U2l6ZTogXCI5MCVcIixcclxuICAgICAgICB3aWR0aDogXCIuOGVtXCIsXHJcbiAgICAgICAgZGlzcGxheTogXCJpbmxpbmUtYmxvY2tcIixcclxuICAgICAgICB0ZXh0QWxpZ246IFwiY2VudGVyXCIsXHJcbiAgICAgICAgcGFkZGluZ1JpZ2h0OiBcIi42ZW1cIixcclxuICAgICAgICBvcGFjaXR5OiBcIjAuNlwiLFxyXG4gICAgICAgIGJveFNpemluZzogXCJjb250ZW50LWJveFwiXHJcbiAgICB9LFxyXG4gICAgXCIuY20tY29tcGxldGlvbkljb24tZnVuY3Rpb24sIC5jbS1jb21wbGV0aW9uSWNvbi1tZXRob2RcIjoge1xyXG4gICAgICAgIFwiJjphZnRlclwiOiB7IGNvbnRlbnQ6IFwiJ8aSJ1wiIH1cclxuICAgIH0sXHJcbiAgICBcIi5jbS1jb21wbGV0aW9uSWNvbi1jbGFzc1wiOiB7XHJcbiAgICAgICAgXCImOmFmdGVyXCI6IHsgY29udGVudDogXCIn4peLJ1wiIH1cclxuICAgIH0sXHJcbiAgICBcIi5jbS1jb21wbGV0aW9uSWNvbi1pbnRlcmZhY2VcIjoge1xyXG4gICAgICAgIFwiJjphZnRlclwiOiB7IGNvbnRlbnQ6IFwiJ+KXjCdcIiB9XHJcbiAgICB9LFxyXG4gICAgXCIuY20tY29tcGxldGlvbkljb24tdmFyaWFibGVcIjoge1xyXG4gICAgICAgIFwiJjphZnRlclwiOiB7IGNvbnRlbnQ6IFwiJ/CdkaUnXCIgfVxyXG4gICAgfSxcclxuICAgIFwiLmNtLWNvbXBsZXRpb25JY29uLWNvbnN0YW50XCI6IHtcclxuICAgICAgICBcIiY6YWZ0ZXJcIjogeyBjb250ZW50OiBcIifwnZC2J1wiIH1cclxuICAgIH0sXHJcbiAgICBcIi5jbS1jb21wbGV0aW9uSWNvbi10eXBlXCI6IHtcclxuICAgICAgICBcIiY6YWZ0ZXJcIjogeyBjb250ZW50OiBcIifwnZGhJ1wiIH1cclxuICAgIH0sXHJcbiAgICBcIi5jbS1jb21wbGV0aW9uSWNvbi1lbnVtXCI6IHtcclxuICAgICAgICBcIiY6YWZ0ZXJcIjogeyBjb250ZW50OiBcIifiiKonXCIgfVxyXG4gICAgfSxcclxuICAgIFwiLmNtLWNvbXBsZXRpb25JY29uLXByb3BlcnR5XCI6IHtcclxuICAgICAgICBcIiY6YWZ0ZXJcIjogeyBjb250ZW50OiBcIifilqEnXCIgfVxyXG4gICAgfSxcclxuICAgIFwiLmNtLWNvbXBsZXRpb25JY29uLWtleXdvcmRcIjoge1xyXG4gICAgICAgIFwiJjphZnRlclwiOiB7IGNvbnRlbnQ6IFwiJ/CflJFcXHVGRTBFJ1wiIH0gLy8gRGlzYWJsZSBlbW9qaSByZW5kZXJpbmdcclxuICAgIH0sXHJcbiAgICBcIi5jbS1jb21wbGV0aW9uSWNvbi1uYW1lc3BhY2VcIjoge1xyXG4gICAgICAgIFwiJjphZnRlclwiOiB7IGNvbnRlbnQ6IFwiJ+KWoidcIiB9XHJcbiAgICB9LFxyXG4gICAgXCIuY20tY29tcGxldGlvbkljb24tdGV4dFwiOiB7XHJcbiAgICAgICAgXCImOmFmdGVyXCI6IHsgY29udGVudDogXCInYWJjJ1wiLCBmb250U2l6ZTogXCI1MCVcIiwgdmVydGljYWxBbGlnbjogXCJtaWRkbGVcIiB9XHJcbiAgICB9XHJcbn0pO1xyXG5cclxuY2xhc3MgRmllbGRQb3Mge1xyXG4gICAgY29uc3RydWN0b3IoZmllbGQsIGxpbmUsIGZyb20sIHRvKSB7XHJcbiAgICAgICAgdGhpcy5maWVsZCA9IGZpZWxkO1xyXG4gICAgICAgIHRoaXMubGluZSA9IGxpbmU7XHJcbiAgICAgICAgdGhpcy5mcm9tID0gZnJvbTtcclxuICAgICAgICB0aGlzLnRvID0gdG87XHJcbiAgICB9XHJcbn1cclxuY2xhc3MgRmllbGRSYW5nZSB7XHJcbiAgICBjb25zdHJ1Y3RvcihmaWVsZCwgZnJvbSwgdG8pIHtcclxuICAgICAgICB0aGlzLmZpZWxkID0gZmllbGQ7XHJcbiAgICAgICAgdGhpcy5mcm9tID0gZnJvbTtcclxuICAgICAgICB0aGlzLnRvID0gdG87XHJcbiAgICB9XHJcbiAgICBtYXAoY2hhbmdlcykge1xyXG4gICAgICAgIGxldCBmcm9tID0gY2hhbmdlcy5tYXBQb3ModGhpcy5mcm9tLCAtMSwgTWFwTW9kZS5UcmFja0RlbCk7XHJcbiAgICAgICAgbGV0IHRvID0gY2hhbmdlcy5tYXBQb3ModGhpcy50bywgMSwgTWFwTW9kZS5UcmFja0RlbCk7XHJcbiAgICAgICAgcmV0dXJuIGZyb20gPT0gbnVsbCB8fCB0byA9PSBudWxsID8gbnVsbCA6IG5ldyBGaWVsZFJhbmdlKHRoaXMuZmllbGQsIGZyb20sIHRvKTtcclxuICAgIH1cclxufVxyXG5jbGFzcyBTbmlwcGV0IHtcclxuICAgIGNvbnN0cnVjdG9yKGxpbmVzLCBmaWVsZFBvc2l0aW9ucykge1xyXG4gICAgICAgIHRoaXMubGluZXMgPSBsaW5lcztcclxuICAgICAgICB0aGlzLmZpZWxkUG9zaXRpb25zID0gZmllbGRQb3NpdGlvbnM7XHJcbiAgICB9XHJcbiAgICBpbnN0YW50aWF0ZShzdGF0ZSwgcG9zKSB7XHJcbiAgICAgICAgbGV0IHRleHQgPSBbXSwgbGluZVN0YXJ0ID0gW3Bvc107XHJcbiAgICAgICAgbGV0IGxpbmVPYmogPSBzdGF0ZS5kb2MubGluZUF0KHBvcyksIGJhc2VJbmRlbnQgPSAvXlxccyovLmV4ZWMobGluZU9iai50ZXh0KVswXTtcclxuICAgICAgICBmb3IgKGxldCBsaW5lIG9mIHRoaXMubGluZXMpIHtcclxuICAgICAgICAgICAgaWYgKHRleHQubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgaW5kZW50ID0gYmFzZUluZGVudCwgdGFicyA9IC9eXFx0Ki8uZXhlYyhsaW5lKVswXS5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRhYnM7IGkrKylcclxuICAgICAgICAgICAgICAgICAgICBpbmRlbnQgKz0gc3RhdGUuZmFjZXQoaW5kZW50VW5pdCk7XHJcbiAgICAgICAgICAgICAgICBsaW5lU3RhcnQucHVzaChwb3MgKyBpbmRlbnQubGVuZ3RoIC0gdGFicyk7XHJcbiAgICAgICAgICAgICAgICBsaW5lID0gaW5kZW50ICsgbGluZS5zbGljZSh0YWJzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0ZXh0LnB1c2gobGluZSk7XHJcbiAgICAgICAgICAgIHBvcyArPSBsaW5lLmxlbmd0aCArIDE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCByYW5nZXMgPSB0aGlzLmZpZWxkUG9zaXRpb25zLm1hcChwb3MgPT4gbmV3IEZpZWxkUmFuZ2UocG9zLmZpZWxkLCBsaW5lU3RhcnRbcG9zLmxpbmVdICsgcG9zLmZyb20sIGxpbmVTdGFydFtwb3MubGluZV0gKyBwb3MudG8pKTtcclxuICAgICAgICByZXR1cm4geyB0ZXh0LCByYW5nZXMgfTtcclxuICAgIH1cclxuICAgIHN0YXRpYyBwYXJzZSh0ZW1wbGF0ZSkge1xyXG4gICAgICAgIGxldCBmaWVsZHMgPSBbXTtcclxuICAgICAgICBsZXQgbGluZXMgPSBbXSwgcG9zaXRpb25zID0gW10sIG07XHJcbiAgICAgICAgZm9yIChsZXQgbGluZSBvZiB0ZW1wbGF0ZS5zcGxpdCgvXFxyXFxuP3xcXG4vKSkge1xyXG4gICAgICAgICAgICB3aGlsZSAobSA9IC9bIyRdXFx7KD86KFxcZCspKD86OihbXn1dKikpP3woW159XSopKVxcfS8uZXhlYyhsaW5lKSkge1xyXG4gICAgICAgICAgICAgICAgbGV0IHNlcSA9IG1bMV0gPyArbVsxXSA6IG51bGwsIG5hbWUgPSBtWzJdIHx8IG1bM10gfHwgXCJcIiwgZm91bmQgPSAtMTtcclxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZmllbGRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlcSAhPSBudWxsID8gZmllbGRzW2ldLnNlcSA9PSBzZXEgOiBuYW1lID8gZmllbGRzW2ldLm5hbWUgPT0gbmFtZSA6IGZhbHNlKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3VuZCA9IGk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoZm91bmQgPCAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IGkgPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChpIDwgZmllbGRzLmxlbmd0aCAmJiAoc2VxID09IG51bGwgfHwgKGZpZWxkc1tpXS5zZXEgIT0gbnVsbCAmJiBmaWVsZHNbaV0uc2VxIDwgc2VxKSkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGkrKztcclxuICAgICAgICAgICAgICAgICAgICBmaWVsZHMuc3BsaWNlKGksIDAsIHsgc2VxLCBuYW1lIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIGZvdW5kID0gaTtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBwb3Mgb2YgcG9zaXRpb25zKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocG9zLmZpZWxkID49IGZvdW5kKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zLmZpZWxkKys7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBwb3NpdGlvbnMucHVzaChuZXcgRmllbGRQb3MoZm91bmQsIGxpbmVzLmxlbmd0aCwgbS5pbmRleCwgbS5pbmRleCArIG5hbWUubGVuZ3RoKSk7XHJcbiAgICAgICAgICAgICAgICBsaW5lID0gbGluZS5zbGljZSgwLCBtLmluZGV4KSArIG5hbWUgKyBsaW5lLnNsaWNlKG0uaW5kZXggKyBtWzBdLmxlbmd0aCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZm9yIChsZXQgZXNjOyBlc2MgPSAvXFxcXChbe31dKS8uZXhlYyhsaW5lKTspIHtcclxuICAgICAgICAgICAgICAgIGxpbmUgPSBsaW5lLnNsaWNlKDAsIGVzYy5pbmRleCkgKyBlc2NbMV0gKyBsaW5lLnNsaWNlKGVzYy5pbmRleCArIGVzY1swXS5sZW5ndGgpO1xyXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgcG9zIG9mIHBvc2l0aW9ucylcclxuICAgICAgICAgICAgICAgICAgICBpZiAocG9zLmxpbmUgPT0gbGluZXMubGVuZ3RoICYmIHBvcy5mcm9tID4gZXNjLmluZGV4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvcy5mcm9tLS07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvcy50by0tO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBsaW5lcy5wdXNoKGxpbmUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbmV3IFNuaXBwZXQobGluZXMsIHBvc2l0aW9ucyk7XHJcbiAgICB9XHJcbn1cclxubGV0IGZpZWxkTWFya2VyID0gLypAX19QVVJFX18qL0RlY29yYXRpb24ud2lkZ2V0KHsgd2lkZ2V0OiAvKkBfX1BVUkVfXyovbmV3IGNsYXNzIGV4dGVuZHMgV2lkZ2V0VHlwZSB7XHJcbiAgICAgICAgdG9ET00oKSB7XHJcbiAgICAgICAgICAgIGxldCBzcGFuID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNwYW5cIik7XHJcbiAgICAgICAgICAgIHNwYW4uY2xhc3NOYW1lID0gXCJjbS1zbmlwcGV0RmllbGRQb3NpdGlvblwiO1xyXG4gICAgICAgICAgICByZXR1cm4gc3BhbjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWdub3JlRXZlbnQoKSB7IHJldHVybiBmYWxzZTsgfVxyXG4gICAgfSB9KTtcclxubGV0IGZpZWxkUmFuZ2UgPSAvKkBfX1BVUkVfXyovRGVjb3JhdGlvbi5tYXJrKHsgY2xhc3M6IFwiY20tc25pcHBldEZpZWxkXCIgfSk7XHJcbmNsYXNzIEFjdGl2ZVNuaXBwZXQge1xyXG4gICAgY29uc3RydWN0b3IocmFuZ2VzLCBhY3RpdmUpIHtcclxuICAgICAgICB0aGlzLnJhbmdlcyA9IHJhbmdlcztcclxuICAgICAgICB0aGlzLmFjdGl2ZSA9IGFjdGl2ZTtcclxuICAgICAgICB0aGlzLmRlY28gPSBEZWNvcmF0aW9uLnNldChyYW5nZXMubWFwKHIgPT4gKHIuZnJvbSA9PSByLnRvID8gZmllbGRNYXJrZXIgOiBmaWVsZFJhbmdlKS5yYW5nZShyLmZyb20sIHIudG8pKSk7XHJcbiAgICB9XHJcbiAgICBtYXAoY2hhbmdlcykge1xyXG4gICAgICAgIGxldCByYW5nZXMgPSBbXTtcclxuICAgICAgICBmb3IgKGxldCByIG9mIHRoaXMucmFuZ2VzKSB7XHJcbiAgICAgICAgICAgIGxldCBtYXBwZWQgPSByLm1hcChjaGFuZ2VzKTtcclxuICAgICAgICAgICAgaWYgKCFtYXBwZWQpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgcmFuZ2VzLnB1c2gobWFwcGVkKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5ldyBBY3RpdmVTbmlwcGV0KHJhbmdlcywgdGhpcy5hY3RpdmUpO1xyXG4gICAgfVxyXG4gICAgc2VsZWN0aW9uSW5zaWRlRmllbGQoc2VsKSB7XHJcbiAgICAgICAgcmV0dXJuIHNlbC5yYW5nZXMuZXZlcnkocmFuZ2UgPT4gdGhpcy5yYW5nZXMuc29tZShyID0+IHIuZmllbGQgPT0gdGhpcy5hY3RpdmUgJiYgci5mcm9tIDw9IHJhbmdlLmZyb20gJiYgci50byA+PSByYW5nZS50bykpO1xyXG4gICAgfVxyXG59XHJcbmNvbnN0IHNldEFjdGl2ZSA9IC8qQF9fUFVSRV9fKi9TdGF0ZUVmZmVjdC5kZWZpbmUoe1xyXG4gICAgbWFwKHZhbHVlLCBjaGFuZ2VzKSB7IHJldHVybiB2YWx1ZSAmJiB2YWx1ZS5tYXAoY2hhbmdlcyk7IH1cclxufSk7XHJcbmNvbnN0IG1vdmVUb0ZpZWxkID0gLypAX19QVVJFX18qL1N0YXRlRWZmZWN0LmRlZmluZSgpO1xyXG5jb25zdCBzbmlwcGV0U3RhdGUgPSAvKkBfX1BVUkVfXyovU3RhdGVGaWVsZC5kZWZpbmUoe1xyXG4gICAgY3JlYXRlKCkgeyByZXR1cm4gbnVsbDsgfSxcclxuICAgIHVwZGF0ZSh2YWx1ZSwgdHIpIHtcclxuICAgICAgICBmb3IgKGxldCBlZmZlY3Qgb2YgdHIuZWZmZWN0cykge1xyXG4gICAgICAgICAgICBpZiAoZWZmZWN0LmlzKHNldEFjdGl2ZSkpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZWZmZWN0LnZhbHVlO1xyXG4gICAgICAgICAgICBpZiAoZWZmZWN0LmlzKG1vdmVUb0ZpZWxkKSAmJiB2YWx1ZSlcclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQWN0aXZlU25pcHBldCh2YWx1ZS5yYW5nZXMsIGVmZmVjdC52YWx1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh2YWx1ZSAmJiB0ci5kb2NDaGFuZ2VkKVxyXG4gICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLm1hcCh0ci5jaGFuZ2VzKTtcclxuICAgICAgICBpZiAodmFsdWUgJiYgdHIuc2VsZWN0aW9uICYmICF2YWx1ZS5zZWxlY3Rpb25JbnNpZGVGaWVsZCh0ci5zZWxlY3Rpb24pKVxyXG4gICAgICAgICAgICB2YWx1ZSA9IG51bGw7XHJcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgfSxcclxuICAgIHByb3ZpZGU6IGYgPT4gRWRpdG9yVmlldy5kZWNvcmF0aW9ucy5mcm9tKGYsIHZhbCA9PiB2YWwgPyB2YWwuZGVjbyA6IERlY29yYXRpb24ubm9uZSlcclxufSk7XHJcbmZ1bmN0aW9uIGZpZWxkU2VsZWN0aW9uKHJhbmdlcywgZmllbGQpIHtcclxuICAgIHJldHVybiBFZGl0b3JTZWxlY3Rpb24uY3JlYXRlKHJhbmdlcy5maWx0ZXIociA9PiByLmZpZWxkID09IGZpZWxkKS5tYXAociA9PiBFZGl0b3JTZWxlY3Rpb24ucmFuZ2Uoci5mcm9tLCByLnRvKSkpO1xyXG59XHJcbi8qKlxyXG5Db252ZXJ0IGEgc25pcHBldCB0ZW1wbGF0ZSB0byBhIGZ1bmN0aW9uIHRoYXQgY2FuXHJcblthcHBseV0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNhdXRvY29tcGxldGUuQ29tcGxldGlvbi5hcHBseSkgaXQuIFNuaXBwZXRzIGFyZSB3cml0dGVuXHJcbnVzaW5nIHN5bnRheCBsaWtlIHRoaXM6XHJcblxyXG4gICAgXCJmb3IgKGxldCAke2luZGV4fSA9IDA7ICR7aW5kZXh9IDwgJHtlbmR9OyAke2luZGV4fSsrKSB7XFxuXFx0JHt9XFxufVwiXHJcblxyXG5FYWNoIGAke31gIHBsYWNlaG9sZGVyICh5b3UgbWF5IGFsc28gdXNlIGAje31gKSBpbmRpY2F0ZXMgYSBmaWVsZFxyXG50aGF0IHRoZSB1c2VyIGNhbiBmaWxsIGluLiBJdHMgbmFtZSwgaWYgYW55LCB3aWxsIGJlIHRoZSBkZWZhdWx0XHJcbmNvbnRlbnQgZm9yIHRoZSBmaWVsZC5cclxuXHJcbldoZW4gdGhlIHNuaXBwZXQgaXMgYWN0aXZhdGVkIGJ5IGNhbGxpbmcgdGhlIHJldHVybmVkIGZ1bmN0aW9uLFxyXG50aGUgY29kZSBpcyBpbnNlcnRlZCBhdCB0aGUgZ2l2ZW4gcG9zaXRpb24uIE5ld2xpbmVzIGluIHRoZVxyXG50ZW1wbGF0ZSBhcmUgaW5kZW50ZWQgYnkgdGhlIGluZGVudGF0aW9uIG9mIHRoZSBzdGFydCBsaW5lLCBwbHVzXHJcbm9uZSBbaW5kZW50IHVuaXRdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jbGFuZ3VhZ2UuaW5kZW50VW5pdCkgcGVyIHRhYiBjaGFyYWN0ZXIgYWZ0ZXJcclxudGhlIG5ld2xpbmUuXHJcblxyXG5PbiBhY3RpdmF0aW9uLCAoYWxsIGluc3RhbmNlcyBvZikgdGhlIGZpcnN0IGZpZWxkIGFyZSBzZWxlY3RlZC5cclxuVGhlIHVzZXIgY2FuIG1vdmUgYmV0d2VlbiBmaWVsZHMgd2l0aCBUYWIgYW5kIFNoaWZ0LVRhYiBhcyBsb25nIGFzXHJcbnRoZSBmaWVsZHMgYXJlIGFjdGl2ZS4gTW92aW5nIHRvIHRoZSBsYXN0IGZpZWxkIG9yIG1vdmluZyB0aGVcclxuY3Vyc29yIG91dCBvZiB0aGUgY3VycmVudCBmaWVsZCBkZWFjdGl2YXRlcyB0aGUgZmllbGRzLlxyXG5cclxuVGhlIG9yZGVyIG9mIGZpZWxkcyBkZWZhdWx0cyB0byB0ZXh0dWFsIG9yZGVyLCBidXQgeW91IGNhbiBhZGRcclxubnVtYmVycyB0byBwbGFjZWhvbGRlcnMgKGAkezF9YCBvciBgJHsxOmRlZmF1bHRUZXh0fWApIHRvIHByb3ZpZGVcclxuYSBjdXN0b20gb3JkZXIuXHJcblxyXG5UbyBpbmNsdWRlIGEgbGl0ZXJhbCBge2Agb3IgYH1gIGluIHlvdXIgdGVtcGxhdGUsIHB1dCBhIGJhY2tzbGFzaFxyXG5pbiBmcm9udCBvZiBpdC4gVGhpcyB3aWxsIGJlIHJlbW92ZWQgYW5kIHRoZSBicmFjZSB3aWxsIG5vdCBiZVxyXG5pbnRlcnByZXRlZCBhcyBpbmRpY2F0aW5nIGEgcGxhY2Vob2xkZXIuXHJcbiovXHJcbmZ1bmN0aW9uIHNuaXBwZXQodGVtcGxhdGUpIHtcclxuICAgIGxldCBzbmlwcGV0ID0gU25pcHBldC5wYXJzZSh0ZW1wbGF0ZSk7XHJcbiAgICByZXR1cm4gKGVkaXRvciwgX2NvbXBsZXRpb24sIGZyb20sIHRvKSA9PiB7XHJcbiAgICAgICAgbGV0IHsgdGV4dCwgcmFuZ2VzIH0gPSBzbmlwcGV0Lmluc3RhbnRpYXRlKGVkaXRvci5zdGF0ZSwgZnJvbSk7XHJcbiAgICAgICAgbGV0IHNwZWMgPSB7XHJcbiAgICAgICAgICAgIGNoYW5nZXM6IHsgZnJvbSwgdG8sIGluc2VydDogVGV4dC5vZih0ZXh0KSB9LFxyXG4gICAgICAgICAgICBzY3JvbGxJbnRvVmlldzogdHJ1ZVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgaWYgKHJhbmdlcy5sZW5ndGgpXHJcbiAgICAgICAgICAgIHNwZWMuc2VsZWN0aW9uID0gZmllbGRTZWxlY3Rpb24ocmFuZ2VzLCAwKTtcclxuICAgICAgICBpZiAocmFuZ2VzLmxlbmd0aCA+IDEpIHtcclxuICAgICAgICAgICAgbGV0IGFjdGl2ZSA9IG5ldyBBY3RpdmVTbmlwcGV0KHJhbmdlcywgMCk7XHJcbiAgICAgICAgICAgIGxldCBlZmZlY3RzID0gc3BlYy5lZmZlY3RzID0gW3NldEFjdGl2ZS5vZihhY3RpdmUpXTtcclxuICAgICAgICAgICAgaWYgKGVkaXRvci5zdGF0ZS5maWVsZChzbmlwcGV0U3RhdGUsIGZhbHNlKSA9PT0gdW5kZWZpbmVkKVxyXG4gICAgICAgICAgICAgICAgZWZmZWN0cy5wdXNoKFN0YXRlRWZmZWN0LmFwcGVuZENvbmZpZy5vZihbc25pcHBldFN0YXRlLCBhZGRTbmlwcGV0S2V5bWFwLCBzbmlwcGV0UG9pbnRlckhhbmRsZXIsIGJhc2VUaGVtZV0pKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWRpdG9yLmRpc3BhdGNoKGVkaXRvci5zdGF0ZS51cGRhdGUoc3BlYykpO1xyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiBtb3ZlRmllbGQoZGlyKSB7XHJcbiAgICByZXR1cm4gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcclxuICAgICAgICBsZXQgYWN0aXZlID0gc3RhdGUuZmllbGQoc25pcHBldFN0YXRlLCBmYWxzZSk7XHJcbiAgICAgICAgaWYgKCFhY3RpdmUgfHwgZGlyIDwgMCAmJiBhY3RpdmUuYWN0aXZlID09IDApXHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICBsZXQgbmV4dCA9IGFjdGl2ZS5hY3RpdmUgKyBkaXIsIGxhc3QgPSBkaXIgPiAwICYmICFhY3RpdmUucmFuZ2VzLnNvbWUociA9PiByLmZpZWxkID09IG5leHQgKyBkaXIpO1xyXG4gICAgICAgIGRpc3BhdGNoKHN0YXRlLnVwZGF0ZSh7XHJcbiAgICAgICAgICAgIHNlbGVjdGlvbjogZmllbGRTZWxlY3Rpb24oYWN0aXZlLnJhbmdlcywgbmV4dCksXHJcbiAgICAgICAgICAgIGVmZmVjdHM6IHNldEFjdGl2ZS5vZihsYXN0ID8gbnVsbCA6IG5ldyBBY3RpdmVTbmlwcGV0KGFjdGl2ZS5yYW5nZXMsIG5leHQpKVxyXG4gICAgICAgIH0pKTtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH07XHJcbn1cclxuLyoqXHJcbkEgY29tbWFuZCB0aGF0IGNsZWFycyB0aGUgYWN0aXZlIHNuaXBwZXQsIGlmIGFueS5cclxuKi9cclxuY29uc3QgY2xlYXJTbmlwcGV0ID0gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcclxuICAgIGxldCBhY3RpdmUgPSBzdGF0ZS5maWVsZChzbmlwcGV0U3RhdGUsIGZhbHNlKTtcclxuICAgIGlmICghYWN0aXZlKVxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIGRpc3BhdGNoKHN0YXRlLnVwZGF0ZSh7IGVmZmVjdHM6IHNldEFjdGl2ZS5vZihudWxsKSB9KSk7XHJcbiAgICByZXR1cm4gdHJ1ZTtcclxufTtcclxuLyoqXHJcbk1vdmUgdG8gdGhlIG5leHQgc25pcHBldCBmaWVsZCwgaWYgYXZhaWxhYmxlLlxyXG4qL1xyXG5jb25zdCBuZXh0U25pcHBldEZpZWxkID0gLypAX19QVVJFX18qL21vdmVGaWVsZCgxKTtcclxuLyoqXHJcbk1vdmUgdG8gdGhlIHByZXZpb3VzIHNuaXBwZXQgZmllbGQsIGlmIGF2YWlsYWJsZS5cclxuKi9cclxuY29uc3QgcHJldlNuaXBwZXRGaWVsZCA9IC8qQF9fUFVSRV9fKi9tb3ZlRmllbGQoLTEpO1xyXG5jb25zdCBkZWZhdWx0U25pcHBldEtleW1hcCA9IFtcclxuICAgIHsga2V5OiBcIlRhYlwiLCBydW46IG5leHRTbmlwcGV0RmllbGQsIHNoaWZ0OiBwcmV2U25pcHBldEZpZWxkIH0sXHJcbiAgICB7IGtleTogXCJFc2NhcGVcIiwgcnVuOiBjbGVhclNuaXBwZXQgfVxyXG5dO1xyXG4vKipcclxuQSBmYWNldCB0aGF0IGNhbiBiZSB1c2VkIHRvIGNvbmZpZ3VyZSB0aGUga2V5IGJpbmRpbmdzIHVzZWQgYnlcclxuc25pcHBldHMuIFRoZSBkZWZhdWx0IGJpbmRzIFRhYiB0b1xyXG5bYG5leHRTbmlwcGV0RmllbGRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2F1dG9jb21wbGV0ZS5uZXh0U25pcHBldEZpZWxkKSwgU2hpZnQtVGFiIHRvXHJcbltgcHJldlNuaXBwZXRGaWVsZGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jYXV0b2NvbXBsZXRlLnByZXZTbmlwcGV0RmllbGQpLCBhbmQgRXNjYXBlXHJcbnRvIFtgY2xlYXJTbmlwcGV0YF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNhdXRvY29tcGxldGUuY2xlYXJTbmlwcGV0KS5cclxuKi9cclxuY29uc3Qgc25pcHBldEtleW1hcCA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoe1xyXG4gICAgY29tYmluZShtYXBzKSB7IHJldHVybiBtYXBzLmxlbmd0aCA/IG1hcHNbMF0gOiBkZWZhdWx0U25pcHBldEtleW1hcDsgfVxyXG59KTtcclxuY29uc3QgYWRkU25pcHBldEtleW1hcCA9IC8qQF9fUFVSRV9fKi9QcmVjLmhpZ2hlc3QoLypAX19QVVJFX18qL2tleW1hcC5jb21wdXRlKFtzbmlwcGV0S2V5bWFwXSwgc3RhdGUgPT4gc3RhdGUuZmFjZXQoc25pcHBldEtleW1hcCkpKTtcclxuLyoqXHJcbkNyZWF0ZSBhIGNvbXBsZXRpb24gZnJvbSBhIHNuaXBwZXQuIFJldHVybnMgYW4gb2JqZWN0IHdpdGggdGhlXHJcbnByb3BlcnRpZXMgZnJvbSBgY29tcGxldGlvbmAsIHBsdXMgYW4gYGFwcGx5YCBmdW5jdGlvbiB0aGF0XHJcbmFwcGxpZXMgdGhlIHNuaXBwZXQuXHJcbiovXHJcbmZ1bmN0aW9uIHNuaXBwZXRDb21wbGV0aW9uKHRlbXBsYXRlLCBjb21wbGV0aW9uKSB7XHJcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBjb21wbGV0aW9uKSwgeyBhcHBseTogc25pcHBldCh0ZW1wbGF0ZSkgfSk7XHJcbn1cclxuY29uc3Qgc25pcHBldFBvaW50ZXJIYW5kbGVyID0gLypAX19QVVJFX18qL0VkaXRvclZpZXcuZG9tRXZlbnRIYW5kbGVycyh7XHJcbiAgICBtb3VzZWRvd24oZXZlbnQsIHZpZXcpIHtcclxuICAgICAgICBsZXQgYWN0aXZlID0gdmlldy5zdGF0ZS5maWVsZChzbmlwcGV0U3RhdGUsIGZhbHNlKSwgcG9zO1xyXG4gICAgICAgIGlmICghYWN0aXZlIHx8IChwb3MgPSB2aWV3LnBvc0F0Q29vcmRzKHsgeDogZXZlbnQuY2xpZW50WCwgeTogZXZlbnQuY2xpZW50WSB9KSkgPT0gbnVsbClcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIGxldCBtYXRjaCA9IGFjdGl2ZS5yYW5nZXMuZmluZChyID0+IHIuZnJvbSA8PSBwb3MgJiYgci50byA+PSBwb3MpO1xyXG4gICAgICAgIGlmICghbWF0Y2ggfHwgbWF0Y2guZmllbGQgPT0gYWN0aXZlLmFjdGl2ZSlcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIHZpZXcuZGlzcGF0Y2goe1xyXG4gICAgICAgICAgICBzZWxlY3Rpb246IGZpZWxkU2VsZWN0aW9uKGFjdGl2ZS5yYW5nZXMsIG1hdGNoLmZpZWxkKSxcclxuICAgICAgICAgICAgZWZmZWN0czogc2V0QWN0aXZlLm9mKGFjdGl2ZS5yYW5nZXMuc29tZShyID0+IHIuZmllbGQgPiBtYXRjaC5maWVsZCkgPyBuZXcgQWN0aXZlU25pcHBldChhY3RpdmUucmFuZ2VzLCBtYXRjaC5maWVsZCkgOiBudWxsKVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG59KTtcclxuXHJcbmZ1bmN0aW9uIHdvcmRSRSh3b3JkQ2hhcnMpIHtcclxuICAgIGxldCBlc2NhcGVkID0gd29yZENoYXJzLnJlcGxhY2UoL1tcXFxcWy4rKj8oKXt8XiRdL2csIFwiXFxcXCQmXCIpO1xyXG4gICAgdHJ5IHtcclxuICAgICAgICByZXR1cm4gbmV3IFJlZ0V4cChgW1xcXFxwe0FscGhhYmV0aWN9XFxcXHB7TnVtYmVyfV8ke2VzY2FwZWR9XStgLCBcInVnXCIpO1xyXG4gICAgfVxyXG4gICAgY2F0Y2ggKF9hKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBSZWdFeHAoYFtcXHcke2VzY2FwZWR9XWAsIFwiZ1wiKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBtYXBSRShyZSwgZikge1xyXG4gICAgcmV0dXJuIG5ldyBSZWdFeHAoZihyZS5zb3VyY2UpLCByZS51bmljb2RlID8gXCJ1XCIgOiBcIlwiKTtcclxufVxyXG5jb25zdCB3b3JkQ2FjaGVzID0gLypAX19QVVJFX18qL09iamVjdC5jcmVhdGUobnVsbCk7XHJcbmZ1bmN0aW9uIHdvcmRDYWNoZSh3b3JkQ2hhcnMpIHtcclxuICAgIHJldHVybiB3b3JkQ2FjaGVzW3dvcmRDaGFyc10gfHwgKHdvcmRDYWNoZXNbd29yZENoYXJzXSA9IG5ldyBXZWFrTWFwKTtcclxufVxyXG5mdW5jdGlvbiBzdG9yZVdvcmRzKGRvYywgd29yZFJFLCByZXN1bHQsIHNlZW4sIGlnbm9yZUF0KSB7XHJcbiAgICBmb3IgKGxldCBsaW5lcyA9IGRvYy5pdGVyTGluZXMoKSwgcG9zID0gMDsgIWxpbmVzLm5leHQoKS5kb25lOykge1xyXG4gICAgICAgIGxldCB7IHZhbHVlIH0gPSBsaW5lcywgbTtcclxuICAgICAgICB3b3JkUkUubGFzdEluZGV4ID0gMDtcclxuICAgICAgICB3aGlsZSAobSA9IHdvcmRSRS5leGVjKHZhbHVlKSkge1xyXG4gICAgICAgICAgICBpZiAoIXNlZW5bbVswXV0gJiYgcG9zICsgbS5pbmRleCAhPSBpZ25vcmVBdCkge1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goeyB0eXBlOiBcInRleHRcIiwgbGFiZWw6IG1bMF0gfSk7XHJcbiAgICAgICAgICAgICAgICBzZWVuW21bMF1dID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQubGVuZ3RoID49IDIwMDAgLyogQy5NYXhMaXN0ICovKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBwb3MgKz0gdmFsdWUubGVuZ3RoICsgMTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBjb2xsZWN0V29yZHMoZG9jLCBjYWNoZSwgd29yZFJFLCB0bywgaWdub3JlQXQpIHtcclxuICAgIGxldCBiaWcgPSBkb2MubGVuZ3RoID49IDEwMDAgLyogQy5NaW5DYWNoZUxlbiAqLztcclxuICAgIGxldCBjYWNoZWQgPSBiaWcgJiYgY2FjaGUuZ2V0KGRvYyk7XHJcbiAgICBpZiAoY2FjaGVkKVxyXG4gICAgICAgIHJldHVybiBjYWNoZWQ7XHJcbiAgICBsZXQgcmVzdWx0ID0gW10sIHNlZW4gPSBPYmplY3QuY3JlYXRlKG51bGwpO1xyXG4gICAgaWYgKGRvYy5jaGlsZHJlbikge1xyXG4gICAgICAgIGxldCBwb3MgPSAwO1xyXG4gICAgICAgIGZvciAobGV0IGNoIG9mIGRvYy5jaGlsZHJlbikge1xyXG4gICAgICAgICAgICBpZiAoY2gubGVuZ3RoID49IDEwMDAgLyogQy5NaW5DYWNoZUxlbiAqLykge1xyXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgYyBvZiBjb2xsZWN0V29yZHMoY2gsIGNhY2hlLCB3b3JkUkUsIHRvIC0gcG9zLCBpZ25vcmVBdCAtIHBvcykpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIXNlZW5bYy5sYWJlbF0pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2VlbltjLmxhYmVsXSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGMpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHN0b3JlV29yZHMoY2gsIHdvcmRSRSwgcmVzdWx0LCBzZWVuLCBpZ25vcmVBdCAtIHBvcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcG9zICs9IGNoLmxlbmd0aCArIDE7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgc3RvcmVXb3Jkcyhkb2MsIHdvcmRSRSwgcmVzdWx0LCBzZWVuLCBpZ25vcmVBdCk7XHJcbiAgICB9XHJcbiAgICBpZiAoYmlnICYmIHJlc3VsdC5sZW5ndGggPCAyMDAwIC8qIEMuTWF4TGlzdCAqLylcclxuICAgICAgICBjYWNoZS5zZXQoZG9jLCByZXN1bHQpO1xyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufVxyXG4vKipcclxuQSBjb21wbGV0aW9uIHNvdXJjZSB0aGF0IHdpbGwgc2NhbiB0aGUgZG9jdW1lbnQgZm9yIHdvcmRzICh1c2luZyBhXHJcbltjaGFyYWN0ZXIgY2F0ZWdvcml6ZXJdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuRWRpdG9yU3RhdGUuY2hhckNhdGVnb3JpemVyKSksIGFuZFxyXG5yZXR1cm4gdGhvc2UgYXMgY29tcGxldGlvbnMuXHJcbiovXHJcbmNvbnN0IGNvbXBsZXRlQW55V29yZCA9IGNvbnRleHQgPT4ge1xyXG4gICAgbGV0IHdvcmRDaGFycyA9IGNvbnRleHQuc3RhdGUubGFuZ3VhZ2VEYXRhQXQoXCJ3b3JkQ2hhcnNcIiwgY29udGV4dC5wb3MpLmpvaW4oXCJcIik7XHJcbiAgICBsZXQgcmUgPSB3b3JkUkUod29yZENoYXJzKTtcclxuICAgIGxldCB0b2tlbiA9IGNvbnRleHQubWF0Y2hCZWZvcmUobWFwUkUocmUsIHMgPT4gcyArIFwiJFwiKSk7XHJcbiAgICBpZiAoIXRva2VuICYmICFjb250ZXh0LmV4cGxpY2l0KVxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgbGV0IGZyb20gPSB0b2tlbiA/IHRva2VuLmZyb20gOiBjb250ZXh0LnBvcztcclxuICAgIGxldCBvcHRpb25zID0gY29sbGVjdFdvcmRzKGNvbnRleHQuc3RhdGUuZG9jLCB3b3JkQ2FjaGUod29yZENoYXJzKSwgcmUsIDUwMDAwIC8qIEMuUmFuZ2UgKi8sIGZyb20pO1xyXG4gICAgcmV0dXJuIHsgZnJvbSwgb3B0aW9ucywgdmFsaWRGb3I6IG1hcFJFKHJlLCBzID0+IFwiXlwiICsgcykgfTtcclxufTtcclxuXHJcbmNvbnN0IGRlZmF1bHRzID0ge1xyXG4gICAgYnJhY2tldHM6IFtcIihcIiwgXCJbXCIsIFwie1wiLCBcIidcIiwgJ1wiJ10sXHJcbiAgICBiZWZvcmU6IFwiKV19Ojs+XCIsXHJcbiAgICBzdHJpbmdQcmVmaXhlczogW11cclxufTtcclxuY29uc3QgY2xvc2VCcmFja2V0RWZmZWN0ID0gLypAX19QVVJFX18qL1N0YXRlRWZmZWN0LmRlZmluZSh7XHJcbiAgICBtYXAodmFsdWUsIG1hcHBpbmcpIHtcclxuICAgICAgICBsZXQgbWFwcGVkID0gbWFwcGluZy5tYXBQb3ModmFsdWUsIC0xLCBNYXBNb2RlLlRyYWNrQWZ0ZXIpO1xyXG4gICAgICAgIHJldHVybiBtYXBwZWQgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IG1hcHBlZDtcclxuICAgIH1cclxufSk7XHJcbmNvbnN0IHNraXBCcmFja2V0RWZmZWN0ID0gLypAX19QVVJFX18qL1N0YXRlRWZmZWN0LmRlZmluZSh7XHJcbiAgICBtYXAodmFsdWUsIG1hcHBpbmcpIHsgcmV0dXJuIG1hcHBpbmcubWFwUG9zKHZhbHVlKTsgfVxyXG59KTtcclxuY29uc3QgY2xvc2VkQnJhY2tldCA9IC8qQF9fUFVSRV9fKi9uZXcgY2xhc3MgZXh0ZW5kcyBSYW5nZVZhbHVlIHtcclxufTtcclxuY2xvc2VkQnJhY2tldC5zdGFydFNpZGUgPSAxO1xyXG5jbG9zZWRCcmFja2V0LmVuZFNpZGUgPSAtMTtcclxuY29uc3QgYnJhY2tldFN0YXRlID0gLypAX19QVVJFX18qL1N0YXRlRmllbGQuZGVmaW5lKHtcclxuICAgIGNyZWF0ZSgpIHsgcmV0dXJuIFJhbmdlU2V0LmVtcHR5OyB9LFxyXG4gICAgdXBkYXRlKHZhbHVlLCB0cikge1xyXG4gICAgICAgIGlmICh0ci5zZWxlY3Rpb24pIHtcclxuICAgICAgICAgICAgbGV0IGxpbmVTdGFydCA9IHRyLnN0YXRlLmRvYy5saW5lQXQodHIuc2VsZWN0aW9uLm1haW4uaGVhZCkuZnJvbTtcclxuICAgICAgICAgICAgbGV0IHByZXZMaW5lU3RhcnQgPSB0ci5zdGFydFN0YXRlLmRvYy5saW5lQXQodHIuc3RhcnRTdGF0ZS5zZWxlY3Rpb24ubWFpbi5oZWFkKS5mcm9tO1xyXG4gICAgICAgICAgICBpZiAobGluZVN0YXJ0ICE9IHRyLmNoYW5nZXMubWFwUG9zKHByZXZMaW5lU3RhcnQsIC0xKSlcclxuICAgICAgICAgICAgICAgIHZhbHVlID0gUmFuZ2VTZXQuZW1wdHk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhbHVlID0gdmFsdWUubWFwKHRyLmNoYW5nZXMpO1xyXG4gICAgICAgIGZvciAobGV0IGVmZmVjdCBvZiB0ci5lZmZlY3RzKSB7XHJcbiAgICAgICAgICAgIGlmIChlZmZlY3QuaXMoY2xvc2VCcmFja2V0RWZmZWN0KSlcclxuICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUudXBkYXRlKHsgYWRkOiBbY2xvc2VkQnJhY2tldC5yYW5nZShlZmZlY3QudmFsdWUsIGVmZmVjdC52YWx1ZSArIDEpXSB9KTtcclxuICAgICAgICAgICAgZWxzZSBpZiAoZWZmZWN0LmlzKHNraXBCcmFja2V0RWZmZWN0KSlcclxuICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUudXBkYXRlKHsgZmlsdGVyOiBmcm9tID0+IGZyb20gIT0gZWZmZWN0LnZhbHVlIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdmFsdWU7XHJcbiAgICB9XHJcbn0pO1xyXG4vKipcclxuRXh0ZW5zaW9uIHRvIGVuYWJsZSBicmFja2V0LWNsb3NpbmcgYmVoYXZpb3IuIFdoZW4gYSBjbG9zZWFibGVcclxuYnJhY2tldCBpcyB0eXBlZCwgaXRzIGNsb3NpbmcgYnJhY2tldCBpcyBpbW1lZGlhdGVseSBpbnNlcnRlZFxyXG5hZnRlciB0aGUgY3Vyc29yLiBXaGVuIGNsb3NpbmcgYSBicmFja2V0IGRpcmVjdGx5IGluIGZyb250IG9mIGFcclxuY2xvc2luZyBicmFja2V0IGluc2VydGVkIGJ5IHRoZSBleHRlbnNpb24sIHRoZSBjdXJzb3IgbW92ZXMgb3ZlclxyXG50aGF0IGJyYWNrZXQuXHJcbiovXHJcbmZ1bmN0aW9uIGNsb3NlQnJhY2tldHMoKSB7XHJcbiAgICByZXR1cm4gW2lucHV0SGFuZGxlciwgYnJhY2tldFN0YXRlXTtcclxufVxyXG5jb25zdCBkZWZpbmVkQ2xvc2luZyA9IFwiKClbXXt9PD5cIjtcclxuZnVuY3Rpb24gY2xvc2luZyhjaCkge1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkZWZpbmVkQ2xvc2luZy5sZW5ndGg7IGkgKz0gMilcclxuICAgICAgICBpZiAoZGVmaW5lZENsb3NpbmcuY2hhckNvZGVBdChpKSA9PSBjaClcclxuICAgICAgICAgICAgcmV0dXJuIGRlZmluZWRDbG9zaW5nLmNoYXJBdChpICsgMSk7XHJcbiAgICByZXR1cm4gZnJvbUNvZGVQb2ludChjaCA8IDEyOCA/IGNoIDogY2ggKyAxKTtcclxufVxyXG5mdW5jdGlvbiBjb25maWcoc3RhdGUsIHBvcykge1xyXG4gICAgcmV0dXJuIHN0YXRlLmxhbmd1YWdlRGF0YUF0KFwiY2xvc2VCcmFja2V0c1wiLCBwb3MpWzBdIHx8IGRlZmF1bHRzO1xyXG59XHJcbmNvbnN0IGFuZHJvaWQgPSB0eXBlb2YgbmF2aWdhdG9yID09IFwib2JqZWN0XCIgJiYgLypAX19QVVJFX18qLy9BbmRyb2lkXFxiLy50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xyXG5jb25zdCBpbnB1dEhhbmRsZXIgPSAvKkBfX1BVUkVfXyovRWRpdG9yVmlldy5pbnB1dEhhbmRsZXIub2YoKHZpZXcsIGZyb20sIHRvLCBpbnNlcnQpID0+IHtcclxuICAgIGlmICgoYW5kcm9pZCA/IHZpZXcuY29tcG9zaW5nIDogdmlldy5jb21wb3NpdGlvblN0YXJ0ZWQpIHx8IHZpZXcuc3RhdGUucmVhZE9ubHkpXHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgbGV0IHNlbCA9IHZpZXcuc3RhdGUuc2VsZWN0aW9uLm1haW47XHJcbiAgICBpZiAoaW5zZXJ0Lmxlbmd0aCA+IDIgfHwgaW5zZXJ0Lmxlbmd0aCA9PSAyICYmIGNvZGVQb2ludFNpemUoY29kZVBvaW50QXQoaW5zZXJ0LCAwKSkgPT0gMSB8fFxyXG4gICAgICAgIGZyb20gIT0gc2VsLmZyb20gfHwgdG8gIT0gc2VsLnRvKVxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIGxldCB0ciA9IGluc2VydEJyYWNrZXQodmlldy5zdGF0ZSwgaW5zZXJ0KTtcclxuICAgIGlmICghdHIpXHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgdmlldy5kaXNwYXRjaCh0cik7XHJcbiAgICByZXR1cm4gdHJ1ZTtcclxufSk7XHJcbi8qKlxyXG5Db21tYW5kIHRoYXQgaW1wbGVtZW50cyBkZWxldGluZyBhIHBhaXIgb2YgbWF0Y2hpbmcgYnJhY2tldHMgd2hlblxyXG50aGUgY3Vyc29yIGlzIGJldHdlZW4gdGhlbS5cclxuKi9cclxuY29uc3QgZGVsZXRlQnJhY2tldFBhaXIgPSAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xyXG4gICAgaWYgKHN0YXRlLnJlYWRPbmx5KVxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIGxldCBjb25mID0gY29uZmlnKHN0YXRlLCBzdGF0ZS5zZWxlY3Rpb24ubWFpbi5oZWFkKTtcclxuICAgIGxldCB0b2tlbnMgPSBjb25mLmJyYWNrZXRzIHx8IGRlZmF1bHRzLmJyYWNrZXRzO1xyXG4gICAgbGV0IGRvbnQgPSBudWxsLCBjaGFuZ2VzID0gc3RhdGUuY2hhbmdlQnlSYW5nZShyYW5nZSA9PiB7XHJcbiAgICAgICAgaWYgKHJhbmdlLmVtcHR5KSB7XHJcbiAgICAgICAgICAgIGxldCBiZWZvcmUgPSBwcmV2Q2hhcihzdGF0ZS5kb2MsIHJhbmdlLmhlYWQpO1xyXG4gICAgICAgICAgICBmb3IgKGxldCB0b2tlbiBvZiB0b2tlbnMpIHtcclxuICAgICAgICAgICAgICAgIGlmICh0b2tlbiA9PSBiZWZvcmUgJiYgbmV4dENoYXIoc3RhdGUuZG9jLCByYW5nZS5oZWFkKSA9PSBjbG9zaW5nKGNvZGVQb2ludEF0KHRva2VuLCAwKSkpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgY2hhbmdlczogeyBmcm9tOiByYW5nZS5oZWFkIC0gdG9rZW4ubGVuZ3RoLCB0bzogcmFuZ2UuaGVhZCArIHRva2VuLmxlbmd0aCB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICByYW5nZTogRWRpdG9yU2VsZWN0aW9uLmN1cnNvcihyYW5nZS5oZWFkIC0gdG9rZW4ubGVuZ3RoKSB9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB7IHJhbmdlOiBkb250ID0gcmFuZ2UgfTtcclxuICAgIH0pO1xyXG4gICAgaWYgKCFkb250KVxyXG4gICAgICAgIGRpc3BhdGNoKHN0YXRlLnVwZGF0ZShjaGFuZ2VzLCB7IHNjcm9sbEludG9WaWV3OiB0cnVlLCB1c2VyRXZlbnQ6IFwiZGVsZXRlLmJhY2t3YXJkXCIgfSkpO1xyXG4gICAgcmV0dXJuICFkb250O1xyXG59O1xyXG4vKipcclxuQ2xvc2UtYnJhY2tldHMgcmVsYXRlZCBrZXkgYmluZGluZ3MuIEJpbmRzIEJhY2tzcGFjZSB0b1xyXG5bYGRlbGV0ZUJyYWNrZXRQYWlyYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNhdXRvY29tcGxldGUuZGVsZXRlQnJhY2tldFBhaXIpLlxyXG4qL1xyXG5jb25zdCBjbG9zZUJyYWNrZXRzS2V5bWFwID0gW1xyXG4gICAgeyBrZXk6IFwiQmFja3NwYWNlXCIsIHJ1bjogZGVsZXRlQnJhY2tldFBhaXIgfVxyXG5dO1xyXG4vKipcclxuSW1wbGVtZW50cyB0aGUgZXh0ZW5zaW9uJ3MgYmVoYXZpb3Igb24gdGV4dCBpbnNlcnRpb24uIElmIHRoZVxyXG5naXZlbiBzdHJpbmcgY291bnRzIGFzIGEgYnJhY2tldCBpbiB0aGUgbGFuZ3VhZ2UgYXJvdW5kIHRoZVxyXG5zZWxlY3Rpb24sIGFuZCByZXBsYWNpbmcgdGhlIHNlbGVjdGlvbiB3aXRoIGl0IHJlcXVpcmVzIGN1c3RvbVxyXG5iZWhhdmlvciAoaW5zZXJ0aW5nIGEgY2xvc2luZyB2ZXJzaW9uIG9yIHNraXBwaW5nIHBhc3QgYVxyXG5wcmV2aW91c2x5LWNsb3NlZCBicmFja2V0KSwgdGhpcyBmdW5jdGlvbiByZXR1cm5zIGEgdHJhbnNhY3Rpb25cclxucmVwcmVzZW50aW5nIHRoYXQgY3VzdG9tIGJlaGF2aW9yLiAoWW91IG9ubHkgbmVlZCB0aGlzIGlmIHlvdSB3YW50XHJcbnRvIHByb2dyYW1tYXRpY2FsbHkgaW5zZXJ0IGJyYWNrZXRz4oCUdGhlXHJcbltgY2xvc2VCcmFja2V0c2BdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jYXV0b2NvbXBsZXRlLmNsb3NlQnJhY2tldHMpIGV4dGVuc2lvbiB3aWxsXHJcbnRha2UgY2FyZSBvZiBydW5uaW5nIHRoaXMgZm9yIHVzZXIgaW5wdXQuKVxyXG4qL1xyXG5mdW5jdGlvbiBpbnNlcnRCcmFja2V0KHN0YXRlLCBicmFja2V0KSB7XHJcbiAgICBsZXQgY29uZiA9IGNvbmZpZyhzdGF0ZSwgc3RhdGUuc2VsZWN0aW9uLm1haW4uaGVhZCk7XHJcbiAgICBsZXQgdG9rZW5zID0gY29uZi5icmFja2V0cyB8fCBkZWZhdWx0cy5icmFja2V0cztcclxuICAgIGZvciAobGV0IHRvayBvZiB0b2tlbnMpIHtcclxuICAgICAgICBsZXQgY2xvc2VkID0gY2xvc2luZyhjb2RlUG9pbnRBdCh0b2ssIDApKTtcclxuICAgICAgICBpZiAoYnJhY2tldCA9PSB0b2spXHJcbiAgICAgICAgICAgIHJldHVybiBjbG9zZWQgPT0gdG9rID8gaGFuZGxlU2FtZShzdGF0ZSwgdG9rLCB0b2tlbnMuaW5kZXhPZih0b2sgKyB0b2sgKyB0b2spID4gLTEsIGNvbmYpXHJcbiAgICAgICAgICAgICAgICA6IGhhbmRsZU9wZW4oc3RhdGUsIHRvaywgY2xvc2VkLCBjb25mLmJlZm9yZSB8fCBkZWZhdWx0cy5iZWZvcmUpO1xyXG4gICAgICAgIGlmIChicmFja2V0ID09IGNsb3NlZCAmJiBjbG9zZWRCcmFja2V0QXQoc3RhdGUsIHN0YXRlLnNlbGVjdGlvbi5tYWluLmZyb20pKVxyXG4gICAgICAgICAgICByZXR1cm4gaGFuZGxlQ2xvc2Uoc3RhdGUsIHRvaywgY2xvc2VkKTtcclxuICAgIH1cclxuICAgIHJldHVybiBudWxsO1xyXG59XHJcbmZ1bmN0aW9uIGNsb3NlZEJyYWNrZXRBdChzdGF0ZSwgcG9zKSB7XHJcbiAgICBsZXQgZm91bmQgPSBmYWxzZTtcclxuICAgIHN0YXRlLmZpZWxkKGJyYWNrZXRTdGF0ZSkuYmV0d2VlbigwLCBzdGF0ZS5kb2MubGVuZ3RoLCBmcm9tID0+IHtcclxuICAgICAgICBpZiAoZnJvbSA9PSBwb3MpXHJcbiAgICAgICAgICAgIGZvdW5kID0gdHJ1ZTtcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIGZvdW5kO1xyXG59XHJcbmZ1bmN0aW9uIG5leHRDaGFyKGRvYywgcG9zKSB7XHJcbiAgICBsZXQgbmV4dCA9IGRvYy5zbGljZVN0cmluZyhwb3MsIHBvcyArIDIpO1xyXG4gICAgcmV0dXJuIG5leHQuc2xpY2UoMCwgY29kZVBvaW50U2l6ZShjb2RlUG9pbnRBdChuZXh0LCAwKSkpO1xyXG59XHJcbmZ1bmN0aW9uIHByZXZDaGFyKGRvYywgcG9zKSB7XHJcbiAgICBsZXQgcHJldiA9IGRvYy5zbGljZVN0cmluZyhwb3MgLSAyLCBwb3MpO1xyXG4gICAgcmV0dXJuIGNvZGVQb2ludFNpemUoY29kZVBvaW50QXQocHJldiwgMCkpID09IHByZXYubGVuZ3RoID8gcHJldiA6IHByZXYuc2xpY2UoMSk7XHJcbn1cclxuZnVuY3Rpb24gaGFuZGxlT3BlbihzdGF0ZSwgb3BlbiwgY2xvc2UsIGNsb3NlQmVmb3JlKSB7XHJcbiAgICBsZXQgZG9udCA9IG51bGwsIGNoYW5nZXMgPSBzdGF0ZS5jaGFuZ2VCeVJhbmdlKHJhbmdlID0+IHtcclxuICAgICAgICBpZiAoIXJhbmdlLmVtcHR5KVxyXG4gICAgICAgICAgICByZXR1cm4geyBjaGFuZ2VzOiBbeyBpbnNlcnQ6IG9wZW4sIGZyb206IHJhbmdlLmZyb20gfSwgeyBpbnNlcnQ6IGNsb3NlLCBmcm9tOiByYW5nZS50byB9XSxcclxuICAgICAgICAgICAgICAgIGVmZmVjdHM6IGNsb3NlQnJhY2tldEVmZmVjdC5vZihyYW5nZS50byArIG9wZW4ubGVuZ3RoKSxcclxuICAgICAgICAgICAgICAgIHJhbmdlOiBFZGl0b3JTZWxlY3Rpb24ucmFuZ2UocmFuZ2UuYW5jaG9yICsgb3Blbi5sZW5ndGgsIHJhbmdlLmhlYWQgKyBvcGVuLmxlbmd0aCkgfTtcclxuICAgICAgICBsZXQgbmV4dCA9IG5leHRDaGFyKHN0YXRlLmRvYywgcmFuZ2UuaGVhZCk7XHJcbiAgICAgICAgaWYgKCFuZXh0IHx8IC9cXHMvLnRlc3QobmV4dCkgfHwgY2xvc2VCZWZvcmUuaW5kZXhPZihuZXh0KSA+IC0xKVxyXG4gICAgICAgICAgICByZXR1cm4geyBjaGFuZ2VzOiB7IGluc2VydDogb3BlbiArIGNsb3NlLCBmcm9tOiByYW5nZS5oZWFkIH0sXHJcbiAgICAgICAgICAgICAgICBlZmZlY3RzOiBjbG9zZUJyYWNrZXRFZmZlY3Qub2YocmFuZ2UuaGVhZCArIG9wZW4ubGVuZ3RoKSxcclxuICAgICAgICAgICAgICAgIHJhbmdlOiBFZGl0b3JTZWxlY3Rpb24uY3Vyc29yKHJhbmdlLmhlYWQgKyBvcGVuLmxlbmd0aCkgfTtcclxuICAgICAgICByZXR1cm4geyByYW5nZTogZG9udCA9IHJhbmdlIH07XHJcbiAgICB9KTtcclxuICAgIHJldHVybiBkb250ID8gbnVsbCA6IHN0YXRlLnVwZGF0ZShjaGFuZ2VzLCB7XHJcbiAgICAgICAgc2Nyb2xsSW50b1ZpZXc6IHRydWUsXHJcbiAgICAgICAgdXNlckV2ZW50OiBcImlucHV0LnR5cGVcIlxyXG4gICAgfSk7XHJcbn1cclxuZnVuY3Rpb24gaGFuZGxlQ2xvc2Uoc3RhdGUsIF9vcGVuLCBjbG9zZSkge1xyXG4gICAgbGV0IGRvbnQgPSBudWxsLCBtb3ZlZCA9IHN0YXRlLnNlbGVjdGlvbi5yYW5nZXMubWFwKHJhbmdlID0+IHtcclxuICAgICAgICBpZiAocmFuZ2UuZW1wdHkgJiYgbmV4dENoYXIoc3RhdGUuZG9jLCByYW5nZS5oZWFkKSA9PSBjbG9zZSlcclxuICAgICAgICAgICAgcmV0dXJuIEVkaXRvclNlbGVjdGlvbi5jdXJzb3IocmFuZ2UuaGVhZCArIGNsb3NlLmxlbmd0aCk7XHJcbiAgICAgICAgcmV0dXJuIGRvbnQgPSByYW5nZTtcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIGRvbnQgPyBudWxsIDogc3RhdGUudXBkYXRlKHtcclxuICAgICAgICBzZWxlY3Rpb246IEVkaXRvclNlbGVjdGlvbi5jcmVhdGUobW92ZWQsIHN0YXRlLnNlbGVjdGlvbi5tYWluSW5kZXgpLFxyXG4gICAgICAgIHNjcm9sbEludG9WaWV3OiB0cnVlLFxyXG4gICAgICAgIGVmZmVjdHM6IHN0YXRlLnNlbGVjdGlvbi5yYW5nZXMubWFwKCh7IGZyb20gfSkgPT4gc2tpcEJyYWNrZXRFZmZlY3Qub2YoZnJvbSkpXHJcbiAgICB9KTtcclxufVxyXG4vLyBIYW5kbGVzIGNhc2VzIHdoZXJlIHRoZSBvcGVuIGFuZCBjbG9zZSB0b2tlbiBhcmUgdGhlIHNhbWUsIGFuZFxyXG4vLyBwb3NzaWJseSB0cmlwbGUgcXVvdGVzIChhcyBpbiBgXCJcIlwiYWJjXCJcIlwiYC1zdHlsZSBxdW90aW5nKS5cclxuZnVuY3Rpb24gaGFuZGxlU2FtZShzdGF0ZSwgdG9rZW4sIGFsbG93VHJpcGxlLCBjb25maWcpIHtcclxuICAgIGxldCBzdHJpbmdQcmVmaXhlcyA9IGNvbmZpZy5zdHJpbmdQcmVmaXhlcyB8fCBkZWZhdWx0cy5zdHJpbmdQcmVmaXhlcztcclxuICAgIGxldCBkb250ID0gbnVsbCwgY2hhbmdlcyA9IHN0YXRlLmNoYW5nZUJ5UmFuZ2UocmFuZ2UgPT4ge1xyXG4gICAgICAgIGlmICghcmFuZ2UuZW1wdHkpXHJcbiAgICAgICAgICAgIHJldHVybiB7IGNoYW5nZXM6IFt7IGluc2VydDogdG9rZW4sIGZyb206IHJhbmdlLmZyb20gfSwgeyBpbnNlcnQ6IHRva2VuLCBmcm9tOiByYW5nZS50byB9XSxcclxuICAgICAgICAgICAgICAgIGVmZmVjdHM6IGNsb3NlQnJhY2tldEVmZmVjdC5vZihyYW5nZS50byArIHRva2VuLmxlbmd0aCksXHJcbiAgICAgICAgICAgICAgICByYW5nZTogRWRpdG9yU2VsZWN0aW9uLnJhbmdlKHJhbmdlLmFuY2hvciArIHRva2VuLmxlbmd0aCwgcmFuZ2UuaGVhZCArIHRva2VuLmxlbmd0aCkgfTtcclxuICAgICAgICBsZXQgcG9zID0gcmFuZ2UuaGVhZCwgbmV4dCA9IG5leHRDaGFyKHN0YXRlLmRvYywgcG9zKSwgc3RhcnQ7XHJcbiAgICAgICAgaWYgKG5leHQgPT0gdG9rZW4pIHtcclxuICAgICAgICAgICAgaWYgKG5vZGVTdGFydChzdGF0ZSwgcG9zKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgY2hhbmdlczogeyBpbnNlcnQ6IHRva2VuICsgdG9rZW4sIGZyb206IHBvcyB9LFxyXG4gICAgICAgICAgICAgICAgICAgIGVmZmVjdHM6IGNsb3NlQnJhY2tldEVmZmVjdC5vZihwb3MgKyB0b2tlbi5sZW5ndGgpLFxyXG4gICAgICAgICAgICAgICAgICAgIHJhbmdlOiBFZGl0b3JTZWxlY3Rpb24uY3Vyc29yKHBvcyArIHRva2VuLmxlbmd0aCkgfTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChjbG9zZWRCcmFja2V0QXQoc3RhdGUsIHBvcykpIHtcclxuICAgICAgICAgICAgICAgIGxldCBpc1RyaXBsZSA9IGFsbG93VHJpcGxlICYmIHN0YXRlLnNsaWNlRG9jKHBvcywgcG9zICsgdG9rZW4ubGVuZ3RoICogMykgPT0gdG9rZW4gKyB0b2tlbiArIHRva2VuO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgcmFuZ2U6IEVkaXRvclNlbGVjdGlvbi5jdXJzb3IocG9zICsgdG9rZW4ubGVuZ3RoICogKGlzVHJpcGxlID8gMyA6IDEpKSxcclxuICAgICAgICAgICAgICAgICAgICBlZmZlY3RzOiBza2lwQnJhY2tldEVmZmVjdC5vZihwb3MpIH07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoYWxsb3dUcmlwbGUgJiYgc3RhdGUuc2xpY2VEb2MocG9zIC0gMiAqIHRva2VuLmxlbmd0aCwgcG9zKSA9PSB0b2tlbiArIHRva2VuICYmXHJcbiAgICAgICAgICAgIChzdGFydCA9IGNhblN0YXJ0U3RyaW5nQXQoc3RhdGUsIHBvcyAtIDIgKiB0b2tlbi5sZW5ndGgsIHN0cmluZ1ByZWZpeGVzKSkgPiAtMSAmJlxyXG4gICAgICAgICAgICBub2RlU3RhcnQoc3RhdGUsIHN0YXJ0KSkge1xyXG4gICAgICAgICAgICByZXR1cm4geyBjaGFuZ2VzOiB7IGluc2VydDogdG9rZW4gKyB0b2tlbiArIHRva2VuICsgdG9rZW4sIGZyb206IHBvcyB9LFxyXG4gICAgICAgICAgICAgICAgZWZmZWN0czogY2xvc2VCcmFja2V0RWZmZWN0Lm9mKHBvcyArIHRva2VuLmxlbmd0aCksXHJcbiAgICAgICAgICAgICAgICByYW5nZTogRWRpdG9yU2VsZWN0aW9uLmN1cnNvcihwb3MgKyB0b2tlbi5sZW5ndGgpIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHN0YXRlLmNoYXJDYXRlZ29yaXplcihwb3MpKG5leHQpICE9IENoYXJDYXRlZ29yeS5Xb3JkKSB7XHJcbiAgICAgICAgICAgIGlmIChjYW5TdGFydFN0cmluZ0F0KHN0YXRlLCBwb3MsIHN0cmluZ1ByZWZpeGVzKSA+IC0xICYmICFwcm9iYWJseUluU3RyaW5nKHN0YXRlLCBwb3MsIHRva2VuLCBzdHJpbmdQcmVmaXhlcykpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4geyBjaGFuZ2VzOiB7IGluc2VydDogdG9rZW4gKyB0b2tlbiwgZnJvbTogcG9zIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgZWZmZWN0czogY2xvc2VCcmFja2V0RWZmZWN0Lm9mKHBvcyArIHRva2VuLmxlbmd0aCksXHJcbiAgICAgICAgICAgICAgICAgICAgcmFuZ2U6IEVkaXRvclNlbGVjdGlvbi5jdXJzb3IocG9zICsgdG9rZW4ubGVuZ3RoKSB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4geyByYW5nZTogZG9udCA9IHJhbmdlIH07XHJcbiAgICB9KTtcclxuICAgIHJldHVybiBkb250ID8gbnVsbCA6IHN0YXRlLnVwZGF0ZShjaGFuZ2VzLCB7XHJcbiAgICAgICAgc2Nyb2xsSW50b1ZpZXc6IHRydWUsXHJcbiAgICAgICAgdXNlckV2ZW50OiBcImlucHV0LnR5cGVcIlxyXG4gICAgfSk7XHJcbn1cclxuZnVuY3Rpb24gbm9kZVN0YXJ0KHN0YXRlLCBwb3MpIHtcclxuICAgIGxldCB0cmVlID0gc3ludGF4VHJlZShzdGF0ZSkucmVzb2x2ZUlubmVyKHBvcyArIDEpO1xyXG4gICAgcmV0dXJuIHRyZWUucGFyZW50ICYmIHRyZWUuZnJvbSA9PSBwb3M7XHJcbn1cclxuZnVuY3Rpb24gcHJvYmFibHlJblN0cmluZyhzdGF0ZSwgcG9zLCBxdW90ZVRva2VuLCBwcmVmaXhlcykge1xyXG4gICAgbGV0IG5vZGUgPSBzeW50YXhUcmVlKHN0YXRlKS5yZXNvbHZlSW5uZXIocG9zLCAtMSk7XHJcbiAgICBsZXQgbWF4UHJlZml4ID0gcHJlZml4ZXMucmVkdWNlKChtLCBwKSA9PiBNYXRoLm1heChtLCBwLmxlbmd0aCksIDApO1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCA1OyBpKyspIHtcclxuICAgICAgICBsZXQgc3RhcnQgPSBzdGF0ZS5zbGljZURvYyhub2RlLmZyb20sIE1hdGgubWluKG5vZGUudG8sIG5vZGUuZnJvbSArIHF1b3RlVG9rZW4ubGVuZ3RoICsgbWF4UHJlZml4KSk7XHJcbiAgICAgICAgbGV0IHF1b3RlUG9zID0gc3RhcnQuaW5kZXhPZihxdW90ZVRva2VuKTtcclxuICAgICAgICBpZiAoIXF1b3RlUG9zIHx8IHF1b3RlUG9zID4gLTEgJiYgcHJlZml4ZXMuaW5kZXhPZihzdGFydC5zbGljZSgwLCBxdW90ZVBvcykpID4gLTEpIHtcclxuICAgICAgICAgICAgbGV0IGZpcnN0ID0gbm9kZS5maXJzdENoaWxkO1xyXG4gICAgICAgICAgICB3aGlsZSAoZmlyc3QgJiYgZmlyc3QuZnJvbSA9PSBub2RlLmZyb20gJiYgZmlyc3QudG8gLSBmaXJzdC5mcm9tID4gcXVvdGVUb2tlbi5sZW5ndGggKyBxdW90ZVBvcykge1xyXG4gICAgICAgICAgICAgICAgaWYgKHN0YXRlLnNsaWNlRG9jKGZpcnN0LnRvIC0gcXVvdGVUb2tlbi5sZW5ndGgsIGZpcnN0LnRvKSA9PSBxdW90ZVRva2VuKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICAgIGZpcnN0ID0gZmlyc3QuZmlyc3RDaGlsZDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IHBhcmVudCA9IG5vZGUudG8gPT0gcG9zICYmIG5vZGUucGFyZW50O1xyXG4gICAgICAgIGlmICghcGFyZW50KVxyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICBub2RlID0gcGFyZW50O1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG59XHJcbmZ1bmN0aW9uIGNhblN0YXJ0U3RyaW5nQXQoc3RhdGUsIHBvcywgcHJlZml4ZXMpIHtcclxuICAgIGxldCBjaGFyQ2F0ID0gc3RhdGUuY2hhckNhdGVnb3JpemVyKHBvcyk7XHJcbiAgICBpZiAoY2hhckNhdChzdGF0ZS5zbGljZURvYyhwb3MgLSAxLCBwb3MpKSAhPSBDaGFyQ2F0ZWdvcnkuV29yZClcclxuICAgICAgICByZXR1cm4gcG9zO1xyXG4gICAgZm9yIChsZXQgcHJlZml4IG9mIHByZWZpeGVzKSB7XHJcbiAgICAgICAgbGV0IHN0YXJ0ID0gcG9zIC0gcHJlZml4Lmxlbmd0aDtcclxuICAgICAgICBpZiAoc3RhdGUuc2xpY2VEb2Moc3RhcnQsIHBvcykgPT0gcHJlZml4ICYmIGNoYXJDYXQoc3RhdGUuc2xpY2VEb2Moc3RhcnQgLSAxLCBzdGFydCkpICE9IENoYXJDYXRlZ29yeS5Xb3JkKVxyXG4gICAgICAgICAgICByZXR1cm4gc3RhcnQ7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gLTE7XHJcbn1cclxuXHJcbi8qKlxyXG5SZXR1cm5zIGFuIGV4dGVuc2lvbiB0aGF0IGVuYWJsZXMgYXV0b2NvbXBsZXRpb24uXHJcbiovXHJcbmZ1bmN0aW9uIGF1dG9jb21wbGV0aW9uKGNvbmZpZyA9IHt9KSB7XHJcbiAgICByZXR1cm4gW1xyXG4gICAgICAgIGNvbXBsZXRpb25TdGF0ZSxcclxuICAgICAgICBjb21wbGV0aW9uQ29uZmlnLm9mKGNvbmZpZyksXHJcbiAgICAgICAgY29tcGxldGlvblBsdWdpbixcclxuICAgICAgICBjb21wbGV0aW9uS2V5bWFwRXh0LFxyXG4gICAgICAgIGJhc2VUaGVtZVxyXG4gICAgXTtcclxufVxyXG4vKipcclxuQmFzaWMga2V5YmluZGluZ3MgZm9yIGF1dG9jb21wbGV0aW9uLlxyXG5cclxuIC0gQ3RybC1TcGFjZTogW2BzdGFydENvbXBsZXRpb25gXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2F1dG9jb21wbGV0ZS5zdGFydENvbXBsZXRpb24pXHJcbiAtIEVzY2FwZTogW2BjbG9zZUNvbXBsZXRpb25gXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2F1dG9jb21wbGV0ZS5jbG9zZUNvbXBsZXRpb24pXHJcbiAtIEFycm93RG93bjogW2Btb3ZlQ29tcGxldGlvblNlbGVjdGlvbmBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jYXV0b2NvbXBsZXRlLm1vdmVDb21wbGV0aW9uU2VsZWN0aW9uKWAodHJ1ZSlgXHJcbiAtIEFycm93VXA6IFtgbW92ZUNvbXBsZXRpb25TZWxlY3Rpb25gXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2F1dG9jb21wbGV0ZS5tb3ZlQ29tcGxldGlvblNlbGVjdGlvbilgKGZhbHNlKWBcclxuIC0gUGFnZURvd246IFtgbW92ZUNvbXBsZXRpb25TZWxlY3Rpb25gXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2F1dG9jb21wbGV0ZS5tb3ZlQ29tcGxldGlvblNlbGVjdGlvbilgKHRydWUsIFwicGFnZVwiKWBcclxuIC0gUGFnZURvd246IFtgbW92ZUNvbXBsZXRpb25TZWxlY3Rpb25gXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2F1dG9jb21wbGV0ZS5tb3ZlQ29tcGxldGlvblNlbGVjdGlvbilgKHRydWUsIFwicGFnZVwiKWBcclxuIC0gRW50ZXI6IFtgYWNjZXB0Q29tcGxldGlvbmBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jYXV0b2NvbXBsZXRlLmFjY2VwdENvbXBsZXRpb24pXHJcbiovXHJcbmNvbnN0IGNvbXBsZXRpb25LZXltYXAgPSBbXHJcbiAgICB7IGtleTogXCJDdHJsLVNwYWNlXCIsIHJ1bjogc3RhcnRDb21wbGV0aW9uIH0sXHJcbiAgICB7IGtleTogXCJFc2NhcGVcIiwgcnVuOiBjbG9zZUNvbXBsZXRpb24gfSxcclxuICAgIHsga2V5OiBcIkFycm93RG93blwiLCBydW46IC8qQF9fUFVSRV9fKi9tb3ZlQ29tcGxldGlvblNlbGVjdGlvbih0cnVlKSB9LFxyXG4gICAgeyBrZXk6IFwiQXJyb3dVcFwiLCBydW46IC8qQF9fUFVSRV9fKi9tb3ZlQ29tcGxldGlvblNlbGVjdGlvbihmYWxzZSkgfSxcclxuICAgIHsga2V5OiBcIlBhZ2VEb3duXCIsIHJ1bjogLypAX19QVVJFX18qL21vdmVDb21wbGV0aW9uU2VsZWN0aW9uKHRydWUsIFwicGFnZVwiKSB9LFxyXG4gICAgeyBrZXk6IFwiUGFnZVVwXCIsIHJ1bjogLypAX19QVVJFX18qL21vdmVDb21wbGV0aW9uU2VsZWN0aW9uKGZhbHNlLCBcInBhZ2VcIikgfSxcclxuICAgIHsga2V5OiBcIkVudGVyXCIsIHJ1bjogYWNjZXB0Q29tcGxldGlvbiB9XHJcbl07XHJcbmNvbnN0IGNvbXBsZXRpb25LZXltYXBFeHQgPSAvKkBfX1BVUkVfXyovUHJlYy5oaWdoZXN0KC8qQF9fUFVSRV9fKi9rZXltYXAuY29tcHV0ZU4oW2NvbXBsZXRpb25Db25maWddLCBzdGF0ZSA9PiBzdGF0ZS5mYWNldChjb21wbGV0aW9uQ29uZmlnKS5kZWZhdWx0S2V5bWFwID8gW2NvbXBsZXRpb25LZXltYXBdIDogW10pKTtcclxuLyoqXHJcbkdldCB0aGUgY3VycmVudCBjb21wbGV0aW9uIHN0YXR1cy4gV2hlbiBjb21wbGV0aW9ucyBhcmUgYXZhaWxhYmxlLFxyXG50aGlzIHdpbGwgcmV0dXJuIGBcImFjdGl2ZVwiYC4gV2hlbiBjb21wbGV0aW9ucyBhcmUgcGVuZGluZyAoaW4gdGhlXHJcbnByb2Nlc3Mgb2YgYmVpbmcgcXVlcmllZCksIHRoaXMgcmV0dXJucyBgXCJwZW5kaW5nXCJgLiBPdGhlcndpc2UsIGl0XHJcbnJldHVybnMgYG51bGxgLlxyXG4qL1xyXG5mdW5jdGlvbiBjb21wbGV0aW9uU3RhdHVzKHN0YXRlKSB7XHJcbiAgICBsZXQgY1N0YXRlID0gc3RhdGUuZmllbGQoY29tcGxldGlvblN0YXRlLCBmYWxzZSk7XHJcbiAgICByZXR1cm4gY1N0YXRlICYmIGNTdGF0ZS5hY3RpdmUuc29tZShhID0+IGEuc3RhdGUgPT0gMSAvKiBTdGF0ZS5QZW5kaW5nICovKSA/IFwicGVuZGluZ1wiXHJcbiAgICAgICAgOiBjU3RhdGUgJiYgY1N0YXRlLmFjdGl2ZS5zb21lKGEgPT4gYS5zdGF0ZSAhPSAwIC8qIFN0YXRlLkluYWN0aXZlICovKSA/IFwiYWN0aXZlXCIgOiBudWxsO1xyXG59XHJcbmNvbnN0IGNvbXBsZXRpb25BcnJheUNhY2hlID0gLypAX19QVVJFX18qL25ldyBXZWFrTWFwO1xyXG4vKipcclxuUmV0dXJucyB0aGUgYXZhaWxhYmxlIGNvbXBsZXRpb25zIGFzIGFuIGFycmF5LlxyXG4qL1xyXG5mdW5jdGlvbiBjdXJyZW50Q29tcGxldGlvbnMoc3RhdGUpIHtcclxuICAgIHZhciBfYTtcclxuICAgIGxldCBvcGVuID0gKF9hID0gc3RhdGUuZmllbGQoY29tcGxldGlvblN0YXRlLCBmYWxzZSkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5vcGVuO1xyXG4gICAgaWYgKCFvcGVuIHx8IG9wZW4uZGlzYWJsZWQpXHJcbiAgICAgICAgcmV0dXJuIFtdO1xyXG4gICAgbGV0IGNvbXBsZXRpb25zID0gY29tcGxldGlvbkFycmF5Q2FjaGUuZ2V0KG9wZW4ub3B0aW9ucyk7XHJcbiAgICBpZiAoIWNvbXBsZXRpb25zKVxyXG4gICAgICAgIGNvbXBsZXRpb25BcnJheUNhY2hlLnNldChvcGVuLm9wdGlvbnMsIGNvbXBsZXRpb25zID0gb3Blbi5vcHRpb25zLm1hcChvID0+IG8uY29tcGxldGlvbikpO1xyXG4gICAgcmV0dXJuIGNvbXBsZXRpb25zO1xyXG59XHJcbi8qKlxyXG5SZXR1cm4gdGhlIGN1cnJlbnRseSBzZWxlY3RlZCBjb21wbGV0aW9uLCBpZiBhbnkuXHJcbiovXHJcbmZ1bmN0aW9uIHNlbGVjdGVkQ29tcGxldGlvbihzdGF0ZSkge1xyXG4gICAgdmFyIF9hO1xyXG4gICAgbGV0IG9wZW4gPSAoX2EgPSBzdGF0ZS5maWVsZChjb21wbGV0aW9uU3RhdGUsIGZhbHNlKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm9wZW47XHJcbiAgICByZXR1cm4gb3BlbiAmJiAhb3Blbi5kaXNhYmxlZCAmJiBvcGVuLnNlbGVjdGVkID49IDAgPyBvcGVuLm9wdGlvbnNbb3Blbi5zZWxlY3RlZF0uY29tcGxldGlvbiA6IG51bGw7XHJcbn1cclxuLyoqXHJcblJldHVybnMgdGhlIGN1cnJlbnRseSBzZWxlY3RlZCBwb3NpdGlvbiBpbiB0aGUgYWN0aXZlIGNvbXBsZXRpb25cclxubGlzdCwgb3IgbnVsbCBpZiBubyBjb21wbGV0aW9ucyBhcmUgYWN0aXZlLlxyXG4qL1xyXG5mdW5jdGlvbiBzZWxlY3RlZENvbXBsZXRpb25JbmRleChzdGF0ZSkge1xyXG4gICAgdmFyIF9hO1xyXG4gICAgbGV0IG9wZW4gPSAoX2EgPSBzdGF0ZS5maWVsZChjb21wbGV0aW9uU3RhdGUsIGZhbHNlKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm9wZW47XHJcbiAgICByZXR1cm4gb3BlbiAmJiAhb3Blbi5kaXNhYmxlZCAmJiBvcGVuLnNlbGVjdGVkID49IDAgPyBvcGVuLnNlbGVjdGVkIDogbnVsbDtcclxufVxyXG4vKipcclxuQ3JlYXRlIGFuIGVmZmVjdCB0aGF0IGNhbiBiZSBhdHRhY2hlZCB0byBhIHRyYW5zYWN0aW9uIHRvIGNoYW5nZVxyXG50aGUgY3VycmVudGx5IHNlbGVjdGVkIGNvbXBsZXRpb24uXHJcbiovXHJcbmZ1bmN0aW9uIHNldFNlbGVjdGVkQ29tcGxldGlvbihpbmRleCkge1xyXG4gICAgcmV0dXJuIHNldFNlbGVjdGVkRWZmZWN0Lm9mKGluZGV4KTtcclxufVxyXG5cclxuZXhwb3J0IHsgQ29tcGxldGlvbkNvbnRleHQsIGFjY2VwdENvbXBsZXRpb24sIGF1dG9jb21wbGV0aW9uLCBjbGVhclNuaXBwZXQsIGNsb3NlQnJhY2tldHMsIGNsb3NlQnJhY2tldHNLZXltYXAsIGNsb3NlQ29tcGxldGlvbiwgY29tcGxldGVBbnlXb3JkLCBjb21wbGV0ZUZyb21MaXN0LCBjb21wbGV0aW9uS2V5bWFwLCBjb21wbGV0aW9uU3RhdHVzLCBjdXJyZW50Q29tcGxldGlvbnMsIGRlbGV0ZUJyYWNrZXRQYWlyLCBpZkluLCBpZk5vdEluLCBpbnNlcnRCcmFja2V0LCBpbnNlcnRDb21wbGV0aW9uVGV4dCwgbW92ZUNvbXBsZXRpb25TZWxlY3Rpb24sIG5leHRTbmlwcGV0RmllbGQsIHBpY2tlZENvbXBsZXRpb24sIHByZXZTbmlwcGV0RmllbGQsIHNlbGVjdGVkQ29tcGxldGlvbiwgc2VsZWN0ZWRDb21wbGV0aW9uSW5kZXgsIHNldFNlbGVjdGVkQ29tcGxldGlvbiwgc25pcHBldCwgc25pcHBldENvbXBsZXRpb24sIHNuaXBwZXRLZXltYXAsIHN0YXJ0Q29tcGxldGlvbiB9O1xyXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@codemirror/autocomplete/dist/index.js\n"));

/***/ }),

/***/ "./node_modules/@codemirror/commands/dist/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/@codemirror/commands/dist/index.js ***!
  \*********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"blockComment\": function() { return /* binding */ blockComment; },\n/* harmony export */   \"blockUncomment\": function() { return /* binding */ blockUncomment; },\n/* harmony export */   \"copyLineDown\": function() { return /* binding */ copyLineDown; },\n/* harmony export */   \"copyLineUp\": function() { return /* binding */ copyLineUp; },\n/* harmony export */   \"cursorCharBackward\": function() { return /* binding */ cursorCharBackward; },\n/* harmony export */   \"cursorCharForward\": function() { return /* binding */ cursorCharForward; },\n/* harmony export */   \"cursorCharLeft\": function() { return /* binding */ cursorCharLeft; },\n/* harmony export */   \"cursorCharRight\": function() { return /* binding */ cursorCharRight; },\n/* harmony export */   \"cursorDocEnd\": function() { return /* binding */ cursorDocEnd; },\n/* harmony export */   \"cursorDocStart\": function() { return /* binding */ cursorDocStart; },\n/* harmony export */   \"cursorGroupBackward\": function() { return /* binding */ cursorGroupBackward; },\n/* harmony export */   \"cursorGroupForward\": function() { return /* binding */ cursorGroupForward; },\n/* harmony export */   \"cursorGroupLeft\": function() { return /* binding */ cursorGroupLeft; },\n/* harmony export */   \"cursorGroupRight\": function() { return /* binding */ cursorGroupRight; },\n/* harmony export */   \"cursorLineBoundaryBackward\": function() { return /* binding */ cursorLineBoundaryBackward; },\n/* harmony export */   \"cursorLineBoundaryForward\": function() { return /* binding */ cursorLineBoundaryForward; },\n/* harmony export */   \"cursorLineBoundaryLeft\": function() { return /* binding */ cursorLineBoundaryLeft; },\n/* harmony export */   \"cursorLineBoundaryRight\": function() { return /* binding */ cursorLineBoundaryRight; },\n/* harmony export */   \"cursorLineDown\": function() { return /* binding */ cursorLineDown; },\n/* harmony export */   \"cursorLineEnd\": function() { return /* binding */ cursorLineEnd; },\n/* harmony export */   \"cursorLineStart\": function() { return /* binding */ cursorLineStart; },\n/* harmony export */   \"cursorLineUp\": function() { return /* binding */ cursorLineUp; },\n/* harmony export */   \"cursorMatchingBracket\": function() { return /* binding */ cursorMatchingBracket; },\n/* harmony export */   \"cursorPageDown\": function() { return /* binding */ cursorPageDown; },\n/* harmony export */   \"cursorPageUp\": function() { return /* binding */ cursorPageUp; },\n/* harmony export */   \"cursorSubwordBackward\": function() { return /* binding */ cursorSubwordBackward; },\n/* harmony export */   \"cursorSubwordForward\": function() { return /* binding */ cursorSubwordForward; },\n/* harmony export */   \"cursorSyntaxLeft\": function() { return /* binding */ cursorSyntaxLeft; },\n/* harmony export */   \"cursorSyntaxRight\": function() { return /* binding */ cursorSyntaxRight; },\n/* harmony export */   \"defaultKeymap\": function() { return /* binding */ defaultKeymap; },\n/* harmony export */   \"deleteCharBackward\": function() { return /* binding */ deleteCharBackward; },\n/* harmony export */   \"deleteCharForward\": function() { return /* binding */ deleteCharForward; },\n/* harmony export */   \"deleteGroupBackward\": function() { return /* binding */ deleteGroupBackward; },\n/* harmony export */   \"deleteGroupForward\": function() { return /* binding */ deleteGroupForward; },\n/* harmony export */   \"deleteLine\": function() { return /* binding */ deleteLine; },\n/* harmony export */   \"deleteToLineEnd\": function() { return /* binding */ deleteToLineEnd; },\n/* harmony export */   \"deleteToLineStart\": function() { return /* binding */ deleteToLineStart; },\n/* harmony export */   \"deleteTrailingWhitespace\": function() { return /* binding */ deleteTrailingWhitespace; },\n/* harmony export */   \"emacsStyleKeymap\": function() { return /* binding */ emacsStyleKeymap; },\n/* harmony export */   \"history\": function() { return /* binding */ history; },\n/* harmony export */   \"historyField\": function() { return /* binding */ historyField; },\n/* harmony export */   \"historyKeymap\": function() { return /* binding */ historyKeymap; },\n/* harmony export */   \"indentLess\": function() { return /* binding */ indentLess; },\n/* harmony export */   \"indentMore\": function() { return /* binding */ indentMore; },\n/* harmony export */   \"indentSelection\": function() { return /* binding */ indentSelection; },\n/* harmony export */   \"indentWithTab\": function() { return /* binding */ indentWithTab; },\n/* harmony export */   \"insertBlankLine\": function() { return /* binding */ insertBlankLine; },\n/* harmony export */   \"insertNewline\": function() { return /* binding */ insertNewline; },\n/* harmony export */   \"insertNewlineAndIndent\": function() { return /* binding */ insertNewlineAndIndent; },\n/* harmony export */   \"insertTab\": function() { return /* binding */ insertTab; },\n/* harmony export */   \"invertedEffects\": function() { return /* binding */ invertedEffects; },\n/* harmony export */   \"isolateHistory\": function() { return /* binding */ isolateHistory; },\n/* harmony export */   \"lineComment\": function() { return /* binding */ lineComment; },\n/* harmony export */   \"lineUncomment\": function() { return /* binding */ lineUncomment; },\n/* harmony export */   \"moveLineDown\": function() { return /* binding */ moveLineDown; },\n/* harmony export */   \"moveLineUp\": function() { return /* binding */ moveLineUp; },\n/* harmony export */   \"redo\": function() { return /* binding */ redo; },\n/* harmony export */   \"redoDepth\": function() { return /* binding */ redoDepth; },\n/* harmony export */   \"redoSelection\": function() { return /* binding */ redoSelection; },\n/* harmony export */   \"selectAll\": function() { return /* binding */ selectAll; },\n/* harmony export */   \"selectCharBackward\": function() { return /* binding */ selectCharBackward; },\n/* harmony export */   \"selectCharForward\": function() { return /* binding */ selectCharForward; },\n/* harmony export */   \"selectCharLeft\": function() { return /* binding */ selectCharLeft; },\n/* harmony export */   \"selectCharRight\": function() { return /* binding */ selectCharRight; },\n/* harmony export */   \"selectDocEnd\": function() { return /* binding */ selectDocEnd; },\n/* harmony export */   \"selectDocStart\": function() { return /* binding */ selectDocStart; },\n/* harmony export */   \"selectGroupBackward\": function() { return /* binding */ selectGroupBackward; },\n/* harmony export */   \"selectGroupForward\": function() { return /* binding */ selectGroupForward; },\n/* harmony export */   \"selectGroupLeft\": function() { return /* binding */ selectGroupLeft; },\n/* harmony export */   \"selectGroupRight\": function() { return /* binding */ selectGroupRight; },\n/* harmony export */   \"selectLine\": function() { return /* binding */ selectLine; },\n/* harmony export */   \"selectLineBoundaryBackward\": function() { return /* binding */ selectLineBoundaryBackward; },\n/* harmony export */   \"selectLineBoundaryForward\": function() { return /* binding */ selectLineBoundaryForward; },\n/* harmony export */   \"selectLineBoundaryLeft\": function() { return /* binding */ selectLineBoundaryLeft; },\n/* harmony export */   \"selectLineBoundaryRight\": function() { return /* binding */ selectLineBoundaryRight; },\n/* harmony export */   \"selectLineDown\": function() { return /* binding */ selectLineDown; },\n/* harmony export */   \"selectLineEnd\": function() { return /* binding */ selectLineEnd; },\n/* harmony export */   \"selectLineStart\": function() { return /* binding */ selectLineStart; },\n/* harmony export */   \"selectLineUp\": function() { return /* binding */ selectLineUp; },\n/* harmony export */   \"selectMatchingBracket\": function() { return /* binding */ selectMatchingBracket; },\n/* harmony export */   \"selectPageDown\": function() { return /* binding */ selectPageDown; },\n/* harmony export */   \"selectPageUp\": function() { return /* binding */ selectPageUp; },\n/* harmony export */   \"selectParentSyntax\": function() { return /* binding */ selectParentSyntax; },\n/* harmony export */   \"selectSubwordBackward\": function() { return /* binding */ selectSubwordBackward; },\n/* harmony export */   \"selectSubwordForward\": function() { return /* binding */ selectSubwordForward; },\n/* harmony export */   \"selectSyntaxLeft\": function() { return /* binding */ selectSyntaxLeft; },\n/* harmony export */   \"selectSyntaxRight\": function() { return /* binding */ selectSyntaxRight; },\n/* harmony export */   \"simplifySelection\": function() { return /* binding */ simplifySelection; },\n/* harmony export */   \"splitLine\": function() { return /* binding */ splitLine; },\n/* harmony export */   \"standardKeymap\": function() { return /* binding */ standardKeymap; },\n/* harmony export */   \"toggleBlockComment\": function() { return /* binding */ toggleBlockComment; },\n/* harmony export */   \"toggleBlockCommentByLine\": function() { return /* binding */ toggleBlockCommentByLine; },\n/* harmony export */   \"toggleComment\": function() { return /* binding */ toggleComment; },\n/* harmony export */   \"toggleLineComment\": function() { return /* binding */ toggleLineComment; },\n/* harmony export */   \"transposeChars\": function() { return /* binding */ transposeChars; },\n/* harmony export */   \"undo\": function() { return /* binding */ undo; },\n/* harmony export */   \"undoDepth\": function() { return /* binding */ undoDepth; },\n/* harmony export */   \"undoSelection\": function() { return /* binding */ undoSelection; }\n/* harmony export */ });\n/* harmony import */ var _codemirror_state__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @codemirror/state */ \"./node_modules/@codemirror/state/dist/index.js\");\n/* harmony import */ var _codemirror_view__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @codemirror/view */ \"./node_modules/@codemirror/view/dist/index.js\");\n/* harmony import */ var _codemirror_language__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @codemirror/language */ \"./node_modules/@codemirror/language/dist/index.js\");\n/* harmony import */ var _lezer_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lezer/common */ \"./node_modules/@lezer/common/dist/index.js\");\n\r\n\r\n\r\n\r\n\r\n/**\r\nComment or uncomment the current selection. Will use line comments\r\nif available, otherwise falling back to block comments.\r\n*/\r\nconst toggleComment = target => {\r\n    let config = getConfig(target.state);\r\n    return config.line ? toggleLineComment(target) : config.block ? toggleBlockCommentByLine(target) : false;\r\n};\r\nfunction command(f, option) {\r\n    return ({ state, dispatch }) => {\r\n        if (state.readOnly)\r\n            return false;\r\n        let tr = f(option, state);\r\n        if (!tr)\r\n            return false;\r\n        dispatch(state.update(tr));\r\n        return true;\r\n    };\r\n}\r\n/**\r\nComment or uncomment the current selection using line comments.\r\nThe line comment syntax is taken from the\r\n[`commentTokens`](https://codemirror.net/6/docs/ref/#commands.CommentTokens) [language\r\ndata](https://codemirror.net/6/docs/ref/#state.EditorState.languageDataAt).\r\n*/\r\nconst toggleLineComment = /*@__PURE__*/command(changeLineComment, 0 /* CommentOption.Toggle */);\r\n/**\r\nComment the current selection using line comments.\r\n*/\r\nconst lineComment = /*@__PURE__*/command(changeLineComment, 1 /* CommentOption.Comment */);\r\n/**\r\nUncomment the current selection using line comments.\r\n*/\r\nconst lineUncomment = /*@__PURE__*/command(changeLineComment, 2 /* CommentOption.Uncomment */);\r\n/**\r\nComment or uncomment the current selection using block comments.\r\nThe block comment syntax is taken from the\r\n[`commentTokens`](https://codemirror.net/6/docs/ref/#commands.CommentTokens) [language\r\ndata](https://codemirror.net/6/docs/ref/#state.EditorState.languageDataAt).\r\n*/\r\nconst toggleBlockComment = /*@__PURE__*/command(changeBlockComment, 0 /* CommentOption.Toggle */);\r\n/**\r\nComment the current selection using block comments.\r\n*/\r\nconst blockComment = /*@__PURE__*/command(changeBlockComment, 1 /* CommentOption.Comment */);\r\n/**\r\nUncomment the current selection using block comments.\r\n*/\r\nconst blockUncomment = /*@__PURE__*/command(changeBlockComment, 2 /* CommentOption.Uncomment */);\r\n/**\r\nComment or uncomment the lines around the current selection using\r\nblock comments.\r\n*/\r\nconst toggleBlockCommentByLine = /*@__PURE__*/command((o, s) => changeBlockComment(o, s, selectedLineRanges(s)), 0 /* CommentOption.Toggle */);\r\nfunction getConfig(state, pos = state.selection.main.head) {\r\n    let data = state.languageDataAt(\"commentTokens\", pos);\r\n    return data.length ? data[0] : {};\r\n}\r\nconst SearchMargin = 50;\r\n/**\r\nDetermines if the given range is block-commented in the given\r\nstate.\r\n*/\r\nfunction findBlockComment(state, { open, close }, from, to) {\r\n    let textBefore = state.sliceDoc(from - SearchMargin, from);\r\n    let textAfter = state.sliceDoc(to, to + SearchMargin);\r\n    let spaceBefore = /\\s*$/.exec(textBefore)[0].length, spaceAfter = /^\\s*/.exec(textAfter)[0].length;\r\n    let beforeOff = textBefore.length - spaceBefore;\r\n    if (textBefore.slice(beforeOff - open.length, beforeOff) == open &&\r\n        textAfter.slice(spaceAfter, spaceAfter + close.length) == close) {\r\n        return { open: { pos: from - spaceBefore, margin: spaceBefore && 1 },\r\n            close: { pos: to + spaceAfter, margin: spaceAfter && 1 } };\r\n    }\r\n    let startText, endText;\r\n    if (to - from <= 2 * SearchMargin) {\r\n        startText = endText = state.sliceDoc(from, to);\r\n    }\r\n    else {\r\n        startText = state.sliceDoc(from, from + SearchMargin);\r\n        endText = state.sliceDoc(to - SearchMargin, to);\r\n    }\r\n    let startSpace = /^\\s*/.exec(startText)[0].length, endSpace = /\\s*$/.exec(endText)[0].length;\r\n    let endOff = endText.length - endSpace - close.length;\r\n    if (startText.slice(startSpace, startSpace + open.length) == open &&\r\n        endText.slice(endOff, endOff + close.length) == close) {\r\n        return { open: { pos: from + startSpace + open.length,\r\n                margin: /\\s/.test(startText.charAt(startSpace + open.length)) ? 1 : 0 },\r\n            close: { pos: to - endSpace - close.length,\r\n                margin: /\\s/.test(endText.charAt(endOff - 1)) ? 1 : 0 } };\r\n    }\r\n    return null;\r\n}\r\nfunction selectedLineRanges(state) {\r\n    let ranges = [];\r\n    for (let r of state.selection.ranges) {\r\n        let fromLine = state.doc.lineAt(r.from);\r\n        let toLine = r.to <= fromLine.to ? fromLine : state.doc.lineAt(r.to);\r\n        let last = ranges.length - 1;\r\n        if (last >= 0 && ranges[last].to > fromLine.from)\r\n            ranges[last].to = toLine.to;\r\n        else\r\n            ranges.push({ from: fromLine.from, to: toLine.to });\r\n    }\r\n    return ranges;\r\n}\r\n// Performs toggle, comment and uncomment of block comments in\r\n// languages that support them.\r\nfunction changeBlockComment(option, state, ranges = state.selection.ranges) {\r\n    let tokens = ranges.map(r => getConfig(state, r.from).block);\r\n    if (!tokens.every(c => c))\r\n        return null;\r\n    let comments = ranges.map((r, i) => findBlockComment(state, tokens[i], r.from, r.to));\r\n    if (option != 2 /* CommentOption.Uncomment */ && !comments.every(c => c)) {\r\n        return { changes: state.changes(ranges.map((range, i) => {\r\n                if (comments[i])\r\n                    return [];\r\n                return [{ from: range.from, insert: tokens[i].open + \" \" }, { from: range.to, insert: \" \" + tokens[i].close }];\r\n            })) };\r\n    }\r\n    else if (option != 1 /* CommentOption.Comment */ && comments.some(c => c)) {\r\n        let changes = [];\r\n        for (let i = 0, comment; i < comments.length; i++)\r\n            if (comment = comments[i]) {\r\n                let token = tokens[i], { open, close } = comment;\r\n                changes.push({ from: open.pos - token.open.length, to: open.pos + open.margin }, { from: close.pos - close.margin, to: close.pos + token.close.length });\r\n            }\r\n        return { changes };\r\n    }\r\n    return null;\r\n}\r\n// Performs toggle, comment and uncomment of line comments.\r\nfunction changeLineComment(option, state, ranges = state.selection.ranges) {\r\n    let lines = [];\r\n    let prevLine = -1;\r\n    for (let { from, to } of ranges) {\r\n        let startI = lines.length, minIndent = 1e9;\r\n        for (let pos = from; pos <= to;) {\r\n            let line = state.doc.lineAt(pos);\r\n            if (line.from > prevLine && (from == to || to > line.from)) {\r\n                prevLine = line.from;\r\n                let token = getConfig(state, pos).line;\r\n                if (!token)\r\n                    continue;\r\n                let indent = /^\\s*/.exec(line.text)[0].length;\r\n                let empty = indent == line.length;\r\n                let comment = line.text.slice(indent, indent + token.length) == token ? indent : -1;\r\n                if (indent < line.text.length && indent < minIndent)\r\n                    minIndent = indent;\r\n                lines.push({ line, comment, token, indent, empty, single: false });\r\n            }\r\n            pos = line.to + 1;\r\n        }\r\n        if (minIndent < 1e9)\r\n            for (let i = startI; i < lines.length; i++)\r\n                if (lines[i].indent < lines[i].line.text.length)\r\n                    lines[i].indent = minIndent;\r\n        if (lines.length == startI + 1)\r\n            lines[startI].single = true;\r\n    }\r\n    if (option != 2 /* CommentOption.Uncomment */ && lines.some(l => l.comment < 0 && (!l.empty || l.single))) {\r\n        let changes = [];\r\n        for (let { line, token, indent, empty, single } of lines)\r\n            if (single || !empty)\r\n                changes.push({ from: line.from + indent, insert: token + \" \" });\r\n        let changeSet = state.changes(changes);\r\n        return { changes: changeSet, selection: state.selection.map(changeSet, 1) };\r\n    }\r\n    else if (option != 1 /* CommentOption.Comment */ && lines.some(l => l.comment >= 0)) {\r\n        let changes = [];\r\n        for (let { line, comment, token } of lines)\r\n            if (comment >= 0) {\r\n                let from = line.from + comment, to = from + token.length;\r\n                if (line.text[to - line.from] == \" \")\r\n                    to++;\r\n                changes.push({ from, to });\r\n            }\r\n        return { changes };\r\n    }\r\n    return null;\r\n}\r\n\r\nconst fromHistory = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.Annotation.define();\r\n/**\r\nTransaction annotation that will prevent that transaction from\r\nbeing combined with other transactions in the undo history. Given\r\n`\"before\"`, it'll prevent merging with previous transactions. With\r\n`\"after\"`, subsequent transactions won't be combined with this\r\none. With `\"full\"`, the transaction is isolated on both sides.\r\n*/\r\nconst isolateHistory = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.Annotation.define();\r\n/**\r\nThis facet provides a way to register functions that, given a\r\ntransaction, provide a set of effects that the history should\r\nstore when inverting the transaction. This can be used to\r\nintegrate some kinds of effects in the history, so that they can\r\nbe undone (and redone again).\r\n*/\r\nconst invertedEffects = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.Facet.define();\r\nconst historyConfig = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.Facet.define({\r\n    combine(configs) {\r\n        return (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.combineConfig)(configs, {\r\n            minDepth: 100,\r\n            newGroupDelay: 500\r\n        }, { minDepth: Math.max, newGroupDelay: Math.min });\r\n    }\r\n});\r\nfunction changeEnd(changes) {\r\n    let end = 0;\r\n    changes.iterChangedRanges((_, to) => end = to);\r\n    return end;\r\n}\r\nconst historyField_ = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.StateField.define({\r\n    create() {\r\n        return HistoryState.empty;\r\n    },\r\n    update(state, tr) {\r\n        let config = tr.state.facet(historyConfig);\r\n        let fromHist = tr.annotation(fromHistory);\r\n        if (fromHist) {\r\n            let selection = tr.docChanged ? _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.single(changeEnd(tr.changes)) : undefined;\r\n            let item = HistEvent.fromTransaction(tr, selection), from = fromHist.side;\r\n            let other = from == 0 /* BranchName.Done */ ? state.undone : state.done;\r\n            if (item)\r\n                other = updateBranch(other, other.length, config.minDepth, item);\r\n            else\r\n                other = addSelection(other, tr.startState.selection);\r\n            return new HistoryState(from == 0 /* BranchName.Done */ ? fromHist.rest : other, from == 0 /* BranchName.Done */ ? other : fromHist.rest);\r\n        }\r\n        let isolate = tr.annotation(isolateHistory);\r\n        if (isolate == \"full\" || isolate == \"before\")\r\n            state = state.isolate();\r\n        if (tr.annotation(_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.Transaction.addToHistory) === false)\r\n            return !tr.changes.empty ? state.addMapping(tr.changes.desc) : state;\r\n        let event = HistEvent.fromTransaction(tr);\r\n        let time = tr.annotation(_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.Transaction.time), userEvent = tr.annotation(_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.Transaction.userEvent);\r\n        if (event)\r\n            state = state.addChanges(event, time, userEvent, config.newGroupDelay, config.minDepth);\r\n        else if (tr.selection)\r\n            state = state.addSelection(tr.startState.selection, time, userEvent, config.newGroupDelay);\r\n        if (isolate == \"full\" || isolate == \"after\")\r\n            state = state.isolate();\r\n        return state;\r\n    },\r\n    toJSON(value) {\r\n        return { done: value.done.map(e => e.toJSON()), undone: value.undone.map(e => e.toJSON()) };\r\n    },\r\n    fromJSON(json) {\r\n        return new HistoryState(json.done.map(HistEvent.fromJSON), json.undone.map(HistEvent.fromJSON));\r\n    }\r\n});\r\n/**\r\nCreate a history extension with the given configuration.\r\n*/\r\nfunction history(config = {}) {\r\n    return [\r\n        historyField_,\r\n        historyConfig.of(config),\r\n        _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.EditorView.domEventHandlers({\r\n            beforeinput(e, view) {\r\n                let command = e.inputType == \"historyUndo\" ? undo : e.inputType == \"historyRedo\" ? redo : null;\r\n                if (!command)\r\n                    return false;\r\n                e.preventDefault();\r\n                return command(view);\r\n            }\r\n        })\r\n    ];\r\n}\r\n/**\r\nThe state field used to store the history data. Should probably\r\nonly be used when you want to\r\n[serialize](https://codemirror.net/6/docs/ref/#state.EditorState.toJSON) or\r\n[deserialize](https://codemirror.net/6/docs/ref/#state.EditorState^fromJSON) state objects in a way\r\nthat preserves history.\r\n*/\r\nconst historyField = historyField_;\r\nfunction cmd(side, selection) {\r\n    return function ({ state, dispatch }) {\r\n        if (!selection && state.readOnly)\r\n            return false;\r\n        let historyState = state.field(historyField_, false);\r\n        if (!historyState)\r\n            return false;\r\n        let tr = historyState.pop(side, state, selection);\r\n        if (!tr)\r\n            return false;\r\n        dispatch(tr);\r\n        return true;\r\n    };\r\n}\r\n/**\r\nUndo a single group of history events. Returns false if no group\r\nwas available.\r\n*/\r\nconst undo = /*@__PURE__*/cmd(0 /* BranchName.Done */, false);\r\n/**\r\nRedo a group of history events. Returns false if no group was\r\navailable.\r\n*/\r\nconst redo = /*@__PURE__*/cmd(1 /* BranchName.Undone */, false);\r\n/**\r\nUndo a change or selection change.\r\n*/\r\nconst undoSelection = /*@__PURE__*/cmd(0 /* BranchName.Done */, true);\r\n/**\r\nRedo a change or selection change.\r\n*/\r\nconst redoSelection = /*@__PURE__*/cmd(1 /* BranchName.Undone */, true);\r\nfunction depth(side) {\r\n    return function (state) {\r\n        let histState = state.field(historyField_, false);\r\n        if (!histState)\r\n            return 0;\r\n        let branch = side == 0 /* BranchName.Done */ ? histState.done : histState.undone;\r\n        return branch.length - (branch.length && !branch[0].changes ? 1 : 0);\r\n    };\r\n}\r\n/**\r\nThe amount of undoable change events available in a given state.\r\n*/\r\nconst undoDepth = /*@__PURE__*/depth(0 /* BranchName.Done */);\r\n/**\r\nThe amount of redoable change events available in a given state.\r\n*/\r\nconst redoDepth = /*@__PURE__*/depth(1 /* BranchName.Undone */);\r\n// History events store groups of changes or effects that need to be\r\n// undone/redone together.\r\nclass HistEvent {\r\n    constructor(\r\n    // The changes in this event. Normal events hold at least one\r\n    // change or effect. But it may be necessary to store selection\r\n    // events before the first change, in which case a special type of\r\n    // instance is created which doesn't hold any changes, with\r\n    // changes == startSelection == undefined\r\n    changes, \r\n    // The effects associated with this event\r\n    effects, \r\n    // Accumulated mapping (from addToHistory==false) that should be\r\n    // applied to events below this one.\r\n    mapped, \r\n    // The selection before this event\r\n    startSelection, \r\n    // Stores selection changes after this event, to be used for\r\n    // selection undo/redo.\r\n    selectionsAfter) {\r\n        this.changes = changes;\r\n        this.effects = effects;\r\n        this.mapped = mapped;\r\n        this.startSelection = startSelection;\r\n        this.selectionsAfter = selectionsAfter;\r\n    }\r\n    setSelAfter(after) {\r\n        return new HistEvent(this.changes, this.effects, this.mapped, this.startSelection, after);\r\n    }\r\n    toJSON() {\r\n        var _a, _b, _c;\r\n        return {\r\n            changes: (_a = this.changes) === null || _a === void 0 ? void 0 : _a.toJSON(),\r\n            mapped: (_b = this.mapped) === null || _b === void 0 ? void 0 : _b.toJSON(),\r\n            startSelection: (_c = this.startSelection) === null || _c === void 0 ? void 0 : _c.toJSON(),\r\n            selectionsAfter: this.selectionsAfter.map(s => s.toJSON())\r\n        };\r\n    }\r\n    static fromJSON(json) {\r\n        return new HistEvent(json.changes && _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.ChangeSet.fromJSON(json.changes), [], json.mapped && _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.ChangeDesc.fromJSON(json.mapped), json.startSelection && _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.fromJSON(json.startSelection), json.selectionsAfter.map(_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.fromJSON));\r\n    }\r\n    // This does not check `addToHistory` and such, it assumes the\r\n    // transaction needs to be converted to an item. Returns null when\r\n    // there are no changes or effects in the transaction.\r\n    static fromTransaction(tr, selection) {\r\n        let effects = none;\r\n        for (let invert of tr.startState.facet(invertedEffects)) {\r\n            let result = invert(tr);\r\n            if (result.length)\r\n                effects = effects.concat(result);\r\n        }\r\n        if (!effects.length && tr.changes.empty)\r\n            return null;\r\n        return new HistEvent(tr.changes.invert(tr.startState.doc), effects, undefined, selection || tr.startState.selection, none);\r\n    }\r\n    static selection(selections) {\r\n        return new HistEvent(undefined, none, undefined, undefined, selections);\r\n    }\r\n}\r\nfunction updateBranch(branch, to, maxLen, newEvent) {\r\n    let start = to + 1 > maxLen + 20 ? to - maxLen - 1 : 0;\r\n    let newBranch = branch.slice(start, to);\r\n    newBranch.push(newEvent);\r\n    return newBranch;\r\n}\r\nfunction isAdjacent(a, b) {\r\n    let ranges = [], isAdjacent = false;\r\n    a.iterChangedRanges((f, t) => ranges.push(f, t));\r\n    b.iterChangedRanges((_f, _t, f, t) => {\r\n        for (let i = 0; i < ranges.length;) {\r\n            let from = ranges[i++], to = ranges[i++];\r\n            if (t >= from && f <= to)\r\n                isAdjacent = true;\r\n        }\r\n    });\r\n    return isAdjacent;\r\n}\r\nfunction eqSelectionShape(a, b) {\r\n    return a.ranges.length == b.ranges.length &&\r\n        a.ranges.filter((r, i) => r.empty != b.ranges[i].empty).length === 0;\r\n}\r\nfunction conc(a, b) {\r\n    return !a.length ? b : !b.length ? a : a.concat(b);\r\n}\r\nconst none = [];\r\nconst MaxSelectionsPerEvent = 200;\r\nfunction addSelection(branch, selection) {\r\n    if (!branch.length) {\r\n        return [HistEvent.selection([selection])];\r\n    }\r\n    else {\r\n        let lastEvent = branch[branch.length - 1];\r\n        let sels = lastEvent.selectionsAfter.slice(Math.max(0, lastEvent.selectionsAfter.length - MaxSelectionsPerEvent));\r\n        if (sels.length && sels[sels.length - 1].eq(selection))\r\n            return branch;\r\n        sels.push(selection);\r\n        return updateBranch(branch, branch.length - 1, 1e9, lastEvent.setSelAfter(sels));\r\n    }\r\n}\r\n// Assumes the top item has one or more selectionAfter values\r\nfunction popSelection(branch) {\r\n    let last = branch[branch.length - 1];\r\n    let newBranch = branch.slice();\r\n    newBranch[branch.length - 1] = last.setSelAfter(last.selectionsAfter.slice(0, last.selectionsAfter.length - 1));\r\n    return newBranch;\r\n}\r\n// Add a mapping to the top event in the given branch. If this maps\r\n// away all the changes and effects in that item, drop it and\r\n// propagate the mapping to the next item.\r\nfunction addMappingToBranch(branch, mapping) {\r\n    if (!branch.length)\r\n        return branch;\r\n    let length = branch.length, selections = none;\r\n    while (length) {\r\n        let event = mapEvent(branch[length - 1], mapping, selections);\r\n        if (event.changes && !event.changes.empty || event.effects.length) { // Event survived mapping\r\n            let result = branch.slice(0, length);\r\n            result[length - 1] = event;\r\n            return result;\r\n        }\r\n        else { // Drop this event, since there's no changes or effects left\r\n            mapping = event.mapped;\r\n            length--;\r\n            selections = event.selectionsAfter;\r\n        }\r\n    }\r\n    return selections.length ? [HistEvent.selection(selections)] : none;\r\n}\r\nfunction mapEvent(event, mapping, extraSelections) {\r\n    let selections = conc(event.selectionsAfter.length ? event.selectionsAfter.map(s => s.map(mapping)) : none, extraSelections);\r\n    // Change-less events don't store mappings (they are always the last event in a branch)\r\n    if (!event.changes)\r\n        return HistEvent.selection(selections);\r\n    let mappedChanges = event.changes.map(mapping), before = mapping.mapDesc(event.changes, true);\r\n    let fullMapping = event.mapped ? event.mapped.composeDesc(before) : before;\r\n    return new HistEvent(mappedChanges, _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.StateEffect.mapEffects(event.effects, mapping), fullMapping, event.startSelection.map(before), selections);\r\n}\r\nconst joinableUserEvent = /^(input\\.type|delete)($|\\.)/;\r\nclass HistoryState {\r\n    constructor(done, undone, prevTime = 0, prevUserEvent = undefined) {\r\n        this.done = done;\r\n        this.undone = undone;\r\n        this.prevTime = prevTime;\r\n        this.prevUserEvent = prevUserEvent;\r\n    }\r\n    isolate() {\r\n        return this.prevTime ? new HistoryState(this.done, this.undone) : this;\r\n    }\r\n    addChanges(event, time, userEvent, newGroupDelay, maxLen) {\r\n        let done = this.done, lastEvent = done[done.length - 1];\r\n        if (lastEvent && lastEvent.changes && !lastEvent.changes.empty && event.changes &&\r\n            (!userEvent || joinableUserEvent.test(userEvent)) &&\r\n            ((!lastEvent.selectionsAfter.length &&\r\n                time - this.prevTime < newGroupDelay &&\r\n                isAdjacent(lastEvent.changes, event.changes)) ||\r\n                // For compose (but not compose.start) events, always join with previous event\r\n                userEvent == \"input.type.compose\")) {\r\n            done = updateBranch(done, done.length - 1, maxLen, new HistEvent(event.changes.compose(lastEvent.changes), conc(event.effects, lastEvent.effects), lastEvent.mapped, lastEvent.startSelection, none));\r\n        }\r\n        else {\r\n            done = updateBranch(done, done.length, maxLen, event);\r\n        }\r\n        return new HistoryState(done, none, time, userEvent);\r\n    }\r\n    addSelection(selection, time, userEvent, newGroupDelay) {\r\n        let last = this.done.length ? this.done[this.done.length - 1].selectionsAfter : none;\r\n        if (last.length > 0 &&\r\n            time - this.prevTime < newGroupDelay &&\r\n            userEvent == this.prevUserEvent && userEvent && /^select($|\\.)/.test(userEvent) &&\r\n            eqSelectionShape(last[last.length - 1], selection))\r\n            return this;\r\n        return new HistoryState(addSelection(this.done, selection), this.undone, time, userEvent);\r\n    }\r\n    addMapping(mapping) {\r\n        return new HistoryState(addMappingToBranch(this.done, mapping), addMappingToBranch(this.undone, mapping), this.prevTime, this.prevUserEvent);\r\n    }\r\n    pop(side, state, selection) {\r\n        let branch = side == 0 /* BranchName.Done */ ? this.done : this.undone;\r\n        if (branch.length == 0)\r\n            return null;\r\n        let event = branch[branch.length - 1];\r\n        if (selection && event.selectionsAfter.length) {\r\n            return state.update({\r\n                selection: event.selectionsAfter[event.selectionsAfter.length - 1],\r\n                annotations: fromHistory.of({ side, rest: popSelection(branch) }),\r\n                userEvent: side == 0 /* BranchName.Done */ ? \"select.undo\" : \"select.redo\",\r\n                scrollIntoView: true\r\n            });\r\n        }\r\n        else if (!event.changes) {\r\n            return null;\r\n        }\r\n        else {\r\n            let rest = branch.length == 1 ? none : branch.slice(0, branch.length - 1);\r\n            if (event.mapped)\r\n                rest = addMappingToBranch(rest, event.mapped);\r\n            return state.update({\r\n                changes: event.changes,\r\n                selection: event.startSelection,\r\n                effects: event.effects,\r\n                annotations: fromHistory.of({ side, rest }),\r\n                filter: false,\r\n                userEvent: side == 0 /* BranchName.Done */ ? \"undo\" : \"redo\",\r\n                scrollIntoView: true\r\n            });\r\n        }\r\n    }\r\n}\r\nHistoryState.empty = /*@__PURE__*/new HistoryState(none, none);\r\n/**\r\nDefault key bindings for the undo history.\r\n\r\n- Mod-z: [`undo`](https://codemirror.net/6/docs/ref/#commands.undo).\r\n- Mod-y (Mod-Shift-z on macOS) + Ctrl-Shift-z on Linux: [`redo`](https://codemirror.net/6/docs/ref/#commands.redo).\r\n- Mod-u: [`undoSelection`](https://codemirror.net/6/docs/ref/#commands.undoSelection).\r\n- Alt-u (Mod-Shift-u on macOS): [`redoSelection`](https://codemirror.net/6/docs/ref/#commands.redoSelection).\r\n*/\r\nconst historyKeymap = [\r\n    { key: \"Mod-z\", run: undo, preventDefault: true },\r\n    { key: \"Mod-y\", mac: \"Mod-Shift-z\", run: redo, preventDefault: true },\r\n    { linux: \"Ctrl-Shift-z\", run: redo, preventDefault: true },\r\n    { key: \"Mod-u\", run: undoSelection, preventDefault: true },\r\n    { key: \"Alt-u\", mac: \"Mod-Shift-u\", run: redoSelection, preventDefault: true }\r\n];\r\n\r\nfunction updateSel(sel, by) {\r\n    return _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.create(sel.ranges.map(by), sel.mainIndex);\r\n}\r\nfunction setSel(state, selection) {\r\n    return state.update({ selection, scrollIntoView: true, userEvent: \"select\" });\r\n}\r\nfunction moveSel({ state, dispatch }, how) {\r\n    let selection = updateSel(state.selection, how);\r\n    if (selection.eq(state.selection))\r\n        return false;\r\n    dispatch(setSel(state, selection));\r\n    return true;\r\n}\r\nfunction rangeEnd(range, forward) {\r\n    return _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.cursor(forward ? range.to : range.from);\r\n}\r\nfunction cursorByChar(view, forward) {\r\n    return moveSel(view, range => range.empty ? view.moveByChar(range, forward) : rangeEnd(range, forward));\r\n}\r\nfunction ltrAtCursor(view) {\r\n    return view.textDirectionAt(view.state.selection.main.head) == _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.Direction.LTR;\r\n}\r\n/**\r\nMove the selection one character to the left (which is backward in\r\nleft-to-right text, forward in right-to-left text).\r\n*/\r\nconst cursorCharLeft = view => cursorByChar(view, !ltrAtCursor(view));\r\n/**\r\nMove the selection one character to the right.\r\n*/\r\nconst cursorCharRight = view => cursorByChar(view, ltrAtCursor(view));\r\n/**\r\nMove the selection one character forward.\r\n*/\r\nconst cursorCharForward = view => cursorByChar(view, true);\r\n/**\r\nMove the selection one character backward.\r\n*/\r\nconst cursorCharBackward = view => cursorByChar(view, false);\r\nfunction cursorByGroup(view, forward) {\r\n    return moveSel(view, range => range.empty ? view.moveByGroup(range, forward) : rangeEnd(range, forward));\r\n}\r\n/**\r\nMove the selection to the left across one group of word or\r\nnon-word (but also non-space) characters.\r\n*/\r\nconst cursorGroupLeft = view => cursorByGroup(view, !ltrAtCursor(view));\r\n/**\r\nMove the selection one group to the right.\r\n*/\r\nconst cursorGroupRight = view => cursorByGroup(view, ltrAtCursor(view));\r\n/**\r\nMove the selection one group forward.\r\n*/\r\nconst cursorGroupForward = view => cursorByGroup(view, true);\r\n/**\r\nMove the selection one group backward.\r\n*/\r\nconst cursorGroupBackward = view => cursorByGroup(view, false);\r\nfunction moveBySubword(view, range, forward) {\r\n    let categorize = view.state.charCategorizer(range.from);\r\n    return view.moveByChar(range, forward, start => {\r\n        let cat = _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.CharCategory.Space, pos = range.from;\r\n        let done = false, sawUpper = false, sawLower = false;\r\n        let step = (next) => {\r\n            if (done)\r\n                return false;\r\n            pos += forward ? next.length : -next.length;\r\n            let nextCat = categorize(next), ahead;\r\n            if (cat == _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.CharCategory.Space)\r\n                cat = nextCat;\r\n            if (cat != nextCat)\r\n                return false;\r\n            if (cat == _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.CharCategory.Word) {\r\n                if (next.toLowerCase() == next) {\r\n                    if (!forward && sawUpper)\r\n                        return false;\r\n                    sawLower = true;\r\n                }\r\n                else if (sawLower) {\r\n                    if (forward)\r\n                        return false;\r\n                    done = true;\r\n                }\r\n                else {\r\n                    if (sawUpper && forward && categorize(ahead = view.state.sliceDoc(pos, pos + 1)) == _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.CharCategory.Word &&\r\n                        ahead.toLowerCase() == ahead)\r\n                        return false;\r\n                    sawUpper = true;\r\n                }\r\n            }\r\n            return true;\r\n        };\r\n        step(start);\r\n        return step;\r\n    });\r\n}\r\nfunction cursorBySubword(view, forward) {\r\n    return moveSel(view, range => range.empty ? moveBySubword(view, range, forward) : rangeEnd(range, forward));\r\n}\r\n/**\r\nMove the selection one group or camel-case subword forward.\r\n*/\r\nconst cursorSubwordForward = view => cursorBySubword(view, true);\r\n/**\r\nMove the selection one group or camel-case subword backward.\r\n*/\r\nconst cursorSubwordBackward = view => cursorBySubword(view, false);\r\nfunction interestingNode(state, node, bracketProp) {\r\n    if (node.type.prop(bracketProp))\r\n        return true;\r\n    let len = node.to - node.from;\r\n    return len && (len > 2 || /[^\\s,.;:]/.test(state.sliceDoc(node.from, node.to))) || node.firstChild;\r\n}\r\nfunction moveBySyntax(state, start, forward) {\r\n    let pos = (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.syntaxTree)(state).resolveInner(start.head);\r\n    let bracketProp = forward ? _lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeProp.closedBy : _lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeProp.openedBy;\r\n    // Scan forward through child nodes to see if there's an interesting\r\n    // node ahead.\r\n    for (let at = start.head;;) {\r\n        let next = forward ? pos.childAfter(at) : pos.childBefore(at);\r\n        if (!next)\r\n            break;\r\n        if (interestingNode(state, next, bracketProp))\r\n            pos = next;\r\n        else\r\n            at = forward ? next.to : next.from;\r\n    }\r\n    let bracket = pos.type.prop(bracketProp), match, newPos;\r\n    if (bracket && (match = forward ? (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.matchBrackets)(state, pos.from, 1) : (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.matchBrackets)(state, pos.to, -1)) && match.matched)\r\n        newPos = forward ? match.end.to : match.end.from;\r\n    else\r\n        newPos = forward ? pos.to : pos.from;\r\n    return _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.cursor(newPos, forward ? -1 : 1);\r\n}\r\n/**\r\nMove the cursor over the next syntactic element to the left.\r\n*/\r\nconst cursorSyntaxLeft = view => moveSel(view, range => moveBySyntax(view.state, range, !ltrAtCursor(view)));\r\n/**\r\nMove the cursor over the next syntactic element to the right.\r\n*/\r\nconst cursorSyntaxRight = view => moveSel(view, range => moveBySyntax(view.state, range, ltrAtCursor(view)));\r\nfunction cursorByLine(view, forward) {\r\n    return moveSel(view, range => {\r\n        if (!range.empty)\r\n            return rangeEnd(range, forward);\r\n        let moved = view.moveVertically(range, forward);\r\n        return moved.head != range.head ? moved : view.moveToLineBoundary(range, forward);\r\n    });\r\n}\r\n/**\r\nMove the selection one line up.\r\n*/\r\nconst cursorLineUp = view => cursorByLine(view, false);\r\n/**\r\nMove the selection one line down.\r\n*/\r\nconst cursorLineDown = view => cursorByLine(view, true);\r\nfunction pageHeight(view) {\r\n    return Math.max(view.defaultLineHeight, Math.min(view.dom.clientHeight, innerHeight) - 5);\r\n}\r\nfunction cursorByPage(view, forward) {\r\n    let { state } = view, selection = updateSel(state.selection, range => {\r\n        return range.empty ? view.moveVertically(range, forward, pageHeight(view)) : rangeEnd(range, forward);\r\n    });\r\n    if (selection.eq(state.selection))\r\n        return false;\r\n    let startPos = view.coordsAtPos(state.selection.main.head);\r\n    let scrollRect = view.scrollDOM.getBoundingClientRect();\r\n    let effect;\r\n    if (startPos && startPos.top > scrollRect.top && startPos.bottom < scrollRect.bottom &&\r\n        startPos.top - scrollRect.top <= view.scrollDOM.scrollHeight - view.scrollDOM.scrollTop - view.scrollDOM.clientHeight)\r\n        effect = _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.EditorView.scrollIntoView(selection.main.head, { y: \"start\", yMargin: startPos.top - scrollRect.top });\r\n    view.dispatch(setSel(state, selection), { effects: effect });\r\n    return true;\r\n}\r\n/**\r\nMove the selection one page up.\r\n*/\r\nconst cursorPageUp = view => cursorByPage(view, false);\r\n/**\r\nMove the selection one page down.\r\n*/\r\nconst cursorPageDown = view => cursorByPage(view, true);\r\nfunction moveByLineBoundary(view, start, forward) {\r\n    let line = view.lineBlockAt(start.head), moved = view.moveToLineBoundary(start, forward);\r\n    if (moved.head == start.head && moved.head != (forward ? line.to : line.from))\r\n        moved = view.moveToLineBoundary(start, forward, false);\r\n    if (!forward && moved.head == line.from && line.length) {\r\n        let space = /^\\s*/.exec(view.state.sliceDoc(line.from, Math.min(line.from + 100, line.to)))[0].length;\r\n        if (space && start.head != line.from + space)\r\n            moved = _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.cursor(line.from + space);\r\n    }\r\n    return moved;\r\n}\r\n/**\r\nMove the selection to the next line wrap point, or to the end of\r\nthe line if there isn't one left on this line.\r\n*/\r\nconst cursorLineBoundaryForward = view => moveSel(view, range => moveByLineBoundary(view, range, true));\r\n/**\r\nMove the selection to previous line wrap point, or failing that to\r\nthe start of the line. If the line is indented, and the cursor\r\nisn't already at the end of the indentation, this will move to the\r\nend of the indentation instead of the start of the line.\r\n*/\r\nconst cursorLineBoundaryBackward = view => moveSel(view, range => moveByLineBoundary(view, range, false));\r\n/**\r\nMove the selection one line wrap point to the left.\r\n*/\r\nconst cursorLineBoundaryLeft = view => moveSel(view, range => moveByLineBoundary(view, range, !ltrAtCursor(view)));\r\n/**\r\nMove the selection one line wrap point to the right.\r\n*/\r\nconst cursorLineBoundaryRight = view => moveSel(view, range => moveByLineBoundary(view, range, ltrAtCursor(view)));\r\n/**\r\nMove the selection to the start of the line.\r\n*/\r\nconst cursorLineStart = view => moveSel(view, range => _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.cursor(view.lineBlockAt(range.head).from, 1));\r\n/**\r\nMove the selection to the end of the line.\r\n*/\r\nconst cursorLineEnd = view => moveSel(view, range => _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.cursor(view.lineBlockAt(range.head).to, -1));\r\nfunction toMatchingBracket(state, dispatch, extend) {\r\n    let found = false, selection = updateSel(state.selection, range => {\r\n        let matching = (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.matchBrackets)(state, range.head, -1)\r\n            || (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.matchBrackets)(state, range.head, 1)\r\n            || (range.head > 0 && (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.matchBrackets)(state, range.head - 1, 1))\r\n            || (range.head < state.doc.length && (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.matchBrackets)(state, range.head + 1, -1));\r\n        if (!matching || !matching.end)\r\n            return range;\r\n        found = true;\r\n        let head = matching.start.from == range.head ? matching.end.to : matching.end.from;\r\n        return extend ? _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.range(range.anchor, head) : _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.cursor(head);\r\n    });\r\n    if (!found)\r\n        return false;\r\n    dispatch(setSel(state, selection));\r\n    return true;\r\n}\r\n/**\r\nMove the selection to the bracket matching the one it is currently\r\non, if any.\r\n*/\r\nconst cursorMatchingBracket = ({ state, dispatch }) => toMatchingBracket(state, dispatch, false);\r\n/**\r\nExtend the selection to the bracket matching the one the selection\r\nhead is currently on, if any.\r\n*/\r\nconst selectMatchingBracket = ({ state, dispatch }) => toMatchingBracket(state, dispatch, true);\r\nfunction extendSel(view, how) {\r\n    let selection = updateSel(view.state.selection, range => {\r\n        let head = how(range);\r\n        return _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.range(range.anchor, head.head, head.goalColumn, head.bidiLevel || undefined);\r\n    });\r\n    if (selection.eq(view.state.selection))\r\n        return false;\r\n    view.dispatch(setSel(view.state, selection));\r\n    return true;\r\n}\r\nfunction selectByChar(view, forward) {\r\n    return extendSel(view, range => view.moveByChar(range, forward));\r\n}\r\n/**\r\nMove the selection head one character to the left, while leaving\r\nthe anchor in place.\r\n*/\r\nconst selectCharLeft = view => selectByChar(view, !ltrAtCursor(view));\r\n/**\r\nMove the selection head one character to the right.\r\n*/\r\nconst selectCharRight = view => selectByChar(view, ltrAtCursor(view));\r\n/**\r\nMove the selection head one character forward.\r\n*/\r\nconst selectCharForward = view => selectByChar(view, true);\r\n/**\r\nMove the selection head one character backward.\r\n*/\r\nconst selectCharBackward = view => selectByChar(view, false);\r\nfunction selectByGroup(view, forward) {\r\n    return extendSel(view, range => view.moveByGroup(range, forward));\r\n}\r\n/**\r\nMove the selection head one [group](https://codemirror.net/6/docs/ref/#commands.cursorGroupLeft) to\r\nthe left.\r\n*/\r\nconst selectGroupLeft = view => selectByGroup(view, !ltrAtCursor(view));\r\n/**\r\nMove the selection head one group to the right.\r\n*/\r\nconst selectGroupRight = view => selectByGroup(view, ltrAtCursor(view));\r\n/**\r\nMove the selection head one group forward.\r\n*/\r\nconst selectGroupForward = view => selectByGroup(view, true);\r\n/**\r\nMove the selection head one group backward.\r\n*/\r\nconst selectGroupBackward = view => selectByGroup(view, false);\r\nfunction selectBySubword(view, forward) {\r\n    return extendSel(view, range => moveBySubword(view, range, forward));\r\n}\r\n/**\r\nMove the selection head one group or camel-case subword forward.\r\n*/\r\nconst selectSubwordForward = view => selectBySubword(view, true);\r\n/**\r\nMove the selection head one group or subword backward.\r\n*/\r\nconst selectSubwordBackward = view => selectBySubword(view, false);\r\n/**\r\nMove the selection head over the next syntactic element to the left.\r\n*/\r\nconst selectSyntaxLeft = view => extendSel(view, range => moveBySyntax(view.state, range, !ltrAtCursor(view)));\r\n/**\r\nMove the selection head over the next syntactic element to the right.\r\n*/\r\nconst selectSyntaxRight = view => extendSel(view, range => moveBySyntax(view.state, range, ltrAtCursor(view)));\r\nfunction selectByLine(view, forward) {\r\n    return extendSel(view, range => view.moveVertically(range, forward));\r\n}\r\n/**\r\nMove the selection head one line up.\r\n*/\r\nconst selectLineUp = view => selectByLine(view, false);\r\n/**\r\nMove the selection head one line down.\r\n*/\r\nconst selectLineDown = view => selectByLine(view, true);\r\nfunction selectByPage(view, forward) {\r\n    return extendSel(view, range => view.moveVertically(range, forward, pageHeight(view)));\r\n}\r\n/**\r\nMove the selection head one page up.\r\n*/\r\nconst selectPageUp = view => selectByPage(view, false);\r\n/**\r\nMove the selection head one page down.\r\n*/\r\nconst selectPageDown = view => selectByPage(view, true);\r\n/**\r\nMove the selection head to the next line boundary.\r\n*/\r\nconst selectLineBoundaryForward = view => extendSel(view, range => moveByLineBoundary(view, range, true));\r\n/**\r\nMove the selection head to the previous line boundary.\r\n*/\r\nconst selectLineBoundaryBackward = view => extendSel(view, range => moveByLineBoundary(view, range, false));\r\n/**\r\nMove the selection head one line boundary to the left.\r\n*/\r\nconst selectLineBoundaryLeft = view => extendSel(view, range => moveByLineBoundary(view, range, !ltrAtCursor(view)));\r\n/**\r\nMove the selection head one line boundary to the right.\r\n*/\r\nconst selectLineBoundaryRight = view => extendSel(view, range => moveByLineBoundary(view, range, ltrAtCursor(view)));\r\n/**\r\nMove the selection head to the start of the line.\r\n*/\r\nconst selectLineStart = view => extendSel(view, range => _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.cursor(view.lineBlockAt(range.head).from));\r\n/**\r\nMove the selection head to the end of the line.\r\n*/\r\nconst selectLineEnd = view => extendSel(view, range => _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.cursor(view.lineBlockAt(range.head).to));\r\n/**\r\nMove the selection to the start of the document.\r\n*/\r\nconst cursorDocStart = ({ state, dispatch }) => {\r\n    dispatch(setSel(state, { anchor: 0 }));\r\n    return true;\r\n};\r\n/**\r\nMove the selection to the end of the document.\r\n*/\r\nconst cursorDocEnd = ({ state, dispatch }) => {\r\n    dispatch(setSel(state, { anchor: state.doc.length }));\r\n    return true;\r\n};\r\n/**\r\nMove the selection head to the start of the document.\r\n*/\r\nconst selectDocStart = ({ state, dispatch }) => {\r\n    dispatch(setSel(state, { anchor: state.selection.main.anchor, head: 0 }));\r\n    return true;\r\n};\r\n/**\r\nMove the selection head to the end of the document.\r\n*/\r\nconst selectDocEnd = ({ state, dispatch }) => {\r\n    dispatch(setSel(state, { anchor: state.selection.main.anchor, head: state.doc.length }));\r\n    return true;\r\n};\r\n/**\r\nSelect the entire document.\r\n*/\r\nconst selectAll = ({ state, dispatch }) => {\r\n    dispatch(state.update({ selection: { anchor: 0, head: state.doc.length }, userEvent: \"select\" }));\r\n    return true;\r\n};\r\n/**\r\nExpand the selection to cover entire lines.\r\n*/\r\nconst selectLine = ({ state, dispatch }) => {\r\n    let ranges = selectedLineBlocks(state).map(({ from, to }) => _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.range(from, Math.min(to + 1, state.doc.length)));\r\n    dispatch(state.update({ selection: _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.create(ranges), userEvent: \"select\" }));\r\n    return true;\r\n};\r\n/**\r\nSelect the next syntactic construct that is larger than the\r\nselection. Note that this will only work insofar as the language\r\n[provider](https://codemirror.net/6/docs/ref/#language.language) you use builds up a full\r\nsyntax tree.\r\n*/\r\nconst selectParentSyntax = ({ state, dispatch }) => {\r\n    let selection = updateSel(state.selection, range => {\r\n        var _a;\r\n        let context = (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.syntaxTree)(state).resolveInner(range.head, 1);\r\n        while (!((context.from < range.from && context.to >= range.to) ||\r\n            (context.to > range.to && context.from <= range.from) ||\r\n            !((_a = context.parent) === null || _a === void 0 ? void 0 : _a.parent)))\r\n            context = context.parent;\r\n        return _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.range(context.to, context.from);\r\n    });\r\n    dispatch(setSel(state, selection));\r\n    return true;\r\n};\r\n/**\r\nSimplify the current selection. When multiple ranges are selected,\r\nreduce it to its main range. Otherwise, if the selection is\r\nnon-empty, convert it to a cursor selection.\r\n*/\r\nconst simplifySelection = ({ state, dispatch }) => {\r\n    let cur = state.selection, selection = null;\r\n    if (cur.ranges.length > 1)\r\n        selection = _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.create([cur.main]);\r\n    else if (!cur.main.empty)\r\n        selection = _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.create([_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.cursor(cur.main.head)]);\r\n    if (!selection)\r\n        return false;\r\n    dispatch(setSel(state, selection));\r\n    return true;\r\n};\r\nfunction deleteBy(target, by) {\r\n    if (target.state.readOnly)\r\n        return false;\r\n    let event = \"delete.selection\", { state } = target;\r\n    let changes = state.changeByRange(range => {\r\n        let { from, to } = range;\r\n        if (from == to) {\r\n            let towards = by(from);\r\n            if (towards < from) {\r\n                event = \"delete.backward\";\r\n                towards = skipAtomic(target, towards, false);\r\n            }\r\n            else if (towards > from) {\r\n                event = \"delete.forward\";\r\n                towards = skipAtomic(target, towards, true);\r\n            }\r\n            from = Math.min(from, towards);\r\n            to = Math.max(to, towards);\r\n        }\r\n        else {\r\n            from = skipAtomic(target, from, false);\r\n            to = skipAtomic(target, to, true);\r\n        }\r\n        return from == to ? { range } : { changes: { from, to }, range: _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.cursor(from) };\r\n    });\r\n    if (changes.changes.empty)\r\n        return false;\r\n    target.dispatch(state.update(changes, {\r\n        scrollIntoView: true,\r\n        userEvent: event,\r\n        effects: event == \"delete.selection\" ? _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.EditorView.announce.of(state.phrase(\"Selection deleted\")) : undefined\r\n    }));\r\n    return true;\r\n}\r\nfunction skipAtomic(target, pos, forward) {\r\n    if (target instanceof _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.EditorView)\r\n        for (let ranges of target.state.facet(_codemirror_view__WEBPACK_IMPORTED_MODULE_2__.EditorView.atomicRanges).map(f => f(target)))\r\n            ranges.between(pos, pos, (from, to) => {\r\n                if (from < pos && to > pos)\r\n                    pos = forward ? to : from;\r\n            });\r\n    return pos;\r\n}\r\nconst deleteByChar = (target, forward) => deleteBy(target, pos => {\r\n    let { state } = target, line = state.doc.lineAt(pos), before, targetPos;\r\n    if (!forward && pos > line.from && pos < line.from + 200 &&\r\n        !/[^ \\t]/.test(before = line.text.slice(0, pos - line.from))) {\r\n        if (before[before.length - 1] == \"\\t\")\r\n            return pos - 1;\r\n        let col = (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.countColumn)(before, state.tabSize), drop = col % (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.getIndentUnit)(state) || (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.getIndentUnit)(state);\r\n        for (let i = 0; i < drop && before[before.length - 1 - i] == \" \"; i++)\r\n            pos--;\r\n        targetPos = pos;\r\n    }\r\n    else {\r\n        targetPos = (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.findClusterBreak)(line.text, pos - line.from, forward, forward) + line.from;\r\n        if (targetPos == pos && line.number != (forward ? state.doc.lines : 1))\r\n            targetPos += forward ? 1 : -1;\r\n    }\r\n    return targetPos;\r\n});\r\n/**\r\nDelete the selection, or, for cursor selections, the character\r\nbefore the cursor.\r\n*/\r\nconst deleteCharBackward = view => deleteByChar(view, false);\r\n/**\r\nDelete the selection or the character after the cursor.\r\n*/\r\nconst deleteCharForward = view => deleteByChar(view, true);\r\nconst deleteByGroup = (target, forward) => deleteBy(target, start => {\r\n    let pos = start, { state } = target, line = state.doc.lineAt(pos);\r\n    let categorize = state.charCategorizer(pos);\r\n    for (let cat = null;;) {\r\n        if (pos == (forward ? line.to : line.from)) {\r\n            if (pos == start && line.number != (forward ? state.doc.lines : 1))\r\n                pos += forward ? 1 : -1;\r\n            break;\r\n        }\r\n        let next = (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.findClusterBreak)(line.text, pos - line.from, forward) + line.from;\r\n        let nextChar = line.text.slice(Math.min(pos, next) - line.from, Math.max(pos, next) - line.from);\r\n        let nextCat = categorize(nextChar);\r\n        if (cat != null && nextCat != cat)\r\n            break;\r\n        if (nextChar != \" \" || pos != start)\r\n            cat = nextCat;\r\n        pos = next;\r\n    }\r\n    return pos;\r\n});\r\n/**\r\nDelete the selection or backward until the end of the next\r\n[group](https://codemirror.net/6/docs/ref/#view.EditorView.moveByGroup), only skipping groups of\r\nwhitespace when they consist of a single space.\r\n*/\r\nconst deleteGroupBackward = target => deleteByGroup(target, false);\r\n/**\r\nDelete the selection or forward until the end of the next group.\r\n*/\r\nconst deleteGroupForward = target => deleteByGroup(target, true);\r\n/**\r\nDelete the selection, or, if it is a cursor selection, delete to\r\nthe end of the line. If the cursor is directly at the end of the\r\nline, delete the line break after it.\r\n*/\r\nconst deleteToLineEnd = view => deleteBy(view, pos => {\r\n    let lineEnd = view.lineBlockAt(pos).to;\r\n    return pos < lineEnd ? lineEnd : Math.min(view.state.doc.length, pos + 1);\r\n});\r\n/**\r\nDelete the selection, or, if it is a cursor selection, delete to\r\nthe start of the line. If the cursor is directly at the start of the\r\nline, delete the line break before it.\r\n*/\r\nconst deleteToLineStart = view => deleteBy(view, pos => {\r\n    let lineStart = view.lineBlockAt(pos).from;\r\n    return pos > lineStart ? lineStart : Math.max(0, pos - 1);\r\n});\r\n/**\r\nDelete all whitespace directly before a line end from the\r\ndocument.\r\n*/\r\nconst deleteTrailingWhitespace = ({ state, dispatch }) => {\r\n    if (state.readOnly)\r\n        return false;\r\n    let changes = [];\r\n    for (let pos = 0, prev = \"\", iter = state.doc.iter();;) {\r\n        iter.next();\r\n        if (iter.lineBreak || iter.done) {\r\n            let trailing = prev.search(/\\s+$/);\r\n            if (trailing > -1)\r\n                changes.push({ from: pos - (prev.length - trailing), to: pos });\r\n            if (iter.done)\r\n                break;\r\n            prev = \"\";\r\n        }\r\n        else {\r\n            prev = iter.value;\r\n        }\r\n        pos += iter.value.length;\r\n    }\r\n    if (!changes.length)\r\n        return false;\r\n    dispatch(state.update({ changes, userEvent: \"delete\" }));\r\n    return true;\r\n};\r\n/**\r\nReplace each selection range with a line break, leaving the cursor\r\non the line before the break.\r\n*/\r\nconst splitLine = ({ state, dispatch }) => {\r\n    if (state.readOnly)\r\n        return false;\r\n    let changes = state.changeByRange(range => {\r\n        return { changes: { from: range.from, to: range.to, insert: _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.Text.of([\"\", \"\"]) },\r\n            range: _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.cursor(range.from) };\r\n    });\r\n    dispatch(state.update(changes, { scrollIntoView: true, userEvent: \"input\" }));\r\n    return true;\r\n};\r\n/**\r\nFlip the characters before and after the cursor(s).\r\n*/\r\nconst transposeChars = ({ state, dispatch }) => {\r\n    if (state.readOnly)\r\n        return false;\r\n    let changes = state.changeByRange(range => {\r\n        if (!range.empty || range.from == 0 || range.from == state.doc.length)\r\n            return { range };\r\n        let pos = range.from, line = state.doc.lineAt(pos);\r\n        let from = pos == line.from ? pos - 1 : (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.findClusterBreak)(line.text, pos - line.from, false) + line.from;\r\n        let to = pos == line.to ? pos + 1 : (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.findClusterBreak)(line.text, pos - line.from, true) + line.from;\r\n        return { changes: { from, to, insert: state.doc.slice(pos, to).append(state.doc.slice(from, pos)) },\r\n            range: _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.cursor(to) };\r\n    });\r\n    if (changes.changes.empty)\r\n        return false;\r\n    dispatch(state.update(changes, { scrollIntoView: true, userEvent: \"move.character\" }));\r\n    return true;\r\n};\r\nfunction selectedLineBlocks(state) {\r\n    let blocks = [], upto = -1;\r\n    for (let range of state.selection.ranges) {\r\n        let startLine = state.doc.lineAt(range.from), endLine = state.doc.lineAt(range.to);\r\n        if (!range.empty && range.to == endLine.from)\r\n            endLine = state.doc.lineAt(range.to - 1);\r\n        if (upto >= startLine.number) {\r\n            let prev = blocks[blocks.length - 1];\r\n            prev.to = endLine.to;\r\n            prev.ranges.push(range);\r\n        }\r\n        else {\r\n            blocks.push({ from: startLine.from, to: endLine.to, ranges: [range] });\r\n        }\r\n        upto = endLine.number + 1;\r\n    }\r\n    return blocks;\r\n}\r\nfunction moveLine(state, dispatch, forward) {\r\n    if (state.readOnly)\r\n        return false;\r\n    let changes = [], ranges = [];\r\n    for (let block of selectedLineBlocks(state)) {\r\n        if (forward ? block.to == state.doc.length : block.from == 0)\r\n            continue;\r\n        let nextLine = state.doc.lineAt(forward ? block.to + 1 : block.from - 1);\r\n        let size = nextLine.length + 1;\r\n        if (forward) {\r\n            changes.push({ from: block.to, to: nextLine.to }, { from: block.from, insert: nextLine.text + state.lineBreak });\r\n            for (let r of block.ranges)\r\n                ranges.push(_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.range(Math.min(state.doc.length, r.anchor + size), Math.min(state.doc.length, r.head + size)));\r\n        }\r\n        else {\r\n            changes.push({ from: nextLine.from, to: block.from }, { from: block.to, insert: state.lineBreak + nextLine.text });\r\n            for (let r of block.ranges)\r\n                ranges.push(_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.range(r.anchor - size, r.head - size));\r\n        }\r\n    }\r\n    if (!changes.length)\r\n        return false;\r\n    dispatch(state.update({\r\n        changes,\r\n        scrollIntoView: true,\r\n        selection: _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.create(ranges, state.selection.mainIndex),\r\n        userEvent: \"move.line\"\r\n    }));\r\n    return true;\r\n}\r\n/**\r\nMove the selected lines up one line.\r\n*/\r\nconst moveLineUp = ({ state, dispatch }) => moveLine(state, dispatch, false);\r\n/**\r\nMove the selected lines down one line.\r\n*/\r\nconst moveLineDown = ({ state, dispatch }) => moveLine(state, dispatch, true);\r\nfunction copyLine(state, dispatch, forward) {\r\n    if (state.readOnly)\r\n        return false;\r\n    let changes = [];\r\n    for (let block of selectedLineBlocks(state)) {\r\n        if (forward)\r\n            changes.push({ from: block.from, insert: state.doc.slice(block.from, block.to) + state.lineBreak });\r\n        else\r\n            changes.push({ from: block.to, insert: state.lineBreak + state.doc.slice(block.from, block.to) });\r\n    }\r\n    dispatch(state.update({ changes, scrollIntoView: true, userEvent: \"input.copyline\" }));\r\n    return true;\r\n}\r\n/**\r\nCreate a copy of the selected lines. Keep the selection in the top copy.\r\n*/\r\nconst copyLineUp = ({ state, dispatch }) => copyLine(state, dispatch, false);\r\n/**\r\nCreate a copy of the selected lines. Keep the selection in the bottom copy.\r\n*/\r\nconst copyLineDown = ({ state, dispatch }) => copyLine(state, dispatch, true);\r\n/**\r\nDelete selected lines.\r\n*/\r\nconst deleteLine = view => {\r\n    if (view.state.readOnly)\r\n        return false;\r\n    let { state } = view, changes = state.changes(selectedLineBlocks(state).map(({ from, to }) => {\r\n        if (from > 0)\r\n            from--;\r\n        else if (to < state.doc.length)\r\n            to++;\r\n        return { from, to };\r\n    }));\r\n    let selection = updateSel(state.selection, range => view.moveVertically(range, true)).map(changes);\r\n    view.dispatch({ changes, selection, scrollIntoView: true, userEvent: \"delete.line\" });\r\n    return true;\r\n};\r\n/**\r\nReplace the selection with a newline.\r\n*/\r\nconst insertNewline = ({ state, dispatch }) => {\r\n    dispatch(state.update(state.replaceSelection(state.lineBreak), { scrollIntoView: true, userEvent: \"input\" }));\r\n    return true;\r\n};\r\nfunction isBetweenBrackets(state, pos) {\r\n    if (/\\(\\)|\\[\\]|\\{\\}/.test(state.sliceDoc(pos - 1, pos + 1)))\r\n        return { from: pos, to: pos };\r\n    let context = (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.syntaxTree)(state).resolveInner(pos);\r\n    let before = context.childBefore(pos), after = context.childAfter(pos), closedBy;\r\n    if (before && after && before.to <= pos && after.from >= pos &&\r\n        (closedBy = before.type.prop(_lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeProp.closedBy)) && closedBy.indexOf(after.name) > -1 &&\r\n        state.doc.lineAt(before.to).from == state.doc.lineAt(after.from).from)\r\n        return { from: before.to, to: after.from };\r\n    return null;\r\n}\r\n/**\r\nReplace the selection with a newline and indent the newly created\r\nline(s). If the current line consists only of whitespace, this\r\nwill also delete that whitespace. When the cursor is between\r\nmatching brackets, an additional newline will be inserted after\r\nthe cursor.\r\n*/\r\nconst insertNewlineAndIndent = /*@__PURE__*/newlineAndIndent(false);\r\n/**\r\nCreate a blank, indented line below the current line.\r\n*/\r\nconst insertBlankLine = /*@__PURE__*/newlineAndIndent(true);\r\nfunction newlineAndIndent(atEof) {\r\n    return ({ state, dispatch }) => {\r\n        if (state.readOnly)\r\n            return false;\r\n        let changes = state.changeByRange(range => {\r\n            let { from, to } = range, line = state.doc.lineAt(from);\r\n            let explode = !atEof && from == to && isBetweenBrackets(state, from);\r\n            if (atEof)\r\n                from = to = (to <= line.to ? line : state.doc.lineAt(to)).to;\r\n            let cx = new _codemirror_language__WEBPACK_IMPORTED_MODULE_3__.IndentContext(state, { simulateBreak: from, simulateDoubleBreak: !!explode });\r\n            let indent = (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.getIndentation)(cx, from);\r\n            if (indent == null)\r\n                indent = /^\\s*/.exec(state.doc.lineAt(from).text)[0].length;\r\n            while (to < line.to && /\\s/.test(line.text[to - line.from]))\r\n                to++;\r\n            if (explode)\r\n                ({ from, to } = explode);\r\n            else if (from > line.from && from < line.from + 100 && !/\\S/.test(line.text.slice(0, from)))\r\n                from = line.from;\r\n            let insert = [\"\", (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.indentString)(state, indent)];\r\n            if (explode)\r\n                insert.push((0,_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.indentString)(state, cx.lineIndent(line.from, -1)));\r\n            return { changes: { from, to, insert: _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.Text.of(insert) },\r\n                range: _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.cursor(from + 1 + insert[1].length) };\r\n        });\r\n        dispatch(state.update(changes, { scrollIntoView: true, userEvent: \"input\" }));\r\n        return true;\r\n    };\r\n}\r\nfunction changeBySelectedLine(state, f) {\r\n    let atLine = -1;\r\n    return state.changeByRange(range => {\r\n        let changes = [];\r\n        for (let pos = range.from; pos <= range.to;) {\r\n            let line = state.doc.lineAt(pos);\r\n            if (line.number > atLine && (range.empty || range.to > line.from)) {\r\n                f(line, changes, range);\r\n                atLine = line.number;\r\n            }\r\n            pos = line.to + 1;\r\n        }\r\n        let changeSet = state.changes(changes);\r\n        return { changes,\r\n            range: _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.range(changeSet.mapPos(range.anchor, 1), changeSet.mapPos(range.head, 1)) };\r\n    });\r\n}\r\n/**\r\nAuto-indent the selected lines. This uses the [indentation service\r\nfacet](https://codemirror.net/6/docs/ref/#language.indentService) as source for auto-indent\r\ninformation.\r\n*/\r\nconst indentSelection = ({ state, dispatch }) => {\r\n    if (state.readOnly)\r\n        return false;\r\n    let updated = Object.create(null);\r\n    let context = new _codemirror_language__WEBPACK_IMPORTED_MODULE_3__.IndentContext(state, { overrideIndentation: start => {\r\n            let found = updated[start];\r\n            return found == null ? -1 : found;\r\n        } });\r\n    let changes = changeBySelectedLine(state, (line, changes, range) => {\r\n        let indent = (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.getIndentation)(context, line.from);\r\n        if (indent == null)\r\n            return;\r\n        if (!/\\S/.test(line.text))\r\n            indent = 0;\r\n        let cur = /^\\s*/.exec(line.text)[0];\r\n        let norm = (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.indentString)(state, indent);\r\n        if (cur != norm || range.from < line.from + cur.length) {\r\n            updated[line.from] = indent;\r\n            changes.push({ from: line.from, to: line.from + cur.length, insert: norm });\r\n        }\r\n    });\r\n    if (!changes.changes.empty)\r\n        dispatch(state.update(changes, { userEvent: \"indent\" }));\r\n    return true;\r\n};\r\n/**\r\nAdd a [unit](https://codemirror.net/6/docs/ref/#language.indentUnit) of indentation to all selected\r\nlines.\r\n*/\r\nconst indentMore = ({ state, dispatch }) => {\r\n    if (state.readOnly)\r\n        return false;\r\n    dispatch(state.update(changeBySelectedLine(state, (line, changes) => {\r\n        changes.push({ from: line.from, insert: state.facet(_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.indentUnit) });\r\n    }), { userEvent: \"input.indent\" }));\r\n    return true;\r\n};\r\n/**\r\nRemove a [unit](https://codemirror.net/6/docs/ref/#language.indentUnit) of indentation from all\r\nselected lines.\r\n*/\r\nconst indentLess = ({ state, dispatch }) => {\r\n    if (state.readOnly)\r\n        return false;\r\n    dispatch(state.update(changeBySelectedLine(state, (line, changes) => {\r\n        let space = /^\\s*/.exec(line.text)[0];\r\n        if (!space)\r\n            return;\r\n        let col = (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.countColumn)(space, state.tabSize), keep = 0;\r\n        let insert = (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.indentString)(state, Math.max(0, col - (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.getIndentUnit)(state)));\r\n        while (keep < space.length && keep < insert.length && space.charCodeAt(keep) == insert.charCodeAt(keep))\r\n            keep++;\r\n        changes.push({ from: line.from + keep, to: line.from + space.length, insert: insert.slice(keep) });\r\n    }), { userEvent: \"delete.dedent\" }));\r\n    return true;\r\n};\r\n/**\r\nInsert a tab character at the cursor or, if something is selected,\r\nuse [`indentMore`](https://codemirror.net/6/docs/ref/#commands.indentMore) to indent the entire\r\nselection.\r\n*/\r\nconst insertTab = ({ state, dispatch }) => {\r\n    if (state.selection.ranges.some(r => !r.empty))\r\n        return indentMore({ state, dispatch });\r\n    dispatch(state.update(state.replaceSelection(\"\\t\"), { scrollIntoView: true, userEvent: \"input\" }));\r\n    return true;\r\n};\r\n/**\r\nArray of key bindings containing the Emacs-style bindings that are\r\navailable on macOS by default.\r\n\r\n - Ctrl-b: [`cursorCharLeft`](https://codemirror.net/6/docs/ref/#commands.cursorCharLeft) ([`selectCharLeft`](https://codemirror.net/6/docs/ref/#commands.selectCharLeft) with Shift)\r\n - Ctrl-f: [`cursorCharRight`](https://codemirror.net/6/docs/ref/#commands.cursorCharRight) ([`selectCharRight`](https://codemirror.net/6/docs/ref/#commands.selectCharRight) with Shift)\r\n - Ctrl-p: [`cursorLineUp`](https://codemirror.net/6/docs/ref/#commands.cursorLineUp) ([`selectLineUp`](https://codemirror.net/6/docs/ref/#commands.selectLineUp) with Shift)\r\n - Ctrl-n: [`cursorLineDown`](https://codemirror.net/6/docs/ref/#commands.cursorLineDown) ([`selectLineDown`](https://codemirror.net/6/docs/ref/#commands.selectLineDown) with Shift)\r\n - Ctrl-a: [`cursorLineStart`](https://codemirror.net/6/docs/ref/#commands.cursorLineStart) ([`selectLineStart`](https://codemirror.net/6/docs/ref/#commands.selectLineStart) with Shift)\r\n - Ctrl-e: [`cursorLineEnd`](https://codemirror.net/6/docs/ref/#commands.cursorLineEnd) ([`selectLineEnd`](https://codemirror.net/6/docs/ref/#commands.selectLineEnd) with Shift)\r\n - Ctrl-d: [`deleteCharForward`](https://codemirror.net/6/docs/ref/#commands.deleteCharForward)\r\n - Ctrl-h: [`deleteCharBackward`](https://codemirror.net/6/docs/ref/#commands.deleteCharBackward)\r\n - Ctrl-k: [`deleteToLineEnd`](https://codemirror.net/6/docs/ref/#commands.deleteToLineEnd)\r\n - Ctrl-Alt-h: [`deleteGroupBackward`](https://codemirror.net/6/docs/ref/#commands.deleteGroupBackward)\r\n - Ctrl-o: [`splitLine`](https://codemirror.net/6/docs/ref/#commands.splitLine)\r\n - Ctrl-t: [`transposeChars`](https://codemirror.net/6/docs/ref/#commands.transposeChars)\r\n - Ctrl-v: [`cursorPageDown`](https://codemirror.net/6/docs/ref/#commands.cursorPageDown)\r\n - Alt-v: [`cursorPageUp`](https://codemirror.net/6/docs/ref/#commands.cursorPageUp)\r\n*/\r\nconst emacsStyleKeymap = [\r\n    { key: \"Ctrl-b\", run: cursorCharLeft, shift: selectCharLeft, preventDefault: true },\r\n    { key: \"Ctrl-f\", run: cursorCharRight, shift: selectCharRight },\r\n    { key: \"Ctrl-p\", run: cursorLineUp, shift: selectLineUp },\r\n    { key: \"Ctrl-n\", run: cursorLineDown, shift: selectLineDown },\r\n    { key: \"Ctrl-a\", run: cursorLineStart, shift: selectLineStart },\r\n    { key: \"Ctrl-e\", run: cursorLineEnd, shift: selectLineEnd },\r\n    { key: \"Ctrl-d\", run: deleteCharForward },\r\n    { key: \"Ctrl-h\", run: deleteCharBackward },\r\n    { key: \"Ctrl-k\", run: deleteToLineEnd },\r\n    { key: \"Ctrl-Alt-h\", run: deleteGroupBackward },\r\n    { key: \"Ctrl-o\", run: splitLine },\r\n    { key: \"Ctrl-t\", run: transposeChars },\r\n    { key: \"Ctrl-v\", run: cursorPageDown },\r\n];\r\n/**\r\nAn array of key bindings closely sticking to platform-standard or\r\nwidely used bindings. (This includes the bindings from\r\n[`emacsStyleKeymap`](https://codemirror.net/6/docs/ref/#commands.emacsStyleKeymap), with their `key`\r\nproperty changed to `mac`.)\r\n\r\n - ArrowLeft: [`cursorCharLeft`](https://codemirror.net/6/docs/ref/#commands.cursorCharLeft) ([`selectCharLeft`](https://codemirror.net/6/docs/ref/#commands.selectCharLeft) with Shift)\r\n - ArrowRight: [`cursorCharRight`](https://codemirror.net/6/docs/ref/#commands.cursorCharRight) ([`selectCharRight`](https://codemirror.net/6/docs/ref/#commands.selectCharRight) with Shift)\r\n - Ctrl-ArrowLeft (Alt-ArrowLeft on macOS): [`cursorGroupLeft`](https://codemirror.net/6/docs/ref/#commands.cursorGroupLeft) ([`selectGroupLeft`](https://codemirror.net/6/docs/ref/#commands.selectGroupLeft) with Shift)\r\n - Ctrl-ArrowRight (Alt-ArrowRight on macOS): [`cursorGroupRight`](https://codemirror.net/6/docs/ref/#commands.cursorGroupRight) ([`selectGroupRight`](https://codemirror.net/6/docs/ref/#commands.selectGroupRight) with Shift)\r\n - Cmd-ArrowLeft (on macOS): [`cursorLineStart`](https://codemirror.net/6/docs/ref/#commands.cursorLineStart) ([`selectLineStart`](https://codemirror.net/6/docs/ref/#commands.selectLineStart) with Shift)\r\n - Cmd-ArrowRight (on macOS): [`cursorLineEnd`](https://codemirror.net/6/docs/ref/#commands.cursorLineEnd) ([`selectLineEnd`](https://codemirror.net/6/docs/ref/#commands.selectLineEnd) with Shift)\r\n - ArrowUp: [`cursorLineUp`](https://codemirror.net/6/docs/ref/#commands.cursorLineUp) ([`selectLineUp`](https://codemirror.net/6/docs/ref/#commands.selectLineUp) with Shift)\r\n - ArrowDown: [`cursorLineDown`](https://codemirror.net/6/docs/ref/#commands.cursorLineDown) ([`selectLineDown`](https://codemirror.net/6/docs/ref/#commands.selectLineDown) with Shift)\r\n - Cmd-ArrowUp (on macOS): [`cursorDocStart`](https://codemirror.net/6/docs/ref/#commands.cursorDocStart) ([`selectDocStart`](https://codemirror.net/6/docs/ref/#commands.selectDocStart) with Shift)\r\n - Cmd-ArrowDown (on macOS): [`cursorDocEnd`](https://codemirror.net/6/docs/ref/#commands.cursorDocEnd) ([`selectDocEnd`](https://codemirror.net/6/docs/ref/#commands.selectDocEnd) with Shift)\r\n - Ctrl-ArrowUp (on macOS): [`cursorPageUp`](https://codemirror.net/6/docs/ref/#commands.cursorPageUp) ([`selectPageUp`](https://codemirror.net/6/docs/ref/#commands.selectPageUp) with Shift)\r\n - Ctrl-ArrowDown (on macOS): [`cursorPageDown`](https://codemirror.net/6/docs/ref/#commands.cursorPageDown) ([`selectPageDown`](https://codemirror.net/6/docs/ref/#commands.selectPageDown) with Shift)\r\n - PageUp: [`cursorPageUp`](https://codemirror.net/6/docs/ref/#commands.cursorPageUp) ([`selectPageUp`](https://codemirror.net/6/docs/ref/#commands.selectPageUp) with Shift)\r\n - PageDown: [`cursorPageDown`](https://codemirror.net/6/docs/ref/#commands.cursorPageDown) ([`selectPageDown`](https://codemirror.net/6/docs/ref/#commands.selectPageDown) with Shift)\r\n - Home: [`cursorLineBoundaryBackward`](https://codemirror.net/6/docs/ref/#commands.cursorLineBoundaryBackward) ([`selectLineBoundaryBackward`](https://codemirror.net/6/docs/ref/#commands.selectLineBoundaryBackward) with Shift)\r\n - End: [`cursorLineBoundaryForward`](https://codemirror.net/6/docs/ref/#commands.cursorLineBoundaryForward) ([`selectLineBoundaryForward`](https://codemirror.net/6/docs/ref/#commands.selectLineBoundaryForward) with Shift)\r\n - Ctrl-Home (Cmd-Home on macOS): [`cursorDocStart`](https://codemirror.net/6/docs/ref/#commands.cursorDocStart) ([`selectDocStart`](https://codemirror.net/6/docs/ref/#commands.selectDocStart) with Shift)\r\n - Ctrl-End (Cmd-Home on macOS): [`cursorDocEnd`](https://codemirror.net/6/docs/ref/#commands.cursorDocEnd) ([`selectDocEnd`](https://codemirror.net/6/docs/ref/#commands.selectDocEnd) with Shift)\r\n - Enter: [`insertNewlineAndIndent`](https://codemirror.net/6/docs/ref/#commands.insertNewlineAndIndent)\r\n - Ctrl-a (Cmd-a on macOS): [`selectAll`](https://codemirror.net/6/docs/ref/#commands.selectAll)\r\n - Backspace: [`deleteCharBackward`](https://codemirror.net/6/docs/ref/#commands.deleteCharBackward)\r\n - Delete: [`deleteCharForward`](https://codemirror.net/6/docs/ref/#commands.deleteCharForward)\r\n - Ctrl-Backspace (Alt-Backspace on macOS): [`deleteGroupBackward`](https://codemirror.net/6/docs/ref/#commands.deleteGroupBackward)\r\n - Ctrl-Delete (Alt-Delete on macOS): [`deleteGroupForward`](https://codemirror.net/6/docs/ref/#commands.deleteGroupForward)\r\n - Cmd-Backspace (macOS): [`deleteToLineStart`](https://codemirror.net/6/docs/ref/#commands.deleteToLineStart).\r\n - Cmd-Delete (macOS): [`deleteToLineEnd`](https://codemirror.net/6/docs/ref/#commands.deleteToLineEnd).\r\n*/\r\nconst standardKeymap = /*@__PURE__*/[\r\n    { key: \"ArrowLeft\", run: cursorCharLeft, shift: selectCharLeft, preventDefault: true },\r\n    { key: \"Mod-ArrowLeft\", mac: \"Alt-ArrowLeft\", run: cursorGroupLeft, shift: selectGroupLeft, preventDefault: true },\r\n    { mac: \"Cmd-ArrowLeft\", run: cursorLineBoundaryLeft, shift: selectLineBoundaryLeft, preventDefault: true },\r\n    { key: \"ArrowRight\", run: cursorCharRight, shift: selectCharRight, preventDefault: true },\r\n    { key: \"Mod-ArrowRight\", mac: \"Alt-ArrowRight\", run: cursorGroupRight, shift: selectGroupRight, preventDefault: true },\r\n    { mac: \"Cmd-ArrowRight\", run: cursorLineBoundaryRight, shift: selectLineBoundaryRight, preventDefault: true },\r\n    { key: \"ArrowUp\", run: cursorLineUp, shift: selectLineUp, preventDefault: true },\r\n    { mac: \"Cmd-ArrowUp\", run: cursorDocStart, shift: selectDocStart },\r\n    { mac: \"Ctrl-ArrowUp\", run: cursorPageUp, shift: selectPageUp },\r\n    { key: \"ArrowDown\", run: cursorLineDown, shift: selectLineDown, preventDefault: true },\r\n    { mac: \"Cmd-ArrowDown\", run: cursorDocEnd, shift: selectDocEnd },\r\n    { mac: \"Ctrl-ArrowDown\", run: cursorPageDown, shift: selectPageDown },\r\n    { key: \"PageUp\", run: cursorPageUp, shift: selectPageUp },\r\n    { key: \"PageDown\", run: cursorPageDown, shift: selectPageDown },\r\n    { key: \"Home\", run: cursorLineBoundaryBackward, shift: selectLineBoundaryBackward, preventDefault: true },\r\n    { key: \"Mod-Home\", run: cursorDocStart, shift: selectDocStart },\r\n    { key: \"End\", run: cursorLineBoundaryForward, shift: selectLineBoundaryForward, preventDefault: true },\r\n    { key: \"Mod-End\", run: cursorDocEnd, shift: selectDocEnd },\r\n    { key: \"Enter\", run: insertNewlineAndIndent },\r\n    { key: \"Mod-a\", run: selectAll },\r\n    { key: \"Backspace\", run: deleteCharBackward, shift: deleteCharBackward },\r\n    { key: \"Delete\", run: deleteCharForward },\r\n    { key: \"Mod-Backspace\", mac: \"Alt-Backspace\", run: deleteGroupBackward },\r\n    { key: \"Mod-Delete\", mac: \"Alt-Delete\", run: deleteGroupForward },\r\n    { mac: \"Mod-Backspace\", run: deleteToLineStart },\r\n    { mac: \"Mod-Delete\", run: deleteToLineEnd }\r\n].concat(/*@__PURE__*/emacsStyleKeymap.map(b => ({ mac: b.key, run: b.run, shift: b.shift })));\r\n/**\r\nThe default keymap. Includes all bindings from\r\n[`standardKeymap`](https://codemirror.net/6/docs/ref/#commands.standardKeymap) plus the following:\r\n\r\n- Alt-ArrowLeft (Ctrl-ArrowLeft on macOS): [`cursorSyntaxLeft`](https://codemirror.net/6/docs/ref/#commands.cursorSyntaxLeft) ([`selectSyntaxLeft`](https://codemirror.net/6/docs/ref/#commands.selectSyntaxLeft) with Shift)\r\n- Alt-ArrowRight (Ctrl-ArrowRight on macOS): [`cursorSyntaxRight`](https://codemirror.net/6/docs/ref/#commands.cursorSyntaxRight) ([`selectSyntaxRight`](https://codemirror.net/6/docs/ref/#commands.selectSyntaxRight) with Shift)\r\n- Alt-ArrowUp: [`moveLineUp`](https://codemirror.net/6/docs/ref/#commands.moveLineUp)\r\n- Alt-ArrowDown: [`moveLineDown`](https://codemirror.net/6/docs/ref/#commands.moveLineDown)\r\n- Shift-Alt-ArrowUp: [`copyLineUp`](https://codemirror.net/6/docs/ref/#commands.copyLineUp)\r\n- Shift-Alt-ArrowDown: [`copyLineDown`](https://codemirror.net/6/docs/ref/#commands.copyLineDown)\r\n- Escape: [`simplifySelection`](https://codemirror.net/6/docs/ref/#commands.simplifySelection)\r\n- Ctrl-Enter (Comd-Enter on macOS): [`insertBlankLine`](https://codemirror.net/6/docs/ref/#commands.insertBlankLine)\r\n- Alt-l (Ctrl-l on macOS): [`selectLine`](https://codemirror.net/6/docs/ref/#commands.selectLine)\r\n- Ctrl-i (Cmd-i on macOS): [`selectParentSyntax`](https://codemirror.net/6/docs/ref/#commands.selectParentSyntax)\r\n- Ctrl-[ (Cmd-[ on macOS): [`indentLess`](https://codemirror.net/6/docs/ref/#commands.indentLess)\r\n- Ctrl-] (Cmd-] on macOS): [`indentMore`](https://codemirror.net/6/docs/ref/#commands.indentMore)\r\n- Ctrl-Alt-\\\\ (Cmd-Alt-\\\\ on macOS): [`indentSelection`](https://codemirror.net/6/docs/ref/#commands.indentSelection)\r\n- Shift-Ctrl-k (Shift-Cmd-k on macOS): [`deleteLine`](https://codemirror.net/6/docs/ref/#commands.deleteLine)\r\n- Shift-Ctrl-\\\\ (Shift-Cmd-\\\\ on macOS): [`cursorMatchingBracket`](https://codemirror.net/6/docs/ref/#commands.cursorMatchingBracket)\r\n- Ctrl-/ (Cmd-/ on macOS): [`toggleComment`](https://codemirror.net/6/docs/ref/#commands.toggleComment).\r\n- Shift-Alt-a: [`toggleBlockComment`](https://codemirror.net/6/docs/ref/#commands.toggleBlockComment).\r\n*/\r\nconst defaultKeymap = /*@__PURE__*/[\r\n    { key: \"Alt-ArrowLeft\", mac: \"Ctrl-ArrowLeft\", run: cursorSyntaxLeft, shift: selectSyntaxLeft },\r\n    { key: \"Alt-ArrowRight\", mac: \"Ctrl-ArrowRight\", run: cursorSyntaxRight, shift: selectSyntaxRight },\r\n    { key: \"Alt-ArrowUp\", run: moveLineUp },\r\n    { key: \"Shift-Alt-ArrowUp\", run: copyLineUp },\r\n    { key: \"Alt-ArrowDown\", run: moveLineDown },\r\n    { key: \"Shift-Alt-ArrowDown\", run: copyLineDown },\r\n    { key: \"Escape\", run: simplifySelection },\r\n    { key: \"Mod-Enter\", run: insertBlankLine },\r\n    { key: \"Alt-l\", mac: \"Ctrl-l\", run: selectLine },\r\n    { key: \"Mod-i\", run: selectParentSyntax, preventDefault: true },\r\n    { key: \"Mod-[\", run: indentLess },\r\n    { key: \"Mod-]\", run: indentMore },\r\n    { key: \"Mod-Alt-\\\\\", run: indentSelection },\r\n    { key: \"Shift-Mod-k\", run: deleteLine },\r\n    { key: \"Shift-Mod-\\\\\", run: cursorMatchingBracket },\r\n    { key: \"Mod-/\", run: toggleComment },\r\n    { key: \"Alt-A\", run: toggleBlockComment }\r\n].concat(standardKeymap);\r\n/**\r\nA binding that binds Tab to [`indentMore`](https://codemirror.net/6/docs/ref/#commands.indentMore) and\r\nShift-Tab to [`indentLess`](https://codemirror.net/6/docs/ref/#commands.indentLess).\r\nPlease see the [Tab example](../../examples/tab/) before using\r\nthis.\r\n*/\r\nconst indentWithTab = { key: \"Tab\", run: indentMore, shift: indentLess };\r\n\r\n\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGNvZGVtaXJyb3IvY29tbWFuZHMvZGlzdC9pbmRleC5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBc007QUFDN0k7QUFDZ0Y7QUFDaEc7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLGlCQUFpQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLGFBQWE7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFFBQVEsbURBQW1EO0FBQzVFLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixRQUFRO0FBQ3pCLHVGQUF1RjtBQUN2RixxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsb0NBQW9DO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFD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QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDNHFEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AY29kZW1pcnJvci9jb21tYW5kcy9kaXN0L2luZGV4LmpzP2M0Y2MiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQW5ub3RhdGlvbiwgRmFjZXQsIGNvbWJpbmVDb25maWcsIFN0YXRlRmllbGQsIEVkaXRvclNlbGVjdGlvbiwgVHJhbnNhY3Rpb24sIENoYW5nZVNldCwgQ2hhbmdlRGVzYywgU3RhdGVFZmZlY3QsIFRleHQsIGZpbmRDbHVzdGVyQnJlYWssIGNvdW50Q29sdW1uLCBDaGFyQ2F0ZWdvcnkgfSBmcm9tICdAY29kZW1pcnJvci9zdGF0ZSc7XHJcbmltcG9ydCB7IEVkaXRvclZpZXcsIERpcmVjdGlvbiB9IGZyb20gJ0Bjb2RlbWlycm9yL3ZpZXcnO1xyXG5pbXBvcnQgeyBJbmRlbnRDb250ZXh0LCBnZXRJbmRlbnRhdGlvbiwgaW5kZW50U3RyaW5nLCBtYXRjaEJyYWNrZXRzLCBzeW50YXhUcmVlLCBnZXRJbmRlbnRVbml0LCBpbmRlbnRVbml0IH0gZnJvbSAnQGNvZGVtaXJyb3IvbGFuZ3VhZ2UnO1xyXG5pbXBvcnQgeyBOb2RlUHJvcCB9IGZyb20gJ0BsZXplci9jb21tb24nO1xyXG5cclxuLyoqXHJcbkNvbW1lbnQgb3IgdW5jb21tZW50IHRoZSBjdXJyZW50IHNlbGVjdGlvbi4gV2lsbCB1c2UgbGluZSBjb21tZW50c1xyXG5pZiBhdmFpbGFibGUsIG90aGVyd2lzZSBmYWxsaW5nIGJhY2sgdG8gYmxvY2sgY29tbWVudHMuXHJcbiovXHJcbmNvbnN0IHRvZ2dsZUNvbW1lbnQgPSB0YXJnZXQgPT4ge1xyXG4gICAgbGV0IGNvbmZpZyA9IGdldENvbmZpZyh0YXJnZXQuc3RhdGUpO1xyXG4gICAgcmV0dXJuIGNvbmZpZy5saW5lID8gdG9nZ2xlTGluZUNvbW1lbnQodGFyZ2V0KSA6IGNvbmZpZy5ibG9jayA/IHRvZ2dsZUJsb2NrQ29tbWVudEJ5TGluZSh0YXJnZXQpIDogZmFsc2U7XHJcbn07XHJcbmZ1bmN0aW9uIGNvbW1hbmQoZiwgb3B0aW9uKSB7XHJcbiAgICByZXR1cm4gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcclxuICAgICAgICBpZiAoc3RhdGUucmVhZE9ubHkpXHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICBsZXQgdHIgPSBmKG9wdGlvbiwgc3RhdGUpO1xyXG4gICAgICAgIGlmICghdHIpXHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICBkaXNwYXRjaChzdGF0ZS51cGRhdGUodHIpKTtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH07XHJcbn1cclxuLyoqXHJcbkNvbW1lbnQgb3IgdW5jb21tZW50IHRoZSBjdXJyZW50IHNlbGVjdGlvbiB1c2luZyBsaW5lIGNvbW1lbnRzLlxyXG5UaGUgbGluZSBjb21tZW50IHN5bnRheCBpcyB0YWtlbiBmcm9tIHRoZVxyXG5bYGNvbW1lbnRUb2tlbnNgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLkNvbW1lbnRUb2tlbnMpIFtsYW5ndWFnZVxyXG5kYXRhXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkVkaXRvclN0YXRlLmxhbmd1YWdlRGF0YUF0KS5cclxuKi9cclxuY29uc3QgdG9nZ2xlTGluZUNvbW1lbnQgPSAvKkBfX1BVUkVfXyovY29tbWFuZChjaGFuZ2VMaW5lQ29tbWVudCwgMCAvKiBDb21tZW50T3B0aW9uLlRvZ2dsZSAqLyk7XHJcbi8qKlxyXG5Db21tZW50IHRoZSBjdXJyZW50IHNlbGVjdGlvbiB1c2luZyBsaW5lIGNvbW1lbnRzLlxyXG4qL1xyXG5jb25zdCBsaW5lQ29tbWVudCA9IC8qQF9fUFVSRV9fKi9jb21tYW5kKGNoYW5nZUxpbmVDb21tZW50LCAxIC8qIENvbW1lbnRPcHRpb24uQ29tbWVudCAqLyk7XHJcbi8qKlxyXG5VbmNvbW1lbnQgdGhlIGN1cnJlbnQgc2VsZWN0aW9uIHVzaW5nIGxpbmUgY29tbWVudHMuXHJcbiovXHJcbmNvbnN0IGxpbmVVbmNvbW1lbnQgPSAvKkBfX1BVUkVfXyovY29tbWFuZChjaGFuZ2VMaW5lQ29tbWVudCwgMiAvKiBDb21tZW50T3B0aW9uLlVuY29tbWVudCAqLyk7XHJcbi8qKlxyXG5Db21tZW50IG9yIHVuY29tbWVudCB0aGUgY3VycmVudCBzZWxlY3Rpb24gdXNpbmcgYmxvY2sgY29tbWVudHMuXHJcblRoZSBibG9jayBjb21tZW50IHN5bnRheCBpcyB0YWtlbiBmcm9tIHRoZVxyXG5bYGNvbW1lbnRUb2tlbnNgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLkNvbW1lbnRUb2tlbnMpIFtsYW5ndWFnZVxyXG5kYXRhXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkVkaXRvclN0YXRlLmxhbmd1YWdlRGF0YUF0KS5cclxuKi9cclxuY29uc3QgdG9nZ2xlQmxvY2tDb21tZW50ID0gLypAX19QVVJFX18qL2NvbW1hbmQoY2hhbmdlQmxvY2tDb21tZW50LCAwIC8qIENvbW1lbnRPcHRpb24uVG9nZ2xlICovKTtcclxuLyoqXHJcbkNvbW1lbnQgdGhlIGN1cnJlbnQgc2VsZWN0aW9uIHVzaW5nIGJsb2NrIGNvbW1lbnRzLlxyXG4qL1xyXG5jb25zdCBibG9ja0NvbW1lbnQgPSAvKkBfX1BVUkVfXyovY29tbWFuZChjaGFuZ2VCbG9ja0NvbW1lbnQsIDEgLyogQ29tbWVudE9wdGlvbi5Db21tZW50ICovKTtcclxuLyoqXHJcblVuY29tbWVudCB0aGUgY3VycmVudCBzZWxlY3Rpb24gdXNpbmcgYmxvY2sgY29tbWVudHMuXHJcbiovXHJcbmNvbnN0IGJsb2NrVW5jb21tZW50ID0gLypAX19QVVJFX18qL2NvbW1hbmQoY2hhbmdlQmxvY2tDb21tZW50LCAyIC8qIENvbW1lbnRPcHRpb24uVW5jb21tZW50ICovKTtcclxuLyoqXHJcbkNvbW1lbnQgb3IgdW5jb21tZW50IHRoZSBsaW5lcyBhcm91bmQgdGhlIGN1cnJlbnQgc2VsZWN0aW9uIHVzaW5nXHJcbmJsb2NrIGNvbW1lbnRzLlxyXG4qL1xyXG5jb25zdCB0b2dnbGVCbG9ja0NvbW1lbnRCeUxpbmUgPSAvKkBfX1BVUkVfXyovY29tbWFuZCgobywgcykgPT4gY2hhbmdlQmxvY2tDb21tZW50KG8sIHMsIHNlbGVjdGVkTGluZVJhbmdlcyhzKSksIDAgLyogQ29tbWVudE9wdGlvbi5Ub2dnbGUgKi8pO1xyXG5mdW5jdGlvbiBnZXRDb25maWcoc3RhdGUsIHBvcyA9IHN0YXRlLnNlbGVjdGlvbi5tYWluLmhlYWQpIHtcclxuICAgIGxldCBkYXRhID0gc3RhdGUubGFuZ3VhZ2VEYXRhQXQoXCJjb21tZW50VG9rZW5zXCIsIHBvcyk7XHJcbiAgICByZXR1cm4gZGF0YS5sZW5ndGggPyBkYXRhWzBdIDoge307XHJcbn1cclxuY29uc3QgU2VhcmNoTWFyZ2luID0gNTA7XHJcbi8qKlxyXG5EZXRlcm1pbmVzIGlmIHRoZSBnaXZlbiByYW5nZSBpcyBibG9jay1jb21tZW50ZWQgaW4gdGhlIGdpdmVuXHJcbnN0YXRlLlxyXG4qL1xyXG5mdW5jdGlvbiBmaW5kQmxvY2tDb21tZW50KHN0YXRlLCB7IG9wZW4sIGNsb3NlIH0sIGZyb20sIHRvKSB7XHJcbiAgICBsZXQgdGV4dEJlZm9yZSA9IHN0YXRlLnNsaWNlRG9jKGZyb20gLSBTZWFyY2hNYXJnaW4sIGZyb20pO1xyXG4gICAgbGV0IHRleHRBZnRlciA9IHN0YXRlLnNsaWNlRG9jKHRvLCB0byArIFNlYXJjaE1hcmdpbik7XHJcbiAgICBsZXQgc3BhY2VCZWZvcmUgPSAvXFxzKiQvLmV4ZWModGV4dEJlZm9yZSlbMF0ubGVuZ3RoLCBzcGFjZUFmdGVyID0gL15cXHMqLy5leGVjKHRleHRBZnRlcilbMF0ubGVuZ3RoO1xyXG4gICAgbGV0IGJlZm9yZU9mZiA9IHRleHRCZWZvcmUubGVuZ3RoIC0gc3BhY2VCZWZvcmU7XHJcbiAgICBpZiAodGV4dEJlZm9yZS5zbGljZShiZWZvcmVPZmYgLSBvcGVuLmxlbmd0aCwgYmVmb3JlT2ZmKSA9PSBvcGVuICYmXHJcbiAgICAgICAgdGV4dEFmdGVyLnNsaWNlKHNwYWNlQWZ0ZXIsIHNwYWNlQWZ0ZXIgKyBjbG9zZS5sZW5ndGgpID09IGNsb3NlKSB7XHJcbiAgICAgICAgcmV0dXJuIHsgb3BlbjogeyBwb3M6IGZyb20gLSBzcGFjZUJlZm9yZSwgbWFyZ2luOiBzcGFjZUJlZm9yZSAmJiAxIH0sXHJcbiAgICAgICAgICAgIGNsb3NlOiB7IHBvczogdG8gKyBzcGFjZUFmdGVyLCBtYXJnaW46IHNwYWNlQWZ0ZXIgJiYgMSB9IH07XHJcbiAgICB9XHJcbiAgICBsZXQgc3RhcnRUZXh0LCBlbmRUZXh0O1xyXG4gICAgaWYgKHRvIC0gZnJvbSA8PSAyICogU2VhcmNoTWFyZ2luKSB7XHJcbiAgICAgICAgc3RhcnRUZXh0ID0gZW5kVGV4dCA9IHN0YXRlLnNsaWNlRG9jKGZyb20sIHRvKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHN0YXJ0VGV4dCA9IHN0YXRlLnNsaWNlRG9jKGZyb20sIGZyb20gKyBTZWFyY2hNYXJnaW4pO1xyXG4gICAgICAgIGVuZFRleHQgPSBzdGF0ZS5zbGljZURvYyh0byAtIFNlYXJjaE1hcmdpbiwgdG8pO1xyXG4gICAgfVxyXG4gICAgbGV0IHN0YXJ0U3BhY2UgPSAvXlxccyovLmV4ZWMoc3RhcnRUZXh0KVswXS5sZW5ndGgsIGVuZFNwYWNlID0gL1xccyokLy5leGVjKGVuZFRleHQpWzBdLmxlbmd0aDtcclxuICAgIGxldCBlbmRPZmYgPSBlbmRUZXh0Lmxlbmd0aCAtIGVuZFNwYWNlIC0gY2xvc2UubGVuZ3RoO1xyXG4gICAgaWYgKHN0YXJ0VGV4dC5zbGljZShzdGFydFNwYWNlLCBzdGFydFNwYWNlICsgb3Blbi5sZW5ndGgpID09IG9wZW4gJiZcclxuICAgICAgICBlbmRUZXh0LnNsaWNlKGVuZE9mZiwgZW5kT2ZmICsgY2xvc2UubGVuZ3RoKSA9PSBjbG9zZSkge1xyXG4gICAgICAgIHJldHVybiB7IG9wZW46IHsgcG9zOiBmcm9tICsgc3RhcnRTcGFjZSArIG9wZW4ubGVuZ3RoLFxyXG4gICAgICAgICAgICAgICAgbWFyZ2luOiAvXFxzLy50ZXN0KHN0YXJ0VGV4dC5jaGFyQXQoc3RhcnRTcGFjZSArIG9wZW4ubGVuZ3RoKSkgPyAxIDogMCB9LFxyXG4gICAgICAgICAgICBjbG9zZTogeyBwb3M6IHRvIC0gZW5kU3BhY2UgLSBjbG9zZS5sZW5ndGgsXHJcbiAgICAgICAgICAgICAgICBtYXJnaW46IC9cXHMvLnRlc3QoZW5kVGV4dC5jaGFyQXQoZW5kT2ZmIC0gMSkpID8gMSA6IDAgfSB9O1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG51bGw7XHJcbn1cclxuZnVuY3Rpb24gc2VsZWN0ZWRMaW5lUmFuZ2VzKHN0YXRlKSB7XHJcbiAgICBsZXQgcmFuZ2VzID0gW107XHJcbiAgICBmb3IgKGxldCByIG9mIHN0YXRlLnNlbGVjdGlvbi5yYW5nZXMpIHtcclxuICAgICAgICBsZXQgZnJvbUxpbmUgPSBzdGF0ZS5kb2MubGluZUF0KHIuZnJvbSk7XHJcbiAgICAgICAgbGV0IHRvTGluZSA9IHIudG8gPD0gZnJvbUxpbmUudG8gPyBmcm9tTGluZSA6IHN0YXRlLmRvYy5saW5lQXQoci50byk7XHJcbiAgICAgICAgbGV0IGxhc3QgPSByYW5nZXMubGVuZ3RoIC0gMTtcclxuICAgICAgICBpZiAobGFzdCA+PSAwICYmIHJhbmdlc1tsYXN0XS50byA+IGZyb21MaW5lLmZyb20pXHJcbiAgICAgICAgICAgIHJhbmdlc1tsYXN0XS50byA9IHRvTGluZS50bztcclxuICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHJhbmdlcy5wdXNoKHsgZnJvbTogZnJvbUxpbmUuZnJvbSwgdG86IHRvTGluZS50byB9KTtcclxuICAgIH1cclxuICAgIHJldHVybiByYW5nZXM7XHJcbn1cclxuLy8gUGVyZm9ybXMgdG9nZ2xlLCBjb21tZW50IGFuZCB1bmNvbW1lbnQgb2YgYmxvY2sgY29tbWVudHMgaW5cclxuLy8gbGFuZ3VhZ2VzIHRoYXQgc3VwcG9ydCB0aGVtLlxyXG5mdW5jdGlvbiBjaGFuZ2VCbG9ja0NvbW1lbnQob3B0aW9uLCBzdGF0ZSwgcmFuZ2VzID0gc3RhdGUuc2VsZWN0aW9uLnJhbmdlcykge1xyXG4gICAgbGV0IHRva2VucyA9IHJhbmdlcy5tYXAociA9PiBnZXRDb25maWcoc3RhdGUsIHIuZnJvbSkuYmxvY2spO1xyXG4gICAgaWYgKCF0b2tlbnMuZXZlcnkoYyA9PiBjKSlcclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIGxldCBjb21tZW50cyA9IHJhbmdlcy5tYXAoKHIsIGkpID0+IGZpbmRCbG9ja0NvbW1lbnQoc3RhdGUsIHRva2Vuc1tpXSwgci5mcm9tLCByLnRvKSk7XHJcbiAgICBpZiAob3B0aW9uICE9IDIgLyogQ29tbWVudE9wdGlvbi5VbmNvbW1lbnQgKi8gJiYgIWNvbW1lbnRzLmV2ZXJ5KGMgPT4gYykpIHtcclxuICAgICAgICByZXR1cm4geyBjaGFuZ2VzOiBzdGF0ZS5jaGFuZ2VzKHJhbmdlcy5tYXAoKHJhbmdlLCBpKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAoY29tbWVudHNbaV0pXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFt7IGZyb206IHJhbmdlLmZyb20sIGluc2VydDogdG9rZW5zW2ldLm9wZW4gKyBcIiBcIiB9LCB7IGZyb206IHJhbmdlLnRvLCBpbnNlcnQ6IFwiIFwiICsgdG9rZW5zW2ldLmNsb3NlIH1dO1xyXG4gICAgICAgICAgICB9KSkgfTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKG9wdGlvbiAhPSAxIC8qIENvbW1lbnRPcHRpb24uQ29tbWVudCAqLyAmJiBjb21tZW50cy5zb21lKGMgPT4gYykpIHtcclxuICAgICAgICBsZXQgY2hhbmdlcyA9IFtdO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBjb21tZW50OyBpIDwgY29tbWVudHMubGVuZ3RoOyBpKyspXHJcbiAgICAgICAgICAgIGlmIChjb21tZW50ID0gY29tbWVudHNbaV0pIHtcclxuICAgICAgICAgICAgICAgIGxldCB0b2tlbiA9IHRva2Vuc1tpXSwgeyBvcGVuLCBjbG9zZSB9ID0gY29tbWVudDtcclxuICAgICAgICAgICAgICAgIGNoYW5nZXMucHVzaCh7IGZyb206IG9wZW4ucG9zIC0gdG9rZW4ub3Blbi5sZW5ndGgsIHRvOiBvcGVuLnBvcyArIG9wZW4ubWFyZ2luIH0sIHsgZnJvbTogY2xvc2UucG9zIC0gY2xvc2UubWFyZ2luLCB0bzogY2xvc2UucG9zICsgdG9rZW4uY2xvc2UubGVuZ3RoIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHsgY2hhbmdlcyB9O1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG51bGw7XHJcbn1cclxuLy8gUGVyZm9ybXMgdG9nZ2xlLCBjb21tZW50IGFuZCB1bmNvbW1lbnQgb2YgbGluZSBjb21tZW50cy5cclxuZnVuY3Rpb24gY2hhbmdlTGluZUNvbW1lbnQob3B0aW9uLCBzdGF0ZSwgcmFuZ2VzID0gc3RhdGUuc2VsZWN0aW9uLnJhbmdlcykge1xyXG4gICAgbGV0IGxpbmVzID0gW107XHJcbiAgICBsZXQgcHJldkxpbmUgPSAtMTtcclxuICAgIGZvciAobGV0IHsgZnJvbSwgdG8gfSBvZiByYW5nZXMpIHtcclxuICAgICAgICBsZXQgc3RhcnRJID0gbGluZXMubGVuZ3RoLCBtaW5JbmRlbnQgPSAxZTk7XHJcbiAgICAgICAgZm9yIChsZXQgcG9zID0gZnJvbTsgcG9zIDw9IHRvOykge1xyXG4gICAgICAgICAgICBsZXQgbGluZSA9IHN0YXRlLmRvYy5saW5lQXQocG9zKTtcclxuICAgICAgICAgICAgaWYgKGxpbmUuZnJvbSA+IHByZXZMaW5lICYmIChmcm9tID09IHRvIHx8IHRvID4gbGluZS5mcm9tKSkge1xyXG4gICAgICAgICAgICAgICAgcHJldkxpbmUgPSBsaW5lLmZyb207XHJcbiAgICAgICAgICAgICAgICBsZXQgdG9rZW4gPSBnZXRDb25maWcoc3RhdGUsIHBvcykubGluZTtcclxuICAgICAgICAgICAgICAgIGlmICghdG9rZW4pXHJcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICBsZXQgaW5kZW50ID0gL15cXHMqLy5leGVjKGxpbmUudGV4dClbMF0ubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgbGV0IGVtcHR5ID0gaW5kZW50ID09IGxpbmUubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgbGV0IGNvbW1lbnQgPSBsaW5lLnRleHQuc2xpY2UoaW5kZW50LCBpbmRlbnQgKyB0b2tlbi5sZW5ndGgpID09IHRva2VuID8gaW5kZW50IDogLTE7XHJcbiAgICAgICAgICAgICAgICBpZiAoaW5kZW50IDwgbGluZS50ZXh0Lmxlbmd0aCAmJiBpbmRlbnQgPCBtaW5JbmRlbnQpXHJcbiAgICAgICAgICAgICAgICAgICAgbWluSW5kZW50ID0gaW5kZW50O1xyXG4gICAgICAgICAgICAgICAgbGluZXMucHVzaCh7IGxpbmUsIGNvbW1lbnQsIHRva2VuLCBpbmRlbnQsIGVtcHR5LCBzaW5nbGU6IGZhbHNlIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHBvcyA9IGxpbmUudG8gKyAxO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobWluSW5kZW50IDwgMWU5KVxyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gc3RhcnRJOyBpIDwgbGluZXMubGVuZ3RoOyBpKyspXHJcbiAgICAgICAgICAgICAgICBpZiAobGluZXNbaV0uaW5kZW50IDwgbGluZXNbaV0ubGluZS50ZXh0Lmxlbmd0aClcclxuICAgICAgICAgICAgICAgICAgICBsaW5lc1tpXS5pbmRlbnQgPSBtaW5JbmRlbnQ7XHJcbiAgICAgICAgaWYgKGxpbmVzLmxlbmd0aCA9PSBzdGFydEkgKyAxKVxyXG4gICAgICAgICAgICBsaW5lc1tzdGFydEldLnNpbmdsZSA9IHRydWU7XHJcbiAgICB9XHJcbiAgICBpZiAob3B0aW9uICE9IDIgLyogQ29tbWVudE9wdGlvbi5VbmNvbW1lbnQgKi8gJiYgbGluZXMuc29tZShsID0+IGwuY29tbWVudCA8IDAgJiYgKCFsLmVtcHR5IHx8IGwuc2luZ2xlKSkpIHtcclxuICAgICAgICBsZXQgY2hhbmdlcyA9IFtdO1xyXG4gICAgICAgIGZvciAobGV0IHsgbGluZSwgdG9rZW4sIGluZGVudCwgZW1wdHksIHNpbmdsZSB9IG9mIGxpbmVzKVxyXG4gICAgICAgICAgICBpZiAoc2luZ2xlIHx8ICFlbXB0eSlcclxuICAgICAgICAgICAgICAgIGNoYW5nZXMucHVzaCh7IGZyb206IGxpbmUuZnJvbSArIGluZGVudCwgaW5zZXJ0OiB0b2tlbiArIFwiIFwiIH0pO1xyXG4gICAgICAgIGxldCBjaGFuZ2VTZXQgPSBzdGF0ZS5jaGFuZ2VzKGNoYW5nZXMpO1xyXG4gICAgICAgIHJldHVybiB7IGNoYW5nZXM6IGNoYW5nZVNldCwgc2VsZWN0aW9uOiBzdGF0ZS5zZWxlY3Rpb24ubWFwKGNoYW5nZVNldCwgMSkgfTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKG9wdGlvbiAhPSAxIC8qIENvbW1lbnRPcHRpb24uQ29tbWVudCAqLyAmJiBsaW5lcy5zb21lKGwgPT4gbC5jb21tZW50ID49IDApKSB7XHJcbiAgICAgICAgbGV0IGNoYW5nZXMgPSBbXTtcclxuICAgICAgICBmb3IgKGxldCB7IGxpbmUsIGNvbW1lbnQsIHRva2VuIH0gb2YgbGluZXMpXHJcbiAgICAgICAgICAgIGlmIChjb21tZW50ID49IDApIHtcclxuICAgICAgICAgICAgICAgIGxldCBmcm9tID0gbGluZS5mcm9tICsgY29tbWVudCwgdG8gPSBmcm9tICsgdG9rZW4ubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgaWYgKGxpbmUudGV4dFt0byAtIGxpbmUuZnJvbV0gPT0gXCIgXCIpXHJcbiAgICAgICAgICAgICAgICAgICAgdG8rKztcclxuICAgICAgICAgICAgICAgIGNoYW5nZXMucHVzaCh7IGZyb20sIHRvIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHsgY2hhbmdlcyB9O1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG51bGw7XHJcbn1cclxuXHJcbmNvbnN0IGZyb21IaXN0b3J5ID0gLypAX19QVVJFX18qL0Fubm90YXRpb24uZGVmaW5lKCk7XHJcbi8qKlxyXG5UcmFuc2FjdGlvbiBhbm5vdGF0aW9uIHRoYXQgd2lsbCBwcmV2ZW50IHRoYXQgdHJhbnNhY3Rpb24gZnJvbVxyXG5iZWluZyBjb21iaW5lZCB3aXRoIG90aGVyIHRyYW5zYWN0aW9ucyBpbiB0aGUgdW5kbyBoaXN0b3J5LiBHaXZlblxyXG5gXCJiZWZvcmVcImAsIGl0J2xsIHByZXZlbnQgbWVyZ2luZyB3aXRoIHByZXZpb3VzIHRyYW5zYWN0aW9ucy4gV2l0aFxyXG5gXCJhZnRlclwiYCwgc3Vic2VxdWVudCB0cmFuc2FjdGlvbnMgd29uJ3QgYmUgY29tYmluZWQgd2l0aCB0aGlzXHJcbm9uZS4gV2l0aCBgXCJmdWxsXCJgLCB0aGUgdHJhbnNhY3Rpb24gaXMgaXNvbGF0ZWQgb24gYm90aCBzaWRlcy5cclxuKi9cclxuY29uc3QgaXNvbGF0ZUhpc3RvcnkgPSAvKkBfX1BVUkVfXyovQW5ub3RhdGlvbi5kZWZpbmUoKTtcclxuLyoqXHJcblRoaXMgZmFjZXQgcHJvdmlkZXMgYSB3YXkgdG8gcmVnaXN0ZXIgZnVuY3Rpb25zIHRoYXQsIGdpdmVuIGFcclxudHJhbnNhY3Rpb24sIHByb3ZpZGUgYSBzZXQgb2YgZWZmZWN0cyB0aGF0IHRoZSBoaXN0b3J5IHNob3VsZFxyXG5zdG9yZSB3aGVuIGludmVydGluZyB0aGUgdHJhbnNhY3Rpb24uIFRoaXMgY2FuIGJlIHVzZWQgdG9cclxuaW50ZWdyYXRlIHNvbWUga2luZHMgb2YgZWZmZWN0cyBpbiB0aGUgaGlzdG9yeSwgc28gdGhhdCB0aGV5IGNhblxyXG5iZSB1bmRvbmUgKGFuZCByZWRvbmUgYWdhaW4pLlxyXG4qL1xyXG5jb25zdCBpbnZlcnRlZEVmZmVjdHMgPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKCk7XHJcbmNvbnN0IGhpc3RvcnlDb25maWcgPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKHtcclxuICAgIGNvbWJpbmUoY29uZmlncykge1xyXG4gICAgICAgIHJldHVybiBjb21iaW5lQ29uZmlnKGNvbmZpZ3MsIHtcclxuICAgICAgICAgICAgbWluRGVwdGg6IDEwMCxcclxuICAgICAgICAgICAgbmV3R3JvdXBEZWxheTogNTAwXHJcbiAgICAgICAgfSwgeyBtaW5EZXB0aDogTWF0aC5tYXgsIG5ld0dyb3VwRGVsYXk6IE1hdGgubWluIH0pO1xyXG4gICAgfVxyXG59KTtcclxuZnVuY3Rpb24gY2hhbmdlRW5kKGNoYW5nZXMpIHtcclxuICAgIGxldCBlbmQgPSAwO1xyXG4gICAgY2hhbmdlcy5pdGVyQ2hhbmdlZFJhbmdlcygoXywgdG8pID0+IGVuZCA9IHRvKTtcclxuICAgIHJldHVybiBlbmQ7XHJcbn1cclxuY29uc3QgaGlzdG9yeUZpZWxkXyA9IC8qQF9fUFVSRV9fKi9TdGF0ZUZpZWxkLmRlZmluZSh7XHJcbiAgICBjcmVhdGUoKSB7XHJcbiAgICAgICAgcmV0dXJuIEhpc3RvcnlTdGF0ZS5lbXB0eTtcclxuICAgIH0sXHJcbiAgICB1cGRhdGUoc3RhdGUsIHRyKSB7XHJcbiAgICAgICAgbGV0IGNvbmZpZyA9IHRyLnN0YXRlLmZhY2V0KGhpc3RvcnlDb25maWcpO1xyXG4gICAgICAgIGxldCBmcm9tSGlzdCA9IHRyLmFubm90YXRpb24oZnJvbUhpc3RvcnkpO1xyXG4gICAgICAgIGlmIChmcm9tSGlzdCkge1xyXG4gICAgICAgICAgICBsZXQgc2VsZWN0aW9uID0gdHIuZG9jQ2hhbmdlZCA/IEVkaXRvclNlbGVjdGlvbi5zaW5nbGUoY2hhbmdlRW5kKHRyLmNoYW5nZXMpKSA6IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgbGV0IGl0ZW0gPSBIaXN0RXZlbnQuZnJvbVRyYW5zYWN0aW9uKHRyLCBzZWxlY3Rpb24pLCBmcm9tID0gZnJvbUhpc3Quc2lkZTtcclxuICAgICAgICAgICAgbGV0IG90aGVyID0gZnJvbSA9PSAwIC8qIEJyYW5jaE5hbWUuRG9uZSAqLyA/IHN0YXRlLnVuZG9uZSA6IHN0YXRlLmRvbmU7XHJcbiAgICAgICAgICAgIGlmIChpdGVtKVxyXG4gICAgICAgICAgICAgICAgb3RoZXIgPSB1cGRhdGVCcmFuY2gob3RoZXIsIG90aGVyLmxlbmd0aCwgY29uZmlnLm1pbkRlcHRoLCBpdGVtKTtcclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgb3RoZXIgPSBhZGRTZWxlY3Rpb24ob3RoZXIsIHRyLnN0YXJ0U3RhdGUuc2VsZWN0aW9uKTtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBIaXN0b3J5U3RhdGUoZnJvbSA9PSAwIC8qIEJyYW5jaE5hbWUuRG9uZSAqLyA/IGZyb21IaXN0LnJlc3QgOiBvdGhlciwgZnJvbSA9PSAwIC8qIEJyYW5jaE5hbWUuRG9uZSAqLyA/IG90aGVyIDogZnJvbUhpc3QucmVzdCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCBpc29sYXRlID0gdHIuYW5ub3RhdGlvbihpc29sYXRlSGlzdG9yeSk7XHJcbiAgICAgICAgaWYgKGlzb2xhdGUgPT0gXCJmdWxsXCIgfHwgaXNvbGF0ZSA9PSBcImJlZm9yZVwiKVxyXG4gICAgICAgICAgICBzdGF0ZSA9IHN0YXRlLmlzb2xhdGUoKTtcclxuICAgICAgICBpZiAodHIuYW5ub3RhdGlvbihUcmFuc2FjdGlvbi5hZGRUb0hpc3RvcnkpID09PSBmYWxzZSlcclxuICAgICAgICAgICAgcmV0dXJuICF0ci5jaGFuZ2VzLmVtcHR5ID8gc3RhdGUuYWRkTWFwcGluZyh0ci5jaGFuZ2VzLmRlc2MpIDogc3RhdGU7XHJcbiAgICAgICAgbGV0IGV2ZW50ID0gSGlzdEV2ZW50LmZyb21UcmFuc2FjdGlvbih0cik7XHJcbiAgICAgICAgbGV0IHRpbWUgPSB0ci5hbm5vdGF0aW9uKFRyYW5zYWN0aW9uLnRpbWUpLCB1c2VyRXZlbnQgPSB0ci5hbm5vdGF0aW9uKFRyYW5zYWN0aW9uLnVzZXJFdmVudCk7XHJcbiAgICAgICAgaWYgKGV2ZW50KVxyXG4gICAgICAgICAgICBzdGF0ZSA9IHN0YXRlLmFkZENoYW5nZXMoZXZlbnQsIHRpbWUsIHVzZXJFdmVudCwgY29uZmlnLm5ld0dyb3VwRGVsYXksIGNvbmZpZy5taW5EZXB0aCk7XHJcbiAgICAgICAgZWxzZSBpZiAodHIuc2VsZWN0aW9uKVxyXG4gICAgICAgICAgICBzdGF0ZSA9IHN0YXRlLmFkZFNlbGVjdGlvbih0ci5zdGFydFN0YXRlLnNlbGVjdGlvbiwgdGltZSwgdXNlckV2ZW50LCBjb25maWcubmV3R3JvdXBEZWxheSk7XHJcbiAgICAgICAgaWYgKGlzb2xhdGUgPT0gXCJmdWxsXCIgfHwgaXNvbGF0ZSA9PSBcImFmdGVyXCIpXHJcbiAgICAgICAgICAgIHN0YXRlID0gc3RhdGUuaXNvbGF0ZSgpO1xyXG4gICAgICAgIHJldHVybiBzdGF0ZTtcclxuICAgIH0sXHJcbiAgICB0b0pTT04odmFsdWUpIHtcclxuICAgICAgICByZXR1cm4geyBkb25lOiB2YWx1ZS5kb25lLm1hcChlID0+IGUudG9KU09OKCkpLCB1bmRvbmU6IHZhbHVlLnVuZG9uZS5tYXAoZSA9PiBlLnRvSlNPTigpKSB9O1xyXG4gICAgfSxcclxuICAgIGZyb21KU09OKGpzb24pIHtcclxuICAgICAgICByZXR1cm4gbmV3IEhpc3RvcnlTdGF0ZShqc29uLmRvbmUubWFwKEhpc3RFdmVudC5mcm9tSlNPTiksIGpzb24udW5kb25lLm1hcChIaXN0RXZlbnQuZnJvbUpTT04pKTtcclxuICAgIH1cclxufSk7XHJcbi8qKlxyXG5DcmVhdGUgYSBoaXN0b3J5IGV4dGVuc2lvbiB3aXRoIHRoZSBnaXZlbiBjb25maWd1cmF0aW9uLlxyXG4qL1xyXG5mdW5jdGlvbiBoaXN0b3J5KGNvbmZpZyA9IHt9KSB7XHJcbiAgICByZXR1cm4gW1xyXG4gICAgICAgIGhpc3RvcnlGaWVsZF8sXHJcbiAgICAgICAgaGlzdG9yeUNvbmZpZy5vZihjb25maWcpLFxyXG4gICAgICAgIEVkaXRvclZpZXcuZG9tRXZlbnRIYW5kbGVycyh7XHJcbiAgICAgICAgICAgIGJlZm9yZWlucHV0KGUsIHZpZXcpIHtcclxuICAgICAgICAgICAgICAgIGxldCBjb21tYW5kID0gZS5pbnB1dFR5cGUgPT0gXCJoaXN0b3J5VW5kb1wiID8gdW5kbyA6IGUuaW5wdXRUeXBlID09IFwiaGlzdG9yeVJlZG9cIiA/IHJlZG8gOiBudWxsO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFjb21tYW5kKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBjb21tYW5kKHZpZXcpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSlcclxuICAgIF07XHJcbn1cclxuLyoqXHJcblRoZSBzdGF0ZSBmaWVsZCB1c2VkIHRvIHN0b3JlIHRoZSBoaXN0b3J5IGRhdGEuIFNob3VsZCBwcm9iYWJseVxyXG5vbmx5IGJlIHVzZWQgd2hlbiB5b3Ugd2FudCB0b1xyXG5bc2VyaWFsaXplXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkVkaXRvclN0YXRlLnRvSlNPTikgb3JcclxuW2Rlc2VyaWFsaXplXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkVkaXRvclN0YXRlXmZyb21KU09OKSBzdGF0ZSBvYmplY3RzIGluIGEgd2F5XHJcbnRoYXQgcHJlc2VydmVzIGhpc3RvcnkuXHJcbiovXHJcbmNvbnN0IGhpc3RvcnlGaWVsZCA9IGhpc3RvcnlGaWVsZF87XHJcbmZ1bmN0aW9uIGNtZChzaWRlLCBzZWxlY3Rpb24pIHtcclxuICAgIHJldHVybiBmdW5jdGlvbiAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkge1xyXG4gICAgICAgIGlmICghc2VsZWN0aW9uICYmIHN0YXRlLnJlYWRPbmx5KVxyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgbGV0IGhpc3RvcnlTdGF0ZSA9IHN0YXRlLmZpZWxkKGhpc3RvcnlGaWVsZF8sIGZhbHNlKTtcclxuICAgICAgICBpZiAoIWhpc3RvcnlTdGF0ZSlcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIGxldCB0ciA9IGhpc3RvcnlTdGF0ZS5wb3Aoc2lkZSwgc3RhdGUsIHNlbGVjdGlvbik7XHJcbiAgICAgICAgaWYgKCF0cilcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIGRpc3BhdGNoKHRyKTtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH07XHJcbn1cclxuLyoqXHJcblVuZG8gYSBzaW5nbGUgZ3JvdXAgb2YgaGlzdG9yeSBldmVudHMuIFJldHVybnMgZmFsc2UgaWYgbm8gZ3JvdXBcclxud2FzIGF2YWlsYWJsZS5cclxuKi9cclxuY29uc3QgdW5kbyA9IC8qQF9fUFVSRV9fKi9jbWQoMCAvKiBCcmFuY2hOYW1lLkRvbmUgKi8sIGZhbHNlKTtcclxuLyoqXHJcblJlZG8gYSBncm91cCBvZiBoaXN0b3J5IGV2ZW50cy4gUmV0dXJucyBmYWxzZSBpZiBubyBncm91cCB3YXNcclxuYXZhaWxhYmxlLlxyXG4qL1xyXG5jb25zdCByZWRvID0gLypAX19QVVJFX18qL2NtZCgxIC8qIEJyYW5jaE5hbWUuVW5kb25lICovLCBmYWxzZSk7XHJcbi8qKlxyXG5VbmRvIGEgY2hhbmdlIG9yIHNlbGVjdGlvbiBjaGFuZ2UuXHJcbiovXHJcbmNvbnN0IHVuZG9TZWxlY3Rpb24gPSAvKkBfX1BVUkVfXyovY21kKDAgLyogQnJhbmNoTmFtZS5Eb25lICovLCB0cnVlKTtcclxuLyoqXHJcblJlZG8gYSBjaGFuZ2Ugb3Igc2VsZWN0aW9uIGNoYW5nZS5cclxuKi9cclxuY29uc3QgcmVkb1NlbGVjdGlvbiA9IC8qQF9fUFVSRV9fKi9jbWQoMSAvKiBCcmFuY2hOYW1lLlVuZG9uZSAqLywgdHJ1ZSk7XHJcbmZ1bmN0aW9uIGRlcHRoKHNpZGUpIHtcclxuICAgIHJldHVybiBmdW5jdGlvbiAoc3RhdGUpIHtcclxuICAgICAgICBsZXQgaGlzdFN0YXRlID0gc3RhdGUuZmllbGQoaGlzdG9yeUZpZWxkXywgZmFsc2UpO1xyXG4gICAgICAgIGlmICghaGlzdFN0YXRlKVxyXG4gICAgICAgICAgICByZXR1cm4gMDtcclxuICAgICAgICBsZXQgYnJhbmNoID0gc2lkZSA9PSAwIC8qIEJyYW5jaE5hbWUuRG9uZSAqLyA/IGhpc3RTdGF0ZS5kb25lIDogaGlzdFN0YXRlLnVuZG9uZTtcclxuICAgICAgICByZXR1cm4gYnJhbmNoLmxlbmd0aCAtIChicmFuY2gubGVuZ3RoICYmICFicmFuY2hbMF0uY2hhbmdlcyA/IDEgOiAwKTtcclxuICAgIH07XHJcbn1cclxuLyoqXHJcblRoZSBhbW91bnQgb2YgdW5kb2FibGUgY2hhbmdlIGV2ZW50cyBhdmFpbGFibGUgaW4gYSBnaXZlbiBzdGF0ZS5cclxuKi9cclxuY29uc3QgdW5kb0RlcHRoID0gLypAX19QVVJFX18qL2RlcHRoKDAgLyogQnJhbmNoTmFtZS5Eb25lICovKTtcclxuLyoqXHJcblRoZSBhbW91bnQgb2YgcmVkb2FibGUgY2hhbmdlIGV2ZW50cyBhdmFpbGFibGUgaW4gYSBnaXZlbiBzdGF0ZS5cclxuKi9cclxuY29uc3QgcmVkb0RlcHRoID0gLypAX19QVVJFX18qL2RlcHRoKDEgLyogQnJhbmNoTmFtZS5VbmRvbmUgKi8pO1xyXG4vLyBIaXN0b3J5IGV2ZW50cyBzdG9yZSBncm91cHMgb2YgY2hhbmdlcyBvciBlZmZlY3RzIHRoYXQgbmVlZCB0byBiZVxyXG4vLyB1bmRvbmUvcmVkb25lIHRvZ2V0aGVyLlxyXG5jbGFzcyBIaXN0RXZlbnQge1xyXG4gICAgY29uc3RydWN0b3IoXHJcbiAgICAvLyBUaGUgY2hhbmdlcyBpbiB0aGlzIGV2ZW50LiBOb3JtYWwgZXZlbnRzIGhvbGQgYXQgbGVhc3Qgb25lXHJcbiAgICAvLyBjaGFuZ2Ugb3IgZWZmZWN0LiBCdXQgaXQgbWF5IGJlIG5lY2Vzc2FyeSB0byBzdG9yZSBzZWxlY3Rpb25cclxuICAgIC8vIGV2ZW50cyBiZWZvcmUgdGhlIGZpcnN0IGNoYW5nZSwgaW4gd2hpY2ggY2FzZSBhIHNwZWNpYWwgdHlwZSBvZlxyXG4gICAgLy8gaW5zdGFuY2UgaXMgY3JlYXRlZCB3aGljaCBkb2Vzbid0IGhvbGQgYW55IGNoYW5nZXMsIHdpdGhcclxuICAgIC8vIGNoYW5nZXMgPT0gc3RhcnRTZWxlY3Rpb24gPT0gdW5kZWZpbmVkXHJcbiAgICBjaGFuZ2VzLCBcclxuICAgIC8vIFRoZSBlZmZlY3RzIGFzc29jaWF0ZWQgd2l0aCB0aGlzIGV2ZW50XHJcbiAgICBlZmZlY3RzLCBcclxuICAgIC8vIEFjY3VtdWxhdGVkIG1hcHBpbmcgKGZyb20gYWRkVG9IaXN0b3J5PT1mYWxzZSkgdGhhdCBzaG91bGQgYmVcclxuICAgIC8vIGFwcGxpZWQgdG8gZXZlbnRzIGJlbG93IHRoaXMgb25lLlxyXG4gICAgbWFwcGVkLCBcclxuICAgIC8vIFRoZSBzZWxlY3Rpb24gYmVmb3JlIHRoaXMgZXZlbnRcclxuICAgIHN0YXJ0U2VsZWN0aW9uLCBcclxuICAgIC8vIFN0b3JlcyBzZWxlY3Rpb24gY2hhbmdlcyBhZnRlciB0aGlzIGV2ZW50LCB0byBiZSB1c2VkIGZvclxyXG4gICAgLy8gc2VsZWN0aW9uIHVuZG8vcmVkby5cclxuICAgIHNlbGVjdGlvbnNBZnRlcikge1xyXG4gICAgICAgIHRoaXMuY2hhbmdlcyA9IGNoYW5nZXM7XHJcbiAgICAgICAgdGhpcy5lZmZlY3RzID0gZWZmZWN0cztcclxuICAgICAgICB0aGlzLm1hcHBlZCA9IG1hcHBlZDtcclxuICAgICAgICB0aGlzLnN0YXJ0U2VsZWN0aW9uID0gc3RhcnRTZWxlY3Rpb247XHJcbiAgICAgICAgdGhpcy5zZWxlY3Rpb25zQWZ0ZXIgPSBzZWxlY3Rpb25zQWZ0ZXI7XHJcbiAgICB9XHJcbiAgICBzZXRTZWxBZnRlcihhZnRlcikge1xyXG4gICAgICAgIHJldHVybiBuZXcgSGlzdEV2ZW50KHRoaXMuY2hhbmdlcywgdGhpcy5lZmZlY3RzLCB0aGlzLm1hcHBlZCwgdGhpcy5zdGFydFNlbGVjdGlvbiwgYWZ0ZXIpO1xyXG4gICAgfVxyXG4gICAgdG9KU09OKCkge1xyXG4gICAgICAgIHZhciBfYSwgX2IsIF9jO1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIGNoYW5nZXM6IChfYSA9IHRoaXMuY2hhbmdlcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnRvSlNPTigpLFxyXG4gICAgICAgICAgICBtYXBwZWQ6IChfYiA9IHRoaXMubWFwcGVkKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IudG9KU09OKCksXHJcbiAgICAgICAgICAgIHN0YXJ0U2VsZWN0aW9uOiAoX2MgPSB0aGlzLnN0YXJ0U2VsZWN0aW9uKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MudG9KU09OKCksXHJcbiAgICAgICAgICAgIHNlbGVjdGlvbnNBZnRlcjogdGhpcy5zZWxlY3Rpb25zQWZ0ZXIubWFwKHMgPT4gcy50b0pTT04oKSlcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGZyb21KU09OKGpzb24pIHtcclxuICAgICAgICByZXR1cm4gbmV3IEhpc3RFdmVudChqc29uLmNoYW5nZXMgJiYgQ2hhbmdlU2V0LmZyb21KU09OKGpzb24uY2hhbmdlcyksIFtdLCBqc29uLm1hcHBlZCAmJiBDaGFuZ2VEZXNjLmZyb21KU09OKGpzb24ubWFwcGVkKSwganNvbi5zdGFydFNlbGVjdGlvbiAmJiBFZGl0b3JTZWxlY3Rpb24uZnJvbUpTT04oanNvbi5zdGFydFNlbGVjdGlvbiksIGpzb24uc2VsZWN0aW9uc0FmdGVyLm1hcChFZGl0b3JTZWxlY3Rpb24uZnJvbUpTT04pKTtcclxuICAgIH1cclxuICAgIC8vIFRoaXMgZG9lcyBub3QgY2hlY2sgYGFkZFRvSGlzdG9yeWAgYW5kIHN1Y2gsIGl0IGFzc3VtZXMgdGhlXHJcbiAgICAvLyB0cmFuc2FjdGlvbiBuZWVkcyB0byBiZSBjb252ZXJ0ZWQgdG8gYW4gaXRlbS4gUmV0dXJucyBudWxsIHdoZW5cclxuICAgIC8vIHRoZXJlIGFyZSBubyBjaGFuZ2VzIG9yIGVmZmVjdHMgaW4gdGhlIHRyYW5zYWN0aW9uLlxyXG4gICAgc3RhdGljIGZyb21UcmFuc2FjdGlvbih0ciwgc2VsZWN0aW9uKSB7XHJcbiAgICAgICAgbGV0IGVmZmVjdHMgPSBub25lO1xyXG4gICAgICAgIGZvciAobGV0IGludmVydCBvZiB0ci5zdGFydFN0YXRlLmZhY2V0KGludmVydGVkRWZmZWN0cykpIHtcclxuICAgICAgICAgICAgbGV0IHJlc3VsdCA9IGludmVydCh0cik7XHJcbiAgICAgICAgICAgIGlmIChyZXN1bHQubGVuZ3RoKVxyXG4gICAgICAgICAgICAgICAgZWZmZWN0cyA9IGVmZmVjdHMuY29uY2F0KHJlc3VsdCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghZWZmZWN0cy5sZW5ndGggJiYgdHIuY2hhbmdlcy5lbXB0eSlcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBIaXN0RXZlbnQodHIuY2hhbmdlcy5pbnZlcnQodHIuc3RhcnRTdGF0ZS5kb2MpLCBlZmZlY3RzLCB1bmRlZmluZWQsIHNlbGVjdGlvbiB8fCB0ci5zdGFydFN0YXRlLnNlbGVjdGlvbiwgbm9uZSk7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgc2VsZWN0aW9uKHNlbGVjdGlvbnMpIHtcclxuICAgICAgICByZXR1cm4gbmV3IEhpc3RFdmVudCh1bmRlZmluZWQsIG5vbmUsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBzZWxlY3Rpb25zKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiB1cGRhdGVCcmFuY2goYnJhbmNoLCB0bywgbWF4TGVuLCBuZXdFdmVudCkge1xyXG4gICAgbGV0IHN0YXJ0ID0gdG8gKyAxID4gbWF4TGVuICsgMjAgPyB0byAtIG1heExlbiAtIDEgOiAwO1xyXG4gICAgbGV0IG5ld0JyYW5jaCA9IGJyYW5jaC5zbGljZShzdGFydCwgdG8pO1xyXG4gICAgbmV3QnJhbmNoLnB1c2gobmV3RXZlbnQpO1xyXG4gICAgcmV0dXJuIG5ld0JyYW5jaDtcclxufVxyXG5mdW5jdGlvbiBpc0FkamFjZW50KGEsIGIpIHtcclxuICAgIGxldCByYW5nZXMgPSBbXSwgaXNBZGphY2VudCA9IGZhbHNlO1xyXG4gICAgYS5pdGVyQ2hhbmdlZFJhbmdlcygoZiwgdCkgPT4gcmFuZ2VzLnB1c2goZiwgdCkpO1xyXG4gICAgYi5pdGVyQ2hhbmdlZFJhbmdlcygoX2YsIF90LCBmLCB0KSA9PiB7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByYW5nZXMubGVuZ3RoOykge1xyXG4gICAgICAgICAgICBsZXQgZnJvbSA9IHJhbmdlc1tpKytdLCB0byA9IHJhbmdlc1tpKytdO1xyXG4gICAgICAgICAgICBpZiAodCA+PSBmcm9tICYmIGYgPD0gdG8pXHJcbiAgICAgICAgICAgICAgICBpc0FkamFjZW50ID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuICAgIHJldHVybiBpc0FkamFjZW50O1xyXG59XHJcbmZ1bmN0aW9uIGVxU2VsZWN0aW9uU2hhcGUoYSwgYikge1xyXG4gICAgcmV0dXJuIGEucmFuZ2VzLmxlbmd0aCA9PSBiLnJhbmdlcy5sZW5ndGggJiZcclxuICAgICAgICBhLnJhbmdlcy5maWx0ZXIoKHIsIGkpID0+IHIuZW1wdHkgIT0gYi5yYW5nZXNbaV0uZW1wdHkpLmxlbmd0aCA9PT0gMDtcclxufVxyXG5mdW5jdGlvbiBjb25jKGEsIGIpIHtcclxuICAgIHJldHVybiAhYS5sZW5ndGggPyBiIDogIWIubGVuZ3RoID8gYSA6IGEuY29uY2F0KGIpO1xyXG59XHJcbmNvbnN0IG5vbmUgPSBbXTtcclxuY29uc3QgTWF4U2VsZWN0aW9uc1BlckV2ZW50ID0gMjAwO1xyXG5mdW5jdGlvbiBhZGRTZWxlY3Rpb24oYnJhbmNoLCBzZWxlY3Rpb24pIHtcclxuICAgIGlmICghYnJhbmNoLmxlbmd0aCkge1xyXG4gICAgICAgIHJldHVybiBbSGlzdEV2ZW50LnNlbGVjdGlvbihbc2VsZWN0aW9uXSldO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgbGV0IGxhc3RFdmVudCA9IGJyYW5jaFticmFuY2gubGVuZ3RoIC0gMV07XHJcbiAgICAgICAgbGV0IHNlbHMgPSBsYXN0RXZlbnQuc2VsZWN0aW9uc0FmdGVyLnNsaWNlKE1hdGgubWF4KDAsIGxhc3RFdmVudC5zZWxlY3Rpb25zQWZ0ZXIubGVuZ3RoIC0gTWF4U2VsZWN0aW9uc1BlckV2ZW50KSk7XHJcbiAgICAgICAgaWYgKHNlbHMubGVuZ3RoICYmIHNlbHNbc2Vscy5sZW5ndGggLSAxXS5lcShzZWxlY3Rpb24pKVxyXG4gICAgICAgICAgICByZXR1cm4gYnJhbmNoO1xyXG4gICAgICAgIHNlbHMucHVzaChzZWxlY3Rpb24pO1xyXG4gICAgICAgIHJldHVybiB1cGRhdGVCcmFuY2goYnJhbmNoLCBicmFuY2gubGVuZ3RoIC0gMSwgMWU5LCBsYXN0RXZlbnQuc2V0U2VsQWZ0ZXIoc2VscykpO1xyXG4gICAgfVxyXG59XHJcbi8vIEFzc3VtZXMgdGhlIHRvcCBpdGVtIGhhcyBvbmUgb3IgbW9yZSBzZWxlY3Rpb25BZnRlciB2YWx1ZXNcclxuZnVuY3Rpb24gcG9wU2VsZWN0aW9uKGJyYW5jaCkge1xyXG4gICAgbGV0IGxhc3QgPSBicmFuY2hbYnJhbmNoLmxlbmd0aCAtIDFdO1xyXG4gICAgbGV0IG5ld0JyYW5jaCA9IGJyYW5jaC5zbGljZSgpO1xyXG4gICAgbmV3QnJhbmNoW2JyYW5jaC5sZW5ndGggLSAxXSA9IGxhc3Quc2V0U2VsQWZ0ZXIobGFzdC5zZWxlY3Rpb25zQWZ0ZXIuc2xpY2UoMCwgbGFzdC5zZWxlY3Rpb25zQWZ0ZXIubGVuZ3RoIC0gMSkpO1xyXG4gICAgcmV0dXJuIG5ld0JyYW5jaDtcclxufVxyXG4vLyBBZGQgYSBtYXBwaW5nIHRvIHRoZSB0b3AgZXZlbnQgaW4gdGhlIGdpdmVuIGJyYW5jaC4gSWYgdGhpcyBtYXBzXHJcbi8vIGF3YXkgYWxsIHRoZSBjaGFuZ2VzIGFuZCBlZmZlY3RzIGluIHRoYXQgaXRlbSwgZHJvcCBpdCBhbmRcclxuLy8gcHJvcGFnYXRlIHRoZSBtYXBwaW5nIHRvIHRoZSBuZXh0IGl0ZW0uXHJcbmZ1bmN0aW9uIGFkZE1hcHBpbmdUb0JyYW5jaChicmFuY2gsIG1hcHBpbmcpIHtcclxuICAgIGlmICghYnJhbmNoLmxlbmd0aClcclxuICAgICAgICByZXR1cm4gYnJhbmNoO1xyXG4gICAgbGV0IGxlbmd0aCA9IGJyYW5jaC5sZW5ndGgsIHNlbGVjdGlvbnMgPSBub25lO1xyXG4gICAgd2hpbGUgKGxlbmd0aCkge1xyXG4gICAgICAgIGxldCBldmVudCA9IG1hcEV2ZW50KGJyYW5jaFtsZW5ndGggLSAxXSwgbWFwcGluZywgc2VsZWN0aW9ucyk7XHJcbiAgICAgICAgaWYgKGV2ZW50LmNoYW5nZXMgJiYgIWV2ZW50LmNoYW5nZXMuZW1wdHkgfHwgZXZlbnQuZWZmZWN0cy5sZW5ndGgpIHsgLy8gRXZlbnQgc3Vydml2ZWQgbWFwcGluZ1xyXG4gICAgICAgICAgICBsZXQgcmVzdWx0ID0gYnJhbmNoLnNsaWNlKDAsIGxlbmd0aCk7XHJcbiAgICAgICAgICAgIHJlc3VsdFtsZW5ndGggLSAxXSA9IGV2ZW50O1xyXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHsgLy8gRHJvcCB0aGlzIGV2ZW50LCBzaW5jZSB0aGVyZSdzIG5vIGNoYW5nZXMgb3IgZWZmZWN0cyBsZWZ0XHJcbiAgICAgICAgICAgIG1hcHBpbmcgPSBldmVudC5tYXBwZWQ7XHJcbiAgICAgICAgICAgIGxlbmd0aC0tO1xyXG4gICAgICAgICAgICBzZWxlY3Rpb25zID0gZXZlbnQuc2VsZWN0aW9uc0FmdGVyO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBzZWxlY3Rpb25zLmxlbmd0aCA/IFtIaXN0RXZlbnQuc2VsZWN0aW9uKHNlbGVjdGlvbnMpXSA6IG5vbmU7XHJcbn1cclxuZnVuY3Rpb24gbWFwRXZlbnQoZXZlbnQsIG1hcHBpbmcsIGV4dHJhU2VsZWN0aW9ucykge1xyXG4gICAgbGV0IHNlbGVjdGlvbnMgPSBjb25jKGV2ZW50LnNlbGVjdGlvbnNBZnRlci5sZW5ndGggPyBldmVudC5zZWxlY3Rpb25zQWZ0ZXIubWFwKHMgPT4gcy5tYXAobWFwcGluZykpIDogbm9uZSwgZXh0cmFTZWxlY3Rpb25zKTtcclxuICAgIC8vIENoYW5nZS1sZXNzIGV2ZW50cyBkb24ndCBzdG9yZSBtYXBwaW5ncyAodGhleSBhcmUgYWx3YXlzIHRoZSBsYXN0IGV2ZW50IGluIGEgYnJhbmNoKVxyXG4gICAgaWYgKCFldmVudC5jaGFuZ2VzKVxyXG4gICAgICAgIHJldHVybiBIaXN0RXZlbnQuc2VsZWN0aW9uKHNlbGVjdGlvbnMpO1xyXG4gICAgbGV0IG1hcHBlZENoYW5nZXMgPSBldmVudC5jaGFuZ2VzLm1hcChtYXBwaW5nKSwgYmVmb3JlID0gbWFwcGluZy5tYXBEZXNjKGV2ZW50LmNoYW5nZXMsIHRydWUpO1xyXG4gICAgbGV0IGZ1bGxNYXBwaW5nID0gZXZlbnQubWFwcGVkID8gZXZlbnQubWFwcGVkLmNvbXBvc2VEZXNjKGJlZm9yZSkgOiBiZWZvcmU7XHJcbiAgICByZXR1cm4gbmV3IEhpc3RFdmVudChtYXBwZWRDaGFuZ2VzLCBTdGF0ZUVmZmVjdC5tYXBFZmZlY3RzKGV2ZW50LmVmZmVjdHMsIG1hcHBpbmcpLCBmdWxsTWFwcGluZywgZXZlbnQuc3RhcnRTZWxlY3Rpb24ubWFwKGJlZm9yZSksIHNlbGVjdGlvbnMpO1xyXG59XHJcbmNvbnN0IGpvaW5hYmxlVXNlckV2ZW50ID0gL14oaW5wdXRcXC50eXBlfGRlbGV0ZSkoJHxcXC4pLztcclxuY2xhc3MgSGlzdG9yeVN0YXRlIHtcclxuICAgIGNvbnN0cnVjdG9yKGRvbmUsIHVuZG9uZSwgcHJldlRpbWUgPSAwLCBwcmV2VXNlckV2ZW50ID0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgdGhpcy5kb25lID0gZG9uZTtcclxuICAgICAgICB0aGlzLnVuZG9uZSA9IHVuZG9uZTtcclxuICAgICAgICB0aGlzLnByZXZUaW1lID0gcHJldlRpbWU7XHJcbiAgICAgICAgdGhpcy5wcmV2VXNlckV2ZW50ID0gcHJldlVzZXJFdmVudDtcclxuICAgIH1cclxuICAgIGlzb2xhdGUoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucHJldlRpbWUgPyBuZXcgSGlzdG9yeVN0YXRlKHRoaXMuZG9uZSwgdGhpcy51bmRvbmUpIDogdGhpcztcclxuICAgIH1cclxuICAgIGFkZENoYW5nZXMoZXZlbnQsIHRpbWUsIHVzZXJFdmVudCwgbmV3R3JvdXBEZWxheSwgbWF4TGVuKSB7XHJcbiAgICAgICAgbGV0IGRvbmUgPSB0aGlzLmRvbmUsIGxhc3RFdmVudCA9IGRvbmVbZG9uZS5sZW5ndGggLSAxXTtcclxuICAgICAgICBpZiAobGFzdEV2ZW50ICYmIGxhc3RFdmVudC5jaGFuZ2VzICYmICFsYXN0RXZlbnQuY2hhbmdlcy5lbXB0eSAmJiBldmVudC5jaGFuZ2VzICYmXHJcbiAgICAgICAgICAgICghdXNlckV2ZW50IHx8IGpvaW5hYmxlVXNlckV2ZW50LnRlc3QodXNlckV2ZW50KSkgJiZcclxuICAgICAgICAgICAgKCghbGFzdEV2ZW50LnNlbGVjdGlvbnNBZnRlci5sZW5ndGggJiZcclxuICAgICAgICAgICAgICAgIHRpbWUgLSB0aGlzLnByZXZUaW1lIDwgbmV3R3JvdXBEZWxheSAmJlxyXG4gICAgICAgICAgICAgICAgaXNBZGphY2VudChsYXN0RXZlbnQuY2hhbmdlcywgZXZlbnQuY2hhbmdlcykpIHx8XHJcbiAgICAgICAgICAgICAgICAvLyBGb3IgY29tcG9zZSAoYnV0IG5vdCBjb21wb3NlLnN0YXJ0KSBldmVudHMsIGFsd2F5cyBqb2luIHdpdGggcHJldmlvdXMgZXZlbnRcclxuICAgICAgICAgICAgICAgIHVzZXJFdmVudCA9PSBcImlucHV0LnR5cGUuY29tcG9zZVwiKSkge1xyXG4gICAgICAgICAgICBkb25lID0gdXBkYXRlQnJhbmNoKGRvbmUsIGRvbmUubGVuZ3RoIC0gMSwgbWF4TGVuLCBuZXcgSGlzdEV2ZW50KGV2ZW50LmNoYW5nZXMuY29tcG9zZShsYXN0RXZlbnQuY2hhbmdlcyksIGNvbmMoZXZlbnQuZWZmZWN0cywgbGFzdEV2ZW50LmVmZmVjdHMpLCBsYXN0RXZlbnQubWFwcGVkLCBsYXN0RXZlbnQuc3RhcnRTZWxlY3Rpb24sIG5vbmUpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGRvbmUgPSB1cGRhdGVCcmFuY2goZG9uZSwgZG9uZS5sZW5ndGgsIG1heExlbiwgZXZlbnQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbmV3IEhpc3RvcnlTdGF0ZShkb25lLCBub25lLCB0aW1lLCB1c2VyRXZlbnQpO1xyXG4gICAgfVxyXG4gICAgYWRkU2VsZWN0aW9uKHNlbGVjdGlvbiwgdGltZSwgdXNlckV2ZW50LCBuZXdHcm91cERlbGF5KSB7XHJcbiAgICAgICAgbGV0IGxhc3QgPSB0aGlzLmRvbmUubGVuZ3RoID8gdGhpcy5kb25lW3RoaXMuZG9uZS5sZW5ndGggLSAxXS5zZWxlY3Rpb25zQWZ0ZXIgOiBub25lO1xyXG4gICAgICAgIGlmIChsYXN0Lmxlbmd0aCA+IDAgJiZcclxuICAgICAgICAgICAgdGltZSAtIHRoaXMucHJldlRpbWUgPCBuZXdHcm91cERlbGF5ICYmXHJcbiAgICAgICAgICAgIHVzZXJFdmVudCA9PSB0aGlzLnByZXZVc2VyRXZlbnQgJiYgdXNlckV2ZW50ICYmIC9ec2VsZWN0KCR8XFwuKS8udGVzdCh1c2VyRXZlbnQpICYmXHJcbiAgICAgICAgICAgIGVxU2VsZWN0aW9uU2hhcGUobGFzdFtsYXN0Lmxlbmd0aCAtIDFdLCBzZWxlY3Rpb24pKVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICByZXR1cm4gbmV3IEhpc3RvcnlTdGF0ZShhZGRTZWxlY3Rpb24odGhpcy5kb25lLCBzZWxlY3Rpb24pLCB0aGlzLnVuZG9uZSwgdGltZSwgdXNlckV2ZW50KTtcclxuICAgIH1cclxuICAgIGFkZE1hcHBpbmcobWFwcGluZykge1xyXG4gICAgICAgIHJldHVybiBuZXcgSGlzdG9yeVN0YXRlKGFkZE1hcHBpbmdUb0JyYW5jaCh0aGlzLmRvbmUsIG1hcHBpbmcpLCBhZGRNYXBwaW5nVG9CcmFuY2godGhpcy51bmRvbmUsIG1hcHBpbmcpLCB0aGlzLnByZXZUaW1lLCB0aGlzLnByZXZVc2VyRXZlbnQpO1xyXG4gICAgfVxyXG4gICAgcG9wKHNpZGUsIHN0YXRlLCBzZWxlY3Rpb24pIHtcclxuICAgICAgICBsZXQgYnJhbmNoID0gc2lkZSA9PSAwIC8qIEJyYW5jaE5hbWUuRG9uZSAqLyA/IHRoaXMuZG9uZSA6IHRoaXMudW5kb25lO1xyXG4gICAgICAgIGlmIChicmFuY2gubGVuZ3RoID09IDApXHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIGxldCBldmVudCA9IGJyYW5jaFticmFuY2gubGVuZ3RoIC0gMV07XHJcbiAgICAgICAgaWYgKHNlbGVjdGlvbiAmJiBldmVudC5zZWxlY3Rpb25zQWZ0ZXIubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBzdGF0ZS51cGRhdGUoe1xyXG4gICAgICAgICAgICAgICAgc2VsZWN0aW9uOiBldmVudC5zZWxlY3Rpb25zQWZ0ZXJbZXZlbnQuc2VsZWN0aW9uc0FmdGVyLmxlbmd0aCAtIDFdLFxyXG4gICAgICAgICAgICAgICAgYW5ub3RhdGlvbnM6IGZyb21IaXN0b3J5Lm9mKHsgc2lkZSwgcmVzdDogcG9wU2VsZWN0aW9uKGJyYW5jaCkgfSksXHJcbiAgICAgICAgICAgICAgICB1c2VyRXZlbnQ6IHNpZGUgPT0gMCAvKiBCcmFuY2hOYW1lLkRvbmUgKi8gPyBcInNlbGVjdC51bmRvXCIgOiBcInNlbGVjdC5yZWRvXCIsXHJcbiAgICAgICAgICAgICAgICBzY3JvbGxJbnRvVmlldzogdHJ1ZVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoIWV2ZW50LmNoYW5nZXMpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBsZXQgcmVzdCA9IGJyYW5jaC5sZW5ndGggPT0gMSA/IG5vbmUgOiBicmFuY2guc2xpY2UoMCwgYnJhbmNoLmxlbmd0aCAtIDEpO1xyXG4gICAgICAgICAgICBpZiAoZXZlbnQubWFwcGVkKVxyXG4gICAgICAgICAgICAgICAgcmVzdCA9IGFkZE1hcHBpbmdUb0JyYW5jaChyZXN0LCBldmVudC5tYXBwZWQpO1xyXG4gICAgICAgICAgICByZXR1cm4gc3RhdGUudXBkYXRlKHtcclxuICAgICAgICAgICAgICAgIGNoYW5nZXM6IGV2ZW50LmNoYW5nZXMsXHJcbiAgICAgICAgICAgICAgICBzZWxlY3Rpb246IGV2ZW50LnN0YXJ0U2VsZWN0aW9uLFxyXG4gICAgICAgICAgICAgICAgZWZmZWN0czogZXZlbnQuZWZmZWN0cyxcclxuICAgICAgICAgICAgICAgIGFubm90YXRpb25zOiBmcm9tSGlzdG9yeS5vZih7IHNpZGUsIHJlc3QgfSksXHJcbiAgICAgICAgICAgICAgICBmaWx0ZXI6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgdXNlckV2ZW50OiBzaWRlID09IDAgLyogQnJhbmNoTmFtZS5Eb25lICovID8gXCJ1bmRvXCIgOiBcInJlZG9cIixcclxuICAgICAgICAgICAgICAgIHNjcm9sbEludG9WaWV3OiB0cnVlXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5IaXN0b3J5U3RhdGUuZW1wdHkgPSAvKkBfX1BVUkVfXyovbmV3IEhpc3RvcnlTdGF0ZShub25lLCBub25lKTtcclxuLyoqXHJcbkRlZmF1bHQga2V5IGJpbmRpbmdzIGZvciB0aGUgdW5kbyBoaXN0b3J5LlxyXG5cclxuLSBNb2QtejogW2B1bmRvYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy51bmRvKS5cclxuLSBNb2QteSAoTW9kLVNoaWZ0LXogb24gbWFjT1MpICsgQ3RybC1TaGlmdC16IG9uIExpbnV4OiBbYHJlZG9gXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLnJlZG8pLlxyXG4tIE1vZC11OiBbYHVuZG9TZWxlY3Rpb25gXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLnVuZG9TZWxlY3Rpb24pLlxyXG4tIEFsdC11IChNb2QtU2hpZnQtdSBvbiBtYWNPUyk6IFtgcmVkb1NlbGVjdGlvbmBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMucmVkb1NlbGVjdGlvbikuXHJcbiovXHJcbmNvbnN0IGhpc3RvcnlLZXltYXAgPSBbXHJcbiAgICB7IGtleTogXCJNb2QtelwiLCBydW46IHVuZG8sIHByZXZlbnREZWZhdWx0OiB0cnVlIH0sXHJcbiAgICB7IGtleTogXCJNb2QteVwiLCBtYWM6IFwiTW9kLVNoaWZ0LXpcIiwgcnVuOiByZWRvLCBwcmV2ZW50RGVmYXVsdDogdHJ1ZSB9LFxyXG4gICAgeyBsaW51eDogXCJDdHJsLVNoaWZ0LXpcIiwgcnVuOiByZWRvLCBwcmV2ZW50RGVmYXVsdDogdHJ1ZSB9LFxyXG4gICAgeyBrZXk6IFwiTW9kLXVcIiwgcnVuOiB1bmRvU2VsZWN0aW9uLCBwcmV2ZW50RGVmYXVsdDogdHJ1ZSB9LFxyXG4gICAgeyBrZXk6IFwiQWx0LXVcIiwgbWFjOiBcIk1vZC1TaGlmdC11XCIsIHJ1bjogcmVkb1NlbGVjdGlvbiwgcHJldmVudERlZmF1bHQ6IHRydWUgfVxyXG5dO1xyXG5cclxuZnVuY3Rpb24gdXBkYXRlU2VsKHNlbCwgYnkpIHtcclxuICAgIHJldHVybiBFZGl0b3JTZWxlY3Rpb24uY3JlYXRlKHNlbC5yYW5nZXMubWFwKGJ5KSwgc2VsLm1haW5JbmRleCk7XHJcbn1cclxuZnVuY3Rpb24gc2V0U2VsKHN0YXRlLCBzZWxlY3Rpb24pIHtcclxuICAgIHJldHVybiBzdGF0ZS51cGRhdGUoeyBzZWxlY3Rpb24sIHNjcm9sbEludG9WaWV3OiB0cnVlLCB1c2VyRXZlbnQ6IFwic2VsZWN0XCIgfSk7XHJcbn1cclxuZnVuY3Rpb24gbW92ZVNlbCh7IHN0YXRlLCBkaXNwYXRjaCB9LCBob3cpIHtcclxuICAgIGxldCBzZWxlY3Rpb24gPSB1cGRhdGVTZWwoc3RhdGUuc2VsZWN0aW9uLCBob3cpO1xyXG4gICAgaWYgKHNlbGVjdGlvbi5lcShzdGF0ZS5zZWxlY3Rpb24pKVxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIGRpc3BhdGNoKHNldFNlbChzdGF0ZSwgc2VsZWN0aW9uKSk7XHJcbiAgICByZXR1cm4gdHJ1ZTtcclxufVxyXG5mdW5jdGlvbiByYW5nZUVuZChyYW5nZSwgZm9yd2FyZCkge1xyXG4gICAgcmV0dXJuIEVkaXRvclNlbGVjdGlvbi5jdXJzb3IoZm9yd2FyZCA/IHJhbmdlLnRvIDogcmFuZ2UuZnJvbSk7XHJcbn1cclxuZnVuY3Rpb24gY3Vyc29yQnlDaGFyKHZpZXcsIGZvcndhcmQpIHtcclxuICAgIHJldHVybiBtb3ZlU2VsKHZpZXcsIHJhbmdlID0+IHJhbmdlLmVtcHR5ID8gdmlldy5tb3ZlQnlDaGFyKHJhbmdlLCBmb3J3YXJkKSA6IHJhbmdlRW5kKHJhbmdlLCBmb3J3YXJkKSk7XHJcbn1cclxuZnVuY3Rpb24gbHRyQXRDdXJzb3Iodmlldykge1xyXG4gICAgcmV0dXJuIHZpZXcudGV4dERpcmVjdGlvbkF0KHZpZXcuc3RhdGUuc2VsZWN0aW9uLm1haW4uaGVhZCkgPT0gRGlyZWN0aW9uLkxUUjtcclxufVxyXG4vKipcclxuTW92ZSB0aGUgc2VsZWN0aW9uIG9uZSBjaGFyYWN0ZXIgdG8gdGhlIGxlZnQgKHdoaWNoIGlzIGJhY2t3YXJkIGluXHJcbmxlZnQtdG8tcmlnaHQgdGV4dCwgZm9yd2FyZCBpbiByaWdodC10by1sZWZ0IHRleHQpLlxyXG4qL1xyXG5jb25zdCBjdXJzb3JDaGFyTGVmdCA9IHZpZXcgPT4gY3Vyc29yQnlDaGFyKHZpZXcsICFsdHJBdEN1cnNvcih2aWV3KSk7XHJcbi8qKlxyXG5Nb3ZlIHRoZSBzZWxlY3Rpb24gb25lIGNoYXJhY3RlciB0byB0aGUgcmlnaHQuXHJcbiovXHJcbmNvbnN0IGN1cnNvckNoYXJSaWdodCA9IHZpZXcgPT4gY3Vyc29yQnlDaGFyKHZpZXcsIGx0ckF0Q3Vyc29yKHZpZXcpKTtcclxuLyoqXHJcbk1vdmUgdGhlIHNlbGVjdGlvbiBvbmUgY2hhcmFjdGVyIGZvcndhcmQuXHJcbiovXHJcbmNvbnN0IGN1cnNvckNoYXJGb3J3YXJkID0gdmlldyA9PiBjdXJzb3JCeUNoYXIodmlldywgdHJ1ZSk7XHJcbi8qKlxyXG5Nb3ZlIHRoZSBzZWxlY3Rpb24gb25lIGNoYXJhY3RlciBiYWNrd2FyZC5cclxuKi9cclxuY29uc3QgY3Vyc29yQ2hhckJhY2t3YXJkID0gdmlldyA9PiBjdXJzb3JCeUNoYXIodmlldywgZmFsc2UpO1xyXG5mdW5jdGlvbiBjdXJzb3JCeUdyb3VwKHZpZXcsIGZvcndhcmQpIHtcclxuICAgIHJldHVybiBtb3ZlU2VsKHZpZXcsIHJhbmdlID0+IHJhbmdlLmVtcHR5ID8gdmlldy5tb3ZlQnlHcm91cChyYW5nZSwgZm9yd2FyZCkgOiByYW5nZUVuZChyYW5nZSwgZm9yd2FyZCkpO1xyXG59XHJcbi8qKlxyXG5Nb3ZlIHRoZSBzZWxlY3Rpb24gdG8gdGhlIGxlZnQgYWNyb3NzIG9uZSBncm91cCBvZiB3b3JkIG9yXHJcbm5vbi13b3JkIChidXQgYWxzbyBub24tc3BhY2UpIGNoYXJhY3RlcnMuXHJcbiovXHJcbmNvbnN0IGN1cnNvckdyb3VwTGVmdCA9IHZpZXcgPT4gY3Vyc29yQnlHcm91cCh2aWV3LCAhbHRyQXRDdXJzb3IodmlldykpO1xyXG4vKipcclxuTW92ZSB0aGUgc2VsZWN0aW9uIG9uZSBncm91cCB0byB0aGUgcmlnaHQuXHJcbiovXHJcbmNvbnN0IGN1cnNvckdyb3VwUmlnaHQgPSB2aWV3ID0+IGN1cnNvckJ5R3JvdXAodmlldywgbHRyQXRDdXJzb3IodmlldykpO1xyXG4vKipcclxuTW92ZSB0aGUgc2VsZWN0aW9uIG9uZSBncm91cCBmb3J3YXJkLlxyXG4qL1xyXG5jb25zdCBjdXJzb3JHcm91cEZvcndhcmQgPSB2aWV3ID0+IGN1cnNvckJ5R3JvdXAodmlldywgdHJ1ZSk7XHJcbi8qKlxyXG5Nb3ZlIHRoZSBzZWxlY3Rpb24gb25lIGdyb3VwIGJhY2t3YXJkLlxyXG4qL1xyXG5jb25zdCBjdXJzb3JHcm91cEJhY2t3YXJkID0gdmlldyA9PiBjdXJzb3JCeUdyb3VwKHZpZXcsIGZhbHNlKTtcclxuZnVuY3Rpb24gbW92ZUJ5U3Vid29yZCh2aWV3LCByYW5nZSwgZm9yd2FyZCkge1xyXG4gICAgbGV0IGNhdGVnb3JpemUgPSB2aWV3LnN0YXRlLmNoYXJDYXRlZ29yaXplcihyYW5nZS5mcm9tKTtcclxuICAgIHJldHVybiB2aWV3Lm1vdmVCeUNoYXIocmFuZ2UsIGZvcndhcmQsIHN0YXJ0ID0+IHtcclxuICAgICAgICBsZXQgY2F0ID0gQ2hhckNhdGVnb3J5LlNwYWNlLCBwb3MgPSByYW5nZS5mcm9tO1xyXG4gICAgICAgIGxldCBkb25lID0gZmFsc2UsIHNhd1VwcGVyID0gZmFsc2UsIHNhd0xvd2VyID0gZmFsc2U7XHJcbiAgICAgICAgbGV0IHN0ZXAgPSAobmV4dCkgPT4ge1xyXG4gICAgICAgICAgICBpZiAoZG9uZSlcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgcG9zICs9IGZvcndhcmQgPyBuZXh0Lmxlbmd0aCA6IC1uZXh0Lmxlbmd0aDtcclxuICAgICAgICAgICAgbGV0IG5leHRDYXQgPSBjYXRlZ29yaXplKG5leHQpLCBhaGVhZDtcclxuICAgICAgICAgICAgaWYgKGNhdCA9PSBDaGFyQ2F0ZWdvcnkuU3BhY2UpXHJcbiAgICAgICAgICAgICAgICBjYXQgPSBuZXh0Q2F0O1xyXG4gICAgICAgICAgICBpZiAoY2F0ICE9IG5leHRDYXQpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIGlmIChjYXQgPT0gQ2hhckNhdGVnb3J5LldvcmQpIHtcclxuICAgICAgICAgICAgICAgIGlmIChuZXh0LnRvTG93ZXJDYXNlKCkgPT0gbmV4dCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghZm9yd2FyZCAmJiBzYXdVcHBlcilcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIHNhd0xvd2VyID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHNhd0xvd2VyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZvcndhcmQpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICBkb25lID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChzYXdVcHBlciAmJiBmb3J3YXJkICYmIGNhdGVnb3JpemUoYWhlYWQgPSB2aWV3LnN0YXRlLnNsaWNlRG9jKHBvcywgcG9zICsgMSkpID09IENoYXJDYXRlZ29yeS5Xb3JkICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFoZWFkLnRvTG93ZXJDYXNlKCkgPT0gYWhlYWQpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICBzYXdVcHBlciA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBzdGVwKHN0YXJ0KTtcclxuICAgICAgICByZXR1cm4gc3RlcDtcclxuICAgIH0pO1xyXG59XHJcbmZ1bmN0aW9uIGN1cnNvckJ5U3Vid29yZCh2aWV3LCBmb3J3YXJkKSB7XHJcbiAgICByZXR1cm4gbW92ZVNlbCh2aWV3LCByYW5nZSA9PiByYW5nZS5lbXB0eSA/IG1vdmVCeVN1YndvcmQodmlldywgcmFuZ2UsIGZvcndhcmQpIDogcmFuZ2VFbmQocmFuZ2UsIGZvcndhcmQpKTtcclxufVxyXG4vKipcclxuTW92ZSB0aGUgc2VsZWN0aW9uIG9uZSBncm91cCBvciBjYW1lbC1jYXNlIHN1YndvcmQgZm9yd2FyZC5cclxuKi9cclxuY29uc3QgY3Vyc29yU3Vid29yZEZvcndhcmQgPSB2aWV3ID0+IGN1cnNvckJ5U3Vid29yZCh2aWV3LCB0cnVlKTtcclxuLyoqXHJcbk1vdmUgdGhlIHNlbGVjdGlvbiBvbmUgZ3JvdXAgb3IgY2FtZWwtY2FzZSBzdWJ3b3JkIGJhY2t3YXJkLlxyXG4qL1xyXG5jb25zdCBjdXJzb3JTdWJ3b3JkQmFja3dhcmQgPSB2aWV3ID0+IGN1cnNvckJ5U3Vid29yZCh2aWV3LCBmYWxzZSk7XHJcbmZ1bmN0aW9uIGludGVyZXN0aW5nTm9kZShzdGF0ZSwgbm9kZSwgYnJhY2tldFByb3ApIHtcclxuICAgIGlmIChub2RlLnR5cGUucHJvcChicmFja2V0UHJvcCkpXHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICBsZXQgbGVuID0gbm9kZS50byAtIG5vZGUuZnJvbTtcclxuICAgIHJldHVybiBsZW4gJiYgKGxlbiA+IDIgfHwgL1teXFxzLC47Ol0vLnRlc3Qoc3RhdGUuc2xpY2VEb2Mobm9kZS5mcm9tLCBub2RlLnRvKSkpIHx8IG5vZGUuZmlyc3RDaGlsZDtcclxufVxyXG5mdW5jdGlvbiBtb3ZlQnlTeW50YXgoc3RhdGUsIHN0YXJ0LCBmb3J3YXJkKSB7XHJcbiAgICBsZXQgcG9zID0gc3ludGF4VHJlZShzdGF0ZSkucmVzb2x2ZUlubmVyKHN0YXJ0LmhlYWQpO1xyXG4gICAgbGV0IGJyYWNrZXRQcm9wID0gZm9yd2FyZCA/IE5vZGVQcm9wLmNsb3NlZEJ5IDogTm9kZVByb3Aub3BlbmVkQnk7XHJcbiAgICAvLyBTY2FuIGZvcndhcmQgdGhyb3VnaCBjaGlsZCBub2RlcyB0byBzZWUgaWYgdGhlcmUncyBhbiBpbnRlcmVzdGluZ1xyXG4gICAgLy8gbm9kZSBhaGVhZC5cclxuICAgIGZvciAobGV0IGF0ID0gc3RhcnQuaGVhZDs7KSB7XHJcbiAgICAgICAgbGV0IG5leHQgPSBmb3J3YXJkID8gcG9zLmNoaWxkQWZ0ZXIoYXQpIDogcG9zLmNoaWxkQmVmb3JlKGF0KTtcclxuICAgICAgICBpZiAoIW5leHQpXHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGlmIChpbnRlcmVzdGluZ05vZGUoc3RhdGUsIG5leHQsIGJyYWNrZXRQcm9wKSlcclxuICAgICAgICAgICAgcG9zID0gbmV4dDtcclxuICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIGF0ID0gZm9yd2FyZCA/IG5leHQudG8gOiBuZXh0LmZyb207XHJcbiAgICB9XHJcbiAgICBsZXQgYnJhY2tldCA9IHBvcy50eXBlLnByb3AoYnJhY2tldFByb3ApLCBtYXRjaCwgbmV3UG9zO1xyXG4gICAgaWYgKGJyYWNrZXQgJiYgKG1hdGNoID0gZm9yd2FyZCA/IG1hdGNoQnJhY2tldHMoc3RhdGUsIHBvcy5mcm9tLCAxKSA6IG1hdGNoQnJhY2tldHMoc3RhdGUsIHBvcy50bywgLTEpKSAmJiBtYXRjaC5tYXRjaGVkKVxyXG4gICAgICAgIG5ld1BvcyA9IGZvcndhcmQgPyBtYXRjaC5lbmQudG8gOiBtYXRjaC5lbmQuZnJvbTtcclxuICAgIGVsc2VcclxuICAgICAgICBuZXdQb3MgPSBmb3J3YXJkID8gcG9zLnRvIDogcG9zLmZyb207XHJcbiAgICByZXR1cm4gRWRpdG9yU2VsZWN0aW9uLmN1cnNvcihuZXdQb3MsIGZvcndhcmQgPyAtMSA6IDEpO1xyXG59XHJcbi8qKlxyXG5Nb3ZlIHRoZSBjdXJzb3Igb3ZlciB0aGUgbmV4dCBzeW50YWN0aWMgZWxlbWVudCB0byB0aGUgbGVmdC5cclxuKi9cclxuY29uc3QgY3Vyc29yU3ludGF4TGVmdCA9IHZpZXcgPT4gbW92ZVNlbCh2aWV3LCByYW5nZSA9PiBtb3ZlQnlTeW50YXgodmlldy5zdGF0ZSwgcmFuZ2UsICFsdHJBdEN1cnNvcih2aWV3KSkpO1xyXG4vKipcclxuTW92ZSB0aGUgY3Vyc29yIG92ZXIgdGhlIG5leHQgc3ludGFjdGljIGVsZW1lbnQgdG8gdGhlIHJpZ2h0LlxyXG4qL1xyXG5jb25zdCBjdXJzb3JTeW50YXhSaWdodCA9IHZpZXcgPT4gbW92ZVNlbCh2aWV3LCByYW5nZSA9PiBtb3ZlQnlTeW50YXgodmlldy5zdGF0ZSwgcmFuZ2UsIGx0ckF0Q3Vyc29yKHZpZXcpKSk7XHJcbmZ1bmN0aW9uIGN1cnNvckJ5TGluZSh2aWV3LCBmb3J3YXJkKSB7XHJcbiAgICByZXR1cm4gbW92ZVNlbCh2aWV3LCByYW5nZSA9PiB7XHJcbiAgICAgICAgaWYgKCFyYW5nZS5lbXB0eSlcclxuICAgICAgICAgICAgcmV0dXJuIHJhbmdlRW5kKHJhbmdlLCBmb3J3YXJkKTtcclxuICAgICAgICBsZXQgbW92ZWQgPSB2aWV3Lm1vdmVWZXJ0aWNhbGx5KHJhbmdlLCBmb3J3YXJkKTtcclxuICAgICAgICByZXR1cm4gbW92ZWQuaGVhZCAhPSByYW5nZS5oZWFkID8gbW92ZWQgOiB2aWV3Lm1vdmVUb0xpbmVCb3VuZGFyeShyYW5nZSwgZm9yd2FyZCk7XHJcbiAgICB9KTtcclxufVxyXG4vKipcclxuTW92ZSB0aGUgc2VsZWN0aW9uIG9uZSBsaW5lIHVwLlxyXG4qL1xyXG5jb25zdCBjdXJzb3JMaW5lVXAgPSB2aWV3ID0+IGN1cnNvckJ5TGluZSh2aWV3LCBmYWxzZSk7XHJcbi8qKlxyXG5Nb3ZlIHRoZSBzZWxlY3Rpb24gb25lIGxpbmUgZG93bi5cclxuKi9cclxuY29uc3QgY3Vyc29yTGluZURvd24gPSB2aWV3ID0+IGN1cnNvckJ5TGluZSh2aWV3LCB0cnVlKTtcclxuZnVuY3Rpb24gcGFnZUhlaWdodCh2aWV3KSB7XHJcbiAgICByZXR1cm4gTWF0aC5tYXgodmlldy5kZWZhdWx0TGluZUhlaWdodCwgTWF0aC5taW4odmlldy5kb20uY2xpZW50SGVpZ2h0LCBpbm5lckhlaWdodCkgLSA1KTtcclxufVxyXG5mdW5jdGlvbiBjdXJzb3JCeVBhZ2UodmlldywgZm9yd2FyZCkge1xyXG4gICAgbGV0IHsgc3RhdGUgfSA9IHZpZXcsIHNlbGVjdGlvbiA9IHVwZGF0ZVNlbChzdGF0ZS5zZWxlY3Rpb24sIHJhbmdlID0+IHtcclxuICAgICAgICByZXR1cm4gcmFuZ2UuZW1wdHkgPyB2aWV3Lm1vdmVWZXJ0aWNhbGx5KHJhbmdlLCBmb3J3YXJkLCBwYWdlSGVpZ2h0KHZpZXcpKSA6IHJhbmdlRW5kKHJhbmdlLCBmb3J3YXJkKTtcclxuICAgIH0pO1xyXG4gICAgaWYgKHNlbGVjdGlvbi5lcShzdGF0ZS5zZWxlY3Rpb24pKVxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIGxldCBzdGFydFBvcyA9IHZpZXcuY29vcmRzQXRQb3Moc3RhdGUuc2VsZWN0aW9uLm1haW4uaGVhZCk7XHJcbiAgICBsZXQgc2Nyb2xsUmVjdCA9IHZpZXcuc2Nyb2xsRE9NLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xyXG4gICAgbGV0IGVmZmVjdDtcclxuICAgIGlmIChzdGFydFBvcyAmJiBzdGFydFBvcy50b3AgPiBzY3JvbGxSZWN0LnRvcCAmJiBzdGFydFBvcy5ib3R0b20gPCBzY3JvbGxSZWN0LmJvdHRvbSAmJlxyXG4gICAgICAgIHN0YXJ0UG9zLnRvcCAtIHNjcm9sbFJlY3QudG9wIDw9IHZpZXcuc2Nyb2xsRE9NLnNjcm9sbEhlaWdodCAtIHZpZXcuc2Nyb2xsRE9NLnNjcm9sbFRvcCAtIHZpZXcuc2Nyb2xsRE9NLmNsaWVudEhlaWdodClcclxuICAgICAgICBlZmZlY3QgPSBFZGl0b3JWaWV3LnNjcm9sbEludG9WaWV3KHNlbGVjdGlvbi5tYWluLmhlYWQsIHsgeTogXCJzdGFydFwiLCB5TWFyZ2luOiBzdGFydFBvcy50b3AgLSBzY3JvbGxSZWN0LnRvcCB9KTtcclxuICAgIHZpZXcuZGlzcGF0Y2goc2V0U2VsKHN0YXRlLCBzZWxlY3Rpb24pLCB7IGVmZmVjdHM6IGVmZmVjdCB9KTtcclxuICAgIHJldHVybiB0cnVlO1xyXG59XHJcbi8qKlxyXG5Nb3ZlIHRoZSBzZWxlY3Rpb24gb25lIHBhZ2UgdXAuXHJcbiovXHJcbmNvbnN0IGN1cnNvclBhZ2VVcCA9IHZpZXcgPT4gY3Vyc29yQnlQYWdlKHZpZXcsIGZhbHNlKTtcclxuLyoqXHJcbk1vdmUgdGhlIHNlbGVjdGlvbiBvbmUgcGFnZSBkb3duLlxyXG4qL1xyXG5jb25zdCBjdXJzb3JQYWdlRG93biA9IHZpZXcgPT4gY3Vyc29yQnlQYWdlKHZpZXcsIHRydWUpO1xyXG5mdW5jdGlvbiBtb3ZlQnlMaW5lQm91bmRhcnkodmlldywgc3RhcnQsIGZvcndhcmQpIHtcclxuICAgIGxldCBsaW5lID0gdmlldy5saW5lQmxvY2tBdChzdGFydC5oZWFkKSwgbW92ZWQgPSB2aWV3Lm1vdmVUb0xpbmVCb3VuZGFyeShzdGFydCwgZm9yd2FyZCk7XHJcbiAgICBpZiAobW92ZWQuaGVhZCA9PSBzdGFydC5oZWFkICYmIG1vdmVkLmhlYWQgIT0gKGZvcndhcmQgPyBsaW5lLnRvIDogbGluZS5mcm9tKSlcclxuICAgICAgICBtb3ZlZCA9IHZpZXcubW92ZVRvTGluZUJvdW5kYXJ5KHN0YXJ0LCBmb3J3YXJkLCBmYWxzZSk7XHJcbiAgICBpZiAoIWZvcndhcmQgJiYgbW92ZWQuaGVhZCA9PSBsaW5lLmZyb20gJiYgbGluZS5sZW5ndGgpIHtcclxuICAgICAgICBsZXQgc3BhY2UgPSAvXlxccyovLmV4ZWModmlldy5zdGF0ZS5zbGljZURvYyhsaW5lLmZyb20sIE1hdGgubWluKGxpbmUuZnJvbSArIDEwMCwgbGluZS50bykpKVswXS5sZW5ndGg7XHJcbiAgICAgICAgaWYgKHNwYWNlICYmIHN0YXJ0LmhlYWQgIT0gbGluZS5mcm9tICsgc3BhY2UpXHJcbiAgICAgICAgICAgIG1vdmVkID0gRWRpdG9yU2VsZWN0aW9uLmN1cnNvcihsaW5lLmZyb20gKyBzcGFjZSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbW92ZWQ7XHJcbn1cclxuLyoqXHJcbk1vdmUgdGhlIHNlbGVjdGlvbiB0byB0aGUgbmV4dCBsaW5lIHdyYXAgcG9pbnQsIG9yIHRvIHRoZSBlbmQgb2ZcclxudGhlIGxpbmUgaWYgdGhlcmUgaXNuJ3Qgb25lIGxlZnQgb24gdGhpcyBsaW5lLlxyXG4qL1xyXG5jb25zdCBjdXJzb3JMaW5lQm91bmRhcnlGb3J3YXJkID0gdmlldyA9PiBtb3ZlU2VsKHZpZXcsIHJhbmdlID0+IG1vdmVCeUxpbmVCb3VuZGFyeSh2aWV3LCByYW5nZSwgdHJ1ZSkpO1xyXG4vKipcclxuTW92ZSB0aGUgc2VsZWN0aW9uIHRvIHByZXZpb3VzIGxpbmUgd3JhcCBwb2ludCwgb3IgZmFpbGluZyB0aGF0IHRvXHJcbnRoZSBzdGFydCBvZiB0aGUgbGluZS4gSWYgdGhlIGxpbmUgaXMgaW5kZW50ZWQsIGFuZCB0aGUgY3Vyc29yXHJcbmlzbid0IGFscmVhZHkgYXQgdGhlIGVuZCBvZiB0aGUgaW5kZW50YXRpb24sIHRoaXMgd2lsbCBtb3ZlIHRvIHRoZVxyXG5lbmQgb2YgdGhlIGluZGVudGF0aW9uIGluc3RlYWQgb2YgdGhlIHN0YXJ0IG9mIHRoZSBsaW5lLlxyXG4qL1xyXG5jb25zdCBjdXJzb3JMaW5lQm91bmRhcnlCYWNrd2FyZCA9IHZpZXcgPT4gbW92ZVNlbCh2aWV3LCByYW5nZSA9PiBtb3ZlQnlMaW5lQm91bmRhcnkodmlldywgcmFuZ2UsIGZhbHNlKSk7XHJcbi8qKlxyXG5Nb3ZlIHRoZSBzZWxlY3Rpb24gb25lIGxpbmUgd3JhcCBwb2ludCB0byB0aGUgbGVmdC5cclxuKi9cclxuY29uc3QgY3Vyc29yTGluZUJvdW5kYXJ5TGVmdCA9IHZpZXcgPT4gbW92ZVNlbCh2aWV3LCByYW5nZSA9PiBtb3ZlQnlMaW5lQm91bmRhcnkodmlldywgcmFuZ2UsICFsdHJBdEN1cnNvcih2aWV3KSkpO1xyXG4vKipcclxuTW92ZSB0aGUgc2VsZWN0aW9uIG9uZSBsaW5lIHdyYXAgcG9pbnQgdG8gdGhlIHJpZ2h0LlxyXG4qL1xyXG5jb25zdCBjdXJzb3JMaW5lQm91bmRhcnlSaWdodCA9IHZpZXcgPT4gbW92ZVNlbCh2aWV3LCByYW5nZSA9PiBtb3ZlQnlMaW5lQm91bmRhcnkodmlldywgcmFuZ2UsIGx0ckF0Q3Vyc29yKHZpZXcpKSk7XHJcbi8qKlxyXG5Nb3ZlIHRoZSBzZWxlY3Rpb24gdG8gdGhlIHN0YXJ0IG9mIHRoZSBsaW5lLlxyXG4qL1xyXG5jb25zdCBjdXJzb3JMaW5lU3RhcnQgPSB2aWV3ID0+IG1vdmVTZWwodmlldywgcmFuZ2UgPT4gRWRpdG9yU2VsZWN0aW9uLmN1cnNvcih2aWV3LmxpbmVCbG9ja0F0KHJhbmdlLmhlYWQpLmZyb20sIDEpKTtcclxuLyoqXHJcbk1vdmUgdGhlIHNlbGVjdGlvbiB0byB0aGUgZW5kIG9mIHRoZSBsaW5lLlxyXG4qL1xyXG5jb25zdCBjdXJzb3JMaW5lRW5kID0gdmlldyA9PiBtb3ZlU2VsKHZpZXcsIHJhbmdlID0+IEVkaXRvclNlbGVjdGlvbi5jdXJzb3Iodmlldy5saW5lQmxvY2tBdChyYW5nZS5oZWFkKS50bywgLTEpKTtcclxuZnVuY3Rpb24gdG9NYXRjaGluZ0JyYWNrZXQoc3RhdGUsIGRpc3BhdGNoLCBleHRlbmQpIHtcclxuICAgIGxldCBmb3VuZCA9IGZhbHNlLCBzZWxlY3Rpb24gPSB1cGRhdGVTZWwoc3RhdGUuc2VsZWN0aW9uLCByYW5nZSA9PiB7XHJcbiAgICAgICAgbGV0IG1hdGNoaW5nID0gbWF0Y2hCcmFja2V0cyhzdGF0ZSwgcmFuZ2UuaGVhZCwgLTEpXHJcbiAgICAgICAgICAgIHx8IG1hdGNoQnJhY2tldHMoc3RhdGUsIHJhbmdlLmhlYWQsIDEpXHJcbiAgICAgICAgICAgIHx8IChyYW5nZS5oZWFkID4gMCAmJiBtYXRjaEJyYWNrZXRzKHN0YXRlLCByYW5nZS5oZWFkIC0gMSwgMSkpXHJcbiAgICAgICAgICAgIHx8IChyYW5nZS5oZWFkIDwgc3RhdGUuZG9jLmxlbmd0aCAmJiBtYXRjaEJyYWNrZXRzKHN0YXRlLCByYW5nZS5oZWFkICsgMSwgLTEpKTtcclxuICAgICAgICBpZiAoIW1hdGNoaW5nIHx8ICFtYXRjaGluZy5lbmQpXHJcbiAgICAgICAgICAgIHJldHVybiByYW5nZTtcclxuICAgICAgICBmb3VuZCA9IHRydWU7XHJcbiAgICAgICAgbGV0IGhlYWQgPSBtYXRjaGluZy5zdGFydC5mcm9tID09IHJhbmdlLmhlYWQgPyBtYXRjaGluZy5lbmQudG8gOiBtYXRjaGluZy5lbmQuZnJvbTtcclxuICAgICAgICByZXR1cm4gZXh0ZW5kID8gRWRpdG9yU2VsZWN0aW9uLnJhbmdlKHJhbmdlLmFuY2hvciwgaGVhZCkgOiBFZGl0b3JTZWxlY3Rpb24uY3Vyc29yKGhlYWQpO1xyXG4gICAgfSk7XHJcbiAgICBpZiAoIWZvdW5kKVxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIGRpc3BhdGNoKHNldFNlbChzdGF0ZSwgc2VsZWN0aW9uKSk7XHJcbiAgICByZXR1cm4gdHJ1ZTtcclxufVxyXG4vKipcclxuTW92ZSB0aGUgc2VsZWN0aW9uIHRvIHRoZSBicmFja2V0IG1hdGNoaW5nIHRoZSBvbmUgaXQgaXMgY3VycmVudGx5XHJcbm9uLCBpZiBhbnkuXHJcbiovXHJcbmNvbnN0IGN1cnNvck1hdGNoaW5nQnJhY2tldCA9ICh7IHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB0b01hdGNoaW5nQnJhY2tldChzdGF0ZSwgZGlzcGF0Y2gsIGZhbHNlKTtcclxuLyoqXHJcbkV4dGVuZCB0aGUgc2VsZWN0aW9uIHRvIHRoZSBicmFja2V0IG1hdGNoaW5nIHRoZSBvbmUgdGhlIHNlbGVjdGlvblxyXG5oZWFkIGlzIGN1cnJlbnRseSBvbiwgaWYgYW55LlxyXG4qL1xyXG5jb25zdCBzZWxlY3RNYXRjaGluZ0JyYWNrZXQgPSAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4gdG9NYXRjaGluZ0JyYWNrZXQoc3RhdGUsIGRpc3BhdGNoLCB0cnVlKTtcclxuZnVuY3Rpb24gZXh0ZW5kU2VsKHZpZXcsIGhvdykge1xyXG4gICAgbGV0IHNlbGVjdGlvbiA9IHVwZGF0ZVNlbCh2aWV3LnN0YXRlLnNlbGVjdGlvbiwgcmFuZ2UgPT4ge1xyXG4gICAgICAgIGxldCBoZWFkID0gaG93KHJhbmdlKTtcclxuICAgICAgICByZXR1cm4gRWRpdG9yU2VsZWN0aW9uLnJhbmdlKHJhbmdlLmFuY2hvciwgaGVhZC5oZWFkLCBoZWFkLmdvYWxDb2x1bW4sIGhlYWQuYmlkaUxldmVsIHx8IHVuZGVmaW5lZCk7XHJcbiAgICB9KTtcclxuICAgIGlmIChzZWxlY3Rpb24uZXEodmlldy5zdGF0ZS5zZWxlY3Rpb24pKVxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIHZpZXcuZGlzcGF0Y2goc2V0U2VsKHZpZXcuc3RhdGUsIHNlbGVjdGlvbikpO1xyXG4gICAgcmV0dXJuIHRydWU7XHJcbn1cclxuZnVuY3Rpb24gc2VsZWN0QnlDaGFyKHZpZXcsIGZvcndhcmQpIHtcclxuICAgIHJldHVybiBleHRlbmRTZWwodmlldywgcmFuZ2UgPT4gdmlldy5tb3ZlQnlDaGFyKHJhbmdlLCBmb3J3YXJkKSk7XHJcbn1cclxuLyoqXHJcbk1vdmUgdGhlIHNlbGVjdGlvbiBoZWFkIG9uZSBjaGFyYWN0ZXIgdG8gdGhlIGxlZnQsIHdoaWxlIGxlYXZpbmdcclxudGhlIGFuY2hvciBpbiBwbGFjZS5cclxuKi9cclxuY29uc3Qgc2VsZWN0Q2hhckxlZnQgPSB2aWV3ID0+IHNlbGVjdEJ5Q2hhcih2aWV3LCAhbHRyQXRDdXJzb3IodmlldykpO1xyXG4vKipcclxuTW92ZSB0aGUgc2VsZWN0aW9uIGhlYWQgb25lIGNoYXJhY3RlciB0byB0aGUgcmlnaHQuXHJcbiovXHJcbmNvbnN0IHNlbGVjdENoYXJSaWdodCA9IHZpZXcgPT4gc2VsZWN0QnlDaGFyKHZpZXcsIGx0ckF0Q3Vyc29yKHZpZXcpKTtcclxuLyoqXHJcbk1vdmUgdGhlIHNlbGVjdGlvbiBoZWFkIG9uZSBjaGFyYWN0ZXIgZm9yd2FyZC5cclxuKi9cclxuY29uc3Qgc2VsZWN0Q2hhckZvcndhcmQgPSB2aWV3ID0+IHNlbGVjdEJ5Q2hhcih2aWV3LCB0cnVlKTtcclxuLyoqXHJcbk1vdmUgdGhlIHNlbGVjdGlvbiBoZWFkIG9uZSBjaGFyYWN0ZXIgYmFja3dhcmQuXHJcbiovXHJcbmNvbnN0IHNlbGVjdENoYXJCYWNrd2FyZCA9IHZpZXcgPT4gc2VsZWN0QnlDaGFyKHZpZXcsIGZhbHNlKTtcclxuZnVuY3Rpb24gc2VsZWN0QnlHcm91cCh2aWV3LCBmb3J3YXJkKSB7XHJcbiAgICByZXR1cm4gZXh0ZW5kU2VsKHZpZXcsIHJhbmdlID0+IHZpZXcubW92ZUJ5R3JvdXAocmFuZ2UsIGZvcndhcmQpKTtcclxufVxyXG4vKipcclxuTW92ZSB0aGUgc2VsZWN0aW9uIGhlYWQgb25lIFtncm91cF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5jdXJzb3JHcm91cExlZnQpIHRvXHJcbnRoZSBsZWZ0LlxyXG4qL1xyXG5jb25zdCBzZWxlY3RHcm91cExlZnQgPSB2aWV3ID0+IHNlbGVjdEJ5R3JvdXAodmlldywgIWx0ckF0Q3Vyc29yKHZpZXcpKTtcclxuLyoqXHJcbk1vdmUgdGhlIHNlbGVjdGlvbiBoZWFkIG9uZSBncm91cCB0byB0aGUgcmlnaHQuXHJcbiovXHJcbmNvbnN0IHNlbGVjdEdyb3VwUmlnaHQgPSB2aWV3ID0+IHNlbGVjdEJ5R3JvdXAodmlldywgbHRyQXRDdXJzb3IodmlldykpO1xyXG4vKipcclxuTW92ZSB0aGUgc2VsZWN0aW9uIGhlYWQgb25lIGdyb3VwIGZvcndhcmQuXHJcbiovXHJcbmNvbnN0IHNlbGVjdEdyb3VwRm9yd2FyZCA9IHZpZXcgPT4gc2VsZWN0QnlHcm91cCh2aWV3LCB0cnVlKTtcclxuLyoqXHJcbk1vdmUgdGhlIHNlbGVjdGlvbiBoZWFkIG9uZSBncm91cCBiYWNrd2FyZC5cclxuKi9cclxuY29uc3Qgc2VsZWN0R3JvdXBCYWNrd2FyZCA9IHZpZXcgPT4gc2VsZWN0QnlHcm91cCh2aWV3LCBmYWxzZSk7XHJcbmZ1bmN0aW9uIHNlbGVjdEJ5U3Vid29yZCh2aWV3LCBmb3J3YXJkKSB7XHJcbiAgICByZXR1cm4gZXh0ZW5kU2VsKHZpZXcsIHJhbmdlID0+IG1vdmVCeVN1YndvcmQodmlldywgcmFuZ2UsIGZvcndhcmQpKTtcclxufVxyXG4vKipcclxuTW92ZSB0aGUgc2VsZWN0aW9uIGhlYWQgb25lIGdyb3VwIG9yIGNhbWVsLWNhc2Ugc3Vid29yZCBmb3J3YXJkLlxyXG4qL1xyXG5jb25zdCBzZWxlY3RTdWJ3b3JkRm9yd2FyZCA9IHZpZXcgPT4gc2VsZWN0QnlTdWJ3b3JkKHZpZXcsIHRydWUpO1xyXG4vKipcclxuTW92ZSB0aGUgc2VsZWN0aW9uIGhlYWQgb25lIGdyb3VwIG9yIHN1YndvcmQgYmFja3dhcmQuXHJcbiovXHJcbmNvbnN0IHNlbGVjdFN1YndvcmRCYWNrd2FyZCA9IHZpZXcgPT4gc2VsZWN0QnlTdWJ3b3JkKHZpZXcsIGZhbHNlKTtcclxuLyoqXHJcbk1vdmUgdGhlIHNlbGVjdGlvbiBoZWFkIG92ZXIgdGhlIG5leHQgc3ludGFjdGljIGVsZW1lbnQgdG8gdGhlIGxlZnQuXHJcbiovXHJcbmNvbnN0IHNlbGVjdFN5bnRheExlZnQgPSB2aWV3ID0+IGV4dGVuZFNlbCh2aWV3LCByYW5nZSA9PiBtb3ZlQnlTeW50YXgodmlldy5zdGF0ZSwgcmFuZ2UsICFsdHJBdEN1cnNvcih2aWV3KSkpO1xyXG4vKipcclxuTW92ZSB0aGUgc2VsZWN0aW9uIGhlYWQgb3ZlciB0aGUgbmV4dCBzeW50YWN0aWMgZWxlbWVudCB0byB0aGUgcmlnaHQuXHJcbiovXHJcbmNvbnN0IHNlbGVjdFN5bnRheFJpZ2h0ID0gdmlldyA9PiBleHRlbmRTZWwodmlldywgcmFuZ2UgPT4gbW92ZUJ5U3ludGF4KHZpZXcuc3RhdGUsIHJhbmdlLCBsdHJBdEN1cnNvcih2aWV3KSkpO1xyXG5mdW5jdGlvbiBzZWxlY3RCeUxpbmUodmlldywgZm9yd2FyZCkge1xyXG4gICAgcmV0dXJuIGV4dGVuZFNlbCh2aWV3LCByYW5nZSA9PiB2aWV3Lm1vdmVWZXJ0aWNhbGx5KHJhbmdlLCBmb3J3YXJkKSk7XHJcbn1cclxuLyoqXHJcbk1vdmUgdGhlIHNlbGVjdGlvbiBoZWFkIG9uZSBsaW5lIHVwLlxyXG4qL1xyXG5jb25zdCBzZWxlY3RMaW5lVXAgPSB2aWV3ID0+IHNlbGVjdEJ5TGluZSh2aWV3LCBmYWxzZSk7XHJcbi8qKlxyXG5Nb3ZlIHRoZSBzZWxlY3Rpb24gaGVhZCBvbmUgbGluZSBkb3duLlxyXG4qL1xyXG5jb25zdCBzZWxlY3RMaW5lRG93biA9IHZpZXcgPT4gc2VsZWN0QnlMaW5lKHZpZXcsIHRydWUpO1xyXG5mdW5jdGlvbiBzZWxlY3RCeVBhZ2UodmlldywgZm9yd2FyZCkge1xyXG4gICAgcmV0dXJuIGV4dGVuZFNlbCh2aWV3LCByYW5nZSA9PiB2aWV3Lm1vdmVWZXJ0aWNhbGx5KHJhbmdlLCBmb3J3YXJkLCBwYWdlSGVpZ2h0KHZpZXcpKSk7XHJcbn1cclxuLyoqXHJcbk1vdmUgdGhlIHNlbGVjdGlvbiBoZWFkIG9uZSBwYWdlIHVwLlxyXG4qL1xyXG5jb25zdCBzZWxlY3RQYWdlVXAgPSB2aWV3ID0+IHNlbGVjdEJ5UGFnZSh2aWV3LCBmYWxzZSk7XHJcbi8qKlxyXG5Nb3ZlIHRoZSBzZWxlY3Rpb24gaGVhZCBvbmUgcGFnZSBkb3duLlxyXG4qL1xyXG5jb25zdCBzZWxlY3RQYWdlRG93biA9IHZpZXcgPT4gc2VsZWN0QnlQYWdlKHZpZXcsIHRydWUpO1xyXG4vKipcclxuTW92ZSB0aGUgc2VsZWN0aW9uIGhlYWQgdG8gdGhlIG5leHQgbGluZSBib3VuZGFyeS5cclxuKi9cclxuY29uc3Qgc2VsZWN0TGluZUJvdW5kYXJ5Rm9yd2FyZCA9IHZpZXcgPT4gZXh0ZW5kU2VsKHZpZXcsIHJhbmdlID0+IG1vdmVCeUxpbmVCb3VuZGFyeSh2aWV3LCByYW5nZSwgdHJ1ZSkpO1xyXG4vKipcclxuTW92ZSB0aGUgc2VsZWN0aW9uIGhlYWQgdG8gdGhlIHByZXZpb3VzIGxpbmUgYm91bmRhcnkuXHJcbiovXHJcbmNvbnN0IHNlbGVjdExpbmVCb3VuZGFyeUJhY2t3YXJkID0gdmlldyA9PiBleHRlbmRTZWwodmlldywgcmFuZ2UgPT4gbW92ZUJ5TGluZUJvdW5kYXJ5KHZpZXcsIHJhbmdlLCBmYWxzZSkpO1xyXG4vKipcclxuTW92ZSB0aGUgc2VsZWN0aW9uIGhlYWQgb25lIGxpbmUgYm91bmRhcnkgdG8gdGhlIGxlZnQuXHJcbiovXHJcbmNvbnN0IHNlbGVjdExpbmVCb3VuZGFyeUxlZnQgPSB2aWV3ID0+IGV4dGVuZFNlbCh2aWV3LCByYW5nZSA9PiBtb3ZlQnlMaW5lQm91bmRhcnkodmlldywgcmFuZ2UsICFsdHJBdEN1cnNvcih2aWV3KSkpO1xyXG4vKipcclxuTW92ZSB0aGUgc2VsZWN0aW9uIGhlYWQgb25lIGxpbmUgYm91bmRhcnkgdG8gdGhlIHJpZ2h0LlxyXG4qL1xyXG5jb25zdCBzZWxlY3RMaW5lQm91bmRhcnlSaWdodCA9IHZpZXcgPT4gZXh0ZW5kU2VsKHZpZXcsIHJhbmdlID0+IG1vdmVCeUxpbmVCb3VuZGFyeSh2aWV3LCByYW5nZSwgbHRyQXRDdXJzb3IodmlldykpKTtcclxuLyoqXHJcbk1vdmUgdGhlIHNlbGVjdGlvbiBoZWFkIHRvIHRoZSBzdGFydCBvZiB0aGUgbGluZS5cclxuKi9cclxuY29uc3Qgc2VsZWN0TGluZVN0YXJ0ID0gdmlldyA9PiBleHRlbmRTZWwodmlldywgcmFuZ2UgPT4gRWRpdG9yU2VsZWN0aW9uLmN1cnNvcih2aWV3LmxpbmVCbG9ja0F0KHJhbmdlLmhlYWQpLmZyb20pKTtcclxuLyoqXHJcbk1vdmUgdGhlIHNlbGVjdGlvbiBoZWFkIHRvIHRoZSBlbmQgb2YgdGhlIGxpbmUuXHJcbiovXHJcbmNvbnN0IHNlbGVjdExpbmVFbmQgPSB2aWV3ID0+IGV4dGVuZFNlbCh2aWV3LCByYW5nZSA9PiBFZGl0b3JTZWxlY3Rpb24uY3Vyc29yKHZpZXcubGluZUJsb2NrQXQocmFuZ2UuaGVhZCkudG8pKTtcclxuLyoqXHJcbk1vdmUgdGhlIHNlbGVjdGlvbiB0byB0aGUgc3RhcnQgb2YgdGhlIGRvY3VtZW50LlxyXG4qL1xyXG5jb25zdCBjdXJzb3JEb2NTdGFydCA9ICh7IHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB7XHJcbiAgICBkaXNwYXRjaChzZXRTZWwoc3RhdGUsIHsgYW5jaG9yOiAwIH0pKTtcclxuICAgIHJldHVybiB0cnVlO1xyXG59O1xyXG4vKipcclxuTW92ZSB0aGUgc2VsZWN0aW9uIHRvIHRoZSBlbmQgb2YgdGhlIGRvY3VtZW50LlxyXG4qL1xyXG5jb25zdCBjdXJzb3JEb2NFbmQgPSAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xyXG4gICAgZGlzcGF0Y2goc2V0U2VsKHN0YXRlLCB7IGFuY2hvcjogc3RhdGUuZG9jLmxlbmd0aCB9KSk7XHJcbiAgICByZXR1cm4gdHJ1ZTtcclxufTtcclxuLyoqXHJcbk1vdmUgdGhlIHNlbGVjdGlvbiBoZWFkIHRvIHRoZSBzdGFydCBvZiB0aGUgZG9jdW1lbnQuXHJcbiovXHJcbmNvbnN0IHNlbGVjdERvY1N0YXJ0ID0gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcclxuICAgIGRpc3BhdGNoKHNldFNlbChzdGF0ZSwgeyBhbmNob3I6IHN0YXRlLnNlbGVjdGlvbi5tYWluLmFuY2hvciwgaGVhZDogMCB9KSk7XHJcbiAgICByZXR1cm4gdHJ1ZTtcclxufTtcclxuLyoqXHJcbk1vdmUgdGhlIHNlbGVjdGlvbiBoZWFkIHRvIHRoZSBlbmQgb2YgdGhlIGRvY3VtZW50LlxyXG4qL1xyXG5jb25zdCBzZWxlY3REb2NFbmQgPSAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xyXG4gICAgZGlzcGF0Y2goc2V0U2VsKHN0YXRlLCB7IGFuY2hvcjogc3RhdGUuc2VsZWN0aW9uLm1haW4uYW5jaG9yLCBoZWFkOiBzdGF0ZS5kb2MubGVuZ3RoIH0pKTtcclxuICAgIHJldHVybiB0cnVlO1xyXG59O1xyXG4vKipcclxuU2VsZWN0IHRoZSBlbnRpcmUgZG9jdW1lbnQuXHJcbiovXHJcbmNvbnN0IHNlbGVjdEFsbCA9ICh7IHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB7XHJcbiAgICBkaXNwYXRjaChzdGF0ZS51cGRhdGUoeyBzZWxlY3Rpb246IHsgYW5jaG9yOiAwLCBoZWFkOiBzdGF0ZS5kb2MubGVuZ3RoIH0sIHVzZXJFdmVudDogXCJzZWxlY3RcIiB9KSk7XHJcbiAgICByZXR1cm4gdHJ1ZTtcclxufTtcclxuLyoqXHJcbkV4cGFuZCB0aGUgc2VsZWN0aW9uIHRvIGNvdmVyIGVudGlyZSBsaW5lcy5cclxuKi9cclxuY29uc3Qgc2VsZWN0TGluZSA9ICh7IHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB7XHJcbiAgICBsZXQgcmFuZ2VzID0gc2VsZWN0ZWRMaW5lQmxvY2tzKHN0YXRlKS5tYXAoKHsgZnJvbSwgdG8gfSkgPT4gRWRpdG9yU2VsZWN0aW9uLnJhbmdlKGZyb20sIE1hdGgubWluKHRvICsgMSwgc3RhdGUuZG9jLmxlbmd0aCkpKTtcclxuICAgIGRpc3BhdGNoKHN0YXRlLnVwZGF0ZSh7IHNlbGVjdGlvbjogRWRpdG9yU2VsZWN0aW9uLmNyZWF0ZShyYW5nZXMpLCB1c2VyRXZlbnQ6IFwic2VsZWN0XCIgfSkpO1xyXG4gICAgcmV0dXJuIHRydWU7XHJcbn07XHJcbi8qKlxyXG5TZWxlY3QgdGhlIG5leHQgc3ludGFjdGljIGNvbnN0cnVjdCB0aGF0IGlzIGxhcmdlciB0aGFuIHRoZVxyXG5zZWxlY3Rpb24uIE5vdGUgdGhhdCB0aGlzIHdpbGwgb25seSB3b3JrIGluc29mYXIgYXMgdGhlIGxhbmd1YWdlXHJcbltwcm92aWRlcl0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNsYW5ndWFnZS5sYW5ndWFnZSkgeW91IHVzZSBidWlsZHMgdXAgYSBmdWxsXHJcbnN5bnRheCB0cmVlLlxyXG4qL1xyXG5jb25zdCBzZWxlY3RQYXJlbnRTeW50YXggPSAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xyXG4gICAgbGV0IHNlbGVjdGlvbiA9IHVwZGF0ZVNlbChzdGF0ZS5zZWxlY3Rpb24sIHJhbmdlID0+IHtcclxuICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgbGV0IGNvbnRleHQgPSBzeW50YXhUcmVlKHN0YXRlKS5yZXNvbHZlSW5uZXIocmFuZ2UuaGVhZCwgMSk7XHJcbiAgICAgICAgd2hpbGUgKCEoKGNvbnRleHQuZnJvbSA8IHJhbmdlLmZyb20gJiYgY29udGV4dC50byA+PSByYW5nZS50bykgfHxcclxuICAgICAgICAgICAgKGNvbnRleHQudG8gPiByYW5nZS50byAmJiBjb250ZXh0LmZyb20gPD0gcmFuZ2UuZnJvbSkgfHxcclxuICAgICAgICAgICAgISgoX2EgPSBjb250ZXh0LnBhcmVudCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnBhcmVudCkpKVxyXG4gICAgICAgICAgICBjb250ZXh0ID0gY29udGV4dC5wYXJlbnQ7XHJcbiAgICAgICAgcmV0dXJuIEVkaXRvclNlbGVjdGlvbi5yYW5nZShjb250ZXh0LnRvLCBjb250ZXh0LmZyb20pO1xyXG4gICAgfSk7XHJcbiAgICBkaXNwYXRjaChzZXRTZWwoc3RhdGUsIHNlbGVjdGlvbikpO1xyXG4gICAgcmV0dXJuIHRydWU7XHJcbn07XHJcbi8qKlxyXG5TaW1wbGlmeSB0aGUgY3VycmVudCBzZWxlY3Rpb24uIFdoZW4gbXVsdGlwbGUgcmFuZ2VzIGFyZSBzZWxlY3RlZCxcclxucmVkdWNlIGl0IHRvIGl0cyBtYWluIHJhbmdlLiBPdGhlcndpc2UsIGlmIHRoZSBzZWxlY3Rpb24gaXNcclxubm9uLWVtcHR5LCBjb252ZXJ0IGl0IHRvIGEgY3Vyc29yIHNlbGVjdGlvbi5cclxuKi9cclxuY29uc3Qgc2ltcGxpZnlTZWxlY3Rpb24gPSAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xyXG4gICAgbGV0IGN1ciA9IHN0YXRlLnNlbGVjdGlvbiwgc2VsZWN0aW9uID0gbnVsbDtcclxuICAgIGlmIChjdXIucmFuZ2VzLmxlbmd0aCA+IDEpXHJcbiAgICAgICAgc2VsZWN0aW9uID0gRWRpdG9yU2VsZWN0aW9uLmNyZWF0ZShbY3VyLm1haW5dKTtcclxuICAgIGVsc2UgaWYgKCFjdXIubWFpbi5lbXB0eSlcclxuICAgICAgICBzZWxlY3Rpb24gPSBFZGl0b3JTZWxlY3Rpb24uY3JlYXRlKFtFZGl0b3JTZWxlY3Rpb24uY3Vyc29yKGN1ci5tYWluLmhlYWQpXSk7XHJcbiAgICBpZiAoIXNlbGVjdGlvbilcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICBkaXNwYXRjaChzZXRTZWwoc3RhdGUsIHNlbGVjdGlvbikpO1xyXG4gICAgcmV0dXJuIHRydWU7XHJcbn07XHJcbmZ1bmN0aW9uIGRlbGV0ZUJ5KHRhcmdldCwgYnkpIHtcclxuICAgIGlmICh0YXJnZXQuc3RhdGUucmVhZE9ubHkpXHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgbGV0IGV2ZW50ID0gXCJkZWxldGUuc2VsZWN0aW9uXCIsIHsgc3RhdGUgfSA9IHRhcmdldDtcclxuICAgIGxldCBjaGFuZ2VzID0gc3RhdGUuY2hhbmdlQnlSYW5nZShyYW5nZSA9PiB7XHJcbiAgICAgICAgbGV0IHsgZnJvbSwgdG8gfSA9IHJhbmdlO1xyXG4gICAgICAgIGlmIChmcm9tID09IHRvKSB7XHJcbiAgICAgICAgICAgIGxldCB0b3dhcmRzID0gYnkoZnJvbSk7XHJcbiAgICAgICAgICAgIGlmICh0b3dhcmRzIDwgZnJvbSkge1xyXG4gICAgICAgICAgICAgICAgZXZlbnQgPSBcImRlbGV0ZS5iYWNrd2FyZFwiO1xyXG4gICAgICAgICAgICAgICAgdG93YXJkcyA9IHNraXBBdG9taWModGFyZ2V0LCB0b3dhcmRzLCBmYWxzZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAodG93YXJkcyA+IGZyb20pIHtcclxuICAgICAgICAgICAgICAgIGV2ZW50ID0gXCJkZWxldGUuZm9yd2FyZFwiO1xyXG4gICAgICAgICAgICAgICAgdG93YXJkcyA9IHNraXBBdG9taWModGFyZ2V0LCB0b3dhcmRzLCB0cnVlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBmcm9tID0gTWF0aC5taW4oZnJvbSwgdG93YXJkcyk7XHJcbiAgICAgICAgICAgIHRvID0gTWF0aC5tYXgodG8sIHRvd2FyZHMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgZnJvbSA9IHNraXBBdG9taWModGFyZ2V0LCBmcm9tLCBmYWxzZSk7XHJcbiAgICAgICAgICAgIHRvID0gc2tpcEF0b21pYyh0YXJnZXQsIHRvLCB0cnVlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGZyb20gPT0gdG8gPyB7IHJhbmdlIH0gOiB7IGNoYW5nZXM6IHsgZnJvbSwgdG8gfSwgcmFuZ2U6IEVkaXRvclNlbGVjdGlvbi5jdXJzb3IoZnJvbSkgfTtcclxuICAgIH0pO1xyXG4gICAgaWYgKGNoYW5nZXMuY2hhbmdlcy5lbXB0eSlcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB0YXJnZXQuZGlzcGF0Y2goc3RhdGUudXBkYXRlKGNoYW5nZXMsIHtcclxuICAgICAgICBzY3JvbGxJbnRvVmlldzogdHJ1ZSxcclxuICAgICAgICB1c2VyRXZlbnQ6IGV2ZW50LFxyXG4gICAgICAgIGVmZmVjdHM6IGV2ZW50ID09IFwiZGVsZXRlLnNlbGVjdGlvblwiID8gRWRpdG9yVmlldy5hbm5vdW5jZS5vZihzdGF0ZS5waHJhc2UoXCJTZWxlY3Rpb24gZGVsZXRlZFwiKSkgOiB1bmRlZmluZWRcclxuICAgIH0pKTtcclxuICAgIHJldHVybiB0cnVlO1xyXG59XHJcbmZ1bmN0aW9uIHNraXBBdG9taWModGFyZ2V0LCBwb3MsIGZvcndhcmQpIHtcclxuICAgIGlmICh0YXJnZXQgaW5zdGFuY2VvZiBFZGl0b3JWaWV3KVxyXG4gICAgICAgIGZvciAobGV0IHJhbmdlcyBvZiB0YXJnZXQuc3RhdGUuZmFjZXQoRWRpdG9yVmlldy5hdG9taWNSYW5nZXMpLm1hcChmID0+IGYodGFyZ2V0KSkpXHJcbiAgICAgICAgICAgIHJhbmdlcy5iZXR3ZWVuKHBvcywgcG9zLCAoZnJvbSwgdG8pID0+IHtcclxuICAgICAgICAgICAgICAgIGlmIChmcm9tIDwgcG9zICYmIHRvID4gcG9zKVxyXG4gICAgICAgICAgICAgICAgICAgIHBvcyA9IGZvcndhcmQgPyB0byA6IGZyb207XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgcmV0dXJuIHBvcztcclxufVxyXG5jb25zdCBkZWxldGVCeUNoYXIgPSAodGFyZ2V0LCBmb3J3YXJkKSA9PiBkZWxldGVCeSh0YXJnZXQsIHBvcyA9PiB7XHJcbiAgICBsZXQgeyBzdGF0ZSB9ID0gdGFyZ2V0LCBsaW5lID0gc3RhdGUuZG9jLmxpbmVBdChwb3MpLCBiZWZvcmUsIHRhcmdldFBvcztcclxuICAgIGlmICghZm9yd2FyZCAmJiBwb3MgPiBsaW5lLmZyb20gJiYgcG9zIDwgbGluZS5mcm9tICsgMjAwICYmXHJcbiAgICAgICAgIS9bXiBcXHRdLy50ZXN0KGJlZm9yZSA9IGxpbmUudGV4dC5zbGljZSgwLCBwb3MgLSBsaW5lLmZyb20pKSkge1xyXG4gICAgICAgIGlmIChiZWZvcmVbYmVmb3JlLmxlbmd0aCAtIDFdID09IFwiXFx0XCIpXHJcbiAgICAgICAgICAgIHJldHVybiBwb3MgLSAxO1xyXG4gICAgICAgIGxldCBjb2wgPSBjb3VudENvbHVtbihiZWZvcmUsIHN0YXRlLnRhYlNpemUpLCBkcm9wID0gY29sICUgZ2V0SW5kZW50VW5pdChzdGF0ZSkgfHwgZ2V0SW5kZW50VW5pdChzdGF0ZSk7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkcm9wICYmIGJlZm9yZVtiZWZvcmUubGVuZ3RoIC0gMSAtIGldID09IFwiIFwiOyBpKyspXHJcbiAgICAgICAgICAgIHBvcy0tO1xyXG4gICAgICAgIHRhcmdldFBvcyA9IHBvcztcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHRhcmdldFBvcyA9IGZpbmRDbHVzdGVyQnJlYWsobGluZS50ZXh0LCBwb3MgLSBsaW5lLmZyb20sIGZvcndhcmQsIGZvcndhcmQpICsgbGluZS5mcm9tO1xyXG4gICAgICAgIGlmICh0YXJnZXRQb3MgPT0gcG9zICYmIGxpbmUubnVtYmVyICE9IChmb3J3YXJkID8gc3RhdGUuZG9jLmxpbmVzIDogMSkpXHJcbiAgICAgICAgICAgIHRhcmdldFBvcyArPSBmb3J3YXJkID8gMSA6IC0xO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRhcmdldFBvcztcclxufSk7XHJcbi8qKlxyXG5EZWxldGUgdGhlIHNlbGVjdGlvbiwgb3IsIGZvciBjdXJzb3Igc2VsZWN0aW9ucywgdGhlIGNoYXJhY3RlclxyXG5iZWZvcmUgdGhlIGN1cnNvci5cclxuKi9cclxuY29uc3QgZGVsZXRlQ2hhckJhY2t3YXJkID0gdmlldyA9PiBkZWxldGVCeUNoYXIodmlldywgZmFsc2UpO1xyXG4vKipcclxuRGVsZXRlIHRoZSBzZWxlY3Rpb24gb3IgdGhlIGNoYXJhY3RlciBhZnRlciB0aGUgY3Vyc29yLlxyXG4qL1xyXG5jb25zdCBkZWxldGVDaGFyRm9yd2FyZCA9IHZpZXcgPT4gZGVsZXRlQnlDaGFyKHZpZXcsIHRydWUpO1xyXG5jb25zdCBkZWxldGVCeUdyb3VwID0gKHRhcmdldCwgZm9yd2FyZCkgPT4gZGVsZXRlQnkodGFyZ2V0LCBzdGFydCA9PiB7XHJcbiAgICBsZXQgcG9zID0gc3RhcnQsIHsgc3RhdGUgfSA9IHRhcmdldCwgbGluZSA9IHN0YXRlLmRvYy5saW5lQXQocG9zKTtcclxuICAgIGxldCBjYXRlZ29yaXplID0gc3RhdGUuY2hhckNhdGVnb3JpemVyKHBvcyk7XHJcbiAgICBmb3IgKGxldCBjYXQgPSBudWxsOzspIHtcclxuICAgICAgICBpZiAocG9zID09IChmb3J3YXJkID8gbGluZS50byA6IGxpbmUuZnJvbSkpIHtcclxuICAgICAgICAgICAgaWYgKHBvcyA9PSBzdGFydCAmJiBsaW5lLm51bWJlciAhPSAoZm9yd2FyZCA/IHN0YXRlLmRvYy5saW5lcyA6IDEpKVxyXG4gICAgICAgICAgICAgICAgcG9zICs9IGZvcndhcmQgPyAxIDogLTE7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgbmV4dCA9IGZpbmRDbHVzdGVyQnJlYWsobGluZS50ZXh0LCBwb3MgLSBsaW5lLmZyb20sIGZvcndhcmQpICsgbGluZS5mcm9tO1xyXG4gICAgICAgIGxldCBuZXh0Q2hhciA9IGxpbmUudGV4dC5zbGljZShNYXRoLm1pbihwb3MsIG5leHQpIC0gbGluZS5mcm9tLCBNYXRoLm1heChwb3MsIG5leHQpIC0gbGluZS5mcm9tKTtcclxuICAgICAgICBsZXQgbmV4dENhdCA9IGNhdGVnb3JpemUobmV4dENoYXIpO1xyXG4gICAgICAgIGlmIChjYXQgIT0gbnVsbCAmJiBuZXh0Q2F0ICE9IGNhdClcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgaWYgKG5leHRDaGFyICE9IFwiIFwiIHx8IHBvcyAhPSBzdGFydClcclxuICAgICAgICAgICAgY2F0ID0gbmV4dENhdDtcclxuICAgICAgICBwb3MgPSBuZXh0O1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHBvcztcclxufSk7XHJcbi8qKlxyXG5EZWxldGUgdGhlIHNlbGVjdGlvbiBvciBiYWNrd2FyZCB1bnRpbCB0aGUgZW5kIG9mIHRoZSBuZXh0XHJcbltncm91cF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LkVkaXRvclZpZXcubW92ZUJ5R3JvdXApLCBvbmx5IHNraXBwaW5nIGdyb3VwcyBvZlxyXG53aGl0ZXNwYWNlIHdoZW4gdGhleSBjb25zaXN0IG9mIGEgc2luZ2xlIHNwYWNlLlxyXG4qL1xyXG5jb25zdCBkZWxldGVHcm91cEJhY2t3YXJkID0gdGFyZ2V0ID0+IGRlbGV0ZUJ5R3JvdXAodGFyZ2V0LCBmYWxzZSk7XHJcbi8qKlxyXG5EZWxldGUgdGhlIHNlbGVjdGlvbiBvciBmb3J3YXJkIHVudGlsIHRoZSBlbmQgb2YgdGhlIG5leHQgZ3JvdXAuXHJcbiovXHJcbmNvbnN0IGRlbGV0ZUdyb3VwRm9yd2FyZCA9IHRhcmdldCA9PiBkZWxldGVCeUdyb3VwKHRhcmdldCwgdHJ1ZSk7XHJcbi8qKlxyXG5EZWxldGUgdGhlIHNlbGVjdGlvbiwgb3IsIGlmIGl0IGlzIGEgY3Vyc29yIHNlbGVjdGlvbiwgZGVsZXRlIHRvXHJcbnRoZSBlbmQgb2YgdGhlIGxpbmUuIElmIHRoZSBjdXJzb3IgaXMgZGlyZWN0bHkgYXQgdGhlIGVuZCBvZiB0aGVcclxubGluZSwgZGVsZXRlIHRoZSBsaW5lIGJyZWFrIGFmdGVyIGl0LlxyXG4qL1xyXG5jb25zdCBkZWxldGVUb0xpbmVFbmQgPSB2aWV3ID0+IGRlbGV0ZUJ5KHZpZXcsIHBvcyA9PiB7XHJcbiAgICBsZXQgbGluZUVuZCA9IHZpZXcubGluZUJsb2NrQXQocG9zKS50bztcclxuICAgIHJldHVybiBwb3MgPCBsaW5lRW5kID8gbGluZUVuZCA6IE1hdGgubWluKHZpZXcuc3RhdGUuZG9jLmxlbmd0aCwgcG9zICsgMSk7XHJcbn0pO1xyXG4vKipcclxuRGVsZXRlIHRoZSBzZWxlY3Rpb24sIG9yLCBpZiBpdCBpcyBhIGN1cnNvciBzZWxlY3Rpb24sIGRlbGV0ZSB0b1xyXG50aGUgc3RhcnQgb2YgdGhlIGxpbmUuIElmIHRoZSBjdXJzb3IgaXMgZGlyZWN0bHkgYXQgdGhlIHN0YXJ0IG9mIHRoZVxyXG5saW5lLCBkZWxldGUgdGhlIGxpbmUgYnJlYWsgYmVmb3JlIGl0LlxyXG4qL1xyXG5jb25zdCBkZWxldGVUb0xpbmVTdGFydCA9IHZpZXcgPT4gZGVsZXRlQnkodmlldywgcG9zID0+IHtcclxuICAgIGxldCBsaW5lU3RhcnQgPSB2aWV3LmxpbmVCbG9ja0F0KHBvcykuZnJvbTtcclxuICAgIHJldHVybiBwb3MgPiBsaW5lU3RhcnQgPyBsaW5lU3RhcnQgOiBNYXRoLm1heCgwLCBwb3MgLSAxKTtcclxufSk7XHJcbi8qKlxyXG5EZWxldGUgYWxsIHdoaXRlc3BhY2UgZGlyZWN0bHkgYmVmb3JlIGEgbGluZSBlbmQgZnJvbSB0aGVcclxuZG9jdW1lbnQuXHJcbiovXHJcbmNvbnN0IGRlbGV0ZVRyYWlsaW5nV2hpdGVzcGFjZSA9ICh7IHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB7XHJcbiAgICBpZiAoc3RhdGUucmVhZE9ubHkpXHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgbGV0IGNoYW5nZXMgPSBbXTtcclxuICAgIGZvciAobGV0IHBvcyA9IDAsIHByZXYgPSBcIlwiLCBpdGVyID0gc3RhdGUuZG9jLml0ZXIoKTs7KSB7XHJcbiAgICAgICAgaXRlci5uZXh0KCk7XHJcbiAgICAgICAgaWYgKGl0ZXIubGluZUJyZWFrIHx8IGl0ZXIuZG9uZSkge1xyXG4gICAgICAgICAgICBsZXQgdHJhaWxpbmcgPSBwcmV2LnNlYXJjaCgvXFxzKyQvKTtcclxuICAgICAgICAgICAgaWYgKHRyYWlsaW5nID4gLTEpXHJcbiAgICAgICAgICAgICAgICBjaGFuZ2VzLnB1c2goeyBmcm9tOiBwb3MgLSAocHJldi5sZW5ndGggLSB0cmFpbGluZyksIHRvOiBwb3MgfSk7XHJcbiAgICAgICAgICAgIGlmIChpdGVyLmRvbmUpXHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgcHJldiA9IFwiXCI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBwcmV2ID0gaXRlci52YWx1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcG9zICs9IGl0ZXIudmFsdWUubGVuZ3RoO1xyXG4gICAgfVxyXG4gICAgaWYgKCFjaGFuZ2VzLmxlbmd0aClcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICBkaXNwYXRjaChzdGF0ZS51cGRhdGUoeyBjaGFuZ2VzLCB1c2VyRXZlbnQ6IFwiZGVsZXRlXCIgfSkpO1xyXG4gICAgcmV0dXJuIHRydWU7XHJcbn07XHJcbi8qKlxyXG5SZXBsYWNlIGVhY2ggc2VsZWN0aW9uIHJhbmdlIHdpdGggYSBsaW5lIGJyZWFrLCBsZWF2aW5nIHRoZSBjdXJzb3Jcclxub24gdGhlIGxpbmUgYmVmb3JlIHRoZSBicmVhay5cclxuKi9cclxuY29uc3Qgc3BsaXRMaW5lID0gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcclxuICAgIGlmIChzdGF0ZS5yZWFkT25seSlcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICBsZXQgY2hhbmdlcyA9IHN0YXRlLmNoYW5nZUJ5UmFuZ2UocmFuZ2UgPT4ge1xyXG4gICAgICAgIHJldHVybiB7IGNoYW5nZXM6IHsgZnJvbTogcmFuZ2UuZnJvbSwgdG86IHJhbmdlLnRvLCBpbnNlcnQ6IFRleHQub2YoW1wiXCIsIFwiXCJdKSB9LFxyXG4gICAgICAgICAgICByYW5nZTogRWRpdG9yU2VsZWN0aW9uLmN1cnNvcihyYW5nZS5mcm9tKSB9O1xyXG4gICAgfSk7XHJcbiAgICBkaXNwYXRjaChzdGF0ZS51cGRhdGUoY2hhbmdlcywgeyBzY3JvbGxJbnRvVmlldzogdHJ1ZSwgdXNlckV2ZW50OiBcImlucHV0XCIgfSkpO1xyXG4gICAgcmV0dXJuIHRydWU7XHJcbn07XHJcbi8qKlxyXG5GbGlwIHRoZSBjaGFyYWN0ZXJzIGJlZm9yZSBhbmQgYWZ0ZXIgdGhlIGN1cnNvcihzKS5cclxuKi9cclxuY29uc3QgdHJhbnNwb3NlQ2hhcnMgPSAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xyXG4gICAgaWYgKHN0YXRlLnJlYWRPbmx5KVxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIGxldCBjaGFuZ2VzID0gc3RhdGUuY2hhbmdlQnlSYW5nZShyYW5nZSA9PiB7XHJcbiAgICAgICAgaWYgKCFyYW5nZS5lbXB0eSB8fCByYW5nZS5mcm9tID09IDAgfHwgcmFuZ2UuZnJvbSA9PSBzdGF0ZS5kb2MubGVuZ3RoKVxyXG4gICAgICAgICAgICByZXR1cm4geyByYW5nZSB9O1xyXG4gICAgICAgIGxldCBwb3MgPSByYW5nZS5mcm9tLCBsaW5lID0gc3RhdGUuZG9jLmxpbmVBdChwb3MpO1xyXG4gICAgICAgIGxldCBmcm9tID0gcG9zID09IGxpbmUuZnJvbSA/IHBvcyAtIDEgOiBmaW5kQ2x1c3RlckJyZWFrKGxpbmUudGV4dCwgcG9zIC0gbGluZS5mcm9tLCBmYWxzZSkgKyBsaW5lLmZyb207XHJcbiAgICAgICAgbGV0IHRvID0gcG9zID09IGxpbmUudG8gPyBwb3MgKyAxIDogZmluZENsdXN0ZXJCcmVhayhsaW5lLnRleHQsIHBvcyAtIGxpbmUuZnJvbSwgdHJ1ZSkgKyBsaW5lLmZyb207XHJcbiAgICAgICAgcmV0dXJuIHsgY2hhbmdlczogeyBmcm9tLCB0bywgaW5zZXJ0OiBzdGF0ZS5kb2Muc2xpY2UocG9zLCB0bykuYXBwZW5kKHN0YXRlLmRvYy5zbGljZShmcm9tLCBwb3MpKSB9LFxyXG4gICAgICAgICAgICByYW5nZTogRWRpdG9yU2VsZWN0aW9uLmN1cnNvcih0bykgfTtcclxuICAgIH0pO1xyXG4gICAgaWYgKGNoYW5nZXMuY2hhbmdlcy5lbXB0eSlcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICBkaXNwYXRjaChzdGF0ZS51cGRhdGUoY2hhbmdlcywgeyBzY3JvbGxJbnRvVmlldzogdHJ1ZSwgdXNlckV2ZW50OiBcIm1vdmUuY2hhcmFjdGVyXCIgfSkpO1xyXG4gICAgcmV0dXJuIHRydWU7XHJcbn07XHJcbmZ1bmN0aW9uIHNlbGVjdGVkTGluZUJsb2NrcyhzdGF0ZSkge1xyXG4gICAgbGV0IGJsb2NrcyA9IFtdLCB1cHRvID0gLTE7XHJcbiAgICBmb3IgKGxldCByYW5nZSBvZiBzdGF0ZS5zZWxlY3Rpb24ucmFuZ2VzKSB7XHJcbiAgICAgICAgbGV0IHN0YXJ0TGluZSA9IHN0YXRlLmRvYy5saW5lQXQocmFuZ2UuZnJvbSksIGVuZExpbmUgPSBzdGF0ZS5kb2MubGluZUF0KHJhbmdlLnRvKTtcclxuICAgICAgICBpZiAoIXJhbmdlLmVtcHR5ICYmIHJhbmdlLnRvID09IGVuZExpbmUuZnJvbSlcclxuICAgICAgICAgICAgZW5kTGluZSA9IHN0YXRlLmRvYy5saW5lQXQocmFuZ2UudG8gLSAxKTtcclxuICAgICAgICBpZiAodXB0byA+PSBzdGFydExpbmUubnVtYmVyKSB7XHJcbiAgICAgICAgICAgIGxldCBwcmV2ID0gYmxvY2tzW2Jsb2Nrcy5sZW5ndGggLSAxXTtcclxuICAgICAgICAgICAgcHJldi50byA9IGVuZExpbmUudG87XHJcbiAgICAgICAgICAgIHByZXYucmFuZ2VzLnB1c2gocmFuZ2UpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgYmxvY2tzLnB1c2goeyBmcm9tOiBzdGFydExpbmUuZnJvbSwgdG86IGVuZExpbmUudG8sIHJhbmdlczogW3JhbmdlXSB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdXB0byA9IGVuZExpbmUubnVtYmVyICsgMTtcclxuICAgIH1cclxuICAgIHJldHVybiBibG9ja3M7XHJcbn1cclxuZnVuY3Rpb24gbW92ZUxpbmUoc3RhdGUsIGRpc3BhdGNoLCBmb3J3YXJkKSB7XHJcbiAgICBpZiAoc3RhdGUucmVhZE9ubHkpXHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgbGV0IGNoYW5nZXMgPSBbXSwgcmFuZ2VzID0gW107XHJcbiAgICBmb3IgKGxldCBibG9jayBvZiBzZWxlY3RlZExpbmVCbG9ja3Moc3RhdGUpKSB7XHJcbiAgICAgICAgaWYgKGZvcndhcmQgPyBibG9jay50byA9PSBzdGF0ZS5kb2MubGVuZ3RoIDogYmxvY2suZnJvbSA9PSAwKVxyXG4gICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICBsZXQgbmV4dExpbmUgPSBzdGF0ZS5kb2MubGluZUF0KGZvcndhcmQgPyBibG9jay50byArIDEgOiBibG9jay5mcm9tIC0gMSk7XHJcbiAgICAgICAgbGV0IHNpemUgPSBuZXh0TGluZS5sZW5ndGggKyAxO1xyXG4gICAgICAgIGlmIChmb3J3YXJkKSB7XHJcbiAgICAgICAgICAgIGNoYW5nZXMucHVzaCh7IGZyb206IGJsb2NrLnRvLCB0bzogbmV4dExpbmUudG8gfSwgeyBmcm9tOiBibG9jay5mcm9tLCBpbnNlcnQ6IG5leHRMaW5lLnRleHQgKyBzdGF0ZS5saW5lQnJlYWsgfSk7XHJcbiAgICAgICAgICAgIGZvciAobGV0IHIgb2YgYmxvY2sucmFuZ2VzKVxyXG4gICAgICAgICAgICAgICAgcmFuZ2VzLnB1c2goRWRpdG9yU2VsZWN0aW9uLnJhbmdlKE1hdGgubWluKHN0YXRlLmRvYy5sZW5ndGgsIHIuYW5jaG9yICsgc2l6ZSksIE1hdGgubWluKHN0YXRlLmRvYy5sZW5ndGgsIHIuaGVhZCArIHNpemUpKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBjaGFuZ2VzLnB1c2goeyBmcm9tOiBuZXh0TGluZS5mcm9tLCB0bzogYmxvY2suZnJvbSB9LCB7IGZyb206IGJsb2NrLnRvLCBpbnNlcnQ6IHN0YXRlLmxpbmVCcmVhayArIG5leHRMaW5lLnRleHQgfSk7XHJcbiAgICAgICAgICAgIGZvciAobGV0IHIgb2YgYmxvY2sucmFuZ2VzKVxyXG4gICAgICAgICAgICAgICAgcmFuZ2VzLnB1c2goRWRpdG9yU2VsZWN0aW9uLnJhbmdlKHIuYW5jaG9yIC0gc2l6ZSwgci5oZWFkIC0gc2l6ZSkpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGlmICghY2hhbmdlcy5sZW5ndGgpXHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgZGlzcGF0Y2goc3RhdGUudXBkYXRlKHtcclxuICAgICAgICBjaGFuZ2VzLFxyXG4gICAgICAgIHNjcm9sbEludG9WaWV3OiB0cnVlLFxyXG4gICAgICAgIHNlbGVjdGlvbjogRWRpdG9yU2VsZWN0aW9uLmNyZWF0ZShyYW5nZXMsIHN0YXRlLnNlbGVjdGlvbi5tYWluSW5kZXgpLFxyXG4gICAgICAgIHVzZXJFdmVudDogXCJtb3ZlLmxpbmVcIlxyXG4gICAgfSkpO1xyXG4gICAgcmV0dXJuIHRydWU7XHJcbn1cclxuLyoqXHJcbk1vdmUgdGhlIHNlbGVjdGVkIGxpbmVzIHVwIG9uZSBsaW5lLlxyXG4qL1xyXG5jb25zdCBtb3ZlTGluZVVwID0gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IG1vdmVMaW5lKHN0YXRlLCBkaXNwYXRjaCwgZmFsc2UpO1xyXG4vKipcclxuTW92ZSB0aGUgc2VsZWN0ZWQgbGluZXMgZG93biBvbmUgbGluZS5cclxuKi9cclxuY29uc3QgbW92ZUxpbmVEb3duID0gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IG1vdmVMaW5lKHN0YXRlLCBkaXNwYXRjaCwgdHJ1ZSk7XHJcbmZ1bmN0aW9uIGNvcHlMaW5lKHN0YXRlLCBkaXNwYXRjaCwgZm9yd2FyZCkge1xyXG4gICAgaWYgKHN0YXRlLnJlYWRPbmx5KVxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIGxldCBjaGFuZ2VzID0gW107XHJcbiAgICBmb3IgKGxldCBibG9jayBvZiBzZWxlY3RlZExpbmVCbG9ja3Moc3RhdGUpKSB7XHJcbiAgICAgICAgaWYgKGZvcndhcmQpXHJcbiAgICAgICAgICAgIGNoYW5nZXMucHVzaCh7IGZyb206IGJsb2NrLmZyb20sIGluc2VydDogc3RhdGUuZG9jLnNsaWNlKGJsb2NrLmZyb20sIGJsb2NrLnRvKSArIHN0YXRlLmxpbmVCcmVhayB9KTtcclxuICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIGNoYW5nZXMucHVzaCh7IGZyb206IGJsb2NrLnRvLCBpbnNlcnQ6IHN0YXRlLmxpbmVCcmVhayArIHN0YXRlLmRvYy5zbGljZShibG9jay5mcm9tLCBibG9jay50bykgfSk7XHJcbiAgICB9XHJcbiAgICBkaXNwYXRjaChzdGF0ZS51cGRhdGUoeyBjaGFuZ2VzLCBzY3JvbGxJbnRvVmlldzogdHJ1ZSwgdXNlckV2ZW50OiBcImlucHV0LmNvcHlsaW5lXCIgfSkpO1xyXG4gICAgcmV0dXJuIHRydWU7XHJcbn1cclxuLyoqXHJcbkNyZWF0ZSBhIGNvcHkgb2YgdGhlIHNlbGVjdGVkIGxpbmVzLiBLZWVwIHRoZSBzZWxlY3Rpb24gaW4gdGhlIHRvcCBjb3B5LlxyXG4qL1xyXG5jb25zdCBjb3B5TGluZVVwID0gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IGNvcHlMaW5lKHN0YXRlLCBkaXNwYXRjaCwgZmFsc2UpO1xyXG4vKipcclxuQ3JlYXRlIGEgY29weSBvZiB0aGUgc2VsZWN0ZWQgbGluZXMuIEtlZXAgdGhlIHNlbGVjdGlvbiBpbiB0aGUgYm90dG9tIGNvcHkuXHJcbiovXHJcbmNvbnN0IGNvcHlMaW5lRG93biA9ICh7IHN0YXRlLCBkaXNwYXRjaCB9KSA9PiBjb3B5TGluZShzdGF0ZSwgZGlzcGF0Y2gsIHRydWUpO1xyXG4vKipcclxuRGVsZXRlIHNlbGVjdGVkIGxpbmVzLlxyXG4qL1xyXG5jb25zdCBkZWxldGVMaW5lID0gdmlldyA9PiB7XHJcbiAgICBpZiAodmlldy5zdGF0ZS5yZWFkT25seSlcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICBsZXQgeyBzdGF0ZSB9ID0gdmlldywgY2hhbmdlcyA9IHN0YXRlLmNoYW5nZXMoc2VsZWN0ZWRMaW5lQmxvY2tzKHN0YXRlKS5tYXAoKHsgZnJvbSwgdG8gfSkgPT4ge1xyXG4gICAgICAgIGlmIChmcm9tID4gMClcclxuICAgICAgICAgICAgZnJvbS0tO1xyXG4gICAgICAgIGVsc2UgaWYgKHRvIDwgc3RhdGUuZG9jLmxlbmd0aClcclxuICAgICAgICAgICAgdG8rKztcclxuICAgICAgICByZXR1cm4geyBmcm9tLCB0byB9O1xyXG4gICAgfSkpO1xyXG4gICAgbGV0IHNlbGVjdGlvbiA9IHVwZGF0ZVNlbChzdGF0ZS5zZWxlY3Rpb24sIHJhbmdlID0+IHZpZXcubW92ZVZlcnRpY2FsbHkocmFuZ2UsIHRydWUpKS5tYXAoY2hhbmdlcyk7XHJcbiAgICB2aWV3LmRpc3BhdGNoKHsgY2hhbmdlcywgc2VsZWN0aW9uLCBzY3JvbGxJbnRvVmlldzogdHJ1ZSwgdXNlckV2ZW50OiBcImRlbGV0ZS5saW5lXCIgfSk7XHJcbiAgICByZXR1cm4gdHJ1ZTtcclxufTtcclxuLyoqXHJcblJlcGxhY2UgdGhlIHNlbGVjdGlvbiB3aXRoIGEgbmV3bGluZS5cclxuKi9cclxuY29uc3QgaW5zZXJ0TmV3bGluZSA9ICh7IHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB7XHJcbiAgICBkaXNwYXRjaChzdGF0ZS51cGRhdGUoc3RhdGUucmVwbGFjZVNlbGVjdGlvbihzdGF0ZS5saW5lQnJlYWspLCB7IHNjcm9sbEludG9WaWV3OiB0cnVlLCB1c2VyRXZlbnQ6IFwiaW5wdXRcIiB9KSk7XHJcbiAgICByZXR1cm4gdHJ1ZTtcclxufTtcclxuZnVuY3Rpb24gaXNCZXR3ZWVuQnJhY2tldHMoc3RhdGUsIHBvcykge1xyXG4gICAgaWYgKC9cXChcXCl8XFxbXFxdfFxce1xcfS8udGVzdChzdGF0ZS5zbGljZURvYyhwb3MgLSAxLCBwb3MgKyAxKSkpXHJcbiAgICAgICAgcmV0dXJuIHsgZnJvbTogcG9zLCB0bzogcG9zIH07XHJcbiAgICBsZXQgY29udGV4dCA9IHN5bnRheFRyZWUoc3RhdGUpLnJlc29sdmVJbm5lcihwb3MpO1xyXG4gICAgbGV0IGJlZm9yZSA9IGNvbnRleHQuY2hpbGRCZWZvcmUocG9zKSwgYWZ0ZXIgPSBjb250ZXh0LmNoaWxkQWZ0ZXIocG9zKSwgY2xvc2VkQnk7XHJcbiAgICBpZiAoYmVmb3JlICYmIGFmdGVyICYmIGJlZm9yZS50byA8PSBwb3MgJiYgYWZ0ZXIuZnJvbSA+PSBwb3MgJiZcclxuICAgICAgICAoY2xvc2VkQnkgPSBiZWZvcmUudHlwZS5wcm9wKE5vZGVQcm9wLmNsb3NlZEJ5KSkgJiYgY2xvc2VkQnkuaW5kZXhPZihhZnRlci5uYW1lKSA+IC0xICYmXHJcbiAgICAgICAgc3RhdGUuZG9jLmxpbmVBdChiZWZvcmUudG8pLmZyb20gPT0gc3RhdGUuZG9jLmxpbmVBdChhZnRlci5mcm9tKS5mcm9tKVxyXG4gICAgICAgIHJldHVybiB7IGZyb206IGJlZm9yZS50bywgdG86IGFmdGVyLmZyb20gfTtcclxuICAgIHJldHVybiBudWxsO1xyXG59XHJcbi8qKlxyXG5SZXBsYWNlIHRoZSBzZWxlY3Rpb24gd2l0aCBhIG5ld2xpbmUgYW5kIGluZGVudCB0aGUgbmV3bHkgY3JlYXRlZFxyXG5saW5lKHMpLiBJZiB0aGUgY3VycmVudCBsaW5lIGNvbnNpc3RzIG9ubHkgb2Ygd2hpdGVzcGFjZSwgdGhpc1xyXG53aWxsIGFsc28gZGVsZXRlIHRoYXQgd2hpdGVzcGFjZS4gV2hlbiB0aGUgY3Vyc29yIGlzIGJldHdlZW5cclxubWF0Y2hpbmcgYnJhY2tldHMsIGFuIGFkZGl0aW9uYWwgbmV3bGluZSB3aWxsIGJlIGluc2VydGVkIGFmdGVyXHJcbnRoZSBjdXJzb3IuXHJcbiovXHJcbmNvbnN0IGluc2VydE5ld2xpbmVBbmRJbmRlbnQgPSAvKkBfX1BVUkVfXyovbmV3bGluZUFuZEluZGVudChmYWxzZSk7XHJcbi8qKlxyXG5DcmVhdGUgYSBibGFuaywgaW5kZW50ZWQgbGluZSBiZWxvdyB0aGUgY3VycmVudCBsaW5lLlxyXG4qL1xyXG5jb25zdCBpbnNlcnRCbGFua0xpbmUgPSAvKkBfX1BVUkVfXyovbmV3bGluZUFuZEluZGVudCh0cnVlKTtcclxuZnVuY3Rpb24gbmV3bGluZUFuZEluZGVudChhdEVvZikge1xyXG4gICAgcmV0dXJuICh7IHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB7XHJcbiAgICAgICAgaWYgKHN0YXRlLnJlYWRPbmx5KVxyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgbGV0IGNoYW5nZXMgPSBzdGF0ZS5jaGFuZ2VCeVJhbmdlKHJhbmdlID0+IHtcclxuICAgICAgICAgICAgbGV0IHsgZnJvbSwgdG8gfSA9IHJhbmdlLCBsaW5lID0gc3RhdGUuZG9jLmxpbmVBdChmcm9tKTtcclxuICAgICAgICAgICAgbGV0IGV4cGxvZGUgPSAhYXRFb2YgJiYgZnJvbSA9PSB0byAmJiBpc0JldHdlZW5CcmFja2V0cyhzdGF0ZSwgZnJvbSk7XHJcbiAgICAgICAgICAgIGlmIChhdEVvZilcclxuICAgICAgICAgICAgICAgIGZyb20gPSB0byA9ICh0byA8PSBsaW5lLnRvID8gbGluZSA6IHN0YXRlLmRvYy5saW5lQXQodG8pKS50bztcclxuICAgICAgICAgICAgbGV0IGN4ID0gbmV3IEluZGVudENvbnRleHQoc3RhdGUsIHsgc2ltdWxhdGVCcmVhazogZnJvbSwgc2ltdWxhdGVEb3VibGVCcmVhazogISFleHBsb2RlIH0pO1xyXG4gICAgICAgICAgICBsZXQgaW5kZW50ID0gZ2V0SW5kZW50YXRpb24oY3gsIGZyb20pO1xyXG4gICAgICAgICAgICBpZiAoaW5kZW50ID09IG51bGwpXHJcbiAgICAgICAgICAgICAgICBpbmRlbnQgPSAvXlxccyovLmV4ZWMoc3RhdGUuZG9jLmxpbmVBdChmcm9tKS50ZXh0KVswXS5sZW5ndGg7XHJcbiAgICAgICAgICAgIHdoaWxlICh0byA8IGxpbmUudG8gJiYgL1xccy8udGVzdChsaW5lLnRleHRbdG8gLSBsaW5lLmZyb21dKSlcclxuICAgICAgICAgICAgICAgIHRvKys7XHJcbiAgICAgICAgICAgIGlmIChleHBsb2RlKVxyXG4gICAgICAgICAgICAgICAgKHsgZnJvbSwgdG8gfSA9IGV4cGxvZGUpO1xyXG4gICAgICAgICAgICBlbHNlIGlmIChmcm9tID4gbGluZS5mcm9tICYmIGZyb20gPCBsaW5lLmZyb20gKyAxMDAgJiYgIS9cXFMvLnRlc3QobGluZS50ZXh0LnNsaWNlKDAsIGZyb20pKSlcclxuICAgICAgICAgICAgICAgIGZyb20gPSBsaW5lLmZyb207XHJcbiAgICAgICAgICAgIGxldCBpbnNlcnQgPSBbXCJcIiwgaW5kZW50U3RyaW5nKHN0YXRlLCBpbmRlbnQpXTtcclxuICAgICAgICAgICAgaWYgKGV4cGxvZGUpXHJcbiAgICAgICAgICAgICAgICBpbnNlcnQucHVzaChpbmRlbnRTdHJpbmcoc3RhdGUsIGN4LmxpbmVJbmRlbnQobGluZS5mcm9tLCAtMSkpKTtcclxuICAgICAgICAgICAgcmV0dXJuIHsgY2hhbmdlczogeyBmcm9tLCB0bywgaW5zZXJ0OiBUZXh0Lm9mKGluc2VydCkgfSxcclxuICAgICAgICAgICAgICAgIHJhbmdlOiBFZGl0b3JTZWxlY3Rpb24uY3Vyc29yKGZyb20gKyAxICsgaW5zZXJ0WzFdLmxlbmd0aCkgfTtcclxuICAgICAgICB9KTtcclxuICAgICAgICBkaXNwYXRjaChzdGF0ZS51cGRhdGUoY2hhbmdlcywgeyBzY3JvbGxJbnRvVmlldzogdHJ1ZSwgdXNlckV2ZW50OiBcImlucHV0XCIgfSkpO1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiBjaGFuZ2VCeVNlbGVjdGVkTGluZShzdGF0ZSwgZikge1xyXG4gICAgbGV0IGF0TGluZSA9IC0xO1xyXG4gICAgcmV0dXJuIHN0YXRlLmNoYW5nZUJ5UmFuZ2UocmFuZ2UgPT4ge1xyXG4gICAgICAgIGxldCBjaGFuZ2VzID0gW107XHJcbiAgICAgICAgZm9yIChsZXQgcG9zID0gcmFuZ2UuZnJvbTsgcG9zIDw9IHJhbmdlLnRvOykge1xyXG4gICAgICAgICAgICBsZXQgbGluZSA9IHN0YXRlLmRvYy5saW5lQXQocG9zKTtcclxuICAgICAgICAgICAgaWYgKGxpbmUubnVtYmVyID4gYXRMaW5lICYmIChyYW5nZS5lbXB0eSB8fCByYW5nZS50byA+IGxpbmUuZnJvbSkpIHtcclxuICAgICAgICAgICAgICAgIGYobGluZSwgY2hhbmdlcywgcmFuZ2UpO1xyXG4gICAgICAgICAgICAgICAgYXRMaW5lID0gbGluZS5udW1iZXI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcG9zID0gbGluZS50byArIDE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCBjaGFuZ2VTZXQgPSBzdGF0ZS5jaGFuZ2VzKGNoYW5nZXMpO1xyXG4gICAgICAgIHJldHVybiB7IGNoYW5nZXMsXHJcbiAgICAgICAgICAgIHJhbmdlOiBFZGl0b3JTZWxlY3Rpb24ucmFuZ2UoY2hhbmdlU2V0Lm1hcFBvcyhyYW5nZS5hbmNob3IsIDEpLCBjaGFuZ2VTZXQubWFwUG9zKHJhbmdlLmhlYWQsIDEpKSB9O1xyXG4gICAgfSk7XHJcbn1cclxuLyoqXHJcbkF1dG8taW5kZW50IHRoZSBzZWxlY3RlZCBsaW5lcy4gVGhpcyB1c2VzIHRoZSBbaW5kZW50YXRpb24gc2VydmljZVxyXG5mYWNldF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNsYW5ndWFnZS5pbmRlbnRTZXJ2aWNlKSBhcyBzb3VyY2UgZm9yIGF1dG8taW5kZW50XHJcbmluZm9ybWF0aW9uLlxyXG4qL1xyXG5jb25zdCBpbmRlbnRTZWxlY3Rpb24gPSAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xyXG4gICAgaWYgKHN0YXRlLnJlYWRPbmx5KVxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIGxldCB1cGRhdGVkID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcclxuICAgIGxldCBjb250ZXh0ID0gbmV3IEluZGVudENvbnRleHQoc3RhdGUsIHsgb3ZlcnJpZGVJbmRlbnRhdGlvbjogc3RhcnQgPT4ge1xyXG4gICAgICAgICAgICBsZXQgZm91bmQgPSB1cGRhdGVkW3N0YXJ0XTtcclxuICAgICAgICAgICAgcmV0dXJuIGZvdW5kID09IG51bGwgPyAtMSA6IGZvdW5kO1xyXG4gICAgICAgIH0gfSk7XHJcbiAgICBsZXQgY2hhbmdlcyA9IGNoYW5nZUJ5U2VsZWN0ZWRMaW5lKHN0YXRlLCAobGluZSwgY2hhbmdlcywgcmFuZ2UpID0+IHtcclxuICAgICAgICBsZXQgaW5kZW50ID0gZ2V0SW5kZW50YXRpb24oY29udGV4dCwgbGluZS5mcm9tKTtcclxuICAgICAgICBpZiAoaW5kZW50ID09IG51bGwpXHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICBpZiAoIS9cXFMvLnRlc3QobGluZS50ZXh0KSlcclxuICAgICAgICAgICAgaW5kZW50ID0gMDtcclxuICAgICAgICBsZXQgY3VyID0gL15cXHMqLy5leGVjKGxpbmUudGV4dClbMF07XHJcbiAgICAgICAgbGV0IG5vcm0gPSBpbmRlbnRTdHJpbmcoc3RhdGUsIGluZGVudCk7XHJcbiAgICAgICAgaWYgKGN1ciAhPSBub3JtIHx8IHJhbmdlLmZyb20gPCBsaW5lLmZyb20gKyBjdXIubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHVwZGF0ZWRbbGluZS5mcm9tXSA9IGluZGVudDtcclxuICAgICAgICAgICAgY2hhbmdlcy5wdXNoKHsgZnJvbTogbGluZS5mcm9tLCB0bzogbGluZS5mcm9tICsgY3VyLmxlbmd0aCwgaW5zZXJ0OiBub3JtIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgaWYgKCFjaGFuZ2VzLmNoYW5nZXMuZW1wdHkpXHJcbiAgICAgICAgZGlzcGF0Y2goc3RhdGUudXBkYXRlKGNoYW5nZXMsIHsgdXNlckV2ZW50OiBcImluZGVudFwiIH0pKTtcclxuICAgIHJldHVybiB0cnVlO1xyXG59O1xyXG4vKipcclxuQWRkIGEgW3VuaXRdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jbGFuZ3VhZ2UuaW5kZW50VW5pdCkgb2YgaW5kZW50YXRpb24gdG8gYWxsIHNlbGVjdGVkXHJcbmxpbmVzLlxyXG4qL1xyXG5jb25zdCBpbmRlbnRNb3JlID0gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcclxuICAgIGlmIChzdGF0ZS5yZWFkT25seSlcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICBkaXNwYXRjaChzdGF0ZS51cGRhdGUoY2hhbmdlQnlTZWxlY3RlZExpbmUoc3RhdGUsIChsaW5lLCBjaGFuZ2VzKSA9PiB7XHJcbiAgICAgICAgY2hhbmdlcy5wdXNoKHsgZnJvbTogbGluZS5mcm9tLCBpbnNlcnQ6IHN0YXRlLmZhY2V0KGluZGVudFVuaXQpIH0pO1xyXG4gICAgfSksIHsgdXNlckV2ZW50OiBcImlucHV0LmluZGVudFwiIH0pKTtcclxuICAgIHJldHVybiB0cnVlO1xyXG59O1xyXG4vKipcclxuUmVtb3ZlIGEgW3VuaXRdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jbGFuZ3VhZ2UuaW5kZW50VW5pdCkgb2YgaW5kZW50YXRpb24gZnJvbSBhbGxcclxuc2VsZWN0ZWQgbGluZXMuXHJcbiovXHJcbmNvbnN0IGluZGVudExlc3MgPSAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xyXG4gICAgaWYgKHN0YXRlLnJlYWRPbmx5KVxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIGRpc3BhdGNoKHN0YXRlLnVwZGF0ZShjaGFuZ2VCeVNlbGVjdGVkTGluZShzdGF0ZSwgKGxpbmUsIGNoYW5nZXMpID0+IHtcclxuICAgICAgICBsZXQgc3BhY2UgPSAvXlxccyovLmV4ZWMobGluZS50ZXh0KVswXTtcclxuICAgICAgICBpZiAoIXNwYWNlKVxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgbGV0IGNvbCA9IGNvdW50Q29sdW1uKHNwYWNlLCBzdGF0ZS50YWJTaXplKSwga2VlcCA9IDA7XHJcbiAgICAgICAgbGV0IGluc2VydCA9IGluZGVudFN0cmluZyhzdGF0ZSwgTWF0aC5tYXgoMCwgY29sIC0gZ2V0SW5kZW50VW5pdChzdGF0ZSkpKTtcclxuICAgICAgICB3aGlsZSAoa2VlcCA8IHNwYWNlLmxlbmd0aCAmJiBrZWVwIDwgaW5zZXJ0Lmxlbmd0aCAmJiBzcGFjZS5jaGFyQ29kZUF0KGtlZXApID09IGluc2VydC5jaGFyQ29kZUF0KGtlZXApKVxyXG4gICAgICAgICAgICBrZWVwKys7XHJcbiAgICAgICAgY2hhbmdlcy5wdXNoKHsgZnJvbTogbGluZS5mcm9tICsga2VlcCwgdG86IGxpbmUuZnJvbSArIHNwYWNlLmxlbmd0aCwgaW5zZXJ0OiBpbnNlcnQuc2xpY2Uoa2VlcCkgfSk7XHJcbiAgICB9KSwgeyB1c2VyRXZlbnQ6IFwiZGVsZXRlLmRlZGVudFwiIH0pKTtcclxuICAgIHJldHVybiB0cnVlO1xyXG59O1xyXG4vKipcclxuSW5zZXJ0IGEgdGFiIGNoYXJhY3RlciBhdCB0aGUgY3Vyc29yIG9yLCBpZiBzb21ldGhpbmcgaXMgc2VsZWN0ZWQsXHJcbnVzZSBbYGluZGVudE1vcmVgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLmluZGVudE1vcmUpIHRvIGluZGVudCB0aGUgZW50aXJlXHJcbnNlbGVjdGlvbi5cclxuKi9cclxuY29uc3QgaW5zZXJ0VGFiID0gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcclxuICAgIGlmIChzdGF0ZS5zZWxlY3Rpb24ucmFuZ2VzLnNvbWUociA9PiAhci5lbXB0eSkpXHJcbiAgICAgICAgcmV0dXJuIGluZGVudE1vcmUoeyBzdGF0ZSwgZGlzcGF0Y2ggfSk7XHJcbiAgICBkaXNwYXRjaChzdGF0ZS51cGRhdGUoc3RhdGUucmVwbGFjZVNlbGVjdGlvbihcIlxcdFwiKSwgeyBzY3JvbGxJbnRvVmlldzogdHJ1ZSwgdXNlckV2ZW50OiBcImlucHV0XCIgfSkpO1xyXG4gICAgcmV0dXJuIHRydWU7XHJcbn07XHJcbi8qKlxyXG5BcnJheSBvZiBrZXkgYmluZGluZ3MgY29udGFpbmluZyB0aGUgRW1hY3Mtc3R5bGUgYmluZGluZ3MgdGhhdCBhcmVcclxuYXZhaWxhYmxlIG9uIG1hY09TIGJ5IGRlZmF1bHQuXHJcblxyXG4gLSBDdHJsLWI6IFtgY3Vyc29yQ2hhckxlZnRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLmN1cnNvckNoYXJMZWZ0KSAoW2BzZWxlY3RDaGFyTGVmdGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuc2VsZWN0Q2hhckxlZnQpIHdpdGggU2hpZnQpXHJcbiAtIEN0cmwtZjogW2BjdXJzb3JDaGFyUmlnaHRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLmN1cnNvckNoYXJSaWdodCkgKFtgc2VsZWN0Q2hhclJpZ2h0YF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5zZWxlY3RDaGFyUmlnaHQpIHdpdGggU2hpZnQpXHJcbiAtIEN0cmwtcDogW2BjdXJzb3JMaW5lVXBgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLmN1cnNvckxpbmVVcCkgKFtgc2VsZWN0TGluZVVwYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5zZWxlY3RMaW5lVXApIHdpdGggU2hpZnQpXHJcbiAtIEN0cmwtbjogW2BjdXJzb3JMaW5lRG93bmBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuY3Vyc29yTGluZURvd24pIChbYHNlbGVjdExpbmVEb3duYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5zZWxlY3RMaW5lRG93bikgd2l0aCBTaGlmdClcclxuIC0gQ3RybC1hOiBbYGN1cnNvckxpbmVTdGFydGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuY3Vyc29yTGluZVN0YXJ0KSAoW2BzZWxlY3RMaW5lU3RhcnRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLnNlbGVjdExpbmVTdGFydCkgd2l0aCBTaGlmdClcclxuIC0gQ3RybC1lOiBbYGN1cnNvckxpbmVFbmRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLmN1cnNvckxpbmVFbmQpIChbYHNlbGVjdExpbmVFbmRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLnNlbGVjdExpbmVFbmQpIHdpdGggU2hpZnQpXHJcbiAtIEN0cmwtZDogW2BkZWxldGVDaGFyRm9yd2FyZGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuZGVsZXRlQ2hhckZvcndhcmQpXHJcbiAtIEN0cmwtaDogW2BkZWxldGVDaGFyQmFja3dhcmRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLmRlbGV0ZUNoYXJCYWNrd2FyZClcclxuIC0gQ3RybC1rOiBbYGRlbGV0ZVRvTGluZUVuZGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuZGVsZXRlVG9MaW5lRW5kKVxyXG4gLSBDdHJsLUFsdC1oOiBbYGRlbGV0ZUdyb3VwQmFja3dhcmRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLmRlbGV0ZUdyb3VwQmFja3dhcmQpXHJcbiAtIEN0cmwtbzogW2BzcGxpdExpbmVgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLnNwbGl0TGluZSlcclxuIC0gQ3RybC10OiBbYHRyYW5zcG9zZUNoYXJzYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy50cmFuc3Bvc2VDaGFycylcclxuIC0gQ3RybC12OiBbYGN1cnNvclBhZ2VEb3duYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5jdXJzb3JQYWdlRG93bilcclxuIC0gQWx0LXY6IFtgY3Vyc29yUGFnZVVwYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5jdXJzb3JQYWdlVXApXHJcbiovXHJcbmNvbnN0IGVtYWNzU3R5bGVLZXltYXAgPSBbXHJcbiAgICB7IGtleTogXCJDdHJsLWJcIiwgcnVuOiBjdXJzb3JDaGFyTGVmdCwgc2hpZnQ6IHNlbGVjdENoYXJMZWZ0LCBwcmV2ZW50RGVmYXVsdDogdHJ1ZSB9LFxyXG4gICAgeyBrZXk6IFwiQ3RybC1mXCIsIHJ1bjogY3Vyc29yQ2hhclJpZ2h0LCBzaGlmdDogc2VsZWN0Q2hhclJpZ2h0IH0sXHJcbiAgICB7IGtleTogXCJDdHJsLXBcIiwgcnVuOiBjdXJzb3JMaW5lVXAsIHNoaWZ0OiBzZWxlY3RMaW5lVXAgfSxcclxuICAgIHsga2V5OiBcIkN0cmwtblwiLCBydW46IGN1cnNvckxpbmVEb3duLCBzaGlmdDogc2VsZWN0TGluZURvd24gfSxcclxuICAgIHsga2V5OiBcIkN0cmwtYVwiLCBydW46IGN1cnNvckxpbmVTdGFydCwgc2hpZnQ6IHNlbGVjdExpbmVTdGFydCB9LFxyXG4gICAgeyBrZXk6IFwiQ3RybC1lXCIsIHJ1bjogY3Vyc29yTGluZUVuZCwgc2hpZnQ6IHNlbGVjdExpbmVFbmQgfSxcclxuICAgIHsga2V5OiBcIkN0cmwtZFwiLCBydW46IGRlbGV0ZUNoYXJGb3J3YXJkIH0sXHJcbiAgICB7IGtleTogXCJDdHJsLWhcIiwgcnVuOiBkZWxldGVDaGFyQmFja3dhcmQgfSxcclxuICAgIHsga2V5OiBcIkN0cmwta1wiLCBydW46IGRlbGV0ZVRvTGluZUVuZCB9LFxyXG4gICAgeyBrZXk6IFwiQ3RybC1BbHQtaFwiLCBydW46IGRlbGV0ZUdyb3VwQmFja3dhcmQgfSxcclxuICAgIHsga2V5OiBcIkN0cmwtb1wiLCBydW46IHNwbGl0TGluZSB9LFxyXG4gICAgeyBrZXk6IFwiQ3RybC10XCIsIHJ1bjogdHJhbnNwb3NlQ2hhcnMgfSxcclxuICAgIHsga2V5OiBcIkN0cmwtdlwiLCBydW46IGN1cnNvclBhZ2VEb3duIH0sXHJcbl07XHJcbi8qKlxyXG5BbiBhcnJheSBvZiBrZXkgYmluZGluZ3MgY2xvc2VseSBzdGlja2luZyB0byBwbGF0Zm9ybS1zdGFuZGFyZCBvclxyXG53aWRlbHkgdXNlZCBiaW5kaW5ncy4gKFRoaXMgaW5jbHVkZXMgdGhlIGJpbmRpbmdzIGZyb21cclxuW2BlbWFjc1N0eWxlS2V5bWFwYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5lbWFjc1N0eWxlS2V5bWFwKSwgd2l0aCB0aGVpciBga2V5YFxyXG5wcm9wZXJ0eSBjaGFuZ2VkIHRvIGBtYWNgLilcclxuXHJcbiAtIEFycm93TGVmdDogW2BjdXJzb3JDaGFyTGVmdGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuY3Vyc29yQ2hhckxlZnQpIChbYHNlbGVjdENoYXJMZWZ0YF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5zZWxlY3RDaGFyTGVmdCkgd2l0aCBTaGlmdClcclxuIC0gQXJyb3dSaWdodDogW2BjdXJzb3JDaGFyUmlnaHRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLmN1cnNvckNoYXJSaWdodCkgKFtgc2VsZWN0Q2hhclJpZ2h0YF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5zZWxlY3RDaGFyUmlnaHQpIHdpdGggU2hpZnQpXHJcbiAtIEN0cmwtQXJyb3dMZWZ0IChBbHQtQXJyb3dMZWZ0IG9uIG1hY09TKTogW2BjdXJzb3JHcm91cExlZnRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLmN1cnNvckdyb3VwTGVmdCkgKFtgc2VsZWN0R3JvdXBMZWZ0YF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5zZWxlY3RHcm91cExlZnQpIHdpdGggU2hpZnQpXHJcbiAtIEN0cmwtQXJyb3dSaWdodCAoQWx0LUFycm93UmlnaHQgb24gbWFjT1MpOiBbYGN1cnNvckdyb3VwUmlnaHRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLmN1cnNvckdyb3VwUmlnaHQpIChbYHNlbGVjdEdyb3VwUmlnaHRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLnNlbGVjdEdyb3VwUmlnaHQpIHdpdGggU2hpZnQpXHJcbiAtIENtZC1BcnJvd0xlZnQgKG9uIG1hY09TKTogW2BjdXJzb3JMaW5lU3RhcnRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLmN1cnNvckxpbmVTdGFydCkgKFtgc2VsZWN0TGluZVN0YXJ0YF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5zZWxlY3RMaW5lU3RhcnQpIHdpdGggU2hpZnQpXHJcbiAtIENtZC1BcnJvd1JpZ2h0IChvbiBtYWNPUyk6IFtgY3Vyc29yTGluZUVuZGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuY3Vyc29yTGluZUVuZCkgKFtgc2VsZWN0TGluZUVuZGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuc2VsZWN0TGluZUVuZCkgd2l0aCBTaGlmdClcclxuIC0gQXJyb3dVcDogW2BjdXJzb3JMaW5lVXBgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLmN1cnNvckxpbmVVcCkgKFtgc2VsZWN0TGluZVVwYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5zZWxlY3RMaW5lVXApIHdpdGggU2hpZnQpXHJcbiAtIEFycm93RG93bjogW2BjdXJzb3JMaW5lRG93bmBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuY3Vyc29yTGluZURvd24pIChbYHNlbGVjdExpbmVEb3duYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5zZWxlY3RMaW5lRG93bikgd2l0aCBTaGlmdClcclxuIC0gQ21kLUFycm93VXAgKG9uIG1hY09TKTogW2BjdXJzb3JEb2NTdGFydGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuY3Vyc29yRG9jU3RhcnQpIChbYHNlbGVjdERvY1N0YXJ0YF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5zZWxlY3REb2NTdGFydCkgd2l0aCBTaGlmdClcclxuIC0gQ21kLUFycm93RG93biAob24gbWFjT1MpOiBbYGN1cnNvckRvY0VuZGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuY3Vyc29yRG9jRW5kKSAoW2BzZWxlY3REb2NFbmRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLnNlbGVjdERvY0VuZCkgd2l0aCBTaGlmdClcclxuIC0gQ3RybC1BcnJvd1VwIChvbiBtYWNPUyk6IFtgY3Vyc29yUGFnZVVwYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5jdXJzb3JQYWdlVXApIChbYHNlbGVjdFBhZ2VVcGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuc2VsZWN0UGFnZVVwKSB3aXRoIFNoaWZ0KVxyXG4gLSBDdHJsLUFycm93RG93biAob24gbWFjT1MpOiBbYGN1cnNvclBhZ2VEb3duYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5jdXJzb3JQYWdlRG93bikgKFtgc2VsZWN0UGFnZURvd25gXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLnNlbGVjdFBhZ2VEb3duKSB3aXRoIFNoaWZ0KVxyXG4gLSBQYWdlVXA6IFtgY3Vyc29yUGFnZVVwYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5jdXJzb3JQYWdlVXApIChbYHNlbGVjdFBhZ2VVcGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuc2VsZWN0UGFnZVVwKSB3aXRoIFNoaWZ0KVxyXG4gLSBQYWdlRG93bjogW2BjdXJzb3JQYWdlRG93bmBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuY3Vyc29yUGFnZURvd24pIChbYHNlbGVjdFBhZ2VEb3duYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5zZWxlY3RQYWdlRG93bikgd2l0aCBTaGlmdClcclxuIC0gSG9tZTogW2BjdXJzb3JMaW5lQm91bmRhcnlCYWNrd2FyZGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuY3Vyc29yTGluZUJvdW5kYXJ5QmFja3dhcmQpIChbYHNlbGVjdExpbmVCb3VuZGFyeUJhY2t3YXJkYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5zZWxlY3RMaW5lQm91bmRhcnlCYWNrd2FyZCkgd2l0aCBTaGlmdClcclxuIC0gRW5kOiBbYGN1cnNvckxpbmVCb3VuZGFyeUZvcndhcmRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLmN1cnNvckxpbmVCb3VuZGFyeUZvcndhcmQpIChbYHNlbGVjdExpbmVCb3VuZGFyeUZvcndhcmRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLnNlbGVjdExpbmVCb3VuZGFyeUZvcndhcmQpIHdpdGggU2hpZnQpXHJcbiAtIEN0cmwtSG9tZSAoQ21kLUhvbWUgb24gbWFjT1MpOiBbYGN1cnNvckRvY1N0YXJ0YF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5jdXJzb3JEb2NTdGFydCkgKFtgc2VsZWN0RG9jU3RhcnRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLnNlbGVjdERvY1N0YXJ0KSB3aXRoIFNoaWZ0KVxyXG4gLSBDdHJsLUVuZCAoQ21kLUhvbWUgb24gbWFjT1MpOiBbYGN1cnNvckRvY0VuZGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuY3Vyc29yRG9jRW5kKSAoW2BzZWxlY3REb2NFbmRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLnNlbGVjdERvY0VuZCkgd2l0aCBTaGlmdClcclxuIC0gRW50ZXI6IFtgaW5zZXJ0TmV3bGluZUFuZEluZGVudGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuaW5zZXJ0TmV3bGluZUFuZEluZGVudClcclxuIC0gQ3RybC1hIChDbWQtYSBvbiBtYWNPUyk6IFtgc2VsZWN0QWxsYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5zZWxlY3RBbGwpXHJcbiAtIEJhY2tzcGFjZTogW2BkZWxldGVDaGFyQmFja3dhcmRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLmRlbGV0ZUNoYXJCYWNrd2FyZClcclxuIC0gRGVsZXRlOiBbYGRlbGV0ZUNoYXJGb3J3YXJkYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5kZWxldGVDaGFyRm9yd2FyZClcclxuIC0gQ3RybC1CYWNrc3BhY2UgKEFsdC1CYWNrc3BhY2Ugb24gbWFjT1MpOiBbYGRlbGV0ZUdyb3VwQmFja3dhcmRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLmRlbGV0ZUdyb3VwQmFja3dhcmQpXHJcbiAtIEN0cmwtRGVsZXRlIChBbHQtRGVsZXRlIG9uIG1hY09TKTogW2BkZWxldGVHcm91cEZvcndhcmRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLmRlbGV0ZUdyb3VwRm9yd2FyZClcclxuIC0gQ21kLUJhY2tzcGFjZSAobWFjT1MpOiBbYGRlbGV0ZVRvTGluZVN0YXJ0YF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5kZWxldGVUb0xpbmVTdGFydCkuXHJcbiAtIENtZC1EZWxldGUgKG1hY09TKTogW2BkZWxldGVUb0xpbmVFbmRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLmRlbGV0ZVRvTGluZUVuZCkuXHJcbiovXHJcbmNvbnN0IHN0YW5kYXJkS2V5bWFwID0gLypAX19QVVJFX18qL1tcclxuICAgIHsga2V5OiBcIkFycm93TGVmdFwiLCBydW46IGN1cnNvckNoYXJMZWZ0LCBzaGlmdDogc2VsZWN0Q2hhckxlZnQsIHByZXZlbnREZWZhdWx0OiB0cnVlIH0sXHJcbiAgICB7IGtleTogXCJNb2QtQXJyb3dMZWZ0XCIsIG1hYzogXCJBbHQtQXJyb3dMZWZ0XCIsIHJ1bjogY3Vyc29yR3JvdXBMZWZ0LCBzaGlmdDogc2VsZWN0R3JvdXBMZWZ0LCBwcmV2ZW50RGVmYXVsdDogdHJ1ZSB9LFxyXG4gICAgeyBtYWM6IFwiQ21kLUFycm93TGVmdFwiLCBydW46IGN1cnNvckxpbmVCb3VuZGFyeUxlZnQsIHNoaWZ0OiBzZWxlY3RMaW5lQm91bmRhcnlMZWZ0LCBwcmV2ZW50RGVmYXVsdDogdHJ1ZSB9LFxyXG4gICAgeyBrZXk6IFwiQXJyb3dSaWdodFwiLCBydW46IGN1cnNvckNoYXJSaWdodCwgc2hpZnQ6IHNlbGVjdENoYXJSaWdodCwgcHJldmVudERlZmF1bHQ6IHRydWUgfSxcclxuICAgIHsga2V5OiBcIk1vZC1BcnJvd1JpZ2h0XCIsIG1hYzogXCJBbHQtQXJyb3dSaWdodFwiLCBydW46IGN1cnNvckdyb3VwUmlnaHQsIHNoaWZ0OiBzZWxlY3RHcm91cFJpZ2h0LCBwcmV2ZW50RGVmYXVsdDogdHJ1ZSB9LFxyXG4gICAgeyBtYWM6IFwiQ21kLUFycm93UmlnaHRcIiwgcnVuOiBjdXJzb3JMaW5lQm91bmRhcnlSaWdodCwgc2hpZnQ6IHNlbGVjdExpbmVCb3VuZGFyeVJpZ2h0LCBwcmV2ZW50RGVmYXVsdDogdHJ1ZSB9LFxyXG4gICAgeyBrZXk6IFwiQXJyb3dVcFwiLCBydW46IGN1cnNvckxpbmVVcCwgc2hpZnQ6IHNlbGVjdExpbmVVcCwgcHJldmVudERlZmF1bHQ6IHRydWUgfSxcclxuICAgIHsgbWFjOiBcIkNtZC1BcnJvd1VwXCIsIHJ1bjogY3Vyc29yRG9jU3RhcnQsIHNoaWZ0OiBzZWxlY3REb2NTdGFydCB9LFxyXG4gICAgeyBtYWM6IFwiQ3RybC1BcnJvd1VwXCIsIHJ1bjogY3Vyc29yUGFnZVVwLCBzaGlmdDogc2VsZWN0UGFnZVVwIH0sXHJcbiAgICB7IGtleTogXCJBcnJvd0Rvd25cIiwgcnVuOiBjdXJzb3JMaW5lRG93biwgc2hpZnQ6IHNlbGVjdExpbmVEb3duLCBwcmV2ZW50RGVmYXVsdDogdHJ1ZSB9LFxyXG4gICAgeyBtYWM6IFwiQ21kLUFycm93RG93blwiLCBydW46IGN1cnNvckRvY0VuZCwgc2hpZnQ6IHNlbGVjdERvY0VuZCB9LFxyXG4gICAgeyBtYWM6IFwiQ3RybC1BcnJvd0Rvd25cIiwgcnVuOiBjdXJzb3JQYWdlRG93biwgc2hpZnQ6IHNlbGVjdFBhZ2VEb3duIH0sXHJcbiAgICB7IGtleTogXCJQYWdlVXBcIiwgcnVuOiBjdXJzb3JQYWdlVXAsIHNoaWZ0OiBzZWxlY3RQYWdlVXAgfSxcclxuICAgIHsga2V5OiBcIlBhZ2VEb3duXCIsIHJ1bjogY3Vyc29yUGFnZURvd24sIHNoaWZ0OiBzZWxlY3RQYWdlRG93biB9LFxyXG4gICAgeyBrZXk6IFwiSG9tZVwiLCBydW46IGN1cnNvckxpbmVCb3VuZGFyeUJhY2t3YXJkLCBzaGlmdDogc2VsZWN0TGluZUJvdW5kYXJ5QmFja3dhcmQsIHByZXZlbnREZWZhdWx0OiB0cnVlIH0sXHJcbiAgICB7IGtleTogXCJNb2QtSG9tZVwiLCBydW46IGN1cnNvckRvY1N0YXJ0LCBzaGlmdDogc2VsZWN0RG9jU3RhcnQgfSxcclxuICAgIHsga2V5OiBcIkVuZFwiLCBydW46IGN1cnNvckxpbmVCb3VuZGFyeUZvcndhcmQsIHNoaWZ0OiBzZWxlY3RMaW5lQm91bmRhcnlGb3J3YXJkLCBwcmV2ZW50RGVmYXVsdDogdHJ1ZSB9LFxyXG4gICAgeyBrZXk6IFwiTW9kLUVuZFwiLCBydW46IGN1cnNvckRvY0VuZCwgc2hpZnQ6IHNlbGVjdERvY0VuZCB9LFxyXG4gICAgeyBrZXk6IFwiRW50ZXJcIiwgcnVuOiBpbnNlcnROZXdsaW5lQW5kSW5kZW50IH0sXHJcbiAgICB7IGtleTogXCJNb2QtYVwiLCBydW46IHNlbGVjdEFsbCB9LFxyXG4gICAgeyBrZXk6IFwiQmFja3NwYWNlXCIsIHJ1bjogZGVsZXRlQ2hhckJhY2t3YXJkLCBzaGlmdDogZGVsZXRlQ2hhckJhY2t3YXJkIH0sXHJcbiAgICB7IGtleTogXCJEZWxldGVcIiwgcnVuOiBkZWxldGVDaGFyRm9yd2FyZCB9LFxyXG4gICAgeyBrZXk6IFwiTW9kLUJhY2tzcGFjZVwiLCBtYWM6IFwiQWx0LUJhY2tzcGFjZVwiLCBydW46IGRlbGV0ZUdyb3VwQmFja3dhcmQgfSxcclxuICAgIHsga2V5OiBcIk1vZC1EZWxldGVcIiwgbWFjOiBcIkFsdC1EZWxldGVcIiwgcnVuOiBkZWxldGVHcm91cEZvcndhcmQgfSxcclxuICAgIHsgbWFjOiBcIk1vZC1CYWNrc3BhY2VcIiwgcnVuOiBkZWxldGVUb0xpbmVTdGFydCB9LFxyXG4gICAgeyBtYWM6IFwiTW9kLURlbGV0ZVwiLCBydW46IGRlbGV0ZVRvTGluZUVuZCB9XHJcbl0uY29uY2F0KC8qQF9fUFVSRV9fKi9lbWFjc1N0eWxlS2V5bWFwLm1hcChiID0+ICh7IG1hYzogYi5rZXksIHJ1bjogYi5ydW4sIHNoaWZ0OiBiLnNoaWZ0IH0pKSk7XHJcbi8qKlxyXG5UaGUgZGVmYXVsdCBrZXltYXAuIEluY2x1ZGVzIGFsbCBiaW5kaW5ncyBmcm9tXHJcbltgc3RhbmRhcmRLZXltYXBgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLnN0YW5kYXJkS2V5bWFwKSBwbHVzIHRoZSBmb2xsb3dpbmc6XHJcblxyXG4tIEFsdC1BcnJvd0xlZnQgKEN0cmwtQXJyb3dMZWZ0IG9uIG1hY09TKTogW2BjdXJzb3JTeW50YXhMZWZ0YF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5jdXJzb3JTeW50YXhMZWZ0KSAoW2BzZWxlY3RTeW50YXhMZWZ0YF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5zZWxlY3RTeW50YXhMZWZ0KSB3aXRoIFNoaWZ0KVxyXG4tIEFsdC1BcnJvd1JpZ2h0IChDdHJsLUFycm93UmlnaHQgb24gbWFjT1MpOiBbYGN1cnNvclN5bnRheFJpZ2h0YF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5jdXJzb3JTeW50YXhSaWdodCkgKFtgc2VsZWN0U3ludGF4UmlnaHRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLnNlbGVjdFN5bnRheFJpZ2h0KSB3aXRoIFNoaWZ0KVxyXG4tIEFsdC1BcnJvd1VwOiBbYG1vdmVMaW5lVXBgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLm1vdmVMaW5lVXApXHJcbi0gQWx0LUFycm93RG93bjogW2Btb3ZlTGluZURvd25gXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLm1vdmVMaW5lRG93bilcclxuLSBTaGlmdC1BbHQtQXJyb3dVcDogW2Bjb3B5TGluZVVwYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5jb3B5TGluZVVwKVxyXG4tIFNoaWZ0LUFsdC1BcnJvd0Rvd246IFtgY29weUxpbmVEb3duYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5jb3B5TGluZURvd24pXHJcbi0gRXNjYXBlOiBbYHNpbXBsaWZ5U2VsZWN0aW9uYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5zaW1wbGlmeVNlbGVjdGlvbilcclxuLSBDdHJsLUVudGVyIChDb21kLUVudGVyIG9uIG1hY09TKTogW2BpbnNlcnRCbGFua0xpbmVgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLmluc2VydEJsYW5rTGluZSlcclxuLSBBbHQtbCAoQ3RybC1sIG9uIG1hY09TKTogW2BzZWxlY3RMaW5lYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5zZWxlY3RMaW5lKVxyXG4tIEN0cmwtaSAoQ21kLWkgb24gbWFjT1MpOiBbYHNlbGVjdFBhcmVudFN5bnRheGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuc2VsZWN0UGFyZW50U3ludGF4KVxyXG4tIEN0cmwtWyAoQ21kLVsgb24gbWFjT1MpOiBbYGluZGVudExlc3NgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLmluZGVudExlc3MpXHJcbi0gQ3RybC1dIChDbWQtXSBvbiBtYWNPUyk6IFtgaW5kZW50TW9yZWBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuaW5kZW50TW9yZSlcclxuLSBDdHJsLUFsdC1cXFxcIChDbWQtQWx0LVxcXFwgb24gbWFjT1MpOiBbYGluZGVudFNlbGVjdGlvbmBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuaW5kZW50U2VsZWN0aW9uKVxyXG4tIFNoaWZ0LUN0cmwtayAoU2hpZnQtQ21kLWsgb24gbWFjT1MpOiBbYGRlbGV0ZUxpbmVgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLmRlbGV0ZUxpbmUpXHJcbi0gU2hpZnQtQ3RybC1cXFxcIChTaGlmdC1DbWQtXFxcXCBvbiBtYWNPUyk6IFtgY3Vyc29yTWF0Y2hpbmdCcmFja2V0YF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5jdXJzb3JNYXRjaGluZ0JyYWNrZXQpXHJcbi0gQ3RybC0vIChDbWQtLyBvbiBtYWNPUyk6IFtgdG9nZ2xlQ29tbWVudGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMudG9nZ2xlQ29tbWVudCkuXHJcbi0gU2hpZnQtQWx0LWE6IFtgdG9nZ2xlQmxvY2tDb21tZW50YF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy50b2dnbGVCbG9ja0NvbW1lbnQpLlxyXG4qL1xyXG5jb25zdCBkZWZhdWx0S2V5bWFwID0gLypAX19QVVJFX18qL1tcclxuICAgIHsga2V5OiBcIkFsdC1BcnJvd0xlZnRcIiwgbWFjOiBcIkN0cmwtQXJyb3dMZWZ0XCIsIHJ1bjogY3Vyc29yU3ludGF4TGVmdCwgc2hpZnQ6IHNlbGVjdFN5bnRheExlZnQgfSxcclxuICAgIHsga2V5OiBcIkFsdC1BcnJvd1JpZ2h0XCIsIG1hYzogXCJDdHJsLUFycm93UmlnaHRcIiwgcnVuOiBjdXJzb3JTeW50YXhSaWdodCwgc2hpZnQ6IHNlbGVjdFN5bnRheFJpZ2h0IH0sXHJcbiAgICB7IGtleTogXCJBbHQtQXJyb3dVcFwiLCBydW46IG1vdmVMaW5lVXAgfSxcclxuICAgIHsga2V5OiBcIlNoaWZ0LUFsdC1BcnJvd1VwXCIsIHJ1bjogY29weUxpbmVVcCB9LFxyXG4gICAgeyBrZXk6IFwiQWx0LUFycm93RG93blwiLCBydW46IG1vdmVMaW5lRG93biB9LFxyXG4gICAgeyBrZXk6IFwiU2hpZnQtQWx0LUFycm93RG93blwiLCBydW46IGNvcHlMaW5lRG93biB9LFxyXG4gICAgeyBrZXk6IFwiRXNjYXBlXCIsIHJ1bjogc2ltcGxpZnlTZWxlY3Rpb24gfSxcclxuICAgIHsga2V5OiBcIk1vZC1FbnRlclwiLCBydW46IGluc2VydEJsYW5rTGluZSB9LFxyXG4gICAgeyBrZXk6IFwiQWx0LWxcIiwgbWFjOiBcIkN0cmwtbFwiLCBydW46IHNlbGVjdExpbmUgfSxcclxuICAgIHsga2V5OiBcIk1vZC1pXCIsIHJ1bjogc2VsZWN0UGFyZW50U3ludGF4LCBwcmV2ZW50RGVmYXVsdDogdHJ1ZSB9LFxyXG4gICAgeyBrZXk6IFwiTW9kLVtcIiwgcnVuOiBpbmRlbnRMZXNzIH0sXHJcbiAgICB7IGtleTogXCJNb2QtXVwiLCBydW46IGluZGVudE1vcmUgfSxcclxuICAgIHsga2V5OiBcIk1vZC1BbHQtXFxcXFwiLCBydW46IGluZGVudFNlbGVjdGlvbiB9LFxyXG4gICAgeyBrZXk6IFwiU2hpZnQtTW9kLWtcIiwgcnVuOiBkZWxldGVMaW5lIH0sXHJcbiAgICB7IGtleTogXCJTaGlmdC1Nb2QtXFxcXFwiLCBydW46IGN1cnNvck1hdGNoaW5nQnJhY2tldCB9LFxyXG4gICAgeyBrZXk6IFwiTW9kLS9cIiwgcnVuOiB0b2dnbGVDb21tZW50IH0sXHJcbiAgICB7IGtleTogXCJBbHQtQVwiLCBydW46IHRvZ2dsZUJsb2NrQ29tbWVudCB9XHJcbl0uY29uY2F0KHN0YW5kYXJkS2V5bWFwKTtcclxuLyoqXHJcbkEgYmluZGluZyB0aGF0IGJpbmRzIFRhYiB0byBbYGluZGVudE1vcmVgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLmluZGVudE1vcmUpIGFuZFxyXG5TaGlmdC1UYWIgdG8gW2BpbmRlbnRMZXNzYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5pbmRlbnRMZXNzKS5cclxuUGxlYXNlIHNlZSB0aGUgW1RhYiBleGFtcGxlXSguLi8uLi9leGFtcGxlcy90YWIvKSBiZWZvcmUgdXNpbmdcclxudGhpcy5cclxuKi9cclxuY29uc3QgaW5kZW50V2l0aFRhYiA9IHsga2V5OiBcIlRhYlwiLCBydW46IGluZGVudE1vcmUsIHNoaWZ0OiBpbmRlbnRMZXNzIH07XHJcblxyXG5leHBvcnQgeyBibG9ja0NvbW1lbnQsIGJsb2NrVW5jb21tZW50LCBjb3B5TGluZURvd24sIGNvcHlMaW5lVXAsIGN1cnNvckNoYXJCYWNrd2FyZCwgY3Vyc29yQ2hhckZvcndhcmQsIGN1cnNvckNoYXJMZWZ0LCBjdXJzb3JDaGFyUmlnaHQsIGN1cnNvckRvY0VuZCwgY3Vyc29yRG9jU3RhcnQsIGN1cnNvckdyb3VwQmFja3dhcmQsIGN1cnNvckdyb3VwRm9yd2FyZCwgY3Vyc29yR3JvdXBMZWZ0LCBjdXJzb3JHcm91cFJpZ2h0LCBjdXJzb3JMaW5lQm91bmRhcnlCYWNrd2FyZCwgY3Vyc29yTGluZUJvdW5kYXJ5Rm9yd2FyZCwgY3Vyc29yTGluZUJvdW5kYXJ5TGVmdCwgY3Vyc29yTGluZUJvdW5kYXJ5UmlnaHQsIGN1cnNvckxpbmVEb3duLCBjdXJzb3JMaW5lRW5kLCBjdXJzb3JMaW5lU3RhcnQsIGN1cnNvckxpbmVVcCwgY3Vyc29yTWF0Y2hpbmdCcmFja2V0LCBjdXJzb3JQYWdlRG93biwgY3Vyc29yUGFnZVVwLCBjdXJzb3JTdWJ3b3JkQmFja3dhcmQsIGN1cnNvclN1YndvcmRGb3J3YXJkLCBjdXJzb3JTeW50YXhMZWZ0LCBjdXJzb3JTeW50YXhSaWdodCwgZGVmYXVsdEtleW1hcCwgZGVsZXRlQ2hhckJhY2t3YXJkLCBkZWxldGVDaGFyRm9yd2FyZCwgZGVsZXRlR3JvdXBCYWNrd2FyZCwgZGVsZXRlR3JvdXBGb3J3YXJkLCBkZWxldGVMaW5lLCBkZWxldGVUb0xpbmVFbmQsIGRlbGV0ZVRvTGluZVN0YXJ0LCBkZWxldGVUcmFpbGluZ1doaXRlc3BhY2UsIGVtYWNzU3R5bGVLZXltYXAsIGhpc3RvcnksIGhpc3RvcnlGaWVsZCwgaGlzdG9yeUtleW1hcCwgaW5kZW50TGVzcywgaW5kZW50TW9yZSwgaW5kZW50U2VsZWN0aW9uLCBpbmRlbnRXaXRoVGFiLCBpbnNlcnRCbGFua0xpbmUsIGluc2VydE5ld2xpbmUsIGluc2VydE5ld2xpbmVBbmRJbmRlbnQsIGluc2VydFRhYiwgaW52ZXJ0ZWRFZmZlY3RzLCBpc29sYXRlSGlzdG9yeSwgbGluZUNvbW1lbnQsIGxpbmVVbmNvbW1lbnQsIG1vdmVMaW5lRG93biwgbW92ZUxpbmVVcCwgcmVkbywgcmVkb0RlcHRoLCByZWRvU2VsZWN0aW9uLCBzZWxlY3RBbGwsIHNlbGVjdENoYXJCYWNrd2FyZCwgc2VsZWN0Q2hhckZvcndhcmQsIHNlbGVjdENoYXJMZWZ0LCBzZWxlY3RDaGFyUmlnaHQsIHNlbGVjdERvY0VuZCwgc2VsZWN0RG9jU3RhcnQsIHNlbGVjdEdyb3VwQmFja3dhcmQsIHNlbGVjdEdyb3VwRm9yd2FyZCwgc2VsZWN0R3JvdXBMZWZ0LCBzZWxlY3RHcm91cFJpZ2h0LCBzZWxlY3RMaW5lLCBzZWxlY3RMaW5lQm91bmRhcnlCYWNrd2FyZCwgc2VsZWN0TGluZUJvdW5kYXJ5Rm9yd2FyZCwgc2VsZWN0TGluZUJvdW5kYXJ5TGVmdCwgc2VsZWN0TGluZUJvdW5kYXJ5UmlnaHQsIHNlbGVjdExpbmVEb3duLCBzZWxlY3RMaW5lRW5kLCBzZWxlY3RMaW5lU3RhcnQsIHNlbGVjdExpbmVVcCwgc2VsZWN0TWF0Y2hpbmdCcmFja2V0LCBzZWxlY3RQYWdlRG93biwgc2VsZWN0UGFnZVVwLCBzZWxlY3RQYXJlbnRTeW50YXgsIHNlbGVjdFN1YndvcmRCYWNrd2FyZCwgc2VsZWN0U3Vid29yZEZvcndhcmQsIHNlbGVjdFN5bnRheExlZnQsIHNlbGVjdFN5bnRheFJpZ2h0LCBzaW1wbGlmeVNlbGVjdGlvbiwgc3BsaXRMaW5lLCBzdGFuZGFyZEtleW1hcCwgdG9nZ2xlQmxvY2tDb21tZW50LCB0b2dnbGVCbG9ja0NvbW1lbnRCeUxpbmUsIHRvZ2dsZUNvbW1lbnQsIHRvZ2dsZUxpbmVDb21tZW50LCB0cmFuc3Bvc2VDaGFycywgdW5kbywgdW5kb0RlcHRoLCB1bmRvU2VsZWN0aW9uIH07XHJcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@codemirror/commands/dist/index.js\n"));

/***/ }),

/***/ "./node_modules/@codemirror/language/dist/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/@codemirror/language/dist/index.js ***!
  \*********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"HighlightStyle\": function() { return /* binding */ HighlightStyle; },\n/* harmony export */   \"IndentContext\": function() { return /* binding */ IndentContext; },\n/* harmony export */   \"LRLanguage\": function() { return /* binding */ LRLanguage; },\n/* harmony export */   \"Language\": function() { return /* binding */ Language; },\n/* harmony export */   \"LanguageDescription\": function() { return /* binding */ LanguageDescription; },\n/* harmony export */   \"LanguageSupport\": function() { return /* binding */ LanguageSupport; },\n/* harmony export */   \"ParseContext\": function() { return /* binding */ ParseContext; },\n/* harmony export */   \"StreamLanguage\": function() { return /* binding */ StreamLanguage; },\n/* harmony export */   \"StringStream\": function() { return /* binding */ StringStream; },\n/* harmony export */   \"TreeIndentContext\": function() { return /* binding */ TreeIndentContext; },\n/* harmony export */   \"bracketMatching\": function() { return /* binding */ bracketMatching; },\n/* harmony export */   \"codeFolding\": function() { return /* binding */ codeFolding; },\n/* harmony export */   \"continuedIndent\": function() { return /* binding */ continuedIndent; },\n/* harmony export */   \"defaultHighlightStyle\": function() { return /* binding */ defaultHighlightStyle; },\n/* harmony export */   \"defineLanguageFacet\": function() { return /* binding */ defineLanguageFacet; },\n/* harmony export */   \"delimitedIndent\": function() { return /* binding */ delimitedIndent; },\n/* harmony export */   \"ensureSyntaxTree\": function() { return /* binding */ ensureSyntaxTree; },\n/* harmony export */   \"flatIndent\": function() { return /* binding */ flatIndent; },\n/* harmony export */   \"foldAll\": function() { return /* binding */ foldAll; },\n/* harmony export */   \"foldCode\": function() { return /* binding */ foldCode; },\n/* harmony export */   \"foldEffect\": function() { return /* binding */ foldEffect; },\n/* harmony export */   \"foldGutter\": function() { return /* binding */ foldGutter; },\n/* harmony export */   \"foldInside\": function() { return /* binding */ foldInside; },\n/* harmony export */   \"foldKeymap\": function() { return /* binding */ foldKeymap; },\n/* harmony export */   \"foldNodeProp\": function() { return /* binding */ foldNodeProp; },\n/* harmony export */   \"foldService\": function() { return /* binding */ foldService; },\n/* harmony export */   \"foldState\": function() { return /* binding */ foldState; },\n/* harmony export */   \"foldable\": function() { return /* binding */ foldable; },\n/* harmony export */   \"foldedRanges\": function() { return /* binding */ foldedRanges; },\n/* harmony export */   \"forceParsing\": function() { return /* binding */ forceParsing; },\n/* harmony export */   \"getIndentUnit\": function() { return /* binding */ getIndentUnit; },\n/* harmony export */   \"getIndentation\": function() { return /* binding */ getIndentation; },\n/* harmony export */   \"highlightingFor\": function() { return /* binding */ highlightingFor; },\n/* harmony export */   \"indentNodeProp\": function() { return /* binding */ indentNodeProp; },\n/* harmony export */   \"indentOnInput\": function() { return /* binding */ indentOnInput; },\n/* harmony export */   \"indentRange\": function() { return /* binding */ indentRange; },\n/* harmony export */   \"indentService\": function() { return /* binding */ indentService; },\n/* harmony export */   \"indentString\": function() { return /* binding */ indentString; },\n/* harmony export */   \"indentUnit\": function() { return /* binding */ indentUnit; },\n/* harmony export */   \"language\": function() { return /* binding */ language; },\n/* harmony export */   \"languageDataProp\": function() { return /* binding */ languageDataProp; },\n/* harmony export */   \"matchBrackets\": function() { return /* binding */ matchBrackets; },\n/* harmony export */   \"syntaxHighlighting\": function() { return /* binding */ syntaxHighlighting; },\n/* harmony export */   \"syntaxParserRunning\": function() { return /* binding */ syntaxParserRunning; },\n/* harmony export */   \"syntaxTree\": function() { return /* binding */ syntaxTree; },\n/* harmony export */   \"syntaxTreeAvailable\": function() { return /* binding */ syntaxTreeAvailable; },\n/* harmony export */   \"unfoldAll\": function() { return /* binding */ unfoldAll; },\n/* harmony export */   \"unfoldCode\": function() { return /* binding */ unfoldCode; },\n/* harmony export */   \"unfoldEffect\": function() { return /* binding */ unfoldEffect; }\n/* harmony export */ });\n/* harmony import */ var _lezer_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lezer/common */ \"./node_modules/@lezer/common/dist/index.js\");\n/* harmony import */ var _codemirror_state__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @codemirror/state */ \"./node_modules/@codemirror/state/dist/index.js\");\n/* harmony import */ var _codemirror_view__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @codemirror/view */ \"./node_modules/@codemirror/view/dist/index.js\");\n/* harmony import */ var _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lezer/highlight */ \"./node_modules/@lezer/highlight/dist/index.js\");\n/* harmony import */ var style_mod__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! style-mod */ \"./node_modules/style-mod/src/style-mod.js\");\n\r\n\r\n\r\n\r\n\r\n\r\nvar _a;\r\n/**\r\nNode prop stored in a parser's top syntax node to provide the\r\nfacet that stores language-specific data for that language.\r\n*/\r\nconst languageDataProp = /*@__PURE__*/new _lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeProp();\r\n/**\r\nHelper function to define a facet (to be added to the top syntax\r\nnode(s) for a language via\r\n[`languageDataProp`](https://codemirror.net/6/docs/ref/#language.languageDataProp)), that will be\r\nused to associate language data with the language. You\r\nprobably only need this when subclassing\r\n[`Language`](https://codemirror.net/6/docs/ref/#language.Language).\r\n*/\r\nfunction defineLanguageFacet(baseData) {\r\n    return _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Facet.define({\r\n        combine: baseData ? values => values.concat(baseData) : undefined\r\n    });\r\n}\r\n/**\r\nA language object manages parsing and per-language\r\n[metadata](https://codemirror.net/6/docs/ref/#state.EditorState.languageDataAt). Parse data is\r\nmanaged as a [Lezer](https://lezer.codemirror.net) tree. The class\r\ncan be used directly, via the [`LRLanguage`](https://codemirror.net/6/docs/ref/#language.LRLanguage)\r\nsubclass for [Lezer](https://lezer.codemirror.net/) LR parsers, or\r\nvia the [`StreamLanguage`](https://codemirror.net/6/docs/ref/#language.StreamLanguage) subclass\r\nfor stream parsers.\r\n*/\r\nclass Language {\r\n    /**\r\n    Construct a language object. If you need to invoke this\r\n    directly, first define a data facet with\r\n    [`defineLanguageFacet`](https://codemirror.net/6/docs/ref/#language.defineLanguageFacet), and then\r\n    configure your parser to [attach](https://codemirror.net/6/docs/ref/#language.languageDataProp) it\r\n    to the language's outer syntax node.\r\n    */\r\n    constructor(\r\n    /**\r\n    The [language data](https://codemirror.net/6/docs/ref/#state.EditorState.languageDataAt) facet\r\n    used for this language.\r\n    */\r\n    data, parser, extraExtensions = [], \r\n    /**\r\n    A language name.\r\n    */\r\n    name = \"\") {\r\n        this.data = data;\r\n        this.name = name;\r\n        // Kludge to define EditorState.tree as a debugging helper,\r\n        // without the EditorState package actually knowing about\r\n        // languages and lezer trees.\r\n        if (!_codemirror_state__WEBPACK_IMPORTED_MODULE_3__.EditorState.prototype.hasOwnProperty(\"tree\"))\r\n            Object.defineProperty(_codemirror_state__WEBPACK_IMPORTED_MODULE_3__.EditorState.prototype, \"tree\", { get() { return syntaxTree(this); } });\r\n        this.parser = parser;\r\n        this.extension = [\r\n            language.of(this),\r\n            _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.EditorState.languageData.of((state, pos, side) => state.facet(languageDataFacetAt(state, pos, side)))\r\n        ].concat(extraExtensions);\r\n    }\r\n    /**\r\n    Query whether this language is active at the given position.\r\n    */\r\n    isActiveAt(state, pos, side = -1) {\r\n        return languageDataFacetAt(state, pos, side) == this.data;\r\n    }\r\n    /**\r\n    Find the document regions that were parsed using this language.\r\n    The returned regions will _include_ any nested languages rooted\r\n    in this language, when those exist.\r\n    */\r\n    findRegions(state) {\r\n        let lang = state.facet(language);\r\n        if ((lang === null || lang === void 0 ? void 0 : lang.data) == this.data)\r\n            return [{ from: 0, to: state.doc.length }];\r\n        if (!lang || !lang.allowsNesting)\r\n            return [];\r\n        let result = [];\r\n        let explore = (tree, from) => {\r\n            if (tree.prop(languageDataProp) == this.data) {\r\n                result.push({ from, to: from + tree.length });\r\n                return;\r\n            }\r\n            let mount = tree.prop(_lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeProp.mounted);\r\n            if (mount) {\r\n                if (mount.tree.prop(languageDataProp) == this.data) {\r\n                    if (mount.overlay)\r\n                        for (let r of mount.overlay)\r\n                            result.push({ from: r.from + from, to: r.to + from });\r\n                    else\r\n                        result.push({ from: from, to: from + tree.length });\r\n                    return;\r\n                }\r\n                else if (mount.overlay) {\r\n                    let size = result.length;\r\n                    explore(mount.tree, mount.overlay[0].from + from);\r\n                    if (result.length > size)\r\n                        return;\r\n                }\r\n            }\r\n            for (let i = 0; i < tree.children.length; i++) {\r\n                let ch = tree.children[i];\r\n                if (ch instanceof _lezer_common__WEBPACK_IMPORTED_MODULE_0__.Tree)\r\n                    explore(ch, tree.positions[i] + from);\r\n            }\r\n        };\r\n        explore(syntaxTree(state), 0);\r\n        return result;\r\n    }\r\n    /**\r\n    Indicates whether this language allows nested languages. The\r\n    default implementation returns true.\r\n    */\r\n    get allowsNesting() { return true; }\r\n}\r\n/**\r\n@internal\r\n*/\r\nLanguage.setState = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_3__.StateEffect.define();\r\nfunction languageDataFacetAt(state, pos, side) {\r\n    let topLang = state.facet(language);\r\n    if (!topLang)\r\n        return null;\r\n    let facet = topLang.data;\r\n    if (topLang.allowsNesting) {\r\n        for (let node = syntaxTree(state).topNode; node; node = node.enter(pos, side, _lezer_common__WEBPACK_IMPORTED_MODULE_0__.IterMode.ExcludeBuffers))\r\n            facet = node.type.prop(languageDataProp) || facet;\r\n    }\r\n    return facet;\r\n}\r\n/**\r\nA subclass of [`Language`](https://codemirror.net/6/docs/ref/#language.Language) for use with Lezer\r\n[LR parsers](https://lezer.codemirror.net/docs/ref#lr.LRParser)\r\nparsers.\r\n*/\r\nclass LRLanguage extends Language {\r\n    constructor(data, parser, name) {\r\n        super(data, parser, [], name);\r\n        this.parser = parser;\r\n    }\r\n    /**\r\n    Define a language from a parser.\r\n    */\r\n    static define(spec) {\r\n        let data = defineLanguageFacet(spec.languageData);\r\n        return new LRLanguage(data, spec.parser.configure({\r\n            props: [languageDataProp.add(type => type.isTop ? data : undefined)]\r\n        }), spec.name);\r\n    }\r\n    /**\r\n    Create a new instance of this language with a reconfigured\r\n    version of its parser and optionally a new name.\r\n    */\r\n    configure(options, name) {\r\n        return new LRLanguage(this.data, this.parser.configure(options), name || this.name);\r\n    }\r\n    get allowsNesting() { return this.parser.hasWrappers(); }\r\n}\r\n/**\r\nGet the syntax tree for a state, which is the current (possibly\r\nincomplete) parse tree of the active\r\n[language](https://codemirror.net/6/docs/ref/#language.Language), or the empty tree if there is no\r\nlanguage available.\r\n*/\r\nfunction syntaxTree(state) {\r\n    let field = state.field(Language.state, false);\r\n    return field ? field.tree : _lezer_common__WEBPACK_IMPORTED_MODULE_0__.Tree.empty;\r\n}\r\n/**\r\nTry to get a parse tree that spans at least up to `upto`. The\r\nmethod will do at most `timeout` milliseconds of work to parse\r\nup to that point if the tree isn't already available.\r\n*/\r\nfunction ensureSyntaxTree(state, upto, timeout = 50) {\r\n    var _a;\r\n    let parse = (_a = state.field(Language.state, false)) === null || _a === void 0 ? void 0 : _a.context;\r\n    if (!parse)\r\n        return null;\r\n    let oldVieport = parse.viewport;\r\n    parse.updateViewport({ from: 0, to: upto });\r\n    let result = parse.isDone(upto) || parse.work(timeout, upto) ? parse.tree : null;\r\n    parse.updateViewport(oldVieport);\r\n    return result;\r\n}\r\n/**\r\nQueries whether there is a full syntax tree available up to the\r\ngiven document position. If there isn't, the background parse\r\nprocess _might_ still be working and update the tree further, but\r\nthere is no guarantee of that—the parser will [stop\r\nworking](https://codemirror.net/6/docs/ref/#language.syntaxParserRunning) when it has spent a\r\ncertain amount of time or has moved beyond the visible viewport.\r\nAlways returns false if no language has been enabled.\r\n*/\r\nfunction syntaxTreeAvailable(state, upto = state.doc.length) {\r\n    var _a;\r\n    return ((_a = state.field(Language.state, false)) === null || _a === void 0 ? void 0 : _a.context.isDone(upto)) || false;\r\n}\r\n/**\r\nMove parsing forward, and update the editor state afterwards to\r\nreflect the new tree. Will work for at most `timeout`\r\nmilliseconds. Returns true if the parser managed get to the given\r\nposition in that time.\r\n*/\r\nfunction forceParsing(view, upto = view.viewport.to, timeout = 100) {\r\n    let success = ensureSyntaxTree(view.state, upto, timeout);\r\n    if (success != syntaxTree(view.state))\r\n        view.dispatch({});\r\n    return !!success;\r\n}\r\n/**\r\nTells you whether the language parser is planning to do more\r\nparsing work (in a `requestIdleCallback` pseudo-thread) or has\r\nstopped running, either because it parsed the entire document,\r\nbecause it spent too much time and was cut off, or because there\r\nis no language parser enabled.\r\n*/\r\nfunction syntaxParserRunning(view) {\r\n    var _a;\r\n    return ((_a = view.plugin(parseWorker)) === null || _a === void 0 ? void 0 : _a.isWorking()) || false;\r\n}\r\n// Lezer-style Input object for a Text document.\r\nclass DocInput {\r\n    constructor(doc, length = doc.length) {\r\n        this.doc = doc;\r\n        this.length = length;\r\n        this.cursorPos = 0;\r\n        this.string = \"\";\r\n        this.cursor = doc.iter();\r\n    }\r\n    syncTo(pos) {\r\n        this.string = this.cursor.next(pos - this.cursorPos).value;\r\n        this.cursorPos = pos + this.string.length;\r\n        return this.cursorPos - this.string.length;\r\n    }\r\n    chunk(pos) {\r\n        this.syncTo(pos);\r\n        return this.string;\r\n    }\r\n    get lineChunks() { return true; }\r\n    read(from, to) {\r\n        let stringStart = this.cursorPos - this.string.length;\r\n        if (from < stringStart || to >= this.cursorPos)\r\n            return this.doc.sliceString(from, to);\r\n        else\r\n            return this.string.slice(from - stringStart, to - stringStart);\r\n    }\r\n}\r\nlet currentContext = null;\r\n/**\r\nA parse context provided to parsers working on the editor content.\r\n*/\r\nclass ParseContext {\r\n    constructor(parser, \r\n    /**\r\n    The current editor state.\r\n    */\r\n    state, \r\n    /**\r\n    Tree fragments that can be reused by incremental re-parses.\r\n    */\r\n    fragments = [], \r\n    /**\r\n    @internal\r\n    */\r\n    tree, \r\n    /**\r\n    @internal\r\n    */\r\n    treeLen, \r\n    /**\r\n    The current editor viewport (or some overapproximation\r\n    thereof). Intended to be used for opportunistically avoiding\r\n    work (in which case\r\n    [`skipUntilInView`](https://codemirror.net/6/docs/ref/#language.ParseContext.skipUntilInView)\r\n    should be called to make sure the parser is restarted when the\r\n    skipped region becomes visible).\r\n    */\r\n    viewport, \r\n    /**\r\n    @internal\r\n    */\r\n    skipped, \r\n    /**\r\n    This is where skipping parsers can register a promise that,\r\n    when resolved, will schedule a new parse. It is cleared when\r\n    the parse worker picks up the promise. @internal\r\n    */\r\n    scheduleOn) {\r\n        this.parser = parser;\r\n        this.state = state;\r\n        this.fragments = fragments;\r\n        this.tree = tree;\r\n        this.treeLen = treeLen;\r\n        this.viewport = viewport;\r\n        this.skipped = skipped;\r\n        this.scheduleOn = scheduleOn;\r\n        this.parse = null;\r\n        /**\r\n        @internal\r\n        */\r\n        this.tempSkipped = [];\r\n    }\r\n    /**\r\n    @internal\r\n    */\r\n    static create(parser, state, viewport) {\r\n        return new ParseContext(parser, state, [], _lezer_common__WEBPACK_IMPORTED_MODULE_0__.Tree.empty, 0, viewport, [], null);\r\n    }\r\n    startParse() {\r\n        return this.parser.startParse(new DocInput(this.state.doc), this.fragments);\r\n    }\r\n    /**\r\n    @internal\r\n    */\r\n    work(until, upto) {\r\n        if (upto != null && upto >= this.state.doc.length)\r\n            upto = undefined;\r\n        if (this.tree != _lezer_common__WEBPACK_IMPORTED_MODULE_0__.Tree.empty && this.isDone(upto !== null && upto !== void 0 ? upto : this.state.doc.length)) {\r\n            this.takeTree();\r\n            return true;\r\n        }\r\n        return this.withContext(() => {\r\n            var _a;\r\n            if (typeof until == \"number\") {\r\n                let endTime = Date.now() + until;\r\n                until = () => Date.now() > endTime;\r\n            }\r\n            if (!this.parse)\r\n                this.parse = this.startParse();\r\n            if (upto != null && (this.parse.stoppedAt == null || this.parse.stoppedAt > upto) &&\r\n                upto < this.state.doc.length)\r\n                this.parse.stopAt(upto);\r\n            for (;;) {\r\n                let done = this.parse.advance();\r\n                if (done) {\r\n                    this.fragments = this.withoutTempSkipped(_lezer_common__WEBPACK_IMPORTED_MODULE_0__.TreeFragment.addTree(done, this.fragments, this.parse.stoppedAt != null));\r\n                    this.treeLen = (_a = this.parse.stoppedAt) !== null && _a !== void 0 ? _a : this.state.doc.length;\r\n                    this.tree = done;\r\n                    this.parse = null;\r\n                    if (this.treeLen < (upto !== null && upto !== void 0 ? upto : this.state.doc.length))\r\n                        this.parse = this.startParse();\r\n                    else\r\n                        return true;\r\n                }\r\n                if (until())\r\n                    return false;\r\n            }\r\n        });\r\n    }\r\n    /**\r\n    @internal\r\n    */\r\n    takeTree() {\r\n        let pos, tree;\r\n        if (this.parse && (pos = this.parse.parsedPos) >= this.treeLen) {\r\n            if (this.parse.stoppedAt == null || this.parse.stoppedAt > pos)\r\n                this.parse.stopAt(pos);\r\n            this.withContext(() => { while (!(tree = this.parse.advance())) { } });\r\n            this.treeLen = pos;\r\n            this.tree = tree;\r\n            this.fragments = this.withoutTempSkipped(_lezer_common__WEBPACK_IMPORTED_MODULE_0__.TreeFragment.addTree(this.tree, this.fragments, true));\r\n            this.parse = null;\r\n        }\r\n    }\r\n    withContext(f) {\r\n        let prev = currentContext;\r\n        currentContext = this;\r\n        try {\r\n            return f();\r\n        }\r\n        finally {\r\n            currentContext = prev;\r\n        }\r\n    }\r\n    withoutTempSkipped(fragments) {\r\n        for (let r; r = this.tempSkipped.pop();)\r\n            fragments = cutFragments(fragments, r.from, r.to);\r\n        return fragments;\r\n    }\r\n    /**\r\n    @internal\r\n    */\r\n    changes(changes, newState) {\r\n        let { fragments, tree, treeLen, viewport, skipped } = this;\r\n        this.takeTree();\r\n        if (!changes.empty) {\r\n            let ranges = [];\r\n            changes.iterChangedRanges((fromA, toA, fromB, toB) => ranges.push({ fromA, toA, fromB, toB }));\r\n            fragments = _lezer_common__WEBPACK_IMPORTED_MODULE_0__.TreeFragment.applyChanges(fragments, ranges);\r\n            tree = _lezer_common__WEBPACK_IMPORTED_MODULE_0__.Tree.empty;\r\n            treeLen = 0;\r\n            viewport = { from: changes.mapPos(viewport.from, -1), to: changes.mapPos(viewport.to, 1) };\r\n            if (this.skipped.length) {\r\n                skipped = [];\r\n                for (let r of this.skipped) {\r\n                    let from = changes.mapPos(r.from, 1), to = changes.mapPos(r.to, -1);\r\n                    if (from < to)\r\n                        skipped.push({ from, to });\r\n                }\r\n            }\r\n        }\r\n        return new ParseContext(this.parser, newState, fragments, tree, treeLen, viewport, skipped, this.scheduleOn);\r\n    }\r\n    /**\r\n    @internal\r\n    */\r\n    updateViewport(viewport) {\r\n        if (this.viewport.from == viewport.from && this.viewport.to == viewport.to)\r\n            return false;\r\n        this.viewport = viewport;\r\n        let startLen = this.skipped.length;\r\n        for (let i = 0; i < this.skipped.length; i++) {\r\n            let { from, to } = this.skipped[i];\r\n            if (from < viewport.to && to > viewport.from) {\r\n                this.fragments = cutFragments(this.fragments, from, to);\r\n                this.skipped.splice(i--, 1);\r\n            }\r\n        }\r\n        if (this.skipped.length >= startLen)\r\n            return false;\r\n        this.reset();\r\n        return true;\r\n    }\r\n    /**\r\n    @internal\r\n    */\r\n    reset() {\r\n        if (this.parse) {\r\n            this.takeTree();\r\n            this.parse = null;\r\n        }\r\n    }\r\n    /**\r\n    Notify the parse scheduler that the given region was skipped\r\n    because it wasn't in view, and the parse should be restarted\r\n    when it comes into view.\r\n    */\r\n    skipUntilInView(from, to) {\r\n        this.skipped.push({ from, to });\r\n    }\r\n    /**\r\n    Returns a parser intended to be used as placeholder when\r\n    asynchronously loading a nested parser. It'll skip its input and\r\n    mark it as not-really-parsed, so that the next update will parse\r\n    it again.\r\n    \r\n    When `until` is given, a reparse will be scheduled when that\r\n    promise resolves.\r\n    */\r\n    static getSkippingParser(until) {\r\n        return new class extends _lezer_common__WEBPACK_IMPORTED_MODULE_0__.Parser {\r\n            createParse(input, fragments, ranges) {\r\n                let from = ranges[0].from, to = ranges[ranges.length - 1].to;\r\n                let parser = {\r\n                    parsedPos: from,\r\n                    advance() {\r\n                        let cx = currentContext;\r\n                        if (cx) {\r\n                            for (let r of ranges)\r\n                                cx.tempSkipped.push(r);\r\n                            if (until)\r\n                                cx.scheduleOn = cx.scheduleOn ? Promise.all([cx.scheduleOn, until]) : until;\r\n                        }\r\n                        this.parsedPos = to;\r\n                        return new _lezer_common__WEBPACK_IMPORTED_MODULE_0__.Tree(_lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeType.none, [], [], to - from);\r\n                    },\r\n                    stoppedAt: null,\r\n                    stopAt() { }\r\n                };\r\n                return parser;\r\n            }\r\n        };\r\n    }\r\n    /**\r\n    @internal\r\n    */\r\n    isDone(upto) {\r\n        upto = Math.min(upto, this.state.doc.length);\r\n        let frags = this.fragments;\r\n        return this.treeLen >= upto && frags.length && frags[0].from == 0 && frags[0].to >= upto;\r\n    }\r\n    /**\r\n    Get the context for the current parse, or `null` if no editor\r\n    parse is in progress.\r\n    */\r\n    static get() { return currentContext; }\r\n}\r\nfunction cutFragments(fragments, from, to) {\r\n    return _lezer_common__WEBPACK_IMPORTED_MODULE_0__.TreeFragment.applyChanges(fragments, [{ fromA: from, toA: to, fromB: from, toB: to }]);\r\n}\r\nclass LanguageState {\r\n    constructor(\r\n    // A mutable parse state that is used to preserve work done during\r\n    // the lifetime of a state when moving to the next state.\r\n    context) {\r\n        this.context = context;\r\n        this.tree = context.tree;\r\n    }\r\n    apply(tr) {\r\n        if (!tr.docChanged && this.tree == this.context.tree)\r\n            return this;\r\n        let newCx = this.context.changes(tr.changes, tr.state);\r\n        // If the previous parse wasn't done, go forward only up to its\r\n        // end position or the end of the viewport, to avoid slowing down\r\n        // state updates with parse work beyond the viewport.\r\n        let upto = this.context.treeLen == tr.startState.doc.length ? undefined\r\n            : Math.max(tr.changes.mapPos(this.context.treeLen), newCx.viewport.to);\r\n        if (!newCx.work(20 /* Work.Apply */, upto))\r\n            newCx.takeTree();\r\n        return new LanguageState(newCx);\r\n    }\r\n    static init(state) {\r\n        let vpTo = Math.min(3000 /* Work.InitViewport */, state.doc.length);\r\n        let parseState = ParseContext.create(state.facet(language).parser, state, { from: 0, to: vpTo });\r\n        if (!parseState.work(20 /* Work.Apply */, vpTo))\r\n            parseState.takeTree();\r\n        return new LanguageState(parseState);\r\n    }\r\n}\r\nLanguage.state = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_3__.StateField.define({\r\n    create: LanguageState.init,\r\n    update(value, tr) {\r\n        for (let e of tr.effects)\r\n            if (e.is(Language.setState))\r\n                return e.value;\r\n        if (tr.startState.facet(language) != tr.state.facet(language))\r\n            return LanguageState.init(tr.state);\r\n        return value.apply(tr);\r\n    }\r\n});\r\nlet requestIdle = (callback) => {\r\n    let timeout = setTimeout(() => callback(), 500 /* Work.MaxPause */);\r\n    return () => clearTimeout(timeout);\r\n};\r\nif (typeof requestIdleCallback != \"undefined\")\r\n    requestIdle = (callback) => {\r\n        let idle = -1, timeout = setTimeout(() => {\r\n            idle = requestIdleCallback(callback, { timeout: 500 /* Work.MaxPause */ - 100 /* Work.MinPause */ });\r\n        }, 100 /* Work.MinPause */);\r\n        return () => idle < 0 ? clearTimeout(timeout) : cancelIdleCallback(idle);\r\n    };\r\nconst isInputPending = typeof navigator != \"undefined\" && ((_a = navigator.scheduling) === null || _a === void 0 ? void 0 : _a.isInputPending)\r\n    ? () => navigator.scheduling.isInputPending() : null;\r\nconst parseWorker = /*@__PURE__*/_codemirror_view__WEBPACK_IMPORTED_MODULE_4__.ViewPlugin.fromClass(class ParseWorker {\r\n    constructor(view) {\r\n        this.view = view;\r\n        this.working = null;\r\n        this.workScheduled = 0;\r\n        // End of the current time chunk\r\n        this.chunkEnd = -1;\r\n        // Milliseconds of budget left for this chunk\r\n        this.chunkBudget = -1;\r\n        this.work = this.work.bind(this);\r\n        this.scheduleWork();\r\n    }\r\n    update(update) {\r\n        let cx = this.view.state.field(Language.state).context;\r\n        if (cx.updateViewport(update.view.viewport) || this.view.viewport.to > cx.treeLen)\r\n            this.scheduleWork();\r\n        if (update.docChanged) {\r\n            if (this.view.hasFocus)\r\n                this.chunkBudget += 50 /* Work.ChangeBonus */;\r\n            this.scheduleWork();\r\n        }\r\n        this.checkAsyncSchedule(cx);\r\n    }\r\n    scheduleWork() {\r\n        if (this.working)\r\n            return;\r\n        let { state } = this.view, field = state.field(Language.state);\r\n        if (field.tree != field.context.tree || !field.context.isDone(state.doc.length))\r\n            this.working = requestIdle(this.work);\r\n    }\r\n    work(deadline) {\r\n        this.working = null;\r\n        let now = Date.now();\r\n        if (this.chunkEnd < now && (this.chunkEnd < 0 || this.view.hasFocus)) { // Start a new chunk\r\n            this.chunkEnd = now + 30000 /* Work.ChunkTime */;\r\n            this.chunkBudget = 3000 /* Work.ChunkBudget */;\r\n        }\r\n        if (this.chunkBudget <= 0)\r\n            return; // No more budget\r\n        let { state, viewport: { to: vpTo } } = this.view, field = state.field(Language.state);\r\n        if (field.tree == field.context.tree && field.context.isDone(vpTo + 100000 /* Work.MaxParseAhead */))\r\n            return;\r\n        let endTime = Date.now() + Math.min(this.chunkBudget, 100 /* Work.Slice */, deadline && !isInputPending ? Math.max(25 /* Work.MinSlice */, deadline.timeRemaining() - 5) : 1e9);\r\n        let viewportFirst = field.context.treeLen < vpTo && state.doc.length > vpTo + 1000;\r\n        let done = field.context.work(() => {\r\n            return isInputPending && isInputPending() || Date.now() > endTime;\r\n        }, vpTo + (viewportFirst ? 0 : 100000 /* Work.MaxParseAhead */));\r\n        this.chunkBudget -= Date.now() - now;\r\n        if (done || this.chunkBudget <= 0) {\r\n            field.context.takeTree();\r\n            this.view.dispatch({ effects: Language.setState.of(new LanguageState(field.context)) });\r\n        }\r\n        if (this.chunkBudget > 0 && !(done && !viewportFirst))\r\n            this.scheduleWork();\r\n        this.checkAsyncSchedule(field.context);\r\n    }\r\n    checkAsyncSchedule(cx) {\r\n        if (cx.scheduleOn) {\r\n            this.workScheduled++;\r\n            cx.scheduleOn\r\n                .then(() => this.scheduleWork())\r\n                .catch(err => (0,_codemirror_view__WEBPACK_IMPORTED_MODULE_4__.logException)(this.view.state, err))\r\n                .then(() => this.workScheduled--);\r\n            cx.scheduleOn = null;\r\n        }\r\n    }\r\n    destroy() {\r\n        if (this.working)\r\n            this.working();\r\n    }\r\n    isWorking() {\r\n        return !!(this.working || this.workScheduled > 0);\r\n    }\r\n}, {\r\n    eventHandlers: { focus() { this.scheduleWork(); } }\r\n});\r\n/**\r\nThe facet used to associate a language with an editor state. Used\r\nby `Language` object's `extension` property (so you don't need to\r\nmanually wrap your languages in this). Can be used to access the\r\ncurrent language on a state.\r\n*/\r\nconst language = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Facet.define({\r\n    combine(languages) { return languages.length ? languages[0] : null; },\r\n    enables: language => [\r\n        Language.state,\r\n        parseWorker,\r\n        _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.EditorView.contentAttributes.compute([language], state => {\r\n            let lang = state.facet(language);\r\n            return lang && lang.name ? { \"data-language\": lang.name } : {};\r\n        })\r\n    ]\r\n});\r\n/**\r\nThis class bundles a [language](https://codemirror.net/6/docs/ref/#language.Language) with an\r\noptional set of supporting extensions. Language packages are\r\nencouraged to export a function that optionally takes a\r\nconfiguration object and returns a `LanguageSupport` instance, as\r\nthe main way for client code to use the package.\r\n*/\r\nclass LanguageSupport {\r\n    /**\r\n    Create a language support object.\r\n    */\r\n    constructor(\r\n    /**\r\n    The language object.\r\n    */\r\n    language, \r\n    /**\r\n    An optional set of supporting extensions. When nesting a\r\n    language in another language, the outer language is encouraged\r\n    to include the supporting extensions for its inner languages\r\n    in its own set of support extensions.\r\n    */\r\n    support = []) {\r\n        this.language = language;\r\n        this.support = support;\r\n        this.extension = [language, support];\r\n    }\r\n}\r\n/**\r\nLanguage descriptions are used to store metadata about languages\r\nand to dynamically load them. Their main role is finding the\r\nappropriate language for a filename or dynamically loading nested\r\nparsers.\r\n*/\r\nclass LanguageDescription {\r\n    constructor(\r\n    /**\r\n    The name of this language.\r\n    */\r\n    name, \r\n    /**\r\n    Alternative names for the mode (lowercased, includes `this.name`).\r\n    */\r\n    alias, \r\n    /**\r\n    File extensions associated with this language.\r\n    */\r\n    extensions, \r\n    /**\r\n    Optional filename pattern that should be associated with this\r\n    language.\r\n    */\r\n    filename, loadFunc, \r\n    /**\r\n    If the language has been loaded, this will hold its value.\r\n    */\r\n    support = undefined) {\r\n        this.name = name;\r\n        this.alias = alias;\r\n        this.extensions = extensions;\r\n        this.filename = filename;\r\n        this.loadFunc = loadFunc;\r\n        this.support = support;\r\n        this.loading = null;\r\n    }\r\n    /**\r\n    Start loading the the language. Will return a promise that\r\n    resolves to a [`LanguageSupport`](https://codemirror.net/6/docs/ref/#language.LanguageSupport)\r\n    object when the language successfully loads.\r\n    */\r\n    load() {\r\n        return this.loading || (this.loading = this.loadFunc().then(support => this.support = support, err => { this.loading = null; throw err; }));\r\n    }\r\n    /**\r\n    Create a language description.\r\n    */\r\n    static of(spec) {\r\n        let { load, support } = spec;\r\n        if (!load) {\r\n            if (!support)\r\n                throw new RangeError(\"Must pass either 'load' or 'support' to LanguageDescription.of\");\r\n            load = () => Promise.resolve(support);\r\n        }\r\n        return new LanguageDescription(spec.name, (spec.alias || []).concat(spec.name).map(s => s.toLowerCase()), spec.extensions || [], spec.filename, load, support);\r\n    }\r\n    /**\r\n    Look for a language in the given array of descriptions that\r\n    matches the filename. Will first match\r\n    [`filename`](https://codemirror.net/6/docs/ref/#language.LanguageDescription.filename) patterns,\r\n    and then [extensions](https://codemirror.net/6/docs/ref/#language.LanguageDescription.extensions),\r\n    and return the first language that matches.\r\n    */\r\n    static matchFilename(descs, filename) {\r\n        for (let d of descs)\r\n            if (d.filename && d.filename.test(filename))\r\n                return d;\r\n        let ext = /\\.([^.]+)$/.exec(filename);\r\n        if (ext)\r\n            for (let d of descs)\r\n                if (d.extensions.indexOf(ext[1]) > -1)\r\n                    return d;\r\n        return null;\r\n    }\r\n    /**\r\n    Look for a language whose name or alias matches the the given\r\n    name (case-insensitively). If `fuzzy` is true, and no direct\r\n    matchs is found, this'll also search for a language whose name\r\n    or alias occurs in the string (for names shorter than three\r\n    characters, only when surrounded by non-word characters).\r\n    */\r\n    static matchLanguageName(descs, name, fuzzy = true) {\r\n        name = name.toLowerCase();\r\n        for (let d of descs)\r\n            if (d.alias.some(a => a == name))\r\n                return d;\r\n        if (fuzzy)\r\n            for (let d of descs)\r\n                for (let a of d.alias) {\r\n                    let found = name.indexOf(a);\r\n                    if (found > -1 && (a.length > 2 || !/\\w/.test(name[found - 1]) && !/\\w/.test(name[found + a.length])))\r\n                        return d;\r\n                }\r\n        return null;\r\n    }\r\n}\r\n\r\n/**\r\nFacet that defines a way to provide a function that computes the\r\nappropriate indentation depth, as a column number (see\r\n[`indentString`](https://codemirror.net/6/docs/ref/#language.indentString)), at the start of a given\r\nline. A return value of `null` indicates no indentation can be\r\ndetermined, and the line should inherit the indentation of the one\r\nabove it. A return value of `undefined` defers to the next indent\r\nservice.\r\n*/\r\nconst indentService = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Facet.define();\r\n/**\r\nFacet for overriding the unit by which indentation happens.\r\nShould be a string consisting either entirely of spaces or\r\nentirely of tabs. When not set, this defaults to 2 spaces.\r\n*/\r\nconst indentUnit = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Facet.define({\r\n    combine: values => {\r\n        if (!values.length)\r\n            return \"  \";\r\n        if (!/^(?: +|\\t+)$/.test(values[0]))\r\n            throw new Error(\"Invalid indent unit: \" + JSON.stringify(values[0]));\r\n        return values[0];\r\n    }\r\n});\r\n/**\r\nReturn the _column width_ of an indent unit in the state.\r\nDetermined by the [`indentUnit`](https://codemirror.net/6/docs/ref/#language.indentUnit)\r\nfacet, and [`tabSize`](https://codemirror.net/6/docs/ref/#state.EditorState^tabSize) when that\r\ncontains tabs.\r\n*/\r\nfunction getIndentUnit(state) {\r\n    let unit = state.facet(indentUnit);\r\n    return unit.charCodeAt(0) == 9 ? state.tabSize * unit.length : unit.length;\r\n}\r\n/**\r\nCreate an indentation string that covers columns 0 to `cols`.\r\nWill use tabs for as much of the columns as possible when the\r\n[`indentUnit`](https://codemirror.net/6/docs/ref/#language.indentUnit) facet contains\r\ntabs.\r\n*/\r\nfunction indentString(state, cols) {\r\n    let result = \"\", ts = state.tabSize;\r\n    if (state.facet(indentUnit).charCodeAt(0) == 9)\r\n        while (cols >= ts) {\r\n            result += \"\\t\";\r\n            cols -= ts;\r\n        }\r\n    for (let i = 0; i < cols; i++)\r\n        result += \" \";\r\n    return result;\r\n}\r\n/**\r\nGet the indentation, as a column number, at the given position.\r\nWill first consult any [indent services](https://codemirror.net/6/docs/ref/#language.indentService)\r\nthat are registered, and if none of those return an indentation,\r\nthis will check the syntax tree for the [indent node\r\nprop](https://codemirror.net/6/docs/ref/#language.indentNodeProp) and use that if found. Returns a\r\nnumber when an indentation could be determined, and null\r\notherwise.\r\n*/\r\nfunction getIndentation(context, pos) {\r\n    if (context instanceof _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.EditorState)\r\n        context = new IndentContext(context);\r\n    for (let service of context.state.facet(indentService)) {\r\n        let result = service(context, pos);\r\n        if (result !== undefined)\r\n            return result;\r\n    }\r\n    let tree = syntaxTree(context.state);\r\n    return tree ? syntaxIndentation(context, tree, pos) : null;\r\n}\r\n/**\r\nCreate a change set that auto-indents all lines touched by the\r\ngiven document range.\r\n*/\r\nfunction indentRange(state, from, to) {\r\n    let updated = Object.create(null);\r\n    let context = new IndentContext(state, { overrideIndentation: start => { var _a; return (_a = updated[start]) !== null && _a !== void 0 ? _a : -1; } });\r\n    let changes = [];\r\n    for (let pos = from; pos <= to;) {\r\n        let line = state.doc.lineAt(pos);\r\n        pos = line.to + 1;\r\n        let indent = getIndentation(context, line.from);\r\n        if (indent == null)\r\n            continue;\r\n        if (!/\\S/.test(line.text))\r\n            indent = 0;\r\n        let cur = /^\\s*/.exec(line.text)[0];\r\n        let norm = indentString(state, indent);\r\n        if (cur != norm) {\r\n            updated[line.from] = indent;\r\n            changes.push({ from: line.from, to: line.from + cur.length, insert: norm });\r\n        }\r\n    }\r\n    return state.changes(changes);\r\n}\r\n/**\r\nIndentation contexts are used when calling [indentation\r\nservices](https://codemirror.net/6/docs/ref/#language.indentService). They provide helper utilities\r\nuseful in indentation logic, and can selectively override the\r\nindentation reported for some lines.\r\n*/\r\nclass IndentContext {\r\n    /**\r\n    Create an indent context.\r\n    */\r\n    constructor(\r\n    /**\r\n    The editor state.\r\n    */\r\n    state, \r\n    /**\r\n    @internal\r\n    */\r\n    options = {}) {\r\n        this.state = state;\r\n        this.options = options;\r\n        this.unit = getIndentUnit(state);\r\n    }\r\n    /**\r\n    Get a description of the line at the given position, taking\r\n    [simulated line\r\n    breaks](https://codemirror.net/6/docs/ref/#language.IndentContext.constructor^options.simulateBreak)\r\n    into account. If there is such a break at `pos`, the `bias`\r\n    argument determines whether the part of the line line before or\r\n    after the break is used.\r\n    */\r\n    lineAt(pos, bias = 1) {\r\n        let line = this.state.doc.lineAt(pos);\r\n        let { simulateBreak, simulateDoubleBreak } = this.options;\r\n        if (simulateBreak != null && simulateBreak >= line.from && simulateBreak <= line.to) {\r\n            if (simulateDoubleBreak && simulateBreak == pos)\r\n                return { text: \"\", from: pos };\r\n            else if (bias < 0 ? simulateBreak < pos : simulateBreak <= pos)\r\n                return { text: line.text.slice(simulateBreak - line.from), from: simulateBreak };\r\n            else\r\n                return { text: line.text.slice(0, simulateBreak - line.from), from: line.from };\r\n        }\r\n        return line;\r\n    }\r\n    /**\r\n    Get the text directly after `pos`, either the entire line\r\n    or the next 100 characters, whichever is shorter.\r\n    */\r\n    textAfterPos(pos, bias = 1) {\r\n        if (this.options.simulateDoubleBreak && pos == this.options.simulateBreak)\r\n            return \"\";\r\n        let { text, from } = this.lineAt(pos, bias);\r\n        return text.slice(pos - from, Math.min(text.length, pos + 100 - from));\r\n    }\r\n    /**\r\n    Find the column for the given position.\r\n    */\r\n    column(pos, bias = 1) {\r\n        let { text, from } = this.lineAt(pos, bias);\r\n        let result = this.countColumn(text, pos - from);\r\n        let override = this.options.overrideIndentation ? this.options.overrideIndentation(from) : -1;\r\n        if (override > -1)\r\n            result += override - this.countColumn(text, text.search(/\\S|$/));\r\n        return result;\r\n    }\r\n    /**\r\n    Find the column position (taking tabs into account) of the given\r\n    position in the given string.\r\n    */\r\n    countColumn(line, pos = line.length) {\r\n        return (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_3__.countColumn)(line, this.state.tabSize, pos);\r\n    }\r\n    /**\r\n    Find the indentation column of the line at the given point.\r\n    */\r\n    lineIndent(pos, bias = 1) {\r\n        let { text, from } = this.lineAt(pos, bias);\r\n        let override = this.options.overrideIndentation;\r\n        if (override) {\r\n            let overriden = override(from);\r\n            if (overriden > -1)\r\n                return overriden;\r\n        }\r\n        return this.countColumn(text, text.search(/\\S|$/));\r\n    }\r\n    /**\r\n    Returns the [simulated line\r\n    break](https://codemirror.net/6/docs/ref/#language.IndentContext.constructor^options.simulateBreak)\r\n    for this context, if any.\r\n    */\r\n    get simulatedBreak() {\r\n        return this.options.simulateBreak || null;\r\n    }\r\n}\r\n/**\r\nA syntax tree node prop used to associate indentation strategies\r\nwith node types. Such a strategy is a function from an indentation\r\ncontext to a column number (see also\r\n[`indentString`](https://codemirror.net/6/docs/ref/#language.indentString)) or null, where null\r\nindicates that no definitive indentation can be determined.\r\n*/\r\nconst indentNodeProp = /*@__PURE__*/new _lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeProp();\r\n// Compute the indentation for a given position from the syntax tree.\r\nfunction syntaxIndentation(cx, ast, pos) {\r\n    return indentFrom(ast.resolveInner(pos).enterUnfinishedNodesBefore(pos), pos, cx);\r\n}\r\nfunction ignoreClosed(cx) {\r\n    return cx.pos == cx.options.simulateBreak && cx.options.simulateDoubleBreak;\r\n}\r\nfunction indentStrategy(tree) {\r\n    let strategy = tree.type.prop(indentNodeProp);\r\n    if (strategy)\r\n        return strategy;\r\n    let first = tree.firstChild, close;\r\n    if (first && (close = first.type.prop(_lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeProp.closedBy))) {\r\n        let last = tree.lastChild, closed = last && close.indexOf(last.name) > -1;\r\n        return cx => delimitedStrategy(cx, true, 1, undefined, closed && !ignoreClosed(cx) ? last.from : undefined);\r\n    }\r\n    return tree.parent == null ? topIndent : null;\r\n}\r\nfunction indentFrom(node, pos, base) {\r\n    for (; node; node = node.parent) {\r\n        let strategy = indentStrategy(node);\r\n        if (strategy)\r\n            return strategy(TreeIndentContext.create(base, pos, node));\r\n    }\r\n    return null;\r\n}\r\nfunction topIndent() { return 0; }\r\n/**\r\nObjects of this type provide context information and helper\r\nmethods to indentation functions registered on syntax nodes.\r\n*/\r\nclass TreeIndentContext extends IndentContext {\r\n    constructor(base, \r\n    /**\r\n    The position at which indentation is being computed.\r\n    */\r\n    pos, \r\n    /**\r\n    The syntax tree node to which the indentation strategy\r\n    applies.\r\n    */\r\n    node) {\r\n        super(base.state, base.options);\r\n        this.base = base;\r\n        this.pos = pos;\r\n        this.node = node;\r\n    }\r\n    /**\r\n    @internal\r\n    */\r\n    static create(base, pos, node) {\r\n        return new TreeIndentContext(base, pos, node);\r\n    }\r\n    /**\r\n    Get the text directly after `this.pos`, either the entire line\r\n    or the next 100 characters, whichever is shorter.\r\n    */\r\n    get textAfter() {\r\n        return this.textAfterPos(this.pos);\r\n    }\r\n    /**\r\n    Get the indentation at the reference line for `this.node`, which\r\n    is the line on which it starts, unless there is a node that is\r\n    _not_ a parent of this node covering the start of that line. If\r\n    so, the line at the start of that node is tried, again skipping\r\n    on if it is covered by another such node.\r\n    */\r\n    get baseIndent() {\r\n        let line = this.state.doc.lineAt(this.node.from);\r\n        // Skip line starts that are covered by a sibling (or cousin, etc)\r\n        for (;;) {\r\n            let atBreak = this.node.resolve(line.from);\r\n            while (atBreak.parent && atBreak.parent.from == atBreak.from)\r\n                atBreak = atBreak.parent;\r\n            if (isParent(atBreak, this.node))\r\n                break;\r\n            line = this.state.doc.lineAt(atBreak.from);\r\n        }\r\n        return this.lineIndent(line.from);\r\n    }\r\n    /**\r\n    Continue looking for indentations in the node's parent nodes,\r\n    and return the result of that.\r\n    */\r\n    continue() {\r\n        let parent = this.node.parent;\r\n        return parent ? indentFrom(parent, this.pos, this.base) : 0;\r\n    }\r\n}\r\nfunction isParent(parent, of) {\r\n    for (let cur = of; cur; cur = cur.parent)\r\n        if (parent == cur)\r\n            return true;\r\n    return false;\r\n}\r\n// Check whether a delimited node is aligned (meaning there are\r\n// non-skipped nodes on the same line as the opening delimiter). And\r\n// if so, return the opening token.\r\nfunction bracketedAligned(context) {\r\n    let tree = context.node;\r\n    let openToken = tree.childAfter(tree.from), last = tree.lastChild;\r\n    if (!openToken)\r\n        return null;\r\n    let sim = context.options.simulateBreak;\r\n    let openLine = context.state.doc.lineAt(openToken.from);\r\n    let lineEnd = sim == null || sim <= openLine.from ? openLine.to : Math.min(openLine.to, sim);\r\n    for (let pos = openToken.to;;) {\r\n        let next = tree.childAfter(pos);\r\n        if (!next || next == last)\r\n            return null;\r\n        if (!next.type.isSkipped)\r\n            return next.from < lineEnd ? openToken : null;\r\n        pos = next.to;\r\n    }\r\n}\r\n/**\r\nAn indentation strategy for delimited (usually bracketed) nodes.\r\nWill, by default, indent one unit more than the parent's base\r\nindent unless the line starts with a closing token. When `align`\r\nis true and there are non-skipped nodes on the node's opening\r\nline, the content of the node will be aligned with the end of the\r\nopening node, like this:\r\n\r\n    foo(bar,\r\n        baz)\r\n*/\r\nfunction delimitedIndent({ closing, align = true, units = 1 }) {\r\n    return (context) => delimitedStrategy(context, align, units, closing);\r\n}\r\nfunction delimitedStrategy(context, align, units, closing, closedAt) {\r\n    let after = context.textAfter, space = after.match(/^\\s*/)[0].length;\r\n    let closed = closing && after.slice(space, space + closing.length) == closing || closedAt == context.pos + space;\r\n    let aligned = align ? bracketedAligned(context) : null;\r\n    if (aligned)\r\n        return closed ? context.column(aligned.from) : context.column(aligned.to);\r\n    return context.baseIndent + (closed ? 0 : context.unit * units);\r\n}\r\n/**\r\nAn indentation strategy that aligns a node's content to its base\r\nindentation.\r\n*/\r\nconst flatIndent = (context) => context.baseIndent;\r\n/**\r\nCreates an indentation strategy that, by default, indents\r\ncontinued lines one unit more than the node's base indentation.\r\nYou can provide `except` to prevent indentation of lines that\r\nmatch a pattern (for example `/^else\\b/` in `if`/`else`\r\nconstructs), and you can change the amount of units used with the\r\n`units` option.\r\n*/\r\nfunction continuedIndent({ except, units = 1 } = {}) {\r\n    return (context) => {\r\n        let matchExcept = except && except.test(context.textAfter);\r\n        return context.baseIndent + (matchExcept ? 0 : units * context.unit);\r\n    };\r\n}\r\nconst DontIndentBeyond = 200;\r\n/**\r\nEnables reindentation on input. When a language defines an\r\n`indentOnInput` field in its [language\r\ndata](https://codemirror.net/6/docs/ref/#state.EditorState.languageDataAt), which must hold a regular\r\nexpression, the line at the cursor will be reindented whenever new\r\ntext is typed and the input from the start of the line up to the\r\ncursor matches that regexp.\r\n\r\nTo avoid unneccesary reindents, it is recommended to start the\r\nregexp with `^` (usually followed by `\\s*`), and end it with `$`.\r\nFor example, `/^\\s*\\}$/` will reindent when a closing brace is\r\nadded at the start of a line.\r\n*/\r\nfunction indentOnInput() {\r\n    return _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.EditorState.transactionFilter.of(tr => {\r\n        if (!tr.docChanged || !tr.isUserEvent(\"input.type\") && !tr.isUserEvent(\"input.complete\"))\r\n            return tr;\r\n        let rules = tr.startState.languageDataAt(\"indentOnInput\", tr.startState.selection.main.head);\r\n        if (!rules.length)\r\n            return tr;\r\n        let doc = tr.newDoc, { head } = tr.newSelection.main, line = doc.lineAt(head);\r\n        if (head > line.from + DontIndentBeyond)\r\n            return tr;\r\n        let lineStart = doc.sliceString(line.from, head);\r\n        if (!rules.some(r => r.test(lineStart)))\r\n            return tr;\r\n        let { state } = tr, last = -1, changes = [];\r\n        for (let { head } of state.selection.ranges) {\r\n            let line = state.doc.lineAt(head);\r\n            if (line.from == last)\r\n                continue;\r\n            last = line.from;\r\n            let indent = getIndentation(state, line.from);\r\n            if (indent == null)\r\n                continue;\r\n            let cur = /^\\s*/.exec(line.text)[0];\r\n            let norm = indentString(state, indent);\r\n            if (cur != norm)\r\n                changes.push({ from: line.from, to: line.from + cur.length, insert: norm });\r\n        }\r\n        return changes.length ? [tr, { changes, sequential: true }] : tr;\r\n    });\r\n}\r\n\r\n/**\r\nA facet that registers a code folding service. When called with\r\nthe extent of a line, such a function should return a foldable\r\nrange that starts on that line (but continues beyond it), if one\r\ncan be found.\r\n*/\r\nconst foldService = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Facet.define();\r\n/**\r\nThis node prop is used to associate folding information with\r\nsyntax node types. Given a syntax node, it should check whether\r\nthat tree is foldable and return the range that can be collapsed\r\nwhen it is.\r\n*/\r\nconst foldNodeProp = /*@__PURE__*/new _lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeProp();\r\n/**\r\n[Fold](https://codemirror.net/6/docs/ref/#language.foldNodeProp) function that folds everything but\r\nthe first and the last child of a syntax node. Useful for nodes\r\nthat start and end with delimiters.\r\n*/\r\nfunction foldInside(node) {\r\n    let first = node.firstChild, last = node.lastChild;\r\n    return first && first.to < last.from ? { from: first.to, to: last.type.isError ? node.to : last.from } : null;\r\n}\r\nfunction syntaxFolding(state, start, end) {\r\n    let tree = syntaxTree(state);\r\n    if (tree.length < end)\r\n        return null;\r\n    let inner = tree.resolveInner(end, 1);\r\n    let found = null;\r\n    for (let cur = inner; cur; cur = cur.parent) {\r\n        if (cur.to <= end || cur.from > end)\r\n            continue;\r\n        if (found && cur.from < start)\r\n            break;\r\n        let prop = cur.type.prop(foldNodeProp);\r\n        if (prop && (cur.to < tree.length - 50 || tree.length == state.doc.length || !isUnfinished(cur))) {\r\n            let value = prop(cur, state);\r\n            if (value && value.from <= end && value.from >= start && value.to > end)\r\n                found = value;\r\n        }\r\n    }\r\n    return found;\r\n}\r\nfunction isUnfinished(node) {\r\n    let ch = node.lastChild;\r\n    return ch && ch.to == node.to && ch.type.isError;\r\n}\r\n/**\r\nCheck whether the given line is foldable. First asks any fold\r\nservices registered through\r\n[`foldService`](https://codemirror.net/6/docs/ref/#language.foldService), and if none of them return\r\na result, tries to query the [fold node\r\nprop](https://codemirror.net/6/docs/ref/#language.foldNodeProp) of syntax nodes that cover the end\r\nof the line.\r\n*/\r\nfunction foldable(state, lineStart, lineEnd) {\r\n    for (let service of state.facet(foldService)) {\r\n        let result = service(state, lineStart, lineEnd);\r\n        if (result)\r\n            return result;\r\n    }\r\n    return syntaxFolding(state, lineStart, lineEnd);\r\n}\r\nfunction mapRange(range, mapping) {\r\n    let from = mapping.mapPos(range.from, 1), to = mapping.mapPos(range.to, -1);\r\n    return from >= to ? undefined : { from, to };\r\n}\r\n/**\r\nState effect that can be attached to a transaction to fold the\r\ngiven range. (You probably only need this in exceptional\r\ncircumstances—usually you'll just want to let\r\n[`foldCode`](https://codemirror.net/6/docs/ref/#language.foldCode) and the [fold\r\ngutter](https://codemirror.net/6/docs/ref/#language.foldGutter) create the transactions.)\r\n*/\r\nconst foldEffect = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_3__.StateEffect.define({ map: mapRange });\r\n/**\r\nState effect that unfolds the given range (if it was folded).\r\n*/\r\nconst unfoldEffect = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_3__.StateEffect.define({ map: mapRange });\r\nfunction selectedLines(view) {\r\n    let lines = [];\r\n    for (let { head } of view.state.selection.ranges) {\r\n        if (lines.some(l => l.from <= head && l.to >= head))\r\n            continue;\r\n        lines.push(view.lineBlockAt(head));\r\n    }\r\n    return lines;\r\n}\r\n/**\r\nThe state field that stores the folded ranges (as a [decoration\r\nset](https://codemirror.net/6/docs/ref/#view.DecorationSet)). Can be passed to\r\n[`EditorState.toJSON`](https://codemirror.net/6/docs/ref/#state.EditorState.toJSON) and\r\n[`fromJSON`](https://codemirror.net/6/docs/ref/#state.EditorState^fromJSON) to serialize the fold\r\nstate.\r\n*/\r\nconst foldState = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_3__.StateField.define({\r\n    create() {\r\n        return _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.Decoration.none;\r\n    },\r\n    update(folded, tr) {\r\n        folded = folded.map(tr.changes);\r\n        for (let e of tr.effects) {\r\n            if (e.is(foldEffect) && !foldExists(folded, e.value.from, e.value.to))\r\n                folded = folded.update({ add: [foldWidget.range(e.value.from, e.value.to)] });\r\n            else if (e.is(unfoldEffect))\r\n                folded = folded.update({ filter: (from, to) => e.value.from != from || e.value.to != to,\r\n                    filterFrom: e.value.from, filterTo: e.value.to });\r\n        }\r\n        // Clear folded ranges that cover the selection head\r\n        if (tr.selection) {\r\n            let onSelection = false, { head } = tr.selection.main;\r\n            folded.between(head, head, (a, b) => { if (a < head && b > head)\r\n                onSelection = true; });\r\n            if (onSelection)\r\n                folded = folded.update({\r\n                    filterFrom: head,\r\n                    filterTo: head,\r\n                    filter: (a, b) => b <= head || a >= head\r\n                });\r\n        }\r\n        return folded;\r\n    },\r\n    provide: f => _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.EditorView.decorations.from(f),\r\n    toJSON(folded, state) {\r\n        let ranges = [];\r\n        folded.between(0, state.doc.length, (from, to) => { ranges.push(from, to); });\r\n        return ranges;\r\n    },\r\n    fromJSON(value) {\r\n        if (!Array.isArray(value) || value.length % 2)\r\n            throw new RangeError(\"Invalid JSON for fold state\");\r\n        let ranges = [];\r\n        for (let i = 0; i < value.length;) {\r\n            let from = value[i++], to = value[i++];\r\n            if (typeof from != \"number\" || typeof to != \"number\")\r\n                throw new RangeError(\"Invalid JSON for fold state\");\r\n            ranges.push(foldWidget.range(from, to));\r\n        }\r\n        return _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.Decoration.set(ranges, true);\r\n    }\r\n});\r\n/**\r\nGet a [range set](https://codemirror.net/6/docs/ref/#state.RangeSet) containing the folded ranges\r\nin the given state.\r\n*/\r\nfunction foldedRanges(state) {\r\n    return state.field(foldState, false) || _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.RangeSet.empty;\r\n}\r\nfunction findFold(state, from, to) {\r\n    var _a;\r\n    let found = null;\r\n    (_a = state.field(foldState, false)) === null || _a === void 0 ? void 0 : _a.between(from, to, (from, to) => {\r\n        if (!found || found.from > from)\r\n            found = { from, to };\r\n    });\r\n    return found;\r\n}\r\nfunction foldExists(folded, from, to) {\r\n    let found = false;\r\n    folded.between(from, from, (a, b) => { if (a == from && b == to)\r\n        found = true; });\r\n    return found;\r\n}\r\nfunction maybeEnable(state, other) {\r\n    return state.field(foldState, false) ? other : other.concat(_codemirror_state__WEBPACK_IMPORTED_MODULE_3__.StateEffect.appendConfig.of(codeFolding()));\r\n}\r\n/**\r\nFold the lines that are selected, if possible.\r\n*/\r\nconst foldCode = view => {\r\n    for (let line of selectedLines(view)) {\r\n        let range = foldable(view.state, line.from, line.to);\r\n        if (range) {\r\n            view.dispatch({ effects: maybeEnable(view.state, [foldEffect.of(range), announceFold(view, range)]) });\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n};\r\n/**\r\nUnfold folded ranges on selected lines.\r\n*/\r\nconst unfoldCode = view => {\r\n    if (!view.state.field(foldState, false))\r\n        return false;\r\n    let effects = [];\r\n    for (let line of selectedLines(view)) {\r\n        let folded = findFold(view.state, line.from, line.to);\r\n        if (folded)\r\n            effects.push(unfoldEffect.of(folded), announceFold(view, folded, false));\r\n    }\r\n    if (effects.length)\r\n        view.dispatch({ effects });\r\n    return effects.length > 0;\r\n};\r\nfunction announceFold(view, range, fold = true) {\r\n    let lineFrom = view.state.doc.lineAt(range.from).number, lineTo = view.state.doc.lineAt(range.to).number;\r\n    return _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.EditorView.announce.of(`${view.state.phrase(fold ? \"Folded lines\" : \"Unfolded lines\")} ${lineFrom} ${view.state.phrase(\"to\")} ${lineTo}.`);\r\n}\r\n/**\r\nFold all top-level foldable ranges. Note that, in most cases,\r\nfolding information will depend on the [syntax\r\ntree](https://codemirror.net/6/docs/ref/#language.syntaxTree), and folding everything may not work\r\nreliably when the document hasn't been fully parsed (either\r\nbecause the editor state was only just initialized, or because the\r\ndocument is so big that the parser decided not to parse it\r\nentirely).\r\n*/\r\nconst foldAll = view => {\r\n    let { state } = view, effects = [];\r\n    for (let pos = 0; pos < state.doc.length;) {\r\n        let line = view.lineBlockAt(pos), range = foldable(state, line.from, line.to);\r\n        if (range)\r\n            effects.push(foldEffect.of(range));\r\n        pos = (range ? view.lineBlockAt(range.to) : line).to + 1;\r\n    }\r\n    if (effects.length)\r\n        view.dispatch({ effects: maybeEnable(view.state, effects) });\r\n    return !!effects.length;\r\n};\r\n/**\r\nUnfold all folded code.\r\n*/\r\nconst unfoldAll = view => {\r\n    let field = view.state.field(foldState, false);\r\n    if (!field || !field.size)\r\n        return false;\r\n    let effects = [];\r\n    field.between(0, view.state.doc.length, (from, to) => { effects.push(unfoldEffect.of({ from, to })); });\r\n    view.dispatch({ effects });\r\n    return true;\r\n};\r\n/**\r\nDefault fold-related key bindings.\r\n\r\n - Ctrl-Shift-[ (Cmd-Alt-[ on macOS): [`foldCode`](https://codemirror.net/6/docs/ref/#language.foldCode).\r\n - Ctrl-Shift-] (Cmd-Alt-] on macOS): [`unfoldCode`](https://codemirror.net/6/docs/ref/#language.unfoldCode).\r\n - Ctrl-Alt-[: [`foldAll`](https://codemirror.net/6/docs/ref/#language.foldAll).\r\n - Ctrl-Alt-]: [`unfoldAll`](https://codemirror.net/6/docs/ref/#language.unfoldAll).\r\n*/\r\nconst foldKeymap = [\r\n    { key: \"Ctrl-Shift-[\", mac: \"Cmd-Alt-[\", run: foldCode },\r\n    { key: \"Ctrl-Shift-]\", mac: \"Cmd-Alt-]\", run: unfoldCode },\r\n    { key: \"Ctrl-Alt-[\", run: foldAll },\r\n    { key: \"Ctrl-Alt-]\", run: unfoldAll }\r\n];\r\nconst defaultConfig = {\r\n    placeholderDOM: null,\r\n    placeholderText: \"…\"\r\n};\r\nconst foldConfig = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Facet.define({\r\n    combine(values) { return (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_3__.combineConfig)(values, defaultConfig); }\r\n});\r\n/**\r\nCreate an extension that configures code folding.\r\n*/\r\nfunction codeFolding(config) {\r\n    let result = [foldState, baseTheme$1];\r\n    if (config)\r\n        result.push(foldConfig.of(config));\r\n    return result;\r\n}\r\nconst foldWidget = /*@__PURE__*/_codemirror_view__WEBPACK_IMPORTED_MODULE_4__.Decoration.replace({ widget: /*@__PURE__*/new class extends _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.WidgetType {\r\n        toDOM(view) {\r\n            let { state } = view, conf = state.facet(foldConfig);\r\n            let onclick = (event) => {\r\n                let line = view.lineBlockAt(view.posAtDOM(event.target));\r\n                let folded = findFold(view.state, line.from, line.to);\r\n                if (folded)\r\n                    view.dispatch({ effects: unfoldEffect.of(folded) });\r\n                event.preventDefault();\r\n            };\r\n            if (conf.placeholderDOM)\r\n                return conf.placeholderDOM(view, onclick);\r\n            let element = document.createElement(\"span\");\r\n            element.textContent = conf.placeholderText;\r\n            element.setAttribute(\"aria-label\", state.phrase(\"folded code\"));\r\n            element.title = state.phrase(\"unfold\");\r\n            element.className = \"cm-foldPlaceholder\";\r\n            element.onclick = onclick;\r\n            return element;\r\n        }\r\n    } });\r\nconst foldGutterDefaults = {\r\n    openText: \"⌄\",\r\n    closedText: \"›\",\r\n    markerDOM: null,\r\n    domEventHandlers: {},\r\n    foldingChanged: () => false\r\n};\r\nclass FoldMarker extends _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.GutterMarker {\r\n    constructor(config, open) {\r\n        super();\r\n        this.config = config;\r\n        this.open = open;\r\n    }\r\n    eq(other) { return this.config == other.config && this.open == other.open; }\r\n    toDOM(view) {\r\n        if (this.config.markerDOM)\r\n            return this.config.markerDOM(this.open);\r\n        let span = document.createElement(\"span\");\r\n        span.textContent = this.open ? this.config.openText : this.config.closedText;\r\n        span.title = view.state.phrase(this.open ? \"Fold line\" : \"Unfold line\");\r\n        return span;\r\n    }\r\n}\r\n/**\r\nCreate an extension that registers a fold gutter, which shows a\r\nfold status indicator before foldable lines (which can be clicked\r\nto fold or unfold the line).\r\n*/\r\nfunction foldGutter(config = {}) {\r\n    let fullConfig = Object.assign(Object.assign({}, foldGutterDefaults), config);\r\n    let canFold = new FoldMarker(fullConfig, true), canUnfold = new FoldMarker(fullConfig, false);\r\n    let markers = _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.ViewPlugin.fromClass(class {\r\n        constructor(view) {\r\n            this.from = view.viewport.from;\r\n            this.markers = this.buildMarkers(view);\r\n        }\r\n        update(update) {\r\n            if (update.docChanged || update.viewportChanged ||\r\n                update.startState.facet(language) != update.state.facet(language) ||\r\n                update.startState.field(foldState, false) != update.state.field(foldState, false) ||\r\n                syntaxTree(update.startState) != syntaxTree(update.state) ||\r\n                fullConfig.foldingChanged(update))\r\n                this.markers = this.buildMarkers(update.view);\r\n        }\r\n        buildMarkers(view) {\r\n            let builder = new _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.RangeSetBuilder();\r\n            for (let line of view.viewportLineBlocks) {\r\n                let mark = findFold(view.state, line.from, line.to) ? canUnfold\r\n                    : foldable(view.state, line.from, line.to) ? canFold : null;\r\n                if (mark)\r\n                    builder.add(line.from, line.from, mark);\r\n            }\r\n            return builder.finish();\r\n        }\r\n    });\r\n    let { domEventHandlers } = fullConfig;\r\n    return [\r\n        markers,\r\n        (0,_codemirror_view__WEBPACK_IMPORTED_MODULE_4__.gutter)({\r\n            class: \"cm-foldGutter\",\r\n            markers(view) { var _a; return ((_a = view.plugin(markers)) === null || _a === void 0 ? void 0 : _a.markers) || _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.RangeSet.empty; },\r\n            initialSpacer() {\r\n                return new FoldMarker(fullConfig, false);\r\n            },\r\n            domEventHandlers: Object.assign(Object.assign({}, domEventHandlers), { click: (view, line, event) => {\r\n                    if (domEventHandlers.click && domEventHandlers.click(view, line, event))\r\n                        return true;\r\n                    let folded = findFold(view.state, line.from, line.to);\r\n                    if (folded) {\r\n                        view.dispatch({ effects: unfoldEffect.of(folded) });\r\n                        return true;\r\n                    }\r\n                    let range = foldable(view.state, line.from, line.to);\r\n                    if (range) {\r\n                        view.dispatch({ effects: foldEffect.of(range) });\r\n                        return true;\r\n                    }\r\n                    return false;\r\n                } })\r\n        }),\r\n        codeFolding()\r\n    ];\r\n}\r\nconst baseTheme$1 = /*@__PURE__*/_codemirror_view__WEBPACK_IMPORTED_MODULE_4__.EditorView.baseTheme({\r\n    \".cm-foldPlaceholder\": {\r\n        backgroundColor: \"#eee\",\r\n        border: \"1px solid #ddd\",\r\n        color: \"#888\",\r\n        borderRadius: \".2em\",\r\n        margin: \"0 1px\",\r\n        padding: \"0 1px\",\r\n        cursor: \"pointer\"\r\n    },\r\n    \".cm-foldGutter span\": {\r\n        padding: \"0 1px\",\r\n        cursor: \"pointer\"\r\n    }\r\n});\r\n\r\n/**\r\nA highlight style associates CSS styles with higlighting\r\n[tags](https://lezer.codemirror.net/docs/ref#highlight.Tag).\r\n*/\r\nclass HighlightStyle {\r\n    constructor(\r\n    /**\r\n    The tag styles used to create this highlight style.\r\n    */\r\n    specs, options) {\r\n        this.specs = specs;\r\n        let modSpec;\r\n        function def(spec) {\r\n            let cls = style_mod__WEBPACK_IMPORTED_MODULE_2__.StyleModule.newName();\r\n            (modSpec || (modSpec = Object.create(null)))[\".\" + cls] = spec;\r\n            return cls;\r\n        }\r\n        const all = typeof options.all == \"string\" ? options.all : options.all ? def(options.all) : undefined;\r\n        const scopeOpt = options.scope;\r\n        this.scope = scopeOpt instanceof Language ? (type) => type.prop(languageDataProp) == scopeOpt.data\r\n            : scopeOpt ? (type) => type == scopeOpt : undefined;\r\n        this.style = (0,_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tagHighlighter)(specs.map(style => ({\r\n            tag: style.tag,\r\n            class: style.class || def(Object.assign({}, style, { tag: null }))\r\n        })), {\r\n            all,\r\n        }).style;\r\n        this.module = modSpec ? new style_mod__WEBPACK_IMPORTED_MODULE_2__.StyleModule(modSpec) : null;\r\n        this.themeType = options.themeType;\r\n    }\r\n    /**\r\n    Create a highlighter style that associates the given styles to\r\n    the given tags. The specs must be objects that hold a style tag\r\n    or array of tags in their `tag` property, and either a single\r\n    `class` property providing a static CSS class (for highlighter\r\n    that rely on external styling), or a\r\n    [`style-mod`](https://github.com/marijnh/style-mod#documentation)-style\r\n    set of CSS properties (which define the styling for those tags).\r\n    \r\n    The CSS rules created for a highlighter will be emitted in the\r\n    order of the spec's properties. That means that for elements that\r\n    have multiple tags associated with them, styles defined further\r\n    down in the list will have a higher CSS precedence than styles\r\n    defined earlier.\r\n    */\r\n    static define(specs, options) {\r\n        return new HighlightStyle(specs, options || {});\r\n    }\r\n}\r\nconst highlighterFacet = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Facet.define();\r\nconst fallbackHighlighter = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Facet.define({\r\n    combine(values) { return values.length ? [values[0]] : null; }\r\n});\r\nfunction getHighlighters(state) {\r\n    let main = state.facet(highlighterFacet);\r\n    return main.length ? main : state.facet(fallbackHighlighter);\r\n}\r\n/**\r\nWrap a highlighter in an editor extension that uses it to apply\r\nsyntax highlighting to the editor content.\r\n\r\nWhen multiple (non-fallback) styles are provided, the styling\r\napplied is the union of the classes they emit.\r\n*/\r\nfunction syntaxHighlighting(highlighter, options) {\r\n    let ext = [treeHighlighter], themeType;\r\n    if (highlighter instanceof HighlightStyle) {\r\n        if (highlighter.module)\r\n            ext.push(_codemirror_view__WEBPACK_IMPORTED_MODULE_4__.EditorView.styleModule.of(highlighter.module));\r\n        themeType = highlighter.themeType;\r\n    }\r\n    if (options === null || options === void 0 ? void 0 : options.fallback)\r\n        ext.push(fallbackHighlighter.of(highlighter));\r\n    else if (themeType)\r\n        ext.push(highlighterFacet.computeN([_codemirror_view__WEBPACK_IMPORTED_MODULE_4__.EditorView.darkTheme], state => {\r\n            return state.facet(_codemirror_view__WEBPACK_IMPORTED_MODULE_4__.EditorView.darkTheme) == (themeType == \"dark\") ? [highlighter] : [];\r\n        }));\r\n    else\r\n        ext.push(highlighterFacet.of(highlighter));\r\n    return ext;\r\n}\r\n/**\r\nReturns the CSS classes (if any) that the highlighters active in\r\nthe state would assign to the given style\r\n[tags](https://lezer.codemirror.net/docs/ref#highlight.Tag) and\r\n(optional) language\r\n[scope](https://codemirror.net/6/docs/ref/#language.HighlightStyle^define^options.scope).\r\n*/\r\nfunction highlightingFor(state, tags, scope) {\r\n    let highlighters = getHighlighters(state);\r\n    let result = null;\r\n    if (highlighters)\r\n        for (let highlighter of highlighters) {\r\n            if (!highlighter.scope || scope && highlighter.scope(scope)) {\r\n                let cls = highlighter.style(tags);\r\n                if (cls)\r\n                    result = result ? result + \" \" + cls : cls;\r\n            }\r\n        }\r\n    return result;\r\n}\r\nclass TreeHighlighter {\r\n    constructor(view) {\r\n        this.markCache = Object.create(null);\r\n        this.tree = syntaxTree(view.state);\r\n        this.decorations = this.buildDeco(view, getHighlighters(view.state));\r\n    }\r\n    update(update) {\r\n        let tree = syntaxTree(update.state), highlighters = getHighlighters(update.state);\r\n        let styleChange = highlighters != getHighlighters(update.startState);\r\n        if (tree.length < update.view.viewport.to && !styleChange && tree.type == this.tree.type) {\r\n            this.decorations = this.decorations.map(update.changes);\r\n        }\r\n        else if (tree != this.tree || update.viewportChanged || styleChange) {\r\n            this.tree = tree;\r\n            this.decorations = this.buildDeco(update.view, highlighters);\r\n        }\r\n    }\r\n    buildDeco(view, highlighters) {\r\n        if (!highlighters || !this.tree.length)\r\n            return _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.Decoration.none;\r\n        let builder = new _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.RangeSetBuilder();\r\n        for (let { from, to } of view.visibleRanges) {\r\n            (0,_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.highlightTree)(this.tree, highlighters, (from, to, style) => {\r\n                builder.add(from, to, this.markCache[style] || (this.markCache[style] = _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.Decoration.mark({ class: style })));\r\n            }, from, to);\r\n        }\r\n        return builder.finish();\r\n    }\r\n}\r\nconst treeHighlighter = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Prec.high(/*@__PURE__*/_codemirror_view__WEBPACK_IMPORTED_MODULE_4__.ViewPlugin.fromClass(TreeHighlighter, {\r\n    decorations: v => v.decorations\r\n}));\r\n/**\r\nA default highlight style (works well with light themes).\r\n*/\r\nconst defaultHighlightStyle = /*@__PURE__*/HighlightStyle.define([\r\n    { tag: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.meta,\r\n        color: \"#404740\" },\r\n    { tag: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.link,\r\n        textDecoration: \"underline\" },\r\n    { tag: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.heading,\r\n        textDecoration: \"underline\",\r\n        fontWeight: \"bold\" },\r\n    { tag: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.emphasis,\r\n        fontStyle: \"italic\" },\r\n    { tag: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.strong,\r\n        fontWeight: \"bold\" },\r\n    { tag: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.strikethrough,\r\n        textDecoration: \"line-through\" },\r\n    { tag: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.keyword,\r\n        color: \"#708\" },\r\n    { tag: [_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.atom, _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.bool, _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.url, _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.contentSeparator, _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.labelName],\r\n        color: \"#219\" },\r\n    { tag: [_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.literal, _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.inserted],\r\n        color: \"#164\" },\r\n    { tag: [_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.string, _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.deleted],\r\n        color: \"#a11\" },\r\n    { tag: [_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.regexp, _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.escape, /*@__PURE__*/_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.special(_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.string)],\r\n        color: \"#e40\" },\r\n    { tag: /*@__PURE__*/_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.definition(_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.variableName),\r\n        color: \"#00f\" },\r\n    { tag: /*@__PURE__*/_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.local(_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.variableName),\r\n        color: \"#30a\" },\r\n    { tag: [_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.typeName, _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.namespace],\r\n        color: \"#085\" },\r\n    { tag: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.className,\r\n        color: \"#167\" },\r\n    { tag: [/*@__PURE__*/_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.special(_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.variableName), _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.macroName],\r\n        color: \"#256\" },\r\n    { tag: /*@__PURE__*/_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.definition(_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.propertyName),\r\n        color: \"#00c\" },\r\n    { tag: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.comment,\r\n        color: \"#940\" },\r\n    { tag: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.invalid,\r\n        color: \"#f00\" }\r\n]);\r\n\r\nconst baseTheme = /*@__PURE__*/_codemirror_view__WEBPACK_IMPORTED_MODULE_4__.EditorView.baseTheme({\r\n    \"&.cm-focused .cm-matchingBracket\": { backgroundColor: \"#328c8252\" },\r\n    \"&.cm-focused .cm-nonmatchingBracket\": { backgroundColor: \"#bb555544\" }\r\n});\r\nconst DefaultScanDist = 10000, DefaultBrackets = \"()[]{}\";\r\nconst bracketMatchingConfig = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Facet.define({\r\n    combine(configs) {\r\n        return (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_3__.combineConfig)(configs, {\r\n            afterCursor: true,\r\n            brackets: DefaultBrackets,\r\n            maxScanDistance: DefaultScanDist,\r\n            renderMatch: defaultRenderMatch\r\n        });\r\n    }\r\n});\r\nconst matchingMark = /*@__PURE__*/_codemirror_view__WEBPACK_IMPORTED_MODULE_4__.Decoration.mark({ class: \"cm-matchingBracket\" }), nonmatchingMark = /*@__PURE__*/_codemirror_view__WEBPACK_IMPORTED_MODULE_4__.Decoration.mark({ class: \"cm-nonmatchingBracket\" });\r\nfunction defaultRenderMatch(match) {\r\n    let decorations = [];\r\n    let mark = match.matched ? matchingMark : nonmatchingMark;\r\n    decorations.push(mark.range(match.start.from, match.start.to));\r\n    if (match.end)\r\n        decorations.push(mark.range(match.end.from, match.end.to));\r\n    return decorations;\r\n}\r\nconst bracketMatchingState = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_3__.StateField.define({\r\n    create() { return _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.Decoration.none; },\r\n    update(deco, tr) {\r\n        if (!tr.docChanged && !tr.selection)\r\n            return deco;\r\n        let decorations = [];\r\n        let config = tr.state.facet(bracketMatchingConfig);\r\n        for (let range of tr.state.selection.ranges) {\r\n            if (!range.empty)\r\n                continue;\r\n            let match = matchBrackets(tr.state, range.head, -1, config)\r\n                || (range.head > 0 && matchBrackets(tr.state, range.head - 1, 1, config))\r\n                || (config.afterCursor &&\r\n                    (matchBrackets(tr.state, range.head, 1, config) ||\r\n                        (range.head < tr.state.doc.length && matchBrackets(tr.state, range.head + 1, -1, config))));\r\n            if (match)\r\n                decorations = decorations.concat(config.renderMatch(match, tr.state));\r\n        }\r\n        return _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.Decoration.set(decorations, true);\r\n    },\r\n    provide: f => _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.EditorView.decorations.from(f)\r\n});\r\nconst bracketMatchingUnique = [\r\n    bracketMatchingState,\r\n    baseTheme\r\n];\r\n/**\r\nCreate an extension that enables bracket matching. Whenever the\r\ncursor is next to a bracket, that bracket and the one it matches\r\nare highlighted. Or, when no matching bracket is found, another\r\nhighlighting style is used to indicate this.\r\n*/\r\nfunction bracketMatching(config = {}) {\r\n    return [bracketMatchingConfig.of(config), bracketMatchingUnique];\r\n}\r\nfunction matchingNodes(node, dir, brackets) {\r\n    let byProp = node.prop(dir < 0 ? _lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeProp.openedBy : _lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeProp.closedBy);\r\n    if (byProp)\r\n        return byProp;\r\n    if (node.name.length == 1) {\r\n        let index = brackets.indexOf(node.name);\r\n        if (index > -1 && index % 2 == (dir < 0 ? 1 : 0))\r\n            return [brackets[index + dir]];\r\n    }\r\n    return null;\r\n}\r\n/**\r\nFind the matching bracket for the token at `pos`, scanning\r\ndirection `dir`. Only the `brackets` and `maxScanDistance`\r\nproperties are used from `config`, if given. Returns null if no\r\nbracket was found at `pos`, or a match result otherwise.\r\n*/\r\nfunction matchBrackets(state, pos, dir, config = {}) {\r\n    let maxScanDistance = config.maxScanDistance || DefaultScanDist, brackets = config.brackets || DefaultBrackets;\r\n    let tree = syntaxTree(state), node = tree.resolveInner(pos, dir);\r\n    for (let cur = node; cur; cur = cur.parent) {\r\n        let matches = matchingNodes(cur.type, dir, brackets);\r\n        if (matches && cur.from < cur.to)\r\n            return matchMarkedBrackets(state, pos, dir, cur, matches, brackets);\r\n    }\r\n    return matchPlainBrackets(state, pos, dir, tree, node.type, maxScanDistance, brackets);\r\n}\r\nfunction matchMarkedBrackets(_state, _pos, dir, token, matching, brackets) {\r\n    let parent = token.parent, firstToken = { from: token.from, to: token.to };\r\n    let depth = 0, cursor = parent === null || parent === void 0 ? void 0 : parent.cursor();\r\n    if (cursor && (dir < 0 ? cursor.childBefore(token.from) : cursor.childAfter(token.to)))\r\n        do {\r\n            if (dir < 0 ? cursor.to <= token.from : cursor.from >= token.to) {\r\n                if (depth == 0 && matching.indexOf(cursor.type.name) > -1 && cursor.from < cursor.to) {\r\n                    return { start: firstToken, end: { from: cursor.from, to: cursor.to }, matched: true };\r\n                }\r\n                else if (matchingNodes(cursor.type, dir, brackets)) {\r\n                    depth++;\r\n                }\r\n                else if (matchingNodes(cursor.type, -dir, brackets)) {\r\n                    if (depth == 0)\r\n                        return {\r\n                            start: firstToken,\r\n                            end: cursor.from == cursor.to ? undefined : { from: cursor.from, to: cursor.to },\r\n                            matched: false\r\n                        };\r\n                    depth--;\r\n                }\r\n            }\r\n        } while (dir < 0 ? cursor.prevSibling() : cursor.nextSibling());\r\n    return { start: firstToken, matched: false };\r\n}\r\nfunction matchPlainBrackets(state, pos, dir, tree, tokenType, maxScanDistance, brackets) {\r\n    let startCh = dir < 0 ? state.sliceDoc(pos - 1, pos) : state.sliceDoc(pos, pos + 1);\r\n    let bracket = brackets.indexOf(startCh);\r\n    if (bracket < 0 || (bracket % 2 == 0) != (dir > 0))\r\n        return null;\r\n    let startToken = { from: dir < 0 ? pos - 1 : pos, to: dir > 0 ? pos + 1 : pos };\r\n    let iter = state.doc.iterRange(pos, dir > 0 ? state.doc.length : 0), depth = 0;\r\n    for (let distance = 0; !(iter.next()).done && distance <= maxScanDistance;) {\r\n        let text = iter.value;\r\n        if (dir < 0)\r\n            distance += text.length;\r\n        let basePos = pos + distance * dir;\r\n        for (let pos = dir > 0 ? 0 : text.length - 1, end = dir > 0 ? text.length : -1; pos != end; pos += dir) {\r\n            let found = brackets.indexOf(text[pos]);\r\n            if (found < 0 || tree.resolveInner(basePos + pos, 1).type != tokenType)\r\n                continue;\r\n            if ((found % 2 == 0) == (dir > 0)) {\r\n                depth++;\r\n            }\r\n            else if (depth == 1) { // Closing\r\n                return { start: startToken, end: { from: basePos + pos, to: basePos + pos + 1 }, matched: (found >> 1) == (bracket >> 1) };\r\n            }\r\n            else {\r\n                depth--;\r\n            }\r\n        }\r\n        if (dir > 0)\r\n            distance += text.length;\r\n    }\r\n    return iter.done ? { start: startToken, matched: false } : null;\r\n}\r\n\r\n// Counts the column offset in a string, taking tabs into account.\r\n// Used mostly to find indentation.\r\nfunction countCol(string, end, tabSize, startIndex = 0, startValue = 0) {\r\n    if (end == null) {\r\n        end = string.search(/[^\\s\\u00a0]/);\r\n        if (end == -1)\r\n            end = string.length;\r\n    }\r\n    let n = startValue;\r\n    for (let i = startIndex; i < end; i++) {\r\n        if (string.charCodeAt(i) == 9)\r\n            n += tabSize - (n % tabSize);\r\n        else\r\n            n++;\r\n    }\r\n    return n;\r\n}\r\n/**\r\nEncapsulates a single line of input. Given to stream syntax code,\r\nwhich uses it to tokenize the content.\r\n*/\r\nclass StringStream {\r\n    /**\r\n    Create a stream.\r\n    */\r\n    constructor(\r\n    /**\r\n    The line.\r\n    */\r\n    string, tabSize, \r\n    /**\r\n    The current indent unit size.\r\n    */\r\n    indentUnit) {\r\n        this.string = string;\r\n        this.tabSize = tabSize;\r\n        this.indentUnit = indentUnit;\r\n        /**\r\n        The current position on the line.\r\n        */\r\n        this.pos = 0;\r\n        /**\r\n        The start position of the current token.\r\n        */\r\n        this.start = 0;\r\n        this.lastColumnPos = 0;\r\n        this.lastColumnValue = 0;\r\n    }\r\n    /**\r\n    True if we are at the end of the line.\r\n    */\r\n    eol() { return this.pos >= this.string.length; }\r\n    /**\r\n    True if we are at the start of the line.\r\n    */\r\n    sol() { return this.pos == 0; }\r\n    /**\r\n    Get the next code unit after the current position, or undefined\r\n    if we're at the end of the line.\r\n    */\r\n    peek() { return this.string.charAt(this.pos) || undefined; }\r\n    /**\r\n    Read the next code unit and advance `this.pos`.\r\n    */\r\n    next() {\r\n        if (this.pos < this.string.length)\r\n            return this.string.charAt(this.pos++);\r\n    }\r\n    /**\r\n    Match the next character against the given string, regular\r\n    expression, or predicate. Consume and return it if it matches.\r\n    */\r\n    eat(match) {\r\n        let ch = this.string.charAt(this.pos);\r\n        let ok;\r\n        if (typeof match == \"string\")\r\n            ok = ch == match;\r\n        else\r\n            ok = ch && (match instanceof RegExp ? match.test(ch) : match(ch));\r\n        if (ok) {\r\n            ++this.pos;\r\n            return ch;\r\n        }\r\n    }\r\n    /**\r\n    Continue matching characters that match the given string,\r\n    regular expression, or predicate function. Return true if any\r\n    characters were consumed.\r\n    */\r\n    eatWhile(match) {\r\n        let start = this.pos;\r\n        while (this.eat(match)) { }\r\n        return this.pos > start;\r\n    }\r\n    /**\r\n    Consume whitespace ahead of `this.pos`. Return true if any was\r\n    found.\r\n    */\r\n    eatSpace() {\r\n        let start = this.pos;\r\n        while (/[\\s\\u00a0]/.test(this.string.charAt(this.pos)))\r\n            ++this.pos;\r\n        return this.pos > start;\r\n    }\r\n    /**\r\n    Move to the end of the line.\r\n    */\r\n    skipToEnd() { this.pos = this.string.length; }\r\n    /**\r\n    Move to directly before the given character, if found on the\r\n    current line.\r\n    */\r\n    skipTo(ch) {\r\n        let found = this.string.indexOf(ch, this.pos);\r\n        if (found > -1) {\r\n            this.pos = found;\r\n            return true;\r\n        }\r\n    }\r\n    /**\r\n    Move back `n` characters.\r\n    */\r\n    backUp(n) { this.pos -= n; }\r\n    /**\r\n    Get the column position at `this.pos`.\r\n    */\r\n    column() {\r\n        if (this.lastColumnPos < this.start) {\r\n            this.lastColumnValue = countCol(this.string, this.start, this.tabSize, this.lastColumnPos, this.lastColumnValue);\r\n            this.lastColumnPos = this.start;\r\n        }\r\n        return this.lastColumnValue;\r\n    }\r\n    /**\r\n    Get the indentation column of the current line.\r\n    */\r\n    indentation() {\r\n        return countCol(this.string, null, this.tabSize);\r\n    }\r\n    /**\r\n    Match the input against the given string or regular expression\r\n    (which should start with a `^`). Return true or the regexp match\r\n    if it matches.\r\n    \r\n    Unless `consume` is set to `false`, this will move `this.pos`\r\n    past the matched text.\r\n    \r\n    When matching a string `caseInsensitive` can be set to true to\r\n    make the match case-insensitive.\r\n    */\r\n    match(pattern, consume, caseInsensitive) {\r\n        if (typeof pattern == \"string\") {\r\n            let cased = (str) => caseInsensitive ? str.toLowerCase() : str;\r\n            let substr = this.string.substr(this.pos, pattern.length);\r\n            if (cased(substr) == cased(pattern)) {\r\n                if (consume !== false)\r\n                    this.pos += pattern.length;\r\n                return true;\r\n            }\r\n            else\r\n                return null;\r\n        }\r\n        else {\r\n            let match = this.string.slice(this.pos).match(pattern);\r\n            if (match && match.index > 0)\r\n                return null;\r\n            if (match && consume !== false)\r\n                this.pos += match[0].length;\r\n            return match;\r\n        }\r\n    }\r\n    /**\r\n    Get the current token.\r\n    */\r\n    current() { return this.string.slice(this.start, this.pos); }\r\n}\r\n\r\nfunction fullParser(spec) {\r\n    return {\r\n        name: spec.name || \"\",\r\n        token: spec.token,\r\n        blankLine: spec.blankLine || (() => { }),\r\n        startState: spec.startState || (() => true),\r\n        copyState: spec.copyState || defaultCopyState,\r\n        indent: spec.indent || (() => null),\r\n        languageData: spec.languageData || {},\r\n        tokenTable: spec.tokenTable || noTokens\r\n    };\r\n}\r\nfunction defaultCopyState(state) {\r\n    if (typeof state != \"object\")\r\n        return state;\r\n    let newState = {};\r\n    for (let prop in state) {\r\n        let val = state[prop];\r\n        newState[prop] = (val instanceof Array ? val.slice() : val);\r\n    }\r\n    return newState;\r\n}\r\n/**\r\nA [language](https://codemirror.net/6/docs/ref/#language.Language) class based on a CodeMirror\r\n5-style [streaming parser](https://codemirror.net/6/docs/ref/#language.StreamParser).\r\n*/\r\nclass StreamLanguage extends Language {\r\n    constructor(parser) {\r\n        let data = defineLanguageFacet(parser.languageData);\r\n        let p = fullParser(parser), self;\r\n        let impl = new class extends _lezer_common__WEBPACK_IMPORTED_MODULE_0__.Parser {\r\n            createParse(input, fragments, ranges) {\r\n                return new Parse(self, input, fragments, ranges);\r\n            }\r\n        };\r\n        super(data, impl, [indentService.of((cx, pos) => this.getIndent(cx, pos))], parser.name);\r\n        this.topNode = docID(data);\r\n        self = this;\r\n        this.streamParser = p;\r\n        this.stateAfter = new _lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeProp({ perNode: true });\r\n        this.tokenTable = parser.tokenTable ? new TokenTable(p.tokenTable) : defaultTokenTable;\r\n    }\r\n    /**\r\n    Define a stream language.\r\n    */\r\n    static define(spec) { return new StreamLanguage(spec); }\r\n    getIndent(cx, pos) {\r\n        let tree = syntaxTree(cx.state), at = tree.resolve(pos);\r\n        while (at && at.type != this.topNode)\r\n            at = at.parent;\r\n        if (!at)\r\n            return null;\r\n        let start = findState(this, tree, 0, at.from, pos), statePos, state;\r\n        if (start) {\r\n            state = start.state;\r\n            statePos = start.pos + 1;\r\n        }\r\n        else {\r\n            state = this.streamParser.startState(cx.unit);\r\n            statePos = 0;\r\n        }\r\n        if (pos - statePos > 10000 /* C.MaxIndentScanDist */)\r\n            return null;\r\n        while (statePos < pos) {\r\n            let line = cx.state.doc.lineAt(statePos), end = Math.min(pos, line.to);\r\n            if (line.length) {\r\n                let stream = new StringStream(line.text, cx.state.tabSize, cx.unit);\r\n                while (stream.pos < end - line.from)\r\n                    readToken(this.streamParser.token, stream, state);\r\n            }\r\n            else {\r\n                this.streamParser.blankLine(state, cx.unit);\r\n            }\r\n            if (end == pos)\r\n                break;\r\n            statePos = line.to + 1;\r\n        }\r\n        let { text } = cx.lineAt(pos);\r\n        return this.streamParser.indent(state, /^\\s*(.*)/.exec(text)[1], cx);\r\n    }\r\n    get allowsNesting() { return false; }\r\n}\r\nfunction findState(lang, tree, off, startPos, before) {\r\n    let state = off >= startPos && off + tree.length <= before && tree.prop(lang.stateAfter);\r\n    if (state)\r\n        return { state: lang.streamParser.copyState(state), pos: off + tree.length };\r\n    for (let i = tree.children.length - 1; i >= 0; i--) {\r\n        let child = tree.children[i], pos = off + tree.positions[i];\r\n        let found = child instanceof _lezer_common__WEBPACK_IMPORTED_MODULE_0__.Tree && pos < before && findState(lang, child, pos, startPos, before);\r\n        if (found)\r\n            return found;\r\n    }\r\n    return null;\r\n}\r\nfunction cutTree(lang, tree, from, to, inside) {\r\n    if (inside && from <= 0 && to >= tree.length)\r\n        return tree;\r\n    if (!inside && tree.type == lang.topNode)\r\n        inside = true;\r\n    for (let i = tree.children.length - 1; i >= 0; i--) {\r\n        let pos = tree.positions[i], child = tree.children[i], inner;\r\n        if (pos < to && child instanceof _lezer_common__WEBPACK_IMPORTED_MODULE_0__.Tree) {\r\n            if (!(inner = cutTree(lang, child, from - pos, to - pos, inside)))\r\n                break;\r\n            return !inside ? inner\r\n                : new _lezer_common__WEBPACK_IMPORTED_MODULE_0__.Tree(tree.type, tree.children.slice(0, i).concat(inner), tree.positions.slice(0, i + 1), pos + inner.length);\r\n        }\r\n    }\r\n    return null;\r\n}\r\nfunction findStartInFragments(lang, fragments, startPos, editorState) {\r\n    for (let f of fragments) {\r\n        let from = f.from + (f.openStart ? 25 : 0), to = f.to - (f.openEnd ? 25 : 0);\r\n        let found = from <= startPos && to > startPos && findState(lang, f.tree, 0 - f.offset, startPos, to), tree;\r\n        if (found && (tree = cutTree(lang, f.tree, startPos + f.offset, found.pos + f.offset, false)))\r\n            return { state: found.state, tree };\r\n    }\r\n    return { state: lang.streamParser.startState(editorState ? getIndentUnit(editorState) : 4), tree: _lezer_common__WEBPACK_IMPORTED_MODULE_0__.Tree.empty };\r\n}\r\nclass Parse {\r\n    constructor(lang, input, fragments, ranges) {\r\n        this.lang = lang;\r\n        this.input = input;\r\n        this.fragments = fragments;\r\n        this.ranges = ranges;\r\n        this.stoppedAt = null;\r\n        this.chunks = [];\r\n        this.chunkPos = [];\r\n        this.chunk = [];\r\n        this.chunkReused = undefined;\r\n        this.rangeIndex = 0;\r\n        this.to = ranges[ranges.length - 1].to;\r\n        let context = ParseContext.get(), from = ranges[0].from;\r\n        let { state, tree } = findStartInFragments(lang, fragments, from, context === null || context === void 0 ? void 0 : context.state);\r\n        this.state = state;\r\n        this.parsedPos = this.chunkStart = from + tree.length;\r\n        for (let i = 0; i < tree.children.length; i++) {\r\n            this.chunks.push(tree.children[i]);\r\n            this.chunkPos.push(tree.positions[i]);\r\n        }\r\n        if (context && this.parsedPos < context.viewport.from - 100000 /* C.MaxDistanceBeforeViewport */) {\r\n            this.state = this.lang.streamParser.startState(getIndentUnit(context.state));\r\n            context.skipUntilInView(this.parsedPos, context.viewport.from);\r\n            this.parsedPos = context.viewport.from;\r\n        }\r\n        this.moveRangeIndex();\r\n    }\r\n    advance() {\r\n        let context = ParseContext.get();\r\n        let parseEnd = this.stoppedAt == null ? this.to : Math.min(this.to, this.stoppedAt);\r\n        let end = Math.min(parseEnd, this.chunkStart + 2048 /* C.ChunkSize */);\r\n        if (context)\r\n            end = Math.min(end, context.viewport.to);\r\n        while (this.parsedPos < end)\r\n            this.parseLine(context);\r\n        if (this.chunkStart < this.parsedPos)\r\n            this.finishChunk();\r\n        if (this.parsedPos >= parseEnd)\r\n            return this.finish();\r\n        if (context && this.parsedPos >= context.viewport.to) {\r\n            context.skipUntilInView(this.parsedPos, parseEnd);\r\n            return this.finish();\r\n        }\r\n        return null;\r\n    }\r\n    stopAt(pos) {\r\n        this.stoppedAt = pos;\r\n    }\r\n    lineAfter(pos) {\r\n        let chunk = this.input.chunk(pos);\r\n        if (!this.input.lineChunks) {\r\n            let eol = chunk.indexOf(\"\\n\");\r\n            if (eol > -1)\r\n                chunk = chunk.slice(0, eol);\r\n        }\r\n        else if (chunk == \"\\n\") {\r\n            chunk = \"\";\r\n        }\r\n        return pos + chunk.length <= this.to ? chunk : chunk.slice(0, this.to - pos);\r\n    }\r\n    nextLine() {\r\n        let from = this.parsedPos, line = this.lineAfter(from), end = from + line.length;\r\n        for (let index = this.rangeIndex;;) {\r\n            let rangeEnd = this.ranges[index].to;\r\n            if (rangeEnd >= end)\r\n                break;\r\n            line = line.slice(0, rangeEnd - (end - line.length));\r\n            index++;\r\n            if (index == this.ranges.length)\r\n                break;\r\n            let rangeStart = this.ranges[index].from;\r\n            let after = this.lineAfter(rangeStart);\r\n            line += after;\r\n            end = rangeStart + after.length;\r\n        }\r\n        return { line, end };\r\n    }\r\n    skipGapsTo(pos, offset, side) {\r\n        for (;;) {\r\n            let end = this.ranges[this.rangeIndex].to, offPos = pos + offset;\r\n            if (side > 0 ? end > offPos : end >= offPos)\r\n                break;\r\n            let start = this.ranges[++this.rangeIndex].from;\r\n            offset += start - end;\r\n        }\r\n        return offset;\r\n    }\r\n    moveRangeIndex() {\r\n        while (this.ranges[this.rangeIndex].to < this.parsedPos)\r\n            this.rangeIndex++;\r\n    }\r\n    emitToken(id, from, to, size, offset) {\r\n        if (this.ranges.length > 1) {\r\n            offset = this.skipGapsTo(from, offset, 1);\r\n            from += offset;\r\n            let len0 = this.chunk.length;\r\n            offset = this.skipGapsTo(to, offset, -1);\r\n            to += offset;\r\n            size += this.chunk.length - len0;\r\n        }\r\n        this.chunk.push(id, from, to, size);\r\n        return offset;\r\n    }\r\n    parseLine(context) {\r\n        let { line, end } = this.nextLine(), offset = 0, { streamParser } = this.lang;\r\n        let stream = new StringStream(line, context ? context.state.tabSize : 4, context ? getIndentUnit(context.state) : 2);\r\n        if (stream.eol()) {\r\n            streamParser.blankLine(this.state, stream.indentUnit);\r\n        }\r\n        else {\r\n            while (!stream.eol()) {\r\n                let token = readToken(streamParser.token, stream, this.state);\r\n                if (token)\r\n                    offset = this.emitToken(this.lang.tokenTable.resolve(token), this.parsedPos + stream.start, this.parsedPos + stream.pos, 4, offset);\r\n                if (stream.start > 10000 /* C.MaxLineLength */)\r\n                    break;\r\n            }\r\n        }\r\n        this.parsedPos = end;\r\n        this.moveRangeIndex();\r\n        if (this.parsedPos < this.to)\r\n            this.parsedPos++;\r\n    }\r\n    finishChunk() {\r\n        let tree = _lezer_common__WEBPACK_IMPORTED_MODULE_0__.Tree.build({\r\n            buffer: this.chunk,\r\n            start: this.chunkStart,\r\n            length: this.parsedPos - this.chunkStart,\r\n            nodeSet,\r\n            topID: 0,\r\n            maxBufferLength: 2048 /* C.ChunkSize */,\r\n            reused: this.chunkReused\r\n        });\r\n        tree = new _lezer_common__WEBPACK_IMPORTED_MODULE_0__.Tree(tree.type, tree.children, tree.positions, tree.length, [[this.lang.stateAfter, this.lang.streamParser.copyState(this.state)]]);\r\n        this.chunks.push(tree);\r\n        this.chunkPos.push(this.chunkStart - this.ranges[0].from);\r\n        this.chunk = [];\r\n        this.chunkReused = undefined;\r\n        this.chunkStart = this.parsedPos;\r\n    }\r\n    finish() {\r\n        return new _lezer_common__WEBPACK_IMPORTED_MODULE_0__.Tree(this.lang.topNode, this.chunks, this.chunkPos, this.parsedPos - this.ranges[0].from).balance();\r\n    }\r\n}\r\nfunction readToken(token, stream, state) {\r\n    stream.start = stream.pos;\r\n    for (let i = 0; i < 10; i++) {\r\n        let result = token(stream, state);\r\n        if (stream.pos > stream.start)\r\n            return result;\r\n    }\r\n    throw new Error(\"Stream parser failed to advance stream.\");\r\n}\r\nconst noTokens = /*@__PURE__*/Object.create(null);\r\nconst typeArray = [_lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeType.none];\r\nconst nodeSet = /*@__PURE__*/new _lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeSet(typeArray);\r\nconst warned = [];\r\nconst defaultTable = /*@__PURE__*/Object.create(null);\r\nfor (let [legacyName, name] of [\r\n    [\"variable\", \"variableName\"],\r\n    [\"variable-2\", \"variableName.special\"],\r\n    [\"string-2\", \"string.special\"],\r\n    [\"def\", \"variableName.definition\"],\r\n    [\"tag\", \"tagName\"],\r\n    [\"attribute\", \"attributeName\"],\r\n    [\"type\", \"typeName\"],\r\n    [\"builtin\", \"variableName.standard\"],\r\n    [\"qualifier\", \"modifier\"],\r\n    [\"error\", \"invalid\"],\r\n    [\"header\", \"heading\"],\r\n    [\"property\", \"propertyName\"]\r\n])\r\n    defaultTable[legacyName] = /*@__PURE__*/createTokenType(noTokens, name);\r\nclass TokenTable {\r\n    constructor(extra) {\r\n        this.extra = extra;\r\n        this.table = Object.assign(Object.create(null), defaultTable);\r\n    }\r\n    resolve(tag) {\r\n        return !tag ? 0 : this.table[tag] || (this.table[tag] = createTokenType(this.extra, tag));\r\n    }\r\n}\r\nconst defaultTokenTable = /*@__PURE__*/new TokenTable(noTokens);\r\nfunction warnForPart(part, msg) {\r\n    if (warned.indexOf(part) > -1)\r\n        return;\r\n    warned.push(part);\r\n    console.warn(msg);\r\n}\r\nfunction createTokenType(extra, tagStr) {\r\n    let tag = null;\r\n    for (let part of tagStr.split(\".\")) {\r\n        let value = (extra[part] || _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags[part]);\r\n        if (!value) {\r\n            warnForPart(part, `Unknown highlighting tag ${part}`);\r\n        }\r\n        else if (typeof value == \"function\") {\r\n            if (!tag)\r\n                warnForPart(part, `Modifier ${part} used at start of tag`);\r\n            else\r\n                tag = value(tag);\r\n        }\r\n        else {\r\n            if (tag)\r\n                warnForPart(part, `Tag ${part} used as modifier`);\r\n            else\r\n                tag = value;\r\n        }\r\n    }\r\n    if (!tag)\r\n        return 0;\r\n    let name = tagStr.replace(/ /g, \"_\"), type = _lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeType.define({\r\n        id: typeArray.length,\r\n        name,\r\n        props: [(0,_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.styleTags)({ [name]: tag })]\r\n    });\r\n    typeArray.push(type);\r\n    return type.id;\r\n}\r\nfunction docID(data) {\r\n    let type = _lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeType.define({ id: typeArray.length, name: \"Document\", props: [languageDataProp.add(() => data)] });\r\n    typeArray.push(type);\r\n    return type;\r\n}\r\n\r\n\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGNvZGVtaXJyb3IvbGFuZ3VhZ2UvZGlzdC9pbmRleC5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBa0c7QUFDMkM7QUFDdkI7QUFDcEM7QUFDMUM7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLG1EQUFRO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsMkRBQVk7QUFDdkI7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxtRkFBb0M7QUFDakQsa0NBQWtDLG9FQUFxQixZQUFZLFFBQVEsNEJBQTRCO0FBQ3ZHO0FBQ0E7QUFDQTtBQUNBLFlBQVksMEVBQTJCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLCtCQUErQjtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLDhCQUE4QjtBQUM1RDtBQUNBO0FBQ0Esa0NBQWtDLDJEQUFnQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxzQ0FBc0M7QUFDaEY7QUFDQSxzQ0FBc0Msb0NBQW9DO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QiwwQkFBMEI7QUFDdEQ7QUFDQSxrQ0FBa0MsK0NBQUk7QUFDdEM7QUFDQTtBQUNBO0FB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LGlDQUFpQyxlQUFlO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHFEQUFVO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULG1CQUFtQiwrQ0FBSTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiwrQ0FBSTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHdEQUFhO0FBQ2hDLGlDQUFpQyxrREFBTztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0Msa0RBQUk7QUFDeEM7QUFDQSwwREFBMEQsS0FBSztBQUMvRDtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsTUFBTTtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLE1BQU07QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELDBEQUFlO0FBQ2hFO0FBQ0E7QUFDQSxnQkFBZ0IsMkRBQVMsR0FBRyxhQUFhO0FBQ3pDLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsMERBQWUsR0FBRyxtRkFBbUY7QUFDcEg7QUFDQTtBQUNBO0FBQ0E7QUFDNHRCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AY29kZW1pcnJvci9sYW5ndWFnZS9kaXN0L2luZGV4LmpzP2ViNTciXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgTm9kZVByb3AsIEl0ZXJNb2RlLCBUcmVlLCBUcmVlRnJhZ21lbnQsIFBhcnNlciwgTm9kZVR5cGUsIE5vZGVTZXQgfSBmcm9tICdAbGV6ZXIvY29tbW9uJztcclxuaW1wb3J0IHsgU3RhdGVFZmZlY3QsIFN0YXRlRmllbGQsIEZhY2V0LCBFZGl0b3JTdGF0ZSwgY291bnRDb2x1bW4sIGNvbWJpbmVDb25maWcsIFJhbmdlU2V0LCBSYW5nZVNldEJ1aWxkZXIsIFByZWMgfSBmcm9tICdAY29kZW1pcnJvci9zdGF0ZSc7XHJcbmltcG9ydCB7IFZpZXdQbHVnaW4sIGxvZ0V4Y2VwdGlvbiwgRWRpdG9yVmlldywgRGVjb3JhdGlvbiwgV2lkZ2V0VHlwZSwgZ3V0dGVyLCBHdXR0ZXJNYXJrZXIgfSBmcm9tICdAY29kZW1pcnJvci92aWV3JztcclxuaW1wb3J0IHsgdGFncywgdGFnSGlnaGxpZ2h0ZXIsIGhpZ2hsaWdodFRyZWUsIHN0eWxlVGFncyB9IGZyb20gJ0BsZXplci9oaWdobGlnaHQnO1xyXG5pbXBvcnQgeyBTdHlsZU1vZHVsZSB9IGZyb20gJ3N0eWxlLW1vZCc7XHJcblxyXG52YXIgX2E7XHJcbi8qKlxyXG5Ob2RlIHByb3Agc3RvcmVkIGluIGEgcGFyc2VyJ3MgdG9wIHN5bnRheCBub2RlIHRvIHByb3ZpZGUgdGhlXHJcbmZhY2V0IHRoYXQgc3RvcmVzIGxhbmd1YWdlLXNwZWNpZmljIGRhdGEgZm9yIHRoYXQgbGFuZ3VhZ2UuXHJcbiovXHJcbmNvbnN0IGxhbmd1YWdlRGF0YVByb3AgPSAvKkBfX1BVUkVfXyovbmV3IE5vZGVQcm9wKCk7XHJcbi8qKlxyXG5IZWxwZXIgZnVuY3Rpb24gdG8gZGVmaW5lIGEgZmFjZXQgKHRvIGJlIGFkZGVkIHRvIHRoZSB0b3Agc3ludGF4XHJcbm5vZGUocykgZm9yIGEgbGFuZ3VhZ2UgdmlhXHJcbltgbGFuZ3VhZ2VEYXRhUHJvcGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jbGFuZ3VhZ2UubGFuZ3VhZ2VEYXRhUHJvcCkpLCB0aGF0IHdpbGwgYmVcclxudXNlZCB0byBhc3NvY2lhdGUgbGFuZ3VhZ2UgZGF0YSB3aXRoIHRoZSBsYW5ndWFnZS4gWW91XHJcbnByb2JhYmx5IG9ubHkgbmVlZCB0aGlzIHdoZW4gc3ViY2xhc3NpbmdcclxuW2BMYW5ndWFnZWBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jbGFuZ3VhZ2UuTGFuZ3VhZ2UpLlxyXG4qL1xyXG5mdW5jdGlvbiBkZWZpbmVMYW5ndWFnZUZhY2V0KGJhc2VEYXRhKSB7XHJcbiAgICByZXR1cm4gRmFjZXQuZGVmaW5lKHtcclxuICAgICAgICBjb21iaW5lOiBiYXNlRGF0YSA/IHZhbHVlcyA9PiB2YWx1ZXMuY29uY2F0KGJhc2VEYXRhKSA6IHVuZGVmaW5lZFxyXG4gICAgfSk7XHJcbn1cclxuLyoqXHJcbkEgbGFuZ3VhZ2Ugb2JqZWN0IG1hbmFnZXMgcGFyc2luZyBhbmQgcGVyLWxhbmd1YWdlXHJcblttZXRhZGF0YV0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5FZGl0b3JTdGF0ZS5sYW5ndWFnZURhdGFBdCkuIFBhcnNlIGRhdGEgaXNcclxubWFuYWdlZCBhcyBhIFtMZXplcl0oaHR0cHM6Ly9sZXplci5jb2RlbWlycm9yLm5ldCkgdHJlZS4gVGhlIGNsYXNzXHJcbmNhbiBiZSB1c2VkIGRpcmVjdGx5LCB2aWEgdGhlIFtgTFJMYW5ndWFnZWBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jbGFuZ3VhZ2UuTFJMYW5ndWFnZSlcclxuc3ViY2xhc3MgZm9yIFtMZXplcl0oaHR0cHM6Ly9sZXplci5jb2RlbWlycm9yLm5ldC8pIExSIHBhcnNlcnMsIG9yXHJcbnZpYSB0aGUgW2BTdHJlYW1MYW5ndWFnZWBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jbGFuZ3VhZ2UuU3RyZWFtTGFuZ3VhZ2UpIHN1YmNsYXNzXHJcbmZvciBzdHJlYW0gcGFyc2Vycy5cclxuKi9cclxuY2xhc3MgTGFuZ3VhZ2Uge1xyXG4gICAgLyoqXHJcbiAgICBDb25zdHJ1Y3QgYSBsYW5ndWFnZSBvYmplY3QuIElmIHlvdSBuZWVkIHRvIGludm9rZSB0aGlzXHJcbiAgICBkaXJlY3RseSwgZmlyc3QgZGVmaW5lIGEgZGF0YSBmYWNldCB3aXRoXHJcbiAgICBbYGRlZmluZUxhbmd1YWdlRmFjZXRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2xhbmd1YWdlLmRlZmluZUxhbmd1YWdlRmFjZXQpLCBhbmQgdGhlblxyXG4gICAgY29uZmlndXJlIHlvdXIgcGFyc2VyIHRvIFthdHRhY2hdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jbGFuZ3VhZ2UubGFuZ3VhZ2VEYXRhUHJvcCkgaXRcclxuICAgIHRvIHRoZSBsYW5ndWFnZSdzIG91dGVyIHN5bnRheCBub2RlLlxyXG4gICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKFxyXG4gICAgLyoqXHJcbiAgICBUaGUgW2xhbmd1YWdlIGRhdGFdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuRWRpdG9yU3RhdGUubGFuZ3VhZ2VEYXRhQXQpIGZhY2V0XHJcbiAgICB1c2VkIGZvciB0aGlzIGxhbmd1YWdlLlxyXG4gICAgKi9cclxuICAgIGRhdGEsIHBhcnNlciwgZXh0cmFFeHRlbnNpb25zID0gW10sIFxyXG4gICAgLyoqXHJcbiAgICBBIGxhbmd1YWdlIG5hbWUuXHJcbiAgICAqL1xyXG4gICAgbmFtZSA9IFwiXCIpIHtcclxuICAgICAgICB0aGlzLmRhdGEgPSBkYXRhO1xyXG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XHJcbiAgICAgICAgLy8gS2x1ZGdlIHRvIGRlZmluZSBFZGl0b3JTdGF0ZS50cmVlIGFzIGEgZGVidWdnaW5nIGhlbHBlcixcclxuICAgICAgICAvLyB3aXRob3V0IHRoZSBFZGl0b3JTdGF0ZSBwYWNrYWdlIGFjdHVhbGx5IGtub3dpbmcgYWJvdXRcclxuICAgICAgICAvLyBsYW5ndWFnZXMgYW5kIGxlemVyIHRyZWVzLlxyXG4gICAgICAgIGlmICghRWRpdG9yU3RhdGUucHJvdG90eXBlLmhhc093blByb3BlcnR5KFwidHJlZVwiKSlcclxuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEVkaXRvclN0YXRlLnByb3RvdHlwZSwgXCJ0cmVlXCIsIHsgZ2V0KCkgeyByZXR1cm4gc3ludGF4VHJlZSh0aGlzKTsgfSB9KTtcclxuICAgICAgICB0aGlzLnBhcnNlciA9IHBhcnNlcjtcclxuICAgICAgICB0aGlzLmV4dGVuc2lvbiA9IFtcclxuICAgICAgICAgICAgbGFuZ3VhZ2Uub2YodGhpcyksXHJcbiAgICAgICAgICAgIEVkaXRvclN0YXRlLmxhbmd1YWdlRGF0YS5vZigoc3RhdGUsIHBvcywgc2lkZSkgPT4gc3RhdGUuZmFjZXQobGFuZ3VhZ2VEYXRhRmFjZXRBdChzdGF0ZSwgcG9zLCBzaWRlKSkpXHJcbiAgICAgICAgXS5jb25jYXQoZXh0cmFFeHRlbnNpb25zKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgUXVlcnkgd2hldGhlciB0aGlzIGxhbmd1YWdlIGlzIGFjdGl2ZSBhdCB0aGUgZ2l2ZW4gcG9zaXRpb24uXHJcbiAgICAqL1xyXG4gICAgaXNBY3RpdmVBdChzdGF0ZSwgcG9zLCBzaWRlID0gLTEpIHtcclxuICAgICAgICByZXR1cm4gbGFuZ3VhZ2VEYXRhRmFjZXRBdChzdGF0ZSwgcG9zLCBzaWRlKSA9PSB0aGlzLmRhdGE7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgIEZpbmQgdGhlIGRvY3VtZW50IHJlZ2lvbnMgdGhhdCB3ZXJlIHBhcnNlZCB1c2luZyB0aGlzIGxhbmd1YWdlLlxyXG4gICAgVGhlIHJldHVybmVkIHJlZ2lvbnMgd2lsbCBfaW5jbHVkZV8gYW55IG5lc3RlZCBsYW5ndWFnZXMgcm9vdGVkXHJcbiAgICBpbiB0aGlzIGxhbmd1YWdlLCB3aGVuIHRob3NlIGV4aXN0LlxyXG4gICAgKi9cclxuICAgIGZpbmRSZWdpb25zKHN0YXRlKSB7XHJcbiAgICAgICAgbGV0IGxhbmcgPSBzdGF0ZS5mYWNldChsYW5ndWFnZSk7XHJcbiAgICAgICAgaWYgKChsYW5nID09PSBudWxsIHx8IGxhbmcgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGxhbmcuZGF0YSkgPT0gdGhpcy5kYXRhKVxyXG4gICAgICAgICAgICByZXR1cm4gW3sgZnJvbTogMCwgdG86IHN0YXRlLmRvYy5sZW5ndGggfV07XHJcbiAgICAgICAgaWYgKCFsYW5nIHx8ICFsYW5nLmFsbG93c05lc3RpbmcpXHJcbiAgICAgICAgICAgIHJldHVybiBbXTtcclxuICAgICAgICBsZXQgcmVzdWx0ID0gW107XHJcbiAgICAgICAgbGV0IGV4cGxvcmUgPSAodHJlZSwgZnJvbSkgPT4ge1xyXG4gICAgICAgICAgICBpZiAodHJlZS5wcm9wKGxhbmd1YWdlRGF0YVByb3ApID09IHRoaXMuZGF0YSkge1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goeyBmcm9tLCB0bzogZnJvbSArIHRyZWUubGVuZ3RoIH0pO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGxldCBtb3VudCA9IHRyZWUucHJvcChOb2RlUHJvcC5tb3VudGVkKTtcclxuICAgICAgICAgICAgaWYgKG1vdW50KSB7XHJcbiAgICAgICAgICAgICAgICBpZiAobW91bnQudHJlZS5wcm9wKGxhbmd1YWdlRGF0YVByb3ApID09IHRoaXMuZGF0YSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChtb3VudC5vdmVybGF5KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCByIG9mIG1vdW50Lm92ZXJsYXkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh7IGZyb206IHIuZnJvbSArIGZyb20sIHRvOiByLnRvICsgZnJvbSB9KTtcclxuICAgICAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHsgZnJvbTogZnJvbSwgdG86IGZyb20gKyB0cmVlLmxlbmd0aCB9KTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChtb3VudC5vdmVybGF5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IHNpemUgPSByZXN1bHQubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgICAgIGV4cGxvcmUobW91bnQudHJlZSwgbW91bnQub3ZlcmxheVswXS5mcm9tICsgZnJvbSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5sZW5ndGggPiBzaXplKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0cmVlLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgY2ggPSB0cmVlLmNoaWxkcmVuW2ldO1xyXG4gICAgICAgICAgICAgICAgaWYgKGNoIGluc3RhbmNlb2YgVHJlZSlcclxuICAgICAgICAgICAgICAgICAgICBleHBsb3JlKGNoLCB0cmVlLnBvc2l0aW9uc1tpXSArIGZyb20pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICBleHBsb3JlKHN5bnRheFRyZWUoc3RhdGUpLCAwKTtcclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICBJbmRpY2F0ZXMgd2hldGhlciB0aGlzIGxhbmd1YWdlIGFsbG93cyBuZXN0ZWQgbGFuZ3VhZ2VzLiBUaGVcclxuICAgIGRlZmF1bHQgaW1wbGVtZW50YXRpb24gcmV0dXJucyB0cnVlLlxyXG4gICAgKi9cclxuICAgIGdldCBhbGxvd3NOZXN0aW5nKCkgeyByZXR1cm4gdHJ1ZTsgfVxyXG59XHJcbi8qKlxyXG5AaW50ZXJuYWxcclxuKi9cclxuTGFuZ3VhZ2Uuc2V0U3RhdGUgPSAvKkBfX1BVUkVfXyovU3RhdGVFZmZlY3QuZGVmaW5lKCk7XHJcbmZ1bmN0aW9uIGxhbmd1YWdlRGF0YUZhY2V0QXQoc3RhdGUsIHBvcywgc2lkZSkge1xyXG4gICAgbGV0IHRvcExhbmcgPSBzdGF0ZS5mYWNldChsYW5ndWFnZSk7XHJcbiAgICBpZiAoIXRvcExhbmcpXHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICBsZXQgZmFjZXQgPSB0b3BMYW5nLmRhdGE7XHJcbiAgICBpZiAodG9wTGFuZy5hbGxvd3NOZXN0aW5nKSB7XHJcbiAgICAgICAgZm9yIChsZXQgbm9kZSA9IHN5bnRheFRyZWUoc3RhdGUpLnRvcE5vZGU7IG5vZGU7IG5vZGUgPSBub2RlLmVudGVyKHBvcywgc2lkZSwgSXRlck1vZGUuRXhjbHVkZUJ1ZmZlcnMpKVxyXG4gICAgICAgICAgICBmYWNldCA9IG5vZGUudHlwZS5wcm9wKGxhbmd1YWdlRGF0YVByb3ApIHx8IGZhY2V0O1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGZhY2V0O1xyXG59XHJcbi8qKlxyXG5BIHN1YmNsYXNzIG9mIFtgTGFuZ3VhZ2VgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2xhbmd1YWdlLkxhbmd1YWdlKSBmb3IgdXNlIHdpdGggTGV6ZXJcclxuW0xSIHBhcnNlcnNdKGh0dHBzOi8vbGV6ZXIuY29kZW1pcnJvci5uZXQvZG9jcy9yZWYjbHIuTFJQYXJzZXIpXHJcbnBhcnNlcnMuXHJcbiovXHJcbmNsYXNzIExSTGFuZ3VhZ2UgZXh0ZW5kcyBMYW5ndWFnZSB7XHJcbiAgICBjb25zdHJ1Y3RvcihkYXRhLCBwYXJzZXIsIG5hbWUpIHtcclxuICAgICAgICBzdXBlcihkYXRhLCBwYXJzZXIsIFtdLCBuYW1lKTtcclxuICAgICAgICB0aGlzLnBhcnNlciA9IHBhcnNlcjtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgRGVmaW5lIGEgbGFuZ3VhZ2UgZnJvbSBhIHBhcnNlci5cclxuICAgICovXHJcbiAgICBzdGF0aWMgZGVmaW5lKHNwZWMpIHtcclxuICAgICAgICBsZXQgZGF0YSA9IGRlZmluZUxhbmd1YWdlRmFjZXQoc3BlYy5sYW5ndWFnZURhdGEpO1xyXG4gICAgICAgIHJldHVybiBuZXcgTFJMYW5ndWFnZShkYXRhLCBzcGVjLnBhcnNlci5jb25maWd1cmUoe1xyXG4gICAgICAgICAgICBwcm9wczogW2xhbmd1YWdlRGF0YVByb3AuYWRkKHR5cGUgPT4gdHlwZS5pc1RvcCA/IGRhdGEgOiB1bmRlZmluZWQpXVxyXG4gICAgICAgIH0pLCBzcGVjLm5hbWUpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICBDcmVhdGUgYSBuZXcgaW5zdGFuY2Ugb2YgdGhpcyBsYW5ndWFnZSB3aXRoIGEgcmVjb25maWd1cmVkXHJcbiAgICB2ZXJzaW9uIG9mIGl0cyBwYXJzZXIgYW5kIG9wdGlvbmFsbHkgYSBuZXcgbmFtZS5cclxuICAgICovXHJcbiAgICBjb25maWd1cmUob3B0aW9ucywgbmFtZSkge1xyXG4gICAgICAgIHJldHVybiBuZXcgTFJMYW5ndWFnZSh0aGlzLmRhdGEsIHRoaXMucGFyc2VyLmNvbmZpZ3VyZShvcHRpb25zKSwgbmFtZSB8fCB0aGlzLm5hbWUpO1xyXG4gICAgfVxyXG4gICAgZ2V0IGFsbG93c05lc3RpbmcoKSB7IHJldHVybiB0aGlzLnBhcnNlci5oYXNXcmFwcGVycygpOyB9XHJcbn1cclxuLyoqXHJcbkdldCB0aGUgc3ludGF4IHRyZWUgZm9yIGEgc3RhdGUsIHdoaWNoIGlzIHRoZSBjdXJyZW50IChwb3NzaWJseVxyXG5pbmNvbXBsZXRlKSBwYXJzZSB0cmVlIG9mIHRoZSBhY3RpdmVcclxuW2xhbmd1YWdlXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2xhbmd1YWdlLkxhbmd1YWdlKSwgb3IgdGhlIGVtcHR5IHRyZWUgaWYgdGhlcmUgaXMgbm9cclxubGFuZ3VhZ2UgYXZhaWxhYmxlLlxyXG4qL1xyXG5mdW5jdGlvbiBzeW50YXhUcmVlKHN0YXRlKSB7XHJcbiAgICBsZXQgZmllbGQgPSBzdGF0ZS5maWVsZChMYW5ndWFnZS5zdGF0ZSwgZmFsc2UpO1xyXG4gICAgcmV0dXJuIGZpZWxkID8gZmllbGQudHJlZSA6IFRyZWUuZW1wdHk7XHJcbn1cclxuLyoqXHJcblRyeSB0byBnZXQgYSBwYXJzZSB0cmVlIHRoYXQgc3BhbnMgYXQgbGVhc3QgdXAgdG8gYHVwdG9gLiBUaGVcclxubWV0aG9kIHdpbGwgZG8gYXQgbW9zdCBgdGltZW91dGAgbWlsbGlzZWNvbmRzIG9mIHdvcmsgdG8gcGFyc2VcclxudXAgdG8gdGhhdCBwb2ludCBpZiB0aGUgdHJlZSBpc24ndCBhbHJlYWR5IGF2YWlsYWJsZS5cclxuKi9cclxuZnVuY3Rpb24gZW5zdXJlU3ludGF4VHJlZShzdGF0ZSwgdXB0bywgdGltZW91dCA9IDUwKSB7XHJcbiAgICB2YXIgX2E7XHJcbiAgICBsZXQgcGFyc2UgPSAoX2EgPSBzdGF0ZS5maWVsZChMYW5ndWFnZS5zdGF0ZSwgZmFsc2UpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY29udGV4dDtcclxuICAgIGlmICghcGFyc2UpXHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICBsZXQgb2xkVmllcG9ydCA9IHBhcnNlLnZpZXdwb3J0O1xyXG4gICAgcGFyc2UudXBkYXRlVmlld3BvcnQoeyBmcm9tOiAwLCB0bzogdXB0byB9KTtcclxuICAgIGxldCByZXN1bHQgPSBwYXJzZS5pc0RvbmUodXB0bykgfHwgcGFyc2Uud29yayh0aW1lb3V0LCB1cHRvKSA/IHBhcnNlLnRyZWUgOiBudWxsO1xyXG4gICAgcGFyc2UudXBkYXRlVmlld3BvcnQob2xkVmllcG9ydCk7XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59XHJcbi8qKlxyXG5RdWVyaWVzIHdoZXRoZXIgdGhlcmUgaXMgYSBmdWxsIHN5bnRheCB0cmVlIGF2YWlsYWJsZSB1cCB0byB0aGVcclxuZ2l2ZW4gZG9jdW1lbnQgcG9zaXRpb24uIElmIHRoZXJlIGlzbid0LCB0aGUgYmFja2dyb3VuZCBwYXJzZVxyXG5wcm9jZXNzIF9taWdodF8gc3RpbGwgYmUgd29ya2luZyBhbmQgdXBkYXRlIHRoZSB0cmVlIGZ1cnRoZXIsIGJ1dFxyXG50aGVyZSBpcyBubyBndWFyYW50ZWUgb2YgdGhhdOKAlHRoZSBwYXJzZXIgd2lsbCBbc3RvcFxyXG53b3JraW5nXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2xhbmd1YWdlLnN5bnRheFBhcnNlclJ1bm5pbmcpIHdoZW4gaXQgaGFzIHNwZW50IGFcclxuY2VydGFpbiBhbW91bnQgb2YgdGltZSBvciBoYXMgbW92ZWQgYmV5b25kIHRoZSB2aXNpYmxlIHZpZXdwb3J0LlxyXG5BbHdheXMgcmV0dXJucyBmYWxzZSBpZiBubyBsYW5ndWFnZSBoYXMgYmVlbiBlbmFibGVkLlxyXG4qL1xyXG5mdW5jdGlvbiBzeW50YXhUcmVlQXZhaWxhYmxlKHN0YXRlLCB1cHRvID0gc3RhdGUuZG9jLmxlbmd0aCkge1xyXG4gICAgdmFyIF9hO1xyXG4gICAgcmV0dXJuICgoX2EgPSBzdGF0ZS5maWVsZChMYW5ndWFnZS5zdGF0ZSwgZmFsc2UpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY29udGV4dC5pc0RvbmUodXB0bykpIHx8IGZhbHNlO1xyXG59XHJcbi8qKlxyXG5Nb3ZlIHBhcnNpbmcgZm9yd2FyZCwgYW5kIHVwZGF0ZSB0aGUgZWRpdG9yIHN0YXRlIGFmdGVyd2FyZHMgdG9cclxucmVmbGVjdCB0aGUgbmV3IHRyZWUuIFdpbGwgd29yayBmb3IgYXQgbW9zdCBgdGltZW91dGBcclxubWlsbGlzZWNvbmRzLiBSZXR1cm5zIHRydWUgaWYgdGhlIHBhcnNlciBtYW5hZ2VkIGdldCB0byB0aGUgZ2l2ZW5cclxucG9zaXRpb24gaW4gdGhhdCB0aW1lLlxyXG4qL1xyXG5mdW5jdGlvbiBmb3JjZVBhcnNpbmcodmlldywgdXB0byA9IHZpZXcudmlld3BvcnQudG8sIHRpbWVvdXQgPSAxMDApIHtcclxuICAgIGxldCBzdWNjZXNzID0gZW5zdXJlU3ludGF4VHJlZSh2aWV3LnN0YXRlLCB1cHRvLCB0aW1lb3V0KTtcclxuICAgIGlmIChzdWNjZXNzICE9IHN5bnRheFRyZWUodmlldy5zdGF0ZSkpXHJcbiAgICAgICAgdmlldy5kaXNwYXRjaCh7fSk7XHJcbiAgICByZXR1cm4gISFzdWNjZXNzO1xyXG59XHJcbi8qKlxyXG5UZWxscyB5b3Ugd2hldGhlciB0aGUgbGFuZ3VhZ2UgcGFyc2VyIGlzIHBsYW5uaW5nIHRvIGRvIG1vcmVcclxucGFyc2luZyB3b3JrIChpbiBhIGByZXF1ZXN0SWRsZUNhbGxiYWNrYCBwc2V1ZG8tdGhyZWFkKSBvciBoYXNcclxuc3RvcHBlZCBydW5uaW5nLCBlaXRoZXIgYmVjYXVzZSBpdCBwYXJzZWQgdGhlIGVudGlyZSBkb2N1bWVudCxcclxuYmVjYXVzZSBpdCBzcGVudCB0b28gbXVjaCB0aW1lIGFuZCB3YXMgY3V0IG9mZiwgb3IgYmVjYXVzZSB0aGVyZVxyXG5pcyBubyBsYW5ndWFnZSBwYXJzZXIgZW5hYmxlZC5cclxuKi9cclxuZnVuY3Rpb24gc3ludGF4UGFyc2VyUnVubmluZyh2aWV3KSB7XHJcbiAgICB2YXIgX2E7XHJcbiAgICByZXR1cm4gKChfYSA9IHZpZXcucGx1Z2luKHBhcnNlV29ya2VyKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmlzV29ya2luZygpKSB8fCBmYWxzZTtcclxufVxyXG4vLyBMZXplci1zdHlsZSBJbnB1dCBvYmplY3QgZm9yIGEgVGV4dCBkb2N1bWVudC5cclxuY2xhc3MgRG9jSW5wdXQge1xyXG4gICAgY29uc3RydWN0b3IoZG9jLCBsZW5ndGggPSBkb2MubGVuZ3RoKSB7XHJcbiAgICAgICAgdGhpcy5kb2MgPSBkb2M7XHJcbiAgICAgICAgdGhpcy5sZW5ndGggPSBsZW5ndGg7XHJcbiAgICAgICAgdGhpcy5jdXJzb3JQb3MgPSAwO1xyXG4gICAgICAgIHRoaXMuc3RyaW5nID0gXCJcIjtcclxuICAgICAgICB0aGlzLmN1cnNvciA9IGRvYy5pdGVyKCk7XHJcbiAgICB9XHJcbiAgICBzeW5jVG8ocG9zKSB7XHJcbiAgICAgICAgdGhpcy5zdHJpbmcgPSB0aGlzLmN1cnNvci5uZXh0KHBvcyAtIHRoaXMuY3Vyc29yUG9zKS52YWx1ZTtcclxuICAgICAgICB0aGlzLmN1cnNvclBvcyA9IHBvcyArIHRoaXMuc3RyaW5nLmxlbmd0aDtcclxuICAgICAgICByZXR1cm4gdGhpcy5jdXJzb3JQb3MgLSB0aGlzLnN0cmluZy5sZW5ndGg7XHJcbiAgICB9XHJcbiAgICBjaHVuayhwb3MpIHtcclxuICAgICAgICB0aGlzLnN5bmNUbyhwb3MpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLnN0cmluZztcclxuICAgIH1cclxuICAgIGdldCBsaW5lQ2h1bmtzKCkgeyByZXR1cm4gdHJ1ZTsgfVxyXG4gICAgcmVhZChmcm9tLCB0bykge1xyXG4gICAgICAgIGxldCBzdHJpbmdTdGFydCA9IHRoaXMuY3Vyc29yUG9zIC0gdGhpcy5zdHJpbmcubGVuZ3RoO1xyXG4gICAgICAgIGlmIChmcm9tIDwgc3RyaW5nU3RhcnQgfHwgdG8gPj0gdGhpcy5jdXJzb3JQb3MpXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRvYy5zbGljZVN0cmluZyhmcm9tLCB0byk7XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zdHJpbmcuc2xpY2UoZnJvbSAtIHN0cmluZ1N0YXJ0LCB0byAtIHN0cmluZ1N0YXJ0KTtcclxuICAgIH1cclxufVxyXG5sZXQgY3VycmVudENvbnRleHQgPSBudWxsO1xyXG4vKipcclxuQSBwYXJzZSBjb250ZXh0IHByb3ZpZGVkIHRvIHBhcnNlcnMgd29ya2luZyBvbiB0aGUgZWRpdG9yIGNvbnRlbnQuXHJcbiovXHJcbmNsYXNzIFBhcnNlQ29udGV4dCB7XHJcbiAgICBjb25zdHJ1Y3RvcihwYXJzZXIsIFxyXG4gICAgLyoqXHJcbiAgICBUaGUgY3VycmVudCBlZGl0b3Igc3RhdGUuXHJcbiAgICAqL1xyXG4gICAgc3RhdGUsIFxyXG4gICAgLyoqXHJcbiAgICBUcmVlIGZyYWdtZW50cyB0aGF0IGNhbiBiZSByZXVzZWQgYnkgaW5jcmVtZW50YWwgcmUtcGFyc2VzLlxyXG4gICAgKi9cclxuICAgIGZyYWdtZW50cyA9IFtdLCBcclxuICAgIC8qKlxyXG4gICAgQGludGVybmFsXHJcbiAgICAqL1xyXG4gICAgdHJlZSwgXHJcbiAgICAvKipcclxuICAgIEBpbnRlcm5hbFxyXG4gICAgKi9cclxuICAgIHRyZWVMZW4sIFxyXG4gICAgLyoqXHJcbiAgICBUaGUgY3VycmVudCBlZGl0b3Igdmlld3BvcnQgKG9yIHNvbWUgb3ZlcmFwcHJveGltYXRpb25cclxuICAgIHRoZXJlb2YpLiBJbnRlbmRlZCB0byBiZSB1c2VkIGZvciBvcHBvcnR1bmlzdGljYWxseSBhdm9pZGluZ1xyXG4gICAgd29yayAoaW4gd2hpY2ggY2FzZVxyXG4gICAgW2Bza2lwVW50aWxJblZpZXdgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2xhbmd1YWdlLlBhcnNlQ29udGV4dC5za2lwVW50aWxJblZpZXcpXHJcbiAgICBzaG91bGQgYmUgY2FsbGVkIHRvIG1ha2Ugc3VyZSB0aGUgcGFyc2VyIGlzIHJlc3RhcnRlZCB3aGVuIHRoZVxyXG4gICAgc2tpcHBlZCByZWdpb24gYmVjb21lcyB2aXNpYmxlKS5cclxuICAgICovXHJcbiAgICB2aWV3cG9ydCwgXHJcbiAgICAvKipcclxuICAgIEBpbnRlcm5hbFxyXG4gICAgKi9cclxuICAgIHNraXBwZWQsIFxyXG4gICAgLyoqXHJcbiAgICBUaGlzIGlzIHdoZXJlIHNraXBwaW5nIHBhcnNlcnMgY2FuIHJlZ2lzdGVyIGEgcHJvbWlzZSB0aGF0LFxyXG4gICAgd2hlbiByZXNvbHZlZCwgd2lsbCBzY2hlZHVsZSBhIG5ldyBwYXJzZS4gSXQgaXMgY2xlYXJlZCB3aGVuXHJcbiAgICB0aGUgcGFyc2Ugd29ya2VyIHBpY2tzIHVwIHRoZSBwcm9taXNlLiBAaW50ZXJuYWxcclxuICAgICovXHJcbiAgICBzY2hlZHVsZU9uKSB7XHJcbiAgICAgICAgdGhpcy5wYXJzZXIgPSBwYXJzZXI7XHJcbiAgICAgICAgdGhpcy5zdGF0ZSA9IHN0YXRlO1xyXG4gICAgICAgIHRoaXMuZnJhZ21lbnRzID0gZnJhZ21lbnRzO1xyXG4gICAgICAgIHRoaXMudHJlZSA9IHRyZWU7XHJcbiAgICAgICAgdGhpcy50cmVlTGVuID0gdHJlZUxlbjtcclxuICAgICAgICB0aGlzLnZpZXdwb3J0ID0gdmlld3BvcnQ7XHJcbiAgICAgICAgdGhpcy5za2lwcGVkID0gc2tpcHBlZDtcclxuICAgICAgICB0aGlzLnNjaGVkdWxlT24gPSBzY2hlZHVsZU9uO1xyXG4gICAgICAgIHRoaXMucGFyc2UgPSBudWxsO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgIEBpbnRlcm5hbFxyXG4gICAgICAgICovXHJcbiAgICAgICAgdGhpcy50ZW1wU2tpcHBlZCA9IFtdO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICBAaW50ZXJuYWxcclxuICAgICovXHJcbiAgICBzdGF0aWMgY3JlYXRlKHBhcnNlciwgc3RhdGUsIHZpZXdwb3J0KSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBQYXJzZUNvbnRleHQocGFyc2VyLCBzdGF0ZSwgW10sIFRyZWUuZW1wdHksIDAsIHZpZXdwb3J0LCBbXSwgbnVsbCk7XHJcbiAgICB9XHJcbiAgICBzdGFydFBhcnNlKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlci5zdGFydFBhcnNlKG5ldyBEb2NJbnB1dCh0aGlzLnN0YXRlLmRvYyksIHRoaXMuZnJhZ21lbnRzKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgQGludGVybmFsXHJcbiAgICAqL1xyXG4gICAgd29yayh1bnRpbCwgdXB0bykge1xyXG4gICAgICAgIGlmICh1cHRvICE9IG51bGwgJiYgdXB0byA+PSB0aGlzLnN0YXRlLmRvYy5sZW5ndGgpXHJcbiAgICAgICAgICAgIHVwdG8gPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgaWYgKHRoaXMudHJlZSAhPSBUcmVlLmVtcHR5ICYmIHRoaXMuaXNEb25lKHVwdG8gIT09IG51bGwgJiYgdXB0byAhPT0gdm9pZCAwID8gdXB0byA6IHRoaXMuc3RhdGUuZG9jLmxlbmd0aCkpIHtcclxuICAgICAgICAgICAgdGhpcy50YWtlVHJlZSgpO1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMud2l0aENvbnRleHQoKCkgPT4ge1xyXG4gICAgICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdW50aWwgPT0gXCJudW1iZXJcIikge1xyXG4gICAgICAgICAgICAgICAgbGV0IGVuZFRpbWUgPSBEYXRlLm5vdygpICsgdW50aWw7XHJcbiAgICAgICAgICAgICAgICB1bnRpbCA9ICgpID0+IERhdGUubm93KCkgPiBlbmRUaW1lO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5wYXJzZSlcclxuICAgICAgICAgICAgICAgIHRoaXMucGFyc2UgPSB0aGlzLnN0YXJ0UGFyc2UoKTtcclxuICAgICAgICAgICAgaWYgKHVwdG8gIT0gbnVsbCAmJiAodGhpcy5wYXJzZS5zdG9wcGVkQXQgPT0gbnVsbCB8fCB0aGlzLnBhcnNlLnN0b3BwZWRBdCA+IHVwdG8pICYmXHJcbiAgICAgICAgICAgICAgICB1cHRvIDwgdGhpcy5zdGF0ZS5kb2MubGVuZ3RoKVxyXG4gICAgICAgICAgICAgICAgdGhpcy5wYXJzZS5zdG9wQXQodXB0byk7XHJcbiAgICAgICAgICAgIGZvciAoOzspIHtcclxuICAgICAgICAgICAgICAgIGxldCBkb25lID0gdGhpcy5wYXJzZS5hZHZhbmNlKCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoZG9uZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZnJhZ21lbnRzID0gdGhpcy53aXRob3V0VGVtcFNraXBwZWQoVHJlZUZyYWdtZW50LmFkZFRyZWUoZG9uZSwgdGhpcy5mcmFnbWVudHMsIHRoaXMucGFyc2Uuc3RvcHBlZEF0ICE9IG51bGwpKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnRyZWVMZW4gPSAoX2EgPSB0aGlzLnBhcnNlLnN0b3BwZWRBdCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogdGhpcy5zdGF0ZS5kb2MubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudHJlZSA9IGRvbmU7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wYXJzZSA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMudHJlZUxlbiA8ICh1cHRvICE9PSBudWxsICYmIHVwdG8gIT09IHZvaWQgMCA/IHVwdG8gOiB0aGlzLnN0YXRlLmRvYy5sZW5ndGgpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBhcnNlID0gdGhpcy5zdGFydFBhcnNlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICh1bnRpbCgpKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICBAaW50ZXJuYWxcclxuICAgICovXHJcbiAgICB0YWtlVHJlZSgpIHtcclxuICAgICAgICBsZXQgcG9zLCB0cmVlO1xyXG4gICAgICAgIGlmICh0aGlzLnBhcnNlICYmIChwb3MgPSB0aGlzLnBhcnNlLnBhcnNlZFBvcykgPj0gdGhpcy50cmVlTGVuKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnBhcnNlLnN0b3BwZWRBdCA9PSBudWxsIHx8IHRoaXMucGFyc2Uuc3RvcHBlZEF0ID4gcG9zKVxyXG4gICAgICAgICAgICAgICAgdGhpcy5wYXJzZS5zdG9wQXQocG9zKTtcclxuICAgICAgICAgICAgdGhpcy53aXRoQ29udGV4dCgoKSA9PiB7IHdoaWxlICghKHRyZWUgPSB0aGlzLnBhcnNlLmFkdmFuY2UoKSkpIHsgfSB9KTtcclxuICAgICAgICAgICAgdGhpcy50cmVlTGVuID0gcG9zO1xyXG4gICAgICAgICAgICB0aGlzLnRyZWUgPSB0cmVlO1xyXG4gICAgICAgICAgICB0aGlzLmZyYWdtZW50cyA9IHRoaXMud2l0aG91dFRlbXBTa2lwcGVkKFRyZWVGcmFnbWVudC5hZGRUcmVlKHRoaXMudHJlZSwgdGhpcy5mcmFnbWVudHMsIHRydWUpKTtcclxuICAgICAgICAgICAgdGhpcy5wYXJzZSA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgd2l0aENvbnRleHQoZikge1xyXG4gICAgICAgIGxldCBwcmV2ID0gY3VycmVudENvbnRleHQ7XHJcbiAgICAgICAgY3VycmVudENvbnRleHQgPSB0aGlzO1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZpbmFsbHkge1xyXG4gICAgICAgICAgICBjdXJyZW50Q29udGV4dCA9IHByZXY7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgd2l0aG91dFRlbXBTa2lwcGVkKGZyYWdtZW50cykge1xyXG4gICAgICAgIGZvciAobGV0IHI7IHIgPSB0aGlzLnRlbXBTa2lwcGVkLnBvcCgpOylcclxuICAgICAgICAgICAgZnJhZ21lbnRzID0gY3V0RnJhZ21lbnRzKGZyYWdtZW50cywgci5mcm9tLCByLnRvKTtcclxuICAgICAgICByZXR1cm4gZnJhZ21lbnRzO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICBAaW50ZXJuYWxcclxuICAgICovXHJcbiAgICBjaGFuZ2VzKGNoYW5nZXMsIG5ld1N0YXRlKSB7XHJcbiAgICAgICAgbGV0IHsgZnJhZ21lbnRzLCB0cmVlLCB0cmVlTGVuLCB2aWV3cG9ydCwgc2tpcHBlZCB9ID0gdGhpcztcclxuICAgICAgICB0aGlzLnRha2VUcmVlKCk7XHJcbiAgICAgICAgaWYgKCFjaGFuZ2VzLmVtcHR5KSB7XHJcbiAgICAgICAgICAgIGxldCByYW5nZXMgPSBbXTtcclxuICAgICAgICAgICAgY2hhbmdlcy5pdGVyQ2hhbmdlZFJhbmdlcygoZnJvbUEsIHRvQSwgZnJvbUIsIHRvQikgPT4gcmFuZ2VzLnB1c2goeyBmcm9tQSwgdG9BLCBmcm9tQiwgdG9CIH0pKTtcclxuICAgICAgICAgICAgZnJhZ21lbnRzID0gVHJlZUZyYWdtZW50LmFwcGx5Q2hhbmdlcyhmcmFnbWVudHMsIHJhbmdlcyk7XHJcbiAgICAgICAgICAgIHRyZWUgPSBUcmVlLmVtcHR5O1xyXG4gICAgICAgICAgICB0cmVlTGVuID0gMDtcclxuICAgICAgICAgICAgdmlld3BvcnQgPSB7IGZyb206IGNoYW5nZXMubWFwUG9zKHZpZXdwb3J0LmZyb20sIC0xKSwgdG86IGNoYW5nZXMubWFwUG9zKHZpZXdwb3J0LnRvLCAxKSB9O1xyXG4gICAgICAgICAgICBpZiAodGhpcy5za2lwcGVkLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgc2tpcHBlZCA9IFtdO1xyXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgciBvZiB0aGlzLnNraXBwZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgZnJvbSA9IGNoYW5nZXMubWFwUG9zKHIuZnJvbSwgMSksIHRvID0gY2hhbmdlcy5tYXBQb3Moci50bywgLTEpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChmcm9tIDwgdG8pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNraXBwZWQucHVzaCh7IGZyb20sIHRvIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBuZXcgUGFyc2VDb250ZXh0KHRoaXMucGFyc2VyLCBuZXdTdGF0ZSwgZnJhZ21lbnRzLCB0cmVlLCB0cmVlTGVuLCB2aWV3cG9ydCwgc2tpcHBlZCwgdGhpcy5zY2hlZHVsZU9uKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgQGludGVybmFsXHJcbiAgICAqL1xyXG4gICAgdXBkYXRlVmlld3BvcnQodmlld3BvcnQpIHtcclxuICAgICAgICBpZiAodGhpcy52aWV3cG9ydC5mcm9tID09IHZpZXdwb3J0LmZyb20gJiYgdGhpcy52aWV3cG9ydC50byA9PSB2aWV3cG9ydC50bylcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIHRoaXMudmlld3BvcnQgPSB2aWV3cG9ydDtcclxuICAgICAgICBsZXQgc3RhcnRMZW4gPSB0aGlzLnNraXBwZWQubGVuZ3RoO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5za2lwcGVkLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGxldCB7IGZyb20sIHRvIH0gPSB0aGlzLnNraXBwZWRbaV07XHJcbiAgICAgICAgICAgIGlmIChmcm9tIDwgdmlld3BvcnQudG8gJiYgdG8gPiB2aWV3cG9ydC5mcm9tKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmZyYWdtZW50cyA9IGN1dEZyYWdtZW50cyh0aGlzLmZyYWdtZW50cywgZnJvbSwgdG8pO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5za2lwcGVkLnNwbGljZShpLS0sIDEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLnNraXBwZWQubGVuZ3RoID49IHN0YXJ0TGVuKVxyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5yZXNldCgpO1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICBAaW50ZXJuYWxcclxuICAgICovXHJcbiAgICByZXNldCgpIHtcclxuICAgICAgICBpZiAodGhpcy5wYXJzZSkge1xyXG4gICAgICAgICAgICB0aGlzLnRha2VUcmVlKCk7XHJcbiAgICAgICAgICAgIHRoaXMucGFyc2UgPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgTm90aWZ5IHRoZSBwYXJzZSBzY2hlZHVsZXIgdGhhdCB0aGUgZ2l2ZW4gcmVnaW9uIHdhcyBza2lwcGVkXHJcbiAgICBiZWNhdXNlIGl0IHdhc24ndCBpbiB2aWV3LCBhbmQgdGhlIHBhcnNlIHNob3VsZCBiZSByZXN0YXJ0ZWRcclxuICAgIHdoZW4gaXQgY29tZXMgaW50byB2aWV3LlxyXG4gICAgKi9cclxuICAgIHNraXBVbnRpbEluVmlldyhmcm9tLCB0bykge1xyXG4gICAgICAgIHRoaXMuc2tpcHBlZC5wdXNoKHsgZnJvbSwgdG8gfSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgIFJldHVybnMgYSBwYXJzZXIgaW50ZW5kZWQgdG8gYmUgdXNlZCBhcyBwbGFjZWhvbGRlciB3aGVuXHJcbiAgICBhc3luY2hyb25vdXNseSBsb2FkaW5nIGEgbmVzdGVkIHBhcnNlci4gSXQnbGwgc2tpcCBpdHMgaW5wdXQgYW5kXHJcbiAgICBtYXJrIGl0IGFzIG5vdC1yZWFsbHktcGFyc2VkLCBzbyB0aGF0IHRoZSBuZXh0IHVwZGF0ZSB3aWxsIHBhcnNlXHJcbiAgICBpdCBhZ2Fpbi5cclxuICAgIFxyXG4gICAgV2hlbiBgdW50aWxgIGlzIGdpdmVuLCBhIHJlcGFyc2Ugd2lsbCBiZSBzY2hlZHVsZWQgd2hlbiB0aGF0XHJcbiAgICBwcm9taXNlIHJlc29sdmVzLlxyXG4gICAgKi9cclxuICAgIHN0YXRpYyBnZXRTa2lwcGluZ1BhcnNlcih1bnRpbCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgY2xhc3MgZXh0ZW5kcyBQYXJzZXIge1xyXG4gICAgICAgICAgICBjcmVhdGVQYXJzZShpbnB1dCwgZnJhZ21lbnRzLCByYW5nZXMpIHtcclxuICAgICAgICAgICAgICAgIGxldCBmcm9tID0gcmFuZ2VzWzBdLmZyb20sIHRvID0gcmFuZ2VzW3Jhbmdlcy5sZW5ndGggLSAxXS50bztcclxuICAgICAgICAgICAgICAgIGxldCBwYXJzZXIgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VkUG9zOiBmcm9tLFxyXG4gICAgICAgICAgICAgICAgICAgIGFkdmFuY2UoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBjeCA9IGN1cnJlbnRDb250ZXh0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY3gpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IHIgb2YgcmFuZ2VzKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN4LnRlbXBTa2lwcGVkLnB1c2gocik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodW50aWwpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3guc2NoZWR1bGVPbiA9IGN4LnNjaGVkdWxlT24gPyBQcm9taXNlLmFsbChbY3guc2NoZWR1bGVPbiwgdW50aWxdKSA6IHVudGlsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucGFyc2VkUG9zID0gdG87XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgVHJlZShOb2RlVHlwZS5ub25lLCBbXSwgW10sIHRvIC0gZnJvbSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICBzdG9wcGVkQXQ6IG51bGwsXHJcbiAgICAgICAgICAgICAgICAgICAgc3RvcEF0KCkgeyB9XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlcjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgIEBpbnRlcm5hbFxyXG4gICAgKi9cclxuICAgIGlzRG9uZSh1cHRvKSB7XHJcbiAgICAgICAgdXB0byA9IE1hdGgubWluKHVwdG8sIHRoaXMuc3RhdGUuZG9jLmxlbmd0aCk7XHJcbiAgICAgICAgbGV0IGZyYWdzID0gdGhpcy5mcmFnbWVudHM7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudHJlZUxlbiA+PSB1cHRvICYmIGZyYWdzLmxlbmd0aCAmJiBmcmFnc1swXS5mcm9tID09IDAgJiYgZnJhZ3NbMF0udG8gPj0gdXB0bztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgR2V0IHRoZSBjb250ZXh0IGZvciB0aGUgY3VycmVudCBwYXJzZSwgb3IgYG51bGxgIGlmIG5vIGVkaXRvclxyXG4gICAgcGFyc2UgaXMgaW4gcHJvZ3Jlc3MuXHJcbiAgICAqL1xyXG4gICAgc3RhdGljIGdldCgpIHsgcmV0dXJuIGN1cnJlbnRDb250ZXh0OyB9XHJcbn1cclxuZnVuY3Rpb24gY3V0RnJhZ21lbnRzKGZyYWdtZW50cywgZnJvbSwgdG8pIHtcclxuICAgIHJldHVybiBUcmVlRnJhZ21lbnQuYXBwbHlDaGFuZ2VzKGZyYWdtZW50cywgW3sgZnJvbUE6IGZyb20sIHRvQTogdG8sIGZyb21COiBmcm9tLCB0b0I6IHRvIH1dKTtcclxufVxyXG5jbGFzcyBMYW5ndWFnZVN0YXRlIHtcclxuICAgIGNvbnN0cnVjdG9yKFxyXG4gICAgLy8gQSBtdXRhYmxlIHBhcnNlIHN0YXRlIHRoYXQgaXMgdXNlZCB0byBwcmVzZXJ2ZSB3b3JrIGRvbmUgZHVyaW5nXHJcbiAgICAvLyB0aGUgbGlmZXRpbWUgb2YgYSBzdGF0ZSB3aGVuIG1vdmluZyB0byB0aGUgbmV4dCBzdGF0ZS5cclxuICAgIGNvbnRleHQpIHtcclxuICAgICAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xyXG4gICAgICAgIHRoaXMudHJlZSA9IGNvbnRleHQudHJlZTtcclxuICAgIH1cclxuICAgIGFwcGx5KHRyKSB7XHJcbiAgICAgICAgaWYgKCF0ci5kb2NDaGFuZ2VkICYmIHRoaXMudHJlZSA9PSB0aGlzLmNvbnRleHQudHJlZSlcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgbGV0IG5ld0N4ID0gdGhpcy5jb250ZXh0LmNoYW5nZXModHIuY2hhbmdlcywgdHIuc3RhdGUpO1xyXG4gICAgICAgIC8vIElmIHRoZSBwcmV2aW91cyBwYXJzZSB3YXNuJ3QgZG9uZSwgZ28gZm9yd2FyZCBvbmx5IHVwIHRvIGl0c1xyXG4gICAgICAgIC8vIGVuZCBwb3NpdGlvbiBvciB0aGUgZW5kIG9mIHRoZSB2aWV3cG9ydCwgdG8gYXZvaWQgc2xvd2luZyBkb3duXHJcbiAgICAgICAgLy8gc3RhdGUgdXBkYXRlcyB3aXRoIHBhcnNlIHdvcmsgYmV5b25kIHRoZSB2aWV3cG9ydC5cclxuICAgICAgICBsZXQgdXB0byA9IHRoaXMuY29udGV4dC50cmVlTGVuID09IHRyLnN0YXJ0U3RhdGUuZG9jLmxlbmd0aCA/IHVuZGVmaW5lZFxyXG4gICAgICAgICAgICA6IE1hdGgubWF4KHRyLmNoYW5nZXMubWFwUG9zKHRoaXMuY29udGV4dC50cmVlTGVuKSwgbmV3Q3gudmlld3BvcnQudG8pO1xyXG4gICAgICAgIGlmICghbmV3Q3gud29yaygyMCAvKiBXb3JrLkFwcGx5ICovLCB1cHRvKSlcclxuICAgICAgICAgICAgbmV3Q3gudGFrZVRyZWUoKTtcclxuICAgICAgICByZXR1cm4gbmV3IExhbmd1YWdlU3RhdGUobmV3Q3gpO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGluaXQoc3RhdGUpIHtcclxuICAgICAgICBsZXQgdnBUbyA9IE1hdGgubWluKDMwMDAgLyogV29yay5Jbml0Vmlld3BvcnQgKi8sIHN0YXRlLmRvYy5sZW5ndGgpO1xyXG4gICAgICAgIGxldCBwYXJzZVN0YXRlID0gUGFyc2VDb250ZXh0LmNyZWF0ZShzdGF0ZS5mYWNldChsYW5ndWFnZSkucGFyc2VyLCBzdGF0ZSwgeyBmcm9tOiAwLCB0bzogdnBUbyB9KTtcclxuICAgICAgICBpZiAoIXBhcnNlU3RhdGUud29yaygyMCAvKiBXb3JrLkFwcGx5ICovLCB2cFRvKSlcclxuICAgICAgICAgICAgcGFyc2VTdGF0ZS50YWtlVHJlZSgpO1xyXG4gICAgICAgIHJldHVybiBuZXcgTGFuZ3VhZ2VTdGF0ZShwYXJzZVN0YXRlKTtcclxuICAgIH1cclxufVxyXG5MYW5ndWFnZS5zdGF0ZSA9IC8qQF9fUFVSRV9fKi9TdGF0ZUZpZWxkLmRlZmluZSh7XHJcbiAgICBjcmVhdGU6IExhbmd1YWdlU3RhdGUuaW5pdCxcclxuICAgIHVwZGF0ZSh2YWx1ZSwgdHIpIHtcclxuICAgICAgICBmb3IgKGxldCBlIG9mIHRyLmVmZmVjdHMpXHJcbiAgICAgICAgICAgIGlmIChlLmlzKExhbmd1YWdlLnNldFN0YXRlKSlcclxuICAgICAgICAgICAgICAgIHJldHVybiBlLnZhbHVlO1xyXG4gICAgICAgIGlmICh0ci5zdGFydFN0YXRlLmZhY2V0KGxhbmd1YWdlKSAhPSB0ci5zdGF0ZS5mYWNldChsYW5ndWFnZSkpXHJcbiAgICAgICAgICAgIHJldHVybiBMYW5ndWFnZVN0YXRlLmluaXQodHIuc3RhdGUpO1xyXG4gICAgICAgIHJldHVybiB2YWx1ZS5hcHBseSh0cik7XHJcbiAgICB9XHJcbn0pO1xyXG5sZXQgcmVxdWVzdElkbGUgPSAoY2FsbGJhY2spID0+IHtcclxuICAgIGxldCB0aW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiBjYWxsYmFjaygpLCA1MDAgLyogV29yay5NYXhQYXVzZSAqLyk7XHJcbiAgICByZXR1cm4gKCkgPT4gY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xyXG59O1xyXG5pZiAodHlwZW9mIHJlcXVlc3RJZGxlQ2FsbGJhY2sgIT0gXCJ1bmRlZmluZWRcIilcclxuICAgIHJlcXVlc3RJZGxlID0gKGNhbGxiYWNrKSA9PiB7XHJcbiAgICAgICAgbGV0IGlkbGUgPSAtMSwgdGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICAgICAgICBpZGxlID0gcmVxdWVzdElkbGVDYWxsYmFjayhjYWxsYmFjaywgeyB0aW1lb3V0OiA1MDAgLyogV29yay5NYXhQYXVzZSAqLyAtIDEwMCAvKiBXb3JrLk1pblBhdXNlICovIH0pO1xyXG4gICAgICAgIH0sIDEwMCAvKiBXb3JrLk1pblBhdXNlICovKTtcclxuICAgICAgICByZXR1cm4gKCkgPT4gaWRsZSA8IDAgPyBjbGVhclRpbWVvdXQodGltZW91dCkgOiBjYW5jZWxJZGxlQ2FsbGJhY2soaWRsZSk7XHJcbiAgICB9O1xyXG5jb25zdCBpc0lucHV0UGVuZGluZyA9IHR5cGVvZiBuYXZpZ2F0b3IgIT0gXCJ1bmRlZmluZWRcIiAmJiAoKF9hID0gbmF2aWdhdG9yLnNjaGVkdWxpbmcpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5pc0lucHV0UGVuZGluZylcclxuICAgID8gKCkgPT4gbmF2aWdhdG9yLnNjaGVkdWxpbmcuaXNJbnB1dFBlbmRpbmcoKSA6IG51bGw7XHJcbmNvbnN0IHBhcnNlV29ya2VyID0gLypAX19QVVJFX18qL1ZpZXdQbHVnaW4uZnJvbUNsYXNzKGNsYXNzIFBhcnNlV29ya2VyIHtcclxuICAgIGNvbnN0cnVjdG9yKHZpZXcpIHtcclxuICAgICAgICB0aGlzLnZpZXcgPSB2aWV3O1xyXG4gICAgICAgIHRoaXMud29ya2luZyA9IG51bGw7XHJcbiAgICAgICAgdGhpcy53b3JrU2NoZWR1bGVkID0gMDtcclxuICAgICAgICAvLyBFbmQgb2YgdGhlIGN1cnJlbnQgdGltZSBjaHVua1xyXG4gICAgICAgIHRoaXMuY2h1bmtFbmQgPSAtMTtcclxuICAgICAgICAvLyBNaWxsaXNlY29uZHMgb2YgYnVkZ2V0IGxlZnQgZm9yIHRoaXMgY2h1bmtcclxuICAgICAgICB0aGlzLmNodW5rQnVkZ2V0ID0gLTE7XHJcbiAgICAgICAgdGhpcy53b3JrID0gdGhpcy53b3JrLmJpbmQodGhpcyk7XHJcbiAgICAgICAgdGhpcy5zY2hlZHVsZVdvcmsoKTtcclxuICAgIH1cclxuICAgIHVwZGF0ZSh1cGRhdGUpIHtcclxuICAgICAgICBsZXQgY3ggPSB0aGlzLnZpZXcuc3RhdGUuZmllbGQoTGFuZ3VhZ2Uuc3RhdGUpLmNvbnRleHQ7XHJcbiAgICAgICAgaWYgKGN4LnVwZGF0ZVZpZXdwb3J0KHVwZGF0ZS52aWV3LnZpZXdwb3J0KSB8fCB0aGlzLnZpZXcudmlld3BvcnQudG8gPiBjeC50cmVlTGVuKVxyXG4gICAgICAgICAgICB0aGlzLnNjaGVkdWxlV29yaygpO1xyXG4gICAgICAgIGlmICh1cGRhdGUuZG9jQ2hhbmdlZCkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy52aWV3Lmhhc0ZvY3VzKVxyXG4gICAgICAgICAgICAgICAgdGhpcy5jaHVua0J1ZGdldCArPSA1MCAvKiBXb3JrLkNoYW5nZUJvbnVzICovO1xyXG4gICAgICAgICAgICB0aGlzLnNjaGVkdWxlV29yaygpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmNoZWNrQXN5bmNTY2hlZHVsZShjeCk7XHJcbiAgICB9XHJcbiAgICBzY2hlZHVsZVdvcmsoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMud29ya2luZylcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIGxldCB7IHN0YXRlIH0gPSB0aGlzLnZpZXcsIGZpZWxkID0gc3RhdGUuZmllbGQoTGFuZ3VhZ2Uuc3RhdGUpO1xyXG4gICAgICAgIGlmIChmaWVsZC50cmVlICE9IGZpZWxkLmNvbnRleHQudHJlZSB8fCAhZmllbGQuY29udGV4dC5pc0RvbmUoc3RhdGUuZG9jLmxlbmd0aCkpXHJcbiAgICAgICAgICAgIHRoaXMud29ya2luZyA9IHJlcXVlc3RJZGxlKHRoaXMud29yayk7XHJcbiAgICB9XHJcbiAgICB3b3JrKGRlYWRsaW5lKSB7XHJcbiAgICAgICAgdGhpcy53b3JraW5nID0gbnVsbDtcclxuICAgICAgICBsZXQgbm93ID0gRGF0ZS5ub3coKTtcclxuICAgICAgICBpZiAodGhpcy5jaHVua0VuZCA8IG5vdyAmJiAodGhpcy5jaHVua0VuZCA8IDAgfHwgdGhpcy52aWV3Lmhhc0ZvY3VzKSkgeyAvLyBTdGFydCBhIG5ldyBjaHVua1xyXG4gICAgICAgICAgICB0aGlzLmNodW5rRW5kID0gbm93ICsgMzAwMDAgLyogV29yay5DaHVua1RpbWUgKi87XHJcbiAgICAgICAgICAgIHRoaXMuY2h1bmtCdWRnZXQgPSAzMDAwIC8qIFdvcmsuQ2h1bmtCdWRnZXQgKi87XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLmNodW5rQnVkZ2V0IDw9IDApXHJcbiAgICAgICAgICAgIHJldHVybjsgLy8gTm8gbW9yZSBidWRnZXRcclxuICAgICAgICBsZXQgeyBzdGF0ZSwgdmlld3BvcnQ6IHsgdG86IHZwVG8gfSB9ID0gdGhpcy52aWV3LCBmaWVsZCA9IHN0YXRlLmZpZWxkKExhbmd1YWdlLnN0YXRlKTtcclxuICAgICAgICBpZiAoZmllbGQudHJlZSA9PSBmaWVsZC5jb250ZXh0LnRyZWUgJiYgZmllbGQuY29udGV4dC5pc0RvbmUodnBUbyArIDEwMDAwMCAvKiBXb3JrLk1heFBhcnNlQWhlYWQgKi8pKVxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgbGV0IGVuZFRpbWUgPSBEYXRlLm5vdygpICsgTWF0aC5taW4odGhpcy5jaHVua0J1ZGdldCwgMTAwIC8qIFdvcmsuU2xpY2UgKi8sIGRlYWRsaW5lICYmICFpc0lucHV0UGVuZGluZyA/IE1hdGgubWF4KDI1IC8qIFdvcmsuTWluU2xpY2UgKi8sIGRlYWRsaW5lLnRpbWVSZW1haW5pbmcoKSAtIDUpIDogMWU5KTtcclxuICAgICAgICBsZXQgdmlld3BvcnRGaXJzdCA9IGZpZWxkLmNvbnRleHQudHJlZUxlbiA8IHZwVG8gJiYgc3RhdGUuZG9jLmxlbmd0aCA+IHZwVG8gKyAxMDAwO1xyXG4gICAgICAgIGxldCBkb25lID0gZmllbGQuY29udGV4dC53b3JrKCgpID0+IHtcclxuICAgICAgICAgICAgcmV0dXJuIGlzSW5wdXRQZW5kaW5nICYmIGlzSW5wdXRQZW5kaW5nKCkgfHwgRGF0ZS5ub3coKSA+IGVuZFRpbWU7XHJcbiAgICAgICAgfSwgdnBUbyArICh2aWV3cG9ydEZpcnN0ID8gMCA6IDEwMDAwMCAvKiBXb3JrLk1heFBhcnNlQWhlYWQgKi8pKTtcclxuICAgICAgICB0aGlzLmNodW5rQnVkZ2V0IC09IERhdGUubm93KCkgLSBub3c7XHJcbiAgICAgICAgaWYgKGRvbmUgfHwgdGhpcy5jaHVua0J1ZGdldCA8PSAwKSB7XHJcbiAgICAgICAgICAgIGZpZWxkLmNvbnRleHQudGFrZVRyZWUoKTtcclxuICAgICAgICAgICAgdGhpcy52aWV3LmRpc3BhdGNoKHsgZWZmZWN0czogTGFuZ3VhZ2Uuc2V0U3RhdGUub2YobmV3IExhbmd1YWdlU3RhdGUoZmllbGQuY29udGV4dCkpIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5jaHVua0J1ZGdldCA+IDAgJiYgIShkb25lICYmICF2aWV3cG9ydEZpcnN0KSlcclxuICAgICAgICAgICAgdGhpcy5zY2hlZHVsZVdvcmsoKTtcclxuICAgICAgICB0aGlzLmNoZWNrQXN5bmNTY2hlZHVsZShmaWVsZC5jb250ZXh0KTtcclxuICAgIH1cclxuICAgIGNoZWNrQXN5bmNTY2hlZHVsZShjeCkge1xyXG4gICAgICAgIGlmIChjeC5zY2hlZHVsZU9uKSB7XHJcbiAgICAgICAgICAgIHRoaXMud29ya1NjaGVkdWxlZCsrO1xyXG4gICAgICAgICAgICBjeC5zY2hlZHVsZU9uXHJcbiAgICAgICAgICAgICAgICAudGhlbigoKSA9PiB0aGlzLnNjaGVkdWxlV29yaygpKVxyXG4gICAgICAgICAgICAgICAgLmNhdGNoKGVyciA9PiBsb2dFeGNlcHRpb24odGhpcy52aWV3LnN0YXRlLCBlcnIpKVxyXG4gICAgICAgICAgICAgICAgLnRoZW4oKCkgPT4gdGhpcy53b3JrU2NoZWR1bGVkLS0pO1xyXG4gICAgICAgICAgICBjeC5zY2hlZHVsZU9uID0gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBkZXN0cm95KCkge1xyXG4gICAgICAgIGlmICh0aGlzLndvcmtpbmcpXHJcbiAgICAgICAgICAgIHRoaXMud29ya2luZygpO1xyXG4gICAgfVxyXG4gICAgaXNXb3JraW5nKCkge1xyXG4gICAgICAgIHJldHVybiAhISh0aGlzLndvcmtpbmcgfHwgdGhpcy53b3JrU2NoZWR1bGVkID4gMCk7XHJcbiAgICB9XHJcbn0sIHtcclxuICAgIGV2ZW50SGFuZGxlcnM6IHsgZm9jdXMoKSB7IHRoaXMuc2NoZWR1bGVXb3JrKCk7IH0gfVxyXG59KTtcclxuLyoqXHJcblRoZSBmYWNldCB1c2VkIHRvIGFzc29jaWF0ZSBhIGxhbmd1YWdlIHdpdGggYW4gZWRpdG9yIHN0YXRlLiBVc2VkXHJcbmJ5IGBMYW5ndWFnZWAgb2JqZWN0J3MgYGV4dGVuc2lvbmAgcHJvcGVydHkgKHNvIHlvdSBkb24ndCBuZWVkIHRvXHJcbm1hbnVhbGx5IHdyYXAgeW91ciBsYW5ndWFnZXMgaW4gdGhpcykuIENhbiBiZSB1c2VkIHRvIGFjY2VzcyB0aGVcclxuY3VycmVudCBsYW5ndWFnZSBvbiBhIHN0YXRlLlxyXG4qL1xyXG5jb25zdCBsYW5ndWFnZSA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoe1xyXG4gICAgY29tYmluZShsYW5ndWFnZXMpIHsgcmV0dXJuIGxhbmd1YWdlcy5sZW5ndGggPyBsYW5ndWFnZXNbMF0gOiBudWxsOyB9LFxyXG4gICAgZW5hYmxlczogbGFuZ3VhZ2UgPT4gW1xyXG4gICAgICAgIExhbmd1YWdlLnN0YXRlLFxyXG4gICAgICAgIHBhcnNlV29ya2VyLFxyXG4gICAgICAgIEVkaXRvclZpZXcuY29udGVudEF0dHJpYnV0ZXMuY29tcHV0ZShbbGFuZ3VhZ2VdLCBzdGF0ZSA9PiB7XHJcbiAgICAgICAgICAgIGxldCBsYW5nID0gc3RhdGUuZmFjZXQobGFuZ3VhZ2UpO1xyXG4gICAgICAgICAgICByZXR1cm4gbGFuZyAmJiBsYW5nLm5hbWUgPyB7IFwiZGF0YS1sYW5ndWFnZVwiOiBsYW5nLm5hbWUgfSA6IHt9O1xyXG4gICAgICAgIH0pXHJcbiAgICBdXHJcbn0pO1xyXG4vKipcclxuVGhpcyBjbGFzcyBidW5kbGVzIGEgW2xhbmd1YWdlXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2xhbmd1YWdlLkxhbmd1YWdlKSB3aXRoIGFuXHJcbm9wdGlvbmFsIHNldCBvZiBzdXBwb3J0aW5nIGV4dGVuc2lvbnMuIExhbmd1YWdlIHBhY2thZ2VzIGFyZVxyXG5lbmNvdXJhZ2VkIHRvIGV4cG9ydCBhIGZ1bmN0aW9uIHRoYXQgb3B0aW9uYWxseSB0YWtlcyBhXHJcbmNvbmZpZ3VyYXRpb24gb2JqZWN0IGFuZCByZXR1cm5zIGEgYExhbmd1YWdlU3VwcG9ydGAgaW5zdGFuY2UsIGFzXHJcbnRoZSBtYWluIHdheSBmb3IgY2xpZW50IGNvZGUgdG8gdXNlIHRoZSBwYWNrYWdlLlxyXG4qL1xyXG5jbGFzcyBMYW5ndWFnZVN1cHBvcnQge1xyXG4gICAgLyoqXHJcbiAgICBDcmVhdGUgYSBsYW5ndWFnZSBzdXBwb3J0IG9iamVjdC5cclxuICAgICovXHJcbiAgICBjb25zdHJ1Y3RvcihcclxuICAgIC8qKlxyXG4gICAgVGhlIGxhbmd1YWdlIG9iamVjdC5cclxuICAgICovXHJcbiAgICBsYW5ndWFnZSwgXHJcbiAgICAvKipcclxuICAgIEFuIG9wdGlvbmFsIHNldCBvZiBzdXBwb3J0aW5nIGV4dGVuc2lvbnMuIFdoZW4gbmVzdGluZyBhXHJcbiAgICBsYW5ndWFnZSBpbiBhbm90aGVyIGxhbmd1YWdlLCB0aGUgb3V0ZXIgbGFuZ3VhZ2UgaXMgZW5jb3VyYWdlZFxyXG4gICAgdG8gaW5jbHVkZSB0aGUgc3VwcG9ydGluZyBleHRlbnNpb25zIGZvciBpdHMgaW5uZXIgbGFuZ3VhZ2VzXHJcbiAgICBpbiBpdHMgb3duIHNldCBvZiBzdXBwb3J0IGV4dGVuc2lvbnMuXHJcbiAgICAqL1xyXG4gICAgc3VwcG9ydCA9IFtdKSB7XHJcbiAgICAgICAgdGhpcy5sYW5ndWFnZSA9IGxhbmd1YWdlO1xyXG4gICAgICAgIHRoaXMuc3VwcG9ydCA9IHN1cHBvcnQ7XHJcbiAgICAgICAgdGhpcy5leHRlbnNpb24gPSBbbGFuZ3VhZ2UsIHN1cHBvcnRdO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG5MYW5ndWFnZSBkZXNjcmlwdGlvbnMgYXJlIHVzZWQgdG8gc3RvcmUgbWV0YWRhdGEgYWJvdXQgbGFuZ3VhZ2VzXHJcbmFuZCB0byBkeW5hbWljYWxseSBsb2FkIHRoZW0uIFRoZWlyIG1haW4gcm9sZSBpcyBmaW5kaW5nIHRoZVxyXG5hcHByb3ByaWF0ZSBsYW5ndWFnZSBmb3IgYSBmaWxlbmFtZSBvciBkeW5hbWljYWxseSBsb2FkaW5nIG5lc3RlZFxyXG5wYXJzZXJzLlxyXG4qL1xyXG5jbGFzcyBMYW5ndWFnZURlc2NyaXB0aW9uIHtcclxuICAgIGNvbnN0cnVjdG9yKFxyXG4gICAgLyoqXHJcbiAgICBUaGUgbmFtZSBvZiB0aGlzIGxhbmd1YWdlLlxyXG4gICAgKi9cclxuICAgIG5hbWUsIFxyXG4gICAgLyoqXHJcbiAgICBBbHRlcm5hdGl2ZSBuYW1lcyBmb3IgdGhlIG1vZGUgKGxvd2VyY2FzZWQsIGluY2x1ZGVzIGB0aGlzLm5hbWVgKS5cclxuICAgICovXHJcbiAgICBhbGlhcywgXHJcbiAgICAvKipcclxuICAgIEZpbGUgZXh0ZW5zaW9ucyBhc3NvY2lhdGVkIHdpdGggdGhpcyBsYW5ndWFnZS5cclxuICAgICovXHJcbiAgICBleHRlbnNpb25zLCBcclxuICAgIC8qKlxyXG4gICAgT3B0aW9uYWwgZmlsZW5hbWUgcGF0dGVybiB0aGF0IHNob3VsZCBiZSBhc3NvY2lhdGVkIHdpdGggdGhpc1xyXG4gICAgbGFuZ3VhZ2UuXHJcbiAgICAqL1xyXG4gICAgZmlsZW5hbWUsIGxvYWRGdW5jLCBcclxuICAgIC8qKlxyXG4gICAgSWYgdGhlIGxhbmd1YWdlIGhhcyBiZWVuIGxvYWRlZCwgdGhpcyB3aWxsIGhvbGQgaXRzIHZhbHVlLlxyXG4gICAgKi9cclxuICAgIHN1cHBvcnQgPSB1bmRlZmluZWQpIHtcclxuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xyXG4gICAgICAgIHRoaXMuYWxpYXMgPSBhbGlhcztcclxuICAgICAgICB0aGlzLmV4dGVuc2lvbnMgPSBleHRlbnNpb25zO1xyXG4gICAgICAgIHRoaXMuZmlsZW5hbWUgPSBmaWxlbmFtZTtcclxuICAgICAgICB0aGlzLmxvYWRGdW5jID0gbG9hZEZ1bmM7XHJcbiAgICAgICAgdGhpcy5zdXBwb3J0ID0gc3VwcG9ydDtcclxuICAgICAgICB0aGlzLmxvYWRpbmcgPSBudWxsO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICBTdGFydCBsb2FkaW5nIHRoZSB0aGUgbGFuZ3VhZ2UuIFdpbGwgcmV0dXJuIGEgcHJvbWlzZSB0aGF0XHJcbiAgICByZXNvbHZlcyB0byBhIFtgTGFuZ3VhZ2VTdXBwb3J0YF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNsYW5ndWFnZS5MYW5ndWFnZVN1cHBvcnQpXHJcbiAgICBvYmplY3Qgd2hlbiB0aGUgbGFuZ3VhZ2Ugc3VjY2Vzc2Z1bGx5IGxvYWRzLlxyXG4gICAgKi9cclxuICAgIGxvYWQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubG9hZGluZyB8fCAodGhpcy5sb2FkaW5nID0gdGhpcy5sb2FkRnVuYygpLnRoZW4oc3VwcG9ydCA9PiB0aGlzLnN1cHBvcnQgPSBzdXBwb3J0LCBlcnIgPT4geyB0aGlzLmxvYWRpbmcgPSBudWxsOyB0aHJvdyBlcnI7IH0pKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgQ3JlYXRlIGEgbGFuZ3VhZ2UgZGVzY3JpcHRpb24uXHJcbiAgICAqL1xyXG4gICAgc3RhdGljIG9mKHNwZWMpIHtcclxuICAgICAgICBsZXQgeyBsb2FkLCBzdXBwb3J0IH0gPSBzcGVjO1xyXG4gICAgICAgIGlmICghbG9hZCkge1xyXG4gICAgICAgICAgICBpZiAoIXN1cHBvcnQpXHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIk11c3QgcGFzcyBlaXRoZXIgJ2xvYWQnIG9yICdzdXBwb3J0JyB0byBMYW5ndWFnZURlc2NyaXB0aW9uLm9mXCIpO1xyXG4gICAgICAgICAgICBsb2FkID0gKCkgPT4gUHJvbWlzZS5yZXNvbHZlKHN1cHBvcnQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbmV3IExhbmd1YWdlRGVzY3JpcHRpb24oc3BlYy5uYW1lLCAoc3BlYy5hbGlhcyB8fCBbXSkuY29uY2F0KHNwZWMubmFtZSkubWFwKHMgPT4gcy50b0xvd2VyQ2FzZSgpKSwgc3BlYy5leHRlbnNpb25zIHx8IFtdLCBzcGVjLmZpbGVuYW1lLCBsb2FkLCBzdXBwb3J0KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgTG9vayBmb3IgYSBsYW5ndWFnZSBpbiB0aGUgZ2l2ZW4gYXJyYXkgb2YgZGVzY3JpcHRpb25zIHRoYXRcclxuICAgIG1hdGNoZXMgdGhlIGZpbGVuYW1lLiBXaWxsIGZpcnN0IG1hdGNoXHJcbiAgICBbYGZpbGVuYW1lYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNsYW5ndWFnZS5MYW5ndWFnZURlc2NyaXB0aW9uLmZpbGVuYW1lKSBwYXR0ZXJucyxcclxuICAgIGFuZCB0aGVuIFtleHRlbnNpb25zXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2xhbmd1YWdlLkxhbmd1YWdlRGVzY3JpcHRpb24uZXh0ZW5zaW9ucyksXHJcbiAgICBhbmQgcmV0dXJuIHRoZSBmaXJzdCBsYW5ndWFnZSB0aGF0IG1hdGNoZXMuXHJcbiAgICAqL1xyXG4gICAgc3RhdGljIG1hdGNoRmlsZW5hbWUoZGVzY3MsIGZpbGVuYW1lKSB7XHJcbiAgICAgICAgZm9yIChsZXQgZCBvZiBkZXNjcylcclxuICAgICAgICAgICAgaWYgKGQuZmlsZW5hbWUgJiYgZC5maWxlbmFtZS50ZXN0KGZpbGVuYW1lKSlcclxuICAgICAgICAgICAgICAgIHJldHVybiBkO1xyXG4gICAgICAgIGxldCBleHQgPSAvXFwuKFteLl0rKSQvLmV4ZWMoZmlsZW5hbWUpO1xyXG4gICAgICAgIGlmIChleHQpXHJcbiAgICAgICAgICAgIGZvciAobGV0IGQgb2YgZGVzY3MpXHJcbiAgICAgICAgICAgICAgICBpZiAoZC5leHRlbnNpb25zLmluZGV4T2YoZXh0WzFdKSA+IC0xKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkO1xyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICBMb29rIGZvciBhIGxhbmd1YWdlIHdob3NlIG5hbWUgb3IgYWxpYXMgbWF0Y2hlcyB0aGUgdGhlIGdpdmVuXHJcbiAgICBuYW1lIChjYXNlLWluc2Vuc2l0aXZlbHkpLiBJZiBgZnV6enlgIGlzIHRydWUsIGFuZCBubyBkaXJlY3RcclxuICAgIG1hdGNocyBpcyBmb3VuZCwgdGhpcydsbCBhbHNvIHNlYXJjaCBmb3IgYSBsYW5ndWFnZSB3aG9zZSBuYW1lXHJcbiAgICBvciBhbGlhcyBvY2N1cnMgaW4gdGhlIHN0cmluZyAoZm9yIG5hbWVzIHNob3J0ZXIgdGhhbiB0aHJlZVxyXG4gICAgY2hhcmFjdGVycywgb25seSB3aGVuIHN1cnJvdW5kZWQgYnkgbm9uLXdvcmQgY2hhcmFjdGVycykuXHJcbiAgICAqL1xyXG4gICAgc3RhdGljIG1hdGNoTGFuZ3VhZ2VOYW1lKGRlc2NzLCBuYW1lLCBmdXp6eSA9IHRydWUpIHtcclxuICAgICAgICBuYW1lID0gbmFtZS50b0xvd2VyQ2FzZSgpO1xyXG4gICAgICAgIGZvciAobGV0IGQgb2YgZGVzY3MpXHJcbiAgICAgICAgICAgIGlmIChkLmFsaWFzLnNvbWUoYSA9PiBhID09IG5hbWUpKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGQ7XHJcbiAgICAgICAgaWYgKGZ1enp5KVxyXG4gICAgICAgICAgICBmb3IgKGxldCBkIG9mIGRlc2NzKVxyXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgYSBvZiBkLmFsaWFzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IGZvdW5kID0gbmFtZS5pbmRleE9mKGEpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChmb3VuZCA+IC0xICYmIChhLmxlbmd0aCA+IDIgfHwgIS9cXHcvLnRlc3QobmFtZVtmb3VuZCAtIDFdKSAmJiAhL1xcdy8udGVzdChuYW1lW2ZvdW5kICsgYS5sZW5ndGhdKSkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBkO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG59XHJcblxyXG4vKipcclxuRmFjZXQgdGhhdCBkZWZpbmVzIGEgd2F5IHRvIHByb3ZpZGUgYSBmdW5jdGlvbiB0aGF0IGNvbXB1dGVzIHRoZVxyXG5hcHByb3ByaWF0ZSBpbmRlbnRhdGlvbiBkZXB0aCwgYXMgYSBjb2x1bW4gbnVtYmVyIChzZWVcclxuW2BpbmRlbnRTdHJpbmdgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2xhbmd1YWdlLmluZGVudFN0cmluZykpLCBhdCB0aGUgc3RhcnQgb2YgYSBnaXZlblxyXG5saW5lLiBBIHJldHVybiB2YWx1ZSBvZiBgbnVsbGAgaW5kaWNhdGVzIG5vIGluZGVudGF0aW9uIGNhbiBiZVxyXG5kZXRlcm1pbmVkLCBhbmQgdGhlIGxpbmUgc2hvdWxkIGluaGVyaXQgdGhlIGluZGVudGF0aW9uIG9mIHRoZSBvbmVcclxuYWJvdmUgaXQuIEEgcmV0dXJuIHZhbHVlIG9mIGB1bmRlZmluZWRgIGRlZmVycyB0byB0aGUgbmV4dCBpbmRlbnRcclxuc2VydmljZS5cclxuKi9cclxuY29uc3QgaW5kZW50U2VydmljZSA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoKTtcclxuLyoqXHJcbkZhY2V0IGZvciBvdmVycmlkaW5nIHRoZSB1bml0IGJ5IHdoaWNoIGluZGVudGF0aW9uIGhhcHBlbnMuXHJcblNob3VsZCBiZSBhIHN0cmluZyBjb25zaXN0aW5nIGVpdGhlciBlbnRpcmVseSBvZiBzcGFjZXMgb3JcclxuZW50aXJlbHkgb2YgdGFicy4gV2hlbiBub3Qgc2V0LCB0aGlzIGRlZmF1bHRzIHRvIDIgc3BhY2VzLlxyXG4qL1xyXG5jb25zdCBpbmRlbnRVbml0ID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSh7XHJcbiAgICBjb21iaW5lOiB2YWx1ZXMgPT4ge1xyXG4gICAgICAgIGlmICghdmFsdWVzLmxlbmd0aClcclxuICAgICAgICAgICAgcmV0dXJuIFwiICBcIjtcclxuICAgICAgICBpZiAoIS9eKD86ICt8XFx0KykkLy50ZXN0KHZhbHVlc1swXSkpXHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgaW5kZW50IHVuaXQ6IFwiICsgSlNPTi5zdHJpbmdpZnkodmFsdWVzWzBdKSk7XHJcbiAgICAgICAgcmV0dXJuIHZhbHVlc1swXTtcclxuICAgIH1cclxufSk7XHJcbi8qKlxyXG5SZXR1cm4gdGhlIF9jb2x1bW4gd2lkdGhfIG9mIGFuIGluZGVudCB1bml0IGluIHRoZSBzdGF0ZS5cclxuRGV0ZXJtaW5lZCBieSB0aGUgW2BpbmRlbnRVbml0YF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNsYW5ndWFnZS5pbmRlbnRVbml0KVxyXG5mYWNldCwgYW5kIFtgdGFiU2l6ZWBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuRWRpdG9yU3RhdGVedGFiU2l6ZSkgd2hlbiB0aGF0XHJcbmNvbnRhaW5zIHRhYnMuXHJcbiovXHJcbmZ1bmN0aW9uIGdldEluZGVudFVuaXQoc3RhdGUpIHtcclxuICAgIGxldCB1bml0ID0gc3RhdGUuZmFjZXQoaW5kZW50VW5pdCk7XHJcbiAgICByZXR1cm4gdW5pdC5jaGFyQ29kZUF0KDApID09IDkgPyBzdGF0ZS50YWJTaXplICogdW5pdC5sZW5ndGggOiB1bml0Lmxlbmd0aDtcclxufVxyXG4vKipcclxuQ3JlYXRlIGFuIGluZGVudGF0aW9uIHN0cmluZyB0aGF0IGNvdmVycyBjb2x1bW5zIDAgdG8gYGNvbHNgLlxyXG5XaWxsIHVzZSB0YWJzIGZvciBhcyBtdWNoIG9mIHRoZSBjb2x1bW5zIGFzIHBvc3NpYmxlIHdoZW4gdGhlXHJcbltgaW5kZW50VW5pdGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jbGFuZ3VhZ2UuaW5kZW50VW5pdCkgZmFjZXQgY29udGFpbnNcclxudGFicy5cclxuKi9cclxuZnVuY3Rpb24gaW5kZW50U3RyaW5nKHN0YXRlLCBjb2xzKSB7XHJcbiAgICBsZXQgcmVzdWx0ID0gXCJcIiwgdHMgPSBzdGF0ZS50YWJTaXplO1xyXG4gICAgaWYgKHN0YXRlLmZhY2V0KGluZGVudFVuaXQpLmNoYXJDb2RlQXQoMCkgPT0gOSlcclxuICAgICAgICB3aGlsZSAoY29scyA+PSB0cykge1xyXG4gICAgICAgICAgICByZXN1bHQgKz0gXCJcXHRcIjtcclxuICAgICAgICAgICAgY29scyAtPSB0cztcclxuICAgICAgICB9XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvbHM7IGkrKylcclxuICAgICAgICByZXN1bHQgKz0gXCIgXCI7XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59XHJcbi8qKlxyXG5HZXQgdGhlIGluZGVudGF0aW9uLCBhcyBhIGNvbHVtbiBudW1iZXIsIGF0IHRoZSBnaXZlbiBwb3NpdGlvbi5cclxuV2lsbCBmaXJzdCBjb25zdWx0IGFueSBbaW5kZW50IHNlcnZpY2VzXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2xhbmd1YWdlLmluZGVudFNlcnZpY2UpXHJcbnRoYXQgYXJlIHJlZ2lzdGVyZWQsIGFuZCBpZiBub25lIG9mIHRob3NlIHJldHVybiBhbiBpbmRlbnRhdGlvbixcclxudGhpcyB3aWxsIGNoZWNrIHRoZSBzeW50YXggdHJlZSBmb3IgdGhlIFtpbmRlbnQgbm9kZVxyXG5wcm9wXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2xhbmd1YWdlLmluZGVudE5vZGVQcm9wKSBhbmQgdXNlIHRoYXQgaWYgZm91bmQuIFJldHVybnMgYVxyXG5udW1iZXIgd2hlbiBhbiBpbmRlbnRhdGlvbiBjb3VsZCBiZSBkZXRlcm1pbmVkLCBhbmQgbnVsbFxyXG5vdGhlcndpc2UuXHJcbiovXHJcbmZ1bmN0aW9uIGdldEluZGVudGF0aW9uKGNvbnRleHQsIHBvcykge1xyXG4gICAgaWYgKGNvbnRleHQgaW5zdGFuY2VvZiBFZGl0b3JTdGF0ZSlcclxuICAgICAgICBjb250ZXh0ID0gbmV3IEluZGVudENvbnRleHQoY29udGV4dCk7XHJcbiAgICBmb3IgKGxldCBzZXJ2aWNlIG9mIGNvbnRleHQuc3RhdGUuZmFjZXQoaW5kZW50U2VydmljZSkpIHtcclxuICAgICAgICBsZXQgcmVzdWx0ID0gc2VydmljZShjb250ZXh0LCBwb3MpO1xyXG4gICAgICAgIGlmIChyZXN1bHQgIT09IHVuZGVmaW5lZClcclxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuICAgIGxldCB0cmVlID0gc3ludGF4VHJlZShjb250ZXh0LnN0YXRlKTtcclxuICAgIHJldHVybiB0cmVlID8gc3ludGF4SW5kZW50YXRpb24oY29udGV4dCwgdHJlZSwgcG9zKSA6IG51bGw7XHJcbn1cclxuLyoqXHJcbkNyZWF0ZSBhIGNoYW5nZSBzZXQgdGhhdCBhdXRvLWluZGVudHMgYWxsIGxpbmVzIHRvdWNoZWQgYnkgdGhlXHJcbmdpdmVuIGRvY3VtZW50IHJhbmdlLlxyXG4qL1xyXG5mdW5jdGlvbiBpbmRlbnRSYW5nZShzdGF0ZSwgZnJvbSwgdG8pIHtcclxuICAgIGxldCB1cGRhdGVkID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcclxuICAgIGxldCBjb250ZXh0ID0gbmV3IEluZGVudENvbnRleHQoc3RhdGUsIHsgb3ZlcnJpZGVJbmRlbnRhdGlvbjogc3RhcnQgPT4geyB2YXIgX2E7IHJldHVybiAoX2EgPSB1cGRhdGVkW3N0YXJ0XSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogLTE7IH0gfSk7XHJcbiAgICBsZXQgY2hhbmdlcyA9IFtdO1xyXG4gICAgZm9yIChsZXQgcG9zID0gZnJvbTsgcG9zIDw9IHRvOykge1xyXG4gICAgICAgIGxldCBsaW5lID0gc3RhdGUuZG9jLmxpbmVBdChwb3MpO1xyXG4gICAgICAgIHBvcyA9IGxpbmUudG8gKyAxO1xyXG4gICAgICAgIGxldCBpbmRlbnQgPSBnZXRJbmRlbnRhdGlvbihjb250ZXh0LCBsaW5lLmZyb20pO1xyXG4gICAgICAgIGlmIChpbmRlbnQgPT0gbnVsbClcclxuICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgaWYgKCEvXFxTLy50ZXN0KGxpbmUudGV4dCkpXHJcbiAgICAgICAgICAgIGluZGVudCA9IDA7XHJcbiAgICAgICAgbGV0IGN1ciA9IC9eXFxzKi8uZXhlYyhsaW5lLnRleHQpWzBdO1xyXG4gICAgICAgIGxldCBub3JtID0gaW5kZW50U3RyaW5nKHN0YXRlLCBpbmRlbnQpO1xyXG4gICAgICAgIGlmIChjdXIgIT0gbm9ybSkge1xyXG4gICAgICAgICAgICB1cGRhdGVkW2xpbmUuZnJvbV0gPSBpbmRlbnQ7XHJcbiAgICAgICAgICAgIGNoYW5nZXMucHVzaCh7IGZyb206IGxpbmUuZnJvbSwgdG86IGxpbmUuZnJvbSArIGN1ci5sZW5ndGgsIGluc2VydDogbm9ybSB9KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gc3RhdGUuY2hhbmdlcyhjaGFuZ2VzKTtcclxufVxyXG4vKipcclxuSW5kZW50YXRpb24gY29udGV4dHMgYXJlIHVzZWQgd2hlbiBjYWxsaW5nIFtpbmRlbnRhdGlvblxyXG5zZXJ2aWNlc10oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNsYW5ndWFnZS5pbmRlbnRTZXJ2aWNlKS4gVGhleSBwcm92aWRlIGhlbHBlciB1dGlsaXRpZXNcclxudXNlZnVsIGluIGluZGVudGF0aW9uIGxvZ2ljLCBhbmQgY2FuIHNlbGVjdGl2ZWx5IG92ZXJyaWRlIHRoZVxyXG5pbmRlbnRhdGlvbiByZXBvcnRlZCBmb3Igc29tZSBsaW5lcy5cclxuKi9cclxuY2xhc3MgSW5kZW50Q29udGV4dCB7XHJcbiAgICAvKipcclxuICAgIENyZWF0ZSBhbiBpbmRlbnQgY29udGV4dC5cclxuICAgICovXHJcbiAgICBjb25zdHJ1Y3RvcihcclxuICAgIC8qKlxyXG4gICAgVGhlIGVkaXRvciBzdGF0ZS5cclxuICAgICovXHJcbiAgICBzdGF0ZSwgXHJcbiAgICAvKipcclxuICAgIEBpbnRlcm5hbFxyXG4gICAgKi9cclxuICAgIG9wdGlvbnMgPSB7fSkge1xyXG4gICAgICAgIHRoaXMuc3RhdGUgPSBzdGF0ZTtcclxuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xyXG4gICAgICAgIHRoaXMudW5pdCA9IGdldEluZGVudFVuaXQoc3RhdGUpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICBHZXQgYSBkZXNjcmlwdGlvbiBvZiB0aGUgbGluZSBhdCB0aGUgZ2l2ZW4gcG9zaXRpb24sIHRha2luZ1xyXG4gICAgW3NpbXVsYXRlZCBsaW5lXHJcbiAgICBicmVha3NdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jbGFuZ3VhZ2UuSW5kZW50Q29udGV4dC5jb25zdHJ1Y3Rvcl5vcHRpb25zLnNpbXVsYXRlQnJlYWspXHJcbiAgICBpbnRvIGFjY291bnQuIElmIHRoZXJlIGlzIHN1Y2ggYSBicmVhayBhdCBgcG9zYCwgdGhlIGBiaWFzYFxyXG4gICAgYXJndW1lbnQgZGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBwYXJ0IG9mIHRoZSBsaW5lIGxpbmUgYmVmb3JlIG9yXHJcbiAgICBhZnRlciB0aGUgYnJlYWsgaXMgdXNlZC5cclxuICAgICovXHJcbiAgICBsaW5lQXQocG9zLCBiaWFzID0gMSkge1xyXG4gICAgICAgIGxldCBsaW5lID0gdGhpcy5zdGF0ZS5kb2MubGluZUF0KHBvcyk7XHJcbiAgICAgICAgbGV0IHsgc2ltdWxhdGVCcmVhaywgc2ltdWxhdGVEb3VibGVCcmVhayB9ID0gdGhpcy5vcHRpb25zO1xyXG4gICAgICAgIGlmIChzaW11bGF0ZUJyZWFrICE9IG51bGwgJiYgc2ltdWxhdGVCcmVhayA+PSBsaW5lLmZyb20gJiYgc2ltdWxhdGVCcmVhayA8PSBsaW5lLnRvKSB7XHJcbiAgICAgICAgICAgIGlmIChzaW11bGF0ZURvdWJsZUJyZWFrICYmIHNpbXVsYXRlQnJlYWsgPT0gcG9zKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgdGV4dDogXCJcIiwgZnJvbTogcG9zIH07XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGJpYXMgPCAwID8gc2ltdWxhdGVCcmVhayA8IHBvcyA6IHNpbXVsYXRlQnJlYWsgPD0gcG9zKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgdGV4dDogbGluZS50ZXh0LnNsaWNlKHNpbXVsYXRlQnJlYWsgLSBsaW5lLmZyb20pLCBmcm9tOiBzaW11bGF0ZUJyZWFrIH07XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgIHJldHVybiB7IHRleHQ6IGxpbmUudGV4dC5zbGljZSgwLCBzaW11bGF0ZUJyZWFrIC0gbGluZS5mcm9tKSwgZnJvbTogbGluZS5mcm9tIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBsaW5lO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICBHZXQgdGhlIHRleHQgZGlyZWN0bHkgYWZ0ZXIgYHBvc2AsIGVpdGhlciB0aGUgZW50aXJlIGxpbmVcclxuICAgIG9yIHRoZSBuZXh0IDEwMCBjaGFyYWN0ZXJzLCB3aGljaGV2ZXIgaXMgc2hvcnRlci5cclxuICAgICovXHJcbiAgICB0ZXh0QWZ0ZXJQb3MocG9zLCBiaWFzID0gMSkge1xyXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuc2ltdWxhdGVEb3VibGVCcmVhayAmJiBwb3MgPT0gdGhpcy5vcHRpb25zLnNpbXVsYXRlQnJlYWspXHJcbiAgICAgICAgICAgIHJldHVybiBcIlwiO1xyXG4gICAgICAgIGxldCB7IHRleHQsIGZyb20gfSA9IHRoaXMubGluZUF0KHBvcywgYmlhcyk7XHJcbiAgICAgICAgcmV0dXJuIHRleHQuc2xpY2UocG9zIC0gZnJvbSwgTWF0aC5taW4odGV4dC5sZW5ndGgsIHBvcyArIDEwMCAtIGZyb20pKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgRmluZCB0aGUgY29sdW1uIGZvciB0aGUgZ2l2ZW4gcG9zaXRpb24uXHJcbiAgICAqL1xyXG4gICAgY29sdW1uKHBvcywgYmlhcyA9IDEpIHtcclxuICAgICAgICBsZXQgeyB0ZXh0LCBmcm9tIH0gPSB0aGlzLmxpbmVBdChwb3MsIGJpYXMpO1xyXG4gICAgICAgIGxldCByZXN1bHQgPSB0aGlzLmNvdW50Q29sdW1uKHRleHQsIHBvcyAtIGZyb20pO1xyXG4gICAgICAgIGxldCBvdmVycmlkZSA9IHRoaXMub3B0aW9ucy5vdmVycmlkZUluZGVudGF0aW9uID8gdGhpcy5vcHRpb25zLm92ZXJyaWRlSW5kZW50YXRpb24oZnJvbSkgOiAtMTtcclxuICAgICAgICBpZiAob3ZlcnJpZGUgPiAtMSlcclxuICAgICAgICAgICAgcmVzdWx0ICs9IG92ZXJyaWRlIC0gdGhpcy5jb3VudENvbHVtbih0ZXh0LCB0ZXh0LnNlYXJjaCgvXFxTfCQvKSk7XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgRmluZCB0aGUgY29sdW1uIHBvc2l0aW9uICh0YWtpbmcgdGFicyBpbnRvIGFjY291bnQpIG9mIHRoZSBnaXZlblxyXG4gICAgcG9zaXRpb24gaW4gdGhlIGdpdmVuIHN0cmluZy5cclxuICAgICovXHJcbiAgICBjb3VudENvbHVtbihsaW5lLCBwb3MgPSBsaW5lLmxlbmd0aCkge1xyXG4gICAgICAgIHJldHVybiBjb3VudENvbHVtbihsaW5lLCB0aGlzLnN0YXRlLnRhYlNpemUsIHBvcyk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgIEZpbmQgdGhlIGluZGVudGF0aW9uIGNvbHVtbiBvZiB0aGUgbGluZSBhdCB0aGUgZ2l2ZW4gcG9pbnQuXHJcbiAgICAqL1xyXG4gICAgbGluZUluZGVudChwb3MsIGJpYXMgPSAxKSB7XHJcbiAgICAgICAgbGV0IHsgdGV4dCwgZnJvbSB9ID0gdGhpcy5saW5lQXQocG9zLCBiaWFzKTtcclxuICAgICAgICBsZXQgb3ZlcnJpZGUgPSB0aGlzLm9wdGlvbnMub3ZlcnJpZGVJbmRlbnRhdGlvbjtcclxuICAgICAgICBpZiAob3ZlcnJpZGUpIHtcclxuICAgICAgICAgICAgbGV0IG92ZXJyaWRlbiA9IG92ZXJyaWRlKGZyb20pO1xyXG4gICAgICAgICAgICBpZiAob3ZlcnJpZGVuID4gLTEpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gb3ZlcnJpZGVuO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5jb3VudENvbHVtbih0ZXh0LCB0ZXh0LnNlYXJjaCgvXFxTfCQvKSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgIFJldHVybnMgdGhlIFtzaW11bGF0ZWQgbGluZVxyXG4gICAgYnJlYWtdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jbGFuZ3VhZ2UuSW5kZW50Q29udGV4dC5jb25zdHJ1Y3Rvcl5vcHRpb25zLnNpbXVsYXRlQnJlYWspXHJcbiAgICBmb3IgdGhpcyBjb250ZXh0LCBpZiBhbnkuXHJcbiAgICAqL1xyXG4gICAgZ2V0IHNpbXVsYXRlZEJyZWFrKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnMuc2ltdWxhdGVCcmVhayB8fCBudWxsO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG5BIHN5bnRheCB0cmVlIG5vZGUgcHJvcCB1c2VkIHRvIGFzc29jaWF0ZSBpbmRlbnRhdGlvbiBzdHJhdGVnaWVzXHJcbndpdGggbm9kZSB0eXBlcy4gU3VjaCBhIHN0cmF0ZWd5IGlzIGEgZnVuY3Rpb24gZnJvbSBhbiBpbmRlbnRhdGlvblxyXG5jb250ZXh0IHRvIGEgY29sdW1uIG51bWJlciAoc2VlIGFsc29cclxuW2BpbmRlbnRTdHJpbmdgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2xhbmd1YWdlLmluZGVudFN0cmluZykpIG9yIG51bGwsIHdoZXJlIG51bGxcclxuaW5kaWNhdGVzIHRoYXQgbm8gZGVmaW5pdGl2ZSBpbmRlbnRhdGlvbiBjYW4gYmUgZGV0ZXJtaW5lZC5cclxuKi9cclxuY29uc3QgaW5kZW50Tm9kZVByb3AgPSAvKkBfX1BVUkVfXyovbmV3IE5vZGVQcm9wKCk7XHJcbi8vIENvbXB1dGUgdGhlIGluZGVudGF0aW9uIGZvciBhIGdpdmVuIHBvc2l0aW9uIGZyb20gdGhlIHN5bnRheCB0cmVlLlxyXG5mdW5jdGlvbiBzeW50YXhJbmRlbnRhdGlvbihjeCwgYXN0LCBwb3MpIHtcclxuICAgIHJldHVybiBpbmRlbnRGcm9tKGFzdC5yZXNvbHZlSW5uZXIocG9zKS5lbnRlclVuZmluaXNoZWROb2Rlc0JlZm9yZShwb3MpLCBwb3MsIGN4KTtcclxufVxyXG5mdW5jdGlvbiBpZ25vcmVDbG9zZWQoY3gpIHtcclxuICAgIHJldHVybiBjeC5wb3MgPT0gY3gub3B0aW9ucy5zaW11bGF0ZUJyZWFrICYmIGN4Lm9wdGlvbnMuc2ltdWxhdGVEb3VibGVCcmVhaztcclxufVxyXG5mdW5jdGlvbiBpbmRlbnRTdHJhdGVneSh0cmVlKSB7XHJcbiAgICBsZXQgc3RyYXRlZ3kgPSB0cmVlLnR5cGUucHJvcChpbmRlbnROb2RlUHJvcCk7XHJcbiAgICBpZiAoc3RyYXRlZ3kpXHJcbiAgICAgICAgcmV0dXJuIHN0cmF0ZWd5O1xyXG4gICAgbGV0IGZpcnN0ID0gdHJlZS5maXJzdENoaWxkLCBjbG9zZTtcclxuICAgIGlmIChmaXJzdCAmJiAoY2xvc2UgPSBmaXJzdC50eXBlLnByb3AoTm9kZVByb3AuY2xvc2VkQnkpKSkge1xyXG4gICAgICAgIGxldCBsYXN0ID0gdHJlZS5sYXN0Q2hpbGQsIGNsb3NlZCA9IGxhc3QgJiYgY2xvc2UuaW5kZXhPZihsYXN0Lm5hbWUpID4gLTE7XHJcbiAgICAgICAgcmV0dXJuIGN4ID0+IGRlbGltaXRlZFN0cmF0ZWd5KGN4LCB0cnVlLCAxLCB1bmRlZmluZWQsIGNsb3NlZCAmJiAhaWdub3JlQ2xvc2VkKGN4KSA/IGxhc3QuZnJvbSA6IHVuZGVmaW5lZCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdHJlZS5wYXJlbnQgPT0gbnVsbCA/IHRvcEluZGVudCA6IG51bGw7XHJcbn1cclxuZnVuY3Rpb24gaW5kZW50RnJvbShub2RlLCBwb3MsIGJhc2UpIHtcclxuICAgIGZvciAoOyBub2RlOyBub2RlID0gbm9kZS5wYXJlbnQpIHtcclxuICAgICAgICBsZXQgc3RyYXRlZ3kgPSBpbmRlbnRTdHJhdGVneShub2RlKTtcclxuICAgICAgICBpZiAoc3RyYXRlZ3kpXHJcbiAgICAgICAgICAgIHJldHVybiBzdHJhdGVneShUcmVlSW5kZW50Q29udGV4dC5jcmVhdGUoYmFzZSwgcG9zLCBub2RlKSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbnVsbDtcclxufVxyXG5mdW5jdGlvbiB0b3BJbmRlbnQoKSB7IHJldHVybiAwOyB9XHJcbi8qKlxyXG5PYmplY3RzIG9mIHRoaXMgdHlwZSBwcm92aWRlIGNvbnRleHQgaW5mb3JtYXRpb24gYW5kIGhlbHBlclxyXG5tZXRob2RzIHRvIGluZGVudGF0aW9uIGZ1bmN0aW9ucyByZWdpc3RlcmVkIG9uIHN5bnRheCBub2Rlcy5cclxuKi9cclxuY2xhc3MgVHJlZUluZGVudENvbnRleHQgZXh0ZW5kcyBJbmRlbnRDb250ZXh0IHtcclxuICAgIGNvbnN0cnVjdG9yKGJhc2UsIFxyXG4gICAgLyoqXHJcbiAgICBUaGUgcG9zaXRpb24gYXQgd2hpY2ggaW5kZW50YXRpb24gaXMgYmVpbmcgY29tcHV0ZWQuXHJcbiAgICAqL1xyXG4gICAgcG9zLCBcclxuICAgIC8qKlxyXG4gICAgVGhlIHN5bnRheCB0cmVlIG5vZGUgdG8gd2hpY2ggdGhlIGluZGVudGF0aW9uIHN0cmF0ZWd5XHJcbiAgICBhcHBsaWVzLlxyXG4gICAgKi9cclxuICAgIG5vZGUpIHtcclxuICAgICAgICBzdXBlcihiYXNlLnN0YXRlLCBiYXNlLm9wdGlvbnMpO1xyXG4gICAgICAgIHRoaXMuYmFzZSA9IGJhc2U7XHJcbiAgICAgICAgdGhpcy5wb3MgPSBwb3M7XHJcbiAgICAgICAgdGhpcy5ub2RlID0gbm9kZTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgQGludGVybmFsXHJcbiAgICAqL1xyXG4gICAgc3RhdGljIGNyZWF0ZShiYXNlLCBwb3MsIG5vZGUpIHtcclxuICAgICAgICByZXR1cm4gbmV3IFRyZWVJbmRlbnRDb250ZXh0KGJhc2UsIHBvcywgbm9kZSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgIEdldCB0aGUgdGV4dCBkaXJlY3RseSBhZnRlciBgdGhpcy5wb3NgLCBlaXRoZXIgdGhlIGVudGlyZSBsaW5lXHJcbiAgICBvciB0aGUgbmV4dCAxMDAgY2hhcmFjdGVycywgd2hpY2hldmVyIGlzIHNob3J0ZXIuXHJcbiAgICAqL1xyXG4gICAgZ2V0IHRleHRBZnRlcigpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy50ZXh0QWZ0ZXJQb3ModGhpcy5wb3MpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICBHZXQgdGhlIGluZGVudGF0aW9uIGF0IHRoZSByZWZlcmVuY2UgbGluZSBmb3IgYHRoaXMubm9kZWAsIHdoaWNoXHJcbiAgICBpcyB0aGUgbGluZSBvbiB3aGljaCBpdCBzdGFydHMsIHVubGVzcyB0aGVyZSBpcyBhIG5vZGUgdGhhdCBpc1xyXG4gICAgX25vdF8gYSBwYXJlbnQgb2YgdGhpcyBub2RlIGNvdmVyaW5nIHRoZSBzdGFydCBvZiB0aGF0IGxpbmUuIElmXHJcbiAgICBzbywgdGhlIGxpbmUgYXQgdGhlIHN0YXJ0IG9mIHRoYXQgbm9kZSBpcyB0cmllZCwgYWdhaW4gc2tpcHBpbmdcclxuICAgIG9uIGlmIGl0IGlzIGNvdmVyZWQgYnkgYW5vdGhlciBzdWNoIG5vZGUuXHJcbiAgICAqL1xyXG4gICAgZ2V0IGJhc2VJbmRlbnQoKSB7XHJcbiAgICAgICAgbGV0IGxpbmUgPSB0aGlzLnN0YXRlLmRvYy5saW5lQXQodGhpcy5ub2RlLmZyb20pO1xyXG4gICAgICAgIC8vIFNraXAgbGluZSBzdGFydHMgdGhhdCBhcmUgY292ZXJlZCBieSBhIHNpYmxpbmcgKG9yIGNvdXNpbiwgZXRjKVxyXG4gICAgICAgIGZvciAoOzspIHtcclxuICAgICAgICAgICAgbGV0IGF0QnJlYWsgPSB0aGlzLm5vZGUucmVzb2x2ZShsaW5lLmZyb20pO1xyXG4gICAgICAgICAgICB3aGlsZSAoYXRCcmVhay5wYXJlbnQgJiYgYXRCcmVhay5wYXJlbnQuZnJvbSA9PSBhdEJyZWFrLmZyb20pXHJcbiAgICAgICAgICAgICAgICBhdEJyZWFrID0gYXRCcmVhay5wYXJlbnQ7XHJcbiAgICAgICAgICAgIGlmIChpc1BhcmVudChhdEJyZWFrLCB0aGlzLm5vZGUpKVxyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGxpbmUgPSB0aGlzLnN0YXRlLmRvYy5saW5lQXQoYXRCcmVhay5mcm9tKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubGluZUluZGVudChsaW5lLmZyb20pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICBDb250aW51ZSBsb29raW5nIGZvciBpbmRlbnRhdGlvbnMgaW4gdGhlIG5vZGUncyBwYXJlbnQgbm9kZXMsXHJcbiAgICBhbmQgcmV0dXJuIHRoZSByZXN1bHQgb2YgdGhhdC5cclxuICAgICovXHJcbiAgICBjb250aW51ZSgpIHtcclxuICAgICAgICBsZXQgcGFyZW50ID0gdGhpcy5ub2RlLnBhcmVudDtcclxuICAgICAgICByZXR1cm4gcGFyZW50ID8gaW5kZW50RnJvbShwYXJlbnQsIHRoaXMucG9zLCB0aGlzLmJhc2UpIDogMDtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBpc1BhcmVudChwYXJlbnQsIG9mKSB7XHJcbiAgICBmb3IgKGxldCBjdXIgPSBvZjsgY3VyOyBjdXIgPSBjdXIucGFyZW50KVxyXG4gICAgICAgIGlmIChwYXJlbnQgPT0gY3VyKVxyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIHJldHVybiBmYWxzZTtcclxufVxyXG4vLyBDaGVjayB3aGV0aGVyIGEgZGVsaW1pdGVkIG5vZGUgaXMgYWxpZ25lZCAobWVhbmluZyB0aGVyZSBhcmVcclxuLy8gbm9uLXNraXBwZWQgbm9kZXMgb24gdGhlIHNhbWUgbGluZSBhcyB0aGUgb3BlbmluZyBkZWxpbWl0ZXIpLiBBbmRcclxuLy8gaWYgc28sIHJldHVybiB0aGUgb3BlbmluZyB0b2tlbi5cclxuZnVuY3Rpb24gYnJhY2tldGVkQWxpZ25lZChjb250ZXh0KSB7XHJcbiAgICBsZXQgdHJlZSA9IGNvbnRleHQubm9kZTtcclxuICAgIGxldCBvcGVuVG9rZW4gPSB0cmVlLmNoaWxkQWZ0ZXIodHJlZS5mcm9tKSwgbGFzdCA9IHRyZWUubGFzdENoaWxkO1xyXG4gICAgaWYgKCFvcGVuVG9rZW4pXHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICBsZXQgc2ltID0gY29udGV4dC5vcHRpb25zLnNpbXVsYXRlQnJlYWs7XHJcbiAgICBsZXQgb3BlbkxpbmUgPSBjb250ZXh0LnN0YXRlLmRvYy5saW5lQXQob3BlblRva2VuLmZyb20pO1xyXG4gICAgbGV0IGxpbmVFbmQgPSBzaW0gPT0gbnVsbCB8fCBzaW0gPD0gb3BlbkxpbmUuZnJvbSA/IG9wZW5MaW5lLnRvIDogTWF0aC5taW4ob3BlbkxpbmUudG8sIHNpbSk7XHJcbiAgICBmb3IgKGxldCBwb3MgPSBvcGVuVG9rZW4udG87Oykge1xyXG4gICAgICAgIGxldCBuZXh0ID0gdHJlZS5jaGlsZEFmdGVyKHBvcyk7XHJcbiAgICAgICAgaWYgKCFuZXh0IHx8IG5leHQgPT0gbGFzdClcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgaWYgKCFuZXh0LnR5cGUuaXNTa2lwcGVkKVxyXG4gICAgICAgICAgICByZXR1cm4gbmV4dC5mcm9tIDwgbGluZUVuZCA/IG9wZW5Ub2tlbiA6IG51bGw7XHJcbiAgICAgICAgcG9zID0gbmV4dC50bztcclxuICAgIH1cclxufVxyXG4vKipcclxuQW4gaW5kZW50YXRpb24gc3RyYXRlZ3kgZm9yIGRlbGltaXRlZCAodXN1YWxseSBicmFja2V0ZWQpIG5vZGVzLlxyXG5XaWxsLCBieSBkZWZhdWx0LCBpbmRlbnQgb25lIHVuaXQgbW9yZSB0aGFuIHRoZSBwYXJlbnQncyBiYXNlXHJcbmluZGVudCB1bmxlc3MgdGhlIGxpbmUgc3RhcnRzIHdpdGggYSBjbG9zaW5nIHRva2VuLiBXaGVuIGBhbGlnbmBcclxuaXMgdHJ1ZSBhbmQgdGhlcmUgYXJlIG5vbi1za2lwcGVkIG5vZGVzIG9uIHRoZSBub2RlJ3Mgb3BlbmluZ1xyXG5saW5lLCB0aGUgY29udGVudCBvZiB0aGUgbm9kZSB3aWxsIGJlIGFsaWduZWQgd2l0aCB0aGUgZW5kIG9mIHRoZVxyXG5vcGVuaW5nIG5vZGUsIGxpa2UgdGhpczpcclxuXHJcbiAgICBmb28oYmFyLFxyXG4gICAgICAgIGJheilcclxuKi9cclxuZnVuY3Rpb24gZGVsaW1pdGVkSW5kZW50KHsgY2xvc2luZywgYWxpZ24gPSB0cnVlLCB1bml0cyA9IDEgfSkge1xyXG4gICAgcmV0dXJuIChjb250ZXh0KSA9PiBkZWxpbWl0ZWRTdHJhdGVneShjb250ZXh0LCBhbGlnbiwgdW5pdHMsIGNsb3NpbmcpO1xyXG59XHJcbmZ1bmN0aW9uIGRlbGltaXRlZFN0cmF0ZWd5KGNvbnRleHQsIGFsaWduLCB1bml0cywgY2xvc2luZywgY2xvc2VkQXQpIHtcclxuICAgIGxldCBhZnRlciA9IGNvbnRleHQudGV4dEFmdGVyLCBzcGFjZSA9IGFmdGVyLm1hdGNoKC9eXFxzKi8pWzBdLmxlbmd0aDtcclxuICAgIGxldCBjbG9zZWQgPSBjbG9zaW5nICYmIGFmdGVyLnNsaWNlKHNwYWNlLCBzcGFjZSArIGNsb3NpbmcubGVuZ3RoKSA9PSBjbG9zaW5nIHx8IGNsb3NlZEF0ID09IGNvbnRleHQucG9zICsgc3BhY2U7XHJcbiAgICBsZXQgYWxpZ25lZCA9IGFsaWduID8gYnJhY2tldGVkQWxpZ25lZChjb250ZXh0KSA6IG51bGw7XHJcbiAgICBpZiAoYWxpZ25lZClcclxuICAgICAgICByZXR1cm4gY2xvc2VkID8gY29udGV4dC5jb2x1bW4oYWxpZ25lZC5mcm9tKSA6IGNvbnRleHQuY29sdW1uKGFsaWduZWQudG8pO1xyXG4gICAgcmV0dXJuIGNvbnRleHQuYmFzZUluZGVudCArIChjbG9zZWQgPyAwIDogY29udGV4dC51bml0ICogdW5pdHMpO1xyXG59XHJcbi8qKlxyXG5BbiBpbmRlbnRhdGlvbiBzdHJhdGVneSB0aGF0IGFsaWducyBhIG5vZGUncyBjb250ZW50IHRvIGl0cyBiYXNlXHJcbmluZGVudGF0aW9uLlxyXG4qL1xyXG5jb25zdCBmbGF0SW5kZW50ID0gKGNvbnRleHQpID0+IGNvbnRleHQuYmFzZUluZGVudDtcclxuLyoqXHJcbkNyZWF0ZXMgYW4gaW5kZW50YXRpb24gc3RyYXRlZ3kgdGhhdCwgYnkgZGVmYXVsdCwgaW5kZW50c1xyXG5jb250aW51ZWQgbGluZXMgb25lIHVuaXQgbW9yZSB0aGFuIHRoZSBub2RlJ3MgYmFzZSBpbmRlbnRhdGlvbi5cclxuWW91IGNhbiBwcm92aWRlIGBleGNlcHRgIHRvIHByZXZlbnQgaW5kZW50YXRpb24gb2YgbGluZXMgdGhhdFxyXG5tYXRjaCBhIHBhdHRlcm4gKGZvciBleGFtcGxlIGAvXmVsc2VcXGIvYCBpbiBgaWZgL2BlbHNlYFxyXG5jb25zdHJ1Y3RzKSwgYW5kIHlvdSBjYW4gY2hhbmdlIHRoZSBhbW91bnQgb2YgdW5pdHMgdXNlZCB3aXRoIHRoZVxyXG5gdW5pdHNgIG9wdGlvbi5cclxuKi9cclxuZnVuY3Rpb24gY29udGludWVkSW5kZW50KHsgZXhjZXB0LCB1bml0cyA9IDEgfSA9IHt9KSB7XHJcbiAgICByZXR1cm4gKGNvbnRleHQpID0+IHtcclxuICAgICAgICBsZXQgbWF0Y2hFeGNlcHQgPSBleGNlcHQgJiYgZXhjZXB0LnRlc3QoY29udGV4dC50ZXh0QWZ0ZXIpO1xyXG4gICAgICAgIHJldHVybiBjb250ZXh0LmJhc2VJbmRlbnQgKyAobWF0Y2hFeGNlcHQgPyAwIDogdW5pdHMgKiBjb250ZXh0LnVuaXQpO1xyXG4gICAgfTtcclxufVxyXG5jb25zdCBEb250SW5kZW50QmV5b25kID0gMjAwO1xyXG4vKipcclxuRW5hYmxlcyByZWluZGVudGF0aW9uIG9uIGlucHV0LiBXaGVuIGEgbGFuZ3VhZ2UgZGVmaW5lcyBhblxyXG5gaW5kZW50T25JbnB1dGAgZmllbGQgaW4gaXRzIFtsYW5ndWFnZVxyXG5kYXRhXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkVkaXRvclN0YXRlLmxhbmd1YWdlRGF0YUF0KSwgd2hpY2ggbXVzdCBob2xkIGEgcmVndWxhclxyXG5leHByZXNzaW9uLCB0aGUgbGluZSBhdCB0aGUgY3Vyc29yIHdpbGwgYmUgcmVpbmRlbnRlZCB3aGVuZXZlciBuZXdcclxudGV4dCBpcyB0eXBlZCBhbmQgdGhlIGlucHV0IGZyb20gdGhlIHN0YXJ0IG9mIHRoZSBsaW5lIHVwIHRvIHRoZVxyXG5jdXJzb3IgbWF0Y2hlcyB0aGF0IHJlZ2V4cC5cclxuXHJcblRvIGF2b2lkIHVubmVjY2VzYXJ5IHJlaW5kZW50cywgaXQgaXMgcmVjb21tZW5kZWQgdG8gc3RhcnQgdGhlXHJcbnJlZ2V4cCB3aXRoIGBeYCAodXN1YWxseSBmb2xsb3dlZCBieSBgXFxzKmApLCBhbmQgZW5kIGl0IHdpdGggYCRgLlxyXG5Gb3IgZXhhbXBsZSwgYC9eXFxzKlxcfSQvYCB3aWxsIHJlaW5kZW50IHdoZW4gYSBjbG9zaW5nIGJyYWNlIGlzXHJcbmFkZGVkIGF0IHRoZSBzdGFydCBvZiBhIGxpbmUuXHJcbiovXHJcbmZ1bmN0aW9uIGluZGVudE9uSW5wdXQoKSB7XHJcbiAgICByZXR1cm4gRWRpdG9yU3RhdGUudHJhbnNhY3Rpb25GaWx0ZXIub2YodHIgPT4ge1xyXG4gICAgICAgIGlmICghdHIuZG9jQ2hhbmdlZCB8fCAhdHIuaXNVc2VyRXZlbnQoXCJpbnB1dC50eXBlXCIpICYmICF0ci5pc1VzZXJFdmVudChcImlucHV0LmNvbXBsZXRlXCIpKVxyXG4gICAgICAgICAgICByZXR1cm4gdHI7XHJcbiAgICAgICAgbGV0IHJ1bGVzID0gdHIuc3RhcnRTdGF0ZS5sYW5ndWFnZURhdGFBdChcImluZGVudE9uSW5wdXRcIiwgdHIuc3RhcnRTdGF0ZS5zZWxlY3Rpb24ubWFpbi5oZWFkKTtcclxuICAgICAgICBpZiAoIXJ1bGVzLmxlbmd0aClcclxuICAgICAgICAgICAgcmV0dXJuIHRyO1xyXG4gICAgICAgIGxldCBkb2MgPSB0ci5uZXdEb2MsIHsgaGVhZCB9ID0gdHIubmV3U2VsZWN0aW9uLm1haW4sIGxpbmUgPSBkb2MubGluZUF0KGhlYWQpO1xyXG4gICAgICAgIGlmIChoZWFkID4gbGluZS5mcm9tICsgRG9udEluZGVudEJleW9uZClcclxuICAgICAgICAgICAgcmV0dXJuIHRyO1xyXG4gICAgICAgIGxldCBsaW5lU3RhcnQgPSBkb2Muc2xpY2VTdHJpbmcobGluZS5mcm9tLCBoZWFkKTtcclxuICAgICAgICBpZiAoIXJ1bGVzLnNvbWUociA9PiByLnRlc3QobGluZVN0YXJ0KSkpXHJcbiAgICAgICAgICAgIHJldHVybiB0cjtcclxuICAgICAgICBsZXQgeyBzdGF0ZSB9ID0gdHIsIGxhc3QgPSAtMSwgY2hhbmdlcyA9IFtdO1xyXG4gICAgICAgIGZvciAobGV0IHsgaGVhZCB9IG9mIHN0YXRlLnNlbGVjdGlvbi5yYW5nZXMpIHtcclxuICAgICAgICAgICAgbGV0IGxpbmUgPSBzdGF0ZS5kb2MubGluZUF0KGhlYWQpO1xyXG4gICAgICAgICAgICBpZiAobGluZS5mcm9tID09IGxhc3QpXHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgbGFzdCA9IGxpbmUuZnJvbTtcclxuICAgICAgICAgICAgbGV0IGluZGVudCA9IGdldEluZGVudGF0aW9uKHN0YXRlLCBsaW5lLmZyb20pO1xyXG4gICAgICAgICAgICBpZiAoaW5kZW50ID09IG51bGwpXHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgbGV0IGN1ciA9IC9eXFxzKi8uZXhlYyhsaW5lLnRleHQpWzBdO1xyXG4gICAgICAgICAgICBsZXQgbm9ybSA9IGluZGVudFN0cmluZyhzdGF0ZSwgaW5kZW50KTtcclxuICAgICAgICAgICAgaWYgKGN1ciAhPSBub3JtKVxyXG4gICAgICAgICAgICAgICAgY2hhbmdlcy5wdXNoKHsgZnJvbTogbGluZS5mcm9tLCB0bzogbGluZS5mcm9tICsgY3VyLmxlbmd0aCwgaW5zZXJ0OiBub3JtIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gY2hhbmdlcy5sZW5ndGggPyBbdHIsIHsgY2hhbmdlcywgc2VxdWVudGlhbDogdHJ1ZSB9XSA6IHRyO1xyXG4gICAgfSk7XHJcbn1cclxuXHJcbi8qKlxyXG5BIGZhY2V0IHRoYXQgcmVnaXN0ZXJzIGEgY29kZSBmb2xkaW5nIHNlcnZpY2UuIFdoZW4gY2FsbGVkIHdpdGhcclxudGhlIGV4dGVudCBvZiBhIGxpbmUsIHN1Y2ggYSBmdW5jdGlvbiBzaG91bGQgcmV0dXJuIGEgZm9sZGFibGVcclxucmFuZ2UgdGhhdCBzdGFydHMgb24gdGhhdCBsaW5lIChidXQgY29udGludWVzIGJleW9uZCBpdCksIGlmIG9uZVxyXG5jYW4gYmUgZm91bmQuXHJcbiovXHJcbmNvbnN0IGZvbGRTZXJ2aWNlID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSgpO1xyXG4vKipcclxuVGhpcyBub2RlIHByb3AgaXMgdXNlZCB0byBhc3NvY2lhdGUgZm9sZGluZyBpbmZvcm1hdGlvbiB3aXRoXHJcbnN5bnRheCBub2RlIHR5cGVzLiBHaXZlbiBhIHN5bnRheCBub2RlLCBpdCBzaG91bGQgY2hlY2sgd2hldGhlclxyXG50aGF0IHRyZWUgaXMgZm9sZGFibGUgYW5kIHJldHVybiB0aGUgcmFuZ2UgdGhhdCBjYW4gYmUgY29sbGFwc2VkXHJcbndoZW4gaXQgaXMuXHJcbiovXHJcbmNvbnN0IGZvbGROb2RlUHJvcCA9IC8qQF9fUFVSRV9fKi9uZXcgTm9kZVByb3AoKTtcclxuLyoqXHJcbltGb2xkXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2xhbmd1YWdlLmZvbGROb2RlUHJvcCkgZnVuY3Rpb24gdGhhdCBmb2xkcyBldmVyeXRoaW5nIGJ1dFxyXG50aGUgZmlyc3QgYW5kIHRoZSBsYXN0IGNoaWxkIG9mIGEgc3ludGF4IG5vZGUuIFVzZWZ1bCBmb3Igbm9kZXNcclxudGhhdCBzdGFydCBhbmQgZW5kIHdpdGggZGVsaW1pdGVycy5cclxuKi9cclxuZnVuY3Rpb24gZm9sZEluc2lkZShub2RlKSB7XHJcbiAgICBsZXQgZmlyc3QgPSBub2RlLmZpcnN0Q2hpbGQsIGxhc3QgPSBub2RlLmxhc3RDaGlsZDtcclxuICAgIHJldHVybiBmaXJzdCAmJiBmaXJzdC50byA8IGxhc3QuZnJvbSA/IHsgZnJvbTogZmlyc3QudG8sIHRvOiBsYXN0LnR5cGUuaXNFcnJvciA/IG5vZGUudG8gOiBsYXN0LmZyb20gfSA6IG51bGw7XHJcbn1cclxuZnVuY3Rpb24gc3ludGF4Rm9sZGluZyhzdGF0ZSwgc3RhcnQsIGVuZCkge1xyXG4gICAgbGV0IHRyZWUgPSBzeW50YXhUcmVlKHN0YXRlKTtcclxuICAgIGlmICh0cmVlLmxlbmd0aCA8IGVuZClcclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIGxldCBpbm5lciA9IHRyZWUucmVzb2x2ZUlubmVyKGVuZCwgMSk7XHJcbiAgICBsZXQgZm91bmQgPSBudWxsO1xyXG4gICAgZm9yIChsZXQgY3VyID0gaW5uZXI7IGN1cjsgY3VyID0gY3VyLnBhcmVudCkge1xyXG4gICAgICAgIGlmIChjdXIudG8gPD0gZW5kIHx8IGN1ci5mcm9tID4gZW5kKVxyXG4gICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICBpZiAoZm91bmQgJiYgY3VyLmZyb20gPCBzdGFydClcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgbGV0IHByb3AgPSBjdXIudHlwZS5wcm9wKGZvbGROb2RlUHJvcCk7XHJcbiAgICAgICAgaWYgKHByb3AgJiYgKGN1ci50byA8IHRyZWUubGVuZ3RoIC0gNTAgfHwgdHJlZS5sZW5ndGggPT0gc3RhdGUuZG9jLmxlbmd0aCB8fCAhaXNVbmZpbmlzaGVkKGN1cikpKSB7XHJcbiAgICAgICAgICAgIGxldCB2YWx1ZSA9IHByb3AoY3VyLCBzdGF0ZSk7XHJcbiAgICAgICAgICAgIGlmICh2YWx1ZSAmJiB2YWx1ZS5mcm9tIDw9IGVuZCAmJiB2YWx1ZS5mcm9tID49IHN0YXJ0ICYmIHZhbHVlLnRvID4gZW5kKVxyXG4gICAgICAgICAgICAgICAgZm91bmQgPSB2YWx1ZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZm91bmQ7XHJcbn1cclxuZnVuY3Rpb24gaXNVbmZpbmlzaGVkKG5vZGUpIHtcclxuICAgIGxldCBjaCA9IG5vZGUubGFzdENoaWxkO1xyXG4gICAgcmV0dXJuIGNoICYmIGNoLnRvID09IG5vZGUudG8gJiYgY2gudHlwZS5pc0Vycm9yO1xyXG59XHJcbi8qKlxyXG5DaGVjayB3aGV0aGVyIHRoZSBnaXZlbiBsaW5lIGlzIGZvbGRhYmxlLiBGaXJzdCBhc2tzIGFueSBmb2xkXHJcbnNlcnZpY2VzIHJlZ2lzdGVyZWQgdGhyb3VnaFxyXG5bYGZvbGRTZXJ2aWNlYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNsYW5ndWFnZS5mb2xkU2VydmljZSksIGFuZCBpZiBub25lIG9mIHRoZW0gcmV0dXJuXHJcbmEgcmVzdWx0LCB0cmllcyB0byBxdWVyeSB0aGUgW2ZvbGQgbm9kZVxyXG5wcm9wXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2xhbmd1YWdlLmZvbGROb2RlUHJvcCkgb2Ygc3ludGF4IG5vZGVzIHRoYXQgY292ZXIgdGhlIGVuZFxyXG5vZiB0aGUgbGluZS5cclxuKi9cclxuZnVuY3Rpb24gZm9sZGFibGUoc3RhdGUsIGxpbmVTdGFydCwgbGluZUVuZCkge1xyXG4gICAgZm9yIChsZXQgc2VydmljZSBvZiBzdGF0ZS5mYWNldChmb2xkU2VydmljZSkpIHtcclxuICAgICAgICBsZXQgcmVzdWx0ID0gc2VydmljZShzdGF0ZSwgbGluZVN0YXJ0LCBsaW5lRW5kKTtcclxuICAgICAgICBpZiAocmVzdWx0KVxyXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHN5bnRheEZvbGRpbmcoc3RhdGUsIGxpbmVTdGFydCwgbGluZUVuZCk7XHJcbn1cclxuZnVuY3Rpb24gbWFwUmFuZ2UocmFuZ2UsIG1hcHBpbmcpIHtcclxuICAgIGxldCBmcm9tID0gbWFwcGluZy5tYXBQb3MocmFuZ2UuZnJvbSwgMSksIHRvID0gbWFwcGluZy5tYXBQb3MocmFuZ2UudG8sIC0xKTtcclxuICAgIHJldHVybiBmcm9tID49IHRvID8gdW5kZWZpbmVkIDogeyBmcm9tLCB0byB9O1xyXG59XHJcbi8qKlxyXG5TdGF0ZSBlZmZlY3QgdGhhdCBjYW4gYmUgYXR0YWNoZWQgdG8gYSB0cmFuc2FjdGlvbiB0byBmb2xkIHRoZVxyXG5naXZlbiByYW5nZS4gKFlvdSBwcm9iYWJseSBvbmx5IG5lZWQgdGhpcyBpbiBleGNlcHRpb25hbFxyXG5jaXJjdW1zdGFuY2Vz4oCUdXN1YWxseSB5b3UnbGwganVzdCB3YW50IHRvIGxldFxyXG5bYGZvbGRDb2RlYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNsYW5ndWFnZS5mb2xkQ29kZSkgYW5kIHRoZSBbZm9sZFxyXG5ndXR0ZXJdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jbGFuZ3VhZ2UuZm9sZEd1dHRlcikgY3JlYXRlIHRoZSB0cmFuc2FjdGlvbnMuKVxyXG4qL1xyXG5jb25zdCBmb2xkRWZmZWN0ID0gLypAX19QVVJFX18qL1N0YXRlRWZmZWN0LmRlZmluZSh7IG1hcDogbWFwUmFuZ2UgfSk7XHJcbi8qKlxyXG5TdGF0ZSBlZmZlY3QgdGhhdCB1bmZvbGRzIHRoZSBnaXZlbiByYW5nZSAoaWYgaXQgd2FzIGZvbGRlZCkuXHJcbiovXHJcbmNvbnN0IHVuZm9sZEVmZmVjdCA9IC8qQF9fUFVSRV9fKi9TdGF0ZUVmZmVjdC5kZWZpbmUoeyBtYXA6IG1hcFJhbmdlIH0pO1xyXG5mdW5jdGlvbiBzZWxlY3RlZExpbmVzKHZpZXcpIHtcclxuICAgIGxldCBsaW5lcyA9IFtdO1xyXG4gICAgZm9yIChsZXQgeyBoZWFkIH0gb2Ygdmlldy5zdGF0ZS5zZWxlY3Rpb24ucmFuZ2VzKSB7XHJcbiAgICAgICAgaWYgKGxpbmVzLnNvbWUobCA9PiBsLmZyb20gPD0gaGVhZCAmJiBsLnRvID49IGhlYWQpKVxyXG4gICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICBsaW5lcy5wdXNoKHZpZXcubGluZUJsb2NrQXQoaGVhZCkpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGxpbmVzO1xyXG59XHJcbi8qKlxyXG5UaGUgc3RhdGUgZmllbGQgdGhhdCBzdG9yZXMgdGhlIGZvbGRlZCByYW5nZXMgKGFzIGEgW2RlY29yYXRpb25cclxuc2V0XShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuRGVjb3JhdGlvblNldCkpLiBDYW4gYmUgcGFzc2VkIHRvXHJcbltgRWRpdG9yU3RhdGUudG9KU09OYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5FZGl0b3JTdGF0ZS50b0pTT04pIGFuZFxyXG5bYGZyb21KU09OYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5FZGl0b3JTdGF0ZV5mcm9tSlNPTikgdG8gc2VyaWFsaXplIHRoZSBmb2xkXHJcbnN0YXRlLlxyXG4qL1xyXG5jb25zdCBmb2xkU3RhdGUgPSAvKkBfX1BVUkVfXyovU3RhdGVGaWVsZC5kZWZpbmUoe1xyXG4gICAgY3JlYXRlKCkge1xyXG4gICAgICAgIHJldHVybiBEZWNvcmF0aW9uLm5vbmU7XHJcbiAgICB9LFxyXG4gICAgdXBkYXRlKGZvbGRlZCwgdHIpIHtcclxuICAgICAgICBmb2xkZWQgPSBmb2xkZWQubWFwKHRyLmNoYW5nZXMpO1xyXG4gICAgICAgIGZvciAobGV0IGUgb2YgdHIuZWZmZWN0cykge1xyXG4gICAgICAgICAgICBpZiAoZS5pcyhmb2xkRWZmZWN0KSAmJiAhZm9sZEV4aXN0cyhmb2xkZWQsIGUudmFsdWUuZnJvbSwgZS52YWx1ZS50bykpXHJcbiAgICAgICAgICAgICAgICBmb2xkZWQgPSBmb2xkZWQudXBkYXRlKHsgYWRkOiBbZm9sZFdpZGdldC5yYW5nZShlLnZhbHVlLmZyb20sIGUudmFsdWUudG8pXSB9KTtcclxuICAgICAgICAgICAgZWxzZSBpZiAoZS5pcyh1bmZvbGRFZmZlY3QpKVxyXG4gICAgICAgICAgICAgICAgZm9sZGVkID0gZm9sZGVkLnVwZGF0ZSh7IGZpbHRlcjogKGZyb20sIHRvKSA9PiBlLnZhbHVlLmZyb20gIT0gZnJvbSB8fCBlLnZhbHVlLnRvICE9IHRvLFxyXG4gICAgICAgICAgICAgICAgICAgIGZpbHRlckZyb206IGUudmFsdWUuZnJvbSwgZmlsdGVyVG86IGUudmFsdWUudG8gfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIENsZWFyIGZvbGRlZCByYW5nZXMgdGhhdCBjb3ZlciB0aGUgc2VsZWN0aW9uIGhlYWRcclxuICAgICAgICBpZiAodHIuc2VsZWN0aW9uKSB7XHJcbiAgICAgICAgICAgIGxldCBvblNlbGVjdGlvbiA9IGZhbHNlLCB7IGhlYWQgfSA9IHRyLnNlbGVjdGlvbi5tYWluO1xyXG4gICAgICAgICAgICBmb2xkZWQuYmV0d2VlbihoZWFkLCBoZWFkLCAoYSwgYikgPT4geyBpZiAoYSA8IGhlYWQgJiYgYiA+IGhlYWQpXHJcbiAgICAgICAgICAgICAgICBvblNlbGVjdGlvbiA9IHRydWU7IH0pO1xyXG4gICAgICAgICAgICBpZiAob25TZWxlY3Rpb24pXHJcbiAgICAgICAgICAgICAgICBmb2xkZWQgPSBmb2xkZWQudXBkYXRlKHtcclxuICAgICAgICAgICAgICAgICAgICBmaWx0ZXJGcm9tOiBoZWFkLFxyXG4gICAgICAgICAgICAgICAgICAgIGZpbHRlclRvOiBoZWFkLFxyXG4gICAgICAgICAgICAgICAgICAgIGZpbHRlcjogKGEsIGIpID0+IGIgPD0gaGVhZCB8fCBhID49IGhlYWRcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZm9sZGVkO1xyXG4gICAgfSxcclxuICAgIHByb3ZpZGU6IGYgPT4gRWRpdG9yVmlldy5kZWNvcmF0aW9ucy5mcm9tKGYpLFxyXG4gICAgdG9KU09OKGZvbGRlZCwgc3RhdGUpIHtcclxuICAgICAgICBsZXQgcmFuZ2VzID0gW107XHJcbiAgICAgICAgZm9sZGVkLmJldHdlZW4oMCwgc3RhdGUuZG9jLmxlbmd0aCwgKGZyb20sIHRvKSA9PiB7IHJhbmdlcy5wdXNoKGZyb20sIHRvKTsgfSk7XHJcbiAgICAgICAgcmV0dXJuIHJhbmdlcztcclxuICAgIH0sXHJcbiAgICBmcm9tSlNPTih2YWx1ZSkge1xyXG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheSh2YWx1ZSkgfHwgdmFsdWUubGVuZ3RoICUgMilcclxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIEpTT04gZm9yIGZvbGQgc3RhdGVcIik7XHJcbiAgICAgICAgbGV0IHJhbmdlcyA9IFtdO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWUubGVuZ3RoOykge1xyXG4gICAgICAgICAgICBsZXQgZnJvbSA9IHZhbHVlW2krK10sIHRvID0gdmFsdWVbaSsrXTtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBmcm9tICE9IFwibnVtYmVyXCIgfHwgdHlwZW9mIHRvICE9IFwibnVtYmVyXCIpXHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgSlNPTiBmb3IgZm9sZCBzdGF0ZVwiKTtcclxuICAgICAgICAgICAgcmFuZ2VzLnB1c2goZm9sZFdpZGdldC5yYW5nZShmcm9tLCB0bykpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gRGVjb3JhdGlvbi5zZXQocmFuZ2VzLCB0cnVlKTtcclxuICAgIH1cclxufSk7XHJcbi8qKlxyXG5HZXQgYSBbcmFuZ2Ugc2V0XShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlJhbmdlU2V0KSBjb250YWluaW5nIHRoZSBmb2xkZWQgcmFuZ2VzXHJcbmluIHRoZSBnaXZlbiBzdGF0ZS5cclxuKi9cclxuZnVuY3Rpb24gZm9sZGVkUmFuZ2VzKHN0YXRlKSB7XHJcbiAgICByZXR1cm4gc3RhdGUuZmllbGQoZm9sZFN0YXRlLCBmYWxzZSkgfHwgUmFuZ2VTZXQuZW1wdHk7XHJcbn1cclxuZnVuY3Rpb24gZmluZEZvbGQoc3RhdGUsIGZyb20sIHRvKSB7XHJcbiAgICB2YXIgX2E7XHJcbiAgICBsZXQgZm91bmQgPSBudWxsO1xyXG4gICAgKF9hID0gc3RhdGUuZmllbGQoZm9sZFN0YXRlLCBmYWxzZSkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5iZXR3ZWVuKGZyb20sIHRvLCAoZnJvbSwgdG8pID0+IHtcclxuICAgICAgICBpZiAoIWZvdW5kIHx8IGZvdW5kLmZyb20gPiBmcm9tKVxyXG4gICAgICAgICAgICBmb3VuZCA9IHsgZnJvbSwgdG8gfTtcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIGZvdW5kO1xyXG59XHJcbmZ1bmN0aW9uIGZvbGRFeGlzdHMoZm9sZGVkLCBmcm9tLCB0bykge1xyXG4gICAgbGV0IGZvdW5kID0gZmFsc2U7XHJcbiAgICBmb2xkZWQuYmV0d2Vlbihmcm9tLCBmcm9tLCAoYSwgYikgPT4geyBpZiAoYSA9PSBmcm9tICYmIGIgPT0gdG8pXHJcbiAgICAgICAgZm91bmQgPSB0cnVlOyB9KTtcclxuICAgIHJldHVybiBmb3VuZDtcclxufVxyXG5mdW5jdGlvbiBtYXliZUVuYWJsZShzdGF0ZSwgb3RoZXIpIHtcclxuICAgIHJldHVybiBzdGF0ZS5maWVsZChmb2xkU3RhdGUsIGZhbHNlKSA/IG90aGVyIDogb3RoZXIuY29uY2F0KFN0YXRlRWZmZWN0LmFwcGVuZENvbmZpZy5vZihjb2RlRm9sZGluZygpKSk7XHJcbn1cclxuLyoqXHJcbkZvbGQgdGhlIGxpbmVzIHRoYXQgYXJlIHNlbGVjdGVkLCBpZiBwb3NzaWJsZS5cclxuKi9cclxuY29uc3QgZm9sZENvZGUgPSB2aWV3ID0+IHtcclxuICAgIGZvciAobGV0IGxpbmUgb2Ygc2VsZWN0ZWRMaW5lcyh2aWV3KSkge1xyXG4gICAgICAgIGxldCByYW5nZSA9IGZvbGRhYmxlKHZpZXcuc3RhdGUsIGxpbmUuZnJvbSwgbGluZS50byk7XHJcbiAgICAgICAgaWYgKHJhbmdlKSB7XHJcbiAgICAgICAgICAgIHZpZXcuZGlzcGF0Y2goeyBlZmZlY3RzOiBtYXliZUVuYWJsZSh2aWV3LnN0YXRlLCBbZm9sZEVmZmVjdC5vZihyYW5nZSksIGFubm91bmNlRm9sZCh2aWV3LCByYW5nZSldKSB9KTtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG59O1xyXG4vKipcclxuVW5mb2xkIGZvbGRlZCByYW5nZXMgb24gc2VsZWN0ZWQgbGluZXMuXHJcbiovXHJcbmNvbnN0IHVuZm9sZENvZGUgPSB2aWV3ID0+IHtcclxuICAgIGlmICghdmlldy5zdGF0ZS5maWVsZChmb2xkU3RhdGUsIGZhbHNlKSlcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICBsZXQgZWZmZWN0cyA9IFtdO1xyXG4gICAgZm9yIChsZXQgbGluZSBvZiBzZWxlY3RlZExpbmVzKHZpZXcpKSB7XHJcbiAgICAgICAgbGV0IGZvbGRlZCA9IGZpbmRGb2xkKHZpZXcuc3RhdGUsIGxpbmUuZnJvbSwgbGluZS50byk7XHJcbiAgICAgICAgaWYgKGZvbGRlZClcclxuICAgICAgICAgICAgZWZmZWN0cy5wdXNoKHVuZm9sZEVmZmVjdC5vZihmb2xkZWQpLCBhbm5vdW5jZUZvbGQodmlldywgZm9sZGVkLCBmYWxzZSkpO1xyXG4gICAgfVxyXG4gICAgaWYgKGVmZmVjdHMubGVuZ3RoKVxyXG4gICAgICAgIHZpZXcuZGlzcGF0Y2goeyBlZmZlY3RzIH0pO1xyXG4gICAgcmV0dXJuIGVmZmVjdHMubGVuZ3RoID4gMDtcclxufTtcclxuZnVuY3Rpb24gYW5ub3VuY2VGb2xkKHZpZXcsIHJhbmdlLCBmb2xkID0gdHJ1ZSkge1xyXG4gICAgbGV0IGxpbmVGcm9tID0gdmlldy5zdGF0ZS5kb2MubGluZUF0KHJhbmdlLmZyb20pLm51bWJlciwgbGluZVRvID0gdmlldy5zdGF0ZS5kb2MubGluZUF0KHJhbmdlLnRvKS5udW1iZXI7XHJcbiAgICByZXR1cm4gRWRpdG9yVmlldy5hbm5vdW5jZS5vZihgJHt2aWV3LnN0YXRlLnBocmFzZShmb2xkID8gXCJGb2xkZWQgbGluZXNcIiA6IFwiVW5mb2xkZWQgbGluZXNcIil9ICR7bGluZUZyb219ICR7dmlldy5zdGF0ZS5waHJhc2UoXCJ0b1wiKX0gJHtsaW5lVG99LmApO1xyXG59XHJcbi8qKlxyXG5Gb2xkIGFsbCB0b3AtbGV2ZWwgZm9sZGFibGUgcmFuZ2VzLiBOb3RlIHRoYXQsIGluIG1vc3QgY2FzZXMsXHJcbmZvbGRpbmcgaW5mb3JtYXRpb24gd2lsbCBkZXBlbmQgb24gdGhlIFtzeW50YXhcclxudHJlZV0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNsYW5ndWFnZS5zeW50YXhUcmVlKSwgYW5kIGZvbGRpbmcgZXZlcnl0aGluZyBtYXkgbm90IHdvcmtcclxucmVsaWFibHkgd2hlbiB0aGUgZG9jdW1lbnQgaGFzbid0IGJlZW4gZnVsbHkgcGFyc2VkIChlaXRoZXJcclxuYmVjYXVzZSB0aGUgZWRpdG9yIHN0YXRlIHdhcyBvbmx5IGp1c3QgaW5pdGlhbGl6ZWQsIG9yIGJlY2F1c2UgdGhlXHJcbmRvY3VtZW50IGlzIHNvIGJpZyB0aGF0IHRoZSBwYXJzZXIgZGVjaWRlZCBub3QgdG8gcGFyc2UgaXRcclxuZW50aXJlbHkpLlxyXG4qL1xyXG5jb25zdCBmb2xkQWxsID0gdmlldyA9PiB7XHJcbiAgICBsZXQgeyBzdGF0ZSB9ID0gdmlldywgZWZmZWN0cyA9IFtdO1xyXG4gICAgZm9yIChsZXQgcG9zID0gMDsgcG9zIDwgc3RhdGUuZG9jLmxlbmd0aDspIHtcclxuICAgICAgICBsZXQgbGluZSA9IHZpZXcubGluZUJsb2NrQXQocG9zKSwgcmFuZ2UgPSBmb2xkYWJsZShzdGF0ZSwgbGluZS5mcm9tLCBsaW5lLnRvKTtcclxuICAgICAgICBpZiAocmFuZ2UpXHJcbiAgICAgICAgICAgIGVmZmVjdHMucHVzaChmb2xkRWZmZWN0Lm9mKHJhbmdlKSk7XHJcbiAgICAgICAgcG9zID0gKHJhbmdlID8gdmlldy5saW5lQmxvY2tBdChyYW5nZS50bykgOiBsaW5lKS50byArIDE7XHJcbiAgICB9XHJcbiAgICBpZiAoZWZmZWN0cy5sZW5ndGgpXHJcbiAgICAgICAgdmlldy5kaXNwYXRjaCh7IGVmZmVjdHM6IG1heWJlRW5hYmxlKHZpZXcuc3RhdGUsIGVmZmVjdHMpIH0pO1xyXG4gICAgcmV0dXJuICEhZWZmZWN0cy5sZW5ndGg7XHJcbn07XHJcbi8qKlxyXG5VbmZvbGQgYWxsIGZvbGRlZCBjb2RlLlxyXG4qL1xyXG5jb25zdCB1bmZvbGRBbGwgPSB2aWV3ID0+IHtcclxuICAgIGxldCBmaWVsZCA9IHZpZXcuc3RhdGUuZmllbGQoZm9sZFN0YXRlLCBmYWxzZSk7XHJcbiAgICBpZiAoIWZpZWxkIHx8ICFmaWVsZC5zaXplKVxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIGxldCBlZmZlY3RzID0gW107XHJcbiAgICBmaWVsZC5iZXR3ZWVuKDAsIHZpZXcuc3RhdGUuZG9jLmxlbmd0aCwgKGZyb20sIHRvKSA9PiB7IGVmZmVjdHMucHVzaCh1bmZvbGRFZmZlY3Qub2YoeyBmcm9tLCB0byB9KSk7IH0pO1xyXG4gICAgdmlldy5kaXNwYXRjaCh7IGVmZmVjdHMgfSk7XHJcbiAgICByZXR1cm4gdHJ1ZTtcclxufTtcclxuLyoqXHJcbkRlZmF1bHQgZm9sZC1yZWxhdGVkIGtleSBiaW5kaW5ncy5cclxuXHJcbiAtIEN0cmwtU2hpZnQtWyAoQ21kLUFsdC1bIG9uIG1hY09TKTogW2Bmb2xkQ29kZWBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jbGFuZ3VhZ2UuZm9sZENvZGUpLlxyXG4gLSBDdHJsLVNoaWZ0LV0gKENtZC1BbHQtXSBvbiBtYWNPUyk6IFtgdW5mb2xkQ29kZWBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jbGFuZ3VhZ2UudW5mb2xkQ29kZSkuXHJcbiAtIEN0cmwtQWx0LVs6IFtgZm9sZEFsbGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jbGFuZ3VhZ2UuZm9sZEFsbCkuXHJcbiAtIEN0cmwtQWx0LV06IFtgdW5mb2xkQWxsYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNsYW5ndWFnZS51bmZvbGRBbGwpLlxyXG4qL1xyXG5jb25zdCBmb2xkS2V5bWFwID0gW1xyXG4gICAgeyBrZXk6IFwiQ3RybC1TaGlmdC1bXCIsIG1hYzogXCJDbWQtQWx0LVtcIiwgcnVuOiBmb2xkQ29kZSB9LFxyXG4gICAgeyBrZXk6IFwiQ3RybC1TaGlmdC1dXCIsIG1hYzogXCJDbWQtQWx0LV1cIiwgcnVuOiB1bmZvbGRDb2RlIH0sXHJcbiAgICB7IGtleTogXCJDdHJsLUFsdC1bXCIsIHJ1bjogZm9sZEFsbCB9LFxyXG4gICAgeyBrZXk6IFwiQ3RybC1BbHQtXVwiLCBydW46IHVuZm9sZEFsbCB9XHJcbl07XHJcbmNvbnN0IGRlZmF1bHRDb25maWcgPSB7XHJcbiAgICBwbGFjZWhvbGRlckRPTTogbnVsbCxcclxuICAgIHBsYWNlaG9sZGVyVGV4dDogXCLigKZcIlxyXG59O1xyXG5jb25zdCBmb2xkQ29uZmlnID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSh7XHJcbiAgICBjb21iaW5lKHZhbHVlcykgeyByZXR1cm4gY29tYmluZUNvbmZpZyh2YWx1ZXMsIGRlZmF1bHRDb25maWcpOyB9XHJcbn0pO1xyXG4vKipcclxuQ3JlYXRlIGFuIGV4dGVuc2lvbiB0aGF0IGNvbmZpZ3VyZXMgY29kZSBmb2xkaW5nLlxyXG4qL1xyXG5mdW5jdGlvbiBjb2RlRm9sZGluZyhjb25maWcpIHtcclxuICAgIGxldCByZXN1bHQgPSBbZm9sZFN0YXRlLCBiYXNlVGhlbWUkMV07XHJcbiAgICBpZiAoY29uZmlnKVxyXG4gICAgICAgIHJlc3VsdC5wdXNoKGZvbGRDb25maWcub2YoY29uZmlnKSk7XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59XHJcbmNvbnN0IGZvbGRXaWRnZXQgPSAvKkBfX1BVUkVfXyovRGVjb3JhdGlvbi5yZXBsYWNlKHsgd2lkZ2V0OiAvKkBfX1BVUkVfXyovbmV3IGNsYXNzIGV4dGVuZHMgV2lkZ2V0VHlwZSB7XHJcbiAgICAgICAgdG9ET00odmlldykge1xyXG4gICAgICAgICAgICBsZXQgeyBzdGF0ZSB9ID0gdmlldywgY29uZiA9IHN0YXRlLmZhY2V0KGZvbGRDb25maWcpO1xyXG4gICAgICAgICAgICBsZXQgb25jbGljayA9IChldmVudCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgbGV0IGxpbmUgPSB2aWV3LmxpbmVCbG9ja0F0KHZpZXcucG9zQXRET00oZXZlbnQudGFyZ2V0KSk7XHJcbiAgICAgICAgICAgICAgICBsZXQgZm9sZGVkID0gZmluZEZvbGQodmlldy5zdGF0ZSwgbGluZS5mcm9tLCBsaW5lLnRvKTtcclxuICAgICAgICAgICAgICAgIGlmIChmb2xkZWQpXHJcbiAgICAgICAgICAgICAgICAgICAgdmlldy5kaXNwYXRjaCh7IGVmZmVjdHM6IHVuZm9sZEVmZmVjdC5vZihmb2xkZWQpIH0pO1xyXG4gICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgaWYgKGNvbmYucGxhY2Vob2xkZXJET00pXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY29uZi5wbGFjZWhvbGRlckRPTSh2aWV3LCBvbmNsaWNrKTtcclxuICAgICAgICAgICAgbGV0IGVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3BhblwiKTtcclxuICAgICAgICAgICAgZWxlbWVudC50ZXh0Q29udGVudCA9IGNvbmYucGxhY2Vob2xkZXJUZXh0O1xyXG4gICAgICAgICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZShcImFyaWEtbGFiZWxcIiwgc3RhdGUucGhyYXNlKFwiZm9sZGVkIGNvZGVcIikpO1xyXG4gICAgICAgICAgICBlbGVtZW50LnRpdGxlID0gc3RhdGUucGhyYXNlKFwidW5mb2xkXCIpO1xyXG4gICAgICAgICAgICBlbGVtZW50LmNsYXNzTmFtZSA9IFwiY20tZm9sZFBsYWNlaG9sZGVyXCI7XHJcbiAgICAgICAgICAgIGVsZW1lbnQub25jbGljayA9IG9uY2xpY2s7XHJcbiAgICAgICAgICAgIHJldHVybiBlbGVtZW50O1xyXG4gICAgICAgIH1cclxuICAgIH0gfSk7XHJcbmNvbnN0IGZvbGRHdXR0ZXJEZWZhdWx0cyA9IHtcclxuICAgIG9wZW5UZXh0OiBcIuKMhFwiLFxyXG4gICAgY2xvc2VkVGV4dDogXCLigLpcIixcclxuICAgIG1hcmtlckRPTTogbnVsbCxcclxuICAgIGRvbUV2ZW50SGFuZGxlcnM6IHt9LFxyXG4gICAgZm9sZGluZ0NoYW5nZWQ6ICgpID0+IGZhbHNlXHJcbn07XHJcbmNsYXNzIEZvbGRNYXJrZXIgZXh0ZW5kcyBHdXR0ZXJNYXJrZXIge1xyXG4gICAgY29uc3RydWN0b3IoY29uZmlnLCBvcGVuKSB7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuICAgICAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZztcclxuICAgICAgICB0aGlzLm9wZW4gPSBvcGVuO1xyXG4gICAgfVxyXG4gICAgZXEob3RoZXIpIHsgcmV0dXJuIHRoaXMuY29uZmlnID09IG90aGVyLmNvbmZpZyAmJiB0aGlzLm9wZW4gPT0gb3RoZXIub3BlbjsgfVxyXG4gICAgdG9ET00odmlldykge1xyXG4gICAgICAgIGlmICh0aGlzLmNvbmZpZy5tYXJrZXJET00pXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbmZpZy5tYXJrZXJET00odGhpcy5vcGVuKTtcclxuICAgICAgICBsZXQgc3BhbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpO1xyXG4gICAgICAgIHNwYW4udGV4dENvbnRlbnQgPSB0aGlzLm9wZW4gPyB0aGlzLmNvbmZpZy5vcGVuVGV4dCA6IHRoaXMuY29uZmlnLmNsb3NlZFRleHQ7XHJcbiAgICAgICAgc3Bhbi50aXRsZSA9IHZpZXcuc3RhdGUucGhyYXNlKHRoaXMub3BlbiA/IFwiRm9sZCBsaW5lXCIgOiBcIlVuZm9sZCBsaW5lXCIpO1xyXG4gICAgICAgIHJldHVybiBzcGFuO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG5DcmVhdGUgYW4gZXh0ZW5zaW9uIHRoYXQgcmVnaXN0ZXJzIGEgZm9sZCBndXR0ZXIsIHdoaWNoIHNob3dzIGFcclxuZm9sZCBzdGF0dXMgaW5kaWNhdG9yIGJlZm9yZSBmb2xkYWJsZSBsaW5lcyAod2hpY2ggY2FuIGJlIGNsaWNrZWRcclxudG8gZm9sZCBvciB1bmZvbGQgdGhlIGxpbmUpLlxyXG4qL1xyXG5mdW5jdGlvbiBmb2xkR3V0dGVyKGNvbmZpZyA9IHt9KSB7XHJcbiAgICBsZXQgZnVsbENvbmZpZyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgZm9sZEd1dHRlckRlZmF1bHRzKSwgY29uZmlnKTtcclxuICAgIGxldCBjYW5Gb2xkID0gbmV3IEZvbGRNYXJrZXIoZnVsbENvbmZpZywgdHJ1ZSksIGNhblVuZm9sZCA9IG5ldyBGb2xkTWFya2VyKGZ1bGxDb25maWcsIGZhbHNlKTtcclxuICAgIGxldCBtYXJrZXJzID0gVmlld1BsdWdpbi5mcm9tQ2xhc3MoY2xhc3Mge1xyXG4gICAgICAgIGNvbnN0cnVjdG9yKHZpZXcpIHtcclxuICAgICAgICAgICAgdGhpcy5mcm9tID0gdmlldy52aWV3cG9ydC5mcm9tO1xyXG4gICAgICAgICAgICB0aGlzLm1hcmtlcnMgPSB0aGlzLmJ1aWxkTWFya2Vycyh2aWV3KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdXBkYXRlKHVwZGF0ZSkge1xyXG4gICAgICAgICAgICBpZiAodXBkYXRlLmRvY0NoYW5nZWQgfHwgdXBkYXRlLnZpZXdwb3J0Q2hhbmdlZCB8fFxyXG4gICAgICAgICAgICAgICAgdXBkYXRlLnN0YXJ0U3RhdGUuZmFjZXQobGFuZ3VhZ2UpICE9IHVwZGF0ZS5zdGF0ZS5mYWNldChsYW5ndWFnZSkgfHxcclxuICAgICAgICAgICAgICAgIHVwZGF0ZS5zdGFydFN0YXRlLmZpZWxkKGZvbGRTdGF0ZSwgZmFsc2UpICE9IHVwZGF0ZS5zdGF0ZS5maWVsZChmb2xkU3RhdGUsIGZhbHNlKSB8fFxyXG4gICAgICAgICAgICAgICAgc3ludGF4VHJlZSh1cGRhdGUuc3RhcnRTdGF0ZSkgIT0gc3ludGF4VHJlZSh1cGRhdGUuc3RhdGUpIHx8XHJcbiAgICAgICAgICAgICAgICBmdWxsQ29uZmlnLmZvbGRpbmdDaGFuZ2VkKHVwZGF0ZSkpXHJcbiAgICAgICAgICAgICAgICB0aGlzLm1hcmtlcnMgPSB0aGlzLmJ1aWxkTWFya2Vycyh1cGRhdGUudmlldyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGJ1aWxkTWFya2Vycyh2aWV3KSB7XHJcbiAgICAgICAgICAgIGxldCBidWlsZGVyID0gbmV3IFJhbmdlU2V0QnVpbGRlcigpO1xyXG4gICAgICAgICAgICBmb3IgKGxldCBsaW5lIG9mIHZpZXcudmlld3BvcnRMaW5lQmxvY2tzKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgbWFyayA9IGZpbmRGb2xkKHZpZXcuc3RhdGUsIGxpbmUuZnJvbSwgbGluZS50bykgPyBjYW5VbmZvbGRcclxuICAgICAgICAgICAgICAgICAgICA6IGZvbGRhYmxlKHZpZXcuc3RhdGUsIGxpbmUuZnJvbSwgbGluZS50bykgPyBjYW5Gb2xkIDogbnVsbDtcclxuICAgICAgICAgICAgICAgIGlmIChtYXJrKVxyXG4gICAgICAgICAgICAgICAgICAgIGJ1aWxkZXIuYWRkKGxpbmUuZnJvbSwgbGluZS5mcm9tLCBtYXJrKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gYnVpbGRlci5maW5pc2goKTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuICAgIGxldCB7IGRvbUV2ZW50SGFuZGxlcnMgfSA9IGZ1bGxDb25maWc7XHJcbiAgICByZXR1cm4gW1xyXG4gICAgICAgIG1hcmtlcnMsXHJcbiAgICAgICAgZ3V0dGVyKHtcclxuICAgICAgICAgICAgY2xhc3M6IFwiY20tZm9sZEd1dHRlclwiLFxyXG4gICAgICAgICAgICBtYXJrZXJzKHZpZXcpIHsgdmFyIF9hOyByZXR1cm4gKChfYSA9IHZpZXcucGx1Z2luKG1hcmtlcnMpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubWFya2VycykgfHwgUmFuZ2VTZXQuZW1wdHk7IH0sXHJcbiAgICAgICAgICAgIGluaXRpYWxTcGFjZXIoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEZvbGRNYXJrZXIoZnVsbENvbmZpZywgZmFsc2UpO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBkb21FdmVudEhhbmRsZXJzOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGRvbUV2ZW50SGFuZGxlcnMpLCB7IGNsaWNrOiAodmlldywgbGluZSwgZXZlbnQpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZG9tRXZlbnRIYW5kbGVycy5jbGljayAmJiBkb21FdmVudEhhbmRsZXJzLmNsaWNrKHZpZXcsIGxpbmUsIGV2ZW50KSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IGZvbGRlZCA9IGZpbmRGb2xkKHZpZXcuc3RhdGUsIGxpbmUuZnJvbSwgbGluZS50byk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZvbGRlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2aWV3LmRpc3BhdGNoKHsgZWZmZWN0czogdW5mb2xkRWZmZWN0Lm9mKGZvbGRlZCkgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBsZXQgcmFuZ2UgPSBmb2xkYWJsZSh2aWV3LnN0YXRlLCBsaW5lLmZyb20sIGxpbmUudG8pO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChyYW5nZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2aWV3LmRpc3BhdGNoKHsgZWZmZWN0czogZm9sZEVmZmVjdC5vZihyYW5nZSkgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9IH0pXHJcbiAgICAgICAgfSksXHJcbiAgICAgICAgY29kZUZvbGRpbmcoKVxyXG4gICAgXTtcclxufVxyXG5jb25zdCBiYXNlVGhlbWUkMSA9IC8qQF9fUFVSRV9fKi9FZGl0b3JWaWV3LmJhc2VUaGVtZSh7XHJcbiAgICBcIi5jbS1mb2xkUGxhY2Vob2xkZXJcIjoge1xyXG4gICAgICAgIGJhY2tncm91bmRDb2xvcjogXCIjZWVlXCIsXHJcbiAgICAgICAgYm9yZGVyOiBcIjFweCBzb2xpZCAjZGRkXCIsXHJcbiAgICAgICAgY29sb3I6IFwiIzg4OFwiLFxyXG4gICAgICAgIGJvcmRlclJhZGl1czogXCIuMmVtXCIsXHJcbiAgICAgICAgbWFyZ2luOiBcIjAgMXB4XCIsXHJcbiAgICAgICAgcGFkZGluZzogXCIwIDFweFwiLFxyXG4gICAgICAgIGN1cnNvcjogXCJwb2ludGVyXCJcclxuICAgIH0sXHJcbiAgICBcIi5jbS1mb2xkR3V0dGVyIHNwYW5cIjoge1xyXG4gICAgICAgIHBhZGRpbmc6IFwiMCAxcHhcIixcclxuICAgICAgICBjdXJzb3I6IFwicG9pbnRlclwiXHJcbiAgICB9XHJcbn0pO1xyXG5cclxuLyoqXHJcbkEgaGlnaGxpZ2h0IHN0eWxlIGFzc29jaWF0ZXMgQ1NTIHN0eWxlcyB3aXRoIGhpZ2xpZ2h0aW5nXHJcblt0YWdzXShodHRwczovL2xlemVyLmNvZGVtaXJyb3IubmV0L2RvY3MvcmVmI2hpZ2hsaWdodC5UYWcpLlxyXG4qL1xyXG5jbGFzcyBIaWdobGlnaHRTdHlsZSB7XHJcbiAgICBjb25zdHJ1Y3RvcihcclxuICAgIC8qKlxyXG4gICAgVGhlIHRhZyBzdHlsZXMgdXNlZCB0byBjcmVhdGUgdGhpcyBoaWdobGlnaHQgc3R5bGUuXHJcbiAgICAqL1xyXG4gICAgc3BlY3MsIG9wdGlvbnMpIHtcclxuICAgICAgICB0aGlzLnNwZWNzID0gc3BlY3M7XHJcbiAgICAgICAgbGV0IG1vZFNwZWM7XHJcbiAgICAgICAgZnVuY3Rpb24gZGVmKHNwZWMpIHtcclxuICAgICAgICAgICAgbGV0IGNscyA9IFN0eWxlTW9kdWxlLm5ld05hbWUoKTtcclxuICAgICAgICAgICAgKG1vZFNwZWMgfHwgKG1vZFNwZWMgPSBPYmplY3QuY3JlYXRlKG51bGwpKSlbXCIuXCIgKyBjbHNdID0gc3BlYztcclxuICAgICAgICAgICAgcmV0dXJuIGNscztcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgYWxsID0gdHlwZW9mIG9wdGlvbnMuYWxsID09IFwic3RyaW5nXCIgPyBvcHRpb25zLmFsbCA6IG9wdGlvbnMuYWxsID8gZGVmKG9wdGlvbnMuYWxsKSA6IHVuZGVmaW5lZDtcclxuICAgICAgICBjb25zdCBzY29wZU9wdCA9IG9wdGlvbnMuc2NvcGU7XHJcbiAgICAgICAgdGhpcy5zY29wZSA9IHNjb3BlT3B0IGluc3RhbmNlb2YgTGFuZ3VhZ2UgPyAodHlwZSkgPT4gdHlwZS5wcm9wKGxhbmd1YWdlRGF0YVByb3ApID09IHNjb3BlT3B0LmRhdGFcclxuICAgICAgICAgICAgOiBzY29wZU9wdCA/ICh0eXBlKSA9PiB0eXBlID09IHNjb3BlT3B0IDogdW5kZWZpbmVkO1xyXG4gICAgICAgIHRoaXMuc3R5bGUgPSB0YWdIaWdobGlnaHRlcihzcGVjcy5tYXAoc3R5bGUgPT4gKHtcclxuICAgICAgICAgICAgdGFnOiBzdHlsZS50YWcsXHJcbiAgICAgICAgICAgIGNsYXNzOiBzdHlsZS5jbGFzcyB8fCBkZWYoT2JqZWN0LmFzc2lnbih7fSwgc3R5bGUsIHsgdGFnOiBudWxsIH0pKVxyXG4gICAgICAgIH0pKSwge1xyXG4gICAgICAgICAgICBhbGwsXHJcbiAgICAgICAgfSkuc3R5bGU7XHJcbiAgICAgICAgdGhpcy5tb2R1bGUgPSBtb2RTcGVjID8gbmV3IFN0eWxlTW9kdWxlKG1vZFNwZWMpIDogbnVsbDtcclxuICAgICAgICB0aGlzLnRoZW1lVHlwZSA9IG9wdGlvbnMudGhlbWVUeXBlO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICBDcmVhdGUgYSBoaWdobGlnaHRlciBzdHlsZSB0aGF0IGFzc29jaWF0ZXMgdGhlIGdpdmVuIHN0eWxlcyB0b1xyXG4gICAgdGhlIGdpdmVuIHRhZ3MuIFRoZSBzcGVjcyBtdXN0IGJlIG9iamVjdHMgdGhhdCBob2xkIGEgc3R5bGUgdGFnXHJcbiAgICBvciBhcnJheSBvZiB0YWdzIGluIHRoZWlyIGB0YWdgIHByb3BlcnR5LCBhbmQgZWl0aGVyIGEgc2luZ2xlXHJcbiAgICBgY2xhc3NgIHByb3BlcnR5IHByb3ZpZGluZyBhIHN0YXRpYyBDU1MgY2xhc3MgKGZvciBoaWdobGlnaHRlclxyXG4gICAgdGhhdCByZWx5IG9uIGV4dGVybmFsIHN0eWxpbmcpLCBvciBhXHJcbiAgICBbYHN0eWxlLW1vZGBdKGh0dHBzOi8vZ2l0aHViLmNvbS9tYXJpam5oL3N0eWxlLW1vZCNkb2N1bWVudGF0aW9uKS1zdHlsZVxyXG4gICAgc2V0IG9mIENTUyBwcm9wZXJ0aWVzICh3aGljaCBkZWZpbmUgdGhlIHN0eWxpbmcgZm9yIHRob3NlIHRhZ3MpLlxyXG4gICAgXHJcbiAgICBUaGUgQ1NTIHJ1bGVzIGNyZWF0ZWQgZm9yIGEgaGlnaGxpZ2h0ZXIgd2lsbCBiZSBlbWl0dGVkIGluIHRoZVxyXG4gICAgb3JkZXIgb2YgdGhlIHNwZWMncyBwcm9wZXJ0aWVzLiBUaGF0IG1lYW5zIHRoYXQgZm9yIGVsZW1lbnRzIHRoYXRcclxuICAgIGhhdmUgbXVsdGlwbGUgdGFncyBhc3NvY2lhdGVkIHdpdGggdGhlbSwgc3R5bGVzIGRlZmluZWQgZnVydGhlclxyXG4gICAgZG93biBpbiB0aGUgbGlzdCB3aWxsIGhhdmUgYSBoaWdoZXIgQ1NTIHByZWNlZGVuY2UgdGhhbiBzdHlsZXNcclxuICAgIGRlZmluZWQgZWFybGllci5cclxuICAgICovXHJcbiAgICBzdGF0aWMgZGVmaW5lKHNwZWNzLCBvcHRpb25zKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBIaWdobGlnaHRTdHlsZShzcGVjcywgb3B0aW9ucyB8fCB7fSk7XHJcbiAgICB9XHJcbn1cclxuY29uc3QgaGlnaGxpZ2h0ZXJGYWNldCA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoKTtcclxuY29uc3QgZmFsbGJhY2tIaWdobGlnaHRlciA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoe1xyXG4gICAgY29tYmluZSh2YWx1ZXMpIHsgcmV0dXJuIHZhbHVlcy5sZW5ndGggPyBbdmFsdWVzWzBdXSA6IG51bGw7IH1cclxufSk7XHJcbmZ1bmN0aW9uIGdldEhpZ2hsaWdodGVycyhzdGF0ZSkge1xyXG4gICAgbGV0IG1haW4gPSBzdGF0ZS5mYWNldChoaWdobGlnaHRlckZhY2V0KTtcclxuICAgIHJldHVybiBtYWluLmxlbmd0aCA/IG1haW4gOiBzdGF0ZS5mYWNldChmYWxsYmFja0hpZ2hsaWdodGVyKTtcclxufVxyXG4vKipcclxuV3JhcCBhIGhpZ2hsaWdodGVyIGluIGFuIGVkaXRvciBleHRlbnNpb24gdGhhdCB1c2VzIGl0IHRvIGFwcGx5XHJcbnN5bnRheCBoaWdobGlnaHRpbmcgdG8gdGhlIGVkaXRvciBjb250ZW50LlxyXG5cclxuV2hlbiBtdWx0aXBsZSAobm9uLWZhbGxiYWNrKSBzdHlsZXMgYXJlIHByb3ZpZGVkLCB0aGUgc3R5bGluZ1xyXG5hcHBsaWVkIGlzIHRoZSB1bmlvbiBvZiB0aGUgY2xhc3NlcyB0aGV5IGVtaXQuXHJcbiovXHJcbmZ1bmN0aW9uIHN5bnRheEhpZ2hsaWdodGluZyhoaWdobGlnaHRlciwgb3B0aW9ucykge1xyXG4gICAgbGV0IGV4dCA9IFt0cmVlSGlnaGxpZ2h0ZXJdLCB0aGVtZVR5cGU7XHJcbiAgICBpZiAoaGlnaGxpZ2h0ZXIgaW5zdGFuY2VvZiBIaWdobGlnaHRTdHlsZSkge1xyXG4gICAgICAgIGlmIChoaWdobGlnaHRlci5tb2R1bGUpXHJcbiAgICAgICAgICAgIGV4dC5wdXNoKEVkaXRvclZpZXcuc3R5bGVNb2R1bGUub2YoaGlnaGxpZ2h0ZXIubW9kdWxlKSk7XHJcbiAgICAgICAgdGhlbWVUeXBlID0gaGlnaGxpZ2h0ZXIudGhlbWVUeXBlO1xyXG4gICAgfVxyXG4gICAgaWYgKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5mYWxsYmFjaylcclxuICAgICAgICBleHQucHVzaChmYWxsYmFja0hpZ2hsaWdodGVyLm9mKGhpZ2hsaWdodGVyKSk7XHJcbiAgICBlbHNlIGlmICh0aGVtZVR5cGUpXHJcbiAgICAgICAgZXh0LnB1c2goaGlnaGxpZ2h0ZXJGYWNldC5jb21wdXRlTihbRWRpdG9yVmlldy5kYXJrVGhlbWVdLCBzdGF0ZSA9PiB7XHJcbiAgICAgICAgICAgIHJldHVybiBzdGF0ZS5mYWNldChFZGl0b3JWaWV3LmRhcmtUaGVtZSkgPT0gKHRoZW1lVHlwZSA9PSBcImRhcmtcIikgPyBbaGlnaGxpZ2h0ZXJdIDogW107XHJcbiAgICAgICAgfSkpO1xyXG4gICAgZWxzZVxyXG4gICAgICAgIGV4dC5wdXNoKGhpZ2hsaWdodGVyRmFjZXQub2YoaGlnaGxpZ2h0ZXIpKTtcclxuICAgIHJldHVybiBleHQ7XHJcbn1cclxuLyoqXHJcblJldHVybnMgdGhlIENTUyBjbGFzc2VzIChpZiBhbnkpIHRoYXQgdGhlIGhpZ2hsaWdodGVycyBhY3RpdmUgaW5cclxudGhlIHN0YXRlIHdvdWxkIGFzc2lnbiB0byB0aGUgZ2l2ZW4gc3R5bGVcclxuW3RhZ3NdKGh0dHBzOi8vbGV6ZXIuY29kZW1pcnJvci5uZXQvZG9jcy9yZWYjaGlnaGxpZ2h0LlRhZykgYW5kXHJcbihvcHRpb25hbCkgbGFuZ3VhZ2VcclxuW3Njb3BlXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2xhbmd1YWdlLkhpZ2hsaWdodFN0eWxlXmRlZmluZV5vcHRpb25zLnNjb3BlKS5cclxuKi9cclxuZnVuY3Rpb24gaGlnaGxpZ2h0aW5nRm9yKHN0YXRlLCB0YWdzLCBzY29wZSkge1xyXG4gICAgbGV0IGhpZ2hsaWdodGVycyA9IGdldEhpZ2hsaWdodGVycyhzdGF0ZSk7XHJcbiAgICBsZXQgcmVzdWx0ID0gbnVsbDtcclxuICAgIGlmIChoaWdobGlnaHRlcnMpXHJcbiAgICAgICAgZm9yIChsZXQgaGlnaGxpZ2h0ZXIgb2YgaGlnaGxpZ2h0ZXJzKSB7XHJcbiAgICAgICAgICAgIGlmICghaGlnaGxpZ2h0ZXIuc2NvcGUgfHwgc2NvcGUgJiYgaGlnaGxpZ2h0ZXIuc2NvcGUoc2NvcGUpKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgY2xzID0gaGlnaGxpZ2h0ZXIuc3R5bGUodGFncyk7XHJcbiAgICAgICAgICAgICAgICBpZiAoY2xzKVxyXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdCA/IHJlc3VsdCArIFwiIFwiICsgY2xzIDogY2xzO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufVxyXG5jbGFzcyBUcmVlSGlnaGxpZ2h0ZXIge1xyXG4gICAgY29uc3RydWN0b3Iodmlldykge1xyXG4gICAgICAgIHRoaXMubWFya0NhY2hlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcclxuICAgICAgICB0aGlzLnRyZWUgPSBzeW50YXhUcmVlKHZpZXcuc3RhdGUpO1xyXG4gICAgICAgIHRoaXMuZGVjb3JhdGlvbnMgPSB0aGlzLmJ1aWxkRGVjbyh2aWV3LCBnZXRIaWdobGlnaHRlcnModmlldy5zdGF0ZSkpO1xyXG4gICAgfVxyXG4gICAgdXBkYXRlKHVwZGF0ZSkge1xyXG4gICAgICAgIGxldCB0cmVlID0gc3ludGF4VHJlZSh1cGRhdGUuc3RhdGUpLCBoaWdobGlnaHRlcnMgPSBnZXRIaWdobGlnaHRlcnModXBkYXRlLnN0YXRlKTtcclxuICAgICAgICBsZXQgc3R5bGVDaGFuZ2UgPSBoaWdobGlnaHRlcnMgIT0gZ2V0SGlnaGxpZ2h0ZXJzKHVwZGF0ZS5zdGFydFN0YXRlKTtcclxuICAgICAgICBpZiAodHJlZS5sZW5ndGggPCB1cGRhdGUudmlldy52aWV3cG9ydC50byAmJiAhc3R5bGVDaGFuZ2UgJiYgdHJlZS50eXBlID09IHRoaXMudHJlZS50eXBlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZGVjb3JhdGlvbnMgPSB0aGlzLmRlY29yYXRpb25zLm1hcCh1cGRhdGUuY2hhbmdlcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHRyZWUgIT0gdGhpcy50cmVlIHx8IHVwZGF0ZS52aWV3cG9ydENoYW5nZWQgfHwgc3R5bGVDaGFuZ2UpIHtcclxuICAgICAgICAgICAgdGhpcy50cmVlID0gdHJlZTtcclxuICAgICAgICAgICAgdGhpcy5kZWNvcmF0aW9ucyA9IHRoaXMuYnVpbGREZWNvKHVwZGF0ZS52aWV3LCBoaWdobGlnaHRlcnMpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGJ1aWxkRGVjbyh2aWV3LCBoaWdobGlnaHRlcnMpIHtcclxuICAgICAgICBpZiAoIWhpZ2hsaWdodGVycyB8fCAhdGhpcy50cmVlLmxlbmd0aClcclxuICAgICAgICAgICAgcmV0dXJuIERlY29yYXRpb24ubm9uZTtcclxuICAgICAgICBsZXQgYnVpbGRlciA9IG5ldyBSYW5nZVNldEJ1aWxkZXIoKTtcclxuICAgICAgICBmb3IgKGxldCB7IGZyb20sIHRvIH0gb2Ygdmlldy52aXNpYmxlUmFuZ2VzKSB7XHJcbiAgICAgICAgICAgIGhpZ2hsaWdodFRyZWUodGhpcy50cmVlLCBoaWdobGlnaHRlcnMsIChmcm9tLCB0bywgc3R5bGUpID0+IHtcclxuICAgICAgICAgICAgICAgIGJ1aWxkZXIuYWRkKGZyb20sIHRvLCB0aGlzLm1hcmtDYWNoZVtzdHlsZV0gfHwgKHRoaXMubWFya0NhY2hlW3N0eWxlXSA9IERlY29yYXRpb24ubWFyayh7IGNsYXNzOiBzdHlsZSB9KSkpO1xyXG4gICAgICAgICAgICB9LCBmcm9tLCB0byk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBidWlsZGVyLmZpbmlzaCgpO1xyXG4gICAgfVxyXG59XHJcbmNvbnN0IHRyZWVIaWdobGlnaHRlciA9IC8qQF9fUFVSRV9fKi9QcmVjLmhpZ2goLypAX19QVVJFX18qL1ZpZXdQbHVnaW4uZnJvbUNsYXNzKFRyZWVIaWdobGlnaHRlciwge1xyXG4gICAgZGVjb3JhdGlvbnM6IHYgPT4gdi5kZWNvcmF0aW9uc1xyXG59KSk7XHJcbi8qKlxyXG5BIGRlZmF1bHQgaGlnaGxpZ2h0IHN0eWxlICh3b3JrcyB3ZWxsIHdpdGggbGlnaHQgdGhlbWVzKS5cclxuKi9cclxuY29uc3QgZGVmYXVsdEhpZ2hsaWdodFN0eWxlID0gLypAX19QVVJFX18qL0hpZ2hsaWdodFN0eWxlLmRlZmluZShbXHJcbiAgICB7IHRhZzogdGFncy5tZXRhLFxyXG4gICAgICAgIGNvbG9yOiBcIiM0MDQ3NDBcIiB9LFxyXG4gICAgeyB0YWc6IHRhZ3MubGluayxcclxuICAgICAgICB0ZXh0RGVjb3JhdGlvbjogXCJ1bmRlcmxpbmVcIiB9LFxyXG4gICAgeyB0YWc6IHRhZ3MuaGVhZGluZyxcclxuICAgICAgICB0ZXh0RGVjb3JhdGlvbjogXCJ1bmRlcmxpbmVcIixcclxuICAgICAgICBmb250V2VpZ2h0OiBcImJvbGRcIiB9LFxyXG4gICAgeyB0YWc6IHRhZ3MuZW1waGFzaXMsXHJcbiAgICAgICAgZm9udFN0eWxlOiBcIml0YWxpY1wiIH0sXHJcbiAgICB7IHRhZzogdGFncy5zdHJvbmcsXHJcbiAgICAgICAgZm9udFdlaWdodDogXCJib2xkXCIgfSxcclxuICAgIHsgdGFnOiB0YWdzLnN0cmlrZXRocm91Z2gsXHJcbiAgICAgICAgdGV4dERlY29yYXRpb246IFwibGluZS10aHJvdWdoXCIgfSxcclxuICAgIHsgdGFnOiB0YWdzLmtleXdvcmQsXHJcbiAgICAgICAgY29sb3I6IFwiIzcwOFwiIH0sXHJcbiAgICB7IHRhZzogW3RhZ3MuYXRvbSwgdGFncy5ib29sLCB0YWdzLnVybCwgdGFncy5jb250ZW50U2VwYXJhdG9yLCB0YWdzLmxhYmVsTmFtZV0sXHJcbiAgICAgICAgY29sb3I6IFwiIzIxOVwiIH0sXHJcbiAgICB7IHRhZzogW3RhZ3MubGl0ZXJhbCwgdGFncy5pbnNlcnRlZF0sXHJcbiAgICAgICAgY29sb3I6IFwiIzE2NFwiIH0sXHJcbiAgICB7IHRhZzogW3RhZ3Muc3RyaW5nLCB0YWdzLmRlbGV0ZWRdLFxyXG4gICAgICAgIGNvbG9yOiBcIiNhMTFcIiB9LFxyXG4gICAgeyB0YWc6IFt0YWdzLnJlZ2V4cCwgdGFncy5lc2NhcGUsIC8qQF9fUFVSRV9fKi90YWdzLnNwZWNpYWwodGFncy5zdHJpbmcpXSxcclxuICAgICAgICBjb2xvcjogXCIjZTQwXCIgfSxcclxuICAgIHsgdGFnOiAvKkBfX1BVUkVfXyovdGFncy5kZWZpbml0aW9uKHRhZ3MudmFyaWFibGVOYW1lKSxcclxuICAgICAgICBjb2xvcjogXCIjMDBmXCIgfSxcclxuICAgIHsgdGFnOiAvKkBfX1BVUkVfXyovdGFncy5sb2NhbCh0YWdzLnZhcmlhYmxlTmFtZSksXHJcbiAgICAgICAgY29sb3I6IFwiIzMwYVwiIH0sXHJcbiAgICB7IHRhZzogW3RhZ3MudHlwZU5hbWUsIHRhZ3MubmFtZXNwYWNlXSxcclxuICAgICAgICBjb2xvcjogXCIjMDg1XCIgfSxcclxuICAgIHsgdGFnOiB0YWdzLmNsYXNzTmFtZSxcclxuICAgICAgICBjb2xvcjogXCIjMTY3XCIgfSxcclxuICAgIHsgdGFnOiBbLypAX19QVVJFX18qL3RhZ3Muc3BlY2lhbCh0YWdzLnZhcmlhYmxlTmFtZSksIHRhZ3MubWFjcm9OYW1lXSxcclxuICAgICAgICBjb2xvcjogXCIjMjU2XCIgfSxcclxuICAgIHsgdGFnOiAvKkBfX1BVUkVfXyovdGFncy5kZWZpbml0aW9uKHRhZ3MucHJvcGVydHlOYW1lKSxcclxuICAgICAgICBjb2xvcjogXCIjMDBjXCIgfSxcclxuICAgIHsgdGFnOiB0YWdzLmNvbW1lbnQsXHJcbiAgICAgICAgY29sb3I6IFwiIzk0MFwiIH0sXHJcbiAgICB7IHRhZzogdGFncy5pbnZhbGlkLFxyXG4gICAgICAgIGNvbG9yOiBcIiNmMDBcIiB9XHJcbl0pO1xyXG5cclxuY29uc3QgYmFzZVRoZW1lID0gLypAX19QVVJFX18qL0VkaXRvclZpZXcuYmFzZVRoZW1lKHtcclxuICAgIFwiJi5jbS1mb2N1c2VkIC5jbS1tYXRjaGluZ0JyYWNrZXRcIjogeyBiYWNrZ3JvdW5kQ29sb3I6IFwiIzMyOGM4MjUyXCIgfSxcclxuICAgIFwiJi5jbS1mb2N1c2VkIC5jbS1ub25tYXRjaGluZ0JyYWNrZXRcIjogeyBiYWNrZ3JvdW5kQ29sb3I6IFwiI2JiNTU1NTQ0XCIgfVxyXG59KTtcclxuY29uc3QgRGVmYXVsdFNjYW5EaXN0ID0gMTAwMDAsIERlZmF1bHRCcmFja2V0cyA9IFwiKClbXXt9XCI7XHJcbmNvbnN0IGJyYWNrZXRNYXRjaGluZ0NvbmZpZyA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoe1xyXG4gICAgY29tYmluZShjb25maWdzKSB7XHJcbiAgICAgICAgcmV0dXJuIGNvbWJpbmVDb25maWcoY29uZmlncywge1xyXG4gICAgICAgICAgICBhZnRlckN1cnNvcjogdHJ1ZSxcclxuICAgICAgICAgICAgYnJhY2tldHM6IERlZmF1bHRCcmFja2V0cyxcclxuICAgICAgICAgICAgbWF4U2NhbkRpc3RhbmNlOiBEZWZhdWx0U2NhbkRpc3QsXHJcbiAgICAgICAgICAgIHJlbmRlck1hdGNoOiBkZWZhdWx0UmVuZGVyTWF0Y2hcclxuICAgICAgICB9KTtcclxuICAgIH1cclxufSk7XHJcbmNvbnN0IG1hdGNoaW5nTWFyayA9IC8qQF9fUFVSRV9fKi9EZWNvcmF0aW9uLm1hcmsoeyBjbGFzczogXCJjbS1tYXRjaGluZ0JyYWNrZXRcIiB9KSwgbm9ubWF0Y2hpbmdNYXJrID0gLypAX19QVVJFX18qL0RlY29yYXRpb24ubWFyayh7IGNsYXNzOiBcImNtLW5vbm1hdGNoaW5nQnJhY2tldFwiIH0pO1xyXG5mdW5jdGlvbiBkZWZhdWx0UmVuZGVyTWF0Y2gobWF0Y2gpIHtcclxuICAgIGxldCBkZWNvcmF0aW9ucyA9IFtdO1xyXG4gICAgbGV0IG1hcmsgPSBtYXRjaC5tYXRjaGVkID8gbWF0Y2hpbmdNYXJrIDogbm9ubWF0Y2hpbmdNYXJrO1xyXG4gICAgZGVjb3JhdGlvbnMucHVzaChtYXJrLnJhbmdlKG1hdGNoLnN0YXJ0LmZyb20sIG1hdGNoLnN0YXJ0LnRvKSk7XHJcbiAgICBpZiAobWF0Y2guZW5kKVxyXG4gICAgICAgIGRlY29yYXRpb25zLnB1c2gobWFyay5yYW5nZShtYXRjaC5lbmQuZnJvbSwgbWF0Y2guZW5kLnRvKSk7XHJcbiAgICByZXR1cm4gZGVjb3JhdGlvbnM7XHJcbn1cclxuY29uc3QgYnJhY2tldE1hdGNoaW5nU3RhdGUgPSAvKkBfX1BVUkVfXyovU3RhdGVGaWVsZC5kZWZpbmUoe1xyXG4gICAgY3JlYXRlKCkgeyByZXR1cm4gRGVjb3JhdGlvbi5ub25lOyB9LFxyXG4gICAgdXBkYXRlKGRlY28sIHRyKSB7XHJcbiAgICAgICAgaWYgKCF0ci5kb2NDaGFuZ2VkICYmICF0ci5zZWxlY3Rpb24pXHJcbiAgICAgICAgICAgIHJldHVybiBkZWNvO1xyXG4gICAgICAgIGxldCBkZWNvcmF0aW9ucyA9IFtdO1xyXG4gICAgICAgIGxldCBjb25maWcgPSB0ci5zdGF0ZS5mYWNldChicmFja2V0TWF0Y2hpbmdDb25maWcpO1xyXG4gICAgICAgIGZvciAobGV0IHJhbmdlIG9mIHRyLnN0YXRlLnNlbGVjdGlvbi5yYW5nZXMpIHtcclxuICAgICAgICAgICAgaWYgKCFyYW5nZS5lbXB0eSlcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICBsZXQgbWF0Y2ggPSBtYXRjaEJyYWNrZXRzKHRyLnN0YXRlLCByYW5nZS5oZWFkLCAtMSwgY29uZmlnKVxyXG4gICAgICAgICAgICAgICAgfHwgKHJhbmdlLmhlYWQgPiAwICYmIG1hdGNoQnJhY2tldHModHIuc3RhdGUsIHJhbmdlLmhlYWQgLSAxLCAxLCBjb25maWcpKVxyXG4gICAgICAgICAgICAgICAgfHwgKGNvbmZpZy5hZnRlckN1cnNvciAmJlxyXG4gICAgICAgICAgICAgICAgICAgIChtYXRjaEJyYWNrZXRzKHRyLnN0YXRlLCByYW5nZS5oZWFkLCAxLCBjb25maWcpIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIChyYW5nZS5oZWFkIDwgdHIuc3RhdGUuZG9jLmxlbmd0aCAmJiBtYXRjaEJyYWNrZXRzKHRyLnN0YXRlLCByYW5nZS5oZWFkICsgMSwgLTEsIGNvbmZpZykpKSk7XHJcbiAgICAgICAgICAgIGlmIChtYXRjaClcclxuICAgICAgICAgICAgICAgIGRlY29yYXRpb25zID0gZGVjb3JhdGlvbnMuY29uY2F0KGNvbmZpZy5yZW5kZXJNYXRjaChtYXRjaCwgdHIuc3RhdGUpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIERlY29yYXRpb24uc2V0KGRlY29yYXRpb25zLCB0cnVlKTtcclxuICAgIH0sXHJcbiAgICBwcm92aWRlOiBmID0+IEVkaXRvclZpZXcuZGVjb3JhdGlvbnMuZnJvbShmKVxyXG59KTtcclxuY29uc3QgYnJhY2tldE1hdGNoaW5nVW5pcXVlID0gW1xyXG4gICAgYnJhY2tldE1hdGNoaW5nU3RhdGUsXHJcbiAgICBiYXNlVGhlbWVcclxuXTtcclxuLyoqXHJcbkNyZWF0ZSBhbiBleHRlbnNpb24gdGhhdCBlbmFibGVzIGJyYWNrZXQgbWF0Y2hpbmcuIFdoZW5ldmVyIHRoZVxyXG5jdXJzb3IgaXMgbmV4dCB0byBhIGJyYWNrZXQsIHRoYXQgYnJhY2tldCBhbmQgdGhlIG9uZSBpdCBtYXRjaGVzXHJcbmFyZSBoaWdobGlnaHRlZC4gT3IsIHdoZW4gbm8gbWF0Y2hpbmcgYnJhY2tldCBpcyBmb3VuZCwgYW5vdGhlclxyXG5oaWdobGlnaHRpbmcgc3R5bGUgaXMgdXNlZCB0byBpbmRpY2F0ZSB0aGlzLlxyXG4qL1xyXG5mdW5jdGlvbiBicmFja2V0TWF0Y2hpbmcoY29uZmlnID0ge30pIHtcclxuICAgIHJldHVybiBbYnJhY2tldE1hdGNoaW5nQ29uZmlnLm9mKGNvbmZpZyksIGJyYWNrZXRNYXRjaGluZ1VuaXF1ZV07XHJcbn1cclxuZnVuY3Rpb24gbWF0Y2hpbmdOb2Rlcyhub2RlLCBkaXIsIGJyYWNrZXRzKSB7XHJcbiAgICBsZXQgYnlQcm9wID0gbm9kZS5wcm9wKGRpciA8IDAgPyBOb2RlUHJvcC5vcGVuZWRCeSA6IE5vZGVQcm9wLmNsb3NlZEJ5KTtcclxuICAgIGlmIChieVByb3ApXHJcbiAgICAgICAgcmV0dXJuIGJ5UHJvcDtcclxuICAgIGlmIChub2RlLm5hbWUubGVuZ3RoID09IDEpIHtcclxuICAgICAgICBsZXQgaW5kZXggPSBicmFja2V0cy5pbmRleE9mKG5vZGUubmFtZSk7XHJcbiAgICAgICAgaWYgKGluZGV4ID4gLTEgJiYgaW5kZXggJSAyID09IChkaXIgPCAwID8gMSA6IDApKVxyXG4gICAgICAgICAgICByZXR1cm4gW2JyYWNrZXRzW2luZGV4ICsgZGlyXV07XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbnVsbDtcclxufVxyXG4vKipcclxuRmluZCB0aGUgbWF0Y2hpbmcgYnJhY2tldCBmb3IgdGhlIHRva2VuIGF0IGBwb3NgLCBzY2FubmluZ1xyXG5kaXJlY3Rpb24gYGRpcmAuIE9ubHkgdGhlIGBicmFja2V0c2AgYW5kIGBtYXhTY2FuRGlzdGFuY2VgXHJcbnByb3BlcnRpZXMgYXJlIHVzZWQgZnJvbSBgY29uZmlnYCwgaWYgZ2l2ZW4uIFJldHVybnMgbnVsbCBpZiBub1xyXG5icmFja2V0IHdhcyBmb3VuZCBhdCBgcG9zYCwgb3IgYSBtYXRjaCByZXN1bHQgb3RoZXJ3aXNlLlxyXG4qL1xyXG5mdW5jdGlvbiBtYXRjaEJyYWNrZXRzKHN0YXRlLCBwb3MsIGRpciwgY29uZmlnID0ge30pIHtcclxuICAgIGxldCBtYXhTY2FuRGlzdGFuY2UgPSBjb25maWcubWF4U2NhbkRpc3RhbmNlIHx8IERlZmF1bHRTY2FuRGlzdCwgYnJhY2tldHMgPSBjb25maWcuYnJhY2tldHMgfHwgRGVmYXVsdEJyYWNrZXRzO1xyXG4gICAgbGV0IHRyZWUgPSBzeW50YXhUcmVlKHN0YXRlKSwgbm9kZSA9IHRyZWUucmVzb2x2ZUlubmVyKHBvcywgZGlyKTtcclxuICAgIGZvciAobGV0IGN1ciA9IG5vZGU7IGN1cjsgY3VyID0gY3VyLnBhcmVudCkge1xyXG4gICAgICAgIGxldCBtYXRjaGVzID0gbWF0Y2hpbmdOb2RlcyhjdXIudHlwZSwgZGlyLCBicmFja2V0cyk7XHJcbiAgICAgICAgaWYgKG1hdGNoZXMgJiYgY3VyLmZyb20gPCBjdXIudG8pXHJcbiAgICAgICAgICAgIHJldHVybiBtYXRjaE1hcmtlZEJyYWNrZXRzKHN0YXRlLCBwb3MsIGRpciwgY3VyLCBtYXRjaGVzLCBicmFja2V0cyk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbWF0Y2hQbGFpbkJyYWNrZXRzKHN0YXRlLCBwb3MsIGRpciwgdHJlZSwgbm9kZS50eXBlLCBtYXhTY2FuRGlzdGFuY2UsIGJyYWNrZXRzKTtcclxufVxyXG5mdW5jdGlvbiBtYXRjaE1hcmtlZEJyYWNrZXRzKF9zdGF0ZSwgX3BvcywgZGlyLCB0b2tlbiwgbWF0Y2hpbmcsIGJyYWNrZXRzKSB7XHJcbiAgICBsZXQgcGFyZW50ID0gdG9rZW4ucGFyZW50LCBmaXJzdFRva2VuID0geyBmcm9tOiB0b2tlbi5mcm9tLCB0bzogdG9rZW4udG8gfTtcclxuICAgIGxldCBkZXB0aCA9IDAsIGN1cnNvciA9IHBhcmVudCA9PT0gbnVsbCB8fCBwYXJlbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhcmVudC5jdXJzb3IoKTtcclxuICAgIGlmIChjdXJzb3IgJiYgKGRpciA8IDAgPyBjdXJzb3IuY2hpbGRCZWZvcmUodG9rZW4uZnJvbSkgOiBjdXJzb3IuY2hpbGRBZnRlcih0b2tlbi50bykpKVxyXG4gICAgICAgIGRvIHtcclxuICAgICAgICAgICAgaWYgKGRpciA8IDAgPyBjdXJzb3IudG8gPD0gdG9rZW4uZnJvbSA6IGN1cnNvci5mcm9tID49IHRva2VuLnRvKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZGVwdGggPT0gMCAmJiBtYXRjaGluZy5pbmRleE9mKGN1cnNvci50eXBlLm5hbWUpID4gLTEgJiYgY3Vyc29yLmZyb20gPCBjdXJzb3IudG8pIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBzdGFydDogZmlyc3RUb2tlbiwgZW5kOiB7IGZyb206IGN1cnNvci5mcm9tLCB0bzogY3Vyc29yLnRvIH0sIG1hdGNoZWQ6IHRydWUgfTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKG1hdGNoaW5nTm9kZXMoY3Vyc29yLnR5cGUsIGRpciwgYnJhY2tldHMpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGVwdGgrKztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKG1hdGNoaW5nTm9kZXMoY3Vyc29yLnR5cGUsIC1kaXIsIGJyYWNrZXRzKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChkZXB0aCA9PSAwKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IGZpcnN0VG9rZW4sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmQ6IGN1cnNvci5mcm9tID09IGN1cnNvci50byA/IHVuZGVmaW5lZCA6IHsgZnJvbTogY3Vyc29yLmZyb20sIHRvOiBjdXJzb3IudG8gfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoZWQ6IGZhbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgZGVwdGgtLTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gd2hpbGUgKGRpciA8IDAgPyBjdXJzb3IucHJldlNpYmxpbmcoKSA6IGN1cnNvci5uZXh0U2libGluZygpKTtcclxuICAgIHJldHVybiB7IHN0YXJ0OiBmaXJzdFRva2VuLCBtYXRjaGVkOiBmYWxzZSB9O1xyXG59XHJcbmZ1bmN0aW9uIG1hdGNoUGxhaW5CcmFja2V0cyhzdGF0ZSwgcG9zLCBkaXIsIHRyZWUsIHRva2VuVHlwZSwgbWF4U2NhbkRpc3RhbmNlLCBicmFja2V0cykge1xyXG4gICAgbGV0IHN0YXJ0Q2ggPSBkaXIgPCAwID8gc3RhdGUuc2xpY2VEb2MocG9zIC0gMSwgcG9zKSA6IHN0YXRlLnNsaWNlRG9jKHBvcywgcG9zICsgMSk7XHJcbiAgICBsZXQgYnJhY2tldCA9IGJyYWNrZXRzLmluZGV4T2Yoc3RhcnRDaCk7XHJcbiAgICBpZiAoYnJhY2tldCA8IDAgfHwgKGJyYWNrZXQgJSAyID09IDApICE9IChkaXIgPiAwKSlcclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIGxldCBzdGFydFRva2VuID0geyBmcm9tOiBkaXIgPCAwID8gcG9zIC0gMSA6IHBvcywgdG86IGRpciA+IDAgPyBwb3MgKyAxIDogcG9zIH07XHJcbiAgICBsZXQgaXRlciA9IHN0YXRlLmRvYy5pdGVyUmFuZ2UocG9zLCBkaXIgPiAwID8gc3RhdGUuZG9jLmxlbmd0aCA6IDApLCBkZXB0aCA9IDA7XHJcbiAgICBmb3IgKGxldCBkaXN0YW5jZSA9IDA7ICEoaXRlci5uZXh0KCkpLmRvbmUgJiYgZGlzdGFuY2UgPD0gbWF4U2NhbkRpc3RhbmNlOykge1xyXG4gICAgICAgIGxldCB0ZXh0ID0gaXRlci52YWx1ZTtcclxuICAgICAgICBpZiAoZGlyIDwgMClcclxuICAgICAgICAgICAgZGlzdGFuY2UgKz0gdGV4dC5sZW5ndGg7XHJcbiAgICAgICAgbGV0IGJhc2VQb3MgPSBwb3MgKyBkaXN0YW5jZSAqIGRpcjtcclxuICAgICAgICBmb3IgKGxldCBwb3MgPSBkaXIgPiAwID8gMCA6IHRleHQubGVuZ3RoIC0gMSwgZW5kID0gZGlyID4gMCA/IHRleHQubGVuZ3RoIDogLTE7IHBvcyAhPSBlbmQ7IHBvcyArPSBkaXIpIHtcclxuICAgICAgICAgICAgbGV0IGZvdW5kID0gYnJhY2tldHMuaW5kZXhPZih0ZXh0W3Bvc10pO1xyXG4gICAgICAgICAgICBpZiAoZm91bmQgPCAwIHx8IHRyZWUucmVzb2x2ZUlubmVyKGJhc2VQb3MgKyBwb3MsIDEpLnR5cGUgIT0gdG9rZW5UeXBlKVxyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIGlmICgoZm91bmQgJSAyID09IDApID09IChkaXIgPiAwKSkge1xyXG4gICAgICAgICAgICAgICAgZGVwdGgrKztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChkZXB0aCA9PSAxKSB7IC8vIENsb3NpbmdcclxuICAgICAgICAgICAgICAgIHJldHVybiB7IHN0YXJ0OiBzdGFydFRva2VuLCBlbmQ6IHsgZnJvbTogYmFzZVBvcyArIHBvcywgdG86IGJhc2VQb3MgKyBwb3MgKyAxIH0sIG1hdGNoZWQ6IChmb3VuZCA+PiAxKSA9PSAoYnJhY2tldCA+PiAxKSB9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgZGVwdGgtLTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZGlyID4gMClcclxuICAgICAgICAgICAgZGlzdGFuY2UgKz0gdGV4dC5sZW5ndGg7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gaXRlci5kb25lID8geyBzdGFydDogc3RhcnRUb2tlbiwgbWF0Y2hlZDogZmFsc2UgfSA6IG51bGw7XHJcbn1cclxuXHJcbi8vIENvdW50cyB0aGUgY29sdW1uIG9mZnNldCBpbiBhIHN0cmluZywgdGFraW5nIHRhYnMgaW50byBhY2NvdW50LlxyXG4vLyBVc2VkIG1vc3RseSB0byBmaW5kIGluZGVudGF0aW9uLlxyXG5mdW5jdGlvbiBjb3VudENvbChzdHJpbmcsIGVuZCwgdGFiU2l6ZSwgc3RhcnRJbmRleCA9IDAsIHN0YXJ0VmFsdWUgPSAwKSB7XHJcbiAgICBpZiAoZW5kID09IG51bGwpIHtcclxuICAgICAgICBlbmQgPSBzdHJpbmcuc2VhcmNoKC9bXlxcc1xcdTAwYTBdLyk7XHJcbiAgICAgICAgaWYgKGVuZCA9PSAtMSlcclxuICAgICAgICAgICAgZW5kID0gc3RyaW5nLmxlbmd0aDtcclxuICAgIH1cclxuICAgIGxldCBuID0gc3RhcnRWYWx1ZTtcclxuICAgIGZvciAobGV0IGkgPSBzdGFydEluZGV4OyBpIDwgZW5kOyBpKyspIHtcclxuICAgICAgICBpZiAoc3RyaW5nLmNoYXJDb2RlQXQoaSkgPT0gOSlcclxuICAgICAgICAgICAgbiArPSB0YWJTaXplIC0gKG4gJSB0YWJTaXplKTtcclxuICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIG4rKztcclxuICAgIH1cclxuICAgIHJldHVybiBuO1xyXG59XHJcbi8qKlxyXG5FbmNhcHN1bGF0ZXMgYSBzaW5nbGUgbGluZSBvZiBpbnB1dC4gR2l2ZW4gdG8gc3RyZWFtIHN5bnRheCBjb2RlLFxyXG53aGljaCB1c2VzIGl0IHRvIHRva2VuaXplIHRoZSBjb250ZW50LlxyXG4qL1xyXG5jbGFzcyBTdHJpbmdTdHJlYW0ge1xyXG4gICAgLyoqXHJcbiAgICBDcmVhdGUgYSBzdHJlYW0uXHJcbiAgICAqL1xyXG4gICAgY29uc3RydWN0b3IoXHJcbiAgICAvKipcclxuICAgIFRoZSBsaW5lLlxyXG4gICAgKi9cclxuICAgIHN0cmluZywgdGFiU2l6ZSwgXHJcbiAgICAvKipcclxuICAgIFRoZSBjdXJyZW50IGluZGVudCB1bml0IHNpemUuXHJcbiAgICAqL1xyXG4gICAgaW5kZW50VW5pdCkge1xyXG4gICAgICAgIHRoaXMuc3RyaW5nID0gc3RyaW5nO1xyXG4gICAgICAgIHRoaXMudGFiU2l6ZSA9IHRhYlNpemU7XHJcbiAgICAgICAgdGhpcy5pbmRlbnRVbml0ID0gaW5kZW50VW5pdDtcclxuICAgICAgICAvKipcclxuICAgICAgICBUaGUgY3VycmVudCBwb3NpdGlvbiBvbiB0aGUgbGluZS5cclxuICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMucG9zID0gMDtcclxuICAgICAgICAvKipcclxuICAgICAgICBUaGUgc3RhcnQgcG9zaXRpb24gb2YgdGhlIGN1cnJlbnQgdG9rZW4uXHJcbiAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnN0YXJ0ID0gMDtcclxuICAgICAgICB0aGlzLmxhc3RDb2x1bW5Qb3MgPSAwO1xyXG4gICAgICAgIHRoaXMubGFzdENvbHVtblZhbHVlID0gMDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgVHJ1ZSBpZiB3ZSBhcmUgYXQgdGhlIGVuZCBvZiB0aGUgbGluZS5cclxuICAgICovXHJcbiAgICBlb2woKSB7IHJldHVybiB0aGlzLnBvcyA+PSB0aGlzLnN0cmluZy5sZW5ndGg7IH1cclxuICAgIC8qKlxyXG4gICAgVHJ1ZSBpZiB3ZSBhcmUgYXQgdGhlIHN0YXJ0IG9mIHRoZSBsaW5lLlxyXG4gICAgKi9cclxuICAgIHNvbCgpIHsgcmV0dXJuIHRoaXMucG9zID09IDA7IH1cclxuICAgIC8qKlxyXG4gICAgR2V0IHRoZSBuZXh0IGNvZGUgdW5pdCBhZnRlciB0aGUgY3VycmVudCBwb3NpdGlvbiwgb3IgdW5kZWZpbmVkXHJcbiAgICBpZiB3ZSdyZSBhdCB0aGUgZW5kIG9mIHRoZSBsaW5lLlxyXG4gICAgKi9cclxuICAgIHBlZWsoKSB7IHJldHVybiB0aGlzLnN0cmluZy5jaGFyQXQodGhpcy5wb3MpIHx8IHVuZGVmaW5lZDsgfVxyXG4gICAgLyoqXHJcbiAgICBSZWFkIHRoZSBuZXh0IGNvZGUgdW5pdCBhbmQgYWR2YW5jZSBgdGhpcy5wb3NgLlxyXG4gICAgKi9cclxuICAgIG5leHQoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMucG9zIDwgdGhpcy5zdHJpbmcubGVuZ3RoKVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zdHJpbmcuY2hhckF0KHRoaXMucG9zKyspO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICBNYXRjaCB0aGUgbmV4dCBjaGFyYWN0ZXIgYWdhaW5zdCB0aGUgZ2l2ZW4gc3RyaW5nLCByZWd1bGFyXHJcbiAgICBleHByZXNzaW9uLCBvciBwcmVkaWNhdGUuIENvbnN1bWUgYW5kIHJldHVybiBpdCBpZiBpdCBtYXRjaGVzLlxyXG4gICAgKi9cclxuICAgIGVhdChtYXRjaCkge1xyXG4gICAgICAgIGxldCBjaCA9IHRoaXMuc3RyaW5nLmNoYXJBdCh0aGlzLnBvcyk7XHJcbiAgICAgICAgbGV0IG9rO1xyXG4gICAgICAgIGlmICh0eXBlb2YgbWF0Y2ggPT0gXCJzdHJpbmdcIilcclxuICAgICAgICAgICAgb2sgPSBjaCA9PSBtYXRjaDtcclxuICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIG9rID0gY2ggJiYgKG1hdGNoIGluc3RhbmNlb2YgUmVnRXhwID8gbWF0Y2gudGVzdChjaCkgOiBtYXRjaChjaCkpO1xyXG4gICAgICAgIGlmIChvaykge1xyXG4gICAgICAgICAgICArK3RoaXMucG9zO1xyXG4gICAgICAgICAgICByZXR1cm4gY2g7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICBDb250aW51ZSBtYXRjaGluZyBjaGFyYWN0ZXJzIHRoYXQgbWF0Y2ggdGhlIGdpdmVuIHN0cmluZyxcclxuICAgIHJlZ3VsYXIgZXhwcmVzc2lvbiwgb3IgcHJlZGljYXRlIGZ1bmN0aW9uLiBSZXR1cm4gdHJ1ZSBpZiBhbnlcclxuICAgIGNoYXJhY3RlcnMgd2VyZSBjb25zdW1lZC5cclxuICAgICovXHJcbiAgICBlYXRXaGlsZShtYXRjaCkge1xyXG4gICAgICAgIGxldCBzdGFydCA9IHRoaXMucG9zO1xyXG4gICAgICAgIHdoaWxlICh0aGlzLmVhdChtYXRjaCkpIHsgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLnBvcyA+IHN0YXJ0O1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICBDb25zdW1lIHdoaXRlc3BhY2UgYWhlYWQgb2YgYHRoaXMucG9zYC4gUmV0dXJuIHRydWUgaWYgYW55IHdhc1xyXG4gICAgZm91bmQuXHJcbiAgICAqL1xyXG4gICAgZWF0U3BhY2UoKSB7XHJcbiAgICAgICAgbGV0IHN0YXJ0ID0gdGhpcy5wb3M7XHJcbiAgICAgICAgd2hpbGUgKC9bXFxzXFx1MDBhMF0vLnRlc3QodGhpcy5zdHJpbmcuY2hhckF0KHRoaXMucG9zKSkpXHJcbiAgICAgICAgICAgICsrdGhpcy5wb3M7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucG9zID4gc3RhcnQ7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgIE1vdmUgdG8gdGhlIGVuZCBvZiB0aGUgbGluZS5cclxuICAgICovXHJcbiAgICBza2lwVG9FbmQoKSB7IHRoaXMucG9zID0gdGhpcy5zdHJpbmcubGVuZ3RoOyB9XHJcbiAgICAvKipcclxuICAgIE1vdmUgdG8gZGlyZWN0bHkgYmVmb3JlIHRoZSBnaXZlbiBjaGFyYWN0ZXIsIGlmIGZvdW5kIG9uIHRoZVxyXG4gICAgY3VycmVudCBsaW5lLlxyXG4gICAgKi9cclxuICAgIHNraXBUbyhjaCkge1xyXG4gICAgICAgIGxldCBmb3VuZCA9IHRoaXMuc3RyaW5nLmluZGV4T2YoY2gsIHRoaXMucG9zKTtcclxuICAgICAgICBpZiAoZm91bmQgPiAtMSkge1xyXG4gICAgICAgICAgICB0aGlzLnBvcyA9IGZvdW5kO1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgIE1vdmUgYmFjayBgbmAgY2hhcmFjdGVycy5cclxuICAgICovXHJcbiAgICBiYWNrVXAobikgeyB0aGlzLnBvcyAtPSBuOyB9XHJcbiAgICAvKipcclxuICAgIEdldCB0aGUgY29sdW1uIHBvc2l0aW9uIGF0IGB0aGlzLnBvc2AuXHJcbiAgICAqL1xyXG4gICAgY29sdW1uKCkge1xyXG4gICAgICAgIGlmICh0aGlzLmxhc3RDb2x1bW5Qb3MgPCB0aGlzLnN0YXJ0KSB7XHJcbiAgICAgICAgICAgIHRoaXMubGFzdENvbHVtblZhbHVlID0gY291bnRDb2wodGhpcy5zdHJpbmcsIHRoaXMuc3RhcnQsIHRoaXMudGFiU2l6ZSwgdGhpcy5sYXN0Q29sdW1uUG9zLCB0aGlzLmxhc3RDb2x1bW5WYWx1ZSk7XHJcbiAgICAgICAgICAgIHRoaXMubGFzdENvbHVtblBvcyA9IHRoaXMuc3RhcnQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLmxhc3RDb2x1bW5WYWx1ZTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgR2V0IHRoZSBpbmRlbnRhdGlvbiBjb2x1bW4gb2YgdGhlIGN1cnJlbnQgbGluZS5cclxuICAgICovXHJcbiAgICBpbmRlbnRhdGlvbigpIHtcclxuICAgICAgICByZXR1cm4gY291bnRDb2wodGhpcy5zdHJpbmcsIG51bGwsIHRoaXMudGFiU2l6ZSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgIE1hdGNoIHRoZSBpbnB1dCBhZ2FpbnN0IHRoZSBnaXZlbiBzdHJpbmcgb3IgcmVndWxhciBleHByZXNzaW9uXHJcbiAgICAod2hpY2ggc2hvdWxkIHN0YXJ0IHdpdGggYSBgXmApLiBSZXR1cm4gdHJ1ZSBvciB0aGUgcmVnZXhwIG1hdGNoXHJcbiAgICBpZiBpdCBtYXRjaGVzLlxyXG4gICAgXHJcbiAgICBVbmxlc3MgYGNvbnN1bWVgIGlzIHNldCB0byBgZmFsc2VgLCB0aGlzIHdpbGwgbW92ZSBgdGhpcy5wb3NgXHJcbiAgICBwYXN0IHRoZSBtYXRjaGVkIHRleHQuXHJcbiAgICBcclxuICAgIFdoZW4gbWF0Y2hpbmcgYSBzdHJpbmcgYGNhc2VJbnNlbnNpdGl2ZWAgY2FuIGJlIHNldCB0byB0cnVlIHRvXHJcbiAgICBtYWtlIHRoZSBtYXRjaCBjYXNlLWluc2Vuc2l0aXZlLlxyXG4gICAgKi9cclxuICAgIG1hdGNoKHBhdHRlcm4sIGNvbnN1bWUsIGNhc2VJbnNlbnNpdGl2ZSkge1xyXG4gICAgICAgIGlmICh0eXBlb2YgcGF0dGVybiA9PSBcInN0cmluZ1wiKSB7XHJcbiAgICAgICAgICAgIGxldCBjYXNlZCA9IChzdHIpID0+IGNhc2VJbnNlbnNpdGl2ZSA/IHN0ci50b0xvd2VyQ2FzZSgpIDogc3RyO1xyXG4gICAgICAgICAgICBsZXQgc3Vic3RyID0gdGhpcy5zdHJpbmcuc3Vic3RyKHRoaXMucG9zLCBwYXR0ZXJuLmxlbmd0aCk7XHJcbiAgICAgICAgICAgIGlmIChjYXNlZChzdWJzdHIpID09IGNhc2VkKHBhdHRlcm4pKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoY29uc3VtZSAhPT0gZmFsc2UpXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wb3MgKz0gcGF0dGVybi5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGxldCBtYXRjaCA9IHRoaXMuc3RyaW5nLnNsaWNlKHRoaXMucG9zKS5tYXRjaChwYXR0ZXJuKTtcclxuICAgICAgICAgICAgaWYgKG1hdGNoICYmIG1hdGNoLmluZGV4ID4gMClcclxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICBpZiAobWF0Y2ggJiYgY29uc3VtZSAhPT0gZmFsc2UpXHJcbiAgICAgICAgICAgICAgICB0aGlzLnBvcyArPSBtYXRjaFswXS5sZW5ndGg7XHJcbiAgICAgICAgICAgIHJldHVybiBtYXRjaDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgIEdldCB0aGUgY3VycmVudCB0b2tlbi5cclxuICAgICovXHJcbiAgICBjdXJyZW50KCkgeyByZXR1cm4gdGhpcy5zdHJpbmcuc2xpY2UodGhpcy5zdGFydCwgdGhpcy5wb3MpOyB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGZ1bGxQYXJzZXIoc3BlYykge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBuYW1lOiBzcGVjLm5hbWUgfHwgXCJcIixcclxuICAgICAgICB0b2tlbjogc3BlYy50b2tlbixcclxuICAgICAgICBibGFua0xpbmU6IHNwZWMuYmxhbmtMaW5lIHx8ICgoKSA9PiB7IH0pLFxyXG4gICAgICAgIHN0YXJ0U3RhdGU6IHNwZWMuc3RhcnRTdGF0ZSB8fCAoKCkgPT4gdHJ1ZSksXHJcbiAgICAgICAgY29weVN0YXRlOiBzcGVjLmNvcHlTdGF0ZSB8fCBkZWZhdWx0Q29weVN0YXRlLFxyXG4gICAgICAgIGluZGVudDogc3BlYy5pbmRlbnQgfHwgKCgpID0+IG51bGwpLFxyXG4gICAgICAgIGxhbmd1YWdlRGF0YTogc3BlYy5sYW5ndWFnZURhdGEgfHwge30sXHJcbiAgICAgICAgdG9rZW5UYWJsZTogc3BlYy50b2tlblRhYmxlIHx8IG5vVG9rZW5zXHJcbiAgICB9O1xyXG59XHJcbmZ1bmN0aW9uIGRlZmF1bHRDb3B5U3RhdGUoc3RhdGUpIHtcclxuICAgIGlmICh0eXBlb2Ygc3RhdGUgIT0gXCJvYmplY3RcIilcclxuICAgICAgICByZXR1cm4gc3RhdGU7XHJcbiAgICBsZXQgbmV3U3RhdGUgPSB7fTtcclxuICAgIGZvciAobGV0IHByb3AgaW4gc3RhdGUpIHtcclxuICAgICAgICBsZXQgdmFsID0gc3RhdGVbcHJvcF07XHJcbiAgICAgICAgbmV3U3RhdGVbcHJvcF0gPSAodmFsIGluc3RhbmNlb2YgQXJyYXkgPyB2YWwuc2xpY2UoKSA6IHZhbCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbmV3U3RhdGU7XHJcbn1cclxuLyoqXHJcbkEgW2xhbmd1YWdlXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2xhbmd1YWdlLkxhbmd1YWdlKSBjbGFzcyBiYXNlZCBvbiBhIENvZGVNaXJyb3JcclxuNS1zdHlsZSBbc3RyZWFtaW5nIHBhcnNlcl0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNsYW5ndWFnZS5TdHJlYW1QYXJzZXIpLlxyXG4qL1xyXG5jbGFzcyBTdHJlYW1MYW5ndWFnZSBleHRlbmRzIExhbmd1YWdlIHtcclxuICAgIGNvbnN0cnVjdG9yKHBhcnNlcikge1xyXG4gICAgICAgIGxldCBkYXRhID0gZGVmaW5lTGFuZ3VhZ2VGYWNldChwYXJzZXIubGFuZ3VhZ2VEYXRhKTtcclxuICAgICAgICBsZXQgcCA9IGZ1bGxQYXJzZXIocGFyc2VyKSwgc2VsZjtcclxuICAgICAgICBsZXQgaW1wbCA9IG5ldyBjbGFzcyBleHRlbmRzIFBhcnNlciB7XHJcbiAgICAgICAgICAgIGNyZWF0ZVBhcnNlKGlucHV0LCBmcmFnbWVudHMsIHJhbmdlcykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQYXJzZShzZWxmLCBpbnB1dCwgZnJhZ21lbnRzLCByYW5nZXMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICBzdXBlcihkYXRhLCBpbXBsLCBbaW5kZW50U2VydmljZS5vZigoY3gsIHBvcykgPT4gdGhpcy5nZXRJbmRlbnQoY3gsIHBvcykpXSwgcGFyc2VyLm5hbWUpO1xyXG4gICAgICAgIHRoaXMudG9wTm9kZSA9IGRvY0lEKGRhdGEpO1xyXG4gICAgICAgIHNlbGYgPSB0aGlzO1xyXG4gICAgICAgIHRoaXMuc3RyZWFtUGFyc2VyID0gcDtcclxuICAgICAgICB0aGlzLnN0YXRlQWZ0ZXIgPSBuZXcgTm9kZVByb3AoeyBwZXJOb2RlOiB0cnVlIH0pO1xyXG4gICAgICAgIHRoaXMudG9rZW5UYWJsZSA9IHBhcnNlci50b2tlblRhYmxlID8gbmV3IFRva2VuVGFibGUocC50b2tlblRhYmxlKSA6IGRlZmF1bHRUb2tlblRhYmxlO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICBEZWZpbmUgYSBzdHJlYW0gbGFuZ3VhZ2UuXHJcbiAgICAqL1xyXG4gICAgc3RhdGljIGRlZmluZShzcGVjKSB7IHJldHVybiBuZXcgU3RyZWFtTGFuZ3VhZ2Uoc3BlYyk7IH1cclxuICAgIGdldEluZGVudChjeCwgcG9zKSB7XHJcbiAgICAgICAgbGV0IHRyZWUgPSBzeW50YXhUcmVlKGN4LnN0YXRlKSwgYXQgPSB0cmVlLnJlc29sdmUocG9zKTtcclxuICAgICAgICB3aGlsZSAoYXQgJiYgYXQudHlwZSAhPSB0aGlzLnRvcE5vZGUpXHJcbiAgICAgICAgICAgIGF0ID0gYXQucGFyZW50O1xyXG4gICAgICAgIGlmICghYXQpXHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIGxldCBzdGFydCA9IGZpbmRTdGF0ZSh0aGlzLCB0cmVlLCAwLCBhdC5mcm9tLCBwb3MpLCBzdGF0ZVBvcywgc3RhdGU7XHJcbiAgICAgICAgaWYgKHN0YXJ0KSB7XHJcbiAgICAgICAgICAgIHN0YXRlID0gc3RhcnQuc3RhdGU7XHJcbiAgICAgICAgICAgIHN0YXRlUG9zID0gc3RhcnQucG9zICsgMTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHN0YXRlID0gdGhpcy5zdHJlYW1QYXJzZXIuc3RhcnRTdGF0ZShjeC51bml0KTtcclxuICAgICAgICAgICAgc3RhdGVQb3MgPSAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAocG9zIC0gc3RhdGVQb3MgPiAxMDAwMCAvKiBDLk1heEluZGVudFNjYW5EaXN0ICovKVxyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB3aGlsZSAoc3RhdGVQb3MgPCBwb3MpIHtcclxuICAgICAgICAgICAgbGV0IGxpbmUgPSBjeC5zdGF0ZS5kb2MubGluZUF0KHN0YXRlUG9zKSwgZW5kID0gTWF0aC5taW4ocG9zLCBsaW5lLnRvKTtcclxuICAgICAgICAgICAgaWYgKGxpbmUubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgc3RyZWFtID0gbmV3IFN0cmluZ1N0cmVhbShsaW5lLnRleHQsIGN4LnN0YXRlLnRhYlNpemUsIGN4LnVuaXQpO1xyXG4gICAgICAgICAgICAgICAgd2hpbGUgKHN0cmVhbS5wb3MgPCBlbmQgLSBsaW5lLmZyb20pXHJcbiAgICAgICAgICAgICAgICAgICAgcmVhZFRva2VuKHRoaXMuc3RyZWFtUGFyc2VyLnRva2VuLCBzdHJlYW0sIHN0YXRlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuc3RyZWFtUGFyc2VyLmJsYW5rTGluZShzdGF0ZSwgY3gudW5pdCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGVuZCA9PSBwb3MpXHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgc3RhdGVQb3MgPSBsaW5lLnRvICsgMTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IHsgdGV4dCB9ID0gY3gubGluZUF0KHBvcyk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RyZWFtUGFyc2VyLmluZGVudChzdGF0ZSwgL15cXHMqKC4qKS8uZXhlYyh0ZXh0KVsxXSwgY3gpO1xyXG4gICAgfVxyXG4gICAgZ2V0IGFsbG93c05lc3RpbmcoKSB7IHJldHVybiBmYWxzZTsgfVxyXG59XHJcbmZ1bmN0aW9uIGZpbmRTdGF0ZShsYW5nLCB0cmVlLCBvZmYsIHN0YXJ0UG9zLCBiZWZvcmUpIHtcclxuICAgIGxldCBzdGF0ZSA9IG9mZiA+PSBzdGFydFBvcyAmJiBvZmYgKyB0cmVlLmxlbmd0aCA8PSBiZWZvcmUgJiYgdHJlZS5wcm9wKGxhbmcuc3RhdGVBZnRlcik7XHJcbiAgICBpZiAoc3RhdGUpXHJcbiAgICAgICAgcmV0dXJuIHsgc3RhdGU6IGxhbmcuc3RyZWFtUGFyc2VyLmNvcHlTdGF0ZShzdGF0ZSksIHBvczogb2ZmICsgdHJlZS5sZW5ndGggfTtcclxuICAgIGZvciAobGV0IGkgPSB0cmVlLmNoaWxkcmVuLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XHJcbiAgICAgICAgbGV0IGNoaWxkID0gdHJlZS5jaGlsZHJlbltpXSwgcG9zID0gb2ZmICsgdHJlZS5wb3NpdGlvbnNbaV07XHJcbiAgICAgICAgbGV0IGZvdW5kID0gY2hpbGQgaW5zdGFuY2VvZiBUcmVlICYmIHBvcyA8IGJlZm9yZSAmJiBmaW5kU3RhdGUobGFuZywgY2hpbGQsIHBvcywgc3RhcnRQb3MsIGJlZm9yZSk7XHJcbiAgICAgICAgaWYgKGZvdW5kKVxyXG4gICAgICAgICAgICByZXR1cm4gZm91bmQ7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbnVsbDtcclxufVxyXG5mdW5jdGlvbiBjdXRUcmVlKGxhbmcsIHRyZWUsIGZyb20sIHRvLCBpbnNpZGUpIHtcclxuICAgIGlmIChpbnNpZGUgJiYgZnJvbSA8PSAwICYmIHRvID49IHRyZWUubGVuZ3RoKVxyXG4gICAgICAgIHJldHVybiB0cmVlO1xyXG4gICAgaWYgKCFpbnNpZGUgJiYgdHJlZS50eXBlID09IGxhbmcudG9wTm9kZSlcclxuICAgICAgICBpbnNpZGUgPSB0cnVlO1xyXG4gICAgZm9yIChsZXQgaSA9IHRyZWUuY2hpbGRyZW4ubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcclxuICAgICAgICBsZXQgcG9zID0gdHJlZS5wb3NpdGlvbnNbaV0sIGNoaWxkID0gdHJlZS5jaGlsZHJlbltpXSwgaW5uZXI7XHJcbiAgICAgICAgaWYgKHBvcyA8IHRvICYmIGNoaWxkIGluc3RhbmNlb2YgVHJlZSkge1xyXG4gICAgICAgICAgICBpZiAoIShpbm5lciA9IGN1dFRyZWUobGFuZywgY2hpbGQsIGZyb20gLSBwb3MsIHRvIC0gcG9zLCBpbnNpZGUpKSlcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICByZXR1cm4gIWluc2lkZSA/IGlubmVyXHJcbiAgICAgICAgICAgICAgICA6IG5ldyBUcmVlKHRyZWUudHlwZSwgdHJlZS5jaGlsZHJlbi5zbGljZSgwLCBpKS5jb25jYXQoaW5uZXIpLCB0cmVlLnBvc2l0aW9ucy5zbGljZSgwLCBpICsgMSksIHBvcyArIGlubmVyLmxlbmd0aCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIG51bGw7XHJcbn1cclxuZnVuY3Rpb24gZmluZFN0YXJ0SW5GcmFnbWVudHMobGFuZywgZnJhZ21lbnRzLCBzdGFydFBvcywgZWRpdG9yU3RhdGUpIHtcclxuICAgIGZvciAobGV0IGYgb2YgZnJhZ21lbnRzKSB7XHJcbiAgICAgICAgbGV0IGZyb20gPSBmLmZyb20gKyAoZi5vcGVuU3RhcnQgPyAyNSA6IDApLCB0byA9IGYudG8gLSAoZi5vcGVuRW5kID8gMjUgOiAwKTtcclxuICAgICAgICBsZXQgZm91bmQgPSBmcm9tIDw9IHN0YXJ0UG9zICYmIHRvID4gc3RhcnRQb3MgJiYgZmluZFN0YXRlKGxhbmcsIGYudHJlZSwgMCAtIGYub2Zmc2V0LCBzdGFydFBvcywgdG8pLCB0cmVlO1xyXG4gICAgICAgIGlmIChmb3VuZCAmJiAodHJlZSA9IGN1dFRyZWUobGFuZywgZi50cmVlLCBzdGFydFBvcyArIGYub2Zmc2V0LCBmb3VuZC5wb3MgKyBmLm9mZnNldCwgZmFsc2UpKSlcclxuICAgICAgICAgICAgcmV0dXJuIHsgc3RhdGU6IGZvdW5kLnN0YXRlLCB0cmVlIH07XHJcbiAgICB9XHJcbiAgICByZXR1cm4geyBzdGF0ZTogbGFuZy5zdHJlYW1QYXJzZXIuc3RhcnRTdGF0ZShlZGl0b3JTdGF0ZSA/IGdldEluZGVudFVuaXQoZWRpdG9yU3RhdGUpIDogNCksIHRyZWU6IFRyZWUuZW1wdHkgfTtcclxufVxyXG5jbGFzcyBQYXJzZSB7XHJcbiAgICBjb25zdHJ1Y3RvcihsYW5nLCBpbnB1dCwgZnJhZ21lbnRzLCByYW5nZXMpIHtcclxuICAgICAgICB0aGlzLmxhbmcgPSBsYW5nO1xyXG4gICAgICAgIHRoaXMuaW5wdXQgPSBpbnB1dDtcclxuICAgICAgICB0aGlzLmZyYWdtZW50cyA9IGZyYWdtZW50cztcclxuICAgICAgICB0aGlzLnJhbmdlcyA9IHJhbmdlcztcclxuICAgICAgICB0aGlzLnN0b3BwZWRBdCA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5jaHVua3MgPSBbXTtcclxuICAgICAgICB0aGlzLmNodW5rUG9zID0gW107XHJcbiAgICAgICAgdGhpcy5jaHVuayA9IFtdO1xyXG4gICAgICAgIHRoaXMuY2h1bmtSZXVzZWQgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgdGhpcy5yYW5nZUluZGV4ID0gMDtcclxuICAgICAgICB0aGlzLnRvID0gcmFuZ2VzW3Jhbmdlcy5sZW5ndGggLSAxXS50bztcclxuICAgICAgICBsZXQgY29udGV4dCA9IFBhcnNlQ29udGV4dC5nZXQoKSwgZnJvbSA9IHJhbmdlc1swXS5mcm9tO1xyXG4gICAgICAgIGxldCB7IHN0YXRlLCB0cmVlIH0gPSBmaW5kU3RhcnRJbkZyYWdtZW50cyhsYW5nLCBmcmFnbWVudHMsIGZyb20sIGNvbnRleHQgPT09IG51bGwgfHwgY29udGV4dCA9PT0gdm9pZCAwID8gdm9pZCAwIDogY29udGV4dC5zdGF0ZSk7XHJcbiAgICAgICAgdGhpcy5zdGF0ZSA9IHN0YXRlO1xyXG4gICAgICAgIHRoaXMucGFyc2VkUG9zID0gdGhpcy5jaHVua1N0YXJ0ID0gZnJvbSArIHRyZWUubGVuZ3RoO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdHJlZS5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICB0aGlzLmNodW5rcy5wdXNoKHRyZWUuY2hpbGRyZW5baV0pO1xyXG4gICAgICAgICAgICB0aGlzLmNodW5rUG9zLnB1c2godHJlZS5wb3NpdGlvbnNbaV0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoY29udGV4dCAmJiB0aGlzLnBhcnNlZFBvcyA8IGNvbnRleHQudmlld3BvcnQuZnJvbSAtIDEwMDAwMCAvKiBDLk1heERpc3RhbmNlQmVmb3JlVmlld3BvcnQgKi8pIHtcclxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IHRoaXMubGFuZy5zdHJlYW1QYXJzZXIuc3RhcnRTdGF0ZShnZXRJbmRlbnRVbml0KGNvbnRleHQuc3RhdGUpKTtcclxuICAgICAgICAgICAgY29udGV4dC5za2lwVW50aWxJblZpZXcodGhpcy5wYXJzZWRQb3MsIGNvbnRleHQudmlld3BvcnQuZnJvbSk7XHJcbiAgICAgICAgICAgIHRoaXMucGFyc2VkUG9zID0gY29udGV4dC52aWV3cG9ydC5mcm9tO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLm1vdmVSYW5nZUluZGV4KCk7XHJcbiAgICB9XHJcbiAgICBhZHZhbmNlKCkge1xyXG4gICAgICAgIGxldCBjb250ZXh0ID0gUGFyc2VDb250ZXh0LmdldCgpO1xyXG4gICAgICAgIGxldCBwYXJzZUVuZCA9IHRoaXMuc3RvcHBlZEF0ID09IG51bGwgPyB0aGlzLnRvIDogTWF0aC5taW4odGhpcy50bywgdGhpcy5zdG9wcGVkQXQpO1xyXG4gICAgICAgIGxldCBlbmQgPSBNYXRoLm1pbihwYXJzZUVuZCwgdGhpcy5jaHVua1N0YXJ0ICsgMjA0OCAvKiBDLkNodW5rU2l6ZSAqLyk7XHJcbiAgICAgICAgaWYgKGNvbnRleHQpXHJcbiAgICAgICAgICAgIGVuZCA9IE1hdGgubWluKGVuZCwgY29udGV4dC52aWV3cG9ydC50byk7XHJcbiAgICAgICAgd2hpbGUgKHRoaXMucGFyc2VkUG9zIDwgZW5kKVxyXG4gICAgICAgICAgICB0aGlzLnBhcnNlTGluZShjb250ZXh0KTtcclxuICAgICAgICBpZiAodGhpcy5jaHVua1N0YXJ0IDwgdGhpcy5wYXJzZWRQb3MpXHJcbiAgICAgICAgICAgIHRoaXMuZmluaXNoQ2h1bmsoKTtcclxuICAgICAgICBpZiAodGhpcy5wYXJzZWRQb3MgPj0gcGFyc2VFbmQpXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZpbmlzaCgpO1xyXG4gICAgICAgIGlmIChjb250ZXh0ICYmIHRoaXMucGFyc2VkUG9zID49IGNvbnRleHQudmlld3BvcnQudG8pIHtcclxuICAgICAgICAgICAgY29udGV4dC5za2lwVW50aWxJblZpZXcodGhpcy5wYXJzZWRQb3MsIHBhcnNlRW5kKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmluaXNoKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG4gICAgc3RvcEF0KHBvcykge1xyXG4gICAgICAgIHRoaXMuc3RvcHBlZEF0ID0gcG9zO1xyXG4gICAgfVxyXG4gICAgbGluZUFmdGVyKHBvcykge1xyXG4gICAgICAgIGxldCBjaHVuayA9IHRoaXMuaW5wdXQuY2h1bmsocG9zKTtcclxuICAgICAgICBpZiAoIXRoaXMuaW5wdXQubGluZUNodW5rcykge1xyXG4gICAgICAgICAgICBsZXQgZW9sID0gY2h1bmsuaW5kZXhPZihcIlxcblwiKTtcclxuICAgICAgICAgICAgaWYgKGVvbCA+IC0xKVxyXG4gICAgICAgICAgICAgICAgY2h1bmsgPSBjaHVuay5zbGljZSgwLCBlb2wpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChjaHVuayA9PSBcIlxcblwiKSB7XHJcbiAgICAgICAgICAgIGNodW5rID0gXCJcIjtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHBvcyArIGNodW5rLmxlbmd0aCA8PSB0aGlzLnRvID8gY2h1bmsgOiBjaHVuay5zbGljZSgwLCB0aGlzLnRvIC0gcG9zKTtcclxuICAgIH1cclxuICAgIG5leHRMaW5lKCkge1xyXG4gICAgICAgIGxldCBmcm9tID0gdGhpcy5wYXJzZWRQb3MsIGxpbmUgPSB0aGlzLmxpbmVBZnRlcihmcm9tKSwgZW5kID0gZnJvbSArIGxpbmUubGVuZ3RoO1xyXG4gICAgICAgIGZvciAobGV0IGluZGV4ID0gdGhpcy5yYW5nZUluZGV4OzspIHtcclxuICAgICAgICAgICAgbGV0IHJhbmdlRW5kID0gdGhpcy5yYW5nZXNbaW5kZXhdLnRvO1xyXG4gICAgICAgICAgICBpZiAocmFuZ2VFbmQgPj0gZW5kKVxyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGxpbmUgPSBsaW5lLnNsaWNlKDAsIHJhbmdlRW5kIC0gKGVuZCAtIGxpbmUubGVuZ3RoKSk7XHJcbiAgICAgICAgICAgIGluZGV4Kys7XHJcbiAgICAgICAgICAgIGlmIChpbmRleCA9PSB0aGlzLnJhbmdlcy5sZW5ndGgpXHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgbGV0IHJhbmdlU3RhcnQgPSB0aGlzLnJhbmdlc1tpbmRleF0uZnJvbTtcclxuICAgICAgICAgICAgbGV0IGFmdGVyID0gdGhpcy5saW5lQWZ0ZXIocmFuZ2VTdGFydCk7XHJcbiAgICAgICAgICAgIGxpbmUgKz0gYWZ0ZXI7XHJcbiAgICAgICAgICAgIGVuZCA9IHJhbmdlU3RhcnQgKyBhZnRlci5sZW5ndGg7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB7IGxpbmUsIGVuZCB9O1xyXG4gICAgfVxyXG4gICAgc2tpcEdhcHNUbyhwb3MsIG9mZnNldCwgc2lkZSkge1xyXG4gICAgICAgIGZvciAoOzspIHtcclxuICAgICAgICAgICAgbGV0IGVuZCA9IHRoaXMucmFuZ2VzW3RoaXMucmFuZ2VJbmRleF0udG8sIG9mZlBvcyA9IHBvcyArIG9mZnNldDtcclxuICAgICAgICAgICAgaWYgKHNpZGUgPiAwID8gZW5kID4gb2ZmUG9zIDogZW5kID49IG9mZlBvcylcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBsZXQgc3RhcnQgPSB0aGlzLnJhbmdlc1srK3RoaXMucmFuZ2VJbmRleF0uZnJvbTtcclxuICAgICAgICAgICAgb2Zmc2V0ICs9IHN0YXJ0IC0gZW5kO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gb2Zmc2V0O1xyXG4gICAgfVxyXG4gICAgbW92ZVJhbmdlSW5kZXgoKSB7XHJcbiAgICAgICAgd2hpbGUgKHRoaXMucmFuZ2VzW3RoaXMucmFuZ2VJbmRleF0udG8gPCB0aGlzLnBhcnNlZFBvcylcclxuICAgICAgICAgICAgdGhpcy5yYW5nZUluZGV4Kys7XHJcbiAgICB9XHJcbiAgICBlbWl0VG9rZW4oaWQsIGZyb20sIHRvLCBzaXplLCBvZmZzZXQpIHtcclxuICAgICAgICBpZiAodGhpcy5yYW5nZXMubGVuZ3RoID4gMSkge1xyXG4gICAgICAgICAgICBvZmZzZXQgPSB0aGlzLnNraXBHYXBzVG8oZnJvbSwgb2Zmc2V0LCAxKTtcclxuICAgICAgICAgICAgZnJvbSArPSBvZmZzZXQ7XHJcbiAgICAgICAgICAgIGxldCBsZW4wID0gdGhpcy5jaHVuay5sZW5ndGg7XHJcbiAgICAgICAgICAgIG9mZnNldCA9IHRoaXMuc2tpcEdhcHNUbyh0bywgb2Zmc2V0LCAtMSk7XHJcbiAgICAgICAgICAgIHRvICs9IG9mZnNldDtcclxuICAgICAgICAgICAgc2l6ZSArPSB0aGlzLmNodW5rLmxlbmd0aCAtIGxlbjA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuY2h1bmsucHVzaChpZCwgZnJvbSwgdG8sIHNpemUpO1xyXG4gICAgICAgIHJldHVybiBvZmZzZXQ7XHJcbiAgICB9XHJcbiAgICBwYXJzZUxpbmUoY29udGV4dCkge1xyXG4gICAgICAgIGxldCB7IGxpbmUsIGVuZCB9ID0gdGhpcy5uZXh0TGluZSgpLCBvZmZzZXQgPSAwLCB7IHN0cmVhbVBhcnNlciB9ID0gdGhpcy5sYW5nO1xyXG4gICAgICAgIGxldCBzdHJlYW0gPSBuZXcgU3RyaW5nU3RyZWFtKGxpbmUsIGNvbnRleHQgPyBjb250ZXh0LnN0YXRlLnRhYlNpemUgOiA0LCBjb250ZXh0ID8gZ2V0SW5kZW50VW5pdChjb250ZXh0LnN0YXRlKSA6IDIpO1xyXG4gICAgICAgIGlmIChzdHJlYW0uZW9sKCkpIHtcclxuICAgICAgICAgICAgc3RyZWFtUGFyc2VyLmJsYW5rTGluZSh0aGlzLnN0YXRlLCBzdHJlYW0uaW5kZW50VW5pdCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB3aGlsZSAoIXN0cmVhbS5lb2woKSkge1xyXG4gICAgICAgICAgICAgICAgbGV0IHRva2VuID0gcmVhZFRva2VuKHN0cmVhbVBhcnNlci50b2tlbiwgc3RyZWFtLCB0aGlzLnN0YXRlKTtcclxuICAgICAgICAgICAgICAgIGlmICh0b2tlbilcclxuICAgICAgICAgICAgICAgICAgICBvZmZzZXQgPSB0aGlzLmVtaXRUb2tlbih0aGlzLmxhbmcudG9rZW5UYWJsZS5yZXNvbHZlKHRva2VuKSwgdGhpcy5wYXJzZWRQb3MgKyBzdHJlYW0uc3RhcnQsIHRoaXMucGFyc2VkUG9zICsgc3RyZWFtLnBvcywgNCwgb2Zmc2V0KTtcclxuICAgICAgICAgICAgICAgIGlmIChzdHJlYW0uc3RhcnQgPiAxMDAwMCAvKiBDLk1heExpbmVMZW5ndGggKi8pXHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5wYXJzZWRQb3MgPSBlbmQ7XHJcbiAgICAgICAgdGhpcy5tb3ZlUmFuZ2VJbmRleCgpO1xyXG4gICAgICAgIGlmICh0aGlzLnBhcnNlZFBvcyA8IHRoaXMudG8pXHJcbiAgICAgICAgICAgIHRoaXMucGFyc2VkUG9zKys7XHJcbiAgICB9XHJcbiAgICBmaW5pc2hDaHVuaygpIHtcclxuICAgICAgICBsZXQgdHJlZSA9IFRyZWUuYnVpbGQoe1xyXG4gICAgICAgICAgICBidWZmZXI6IHRoaXMuY2h1bmssXHJcbiAgICAgICAgICAgIHN0YXJ0OiB0aGlzLmNodW5rU3RhcnQsXHJcbiAgICAgICAgICAgIGxlbmd0aDogdGhpcy5wYXJzZWRQb3MgLSB0aGlzLmNodW5rU3RhcnQsXHJcbiAgICAgICAgICAgIG5vZGVTZXQsXHJcbiAgICAgICAgICAgIHRvcElEOiAwLFxyXG4gICAgICAgICAgICBtYXhCdWZmZXJMZW5ndGg6IDIwNDggLyogQy5DaHVua1NpemUgKi8sXHJcbiAgICAgICAgICAgIHJldXNlZDogdGhpcy5jaHVua1JldXNlZFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRyZWUgPSBuZXcgVHJlZSh0cmVlLnR5cGUsIHRyZWUuY2hpbGRyZW4sIHRyZWUucG9zaXRpb25zLCB0cmVlLmxlbmd0aCwgW1t0aGlzLmxhbmcuc3RhdGVBZnRlciwgdGhpcy5sYW5nLnN0cmVhbVBhcnNlci5jb3B5U3RhdGUodGhpcy5zdGF0ZSldXSk7XHJcbiAgICAgICAgdGhpcy5jaHVua3MucHVzaCh0cmVlKTtcclxuICAgICAgICB0aGlzLmNodW5rUG9zLnB1c2godGhpcy5jaHVua1N0YXJ0IC0gdGhpcy5yYW5nZXNbMF0uZnJvbSk7XHJcbiAgICAgICAgdGhpcy5jaHVuayA9IFtdO1xyXG4gICAgICAgIHRoaXMuY2h1bmtSZXVzZWQgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgdGhpcy5jaHVua1N0YXJ0ID0gdGhpcy5wYXJzZWRQb3M7XHJcbiAgICB9XHJcbiAgICBmaW5pc2goKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBUcmVlKHRoaXMubGFuZy50b3BOb2RlLCB0aGlzLmNodW5rcywgdGhpcy5jaHVua1BvcywgdGhpcy5wYXJzZWRQb3MgLSB0aGlzLnJhbmdlc1swXS5mcm9tKS5iYWxhbmNlKCk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gcmVhZFRva2VuKHRva2VuLCBzdHJlYW0sIHN0YXRlKSB7XHJcbiAgICBzdHJlYW0uc3RhcnQgPSBzdHJlYW0ucG9zO1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCAxMDsgaSsrKSB7XHJcbiAgICAgICAgbGV0IHJlc3VsdCA9IHRva2VuKHN0cmVhbSwgc3RhdGUpO1xyXG4gICAgICAgIGlmIChzdHJlYW0ucG9zID4gc3RyZWFtLnN0YXJ0KVxyXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiU3RyZWFtIHBhcnNlciBmYWlsZWQgdG8gYWR2YW5jZSBzdHJlYW0uXCIpO1xyXG59XHJcbmNvbnN0IG5vVG9rZW5zID0gLypAX19QVVJFX18qL09iamVjdC5jcmVhdGUobnVsbCk7XHJcbmNvbnN0IHR5cGVBcnJheSA9IFtOb2RlVHlwZS5ub25lXTtcclxuY29uc3Qgbm9kZVNldCA9IC8qQF9fUFVSRV9fKi9uZXcgTm9kZVNldCh0eXBlQXJyYXkpO1xyXG5jb25zdCB3YXJuZWQgPSBbXTtcclxuY29uc3QgZGVmYXVsdFRhYmxlID0gLypAX19QVVJFX18qL09iamVjdC5jcmVhdGUobnVsbCk7XHJcbmZvciAobGV0IFtsZWdhY3lOYW1lLCBuYW1lXSBvZiBbXHJcbiAgICBbXCJ2YXJpYWJsZVwiLCBcInZhcmlhYmxlTmFtZVwiXSxcclxuICAgIFtcInZhcmlhYmxlLTJcIiwgXCJ2YXJpYWJsZU5hbWUuc3BlY2lhbFwiXSxcclxuICAgIFtcInN0cmluZy0yXCIsIFwic3RyaW5nLnNwZWNpYWxcIl0sXHJcbiAgICBbXCJkZWZcIiwgXCJ2YXJpYWJsZU5hbWUuZGVmaW5pdGlvblwiXSxcclxuICAgIFtcInRhZ1wiLCBcInRhZ05hbWVcIl0sXHJcbiAgICBbXCJhdHRyaWJ1dGVcIiwgXCJhdHRyaWJ1dGVOYW1lXCJdLFxyXG4gICAgW1widHlwZVwiLCBcInR5cGVOYW1lXCJdLFxyXG4gICAgW1wiYnVpbHRpblwiLCBcInZhcmlhYmxlTmFtZS5zdGFuZGFyZFwiXSxcclxuICAgIFtcInF1YWxpZmllclwiLCBcIm1vZGlmaWVyXCJdLFxyXG4gICAgW1wiZXJyb3JcIiwgXCJpbnZhbGlkXCJdLFxyXG4gICAgW1wiaGVhZGVyXCIsIFwiaGVhZGluZ1wiXSxcclxuICAgIFtcInByb3BlcnR5XCIsIFwicHJvcGVydHlOYW1lXCJdXHJcbl0pXHJcbiAgICBkZWZhdWx0VGFibGVbbGVnYWN5TmFtZV0gPSAvKkBfX1BVUkVfXyovY3JlYXRlVG9rZW5UeXBlKG5vVG9rZW5zLCBuYW1lKTtcclxuY2xhc3MgVG9rZW5UYWJsZSB7XHJcbiAgICBjb25zdHJ1Y3RvcihleHRyYSkge1xyXG4gICAgICAgIHRoaXMuZXh0cmEgPSBleHRyYTtcclxuICAgICAgICB0aGlzLnRhYmxlID0gT2JqZWN0LmFzc2lnbihPYmplY3QuY3JlYXRlKG51bGwpLCBkZWZhdWx0VGFibGUpO1xyXG4gICAgfVxyXG4gICAgcmVzb2x2ZSh0YWcpIHtcclxuICAgICAgICByZXR1cm4gIXRhZyA/IDAgOiB0aGlzLnRhYmxlW3RhZ10gfHwgKHRoaXMudGFibGVbdGFnXSA9IGNyZWF0ZVRva2VuVHlwZSh0aGlzLmV4dHJhLCB0YWcpKTtcclxuICAgIH1cclxufVxyXG5jb25zdCBkZWZhdWx0VG9rZW5UYWJsZSA9IC8qQF9fUFVSRV9fKi9uZXcgVG9rZW5UYWJsZShub1Rva2Vucyk7XHJcbmZ1bmN0aW9uIHdhcm5Gb3JQYXJ0KHBhcnQsIG1zZykge1xyXG4gICAgaWYgKHdhcm5lZC5pbmRleE9mKHBhcnQpID4gLTEpXHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgd2FybmVkLnB1c2gocGFydCk7XHJcbiAgICBjb25zb2xlLndhcm4obXNnKTtcclxufVxyXG5mdW5jdGlvbiBjcmVhdGVUb2tlblR5cGUoZXh0cmEsIHRhZ1N0cikge1xyXG4gICAgbGV0IHRhZyA9IG51bGw7XHJcbiAgICBmb3IgKGxldCBwYXJ0IG9mIHRhZ1N0ci5zcGxpdChcIi5cIikpIHtcclxuICAgICAgICBsZXQgdmFsdWUgPSAoZXh0cmFbcGFydF0gfHwgdGFnc1twYXJ0XSk7XHJcbiAgICAgICAgaWYgKCF2YWx1ZSkge1xyXG4gICAgICAgICAgICB3YXJuRm9yUGFydChwYXJ0LCBgVW5rbm93biBoaWdobGlnaHRpbmcgdGFnICR7cGFydH1gKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09IFwiZnVuY3Rpb25cIikge1xyXG4gICAgICAgICAgICBpZiAoIXRhZylcclxuICAgICAgICAgICAgICAgIHdhcm5Gb3JQYXJ0KHBhcnQsIGBNb2RpZmllciAke3BhcnR9IHVzZWQgYXQgc3RhcnQgb2YgdGFnYCk7XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgIHRhZyA9IHZhbHVlKHRhZyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAodGFnKVxyXG4gICAgICAgICAgICAgICAgd2FybkZvclBhcnQocGFydCwgYFRhZyAke3BhcnR9IHVzZWQgYXMgbW9kaWZpZXJgKTtcclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgdGFnID0gdmFsdWU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKCF0YWcpXHJcbiAgICAgICAgcmV0dXJuIDA7XHJcbiAgICBsZXQgbmFtZSA9IHRhZ1N0ci5yZXBsYWNlKC8gL2csIFwiX1wiKSwgdHlwZSA9IE5vZGVUeXBlLmRlZmluZSh7XHJcbiAgICAgICAgaWQ6IHR5cGVBcnJheS5sZW5ndGgsXHJcbiAgICAgICAgbmFtZSxcclxuICAgICAgICBwcm9wczogW3N0eWxlVGFncyh7IFtuYW1lXTogdGFnIH0pXVxyXG4gICAgfSk7XHJcbiAgICB0eXBlQXJyYXkucHVzaCh0eXBlKTtcclxuICAgIHJldHVybiB0eXBlLmlkO1xyXG59XHJcbmZ1bmN0aW9uIGRvY0lEKGRhdGEpIHtcclxuICAgIGxldCB0eXBlID0gTm9kZVR5cGUuZGVmaW5lKHsgaWQ6IHR5cGVBcnJheS5sZW5ndGgsIG5hbWU6IFwiRG9jdW1lbnRcIiwgcHJvcHM6IFtsYW5ndWFnZURhdGFQcm9wLmFkZCgoKSA9PiBkYXRhKV0gfSk7XHJcbiAgICB0eXBlQXJyYXkucHVzaCh0eXBlKTtcclxuICAgIHJldHVybiB0eXBlO1xyXG59XHJcblxyXG5leHBvcnQgeyBIaWdobGlnaHRTdHlsZSwgSW5kZW50Q29udGV4dCwgTFJMYW5ndWFnZSwgTGFuZ3VhZ2UsIExhbmd1YWdlRGVzY3JpcHRpb24sIExhbmd1YWdlU3VwcG9ydCwgUGFyc2VDb250ZXh0LCBTdHJlYW1MYW5ndWFnZSwgU3RyaW5nU3RyZWFtLCBUcmVlSW5kZW50Q29udGV4dCwgYnJhY2tldE1hdGNoaW5nLCBjb2RlRm9sZGluZywgY29udGludWVkSW5kZW50LCBkZWZhdWx0SGlnaGxpZ2h0U3R5bGUsIGRlZmluZUxhbmd1YWdlRmFjZXQsIGRlbGltaXRlZEluZGVudCwgZW5zdXJlU3ludGF4VHJlZSwgZmxhdEluZGVudCwgZm9sZEFsbCwgZm9sZENvZGUsIGZvbGRFZmZlY3QsIGZvbGRHdXR0ZXIsIGZvbGRJbnNpZGUsIGZvbGRLZXltYXAsIGZvbGROb2RlUHJvcCwgZm9sZFNlcnZpY2UsIGZvbGRTdGF0ZSwgZm9sZGFibGUsIGZvbGRlZFJhbmdlcywgZm9yY2VQYXJzaW5nLCBnZXRJbmRlbnRVbml0LCBnZXRJbmRlbnRhdGlvbiwgaGlnaGxpZ2h0aW5nRm9yLCBpbmRlbnROb2RlUHJvcCwgaW5kZW50T25JbnB1dCwgaW5kZW50UmFuZ2UsIGluZGVudFNlcnZpY2UsIGluZGVudFN0cmluZywgaW5kZW50VW5pdCwgbGFuZ3VhZ2UsIGxhbmd1YWdlRGF0YVByb3AsIG1hdGNoQnJhY2tldHMsIHN5bnRheEhpZ2hsaWdodGluZywgc3ludGF4UGFyc2VyUnVubmluZywgc3ludGF4VHJlZSwgc3ludGF4VHJlZUF2YWlsYWJsZSwgdW5mb2xkQWxsLCB1bmZvbGRDb2RlLCB1bmZvbGRFZmZlY3QgfTtcclxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@codemirror/language/dist/index.js\n"));

/***/ }),

/***/ "./node_modules/@codemirror/lint/dist/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/@codemirror/lint/dist/index.js ***!
  \*****************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"closeLintPanel\": function() { return /* binding */ closeLintPanel; },\n/* harmony export */   \"diagnosticCount\": function() { return /* binding */ diagnosticCount; },\n/* harmony export */   \"forEachDiagnostic\": function() { return /* binding */ forEachDiagnostic; },\n/* harmony export */   \"forceLinting\": function() { return /* binding */ forceLinting; },\n/* harmony export */   \"lintGutter\": function() { return /* binding */ lintGutter; },\n/* harmony export */   \"lintKeymap\": function() { return /* binding */ lintKeymap; },\n/* harmony export */   \"linter\": function() { return /* binding */ linter; },\n/* harmony export */   \"nextDiagnostic\": function() { return /* binding */ nextDiagnostic; },\n/* harmony export */   \"openLintPanel\": function() { return /* binding */ openLintPanel; },\n/* harmony export */   \"setDiagnostics\": function() { return /* binding */ setDiagnostics; },\n/* harmony export */   \"setDiagnosticsEffect\": function() { return /* binding */ setDiagnosticsEffect; }\n/* harmony export */ });\n/* harmony import */ var _codemirror_view__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @codemirror/view */ \"./node_modules/@codemirror/view/dist/index.js\");\n/* harmony import */ var _codemirror_state__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @codemirror/state */ \"./node_modules/@codemirror/state/dist/index.js\");\n/* harmony import */ var crelt__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! crelt */ \"./node_modules/crelt/index.es.js\");\n\r\n\r\n\r\n\r\nclass SelectedDiagnostic {\r\n    constructor(from, to, diagnostic) {\r\n        this.from = from;\r\n        this.to = to;\r\n        this.diagnostic = diagnostic;\r\n    }\r\n}\r\nclass LintState {\r\n    constructor(diagnostics, panel, selected) {\r\n        this.diagnostics = diagnostics;\r\n        this.panel = panel;\r\n        this.selected = selected;\r\n    }\r\n    static init(diagnostics, panel, state) {\r\n        // Filter the list of diagnostics for which to create markers\r\n        let markedDiagnostics = diagnostics;\r\n        let diagnosticFilter = state.facet(lintConfig).markerFilter;\r\n        if (diagnosticFilter)\r\n            markedDiagnostics = diagnosticFilter(markedDiagnostics);\r\n        let ranges = _codemirror_view__WEBPACK_IMPORTED_MODULE_1__.Decoration.set(markedDiagnostics.map((d) => {\r\n            // For zero-length ranges or ranges covering only a line break, create a widget\r\n            return d.from == d.to || (d.from == d.to - 1 && state.doc.lineAt(d.from).to == d.from)\r\n                ? _codemirror_view__WEBPACK_IMPORTED_MODULE_1__.Decoration.widget({\r\n                    widget: new DiagnosticWidget(d),\r\n                    diagnostic: d\r\n                }).range(d.from)\r\n                : _codemirror_view__WEBPACK_IMPORTED_MODULE_1__.Decoration.mark({\r\n                    attributes: { class: \"cm-lintRange cm-lintRange-\" + d.severity },\r\n                    diagnostic: d\r\n                }).range(d.from, d.to);\r\n        }), true);\r\n        return new LintState(ranges, panel, findDiagnostic(ranges));\r\n    }\r\n}\r\nfunction findDiagnostic(diagnostics, diagnostic = null, after = 0) {\r\n    let found = null;\r\n    diagnostics.between(after, 1e9, (from, to, { spec }) => {\r\n        if (diagnostic && spec.diagnostic != diagnostic)\r\n            return;\r\n        found = new SelectedDiagnostic(from, to, spec.diagnostic);\r\n        return false;\r\n    });\r\n    return found;\r\n}\r\nfunction hideTooltip(tr, tooltip) {\r\n    return !!(tr.effects.some(e => e.is(setDiagnosticsEffect)) || tr.changes.touchesRange(tooltip.pos));\r\n}\r\nfunction maybeEnableLint(state, effects) {\r\n    return state.field(lintState, false) ? effects : effects.concat(_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.StateEffect.appendConfig.of([\r\n        lintState,\r\n        _codemirror_view__WEBPACK_IMPORTED_MODULE_1__.EditorView.decorations.compute([lintState], state => {\r\n            let { selected, panel } = state.field(lintState);\r\n            return !selected || !panel || selected.from == selected.to ? _codemirror_view__WEBPACK_IMPORTED_MODULE_1__.Decoration.none : _codemirror_view__WEBPACK_IMPORTED_MODULE_1__.Decoration.set([\r\n                activeMark.range(selected.from, selected.to)\r\n            ]);\r\n        }),\r\n        (0,_codemirror_view__WEBPACK_IMPORTED_MODULE_1__.hoverTooltip)(lintTooltip, { hideOn: hideTooltip }),\r\n        baseTheme\r\n    ]));\r\n}\r\n/**\r\nReturns a transaction spec which updates the current set of\r\ndiagnostics, and enables the lint extension if if wasn't already\r\nactive.\r\n*/\r\nfunction setDiagnostics(state, diagnostics) {\r\n    return {\r\n        effects: maybeEnableLint(state, [setDiagnosticsEffect.of(diagnostics)])\r\n    };\r\n}\r\n/**\r\nThe state effect that updates the set of active diagnostics. Can\r\nbe useful when writing an extension that needs to track these.\r\n*/\r\nconst setDiagnosticsEffect = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.StateEffect.define();\r\nconst togglePanel = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.StateEffect.define();\r\nconst movePanelSelection = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.StateEffect.define();\r\nconst lintState = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.StateField.define({\r\n    create() {\r\n        return new LintState(_codemirror_view__WEBPACK_IMPORTED_MODULE_1__.Decoration.none, null, null);\r\n    },\r\n    update(value, tr) {\r\n        if (tr.docChanged) {\r\n            let mapped = value.diagnostics.map(tr.changes), selected = null;\r\n            if (value.selected) {\r\n                let selPos = tr.changes.mapPos(value.selected.from, 1);\r\n                selected = findDiagnostic(mapped, value.selected.diagnostic, selPos) || findDiagnostic(mapped, null, selPos);\r\n            }\r\n            value = new LintState(mapped, value.panel, selected);\r\n        }\r\n        for (let effect of tr.effects) {\r\n            if (effect.is(setDiagnosticsEffect)) {\r\n                value = LintState.init(effect.value, value.panel, tr.state);\r\n            }\r\n            else if (effect.is(togglePanel)) {\r\n                value = new LintState(value.diagnostics, effect.value ? LintPanel.open : null, value.selected);\r\n            }\r\n            else if (effect.is(movePanelSelection)) {\r\n                value = new LintState(value.diagnostics, value.panel, effect.value);\r\n            }\r\n        }\r\n        return value;\r\n    },\r\n    provide: f => [_codemirror_view__WEBPACK_IMPORTED_MODULE_1__.showPanel.from(f, val => val.panel),\r\n        _codemirror_view__WEBPACK_IMPORTED_MODULE_1__.EditorView.decorations.from(f, s => s.diagnostics)]\r\n});\r\n/**\r\nReturns the number of active lint diagnostics in the given state.\r\n*/\r\nfunction diagnosticCount(state) {\r\n    let lint = state.field(lintState, false);\r\n    return lint ? lint.diagnostics.size : 0;\r\n}\r\nconst activeMark = /*@__PURE__*/_codemirror_view__WEBPACK_IMPORTED_MODULE_1__.Decoration.mark({ class: \"cm-lintRange cm-lintRange-active\" });\r\nfunction lintTooltip(view, pos, side) {\r\n    let { diagnostics } = view.state.field(lintState);\r\n    let found = [], stackStart = 2e8, stackEnd = 0;\r\n    diagnostics.between(pos - (side < 0 ? 1 : 0), pos + (side > 0 ? 1 : 0), (from, to, { spec }) => {\r\n        if (pos >= from && pos <= to &&\r\n            (from == to || ((pos > from || side > 0) && (pos < to || side < 0)))) {\r\n            found.push(spec.diagnostic);\r\n            stackStart = Math.min(from, stackStart);\r\n            stackEnd = Math.max(to, stackEnd);\r\n        }\r\n    });\r\n    let diagnosticFilter = view.state.facet(lintConfig).tooltipFilter;\r\n    if (diagnosticFilter)\r\n        found = diagnosticFilter(found);\r\n    if (!found.length)\r\n        return null;\r\n    return {\r\n        pos: stackStart,\r\n        end: stackEnd,\r\n        above: view.state.doc.lineAt(stackStart).to < stackEnd,\r\n        create() {\r\n            return { dom: diagnosticsTooltip(view, found) };\r\n        }\r\n    };\r\n}\r\nfunction diagnosticsTooltip(view, diagnostics) {\r\n    return (0,crelt__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"ul\", { class: \"cm-tooltip-lint\" }, diagnostics.map(d => renderDiagnostic(view, d, false)));\r\n}\r\n/**\r\nCommand to open and focus the lint panel.\r\n*/\r\nconst openLintPanel = (view) => {\r\n    let field = view.state.field(lintState, false);\r\n    if (!field || !field.panel)\r\n        view.dispatch({ effects: maybeEnableLint(view.state, [togglePanel.of(true)]) });\r\n    let panel = (0,_codemirror_view__WEBPACK_IMPORTED_MODULE_1__.getPanel)(view, LintPanel.open);\r\n    if (panel)\r\n        panel.dom.querySelector(\".cm-panel-lint ul\").focus();\r\n    return true;\r\n};\r\n/**\r\nCommand to close the lint panel, when open.\r\n*/\r\nconst closeLintPanel = (view) => {\r\n    let field = view.state.field(lintState, false);\r\n    if (!field || !field.panel)\r\n        return false;\r\n    view.dispatch({ effects: togglePanel.of(false) });\r\n    return true;\r\n};\r\n/**\r\nMove the selection to the next diagnostic.\r\n*/\r\nconst nextDiagnostic = (view) => {\r\n    let field = view.state.field(lintState, false);\r\n    if (!field)\r\n        return false;\r\n    let sel = view.state.selection.main, next = field.diagnostics.iter(sel.to + 1);\r\n    if (!next.value) {\r\n        next = field.diagnostics.iter(0);\r\n        if (!next.value || next.from == sel.from && next.to == sel.to)\r\n            return false;\r\n    }\r\n    view.dispatch({ selection: { anchor: next.from, head: next.to }, scrollIntoView: true });\r\n    return true;\r\n};\r\n/**\r\nA set of default key bindings for the lint functionality.\r\n\r\n- Ctrl-Shift-m (Cmd-Shift-m on macOS): [`openLintPanel`](https://codemirror.net/6/docs/ref/#lint.openLintPanel)\r\n- F8: [`nextDiagnostic`](https://codemirror.net/6/docs/ref/#lint.nextDiagnostic)\r\n*/\r\nconst lintKeymap = [\r\n    { key: \"Mod-Shift-m\", run: openLintPanel, preventDefault: true },\r\n    { key: \"F8\", run: nextDiagnostic }\r\n];\r\nconst lintPlugin = /*@__PURE__*/_codemirror_view__WEBPACK_IMPORTED_MODULE_1__.ViewPlugin.fromClass(class {\r\n    constructor(view) {\r\n        this.view = view;\r\n        this.timeout = -1;\r\n        this.set = true;\r\n        let { delay } = view.state.facet(lintConfig);\r\n        this.lintTime = Date.now() + delay;\r\n        this.run = this.run.bind(this);\r\n        this.timeout = setTimeout(this.run, delay);\r\n    }\r\n    run() {\r\n        let now = Date.now();\r\n        if (now < this.lintTime - 10) {\r\n            setTimeout(this.run, this.lintTime - now);\r\n        }\r\n        else {\r\n            this.set = false;\r\n            let { state } = this.view, { sources } = state.facet(lintConfig);\r\n            Promise.all(sources.map(source => Promise.resolve(source(this.view)))).then(annotations => {\r\n                let all = annotations.reduce((a, b) => a.concat(b));\r\n                if (this.view.state.doc == state.doc)\r\n                    this.view.dispatch(setDiagnostics(this.view.state, all));\r\n            }, error => { (0,_codemirror_view__WEBPACK_IMPORTED_MODULE_1__.logException)(this.view.state, error); });\r\n        }\r\n    }\r\n    update(update) {\r\n        let config = update.state.facet(lintConfig);\r\n        if (update.docChanged || config != update.startState.facet(lintConfig)) {\r\n            this.lintTime = Date.now() + config.delay;\r\n            if (!this.set) {\r\n                this.set = true;\r\n                this.timeout = setTimeout(this.run, config.delay);\r\n            }\r\n        }\r\n    }\r\n    force() {\r\n        if (this.set) {\r\n            this.lintTime = Date.now();\r\n            this.run();\r\n        }\r\n    }\r\n    destroy() {\r\n        clearTimeout(this.timeout);\r\n    }\r\n});\r\nconst lintConfig = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define({\r\n    combine(input) {\r\n        return Object.assign({ sources: input.map(i => i.source) }, (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.combineConfig)(input.map(i => i.config), {\r\n            delay: 750,\r\n            markerFilter: null,\r\n            tooltipFilter: null\r\n        }));\r\n    },\r\n    enables: lintPlugin\r\n});\r\n/**\r\nGiven a diagnostic source, this function returns an extension that\r\nenables linting with that source. It will be called whenever the\r\neditor is idle (after its content changed).\r\n*/\r\nfunction linter(source, config = {}) {\r\n    return lintConfig.of({ source, config });\r\n}\r\n/**\r\nForces any linters [configured](https://codemirror.net/6/docs/ref/#lint.linter) to run when the\r\neditor is idle to run right away.\r\n*/\r\nfunction forceLinting(view) {\r\n    let plugin = view.plugin(lintPlugin);\r\n    if (plugin)\r\n        plugin.force();\r\n}\r\nfunction assignKeys(actions) {\r\n    let assigned = [];\r\n    if (actions)\r\n        actions: for (let { name } of actions) {\r\n            for (let i = 0; i < name.length; i++) {\r\n                let ch = name[i];\r\n                if (/[a-zA-Z]/.test(ch) && !assigned.some(c => c.toLowerCase() == ch.toLowerCase())) {\r\n                    assigned.push(ch);\r\n                    continue actions;\r\n                }\r\n            }\r\n            assigned.push(\"\");\r\n        }\r\n    return assigned;\r\n}\r\nfunction renderDiagnostic(view, diagnostic, inPanel) {\r\n    var _a;\r\n    let keys = inPanel ? assignKeys(diagnostic.actions) : [];\r\n    return (0,crelt__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"li\", { class: \"cm-diagnostic cm-diagnostic-\" + diagnostic.severity }, (0,crelt__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"span\", { class: \"cm-diagnosticText\" }, diagnostic.renderMessage ? diagnostic.renderMessage() : diagnostic.message), (_a = diagnostic.actions) === null || _a === void 0 ? void 0 : _a.map((action, i) => {\r\n        let click = (e) => {\r\n            e.preventDefault();\r\n            let found = findDiagnostic(view.state.field(lintState).diagnostics, diagnostic);\r\n            if (found)\r\n                action.apply(view, found.from, found.to);\r\n        };\r\n        let { name } = action, keyIndex = keys[i] ? name.indexOf(keys[i]) : -1;\r\n        let nameElt = keyIndex < 0 ? name : [name.slice(0, keyIndex),\r\n            (0,crelt__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"u\", name.slice(keyIndex, keyIndex + 1)),\r\n            name.slice(keyIndex + 1)];\r\n        return (0,crelt__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"button\", {\r\n            type: \"button\",\r\n            class: \"cm-diagnosticAction\",\r\n            onclick: click,\r\n            onmousedown: click,\r\n            \"aria-label\": ` Action: ${name}${keyIndex < 0 ? \"\" : ` (access key \"${keys[i]})\"`}.`\r\n        }, nameElt);\r\n    }), diagnostic.source && (0,crelt__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"div\", { class: \"cm-diagnosticSource\" }, diagnostic.source));\r\n}\r\nclass DiagnosticWidget extends _codemirror_view__WEBPACK_IMPORTED_MODULE_1__.WidgetType {\r\n    constructor(diagnostic) {\r\n        super();\r\n        this.diagnostic = diagnostic;\r\n    }\r\n    eq(other) { return other.diagnostic == this.diagnostic; }\r\n    toDOM() {\r\n        return (0,crelt__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"span\", { class: \"cm-lintPoint cm-lintPoint-\" + this.diagnostic.severity });\r\n    }\r\n}\r\nclass PanelItem {\r\n    constructor(view, diagnostic) {\r\n        this.diagnostic = diagnostic;\r\n        this.id = \"item_\" + Math.floor(Math.random() * 0xffffffff).toString(16);\r\n        this.dom = renderDiagnostic(view, diagnostic, true);\r\n        this.dom.id = this.id;\r\n        this.dom.setAttribute(\"role\", \"option\");\r\n    }\r\n}\r\nclass LintPanel {\r\n    constructor(view) {\r\n        this.view = view;\r\n        this.items = [];\r\n        let onkeydown = (event) => {\r\n            if (event.keyCode == 27) { // Escape\r\n                closeLintPanel(this.view);\r\n                this.view.focus();\r\n            }\r\n            else if (event.keyCode == 38 || event.keyCode == 33) { // ArrowUp, PageUp\r\n                this.moveSelection((this.selectedIndex - 1 + this.items.length) % this.items.length);\r\n            }\r\n            else if (event.keyCode == 40 || event.keyCode == 34) { // ArrowDown, PageDown\r\n                this.moveSelection((this.selectedIndex + 1) % this.items.length);\r\n            }\r\n            else if (event.keyCode == 36) { // Home\r\n                this.moveSelection(0);\r\n            }\r\n            else if (event.keyCode == 35) { // End\r\n                this.moveSelection(this.items.length - 1);\r\n            }\r\n            else if (event.keyCode == 13) { // Enter\r\n                this.view.focus();\r\n            }\r\n            else if (event.keyCode >= 65 && event.keyCode <= 90 && this.selectedIndex >= 0) { // A-Z\r\n                let { diagnostic } = this.items[this.selectedIndex], keys = assignKeys(diagnostic.actions);\r\n                for (let i = 0; i < keys.length; i++)\r\n                    if (keys[i].toUpperCase().charCodeAt(0) == event.keyCode) {\r\n                        let found = findDiagnostic(this.view.state.field(lintState).diagnostics, diagnostic);\r\n                        if (found)\r\n                            diagnostic.actions[i].apply(view, found.from, found.to);\r\n                    }\r\n            }\r\n            else {\r\n                return;\r\n            }\r\n            event.preventDefault();\r\n        };\r\n        let onclick = (event) => {\r\n            for (let i = 0; i < this.items.length; i++) {\r\n                if (this.items[i].dom.contains(event.target))\r\n                    this.moveSelection(i);\r\n            }\r\n        };\r\n        this.list = (0,crelt__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"ul\", {\r\n            tabIndex: 0,\r\n            role: \"listbox\",\r\n            \"aria-label\": this.view.state.phrase(\"Diagnostics\"),\r\n            onkeydown,\r\n            onclick\r\n        });\r\n        this.dom = (0,crelt__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"div\", { class: \"cm-panel-lint\" }, this.list, (0,crelt__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"button\", {\r\n            type: \"button\",\r\n            name: \"close\",\r\n            \"aria-label\": this.view.state.phrase(\"close\"),\r\n            onclick: () => closeLintPanel(this.view)\r\n        }, \"×\"));\r\n        this.update();\r\n    }\r\n    get selectedIndex() {\r\n        let selected = this.view.state.field(lintState).selected;\r\n        if (!selected)\r\n            return -1;\r\n        for (let i = 0; i < this.items.length; i++)\r\n            if (this.items[i].diagnostic == selected.diagnostic)\r\n                return i;\r\n        return -1;\r\n    }\r\n    update() {\r\n        let { diagnostics, selected } = this.view.state.field(lintState);\r\n        let i = 0, needsSync = false, newSelectedItem = null;\r\n        diagnostics.between(0, this.view.state.doc.length, (_start, _end, { spec }) => {\r\n            let found = -1, item;\r\n            for (let j = i; j < this.items.length; j++)\r\n                if (this.items[j].diagnostic == spec.diagnostic) {\r\n                    found = j;\r\n                    break;\r\n                }\r\n            if (found < 0) {\r\n                item = new PanelItem(this.view, spec.diagnostic);\r\n                this.items.splice(i, 0, item);\r\n                needsSync = true;\r\n            }\r\n            else {\r\n                item = this.items[found];\r\n                if (found > i) {\r\n                    this.items.splice(i, found - i);\r\n                    needsSync = true;\r\n                }\r\n            }\r\n            if (selected && item.diagnostic == selected.diagnostic) {\r\n                if (!item.dom.hasAttribute(\"aria-selected\")) {\r\n                    item.dom.setAttribute(\"aria-selected\", \"true\");\r\n                    newSelectedItem = item;\r\n                }\r\n            }\r\n            else if (item.dom.hasAttribute(\"aria-selected\")) {\r\n                item.dom.removeAttribute(\"aria-selected\");\r\n            }\r\n            i++;\r\n        });\r\n        while (i < this.items.length && !(this.items.length == 1 && this.items[0].diagnostic.from < 0)) {\r\n            needsSync = true;\r\n            this.items.pop();\r\n        }\r\n        if (this.items.length == 0) {\r\n            this.items.push(new PanelItem(this.view, {\r\n                from: -1, to: -1,\r\n                severity: \"info\",\r\n                message: this.view.state.phrase(\"No diagnostics\")\r\n            }));\r\n            needsSync = true;\r\n        }\r\n        if (newSelectedItem) {\r\n            this.list.setAttribute(\"aria-activedescendant\", newSelectedItem.id);\r\n            this.view.requestMeasure({\r\n                key: this,\r\n                read: () => ({ sel: newSelectedItem.dom.getBoundingClientRect(), panel: this.list.getBoundingClientRect() }),\r\n                write: ({ sel, panel }) => {\r\n                    if (sel.top < panel.top)\r\n                        this.list.scrollTop -= panel.top - sel.top;\r\n                    else if (sel.bottom > panel.bottom)\r\n                        this.list.scrollTop += sel.bottom - panel.bottom;\r\n                }\r\n            });\r\n        }\r\n        else if (this.selectedIndex < 0) {\r\n            this.list.removeAttribute(\"aria-activedescendant\");\r\n        }\r\n        if (needsSync)\r\n            this.sync();\r\n    }\r\n    sync() {\r\n        let domPos = this.list.firstChild;\r\n        function rm() {\r\n            let prev = domPos;\r\n            domPos = prev.nextSibling;\r\n            prev.remove();\r\n        }\r\n        for (let item of this.items) {\r\n            if (item.dom.parentNode == this.list) {\r\n                while (domPos != item.dom)\r\n                    rm();\r\n                domPos = item.dom.nextSibling;\r\n            }\r\n            else {\r\n                this.list.insertBefore(item.dom, domPos);\r\n            }\r\n        }\r\n        while (domPos)\r\n            rm();\r\n    }\r\n    moveSelection(selectedIndex) {\r\n        if (this.selectedIndex < 0)\r\n            return;\r\n        let field = this.view.state.field(lintState);\r\n        let selection = findDiagnostic(field.diagnostics, this.items[selectedIndex].diagnostic);\r\n        if (!selection)\r\n            return;\r\n        this.view.dispatch({\r\n            selection: { anchor: selection.from, head: selection.to },\r\n            scrollIntoView: true,\r\n            effects: movePanelSelection.of(selection)\r\n        });\r\n    }\r\n    static open(view) { return new LintPanel(view); }\r\n}\r\nfunction svg(content, attrs = `viewBox=\"0 0 40 40\"`) {\r\n    return `url('data:image/svg+xml,<svg xmlns=\"http://www.w3.org/2000/svg\" ${attrs}>${encodeURIComponent(content)}</svg>')`;\r\n}\r\nfunction underline(color) {\r\n    return svg(`<path d=\"m0 2.5 l2 -1.5 l1 0 l2 1.5 l1 0\" stroke=\"${color}\" fill=\"none\" stroke-width=\".7\"/>`, `width=\"6\" height=\"3\"`);\r\n}\r\nconst baseTheme = /*@__PURE__*/_codemirror_view__WEBPACK_IMPORTED_MODULE_1__.EditorView.baseTheme({\r\n    \".cm-diagnostic\": {\r\n        padding: \"3px 6px 3px 8px\",\r\n        marginLeft: \"-1px\",\r\n        display: \"block\",\r\n        whiteSpace: \"pre-wrap\"\r\n    },\r\n    \".cm-diagnostic-error\": { borderLeft: \"5px solid #d11\" },\r\n    \".cm-diagnostic-warning\": { borderLeft: \"5px solid orange\" },\r\n    \".cm-diagnostic-info\": { borderLeft: \"5px solid #999\" },\r\n    \".cm-diagnosticAction\": {\r\n        font: \"inherit\",\r\n        border: \"none\",\r\n        padding: \"2px 4px\",\r\n        backgroundColor: \"#444\",\r\n        color: \"white\",\r\n        borderRadius: \"3px\",\r\n        marginLeft: \"8px\"\r\n    },\r\n    \".cm-diagnosticSource\": {\r\n        fontSize: \"70%\",\r\n        opacity: .7\r\n    },\r\n    \".cm-lintRange\": {\r\n        backgroundPosition: \"left bottom\",\r\n        backgroundRepeat: \"repeat-x\",\r\n        paddingBottom: \"0.7px\",\r\n    },\r\n    \".cm-lintRange-error\": { backgroundImage: /*@__PURE__*/underline(\"#d11\") },\r\n    \".cm-lintRange-warning\": { backgroundImage: /*@__PURE__*/underline(\"orange\") },\r\n    \".cm-lintRange-info\": { backgroundImage: /*@__PURE__*/underline(\"#999\") },\r\n    \".cm-lintRange-active\": { backgroundColor: \"#ffdd9980\" },\r\n    \".cm-tooltip-lint\": {\r\n        padding: 0,\r\n        margin: 0\r\n    },\r\n    \".cm-lintPoint\": {\r\n        position: \"relative\",\r\n        \"&:after\": {\r\n            content: '\"\"',\r\n            position: \"absolute\",\r\n            bottom: 0,\r\n            left: \"-2px\",\r\n            borderLeft: \"3px solid transparent\",\r\n            borderRight: \"3px solid transparent\",\r\n            borderBottom: \"4px solid #d11\"\r\n        }\r\n    },\r\n    \".cm-lintPoint-warning\": {\r\n        \"&:after\": { borderBottomColor: \"orange\" }\r\n    },\r\n    \".cm-lintPoint-info\": {\r\n        \"&:after\": { borderBottomColor: \"#999\" }\r\n    },\r\n    \".cm-panel.cm-panel-lint\": {\r\n        position: \"relative\",\r\n        \"& ul\": {\r\n            maxHeight: \"100px\",\r\n            overflowY: \"auto\",\r\n            \"& [aria-selected]\": {\r\n                backgroundColor: \"#ddd\",\r\n                \"& u\": { textDecoration: \"underline\" }\r\n            },\r\n            \"&:focus [aria-selected]\": {\r\n                background_fallback: \"#bdf\",\r\n                backgroundColor: \"Highlight\",\r\n                color_fallback: \"white\",\r\n                color: \"HighlightText\"\r\n            },\r\n            \"& u\": { textDecoration: \"none\" },\r\n            padding: 0,\r\n            margin: 0\r\n        },\r\n        \"& [name=close]\": {\r\n            position: \"absolute\",\r\n            top: \"0\",\r\n            right: \"2px\",\r\n            background: \"inherit\",\r\n            border: \"none\",\r\n            font: \"inherit\",\r\n            padding: 0,\r\n            margin: 0\r\n        }\r\n    }\r\n});\r\nclass LintGutterMarker extends _codemirror_view__WEBPACK_IMPORTED_MODULE_1__.GutterMarker {\r\n    constructor(diagnostics) {\r\n        super();\r\n        this.diagnostics = diagnostics;\r\n        this.severity = diagnostics.reduce((max, d) => {\r\n            let s = d.severity;\r\n            return s == \"error\" || s == \"warning\" && max == \"info\" ? s : max;\r\n        }, \"info\");\r\n    }\r\n    toDOM(view) {\r\n        let elt = document.createElement(\"div\");\r\n        elt.className = \"cm-lint-marker cm-lint-marker-\" + this.severity;\r\n        let diagnostics = this.diagnostics;\r\n        let diagnosticsFilter = view.state.facet(lintGutterConfig).tooltipFilter;\r\n        if (diagnosticsFilter)\r\n            diagnostics = diagnosticsFilter(diagnostics);\r\n        if (diagnostics.length)\r\n            elt.onmouseover = () => gutterMarkerMouseOver(view, elt, diagnostics);\r\n        return elt;\r\n    }\r\n}\r\nfunction trackHoverOn(view, marker) {\r\n    let mousemove = (event) => {\r\n        let rect = marker.getBoundingClientRect();\r\n        if (event.clientX > rect.left - 10 /* Hover.Margin */ && event.clientX < rect.right + 10 /* Hover.Margin */ &&\r\n            event.clientY > rect.top - 10 /* Hover.Margin */ && event.clientY < rect.bottom + 10 /* Hover.Margin */)\r\n            return;\r\n        for (let target = event.target; target; target = target.parentNode) {\r\n            if (target.nodeType == 1 && target.classList.contains(\"cm-tooltip-lint\"))\r\n                return;\r\n        }\r\n        window.removeEventListener(\"mousemove\", mousemove);\r\n        if (view.state.field(lintGutterTooltip))\r\n            view.dispatch({ effects: setLintGutterTooltip.of(null) });\r\n    };\r\n    window.addEventListener(\"mousemove\", mousemove);\r\n}\r\nfunction gutterMarkerMouseOver(view, marker, diagnostics) {\r\n    function hovered() {\r\n        let line = view.elementAtHeight(marker.getBoundingClientRect().top + 5 - view.documentTop);\r\n        const linePos = view.coordsAtPos(line.from);\r\n        if (linePos) {\r\n            view.dispatch({ effects: setLintGutterTooltip.of({\r\n                    pos: line.from,\r\n                    above: false,\r\n                    create() {\r\n                        return {\r\n                            dom: diagnosticsTooltip(view, diagnostics),\r\n                            getCoords: () => marker.getBoundingClientRect()\r\n                        };\r\n                    }\r\n                }) });\r\n        }\r\n        marker.onmouseout = marker.onmousemove = null;\r\n        trackHoverOn(view, marker);\r\n    }\r\n    let { hoverTime } = view.state.facet(lintGutterConfig);\r\n    let hoverTimeout = setTimeout(hovered, hoverTime);\r\n    marker.onmouseout = () => {\r\n        clearTimeout(hoverTimeout);\r\n        marker.onmouseout = marker.onmousemove = null;\r\n    };\r\n    marker.onmousemove = () => {\r\n        clearTimeout(hoverTimeout);\r\n        hoverTimeout = setTimeout(hovered, hoverTime);\r\n    };\r\n}\r\nfunction markersForDiagnostics(doc, diagnostics) {\r\n    let byLine = Object.create(null);\r\n    for (let diagnostic of diagnostics) {\r\n        let line = doc.lineAt(diagnostic.from);\r\n        (byLine[line.from] || (byLine[line.from] = [])).push(diagnostic);\r\n    }\r\n    let markers = [];\r\n    for (let line in byLine) {\r\n        markers.push(new LintGutterMarker(byLine[line]).range(+line));\r\n    }\r\n    return _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.RangeSet.of(markers, true);\r\n}\r\nconst lintGutterExtension = /*@__PURE__*/(0,_codemirror_view__WEBPACK_IMPORTED_MODULE_1__.gutter)({\r\n    class: \"cm-gutter-lint\",\r\n    markers: view => view.state.field(lintGutterMarkers),\r\n});\r\nconst lintGutterMarkers = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.StateField.define({\r\n    create() {\r\n        return _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.RangeSet.empty;\r\n    },\r\n    update(markers, tr) {\r\n        markers = markers.map(tr.changes);\r\n        let diagnosticFilter = tr.state.facet(lintGutterConfig).markerFilter;\r\n        for (let effect of tr.effects) {\r\n            if (effect.is(setDiagnosticsEffect)) {\r\n                let diagnostics = effect.value;\r\n                if (diagnosticFilter)\r\n                    diagnostics = diagnosticFilter(diagnostics || []);\r\n                markers = markersForDiagnostics(tr.state.doc, diagnostics.slice(0));\r\n            }\r\n        }\r\n        return markers;\r\n    }\r\n});\r\nconst setLintGutterTooltip = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.StateEffect.define();\r\nconst lintGutterTooltip = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.StateField.define({\r\n    create() { return null; },\r\n    update(tooltip, tr) {\r\n        if (tooltip && tr.docChanged)\r\n            tooltip = hideTooltip(tr, tooltip) ? null : Object.assign(Object.assign({}, tooltip), { pos: tr.changes.mapPos(tooltip.pos) });\r\n        return tr.effects.reduce((t, e) => e.is(setLintGutterTooltip) ? e.value : t, tooltip);\r\n    },\r\n    provide: field => _codemirror_view__WEBPACK_IMPORTED_MODULE_1__.showTooltip.from(field)\r\n});\r\nconst lintGutterTheme = /*@__PURE__*/_codemirror_view__WEBPACK_IMPORTED_MODULE_1__.EditorView.baseTheme({\r\n    \".cm-gutter-lint\": {\r\n        width: \"1.4em\",\r\n        \"& .cm-gutterElement\": {\r\n            padding: \".2em\"\r\n        }\r\n    },\r\n    \".cm-lint-marker\": {\r\n        width: \"1em\",\r\n        height: \"1em\"\r\n    },\r\n    \".cm-lint-marker-info\": {\r\n        content: /*@__PURE__*/svg(`<path fill=\"#aaf\" stroke=\"#77e\" stroke-width=\"6\" stroke-linejoin=\"round\" d=\"M5 5L35 5L35 35L5 35Z\"/>`)\r\n    },\r\n    \".cm-lint-marker-warning\": {\r\n        content: /*@__PURE__*/svg(`<path fill=\"#fe8\" stroke=\"#fd7\" stroke-width=\"6\" stroke-linejoin=\"round\" d=\"M20 6L37 35L3 35Z\"/>`),\r\n    },\r\n    \".cm-lint-marker-error\": {\r\n        content: /*@__PURE__*/svg(`<circle cx=\"20\" cy=\"20\" r=\"15\" fill=\"#f87\" stroke=\"#f43\" stroke-width=\"6\"/>`)\r\n    },\r\n});\r\nconst lintGutterConfig = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define({\r\n    combine(configs) {\r\n        return (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.combineConfig)(configs, {\r\n            hoverTime: 300 /* Hover.Time */,\r\n            markerFilter: null,\r\n            tooltipFilter: null\r\n        });\r\n    }\r\n});\r\n/**\r\nReturns an extension that installs a gutter showing markers for\r\neach line that has diagnostics, which can be hovered over to see\r\nthe diagnostics.\r\n*/\r\nfunction lintGutter(config = {}) {\r\n    return [lintGutterConfig.of(config), lintGutterMarkers, lintGutterExtension, lintGutterTheme, lintGutterTooltip];\r\n}\r\n/**\r\nIterate over the marked diagnostics for the given editor state,\r\ncalling `f` for each of them. Note that, if the document changed\r\nsince the diagnostics werecreated, the `Diagnostic` object will\r\nhold the original outdated position, whereas the `to` and `from`\r\narguments hold the diagnostic's current position.\r\n*/\r\nfunction forEachDiagnostic(state, f) {\r\n    let lState = state.field(lintState, false);\r\n    if (lState && lState.diagnostics.size)\r\n        for (let iter = _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.RangeSet.iter([lState.diagnostics]); iter.value; iter.next())\r\n            f(iter.value.spec.diagnostic, iter.from, iter.to);\r\n}\r\n\r\n\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGNvZGVtaXJyb3IvbGludC9kaXN0L2luZGV4LmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQXNLO0FBQzFFO0FBQ3BFO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsNERBQWM7QUFDbkM7QUFDQTtBQUNBLGtCQUFrQiwrREFBaUI7QUFDbkM7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixrQkFBa0IsNkRBQWU7QUFDakMsa0NBQWtDLGtEQUFrRDtBQUNwRjtBQUNBLGlCQUFpQjtBQUNqQixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxNQUFNO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9FQUFvRSwwRUFBMkI7QUFDL0Y7QUFDQSxRQUFRLDRFQUE4QjtBQUN0QyxrQkFBa0Isa0JBQWtCO0FBQ3BDLHlFQUF5RSw2REFBZSxHQUFHLDREQUFjO0FBQ3pHO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsUUFBUSw4REFBWSxnQkFBZ0IscUJBQXFCO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsaUVBQWtCO0FBQzVELGlDQUFpQyxpRUFBa0I7QUFDbkQsd0NBQXdDLGlFQUFrQjtBQUMxRCwrQkFBK0IsZ0VBQWlCO0FBQ2hEO0FBQ0EsNkJBQTZCLDZEQUFlO0FBQzVDLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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O0FBQzVCO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qiw0REFBYSx3QkFBd0IsWUFBWTtBQUN6RTtBQUNBO0FBQ0E7QUFDaUwiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0Bjb2RlbWlycm9yL2xpbnQvZGlzdC9pbmRleC5qcz8zNzc3Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IERlY29yYXRpb24sIHNob3dQYW5lbCwgRWRpdG9yVmlldywgVmlld1BsdWdpbiwgbG9nRXhjZXB0aW9uLCBndXR0ZXIsIHNob3dUb29sdGlwLCBnZXRQYW5lbCwgV2lkZ2V0VHlwZSwgaG92ZXJUb29sdGlwLCBHdXR0ZXJNYXJrZXIgfSBmcm9tICdAY29kZW1pcnJvci92aWV3JztcclxuaW1wb3J0IHsgU3RhdGVFZmZlY3QsIFN0YXRlRmllbGQsIEZhY2V0LCBjb21iaW5lQ29uZmlnLCBSYW5nZVNldCB9IGZyb20gJ0Bjb2RlbWlycm9yL3N0YXRlJztcclxuaW1wb3J0IGVsdCBmcm9tICdjcmVsdCc7XHJcblxyXG5jbGFzcyBTZWxlY3RlZERpYWdub3N0aWMge1xyXG4gICAgY29uc3RydWN0b3IoZnJvbSwgdG8sIGRpYWdub3N0aWMpIHtcclxuICAgICAgICB0aGlzLmZyb20gPSBmcm9tO1xyXG4gICAgICAgIHRoaXMudG8gPSB0bztcclxuICAgICAgICB0aGlzLmRpYWdub3N0aWMgPSBkaWFnbm9zdGljO1xyXG4gICAgfVxyXG59XHJcbmNsYXNzIExpbnRTdGF0ZSB7XHJcbiAgICBjb25zdHJ1Y3RvcihkaWFnbm9zdGljcywgcGFuZWwsIHNlbGVjdGVkKSB7XHJcbiAgICAgICAgdGhpcy5kaWFnbm9zdGljcyA9IGRpYWdub3N0aWNzO1xyXG4gICAgICAgIHRoaXMucGFuZWwgPSBwYW5lbDtcclxuICAgICAgICB0aGlzLnNlbGVjdGVkID0gc2VsZWN0ZWQ7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgaW5pdChkaWFnbm9zdGljcywgcGFuZWwsIHN0YXRlKSB7XHJcbiAgICAgICAgLy8gRmlsdGVyIHRoZSBsaXN0IG9mIGRpYWdub3N0aWNzIGZvciB3aGljaCB0byBjcmVhdGUgbWFya2Vyc1xyXG4gICAgICAgIGxldCBtYXJrZWREaWFnbm9zdGljcyA9IGRpYWdub3N0aWNzO1xyXG4gICAgICAgIGxldCBkaWFnbm9zdGljRmlsdGVyID0gc3RhdGUuZmFjZXQobGludENvbmZpZykubWFya2VyRmlsdGVyO1xyXG4gICAgICAgIGlmIChkaWFnbm9zdGljRmlsdGVyKVxyXG4gICAgICAgICAgICBtYXJrZWREaWFnbm9zdGljcyA9IGRpYWdub3N0aWNGaWx0ZXIobWFya2VkRGlhZ25vc3RpY3MpO1xyXG4gICAgICAgIGxldCByYW5nZXMgPSBEZWNvcmF0aW9uLnNldChtYXJrZWREaWFnbm9zdGljcy5tYXAoKGQpID0+IHtcclxuICAgICAgICAgICAgLy8gRm9yIHplcm8tbGVuZ3RoIHJhbmdlcyBvciByYW5nZXMgY292ZXJpbmcgb25seSBhIGxpbmUgYnJlYWssIGNyZWF0ZSBhIHdpZGdldFxyXG4gICAgICAgICAgICByZXR1cm4gZC5mcm9tID09IGQudG8gfHwgKGQuZnJvbSA9PSBkLnRvIC0gMSAmJiBzdGF0ZS5kb2MubGluZUF0KGQuZnJvbSkudG8gPT0gZC5mcm9tKVxyXG4gICAgICAgICAgICAgICAgPyBEZWNvcmF0aW9uLndpZGdldCh7XHJcbiAgICAgICAgICAgICAgICAgICAgd2lkZ2V0OiBuZXcgRGlhZ25vc3RpY1dpZGdldChkKSxcclxuICAgICAgICAgICAgICAgICAgICBkaWFnbm9zdGljOiBkXHJcbiAgICAgICAgICAgICAgICB9KS5yYW5nZShkLmZyb20pXHJcbiAgICAgICAgICAgICAgICA6IERlY29yYXRpb24ubWFyayh7XHJcbiAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlczogeyBjbGFzczogXCJjbS1saW50UmFuZ2UgY20tbGludFJhbmdlLVwiICsgZC5zZXZlcml0eSB9LFxyXG4gICAgICAgICAgICAgICAgICAgIGRpYWdub3N0aWM6IGRcclxuICAgICAgICAgICAgICAgIH0pLnJhbmdlKGQuZnJvbSwgZC50byk7XHJcbiAgICAgICAgfSksIHRydWUpO1xyXG4gICAgICAgIHJldHVybiBuZXcgTGludFN0YXRlKHJhbmdlcywgcGFuZWwsIGZpbmREaWFnbm9zdGljKHJhbmdlcykpO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGZpbmREaWFnbm9zdGljKGRpYWdub3N0aWNzLCBkaWFnbm9zdGljID0gbnVsbCwgYWZ0ZXIgPSAwKSB7XHJcbiAgICBsZXQgZm91bmQgPSBudWxsO1xyXG4gICAgZGlhZ25vc3RpY3MuYmV0d2VlbihhZnRlciwgMWU5LCAoZnJvbSwgdG8sIHsgc3BlYyB9KSA9PiB7XHJcbiAgICAgICAgaWYgKGRpYWdub3N0aWMgJiYgc3BlYy5kaWFnbm9zdGljICE9IGRpYWdub3N0aWMpXHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICBmb3VuZCA9IG5ldyBTZWxlY3RlZERpYWdub3N0aWMoZnJvbSwgdG8sIHNwZWMuZGlhZ25vc3RpYyk7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gZm91bmQ7XHJcbn1cclxuZnVuY3Rpb24gaGlkZVRvb2x0aXAodHIsIHRvb2x0aXApIHtcclxuICAgIHJldHVybiAhISh0ci5lZmZlY3RzLnNvbWUoZSA9PiBlLmlzKHNldERpYWdub3N0aWNzRWZmZWN0KSkgfHwgdHIuY2hhbmdlcy50b3VjaGVzUmFuZ2UodG9vbHRpcC5wb3MpKTtcclxufVxyXG5mdW5jdGlvbiBtYXliZUVuYWJsZUxpbnQoc3RhdGUsIGVmZmVjdHMpIHtcclxuICAgIHJldHVybiBzdGF0ZS5maWVsZChsaW50U3RhdGUsIGZhbHNlKSA/IGVmZmVjdHMgOiBlZmZlY3RzLmNvbmNhdChTdGF0ZUVmZmVjdC5hcHBlbmRDb25maWcub2YoW1xyXG4gICAgICAgIGxpbnRTdGF0ZSxcclxuICAgICAgICBFZGl0b3JWaWV3LmRlY29yYXRpb25zLmNvbXB1dGUoW2xpbnRTdGF0ZV0sIHN0YXRlID0+IHtcclxuICAgICAgICAgICAgbGV0IHsgc2VsZWN0ZWQsIHBhbmVsIH0gPSBzdGF0ZS5maWVsZChsaW50U3RhdGUpO1xyXG4gICAgICAgICAgICByZXR1cm4gIXNlbGVjdGVkIHx8ICFwYW5lbCB8fCBzZWxlY3RlZC5mcm9tID09IHNlbGVjdGVkLnRvID8gRGVjb3JhdGlvbi5ub25lIDogRGVjb3JhdGlvbi5zZXQoW1xyXG4gICAgICAgICAgICAgICAgYWN0aXZlTWFyay5yYW5nZShzZWxlY3RlZC5mcm9tLCBzZWxlY3RlZC50bylcclxuICAgICAgICAgICAgXSk7XHJcbiAgICAgICAgfSksXHJcbiAgICAgICAgaG92ZXJUb29sdGlwKGxpbnRUb29sdGlwLCB7IGhpZGVPbjogaGlkZVRvb2x0aXAgfSksXHJcbiAgICAgICAgYmFzZVRoZW1lXHJcbiAgICBdKSk7XHJcbn1cclxuLyoqXHJcblJldHVybnMgYSB0cmFuc2FjdGlvbiBzcGVjIHdoaWNoIHVwZGF0ZXMgdGhlIGN1cnJlbnQgc2V0IG9mXHJcbmRpYWdub3N0aWNzLCBhbmQgZW5hYmxlcyB0aGUgbGludCBleHRlbnNpb24gaWYgaWYgd2Fzbid0IGFscmVhZHlcclxuYWN0aXZlLlxyXG4qL1xyXG5mdW5jdGlvbiBzZXREaWFnbm9zdGljcyhzdGF0ZSwgZGlhZ25vc3RpY3MpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgZWZmZWN0czogbWF5YmVFbmFibGVMaW50KHN0YXRlLCBbc2V0RGlhZ25vc3RpY3NFZmZlY3Qub2YoZGlhZ25vc3RpY3MpXSlcclxuICAgIH07XHJcbn1cclxuLyoqXHJcblRoZSBzdGF0ZSBlZmZlY3QgdGhhdCB1cGRhdGVzIHRoZSBzZXQgb2YgYWN0aXZlIGRpYWdub3N0aWNzLiBDYW5cclxuYmUgdXNlZnVsIHdoZW4gd3JpdGluZyBhbiBleHRlbnNpb24gdGhhdCBuZWVkcyB0byB0cmFjayB0aGVzZS5cclxuKi9cclxuY29uc3Qgc2V0RGlhZ25vc3RpY3NFZmZlY3QgPSAvKkBfX1BVUkVfXyovU3RhdGVFZmZlY3QuZGVmaW5lKCk7XHJcbmNvbnN0IHRvZ2dsZVBhbmVsID0gLypAX19QVVJFX18qL1N0YXRlRWZmZWN0LmRlZmluZSgpO1xyXG5jb25zdCBtb3ZlUGFuZWxTZWxlY3Rpb24gPSAvKkBfX1BVUkVfXyovU3RhdGVFZmZlY3QuZGVmaW5lKCk7XHJcbmNvbnN0IGxpbnRTdGF0ZSA9IC8qQF9fUFVSRV9fKi9TdGF0ZUZpZWxkLmRlZmluZSh7XHJcbiAgICBjcmVhdGUoKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBMaW50U3RhdGUoRGVjb3JhdGlvbi5ub25lLCBudWxsLCBudWxsKTtcclxuICAgIH0sXHJcbiAgICB1cGRhdGUodmFsdWUsIHRyKSB7XHJcbiAgICAgICAgaWYgKHRyLmRvY0NoYW5nZWQpIHtcclxuICAgICAgICAgICAgbGV0IG1hcHBlZCA9IHZhbHVlLmRpYWdub3N0aWNzLm1hcCh0ci5jaGFuZ2VzKSwgc2VsZWN0ZWQgPSBudWxsO1xyXG4gICAgICAgICAgICBpZiAodmFsdWUuc2VsZWN0ZWQpIHtcclxuICAgICAgICAgICAgICAgIGxldCBzZWxQb3MgPSB0ci5jaGFuZ2VzLm1hcFBvcyh2YWx1ZS5zZWxlY3RlZC5mcm9tLCAxKTtcclxuICAgICAgICAgICAgICAgIHNlbGVjdGVkID0gZmluZERpYWdub3N0aWMobWFwcGVkLCB2YWx1ZS5zZWxlY3RlZC5kaWFnbm9zdGljLCBzZWxQb3MpIHx8IGZpbmREaWFnbm9zdGljKG1hcHBlZCwgbnVsbCwgc2VsUG9zKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YWx1ZSA9IG5ldyBMaW50U3RhdGUobWFwcGVkLCB2YWx1ZS5wYW5lbCwgc2VsZWN0ZWQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmb3IgKGxldCBlZmZlY3Qgb2YgdHIuZWZmZWN0cykge1xyXG4gICAgICAgICAgICBpZiAoZWZmZWN0LmlzKHNldERpYWdub3N0aWNzRWZmZWN0KSkge1xyXG4gICAgICAgICAgICAgICAgdmFsdWUgPSBMaW50U3RhdGUuaW5pdChlZmZlY3QudmFsdWUsIHZhbHVlLnBhbmVsLCB0ci5zdGF0ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoZWZmZWN0LmlzKHRvZ2dsZVBhbmVsKSkge1xyXG4gICAgICAgICAgICAgICAgdmFsdWUgPSBuZXcgTGludFN0YXRlKHZhbHVlLmRpYWdub3N0aWNzLCBlZmZlY3QudmFsdWUgPyBMaW50UGFuZWwub3BlbiA6IG51bGwsIHZhbHVlLnNlbGVjdGVkKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChlZmZlY3QuaXMobW92ZVBhbmVsU2VsZWN0aW9uKSkge1xyXG4gICAgICAgICAgICAgICAgdmFsdWUgPSBuZXcgTGludFN0YXRlKHZhbHVlLmRpYWdub3N0aWNzLCB2YWx1ZS5wYW5lbCwgZWZmZWN0LnZhbHVlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdmFsdWU7XHJcbiAgICB9LFxyXG4gICAgcHJvdmlkZTogZiA9PiBbc2hvd1BhbmVsLmZyb20oZiwgdmFsID0+IHZhbC5wYW5lbCksXHJcbiAgICAgICAgRWRpdG9yVmlldy5kZWNvcmF0aW9ucy5mcm9tKGYsIHMgPT4gcy5kaWFnbm9zdGljcyldXHJcbn0pO1xyXG4vKipcclxuUmV0dXJucyB0aGUgbnVtYmVyIG9mIGFjdGl2ZSBsaW50IGRpYWdub3N0aWNzIGluIHRoZSBnaXZlbiBzdGF0ZS5cclxuKi9cclxuZnVuY3Rpb24gZGlhZ25vc3RpY0NvdW50KHN0YXRlKSB7XHJcbiAgICBsZXQgbGludCA9IHN0YXRlLmZpZWxkKGxpbnRTdGF0ZSwgZmFsc2UpO1xyXG4gICAgcmV0dXJuIGxpbnQgPyBsaW50LmRpYWdub3N0aWNzLnNpemUgOiAwO1xyXG59XHJcbmNvbnN0IGFjdGl2ZU1hcmsgPSAvKkBfX1BVUkVfXyovRGVjb3JhdGlvbi5tYXJrKHsgY2xhc3M6IFwiY20tbGludFJhbmdlIGNtLWxpbnRSYW5nZS1hY3RpdmVcIiB9KTtcclxuZnVuY3Rpb24gbGludFRvb2x0aXAodmlldywgcG9zLCBzaWRlKSB7XHJcbiAgICBsZXQgeyBkaWFnbm9zdGljcyB9ID0gdmlldy5zdGF0ZS5maWVsZChsaW50U3RhdGUpO1xyXG4gICAgbGV0IGZvdW5kID0gW10sIHN0YWNrU3RhcnQgPSAyZTgsIHN0YWNrRW5kID0gMDtcclxuICAgIGRpYWdub3N0aWNzLmJldHdlZW4ocG9zIC0gKHNpZGUgPCAwID8gMSA6IDApLCBwb3MgKyAoc2lkZSA+IDAgPyAxIDogMCksIChmcm9tLCB0bywgeyBzcGVjIH0pID0+IHtcclxuICAgICAgICBpZiAocG9zID49IGZyb20gJiYgcG9zIDw9IHRvICYmXHJcbiAgICAgICAgICAgIChmcm9tID09IHRvIHx8ICgocG9zID4gZnJvbSB8fCBzaWRlID4gMCkgJiYgKHBvcyA8IHRvIHx8IHNpZGUgPCAwKSkpKSB7XHJcbiAgICAgICAgICAgIGZvdW5kLnB1c2goc3BlYy5kaWFnbm9zdGljKTtcclxuICAgICAgICAgICAgc3RhY2tTdGFydCA9IE1hdGgubWluKGZyb20sIHN0YWNrU3RhcnQpO1xyXG4gICAgICAgICAgICBzdGFja0VuZCA9IE1hdGgubWF4KHRvLCBzdGFja0VuZCk7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICBsZXQgZGlhZ25vc3RpY0ZpbHRlciA9IHZpZXcuc3RhdGUuZmFjZXQobGludENvbmZpZykudG9vbHRpcEZpbHRlcjtcclxuICAgIGlmIChkaWFnbm9zdGljRmlsdGVyKVxyXG4gICAgICAgIGZvdW5kID0gZGlhZ25vc3RpY0ZpbHRlcihmb3VuZCk7XHJcbiAgICBpZiAoIWZvdW5kLmxlbmd0aClcclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgcG9zOiBzdGFja1N0YXJ0LFxyXG4gICAgICAgIGVuZDogc3RhY2tFbmQsXHJcbiAgICAgICAgYWJvdmU6IHZpZXcuc3RhdGUuZG9jLmxpbmVBdChzdGFja1N0YXJ0KS50byA8IHN0YWNrRW5kLFxyXG4gICAgICAgIGNyZWF0ZSgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHsgZG9tOiBkaWFnbm9zdGljc1Rvb2x0aXAodmlldywgZm91bmQpIH07XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiBkaWFnbm9zdGljc1Rvb2x0aXAodmlldywgZGlhZ25vc3RpY3MpIHtcclxuICAgIHJldHVybiBlbHQoXCJ1bFwiLCB7IGNsYXNzOiBcImNtLXRvb2x0aXAtbGludFwiIH0sIGRpYWdub3N0aWNzLm1hcChkID0+IHJlbmRlckRpYWdub3N0aWModmlldywgZCwgZmFsc2UpKSk7XHJcbn1cclxuLyoqXHJcbkNvbW1hbmQgdG8gb3BlbiBhbmQgZm9jdXMgdGhlIGxpbnQgcGFuZWwuXHJcbiovXHJcbmNvbnN0IG9wZW5MaW50UGFuZWwgPSAodmlldykgPT4ge1xyXG4gICAgbGV0IGZpZWxkID0gdmlldy5zdGF0ZS5maWVsZChsaW50U3RhdGUsIGZhbHNlKTtcclxuICAgIGlmICghZmllbGQgfHwgIWZpZWxkLnBhbmVsKVxyXG4gICAgICAgIHZpZXcuZGlzcGF0Y2goeyBlZmZlY3RzOiBtYXliZUVuYWJsZUxpbnQodmlldy5zdGF0ZSwgW3RvZ2dsZVBhbmVsLm9mKHRydWUpXSkgfSk7XHJcbiAgICBsZXQgcGFuZWwgPSBnZXRQYW5lbCh2aWV3LCBMaW50UGFuZWwub3Blbik7XHJcbiAgICBpZiAocGFuZWwpXHJcbiAgICAgICAgcGFuZWwuZG9tLnF1ZXJ5U2VsZWN0b3IoXCIuY20tcGFuZWwtbGludCB1bFwiKS5mb2N1cygpO1xyXG4gICAgcmV0dXJuIHRydWU7XHJcbn07XHJcbi8qKlxyXG5Db21tYW5kIHRvIGNsb3NlIHRoZSBsaW50IHBhbmVsLCB3aGVuIG9wZW4uXHJcbiovXHJcbmNvbnN0IGNsb3NlTGludFBhbmVsID0gKHZpZXcpID0+IHtcclxuICAgIGxldCBmaWVsZCA9IHZpZXcuc3RhdGUuZmllbGQobGludFN0YXRlLCBmYWxzZSk7XHJcbiAgICBpZiAoIWZpZWxkIHx8ICFmaWVsZC5wYW5lbClcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB2aWV3LmRpc3BhdGNoKHsgZWZmZWN0czogdG9nZ2xlUGFuZWwub2YoZmFsc2UpIH0pO1xyXG4gICAgcmV0dXJuIHRydWU7XHJcbn07XHJcbi8qKlxyXG5Nb3ZlIHRoZSBzZWxlY3Rpb24gdG8gdGhlIG5leHQgZGlhZ25vc3RpYy5cclxuKi9cclxuY29uc3QgbmV4dERpYWdub3N0aWMgPSAodmlldykgPT4ge1xyXG4gICAgbGV0IGZpZWxkID0gdmlldy5zdGF0ZS5maWVsZChsaW50U3RhdGUsIGZhbHNlKTtcclxuICAgIGlmICghZmllbGQpXHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgbGV0IHNlbCA9IHZpZXcuc3RhdGUuc2VsZWN0aW9uLm1haW4sIG5leHQgPSBmaWVsZC5kaWFnbm9zdGljcy5pdGVyKHNlbC50byArIDEpO1xyXG4gICAgaWYgKCFuZXh0LnZhbHVlKSB7XHJcbiAgICAgICAgbmV4dCA9IGZpZWxkLmRpYWdub3N0aWNzLml0ZXIoMCk7XHJcbiAgICAgICAgaWYgKCFuZXh0LnZhbHVlIHx8IG5leHQuZnJvbSA9PSBzZWwuZnJvbSAmJiBuZXh0LnRvID09IHNlbC50bylcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgdmlldy5kaXNwYXRjaCh7IHNlbGVjdGlvbjogeyBhbmNob3I6IG5leHQuZnJvbSwgaGVhZDogbmV4dC50byB9LCBzY3JvbGxJbnRvVmlldzogdHJ1ZSB9KTtcclxuICAgIHJldHVybiB0cnVlO1xyXG59O1xyXG4vKipcclxuQSBzZXQgb2YgZGVmYXVsdCBrZXkgYmluZGluZ3MgZm9yIHRoZSBsaW50IGZ1bmN0aW9uYWxpdHkuXHJcblxyXG4tIEN0cmwtU2hpZnQtbSAoQ21kLVNoaWZ0LW0gb24gbWFjT1MpOiBbYG9wZW5MaW50UGFuZWxgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2xpbnQub3BlbkxpbnRQYW5lbClcclxuLSBGODogW2BuZXh0RGlhZ25vc3RpY2BdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jbGludC5uZXh0RGlhZ25vc3RpYylcclxuKi9cclxuY29uc3QgbGludEtleW1hcCA9IFtcclxuICAgIHsga2V5OiBcIk1vZC1TaGlmdC1tXCIsIHJ1bjogb3BlbkxpbnRQYW5lbCwgcHJldmVudERlZmF1bHQ6IHRydWUgfSxcclxuICAgIHsga2V5OiBcIkY4XCIsIHJ1bjogbmV4dERpYWdub3N0aWMgfVxyXG5dO1xyXG5jb25zdCBsaW50UGx1Z2luID0gLypAX19QVVJFX18qL1ZpZXdQbHVnaW4uZnJvbUNsYXNzKGNsYXNzIHtcclxuICAgIGNvbnN0cnVjdG9yKHZpZXcpIHtcclxuICAgICAgICB0aGlzLnZpZXcgPSB2aWV3O1xyXG4gICAgICAgIHRoaXMudGltZW91dCA9IC0xO1xyXG4gICAgICAgIHRoaXMuc2V0ID0gdHJ1ZTtcclxuICAgICAgICBsZXQgeyBkZWxheSB9ID0gdmlldy5zdGF0ZS5mYWNldChsaW50Q29uZmlnKTtcclxuICAgICAgICB0aGlzLmxpbnRUaW1lID0gRGF0ZS5ub3coKSArIGRlbGF5O1xyXG4gICAgICAgIHRoaXMucnVuID0gdGhpcy5ydW4uYmluZCh0aGlzKTtcclxuICAgICAgICB0aGlzLnRpbWVvdXQgPSBzZXRUaW1lb3V0KHRoaXMucnVuLCBkZWxheSk7XHJcbiAgICB9XHJcbiAgICBydW4oKSB7XHJcbiAgICAgICAgbGV0IG5vdyA9IERhdGUubm93KCk7XHJcbiAgICAgICAgaWYgKG5vdyA8IHRoaXMubGludFRpbWUgLSAxMCkge1xyXG4gICAgICAgICAgICBzZXRUaW1lb3V0KHRoaXMucnVuLCB0aGlzLmxpbnRUaW1lIC0gbm93KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2V0ID0gZmFsc2U7XHJcbiAgICAgICAgICAgIGxldCB7IHN0YXRlIH0gPSB0aGlzLnZpZXcsIHsgc291cmNlcyB9ID0gc3RhdGUuZmFjZXQobGludENvbmZpZyk7XHJcbiAgICAgICAgICAgIFByb21pc2UuYWxsKHNvdXJjZXMubWFwKHNvdXJjZSA9PiBQcm9taXNlLnJlc29sdmUoc291cmNlKHRoaXMudmlldykpKSkudGhlbihhbm5vdGF0aW9ucyA9PiB7XHJcbiAgICAgICAgICAgICAgICBsZXQgYWxsID0gYW5ub3RhdGlvbnMucmVkdWNlKChhLCBiKSA9PiBhLmNvbmNhdChiKSk7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy52aWV3LnN0YXRlLmRvYyA9PSBzdGF0ZS5kb2MpXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy52aWV3LmRpc3BhdGNoKHNldERpYWdub3N0aWNzKHRoaXMudmlldy5zdGF0ZSwgYWxsKSk7XHJcbiAgICAgICAgICAgIH0sIGVycm9yID0+IHsgbG9nRXhjZXB0aW9uKHRoaXMudmlldy5zdGF0ZSwgZXJyb3IpOyB9KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICB1cGRhdGUodXBkYXRlKSB7XHJcbiAgICAgICAgbGV0IGNvbmZpZyA9IHVwZGF0ZS5zdGF0ZS5mYWNldChsaW50Q29uZmlnKTtcclxuICAgICAgICBpZiAodXBkYXRlLmRvY0NoYW5nZWQgfHwgY29uZmlnICE9IHVwZGF0ZS5zdGFydFN0YXRlLmZhY2V0KGxpbnRDb25maWcpKSB7XHJcbiAgICAgICAgICAgIHRoaXMubGludFRpbWUgPSBEYXRlLm5vdygpICsgY29uZmlnLmRlbGF5O1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMuc2V0KSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNldCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnRpbWVvdXQgPSBzZXRUaW1lb3V0KHRoaXMucnVuLCBjb25maWcuZGVsYXkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZm9yY2UoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuc2V0KSB7XHJcbiAgICAgICAgICAgIHRoaXMubGludFRpbWUgPSBEYXRlLm5vdygpO1xyXG4gICAgICAgICAgICB0aGlzLnJ1bigpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGRlc3Ryb3koKSB7XHJcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMudGltZW91dCk7XHJcbiAgICB9XHJcbn0pO1xyXG5jb25zdCBsaW50Q29uZmlnID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSh7XHJcbiAgICBjb21iaW5lKGlucHV0KSB7XHJcbiAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oeyBzb3VyY2VzOiBpbnB1dC5tYXAoaSA9PiBpLnNvdXJjZSkgfSwgY29tYmluZUNvbmZpZyhpbnB1dC5tYXAoaSA9PiBpLmNvbmZpZyksIHtcclxuICAgICAgICAgICAgZGVsYXk6IDc1MCxcclxuICAgICAgICAgICAgbWFya2VyRmlsdGVyOiBudWxsLFxyXG4gICAgICAgICAgICB0b29sdGlwRmlsdGVyOiBudWxsXHJcbiAgICAgICAgfSkpO1xyXG4gICAgfSxcclxuICAgIGVuYWJsZXM6IGxpbnRQbHVnaW5cclxufSk7XHJcbi8qKlxyXG5HaXZlbiBhIGRpYWdub3N0aWMgc291cmNlLCB0aGlzIGZ1bmN0aW9uIHJldHVybnMgYW4gZXh0ZW5zaW9uIHRoYXRcclxuZW5hYmxlcyBsaW50aW5nIHdpdGggdGhhdCBzb3VyY2UuIEl0IHdpbGwgYmUgY2FsbGVkIHdoZW5ldmVyIHRoZVxyXG5lZGl0b3IgaXMgaWRsZSAoYWZ0ZXIgaXRzIGNvbnRlbnQgY2hhbmdlZCkuXHJcbiovXHJcbmZ1bmN0aW9uIGxpbnRlcihzb3VyY2UsIGNvbmZpZyA9IHt9KSB7XHJcbiAgICByZXR1cm4gbGludENvbmZpZy5vZih7IHNvdXJjZSwgY29uZmlnIH0pO1xyXG59XHJcbi8qKlxyXG5Gb3JjZXMgYW55IGxpbnRlcnMgW2NvbmZpZ3VyZWRdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jbGludC5saW50ZXIpIHRvIHJ1biB3aGVuIHRoZVxyXG5lZGl0b3IgaXMgaWRsZSB0byBydW4gcmlnaHQgYXdheS5cclxuKi9cclxuZnVuY3Rpb24gZm9yY2VMaW50aW5nKHZpZXcpIHtcclxuICAgIGxldCBwbHVnaW4gPSB2aWV3LnBsdWdpbihsaW50UGx1Z2luKTtcclxuICAgIGlmIChwbHVnaW4pXHJcbiAgICAgICAgcGx1Z2luLmZvcmNlKCk7XHJcbn1cclxuZnVuY3Rpb24gYXNzaWduS2V5cyhhY3Rpb25zKSB7XHJcbiAgICBsZXQgYXNzaWduZWQgPSBbXTtcclxuICAgIGlmIChhY3Rpb25zKVxyXG4gICAgICAgIGFjdGlvbnM6IGZvciAobGV0IHsgbmFtZSB9IG9mIGFjdGlvbnMpIHtcclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuYW1lLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgY2ggPSBuYW1lW2ldO1xyXG4gICAgICAgICAgICAgICAgaWYgKC9bYS16QS1aXS8udGVzdChjaCkgJiYgIWFzc2lnbmVkLnNvbWUoYyA9PiBjLnRvTG93ZXJDYXNlKCkgPT0gY2gudG9Mb3dlckNhc2UoKSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBhc3NpZ25lZC5wdXNoKGNoKTtcclxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZSBhY3Rpb25zO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGFzc2lnbmVkLnB1c2goXCJcIik7XHJcbiAgICAgICAgfVxyXG4gICAgcmV0dXJuIGFzc2lnbmVkO1xyXG59XHJcbmZ1bmN0aW9uIHJlbmRlckRpYWdub3N0aWModmlldywgZGlhZ25vc3RpYywgaW5QYW5lbCkge1xyXG4gICAgdmFyIF9hO1xyXG4gICAgbGV0IGtleXMgPSBpblBhbmVsID8gYXNzaWduS2V5cyhkaWFnbm9zdGljLmFjdGlvbnMpIDogW107XHJcbiAgICByZXR1cm4gZWx0KFwibGlcIiwgeyBjbGFzczogXCJjbS1kaWFnbm9zdGljIGNtLWRpYWdub3N0aWMtXCIgKyBkaWFnbm9zdGljLnNldmVyaXR5IH0sIGVsdChcInNwYW5cIiwgeyBjbGFzczogXCJjbS1kaWFnbm9zdGljVGV4dFwiIH0sIGRpYWdub3N0aWMucmVuZGVyTWVzc2FnZSA/IGRpYWdub3N0aWMucmVuZGVyTWVzc2FnZSgpIDogZGlhZ25vc3RpYy5tZXNzYWdlKSwgKF9hID0gZGlhZ25vc3RpYy5hY3Rpb25zKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubWFwKChhY3Rpb24sIGkpID0+IHtcclxuICAgICAgICBsZXQgY2xpY2sgPSAoZSkgPT4ge1xyXG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgICAgIGxldCBmb3VuZCA9IGZpbmREaWFnbm9zdGljKHZpZXcuc3RhdGUuZmllbGQobGludFN0YXRlKS5kaWFnbm9zdGljcywgZGlhZ25vc3RpYyk7XHJcbiAgICAgICAgICAgIGlmIChmb3VuZClcclxuICAgICAgICAgICAgICAgIGFjdGlvbi5hcHBseSh2aWV3LCBmb3VuZC5mcm9tLCBmb3VuZC50byk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBsZXQgeyBuYW1lIH0gPSBhY3Rpb24sIGtleUluZGV4ID0ga2V5c1tpXSA/IG5hbWUuaW5kZXhPZihrZXlzW2ldKSA6IC0xO1xyXG4gICAgICAgIGxldCBuYW1lRWx0ID0ga2V5SW5kZXggPCAwID8gbmFtZSA6IFtuYW1lLnNsaWNlKDAsIGtleUluZGV4KSxcclxuICAgICAgICAgICAgZWx0KFwidVwiLCBuYW1lLnNsaWNlKGtleUluZGV4LCBrZXlJbmRleCArIDEpKSxcclxuICAgICAgICAgICAgbmFtZS5zbGljZShrZXlJbmRleCArIDEpXTtcclxuICAgICAgICByZXR1cm4gZWx0KFwiYnV0dG9uXCIsIHtcclxuICAgICAgICAgICAgdHlwZTogXCJidXR0b25cIixcclxuICAgICAgICAgICAgY2xhc3M6IFwiY20tZGlhZ25vc3RpY0FjdGlvblwiLFxyXG4gICAgICAgICAgICBvbmNsaWNrOiBjbGljayxcclxuICAgICAgICAgICAgb25tb3VzZWRvd246IGNsaWNrLFxyXG4gICAgICAgICAgICBcImFyaWEtbGFiZWxcIjogYCBBY3Rpb246ICR7bmFtZX0ke2tleUluZGV4IDwgMCA/IFwiXCIgOiBgIChhY2Nlc3Mga2V5IFwiJHtrZXlzW2ldfSlcImB9LmBcclxuICAgICAgICB9LCBuYW1lRWx0KTtcclxuICAgIH0pLCBkaWFnbm9zdGljLnNvdXJjZSAmJiBlbHQoXCJkaXZcIiwgeyBjbGFzczogXCJjbS1kaWFnbm9zdGljU291cmNlXCIgfSwgZGlhZ25vc3RpYy5zb3VyY2UpKTtcclxufVxyXG5jbGFzcyBEaWFnbm9zdGljV2lkZ2V0IGV4dGVuZHMgV2lkZ2V0VHlwZSB7XHJcbiAgICBjb25zdHJ1Y3RvcihkaWFnbm9zdGljKSB7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuICAgICAgICB0aGlzLmRpYWdub3N0aWMgPSBkaWFnbm9zdGljO1xyXG4gICAgfVxyXG4gICAgZXEob3RoZXIpIHsgcmV0dXJuIG90aGVyLmRpYWdub3N0aWMgPT0gdGhpcy5kaWFnbm9zdGljOyB9XHJcbiAgICB0b0RPTSgpIHtcclxuICAgICAgICByZXR1cm4gZWx0KFwic3BhblwiLCB7IGNsYXNzOiBcImNtLWxpbnRQb2ludCBjbS1saW50UG9pbnQtXCIgKyB0aGlzLmRpYWdub3N0aWMuc2V2ZXJpdHkgfSk7XHJcbiAgICB9XHJcbn1cclxuY2xhc3MgUGFuZWxJdGVtIHtcclxuICAgIGNvbnN0cnVjdG9yKHZpZXcsIGRpYWdub3N0aWMpIHtcclxuICAgICAgICB0aGlzLmRpYWdub3N0aWMgPSBkaWFnbm9zdGljO1xyXG4gICAgICAgIHRoaXMuaWQgPSBcIml0ZW1fXCIgKyBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAweGZmZmZmZmZmKS50b1N0cmluZygxNik7XHJcbiAgICAgICAgdGhpcy5kb20gPSByZW5kZXJEaWFnbm9zdGljKHZpZXcsIGRpYWdub3N0aWMsIHRydWUpO1xyXG4gICAgICAgIHRoaXMuZG9tLmlkID0gdGhpcy5pZDtcclxuICAgICAgICB0aGlzLmRvbS5zZXRBdHRyaWJ1dGUoXCJyb2xlXCIsIFwib3B0aW9uXCIpO1xyXG4gICAgfVxyXG59XHJcbmNsYXNzIExpbnRQYW5lbCB7XHJcbiAgICBjb25zdHJ1Y3Rvcih2aWV3KSB7XHJcbiAgICAgICAgdGhpcy52aWV3ID0gdmlldztcclxuICAgICAgICB0aGlzLml0ZW1zID0gW107XHJcbiAgICAgICAgbGV0IG9ua2V5ZG93biA9IChldmVudCkgPT4ge1xyXG4gICAgICAgICAgICBpZiAoZXZlbnQua2V5Q29kZSA9PSAyNykgeyAvLyBFc2NhcGVcclxuICAgICAgICAgICAgICAgIGNsb3NlTGludFBhbmVsKHRoaXMudmlldyk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnZpZXcuZm9jdXMoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChldmVudC5rZXlDb2RlID09IDM4IHx8IGV2ZW50LmtleUNvZGUgPT0gMzMpIHsgLy8gQXJyb3dVcCwgUGFnZVVwXHJcbiAgICAgICAgICAgICAgICB0aGlzLm1vdmVTZWxlY3Rpb24oKHRoaXMuc2VsZWN0ZWRJbmRleCAtIDEgKyB0aGlzLml0ZW1zLmxlbmd0aCkgJSB0aGlzLml0ZW1zLmxlbmd0aCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoZXZlbnQua2V5Q29kZSA9PSA0MCB8fCBldmVudC5rZXlDb2RlID09IDM0KSB7IC8vIEFycm93RG93biwgUGFnZURvd25cclxuICAgICAgICAgICAgICAgIHRoaXMubW92ZVNlbGVjdGlvbigodGhpcy5zZWxlY3RlZEluZGV4ICsgMSkgJSB0aGlzLml0ZW1zLmxlbmd0aCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoZXZlbnQua2V5Q29kZSA9PSAzNikgeyAvLyBIb21lXHJcbiAgICAgICAgICAgICAgICB0aGlzLm1vdmVTZWxlY3Rpb24oMCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoZXZlbnQua2V5Q29kZSA9PSAzNSkgeyAvLyBFbmRcclxuICAgICAgICAgICAgICAgIHRoaXMubW92ZVNlbGVjdGlvbih0aGlzLml0ZW1zLmxlbmd0aCAtIDEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGV2ZW50LmtleUNvZGUgPT0gMTMpIHsgLy8gRW50ZXJcclxuICAgICAgICAgICAgICAgIHRoaXMudmlldy5mb2N1cygpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGV2ZW50LmtleUNvZGUgPj0gNjUgJiYgZXZlbnQua2V5Q29kZSA8PSA5MCAmJiB0aGlzLnNlbGVjdGVkSW5kZXggPj0gMCkgeyAvLyBBLVpcclxuICAgICAgICAgICAgICAgIGxldCB7IGRpYWdub3N0aWMgfSA9IHRoaXMuaXRlbXNbdGhpcy5zZWxlY3RlZEluZGV4XSwga2V5cyA9IGFzc2lnbktleXMoZGlhZ25vc3RpYy5hY3Rpb25zKTtcclxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKylcclxuICAgICAgICAgICAgICAgICAgICBpZiAoa2V5c1tpXS50b1VwcGVyQ2FzZSgpLmNoYXJDb2RlQXQoMCkgPT0gZXZlbnQua2V5Q29kZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgZm91bmQgPSBmaW5kRGlhZ25vc3RpYyh0aGlzLnZpZXcuc3RhdGUuZmllbGQobGludFN0YXRlKS5kaWFnbm9zdGljcywgZGlhZ25vc3RpYyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmb3VuZClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpYWdub3N0aWMuYWN0aW9uc1tpXS5hcHBseSh2aWV3LCBmb3VuZC5mcm9tLCBmb3VuZC50byk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBsZXQgb25jbGljayA9IChldmVudCkgPT4ge1xyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuaXRlbXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLml0ZW1zW2ldLmRvbS5jb250YWlucyhldmVudC50YXJnZXQpKVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubW92ZVNlbGVjdGlvbihpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgdGhpcy5saXN0ID0gZWx0KFwidWxcIiwge1xyXG4gICAgICAgICAgICB0YWJJbmRleDogMCxcclxuICAgICAgICAgICAgcm9sZTogXCJsaXN0Ym94XCIsXHJcbiAgICAgICAgICAgIFwiYXJpYS1sYWJlbFwiOiB0aGlzLnZpZXcuc3RhdGUucGhyYXNlKFwiRGlhZ25vc3RpY3NcIiksXHJcbiAgICAgICAgICAgIG9ua2V5ZG93bixcclxuICAgICAgICAgICAgb25jbGlja1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMuZG9tID0gZWx0KFwiZGl2XCIsIHsgY2xhc3M6IFwiY20tcGFuZWwtbGludFwiIH0sIHRoaXMubGlzdCwgZWx0KFwiYnV0dG9uXCIsIHtcclxuICAgICAgICAgICAgdHlwZTogXCJidXR0b25cIixcclxuICAgICAgICAgICAgbmFtZTogXCJjbG9zZVwiLFxyXG4gICAgICAgICAgICBcImFyaWEtbGFiZWxcIjogdGhpcy52aWV3LnN0YXRlLnBocmFzZShcImNsb3NlXCIpLFxyXG4gICAgICAgICAgICBvbmNsaWNrOiAoKSA9PiBjbG9zZUxpbnRQYW5lbCh0aGlzLnZpZXcpXHJcbiAgICAgICAgfSwgXCLDl1wiKSk7XHJcbiAgICAgICAgdGhpcy51cGRhdGUoKTtcclxuICAgIH1cclxuICAgIGdldCBzZWxlY3RlZEluZGV4KCkge1xyXG4gICAgICAgIGxldCBzZWxlY3RlZCA9IHRoaXMudmlldy5zdGF0ZS5maWVsZChsaW50U3RhdGUpLnNlbGVjdGVkO1xyXG4gICAgICAgIGlmICghc2VsZWN0ZWQpXHJcbiAgICAgICAgICAgIHJldHVybiAtMTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuaXRlbXMubGVuZ3RoOyBpKyspXHJcbiAgICAgICAgICAgIGlmICh0aGlzLml0ZW1zW2ldLmRpYWdub3N0aWMgPT0gc2VsZWN0ZWQuZGlhZ25vc3RpYylcclxuICAgICAgICAgICAgICAgIHJldHVybiBpO1xyXG4gICAgICAgIHJldHVybiAtMTtcclxuICAgIH1cclxuICAgIHVwZGF0ZSgpIHtcclxuICAgICAgICBsZXQgeyBkaWFnbm9zdGljcywgc2VsZWN0ZWQgfSA9IHRoaXMudmlldy5zdGF0ZS5maWVsZChsaW50U3RhdGUpO1xyXG4gICAgICAgIGxldCBpID0gMCwgbmVlZHNTeW5jID0gZmFsc2UsIG5ld1NlbGVjdGVkSXRlbSA9IG51bGw7XHJcbiAgICAgICAgZGlhZ25vc3RpY3MuYmV0d2VlbigwLCB0aGlzLnZpZXcuc3RhdGUuZG9jLmxlbmd0aCwgKF9zdGFydCwgX2VuZCwgeyBzcGVjIH0pID0+IHtcclxuICAgICAgICAgICAgbGV0IGZvdW5kID0gLTEsIGl0ZW07XHJcbiAgICAgICAgICAgIGZvciAobGV0IGogPSBpOyBqIDwgdGhpcy5pdGVtcy5sZW5ndGg7IGorKylcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLml0ZW1zW2pdLmRpYWdub3N0aWMgPT0gc3BlYy5kaWFnbm9zdGljKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZm91bmQgPSBqO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoZm91bmQgPCAwKSB7XHJcbiAgICAgICAgICAgICAgICBpdGVtID0gbmV3IFBhbmVsSXRlbSh0aGlzLnZpZXcsIHNwZWMuZGlhZ25vc3RpYyk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLml0ZW1zLnNwbGljZShpLCAwLCBpdGVtKTtcclxuICAgICAgICAgICAgICAgIG5lZWRzU3luYyA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBpdGVtID0gdGhpcy5pdGVtc1tmb3VuZF07XHJcbiAgICAgICAgICAgICAgICBpZiAoZm91bmQgPiBpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pdGVtcy5zcGxpY2UoaSwgZm91bmQgLSBpKTtcclxuICAgICAgICAgICAgICAgICAgICBuZWVkc1N5bmMgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChzZWxlY3RlZCAmJiBpdGVtLmRpYWdub3N0aWMgPT0gc2VsZWN0ZWQuZGlhZ25vc3RpYykge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFpdGVtLmRvbS5oYXNBdHRyaWJ1dGUoXCJhcmlhLXNlbGVjdGVkXCIpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaXRlbS5kb20uc2V0QXR0cmlidXRlKFwiYXJpYS1zZWxlY3RlZFwiLCBcInRydWVcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgbmV3U2VsZWN0ZWRJdGVtID0gaXRlbTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChpdGVtLmRvbS5oYXNBdHRyaWJ1dGUoXCJhcmlhLXNlbGVjdGVkXCIpKSB7XHJcbiAgICAgICAgICAgICAgICBpdGVtLmRvbS5yZW1vdmVBdHRyaWJ1dGUoXCJhcmlhLXNlbGVjdGVkXCIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGkrKztcclxuICAgICAgICB9KTtcclxuICAgICAgICB3aGlsZSAoaSA8IHRoaXMuaXRlbXMubGVuZ3RoICYmICEodGhpcy5pdGVtcy5sZW5ndGggPT0gMSAmJiB0aGlzLml0ZW1zWzBdLmRpYWdub3N0aWMuZnJvbSA8IDApKSB7XHJcbiAgICAgICAgICAgIG5lZWRzU3luYyA9IHRydWU7XHJcbiAgICAgICAgICAgIHRoaXMuaXRlbXMucG9wKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLml0ZW1zLmxlbmd0aCA9PSAwKSB7XHJcbiAgICAgICAgICAgIHRoaXMuaXRlbXMucHVzaChuZXcgUGFuZWxJdGVtKHRoaXMudmlldywge1xyXG4gICAgICAgICAgICAgICAgZnJvbTogLTEsIHRvOiAtMSxcclxuICAgICAgICAgICAgICAgIHNldmVyaXR5OiBcImluZm9cIixcclxuICAgICAgICAgICAgICAgIG1lc3NhZ2U6IHRoaXMudmlldy5zdGF0ZS5waHJhc2UoXCJObyBkaWFnbm9zdGljc1wiKVxyXG4gICAgICAgICAgICB9KSk7XHJcbiAgICAgICAgICAgIG5lZWRzU3luYyA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChuZXdTZWxlY3RlZEl0ZW0pIHtcclxuICAgICAgICAgICAgdGhpcy5saXN0LnNldEF0dHJpYnV0ZShcImFyaWEtYWN0aXZlZGVzY2VuZGFudFwiLCBuZXdTZWxlY3RlZEl0ZW0uaWQpO1xyXG4gICAgICAgICAgICB0aGlzLnZpZXcucmVxdWVzdE1lYXN1cmUoe1xyXG4gICAgICAgICAgICAgICAga2V5OiB0aGlzLFxyXG4gICAgICAgICAgICAgICAgcmVhZDogKCkgPT4gKHsgc2VsOiBuZXdTZWxlY3RlZEl0ZW0uZG9tLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLCBwYW5lbDogdGhpcy5saXN0LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpIH0pLFxyXG4gICAgICAgICAgICAgICAgd3JpdGU6ICh7IHNlbCwgcGFuZWwgfSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChzZWwudG9wIDwgcGFuZWwudG9wKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmxpc3Quc2Nyb2xsVG9wIC09IHBhbmVsLnRvcCAtIHNlbC50b3A7XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoc2VsLmJvdHRvbSA+IHBhbmVsLmJvdHRvbSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5saXN0LnNjcm9sbFRvcCArPSBzZWwuYm90dG9tIC0gcGFuZWwuYm90dG9tO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodGhpcy5zZWxlY3RlZEluZGV4IDwgMCkge1xyXG4gICAgICAgICAgICB0aGlzLmxpc3QucmVtb3ZlQXR0cmlidXRlKFwiYXJpYS1hY3RpdmVkZXNjZW5kYW50XCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobmVlZHNTeW5jKVxyXG4gICAgICAgICAgICB0aGlzLnN5bmMoKTtcclxuICAgIH1cclxuICAgIHN5bmMoKSB7XHJcbiAgICAgICAgbGV0IGRvbVBvcyA9IHRoaXMubGlzdC5maXJzdENoaWxkO1xyXG4gICAgICAgIGZ1bmN0aW9uIHJtKCkge1xyXG4gICAgICAgICAgICBsZXQgcHJldiA9IGRvbVBvcztcclxuICAgICAgICAgICAgZG9tUG9zID0gcHJldi5uZXh0U2libGluZztcclxuICAgICAgICAgICAgcHJldi5yZW1vdmUoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZm9yIChsZXQgaXRlbSBvZiB0aGlzLml0ZW1zKSB7XHJcbiAgICAgICAgICAgIGlmIChpdGVtLmRvbS5wYXJlbnROb2RlID09IHRoaXMubGlzdCkge1xyXG4gICAgICAgICAgICAgICAgd2hpbGUgKGRvbVBvcyAhPSBpdGVtLmRvbSlcclxuICAgICAgICAgICAgICAgICAgICBybSgpO1xyXG4gICAgICAgICAgICAgICAgZG9tUG9zID0gaXRlbS5kb20ubmV4dFNpYmxpbmc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmxpc3QuaW5zZXJ0QmVmb3JlKGl0ZW0uZG9tLCBkb21Qb3MpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHdoaWxlIChkb21Qb3MpXHJcbiAgICAgICAgICAgIHJtKCk7XHJcbiAgICB9XHJcbiAgICBtb3ZlU2VsZWN0aW9uKHNlbGVjdGVkSW5kZXgpIHtcclxuICAgICAgICBpZiAodGhpcy5zZWxlY3RlZEluZGV4IDwgMClcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIGxldCBmaWVsZCA9IHRoaXMudmlldy5zdGF0ZS5maWVsZChsaW50U3RhdGUpO1xyXG4gICAgICAgIGxldCBzZWxlY3Rpb24gPSBmaW5kRGlhZ25vc3RpYyhmaWVsZC5kaWFnbm9zdGljcywgdGhpcy5pdGVtc1tzZWxlY3RlZEluZGV4XS5kaWFnbm9zdGljKTtcclxuICAgICAgICBpZiAoIXNlbGVjdGlvbilcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIHRoaXMudmlldy5kaXNwYXRjaCh7XHJcbiAgICAgICAgICAgIHNlbGVjdGlvbjogeyBhbmNob3I6IHNlbGVjdGlvbi5mcm9tLCBoZWFkOiBzZWxlY3Rpb24udG8gfSxcclxuICAgICAgICAgICAgc2Nyb2xsSW50b1ZpZXc6IHRydWUsXHJcbiAgICAgICAgICAgIGVmZmVjdHM6IG1vdmVQYW5lbFNlbGVjdGlvbi5vZihzZWxlY3Rpb24pXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgb3Blbih2aWV3KSB7IHJldHVybiBuZXcgTGludFBhbmVsKHZpZXcpOyB9XHJcbn1cclxuZnVuY3Rpb24gc3ZnKGNvbnRlbnQsIGF0dHJzID0gYHZpZXdCb3g9XCIwIDAgNDAgNDBcImApIHtcclxuICAgIHJldHVybiBgdXJsKCdkYXRhOmltYWdlL3N2Zyt4bWwsPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgJHthdHRyc30+JHtlbmNvZGVVUklDb21wb25lbnQoY29udGVudCl9PC9zdmc+JylgO1xyXG59XHJcbmZ1bmN0aW9uIHVuZGVybGluZShjb2xvcikge1xyXG4gICAgcmV0dXJuIHN2ZyhgPHBhdGggZD1cIm0wIDIuNSBsMiAtMS41IGwxIDAgbDIgMS41IGwxIDBcIiBzdHJva2U9XCIke2NvbG9yfVwiIGZpbGw9XCJub25lXCIgc3Ryb2tlLXdpZHRoPVwiLjdcIi8+YCwgYHdpZHRoPVwiNlwiIGhlaWdodD1cIjNcImApO1xyXG59XHJcbmNvbnN0IGJhc2VUaGVtZSA9IC8qQF9fUFVSRV9fKi9FZGl0b3JWaWV3LmJhc2VUaGVtZSh7XHJcbiAgICBcIi5jbS1kaWFnbm9zdGljXCI6IHtcclxuICAgICAgICBwYWRkaW5nOiBcIjNweCA2cHggM3B4IDhweFwiLFxyXG4gICAgICAgIG1hcmdpbkxlZnQ6IFwiLTFweFwiLFxyXG4gICAgICAgIGRpc3BsYXk6IFwiYmxvY2tcIixcclxuICAgICAgICB3aGl0ZVNwYWNlOiBcInByZS13cmFwXCJcclxuICAgIH0sXHJcbiAgICBcIi5jbS1kaWFnbm9zdGljLWVycm9yXCI6IHsgYm9yZGVyTGVmdDogXCI1cHggc29saWQgI2QxMVwiIH0sXHJcbiAgICBcIi5jbS1kaWFnbm9zdGljLXdhcm5pbmdcIjogeyBib3JkZXJMZWZ0OiBcIjVweCBzb2xpZCBvcmFuZ2VcIiB9LFxyXG4gICAgXCIuY20tZGlhZ25vc3RpYy1pbmZvXCI6IHsgYm9yZGVyTGVmdDogXCI1cHggc29saWQgIzk5OVwiIH0sXHJcbiAgICBcIi5jbS1kaWFnbm9zdGljQWN0aW9uXCI6IHtcclxuICAgICAgICBmb250OiBcImluaGVyaXRcIixcclxuICAgICAgICBib3JkZXI6IFwibm9uZVwiLFxyXG4gICAgICAgIHBhZGRpbmc6IFwiMnB4IDRweFwiLFxyXG4gICAgICAgIGJhY2tncm91bmRDb2xvcjogXCIjNDQ0XCIsXHJcbiAgICAgICAgY29sb3I6IFwid2hpdGVcIixcclxuICAgICAgICBib3JkZXJSYWRpdXM6IFwiM3B4XCIsXHJcbiAgICAgICAgbWFyZ2luTGVmdDogXCI4cHhcIlxyXG4gICAgfSxcclxuICAgIFwiLmNtLWRpYWdub3N0aWNTb3VyY2VcIjoge1xyXG4gICAgICAgIGZvbnRTaXplOiBcIjcwJVwiLFxyXG4gICAgICAgIG9wYWNpdHk6IC43XHJcbiAgICB9LFxyXG4gICAgXCIuY20tbGludFJhbmdlXCI6IHtcclxuICAgICAgICBiYWNrZ3JvdW5kUG9zaXRpb246IFwibGVmdCBib3R0b21cIixcclxuICAgICAgICBiYWNrZ3JvdW5kUmVwZWF0OiBcInJlcGVhdC14XCIsXHJcbiAgICAgICAgcGFkZGluZ0JvdHRvbTogXCIwLjdweFwiLFxyXG4gICAgfSxcclxuICAgIFwiLmNtLWxpbnRSYW5nZS1lcnJvclwiOiB7IGJhY2tncm91bmRJbWFnZTogLypAX19QVVJFX18qL3VuZGVybGluZShcIiNkMTFcIikgfSxcclxuICAgIFwiLmNtLWxpbnRSYW5nZS13YXJuaW5nXCI6IHsgYmFja2dyb3VuZEltYWdlOiAvKkBfX1BVUkVfXyovdW5kZXJsaW5lKFwib3JhbmdlXCIpIH0sXHJcbiAgICBcIi5jbS1saW50UmFuZ2UtaW5mb1wiOiB7IGJhY2tncm91bmRJbWFnZTogLypAX19QVVJFX18qL3VuZGVybGluZShcIiM5OTlcIikgfSxcclxuICAgIFwiLmNtLWxpbnRSYW5nZS1hY3RpdmVcIjogeyBiYWNrZ3JvdW5kQ29sb3I6IFwiI2ZmZGQ5OTgwXCIgfSxcclxuICAgIFwiLmNtLXRvb2x0aXAtbGludFwiOiB7XHJcbiAgICAgICAgcGFkZGluZzogMCxcclxuICAgICAgICBtYXJnaW46IDBcclxuICAgIH0sXHJcbiAgICBcIi5jbS1saW50UG9pbnRcIjoge1xyXG4gICAgICAgIHBvc2l0aW9uOiBcInJlbGF0aXZlXCIsXHJcbiAgICAgICAgXCImOmFmdGVyXCI6IHtcclxuICAgICAgICAgICAgY29udGVudDogJ1wiXCInLFxyXG4gICAgICAgICAgICBwb3NpdGlvbjogXCJhYnNvbHV0ZVwiLFxyXG4gICAgICAgICAgICBib3R0b206IDAsXHJcbiAgICAgICAgICAgIGxlZnQ6IFwiLTJweFwiLFxyXG4gICAgICAgICAgICBib3JkZXJMZWZ0OiBcIjNweCBzb2xpZCB0cmFuc3BhcmVudFwiLFxyXG4gICAgICAgICAgICBib3JkZXJSaWdodDogXCIzcHggc29saWQgdHJhbnNwYXJlbnRcIixcclxuICAgICAgICAgICAgYm9yZGVyQm90dG9tOiBcIjRweCBzb2xpZCAjZDExXCJcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgXCIuY20tbGludFBvaW50LXdhcm5pbmdcIjoge1xyXG4gICAgICAgIFwiJjphZnRlclwiOiB7IGJvcmRlckJvdHRvbUNvbG9yOiBcIm9yYW5nZVwiIH1cclxuICAgIH0sXHJcbiAgICBcIi5jbS1saW50UG9pbnQtaW5mb1wiOiB7XHJcbiAgICAgICAgXCImOmFmdGVyXCI6IHsgYm9yZGVyQm90dG9tQ29sb3I6IFwiIzk5OVwiIH1cclxuICAgIH0sXHJcbiAgICBcIi5jbS1wYW5lbC5jbS1wYW5lbC1saW50XCI6IHtcclxuICAgICAgICBwb3NpdGlvbjogXCJyZWxhdGl2ZVwiLFxyXG4gICAgICAgIFwiJiB1bFwiOiB7XHJcbiAgICAgICAgICAgIG1heEhlaWdodDogXCIxMDBweFwiLFxyXG4gICAgICAgICAgICBvdmVyZmxvd1k6IFwiYXV0b1wiLFxyXG4gICAgICAgICAgICBcIiYgW2FyaWEtc2VsZWN0ZWRdXCI6IHtcclxuICAgICAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogXCIjZGRkXCIsXHJcbiAgICAgICAgICAgICAgICBcIiYgdVwiOiB7IHRleHREZWNvcmF0aW9uOiBcInVuZGVybGluZVwiIH1cclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgXCImOmZvY3VzIFthcmlhLXNlbGVjdGVkXVwiOiB7XHJcbiAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kX2ZhbGxiYWNrOiBcIiNiZGZcIixcclxuICAgICAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogXCJIaWdobGlnaHRcIixcclxuICAgICAgICAgICAgICAgIGNvbG9yX2ZhbGxiYWNrOiBcIndoaXRlXCIsXHJcbiAgICAgICAgICAgICAgICBjb2xvcjogXCJIaWdobGlnaHRUZXh0XCJcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgXCImIHVcIjogeyB0ZXh0RGVjb3JhdGlvbjogXCJub25lXCIgfSxcclxuICAgICAgICAgICAgcGFkZGluZzogMCxcclxuICAgICAgICAgICAgbWFyZ2luOiAwXHJcbiAgICAgICAgfSxcclxuICAgICAgICBcIiYgW25hbWU9Y2xvc2VdXCI6IHtcclxuICAgICAgICAgICAgcG9zaXRpb246IFwiYWJzb2x1dGVcIixcclxuICAgICAgICAgICAgdG9wOiBcIjBcIixcclxuICAgICAgICAgICAgcmlnaHQ6IFwiMnB4XCIsXHJcbiAgICAgICAgICAgIGJhY2tncm91bmQ6IFwiaW5oZXJpdFwiLFxyXG4gICAgICAgICAgICBib3JkZXI6IFwibm9uZVwiLFxyXG4gICAgICAgICAgICBmb250OiBcImluaGVyaXRcIixcclxuICAgICAgICAgICAgcGFkZGluZzogMCxcclxuICAgICAgICAgICAgbWFyZ2luOiAwXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59KTtcclxuY2xhc3MgTGludEd1dHRlck1hcmtlciBleHRlbmRzIEd1dHRlck1hcmtlciB7XHJcbiAgICBjb25zdHJ1Y3RvcihkaWFnbm9zdGljcykge1xyXG4gICAgICAgIHN1cGVyKCk7XHJcbiAgICAgICAgdGhpcy5kaWFnbm9zdGljcyA9IGRpYWdub3N0aWNzO1xyXG4gICAgICAgIHRoaXMuc2V2ZXJpdHkgPSBkaWFnbm9zdGljcy5yZWR1Y2UoKG1heCwgZCkgPT4ge1xyXG4gICAgICAgICAgICBsZXQgcyA9IGQuc2V2ZXJpdHk7XHJcbiAgICAgICAgICAgIHJldHVybiBzID09IFwiZXJyb3JcIiB8fCBzID09IFwid2FybmluZ1wiICYmIG1heCA9PSBcImluZm9cIiA/IHMgOiBtYXg7XHJcbiAgICAgICAgfSwgXCJpbmZvXCIpO1xyXG4gICAgfVxyXG4gICAgdG9ET00odmlldykge1xyXG4gICAgICAgIGxldCBlbHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xyXG4gICAgICAgIGVsdC5jbGFzc05hbWUgPSBcImNtLWxpbnQtbWFya2VyIGNtLWxpbnQtbWFya2VyLVwiICsgdGhpcy5zZXZlcml0eTtcclxuICAgICAgICBsZXQgZGlhZ25vc3RpY3MgPSB0aGlzLmRpYWdub3N0aWNzO1xyXG4gICAgICAgIGxldCBkaWFnbm9zdGljc0ZpbHRlciA9IHZpZXcuc3RhdGUuZmFjZXQobGludEd1dHRlckNvbmZpZykudG9vbHRpcEZpbHRlcjtcclxuICAgICAgICBpZiAoZGlhZ25vc3RpY3NGaWx0ZXIpXHJcbiAgICAgICAgICAgIGRpYWdub3N0aWNzID0gZGlhZ25vc3RpY3NGaWx0ZXIoZGlhZ25vc3RpY3MpO1xyXG4gICAgICAgIGlmIChkaWFnbm9zdGljcy5sZW5ndGgpXHJcbiAgICAgICAgICAgIGVsdC5vbm1vdXNlb3ZlciA9ICgpID0+IGd1dHRlck1hcmtlck1vdXNlT3Zlcih2aWV3LCBlbHQsIGRpYWdub3N0aWNzKTtcclxuICAgICAgICByZXR1cm4gZWx0O1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIHRyYWNrSG92ZXJPbih2aWV3LCBtYXJrZXIpIHtcclxuICAgIGxldCBtb3VzZW1vdmUgPSAoZXZlbnQpID0+IHtcclxuICAgICAgICBsZXQgcmVjdCA9IG1hcmtlci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcclxuICAgICAgICBpZiAoZXZlbnQuY2xpZW50WCA+IHJlY3QubGVmdCAtIDEwIC8qIEhvdmVyLk1hcmdpbiAqLyAmJiBldmVudC5jbGllbnRYIDwgcmVjdC5yaWdodCArIDEwIC8qIEhvdmVyLk1hcmdpbiAqLyAmJlxyXG4gICAgICAgICAgICBldmVudC5jbGllbnRZID4gcmVjdC50b3AgLSAxMCAvKiBIb3Zlci5NYXJnaW4gKi8gJiYgZXZlbnQuY2xpZW50WSA8IHJlY3QuYm90dG9tICsgMTAgLyogSG92ZXIuTWFyZ2luICovKVxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgZm9yIChsZXQgdGFyZ2V0ID0gZXZlbnQudGFyZ2V0OyB0YXJnZXQ7IHRhcmdldCA9IHRhcmdldC5wYXJlbnROb2RlKSB7XHJcbiAgICAgICAgICAgIGlmICh0YXJnZXQubm9kZVR5cGUgPT0gMSAmJiB0YXJnZXQuY2xhc3NMaXN0LmNvbnRhaW5zKFwiY20tdG9vbHRpcC1saW50XCIpKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNlbW92ZVwiLCBtb3VzZW1vdmUpO1xyXG4gICAgICAgIGlmICh2aWV3LnN0YXRlLmZpZWxkKGxpbnRHdXR0ZXJUb29sdGlwKSlcclxuICAgICAgICAgICAgdmlldy5kaXNwYXRjaCh7IGVmZmVjdHM6IHNldExpbnRHdXR0ZXJUb29sdGlwLm9mKG51bGwpIH0pO1xyXG4gICAgfTtcclxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwibW91c2Vtb3ZlXCIsIG1vdXNlbW92ZSk7XHJcbn1cclxuZnVuY3Rpb24gZ3V0dGVyTWFya2VyTW91c2VPdmVyKHZpZXcsIG1hcmtlciwgZGlhZ25vc3RpY3MpIHtcclxuICAgIGZ1bmN0aW9uIGhvdmVyZWQoKSB7XHJcbiAgICAgICAgbGV0IGxpbmUgPSB2aWV3LmVsZW1lbnRBdEhlaWdodChtYXJrZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkudG9wICsgNSAtIHZpZXcuZG9jdW1lbnRUb3ApO1xyXG4gICAgICAgIGNvbnN0IGxpbmVQb3MgPSB2aWV3LmNvb3Jkc0F0UG9zKGxpbmUuZnJvbSk7XHJcbiAgICAgICAgaWYgKGxpbmVQb3MpIHtcclxuICAgICAgICAgICAgdmlldy5kaXNwYXRjaCh7IGVmZmVjdHM6IHNldExpbnRHdXR0ZXJUb29sdGlwLm9mKHtcclxuICAgICAgICAgICAgICAgICAgICBwb3M6IGxpbmUuZnJvbSxcclxuICAgICAgICAgICAgICAgICAgICBhYm92ZTogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICAgICAgY3JlYXRlKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9tOiBkaWFnbm9zdGljc1Rvb2x0aXAodmlldywgZGlhZ25vc3RpY3MpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0Q29vcmRzOiAoKSA9PiBtYXJrZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KClcclxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9KSB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbWFya2VyLm9ubW91c2VvdXQgPSBtYXJrZXIub25tb3VzZW1vdmUgPSBudWxsO1xyXG4gICAgICAgIHRyYWNrSG92ZXJPbih2aWV3LCBtYXJrZXIpO1xyXG4gICAgfVxyXG4gICAgbGV0IHsgaG92ZXJUaW1lIH0gPSB2aWV3LnN0YXRlLmZhY2V0KGxpbnRHdXR0ZXJDb25maWcpO1xyXG4gICAgbGV0IGhvdmVyVGltZW91dCA9IHNldFRpbWVvdXQoaG92ZXJlZCwgaG92ZXJUaW1lKTtcclxuICAgIG1hcmtlci5vbm1vdXNlb3V0ID0gKCkgPT4ge1xyXG4gICAgICAgIGNsZWFyVGltZW91dChob3ZlclRpbWVvdXQpO1xyXG4gICAgICAgIG1hcmtlci5vbm1vdXNlb3V0ID0gbWFya2VyLm9ubW91c2Vtb3ZlID0gbnVsbDtcclxuICAgIH07XHJcbiAgICBtYXJrZXIub25tb3VzZW1vdmUgPSAoKSA9PiB7XHJcbiAgICAgICAgY2xlYXJUaW1lb3V0KGhvdmVyVGltZW91dCk7XHJcbiAgICAgICAgaG92ZXJUaW1lb3V0ID0gc2V0VGltZW91dChob3ZlcmVkLCBob3ZlclRpbWUpO1xyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiBtYXJrZXJzRm9yRGlhZ25vc3RpY3MoZG9jLCBkaWFnbm9zdGljcykge1xyXG4gICAgbGV0IGJ5TGluZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XHJcbiAgICBmb3IgKGxldCBkaWFnbm9zdGljIG9mIGRpYWdub3N0aWNzKSB7XHJcbiAgICAgICAgbGV0IGxpbmUgPSBkb2MubGluZUF0KGRpYWdub3N0aWMuZnJvbSk7XHJcbiAgICAgICAgKGJ5TGluZVtsaW5lLmZyb21dIHx8IChieUxpbmVbbGluZS5mcm9tXSA9IFtdKSkucHVzaChkaWFnbm9zdGljKTtcclxuICAgIH1cclxuICAgIGxldCBtYXJrZXJzID0gW107XHJcbiAgICBmb3IgKGxldCBsaW5lIGluIGJ5TGluZSkge1xyXG4gICAgICAgIG1hcmtlcnMucHVzaChuZXcgTGludEd1dHRlck1hcmtlcihieUxpbmVbbGluZV0pLnJhbmdlKCtsaW5lKSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gUmFuZ2VTZXQub2YobWFya2VycywgdHJ1ZSk7XHJcbn1cclxuY29uc3QgbGludEd1dHRlckV4dGVuc2lvbiA9IC8qQF9fUFVSRV9fKi9ndXR0ZXIoe1xyXG4gICAgY2xhc3M6IFwiY20tZ3V0dGVyLWxpbnRcIixcclxuICAgIG1hcmtlcnM6IHZpZXcgPT4gdmlldy5zdGF0ZS5maWVsZChsaW50R3V0dGVyTWFya2VycyksXHJcbn0pO1xyXG5jb25zdCBsaW50R3V0dGVyTWFya2VycyA9IC8qQF9fUFVSRV9fKi9TdGF0ZUZpZWxkLmRlZmluZSh7XHJcbiAgICBjcmVhdGUoKSB7XHJcbiAgICAgICAgcmV0dXJuIFJhbmdlU2V0LmVtcHR5O1xyXG4gICAgfSxcclxuICAgIHVwZGF0ZShtYXJrZXJzLCB0cikge1xyXG4gICAgICAgIG1hcmtlcnMgPSBtYXJrZXJzLm1hcCh0ci5jaGFuZ2VzKTtcclxuICAgICAgICBsZXQgZGlhZ25vc3RpY0ZpbHRlciA9IHRyLnN0YXRlLmZhY2V0KGxpbnRHdXR0ZXJDb25maWcpLm1hcmtlckZpbHRlcjtcclxuICAgICAgICBmb3IgKGxldCBlZmZlY3Qgb2YgdHIuZWZmZWN0cykge1xyXG4gICAgICAgICAgICBpZiAoZWZmZWN0LmlzKHNldERpYWdub3N0aWNzRWZmZWN0KSkge1xyXG4gICAgICAgICAgICAgICAgbGV0IGRpYWdub3N0aWNzID0gZWZmZWN0LnZhbHVlO1xyXG4gICAgICAgICAgICAgICAgaWYgKGRpYWdub3N0aWNGaWx0ZXIpXHJcbiAgICAgICAgICAgICAgICAgICAgZGlhZ25vc3RpY3MgPSBkaWFnbm9zdGljRmlsdGVyKGRpYWdub3N0aWNzIHx8IFtdKTtcclxuICAgICAgICAgICAgICAgIG1hcmtlcnMgPSBtYXJrZXJzRm9yRGlhZ25vc3RpY3ModHIuc3RhdGUuZG9jLCBkaWFnbm9zdGljcy5zbGljZSgwKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG1hcmtlcnM7XHJcbiAgICB9XHJcbn0pO1xyXG5jb25zdCBzZXRMaW50R3V0dGVyVG9vbHRpcCA9IC8qQF9fUFVSRV9fKi9TdGF0ZUVmZmVjdC5kZWZpbmUoKTtcclxuY29uc3QgbGludEd1dHRlclRvb2x0aXAgPSAvKkBfX1BVUkVfXyovU3RhdGVGaWVsZC5kZWZpbmUoe1xyXG4gICAgY3JlYXRlKCkgeyByZXR1cm4gbnVsbDsgfSxcclxuICAgIHVwZGF0ZSh0b29sdGlwLCB0cikge1xyXG4gICAgICAgIGlmICh0b29sdGlwICYmIHRyLmRvY0NoYW5nZWQpXHJcbiAgICAgICAgICAgIHRvb2x0aXAgPSBoaWRlVG9vbHRpcCh0ciwgdG9vbHRpcCkgPyBudWxsIDogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0b29sdGlwKSwgeyBwb3M6IHRyLmNoYW5nZXMubWFwUG9zKHRvb2x0aXAucG9zKSB9KTtcclxuICAgICAgICByZXR1cm4gdHIuZWZmZWN0cy5yZWR1Y2UoKHQsIGUpID0+IGUuaXMoc2V0TGludEd1dHRlclRvb2x0aXApID8gZS52YWx1ZSA6IHQsIHRvb2x0aXApO1xyXG4gICAgfSxcclxuICAgIHByb3ZpZGU6IGZpZWxkID0+IHNob3dUb29sdGlwLmZyb20oZmllbGQpXHJcbn0pO1xyXG5jb25zdCBsaW50R3V0dGVyVGhlbWUgPSAvKkBfX1BVUkVfXyovRWRpdG9yVmlldy5iYXNlVGhlbWUoe1xyXG4gICAgXCIuY20tZ3V0dGVyLWxpbnRcIjoge1xyXG4gICAgICAgIHdpZHRoOiBcIjEuNGVtXCIsXHJcbiAgICAgICAgXCImIC5jbS1ndXR0ZXJFbGVtZW50XCI6IHtcclxuICAgICAgICAgICAgcGFkZGluZzogXCIuMmVtXCJcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgXCIuY20tbGludC1tYXJrZXJcIjoge1xyXG4gICAgICAgIHdpZHRoOiBcIjFlbVwiLFxyXG4gICAgICAgIGhlaWdodDogXCIxZW1cIlxyXG4gICAgfSxcclxuICAgIFwiLmNtLWxpbnQtbWFya2VyLWluZm9cIjoge1xyXG4gICAgICAgIGNvbnRlbnQ6IC8qQF9fUFVSRV9fKi9zdmcoYDxwYXRoIGZpbGw9XCIjYWFmXCIgc3Ryb2tlPVwiIzc3ZVwiIHN0cm9rZS13aWR0aD1cIjZcIiBzdHJva2UtbGluZWpvaW49XCJyb3VuZFwiIGQ9XCJNNSA1TDM1IDVMMzUgMzVMNSAzNVpcIi8+YClcclxuICAgIH0sXHJcbiAgICBcIi5jbS1saW50LW1hcmtlci13YXJuaW5nXCI6IHtcclxuICAgICAgICBjb250ZW50OiAvKkBfX1BVUkVfXyovc3ZnKGA8cGF0aCBmaWxsPVwiI2ZlOFwiIHN0cm9rZT1cIiNmZDdcIiBzdHJva2Utd2lkdGg9XCI2XCIgc3Ryb2tlLWxpbmVqb2luPVwicm91bmRcIiBkPVwiTTIwIDZMMzcgMzVMMyAzNVpcIi8+YCksXHJcbiAgICB9LFxyXG4gICAgXCIuY20tbGludC1tYXJrZXItZXJyb3JcIjoge1xyXG4gICAgICAgIGNvbnRlbnQ6IC8qQF9fUFVSRV9fKi9zdmcoYDxjaXJjbGUgY3g9XCIyMFwiIGN5PVwiMjBcIiByPVwiMTVcIiBmaWxsPVwiI2Y4N1wiIHN0cm9rZT1cIiNmNDNcIiBzdHJva2Utd2lkdGg9XCI2XCIvPmApXHJcbiAgICB9LFxyXG59KTtcclxuY29uc3QgbGludEd1dHRlckNvbmZpZyA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoe1xyXG4gICAgY29tYmluZShjb25maWdzKSB7XHJcbiAgICAgICAgcmV0dXJuIGNvbWJpbmVDb25maWcoY29uZmlncywge1xyXG4gICAgICAgICAgICBob3ZlclRpbWU6IDMwMCAvKiBIb3Zlci5UaW1lICovLFxyXG4gICAgICAgICAgICBtYXJrZXJGaWx0ZXI6IG51bGwsXHJcbiAgICAgICAgICAgIHRvb2x0aXBGaWx0ZXI6IG51bGxcclxuICAgICAgICB9KTtcclxuICAgIH1cclxufSk7XHJcbi8qKlxyXG5SZXR1cm5zIGFuIGV4dGVuc2lvbiB0aGF0IGluc3RhbGxzIGEgZ3V0dGVyIHNob3dpbmcgbWFya2VycyBmb3JcclxuZWFjaCBsaW5lIHRoYXQgaGFzIGRpYWdub3N0aWNzLCB3aGljaCBjYW4gYmUgaG92ZXJlZCBvdmVyIHRvIHNlZVxyXG50aGUgZGlhZ25vc3RpY3MuXHJcbiovXHJcbmZ1bmN0aW9uIGxpbnRHdXR0ZXIoY29uZmlnID0ge30pIHtcclxuICAgIHJldHVybiBbbGludEd1dHRlckNvbmZpZy5vZihjb25maWcpLCBsaW50R3V0dGVyTWFya2VycywgbGludEd1dHRlckV4dGVuc2lvbiwgbGludEd1dHRlclRoZW1lLCBsaW50R3V0dGVyVG9vbHRpcF07XHJcbn1cclxuLyoqXHJcbkl0ZXJhdGUgb3ZlciB0aGUgbWFya2VkIGRpYWdub3N0aWNzIGZvciB0aGUgZ2l2ZW4gZWRpdG9yIHN0YXRlLFxyXG5jYWxsaW5nIGBmYCBmb3IgZWFjaCBvZiB0aGVtLiBOb3RlIHRoYXQsIGlmIHRoZSBkb2N1bWVudCBjaGFuZ2VkXHJcbnNpbmNlIHRoZSBkaWFnbm9zdGljcyB3ZXJlY3JlYXRlZCwgdGhlIGBEaWFnbm9zdGljYCBvYmplY3Qgd2lsbFxyXG5ob2xkIHRoZSBvcmlnaW5hbCBvdXRkYXRlZCBwb3NpdGlvbiwgd2hlcmVhcyB0aGUgYHRvYCBhbmQgYGZyb21gXHJcbmFyZ3VtZW50cyBob2xkIHRoZSBkaWFnbm9zdGljJ3MgY3VycmVudCBwb3NpdGlvbi5cclxuKi9cclxuZnVuY3Rpb24gZm9yRWFjaERpYWdub3N0aWMoc3RhdGUsIGYpIHtcclxuICAgIGxldCBsU3RhdGUgPSBzdGF0ZS5maWVsZChsaW50U3RhdGUsIGZhbHNlKTtcclxuICAgIGlmIChsU3RhdGUgJiYgbFN0YXRlLmRpYWdub3N0aWNzLnNpemUpXHJcbiAgICAgICAgZm9yIChsZXQgaXRlciA9IFJhbmdlU2V0Lml0ZXIoW2xTdGF0ZS5kaWFnbm9zdGljc10pOyBpdGVyLnZhbHVlOyBpdGVyLm5leHQoKSlcclxuICAgICAgICAgICAgZihpdGVyLnZhbHVlLnNwZWMuZGlhZ25vc3RpYywgaXRlci5mcm9tLCBpdGVyLnRvKTtcclxufVxyXG5cclxuZXhwb3J0IHsgY2xvc2VMaW50UGFuZWwsIGRpYWdub3N0aWNDb3VudCwgZm9yRWFjaERpYWdub3N0aWMsIGZvcmNlTGludGluZywgbGludEd1dHRlciwgbGludEtleW1hcCwgbGludGVyLCBuZXh0RGlhZ25vc3RpYywgb3BlbkxpbnRQYW5lbCwgc2V0RGlhZ25vc3RpY3MsIHNldERpYWdub3N0aWNzRWZmZWN0IH07XHJcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@codemirror/lint/dist/index.js\n"));

/***/ }),

/***/ "./node_modules/@codemirror/search/dist/index.js":
/*!*******************************************************!*\
  !*** ./node_modules/@codemirror/search/dist/index.js ***!
  \*******************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"RegExpCursor\": function() { return /* binding */ RegExpCursor; },\n/* harmony export */   \"SearchCursor\": function() { return /* binding */ SearchCursor; },\n/* harmony export */   \"SearchQuery\": function() { return /* binding */ SearchQuery; },\n/* harmony export */   \"closeSearchPanel\": function() { return /* binding */ closeSearchPanel; },\n/* harmony export */   \"findNext\": function() { return /* binding */ findNext; },\n/* harmony export */   \"findPrevious\": function() { return /* binding */ findPrevious; },\n/* harmony export */   \"getSearchQuery\": function() { return /* binding */ getSearchQuery; },\n/* harmony export */   \"gotoLine\": function() { return /* binding */ gotoLine; },\n/* harmony export */   \"highlightSelectionMatches\": function() { return /* binding */ highlightSelectionMatches; },\n/* harmony export */   \"openSearchPanel\": function() { return /* binding */ openSearchPanel; },\n/* harmony export */   \"replaceAll\": function() { return /* binding */ replaceAll; },\n/* harmony export */   \"replaceNext\": function() { return /* binding */ replaceNext; },\n/* harmony export */   \"search\": function() { return /* binding */ search; },\n/* harmony export */   \"searchKeymap\": function() { return /* binding */ searchKeymap; },\n/* harmony export */   \"searchPanelOpen\": function() { return /* binding */ searchPanelOpen; },\n/* harmony export */   \"selectMatches\": function() { return /* binding */ selectMatches; },\n/* harmony export */   \"selectNextOccurrence\": function() { return /* binding */ selectNextOccurrence; },\n/* harmony export */   \"selectSelectionMatches\": function() { return /* binding */ selectSelectionMatches; },\n/* harmony export */   \"setSearchQuery\": function() { return /* binding */ setSearchQuery; }\n/* harmony export */ });\n/* harmony import */ var _codemirror_view__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @codemirror/view */ \"./node_modules/@codemirror/view/dist/index.js\");\n/* harmony import */ var _codemirror_state__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @codemirror/state */ \"./node_modules/@codemirror/state/dist/index.js\");\n/* harmony import */ var crelt__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! crelt */ \"./node_modules/crelt/index.es.js\");\n\r\n\r\n\r\n\r\nconst basicNormalize = typeof String.prototype.normalize == \"function\"\r\n    ? x => x.normalize(\"NFKD\") : x => x;\r\n/**\r\nA search cursor provides an iterator over text matches in a\r\ndocument.\r\n*/\r\nclass SearchCursor {\r\n    /**\r\n    Create a text cursor. The query is the search string, `from` to\r\n    `to` provides the region to search.\r\n    \r\n    When `normalize` is given, it will be called, on both the query\r\n    string and the content it is matched against, before comparing.\r\n    You can, for example, create a case-insensitive search by\r\n    passing `s => s.toLowerCase()`.\r\n    \r\n    Text is always normalized with\r\n    [`.normalize(\"NFKD\")`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/normalize)\r\n    (when supported).\r\n    */\r\n    constructor(text, query, from = 0, to = text.length, normalize, test) {\r\n        this.test = test;\r\n        /**\r\n        The current match (only holds a meaningful value after\r\n        [`next`](https://codemirror.net/6/docs/ref/#search.SearchCursor.next) has been called and when\r\n        `done` is false).\r\n        */\r\n        this.value = { from: 0, to: 0 };\r\n        /**\r\n        Whether the end of the iterated region has been reached.\r\n        */\r\n        this.done = false;\r\n        this.matches = [];\r\n        this.buffer = \"\";\r\n        this.bufferPos = 0;\r\n        this.iter = text.iterRange(from, to);\r\n        this.bufferStart = from;\r\n        this.normalize = normalize ? x => normalize(basicNormalize(x)) : basicNormalize;\r\n        this.query = this.normalize(query);\r\n    }\r\n    peek() {\r\n        if (this.bufferPos == this.buffer.length) {\r\n            this.bufferStart += this.buffer.length;\r\n            this.iter.next();\r\n            if (this.iter.done)\r\n                return -1;\r\n            this.bufferPos = 0;\r\n            this.buffer = this.iter.value;\r\n        }\r\n        return (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.codePointAt)(this.buffer, this.bufferPos);\r\n    }\r\n    /**\r\n    Look for the next match. Updates the iterator's\r\n    [`value`](https://codemirror.net/6/docs/ref/#search.SearchCursor.value) and\r\n    [`done`](https://codemirror.net/6/docs/ref/#search.SearchCursor.done) properties. Should be called\r\n    at least once before using the cursor.\r\n    */\r\n    next() {\r\n        while (this.matches.length)\r\n            this.matches.pop();\r\n        return this.nextOverlapping();\r\n    }\r\n    /**\r\n    The `next` method will ignore matches that partially overlap a\r\n    previous match. This method behaves like `next`, but includes\r\n    such matches.\r\n    */\r\n    nextOverlapping() {\r\n        for (;;) {\r\n            let next = this.peek();\r\n            if (next < 0) {\r\n                this.done = true;\r\n                return this;\r\n            }\r\n            let str = (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.fromCodePoint)(next), start = this.bufferStart + this.bufferPos;\r\n            this.bufferPos += (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.codePointSize)(next);\r\n            let norm = this.normalize(str);\r\n            for (let i = 0, pos = start;; i++) {\r\n                let code = norm.charCodeAt(i);\r\n                let match = this.match(code, pos);\r\n                if (match) {\r\n                    this.value = match;\r\n                    return this;\r\n                }\r\n                if (i == norm.length - 1)\r\n                    break;\r\n                if (pos == start && i < str.length && str.charCodeAt(i) == code)\r\n                    pos++;\r\n            }\r\n        }\r\n    }\r\n    match(code, pos) {\r\n        let match = null;\r\n        for (let i = 0; i < this.matches.length; i += 2) {\r\n            let index = this.matches[i], keep = false;\r\n            if (this.query.charCodeAt(index) == code) {\r\n                if (index == this.query.length - 1) {\r\n                    match = { from: this.matches[i + 1], to: pos + 1 };\r\n                }\r\n                else {\r\n                    this.matches[i]++;\r\n                    keep = true;\r\n                }\r\n            }\r\n            if (!keep) {\r\n                this.matches.splice(i, 2);\r\n                i -= 2;\r\n            }\r\n        }\r\n        if (this.query.charCodeAt(0) == code) {\r\n            if (this.query.length == 1)\r\n                match = { from: pos, to: pos + 1 };\r\n            else\r\n                this.matches.push(1, pos);\r\n        }\r\n        if (match && this.test && !this.test(match.from, match.to, this.buffer, this.bufferPos))\r\n            match = null;\r\n        return match;\r\n    }\r\n}\r\nif (typeof Symbol != \"undefined\")\r\n    SearchCursor.prototype[Symbol.iterator] = function () { return this; };\r\n\r\nconst empty = { from: -1, to: -1, match: /*@__PURE__*//.*/.exec(\"\") };\r\nconst baseFlags = \"gm\" + (/x/.unicode == null ? \"\" : \"u\");\r\n/**\r\nThis class is similar to [`SearchCursor`](https://codemirror.net/6/docs/ref/#search.SearchCursor)\r\nbut searches for a regular expression pattern instead of a plain\r\nstring.\r\n*/\r\nclass RegExpCursor {\r\n    /**\r\n    Create a cursor that will search the given range in the given\r\n    document. `query` should be the raw pattern (as you'd pass it to\r\n    `new RegExp`).\r\n    */\r\n    constructor(text, query, options, from = 0, to = text.length) {\r\n        this.text = text;\r\n        this.to = to;\r\n        this.curLine = \"\";\r\n        /**\r\n        Set to `true` when the cursor has reached the end of the search\r\n        range.\r\n        */\r\n        this.done = false;\r\n        /**\r\n        Will contain an object with the extent of the match and the\r\n        match object when [`next`](https://codemirror.net/6/docs/ref/#search.RegExpCursor.next)\r\n        sucessfully finds a match.\r\n        */\r\n        this.value = empty;\r\n        if (/\\\\[sWDnr]|\\n|\\r|\\[\\^/.test(query))\r\n            return new MultilineRegExpCursor(text, query, options, from, to);\r\n        this.re = new RegExp(query, baseFlags + ((options === null || options === void 0 ? void 0 : options.ignoreCase) ? \"i\" : \"\"));\r\n        this.test = options === null || options === void 0 ? void 0 : options.test;\r\n        this.iter = text.iter();\r\n        let startLine = text.lineAt(from);\r\n        this.curLineStart = startLine.from;\r\n        this.matchPos = toCharEnd(text, from);\r\n        this.getLine(this.curLineStart);\r\n    }\r\n    getLine(skip) {\r\n        this.iter.next(skip);\r\n        if (this.iter.lineBreak) {\r\n            this.curLine = \"\";\r\n        }\r\n        else {\r\n            this.curLine = this.iter.value;\r\n            if (this.curLineStart + this.curLine.length > this.to)\r\n                this.curLine = this.curLine.slice(0, this.to - this.curLineStart);\r\n            this.iter.next();\r\n        }\r\n    }\r\n    nextLine() {\r\n        this.curLineStart = this.curLineStart + this.curLine.length + 1;\r\n        if (this.curLineStart > this.to)\r\n            this.curLine = \"\";\r\n        else\r\n            this.getLine(0);\r\n    }\r\n    /**\r\n    Move to the next match, if there is one.\r\n    */\r\n    next() {\r\n        for (let off = this.matchPos - this.curLineStart;;) {\r\n            this.re.lastIndex = off;\r\n            let match = this.matchPos <= this.to && this.re.exec(this.curLine);\r\n            if (match) {\r\n                let from = this.curLineStart + match.index, to = from + match[0].length;\r\n                this.matchPos = toCharEnd(this.text, to + (from == to ? 1 : 0));\r\n                if (from == this.curLineStart + this.curLine.length)\r\n                    this.nextLine();\r\n                if ((from < to || from > this.value.to) && (!this.test || this.test(from, to, match))) {\r\n                    this.value = { from, to, match };\r\n                    return this;\r\n                }\r\n                off = this.matchPos - this.curLineStart;\r\n            }\r\n            else if (this.curLineStart + this.curLine.length < this.to) {\r\n                this.nextLine();\r\n                off = 0;\r\n            }\r\n            else {\r\n                this.done = true;\r\n                return this;\r\n            }\r\n        }\r\n    }\r\n}\r\nconst flattened = /*@__PURE__*/new WeakMap();\r\n// Reusable (partially) flattened document strings\r\nclass FlattenedDoc {\r\n    constructor(from, text) {\r\n        this.from = from;\r\n        this.text = text;\r\n    }\r\n    get to() { return this.from + this.text.length; }\r\n    static get(doc, from, to) {\r\n        let cached = flattened.get(doc);\r\n        if (!cached || cached.from >= to || cached.to <= from) {\r\n            let flat = new FlattenedDoc(from, doc.sliceString(from, to));\r\n            flattened.set(doc, flat);\r\n            return flat;\r\n        }\r\n        if (cached.from == from && cached.to == to)\r\n            return cached;\r\n        let { text, from: cachedFrom } = cached;\r\n        if (cachedFrom > from) {\r\n            text = doc.sliceString(from, cachedFrom) + text;\r\n            cachedFrom = from;\r\n        }\r\n        if (cached.to < to)\r\n            text += doc.sliceString(cached.to, to);\r\n        flattened.set(doc, new FlattenedDoc(cachedFrom, text));\r\n        return new FlattenedDoc(from, text.slice(from - cachedFrom, to - cachedFrom));\r\n    }\r\n}\r\nclass MultilineRegExpCursor {\r\n    constructor(text, query, options, from, to) {\r\n        this.text = text;\r\n        this.to = to;\r\n        this.done = false;\r\n        this.value = empty;\r\n        this.matchPos = toCharEnd(text, from);\r\n        this.re = new RegExp(query, baseFlags + ((options === null || options === void 0 ? void 0 : options.ignoreCase) ? \"i\" : \"\"));\r\n        this.test = options === null || options === void 0 ? void 0 : options.test;\r\n        this.flat = FlattenedDoc.get(text, from, this.chunkEnd(from + 5000 /* Chunk.Base */));\r\n    }\r\n    chunkEnd(pos) {\r\n        return pos >= this.to ? this.to : this.text.lineAt(pos).to;\r\n    }\r\n    next() {\r\n        for (;;) {\r\n            let off = this.re.lastIndex = this.matchPos - this.flat.from;\r\n            let match = this.re.exec(this.flat.text);\r\n            // Skip empty matches directly after the last match\r\n            if (match && !match[0] && match.index == off) {\r\n                this.re.lastIndex = off + 1;\r\n                match = this.re.exec(this.flat.text);\r\n            }\r\n            if (match) {\r\n                let from = this.flat.from + match.index, to = from + match[0].length;\r\n                // If a match goes almost to the end of a noncomplete chunk, try\r\n                // again, since it'll likely be able to match more\r\n                if ((this.flat.to >= this.to || match.index + match[0].length <= this.flat.text.length - 10) &&\r\n                    (!this.test || this.test(from, to, match))) {\r\n                    this.value = { from, to, match };\r\n                    this.matchPos = toCharEnd(this.text, to + (from == to ? 1 : 0));\r\n                    return this;\r\n                }\r\n            }\r\n            if (this.flat.to == this.to) {\r\n                this.done = true;\r\n                return this;\r\n            }\r\n            // Grow the flattened doc\r\n            this.flat = FlattenedDoc.get(this.text, this.flat.from, this.chunkEnd(this.flat.from + this.flat.text.length * 2));\r\n        }\r\n    }\r\n}\r\nif (typeof Symbol != \"undefined\") {\r\n    RegExpCursor.prototype[Symbol.iterator] = MultilineRegExpCursor.prototype[Symbol.iterator] =\r\n        function () { return this; };\r\n}\r\nfunction validRegExp(source) {\r\n    try {\r\n        new RegExp(source, baseFlags);\r\n        return true;\r\n    }\r\n    catch (_a) {\r\n        return false;\r\n    }\r\n}\r\nfunction toCharEnd(text, pos) {\r\n    if (pos >= text.length)\r\n        return pos;\r\n    let line = text.lineAt(pos), next;\r\n    while (pos < line.to && (next = line.text.charCodeAt(pos - line.from)) >= 0xDC00 && next < 0xE000)\r\n        pos++;\r\n    return pos;\r\n}\r\n\r\nfunction createLineDialog(view) {\r\n    let input = (0,crelt__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"input\", { class: \"cm-textfield\", name: \"line\" });\r\n    let dom = (0,crelt__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"form\", {\r\n        class: \"cm-gotoLine\",\r\n        onkeydown: (event) => {\r\n            if (event.keyCode == 27) { // Escape\r\n                event.preventDefault();\r\n                view.dispatch({ effects: dialogEffect.of(false) });\r\n                view.focus();\r\n            }\r\n            else if (event.keyCode == 13) { // Enter\r\n                event.preventDefault();\r\n                go();\r\n            }\r\n        },\r\n        onsubmit: (event) => {\r\n            event.preventDefault();\r\n            go();\r\n        }\r\n    }, (0,crelt__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"label\", view.state.phrase(\"Go to line\"), \": \", input), \" \", (0,crelt__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"button\", { class: \"cm-button\", type: \"submit\" }, view.state.phrase(\"go\")));\r\n    function go() {\r\n        let match = /^([+-])?(\\d+)?(:\\d+)?(%)?$/.exec(input.value);\r\n        if (!match)\r\n            return;\r\n        let { state } = view, startLine = state.doc.lineAt(state.selection.main.head);\r\n        let [, sign, ln, cl, percent] = match;\r\n        let col = cl ? +cl.slice(1) : 0;\r\n        let line = ln ? +ln : startLine.number;\r\n        if (ln && percent) {\r\n            let pc = line / 100;\r\n            if (sign)\r\n                pc = pc * (sign == \"-\" ? -1 : 1) + (startLine.number / state.doc.lines);\r\n            line = Math.round(state.doc.lines * pc);\r\n        }\r\n        else if (ln && sign) {\r\n            line = line * (sign == \"-\" ? -1 : 1) + startLine.number;\r\n        }\r\n        let docLine = state.doc.line(Math.max(1, Math.min(state.doc.lines, line)));\r\n        view.dispatch({\r\n            effects: dialogEffect.of(false),\r\n            selection: _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.cursor(docLine.from + Math.max(0, Math.min(col, docLine.length))),\r\n            scrollIntoView: true\r\n        });\r\n        view.focus();\r\n    }\r\n    return { dom };\r\n}\r\nconst dialogEffect = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.StateEffect.define();\r\nconst dialogField = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.StateField.define({\r\n    create() { return true; },\r\n    update(value, tr) {\r\n        for (let e of tr.effects)\r\n            if (e.is(dialogEffect))\r\n                value = e.value;\r\n        return value;\r\n    },\r\n    provide: f => _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.showPanel.from(f, val => val ? createLineDialog : null)\r\n});\r\n/**\r\nCommand that shows a dialog asking the user for a line number, and\r\nwhen a valid position is provided, moves the cursor to that line.\r\n\r\nSupports line numbers, relative line offsets prefixed with `+` or\r\n`-`, document percentages suffixed with `%`, and an optional\r\ncolumn position by adding `:` and a second number after the line\r\nnumber.\r\n\r\nThe dialog can be styled with the `panel.gotoLine` theme\r\nselector.\r\n*/\r\nconst gotoLine = view => {\r\n    let panel = (0,_codemirror_view__WEBPACK_IMPORTED_MODULE_2__.getPanel)(view, createLineDialog);\r\n    if (!panel) {\r\n        let effects = [dialogEffect.of(true)];\r\n        if (view.state.field(dialogField, false) == null)\r\n            effects.push(_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.StateEffect.appendConfig.of([dialogField, baseTheme$1]));\r\n        view.dispatch({ effects });\r\n        panel = (0,_codemirror_view__WEBPACK_IMPORTED_MODULE_2__.getPanel)(view, createLineDialog);\r\n    }\r\n    if (panel)\r\n        panel.dom.querySelector(\"input\").focus();\r\n    return true;\r\n};\r\nconst baseTheme$1 = /*@__PURE__*/_codemirror_view__WEBPACK_IMPORTED_MODULE_2__.EditorView.baseTheme({\r\n    \".cm-panel.cm-gotoLine\": {\r\n        padding: \"2px 6px 4px\",\r\n        \"& label\": { fontSize: \"80%\" }\r\n    }\r\n});\r\n\r\nconst defaultHighlightOptions = {\r\n    highlightWordAroundCursor: false,\r\n    minSelectionLength: 1,\r\n    maxMatches: 100,\r\n    wholeWords: false\r\n};\r\nconst highlightConfig = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.Facet.define({\r\n    combine(options) {\r\n        return (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.combineConfig)(options, defaultHighlightOptions, {\r\n            highlightWordAroundCursor: (a, b) => a || b,\r\n            minSelectionLength: Math.min,\r\n            maxMatches: Math.min\r\n        });\r\n    }\r\n});\r\n/**\r\nThis extension highlights text that matches the selection. It uses\r\nthe `\"cm-selectionMatch\"` class for the highlighting. When\r\n`highlightWordAroundCursor` is enabled, the word at the cursor\r\nitself will be highlighted with `\"cm-selectionMatch-main\"`.\r\n*/\r\nfunction highlightSelectionMatches(options) {\r\n    let ext = [defaultTheme, matchHighlighter];\r\n    if (options)\r\n        ext.push(highlightConfig.of(options));\r\n    return ext;\r\n}\r\nconst matchDeco = /*@__PURE__*/_codemirror_view__WEBPACK_IMPORTED_MODULE_2__.Decoration.mark({ class: \"cm-selectionMatch\" });\r\nconst mainMatchDeco = /*@__PURE__*/_codemirror_view__WEBPACK_IMPORTED_MODULE_2__.Decoration.mark({ class: \"cm-selectionMatch cm-selectionMatch-main\" });\r\n// Whether the characters directly outside the given positions are non-word characters\r\nfunction insideWordBoundaries(check, state, from, to) {\r\n    return (from == 0 || check(state.sliceDoc(from - 1, from)) != _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.CharCategory.Word) &&\r\n        (to == state.doc.length || check(state.sliceDoc(to, to + 1)) != _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.CharCategory.Word);\r\n}\r\n// Whether the characters directly at the given positions are word characters\r\nfunction insideWord(check, state, from, to) {\r\n    return check(state.sliceDoc(from, from + 1)) == _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.CharCategory.Word\r\n        && check(state.sliceDoc(to - 1, to)) == _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.CharCategory.Word;\r\n}\r\nconst matchHighlighter = /*@__PURE__*/_codemirror_view__WEBPACK_IMPORTED_MODULE_2__.ViewPlugin.fromClass(class {\r\n    constructor(view) {\r\n        this.decorations = this.getDeco(view);\r\n    }\r\n    update(update) {\r\n        if (update.selectionSet || update.docChanged || update.viewportChanged)\r\n            this.decorations = this.getDeco(update.view);\r\n    }\r\n    getDeco(view) {\r\n        let conf = view.state.facet(highlightConfig);\r\n        let { state } = view, sel = state.selection;\r\n        if (sel.ranges.length > 1)\r\n            return _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.Decoration.none;\r\n        let range = sel.main, query, check = null;\r\n        if (range.empty) {\r\n            if (!conf.highlightWordAroundCursor)\r\n                return _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.Decoration.none;\r\n            let word = state.wordAt(range.head);\r\n            if (!word)\r\n                return _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.Decoration.none;\r\n            check = state.charCategorizer(range.head);\r\n            query = state.sliceDoc(word.from, word.to);\r\n        }\r\n        else {\r\n            let len = range.to - range.from;\r\n            if (len < conf.minSelectionLength || len > 200)\r\n                return _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.Decoration.none;\r\n            if (conf.wholeWords) {\r\n                query = state.sliceDoc(range.from, range.to); // TODO: allow and include leading/trailing space?\r\n                check = state.charCategorizer(range.head);\r\n                if (!(insideWordBoundaries(check, state, range.from, range.to)\r\n                    && insideWord(check, state, range.from, range.to)))\r\n                    return _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.Decoration.none;\r\n            }\r\n            else {\r\n                query = state.sliceDoc(range.from, range.to).trim();\r\n                if (!query)\r\n                    return _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.Decoration.none;\r\n            }\r\n        }\r\n        let deco = [];\r\n        for (let part of view.visibleRanges) {\r\n            let cursor = new SearchCursor(state.doc, query, part.from, part.to);\r\n            while (!cursor.next().done) {\r\n                let { from, to } = cursor.value;\r\n                if (!check || insideWordBoundaries(check, state, from, to)) {\r\n                    if (range.empty && from <= range.from && to >= range.to)\r\n                        deco.push(mainMatchDeco.range(from, to));\r\n                    else if (from >= range.to || to <= range.from)\r\n                        deco.push(matchDeco.range(from, to));\r\n                    if (deco.length > conf.maxMatches)\r\n                        return _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.Decoration.none;\r\n                }\r\n            }\r\n        }\r\n        return _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.Decoration.set(deco);\r\n    }\r\n}, {\r\n    decorations: v => v.decorations\r\n});\r\nconst defaultTheme = /*@__PURE__*/_codemirror_view__WEBPACK_IMPORTED_MODULE_2__.EditorView.baseTheme({\r\n    \".cm-selectionMatch\": { backgroundColor: \"#99ff7780\" },\r\n    \".cm-searchMatch .cm-selectionMatch\": { backgroundColor: \"transparent\" }\r\n});\r\n// Select the words around the cursors.\r\nconst selectWord = ({ state, dispatch }) => {\r\n    let { selection } = state;\r\n    let newSel = _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.create(selection.ranges.map(range => state.wordAt(range.head) || _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.cursor(range.head)), selection.mainIndex);\r\n    if (newSel.eq(selection))\r\n        return false;\r\n    dispatch(state.update({ selection: newSel }));\r\n    return true;\r\n};\r\n// Find next occurrence of query relative to last cursor. Wrap around\r\n// the document if there are no more matches.\r\nfunction findNextOccurrence(state, query) {\r\n    let { main, ranges } = state.selection;\r\n    let word = state.wordAt(main.head), fullWord = word && word.from == main.from && word.to == main.to;\r\n    for (let cycled = false, cursor = new SearchCursor(state.doc, query, ranges[ranges.length - 1].to);;) {\r\n        cursor.next();\r\n        if (cursor.done) {\r\n            if (cycled)\r\n                return null;\r\n            cursor = new SearchCursor(state.doc, query, 0, Math.max(0, ranges[ranges.length - 1].from - 1));\r\n            cycled = true;\r\n        }\r\n        else {\r\n            if (cycled && ranges.some(r => r.from == cursor.value.from))\r\n                continue;\r\n            if (fullWord) {\r\n                let word = state.wordAt(cursor.value.from);\r\n                if (!word || word.from != cursor.value.from || word.to != cursor.value.to)\r\n                    continue;\r\n            }\r\n            return cursor.value;\r\n        }\r\n    }\r\n}\r\n/**\r\nSelect next occurrence of the current selection. Expand selection\r\nto the surrounding word when the selection is empty.\r\n*/\r\nconst selectNextOccurrence = ({ state, dispatch }) => {\r\n    let { ranges } = state.selection;\r\n    if (ranges.some(sel => sel.from === sel.to))\r\n        return selectWord({ state, dispatch });\r\n    let searchedText = state.sliceDoc(ranges[0].from, ranges[0].to);\r\n    if (state.selection.ranges.some(r => state.sliceDoc(r.from, r.to) != searchedText))\r\n        return false;\r\n    let range = findNextOccurrence(state, searchedText);\r\n    if (!range)\r\n        return false;\r\n    dispatch(state.update({\r\n        selection: state.selection.addRange(_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.range(range.from, range.to), false),\r\n        effects: _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.EditorView.scrollIntoView(range.to)\r\n    }));\r\n    return true;\r\n};\r\n\r\nconst searchConfigFacet = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.Facet.define({\r\n    combine(configs) {\r\n        return (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.combineConfig)(configs, {\r\n            top: false,\r\n            caseSensitive: false,\r\n            literal: false,\r\n            wholeWord: false,\r\n            createPanel: view => new SearchPanel(view)\r\n        });\r\n    }\r\n});\r\n/**\r\nAdd search state to the editor configuration, and optionally\r\nconfigure the search extension.\r\n([`openSearchPanel`](https://codemirror.net/6/docs/ref/#search.openSearchPanel) will automatically\r\nenable this if it isn't already on).\r\n*/\r\nfunction search(config) {\r\n    return config ? [searchConfigFacet.of(config), searchExtensions] : searchExtensions;\r\n}\r\n/**\r\nA search query. Part of the editor's search state.\r\n*/\r\nclass SearchQuery {\r\n    /**\r\n    Create a query object.\r\n    */\r\n    constructor(config) {\r\n        this.search = config.search;\r\n        this.caseSensitive = !!config.caseSensitive;\r\n        this.literal = !!config.literal;\r\n        this.regexp = !!config.regexp;\r\n        this.replace = config.replace || \"\";\r\n        this.valid = !!this.search && (!this.regexp || validRegExp(this.search));\r\n        this.unquoted = this.unquote(this.search);\r\n        this.wholeWord = !!config.wholeWord;\r\n    }\r\n    /**\r\n    @internal\r\n    */\r\n    unquote(text) {\r\n        return this.literal ? text :\r\n            text.replace(/\\\\([nrt\\\\])/g, (_, ch) => ch == \"n\" ? \"\\n\" : ch == \"r\" ? \"\\r\" : ch == \"t\" ? \"\\t\" : \"\\\\\");\r\n    }\r\n    /**\r\n    Compare this query to another query.\r\n    */\r\n    eq(other) {\r\n        return this.search == other.search && this.replace == other.replace &&\r\n            this.caseSensitive == other.caseSensitive && this.regexp == other.regexp &&\r\n            this.wholeWord == other.wholeWord;\r\n    }\r\n    /**\r\n    @internal\r\n    */\r\n    create() {\r\n        return this.regexp ? new RegExpQuery(this) : new StringQuery(this);\r\n    }\r\n    /**\r\n    Get a search cursor for this query, searching through the given\r\n    range in the given state.\r\n    */\r\n    getCursor(state, from = 0, to) {\r\n        let st = state.doc ? state : _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorState.create({ doc: state });\r\n        if (to == null)\r\n            to = st.doc.length;\r\n        return this.regexp ? regexpCursor(this, st, from, to) : stringCursor(this, st, from, to);\r\n    }\r\n}\r\nclass QueryType {\r\n    constructor(spec) {\r\n        this.spec = spec;\r\n    }\r\n}\r\nfunction stringCursor(spec, state, from, to) {\r\n    return new SearchCursor(state.doc, spec.unquoted, from, to, spec.caseSensitive ? undefined : x => x.toLowerCase(), spec.wholeWord ? stringWordTest(state.doc, state.charCategorizer(state.selection.main.head)) : undefined);\r\n}\r\nfunction stringWordTest(doc, categorizer) {\r\n    return (from, to, buf, bufPos) => {\r\n        if (bufPos > from || bufPos + buf.length < to) {\r\n            bufPos = Math.max(0, from - 2);\r\n            buf = doc.sliceString(bufPos, Math.min(doc.length, to + 2));\r\n        }\r\n        return (categorizer(charBefore(buf, from - bufPos)) != _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.CharCategory.Word ||\r\n            categorizer(charAfter(buf, from - bufPos)) != _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.CharCategory.Word) &&\r\n            (categorizer(charAfter(buf, to - bufPos)) != _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.CharCategory.Word ||\r\n                categorizer(charBefore(buf, to - bufPos)) != _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.CharCategory.Word);\r\n    };\r\n}\r\nclass StringQuery extends QueryType {\r\n    constructor(spec) {\r\n        super(spec);\r\n    }\r\n    nextMatch(state, curFrom, curTo) {\r\n        let cursor = stringCursor(this.spec, state, curTo, state.doc.length).nextOverlapping();\r\n        if (cursor.done)\r\n            cursor = stringCursor(this.spec, state, 0, curFrom).nextOverlapping();\r\n        return cursor.done ? null : cursor.value;\r\n    }\r\n    // Searching in reverse is, rather than implementing inverted search\r\n    // cursor, done by scanning chunk after chunk forward.\r\n    prevMatchInRange(state, from, to) {\r\n        for (let pos = to;;) {\r\n            let start = Math.max(from, pos - 10000 /* FindPrev.ChunkSize */ - this.spec.unquoted.length);\r\n            let cursor = stringCursor(this.spec, state, start, pos), range = null;\r\n            while (!cursor.nextOverlapping().done)\r\n                range = cursor.value;\r\n            if (range)\r\n                return range;\r\n            if (start == from)\r\n                return null;\r\n            pos -= 10000 /* FindPrev.ChunkSize */;\r\n        }\r\n    }\r\n    prevMatch(state, curFrom, curTo) {\r\n        return this.prevMatchInRange(state, 0, curFrom) ||\r\n            this.prevMatchInRange(state, curTo, state.doc.length);\r\n    }\r\n    getReplacement(_result) { return this.spec.unquote(this.spec.replace); }\r\n    matchAll(state, limit) {\r\n        let cursor = stringCursor(this.spec, state, 0, state.doc.length), ranges = [];\r\n        while (!cursor.next().done) {\r\n            if (ranges.length >= limit)\r\n                return null;\r\n            ranges.push(cursor.value);\r\n        }\r\n        return ranges;\r\n    }\r\n    highlight(state, from, to, add) {\r\n        let cursor = stringCursor(this.spec, state, Math.max(0, from - this.spec.unquoted.length), Math.min(to + this.spec.unquoted.length, state.doc.length));\r\n        while (!cursor.next().done)\r\n            add(cursor.value.from, cursor.value.to);\r\n    }\r\n}\r\nfunction regexpCursor(spec, state, from, to) {\r\n    return new RegExpCursor(state.doc, spec.search, {\r\n        ignoreCase: !spec.caseSensitive,\r\n        test: spec.wholeWord ? regexpWordTest(state.charCategorizer(state.selection.main.head)) : undefined\r\n    }, from, to);\r\n}\r\nfunction charBefore(str, index) {\r\n    return str.slice((0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.findClusterBreak)(str, index, false), index);\r\n}\r\nfunction charAfter(str, index) {\r\n    return str.slice(index, (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.findClusterBreak)(str, index));\r\n}\r\nfunction regexpWordTest(categorizer) {\r\n    return (_from, _to, match) => !match[0].length ||\r\n        (categorizer(charBefore(match.input, match.index)) != _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.CharCategory.Word ||\r\n            categorizer(charAfter(match.input, match.index)) != _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.CharCategory.Word) &&\r\n            (categorizer(charAfter(match.input, match.index + match[0].length)) != _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.CharCategory.Word ||\r\n                categorizer(charBefore(match.input, match.index + match[0].length)) != _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.CharCategory.Word);\r\n}\r\nclass RegExpQuery extends QueryType {\r\n    nextMatch(state, curFrom, curTo) {\r\n        let cursor = regexpCursor(this.spec, state, curTo, state.doc.length).next();\r\n        if (cursor.done)\r\n            cursor = regexpCursor(this.spec, state, 0, curFrom).next();\r\n        return cursor.done ? null : cursor.value;\r\n    }\r\n    prevMatchInRange(state, from, to) {\r\n        for (let size = 1;; size++) {\r\n            let start = Math.max(from, to - size * 10000 /* FindPrev.ChunkSize */);\r\n            let cursor = regexpCursor(this.spec, state, start, to), range = null;\r\n            while (!cursor.next().done)\r\n                range = cursor.value;\r\n            if (range && (start == from || range.from > start + 10))\r\n                return range;\r\n            if (start == from)\r\n                return null;\r\n        }\r\n    }\r\n    prevMatch(state, curFrom, curTo) {\r\n        return this.prevMatchInRange(state, 0, curFrom) ||\r\n            this.prevMatchInRange(state, curTo, state.doc.length);\r\n    }\r\n    getReplacement(result) {\r\n        return this.spec.unquote(this.spec.replace.replace(/\\$([$&\\d+])/g, (m, i) => i == \"$\" ? \"$\"\r\n            : i == \"&\" ? result.match[0]\r\n                : i != \"0\" && +i < result.match.length ? result.match[i]\r\n                    : m));\r\n    }\r\n    matchAll(state, limit) {\r\n        let cursor = regexpCursor(this.spec, state, 0, state.doc.length), ranges = [];\r\n        while (!cursor.next().done) {\r\n            if (ranges.length >= limit)\r\n                return null;\r\n            ranges.push(cursor.value);\r\n        }\r\n        return ranges;\r\n    }\r\n    highlight(state, from, to, add) {\r\n        let cursor = regexpCursor(this.spec, state, Math.max(0, from - 250 /* RegExp.HighlightMargin */), Math.min(to + 250 /* RegExp.HighlightMargin */, state.doc.length));\r\n        while (!cursor.next().done)\r\n            add(cursor.value.from, cursor.value.to);\r\n    }\r\n}\r\n/**\r\nA state effect that updates the current search query. Note that\r\nthis only has an effect if the search state has been initialized\r\n(by including [`search`](https://codemirror.net/6/docs/ref/#search.search) in your configuration or\r\nby running [`openSearchPanel`](https://codemirror.net/6/docs/ref/#search.openSearchPanel) at least\r\nonce).\r\n*/\r\nconst setSearchQuery = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.StateEffect.define();\r\nconst togglePanel = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.StateEffect.define();\r\nconst searchState = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.StateField.define({\r\n    create(state) {\r\n        return new SearchState(defaultQuery(state).create(), null);\r\n    },\r\n    update(value, tr) {\r\n        for (let effect of tr.effects) {\r\n            if (effect.is(setSearchQuery))\r\n                value = new SearchState(effect.value.create(), value.panel);\r\n            else if (effect.is(togglePanel))\r\n                value = new SearchState(value.query, effect.value ? createSearchPanel : null);\r\n        }\r\n        return value;\r\n    },\r\n    provide: f => _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.showPanel.from(f, val => val.panel)\r\n});\r\n/**\r\nGet the current search query from an editor state.\r\n*/\r\nfunction getSearchQuery(state) {\r\n    let curState = state.field(searchState, false);\r\n    return curState ? curState.query.spec : defaultQuery(state);\r\n}\r\n/**\r\nQuery whether the search panel is open in the given editor state.\r\n*/\r\nfunction searchPanelOpen(state) {\r\n    var _a;\r\n    return ((_a = state.field(searchState, false)) === null || _a === void 0 ? void 0 : _a.panel) != null;\r\n}\r\nclass SearchState {\r\n    constructor(query, panel) {\r\n        this.query = query;\r\n        this.panel = panel;\r\n    }\r\n}\r\nconst matchMark = /*@__PURE__*/_codemirror_view__WEBPACK_IMPORTED_MODULE_2__.Decoration.mark({ class: \"cm-searchMatch\" }), selectedMatchMark = /*@__PURE__*/_codemirror_view__WEBPACK_IMPORTED_MODULE_2__.Decoration.mark({ class: \"cm-searchMatch cm-searchMatch-selected\" });\r\nconst searchHighlighter = /*@__PURE__*/_codemirror_view__WEBPACK_IMPORTED_MODULE_2__.ViewPlugin.fromClass(class {\r\n    constructor(view) {\r\n        this.view = view;\r\n        this.decorations = this.highlight(view.state.field(searchState));\r\n    }\r\n    update(update) {\r\n        let state = update.state.field(searchState);\r\n        if (state != update.startState.field(searchState) || update.docChanged || update.selectionSet || update.viewportChanged)\r\n            this.decorations = this.highlight(state);\r\n    }\r\n    highlight({ query, panel }) {\r\n        if (!panel || !query.spec.valid)\r\n            return _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.Decoration.none;\r\n        let { view } = this;\r\n        let builder = new _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.RangeSetBuilder();\r\n        for (let i = 0, ranges = view.visibleRanges, l = ranges.length; i < l; i++) {\r\n            let { from, to } = ranges[i];\r\n            while (i < l - 1 && to > ranges[i + 1].from - 2 * 250 /* RegExp.HighlightMargin */)\r\n                to = ranges[++i].to;\r\n            query.highlight(view.state, from, to, (from, to) => {\r\n                let selected = view.state.selection.ranges.some(r => r.from == from && r.to == to);\r\n                builder.add(from, to, selected ? selectedMatchMark : matchMark);\r\n            });\r\n        }\r\n        return builder.finish();\r\n    }\r\n}, {\r\n    decorations: v => v.decorations\r\n});\r\nfunction searchCommand(f) {\r\n    return view => {\r\n        let state = view.state.field(searchState, false);\r\n        return state && state.query.spec.valid ? f(view, state) : openSearchPanel(view);\r\n    };\r\n}\r\n/**\r\nOpen the search panel if it isn't already open, and move the\r\nselection to the first match after the current main selection.\r\nWill wrap around to the start of the document when it reaches the\r\nend.\r\n*/\r\nconst findNext = /*@__PURE__*/searchCommand((view, { query }) => {\r\n    let { to } = view.state.selection.main;\r\n    let next = query.nextMatch(view.state, to, to);\r\n    if (!next)\r\n        return false;\r\n    view.dispatch({\r\n        selection: { anchor: next.from, head: next.to },\r\n        scrollIntoView: true,\r\n        effects: announceMatch(view, next),\r\n        userEvent: \"select.search\"\r\n    });\r\n    return true;\r\n});\r\n/**\r\nMove the selection to the previous instance of the search query,\r\nbefore the current main selection. Will wrap past the start\r\nof the document to start searching at the end again.\r\n*/\r\nconst findPrevious = /*@__PURE__*/searchCommand((view, { query }) => {\r\n    let { state } = view, { from } = state.selection.main;\r\n    let range = query.prevMatch(state, from, from);\r\n    if (!range)\r\n        return false;\r\n    view.dispatch({\r\n        selection: { anchor: range.from, head: range.to },\r\n        scrollIntoView: true,\r\n        effects: announceMatch(view, range),\r\n        userEvent: \"select.search\"\r\n    });\r\n    return true;\r\n});\r\n/**\r\nSelect all instances of the search query.\r\n*/\r\nconst selectMatches = /*@__PURE__*/searchCommand((view, { query }) => {\r\n    let ranges = query.matchAll(view.state, 1000);\r\n    if (!ranges || !ranges.length)\r\n        return false;\r\n    view.dispatch({\r\n        selection: _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.create(ranges.map(r => _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.range(r.from, r.to))),\r\n        userEvent: \"select.search.matches\"\r\n    });\r\n    return true;\r\n});\r\n/**\r\nSelect all instances of the currently selected text.\r\n*/\r\nconst selectSelectionMatches = ({ state, dispatch }) => {\r\n    let sel = state.selection;\r\n    if (sel.ranges.length > 1 || sel.main.empty)\r\n        return false;\r\n    let { from, to } = sel.main;\r\n    let ranges = [], main = 0;\r\n    for (let cur = new SearchCursor(state.doc, state.sliceDoc(from, to)); !cur.next().done;) {\r\n        if (ranges.length > 1000)\r\n            return false;\r\n        if (cur.value.from == from)\r\n            main = ranges.length;\r\n        ranges.push(_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.range(cur.value.from, cur.value.to));\r\n    }\r\n    dispatch(state.update({\r\n        selection: _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.create(ranges, main),\r\n        userEvent: \"select.search.matches\"\r\n    }));\r\n    return true;\r\n};\r\n/**\r\nReplace the current match of the search query.\r\n*/\r\nconst replaceNext = /*@__PURE__*/searchCommand((view, { query }) => {\r\n    let { state } = view, { from, to } = state.selection.main;\r\n    if (state.readOnly)\r\n        return false;\r\n    let next = query.nextMatch(state, from, from);\r\n    if (!next)\r\n        return false;\r\n    let changes = [], selection, replacement;\r\n    let announce = [];\r\n    if (next.from == from && next.to == to) {\r\n        replacement = state.toText(query.getReplacement(next));\r\n        changes.push({ from: next.from, to: next.to, insert: replacement });\r\n        next = query.nextMatch(state, next.from, next.to);\r\n        announce.push(_codemirror_view__WEBPACK_IMPORTED_MODULE_2__.EditorView.announce.of(state.phrase(\"replaced match on line $\", state.doc.lineAt(from).number) + \".\"));\r\n    }\r\n    if (next) {\r\n        let off = changes.length == 0 || changes[0].from >= next.to ? 0 : next.to - next.from - replacement.length;\r\n        selection = { anchor: next.from - off, head: next.to - off };\r\n        announce.push(announceMatch(view, next));\r\n    }\r\n    view.dispatch({\r\n        changes, selection,\r\n        scrollIntoView: !!selection,\r\n        effects: announce,\r\n        userEvent: \"input.replace\"\r\n    });\r\n    return true;\r\n});\r\n/**\r\nReplace all instances of the search query with the given\r\nreplacement.\r\n*/\r\nconst replaceAll = /*@__PURE__*/searchCommand((view, { query }) => {\r\n    if (view.state.readOnly)\r\n        return false;\r\n    let changes = query.matchAll(view.state, 1e9).map(match => {\r\n        let { from, to } = match;\r\n        return { from, to, insert: query.getReplacement(match) };\r\n    });\r\n    if (!changes.length)\r\n        return false;\r\n    let announceText = view.state.phrase(\"replaced $ matches\", changes.length) + \".\";\r\n    view.dispatch({\r\n        changes,\r\n        effects: _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.EditorView.announce.of(announceText),\r\n        userEvent: \"input.replace.all\"\r\n    });\r\n    return true;\r\n});\r\nfunction createSearchPanel(view) {\r\n    return view.state.facet(searchConfigFacet).createPanel(view);\r\n}\r\nfunction defaultQuery(state, fallback) {\r\n    var _a, _b, _c, _d;\r\n    let sel = state.selection.main;\r\n    let selText = sel.empty || sel.to > sel.from + 100 ? \"\" : state.sliceDoc(sel.from, sel.to);\r\n    if (fallback && !selText)\r\n        return fallback;\r\n    let config = state.facet(searchConfigFacet);\r\n    return new SearchQuery({\r\n        search: ((_a = fallback === null || fallback === void 0 ? void 0 : fallback.literal) !== null && _a !== void 0 ? _a : config.literal) ? selText : selText.replace(/\\n/g, \"\\\\n\"),\r\n        caseSensitive: (_b = fallback === null || fallback === void 0 ? void 0 : fallback.caseSensitive) !== null && _b !== void 0 ? _b : config.caseSensitive,\r\n        literal: (_c = fallback === null || fallback === void 0 ? void 0 : fallback.literal) !== null && _c !== void 0 ? _c : config.literal,\r\n        wholeWord: (_d = fallback === null || fallback === void 0 ? void 0 : fallback.wholeWord) !== null && _d !== void 0 ? _d : config.wholeWord\r\n    });\r\n}\r\n/**\r\nMake sure the search panel is open and focused.\r\n*/\r\nconst openSearchPanel = view => {\r\n    let state = view.state.field(searchState, false);\r\n    if (state && state.panel) {\r\n        let panel = (0,_codemirror_view__WEBPACK_IMPORTED_MODULE_2__.getPanel)(view, createSearchPanel);\r\n        if (!panel)\r\n            return false;\r\n        let searchInput = panel.dom.querySelector(\"[main-field]\");\r\n        if (searchInput && searchInput != view.root.activeElement) {\r\n            let query = defaultQuery(view.state, state.query.spec);\r\n            if (query.valid)\r\n                view.dispatch({ effects: setSearchQuery.of(query) });\r\n            searchInput.focus();\r\n            searchInput.select();\r\n        }\r\n    }\r\n    else {\r\n        view.dispatch({ effects: [\r\n                togglePanel.of(true),\r\n                state ? setSearchQuery.of(defaultQuery(view.state, state.query.spec)) : _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.StateEffect.appendConfig.of(searchExtensions)\r\n            ] });\r\n    }\r\n    return true;\r\n};\r\n/**\r\nClose the search panel.\r\n*/\r\nconst closeSearchPanel = view => {\r\n    let state = view.state.field(searchState, false);\r\n    if (!state || !state.panel)\r\n        return false;\r\n    let panel = (0,_codemirror_view__WEBPACK_IMPORTED_MODULE_2__.getPanel)(view, createSearchPanel);\r\n    if (panel && panel.dom.contains(view.root.activeElement))\r\n        view.focus();\r\n    view.dispatch({ effects: togglePanel.of(false) });\r\n    return true;\r\n};\r\n/**\r\nDefault search-related key bindings.\r\n\r\n - Mod-f: [`openSearchPanel`](https://codemirror.net/6/docs/ref/#search.openSearchPanel)\r\n - F3, Mod-g: [`findNext`](https://codemirror.net/6/docs/ref/#search.findNext)\r\n - Shift-F3, Shift-Mod-g: [`findPrevious`](https://codemirror.net/6/docs/ref/#search.findPrevious)\r\n - Alt-g: [`gotoLine`](https://codemirror.net/6/docs/ref/#search.gotoLine)\r\n - Mod-d: [`selectNextOccurrence`](https://codemirror.net/6/docs/ref/#search.selectNextOccurrence)\r\n*/\r\nconst searchKeymap = [\r\n    { key: \"Mod-f\", run: openSearchPanel, scope: \"editor search-panel\" },\r\n    { key: \"F3\", run: findNext, shift: findPrevious, scope: \"editor search-panel\", preventDefault: true },\r\n    { key: \"Mod-g\", run: findNext, shift: findPrevious, scope: \"editor search-panel\", preventDefault: true },\r\n    { key: \"Escape\", run: closeSearchPanel, scope: \"editor search-panel\" },\r\n    { key: \"Mod-Shift-l\", run: selectSelectionMatches },\r\n    { key: \"Alt-g\", run: gotoLine },\r\n    { key: \"Mod-d\", run: selectNextOccurrence, preventDefault: true },\r\n];\r\nclass SearchPanel {\r\n    constructor(view) {\r\n        this.view = view;\r\n        let query = this.query = view.state.field(searchState).query.spec;\r\n        this.commit = this.commit.bind(this);\r\n        this.searchField = (0,crelt__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"input\", {\r\n            value: query.search,\r\n            placeholder: phrase(view, \"Find\"),\r\n            \"aria-label\": phrase(view, \"Find\"),\r\n            class: \"cm-textfield\",\r\n            name: \"search\",\r\n            form: \"\",\r\n            \"main-field\": \"true\",\r\n            onchange: this.commit,\r\n            onkeyup: this.commit\r\n        });\r\n        this.replaceField = (0,crelt__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"input\", {\r\n            value: query.replace,\r\n            placeholder: phrase(view, \"Replace\"),\r\n            \"aria-label\": phrase(view, \"Replace\"),\r\n            class: \"cm-textfield\",\r\n            name: \"replace\",\r\n            form: \"\",\r\n            onchange: this.commit,\r\n            onkeyup: this.commit\r\n        });\r\n        this.caseField = (0,crelt__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"input\", {\r\n            type: \"checkbox\",\r\n            name: \"case\",\r\n            form: \"\",\r\n            checked: query.caseSensitive,\r\n            onchange: this.commit\r\n        });\r\n        this.reField = (0,crelt__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"input\", {\r\n            type: \"checkbox\",\r\n            name: \"re\",\r\n            form: \"\",\r\n            checked: query.regexp,\r\n            onchange: this.commit\r\n        });\r\n        this.wordField = (0,crelt__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"input\", {\r\n            type: \"checkbox\",\r\n            name: \"word\",\r\n            form: \"\",\r\n            checked: query.wholeWord,\r\n            onchange: this.commit\r\n        });\r\n        function button(name, onclick, content) {\r\n            return (0,crelt__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"button\", { class: \"cm-button\", name, onclick, type: \"button\" }, content);\r\n        }\r\n        this.dom = (0,crelt__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"div\", { onkeydown: (e) => this.keydown(e), class: \"cm-search\" }, [\r\n            this.searchField,\r\n            button(\"next\", () => findNext(view), [phrase(view, \"next\")]),\r\n            button(\"prev\", () => findPrevious(view), [phrase(view, \"previous\")]),\r\n            button(\"select\", () => selectMatches(view), [phrase(view, \"all\")]),\r\n            (0,crelt__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"label\", null, [this.caseField, phrase(view, \"match case\")]),\r\n            (0,crelt__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"label\", null, [this.reField, phrase(view, \"regexp\")]),\r\n            (0,crelt__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"label\", null, [this.wordField, phrase(view, \"by word\")]),\r\n            ...view.state.readOnly ? [] : [\r\n                (0,crelt__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"br\"),\r\n                this.replaceField,\r\n                button(\"replace\", () => replaceNext(view), [phrase(view, \"replace\")]),\r\n                button(\"replaceAll\", () => replaceAll(view), [phrase(view, \"replace all\")])\r\n            ],\r\n            (0,crelt__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"button\", {\r\n                name: \"close\",\r\n                onclick: () => closeSearchPanel(view),\r\n                \"aria-label\": phrase(view, \"close\"),\r\n                type: \"button\"\r\n            }, [\"×\"])\r\n        ]);\r\n    }\r\n    commit() {\r\n        let query = new SearchQuery({\r\n            search: this.searchField.value,\r\n            caseSensitive: this.caseField.checked,\r\n            regexp: this.reField.checked,\r\n            wholeWord: this.wordField.checked,\r\n            replace: this.replaceField.value,\r\n        });\r\n        if (!query.eq(this.query)) {\r\n            this.query = query;\r\n            this.view.dispatch({ effects: setSearchQuery.of(query) });\r\n        }\r\n    }\r\n    keydown(e) {\r\n        if ((0,_codemirror_view__WEBPACK_IMPORTED_MODULE_2__.runScopeHandlers)(this.view, e, \"search-panel\")) {\r\n            e.preventDefault();\r\n        }\r\n        else if (e.keyCode == 13 && e.target == this.searchField) {\r\n            e.preventDefault();\r\n            (e.shiftKey ? findPrevious : findNext)(this.view);\r\n        }\r\n        else if (e.keyCode == 13 && e.target == this.replaceField) {\r\n            e.preventDefault();\r\n            replaceNext(this.view);\r\n        }\r\n    }\r\n    update(update) {\r\n        for (let tr of update.transactions)\r\n            for (let effect of tr.effects) {\r\n                if (effect.is(setSearchQuery) && !effect.value.eq(this.query))\r\n                    this.setQuery(effect.value);\r\n            }\r\n    }\r\n    setQuery(query) {\r\n        this.query = query;\r\n        this.searchField.value = query.search;\r\n        this.replaceField.value = query.replace;\r\n        this.caseField.checked = query.caseSensitive;\r\n        this.reField.checked = query.regexp;\r\n        this.wordField.checked = query.wholeWord;\r\n    }\r\n    mount() {\r\n        this.searchField.select();\r\n    }\r\n    get pos() { return 80; }\r\n    get top() { return this.view.state.facet(searchConfigFacet).top; }\r\n}\r\nfunction phrase(view, phrase) { return view.state.phrase(phrase); }\r\nconst AnnounceMargin = 30;\r\nconst Break = /[\\s\\.,:;?!]/;\r\nfunction announceMatch(view, { from, to }) {\r\n    let line = view.state.doc.lineAt(from), lineEnd = view.state.doc.lineAt(to).to;\r\n    let start = Math.max(line.from, from - AnnounceMargin), end = Math.min(lineEnd, to + AnnounceMargin);\r\n    let text = view.state.sliceDoc(start, end);\r\n    if (start != line.from) {\r\n        for (let i = 0; i < AnnounceMargin; i++)\r\n            if (!Break.test(text[i + 1]) && Break.test(text[i])) {\r\n                text = text.slice(i);\r\n                break;\r\n            }\r\n    }\r\n    if (end != lineEnd) {\r\n        for (let i = text.length - 1; i > text.length - AnnounceMargin; i--)\r\n            if (!Break.test(text[i - 1]) && Break.test(text[i])) {\r\n                text = text.slice(0, i);\r\n                break;\r\n            }\r\n    }\r\n    return _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.EditorView.announce.of(`${view.state.phrase(\"current match\")}. ${text} ${view.state.phrase(\"on line\")} ${line.number}.`);\r\n}\r\nconst baseTheme = /*@__PURE__*/_codemirror_view__WEBPACK_IMPORTED_MODULE_2__.EditorView.baseTheme({\r\n    \".cm-panel.cm-search\": {\r\n        padding: \"2px 6px 4px\",\r\n        position: \"relative\",\r\n        \"& [name=close]\": {\r\n            position: \"absolute\",\r\n            top: \"0\",\r\n            right: \"4px\",\r\n            backgroundColor: \"inherit\",\r\n            border: \"none\",\r\n            font: \"inherit\",\r\n            padding: 0,\r\n            margin: 0\r\n        },\r\n        \"& input, & button, & label\": {\r\n            margin: \".2em .6em .2em 0\"\r\n        },\r\n        \"& input[type=checkbox]\": {\r\n            marginRight: \".2em\"\r\n        },\r\n        \"& label\": {\r\n            fontSize: \"80%\",\r\n            whiteSpace: \"pre\"\r\n        }\r\n    },\r\n    \"&light .cm-searchMatch\": { backgroundColor: \"#ffff0054\" },\r\n    \"&dark .cm-searchMatch\": { backgroundColor: \"#00ffff8a\" },\r\n    \"&light .cm-searchMatch-selected\": { backgroundColor: \"#ff6a0054\" },\r\n    \"&dark .cm-searchMatch-selected\": { backgroundColor: \"#ff00ff8a\" }\r\n});\r\nconst searchExtensions = [\r\n    searchState,\r\n    /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.Prec.lowest(searchHighlighter),\r\n    baseTheme\r\n];\r\n\r\n\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGNvZGVtaXJyb3Ivc2VhcmNoL2Rpc3QvaW5kZXguanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUE2RztBQUNxRztBQUMxTDtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLDhEQUFXO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGdFQUFhO0FBQ25DLDhCQUE4QixnRUFBYTtBQUMzQztBQUNBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IseUJBQXlCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQ7QUFDNUQ7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBEO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyx5QkFBeUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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Q0E7QUFDQSxnQkFBZ0I7QUFDaEIsZ0JBQWdCO0FBQ2hCO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0EsdUJBQXVCO0FBQ3ZCLCtCQUErQixVQUFVO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLG9CQUFvQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0Msa0NBQWtDO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLG9FQUFzQixJQUFJLG1DQUFtQyxJQUFJLE1BQU0sRUFBRSw4QkFBOEIsRUFBRSxZQUFZO0FBQ2hJO0FBQ0EsK0JBQStCLGtFQUFvQjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLGdDQUFnQyw4QkFBOEI7QUFDOUQsK0JBQStCLDhCQUE4QjtBQUM3RCx5Q0FBeUMsOEJBQThCO0FBQ3ZFLHdDQUF3QztBQUN4QyxDQUFDO0FBQ0Q7QUFDQTtBQUNBLGlCQUFpQiwwREFBVztBQUM1QjtBQUNBO0FBQ0E7QUFDZ1QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0Bjb2RlbWlycm9yL3NlYXJjaC9kaXN0L2luZGV4LmpzP2I3MGYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgc2hvd1BhbmVsLCBFZGl0b3JWaWV3LCBnZXRQYW5lbCwgRGVjb3JhdGlvbiwgVmlld1BsdWdpbiwgcnVuU2NvcGVIYW5kbGVycyB9IGZyb20gJ0Bjb2RlbWlycm9yL3ZpZXcnO1xyXG5pbXBvcnQgeyBjb2RlUG9pbnRBdCwgZnJvbUNvZGVQb2ludCwgY29kZVBvaW50U2l6ZSwgU3RhdGVFZmZlY3QsIFN0YXRlRmllbGQsIEVkaXRvclNlbGVjdGlvbiwgRmFjZXQsIGNvbWJpbmVDb25maWcsIENoYXJDYXRlZ29yeSwgUmFuZ2VTZXRCdWlsZGVyLCBQcmVjLCBFZGl0b3JTdGF0ZSwgZmluZENsdXN0ZXJCcmVhayB9IGZyb20gJ0Bjb2RlbWlycm9yL3N0YXRlJztcclxuaW1wb3J0IGVsdCBmcm9tICdjcmVsdCc7XHJcblxyXG5jb25zdCBiYXNpY05vcm1hbGl6ZSA9IHR5cGVvZiBTdHJpbmcucHJvdG90eXBlLm5vcm1hbGl6ZSA9PSBcImZ1bmN0aW9uXCJcclxuICAgID8geCA9PiB4Lm5vcm1hbGl6ZShcIk5GS0RcIikgOiB4ID0+IHg7XHJcbi8qKlxyXG5BIHNlYXJjaCBjdXJzb3IgcHJvdmlkZXMgYW4gaXRlcmF0b3Igb3ZlciB0ZXh0IG1hdGNoZXMgaW4gYVxyXG5kb2N1bWVudC5cclxuKi9cclxuY2xhc3MgU2VhcmNoQ3Vyc29yIHtcclxuICAgIC8qKlxyXG4gICAgQ3JlYXRlIGEgdGV4dCBjdXJzb3IuIFRoZSBxdWVyeSBpcyB0aGUgc2VhcmNoIHN0cmluZywgYGZyb21gIHRvXHJcbiAgICBgdG9gIHByb3ZpZGVzIHRoZSByZWdpb24gdG8gc2VhcmNoLlxyXG4gICAgXHJcbiAgICBXaGVuIGBub3JtYWxpemVgIGlzIGdpdmVuLCBpdCB3aWxsIGJlIGNhbGxlZCwgb24gYm90aCB0aGUgcXVlcnlcclxuICAgIHN0cmluZyBhbmQgdGhlIGNvbnRlbnQgaXQgaXMgbWF0Y2hlZCBhZ2FpbnN0LCBiZWZvcmUgY29tcGFyaW5nLlxyXG4gICAgWW91IGNhbiwgZm9yIGV4YW1wbGUsIGNyZWF0ZSBhIGNhc2UtaW5zZW5zaXRpdmUgc2VhcmNoIGJ5XHJcbiAgICBwYXNzaW5nIGBzID0+IHMudG9Mb3dlckNhc2UoKWAuXHJcbiAgICBcclxuICAgIFRleHQgaXMgYWx3YXlzIG5vcm1hbGl6ZWQgd2l0aFxyXG4gICAgW2Aubm9ybWFsaXplKFwiTkZLRFwiKWBdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL1N0cmluZy9ub3JtYWxpemUpXHJcbiAgICAod2hlbiBzdXBwb3J0ZWQpLlxyXG4gICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKHRleHQsIHF1ZXJ5LCBmcm9tID0gMCwgdG8gPSB0ZXh0Lmxlbmd0aCwgbm9ybWFsaXplLCB0ZXN0KSB7XHJcbiAgICAgICAgdGhpcy50ZXN0ID0gdGVzdDtcclxuICAgICAgICAvKipcclxuICAgICAgICBUaGUgY3VycmVudCBtYXRjaCAob25seSBob2xkcyBhIG1lYW5pbmdmdWwgdmFsdWUgYWZ0ZXJcclxuICAgICAgICBbYG5leHRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3NlYXJjaC5TZWFyY2hDdXJzb3IubmV4dCkgaGFzIGJlZW4gY2FsbGVkIGFuZCB3aGVuXHJcbiAgICAgICAgYGRvbmVgIGlzIGZhbHNlKS5cclxuICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMudmFsdWUgPSB7IGZyb206IDAsIHRvOiAwIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgV2hldGhlciB0aGUgZW5kIG9mIHRoZSBpdGVyYXRlZCByZWdpb24gaGFzIGJlZW4gcmVhY2hlZC5cclxuICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuZG9uZSA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMubWF0Y2hlcyA9IFtdO1xyXG4gICAgICAgIHRoaXMuYnVmZmVyID0gXCJcIjtcclxuICAgICAgICB0aGlzLmJ1ZmZlclBvcyA9IDA7XHJcbiAgICAgICAgdGhpcy5pdGVyID0gdGV4dC5pdGVyUmFuZ2UoZnJvbSwgdG8pO1xyXG4gICAgICAgIHRoaXMuYnVmZmVyU3RhcnQgPSBmcm9tO1xyXG4gICAgICAgIHRoaXMubm9ybWFsaXplID0gbm9ybWFsaXplID8geCA9PiBub3JtYWxpemUoYmFzaWNOb3JtYWxpemUoeCkpIDogYmFzaWNOb3JtYWxpemU7XHJcbiAgICAgICAgdGhpcy5xdWVyeSA9IHRoaXMubm9ybWFsaXplKHF1ZXJ5KTtcclxuICAgIH1cclxuICAgIHBlZWsoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuYnVmZmVyUG9zID09IHRoaXMuYnVmZmVyLmxlbmd0aCkge1xyXG4gICAgICAgICAgICB0aGlzLmJ1ZmZlclN0YXJ0ICs9IHRoaXMuYnVmZmVyLmxlbmd0aDtcclxuICAgICAgICAgICAgdGhpcy5pdGVyLm5leHQoKTtcclxuICAgICAgICAgICAgaWYgKHRoaXMuaXRlci5kb25lKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xyXG4gICAgICAgICAgICB0aGlzLmJ1ZmZlclBvcyA9IDA7XHJcbiAgICAgICAgICAgIHRoaXMuYnVmZmVyID0gdGhpcy5pdGVyLnZhbHVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gY29kZVBvaW50QXQodGhpcy5idWZmZXIsIHRoaXMuYnVmZmVyUG9zKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgTG9vayBmb3IgdGhlIG5leHQgbWF0Y2guIFVwZGF0ZXMgdGhlIGl0ZXJhdG9yJ3NcclxuICAgIFtgdmFsdWVgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3NlYXJjaC5TZWFyY2hDdXJzb3IudmFsdWUpIGFuZFxyXG4gICAgW2Bkb25lYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzZWFyY2guU2VhcmNoQ3Vyc29yLmRvbmUpIHByb3BlcnRpZXMuIFNob3VsZCBiZSBjYWxsZWRcclxuICAgIGF0IGxlYXN0IG9uY2UgYmVmb3JlIHVzaW5nIHRoZSBjdXJzb3IuXHJcbiAgICAqL1xyXG4gICAgbmV4dCgpIHtcclxuICAgICAgICB3aGlsZSAodGhpcy5tYXRjaGVzLmxlbmd0aClcclxuICAgICAgICAgICAgdGhpcy5tYXRjaGVzLnBvcCgpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLm5leHRPdmVybGFwcGluZygpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICBUaGUgYG5leHRgIG1ldGhvZCB3aWxsIGlnbm9yZSBtYXRjaGVzIHRoYXQgcGFydGlhbGx5IG92ZXJsYXAgYVxyXG4gICAgcHJldmlvdXMgbWF0Y2guIFRoaXMgbWV0aG9kIGJlaGF2ZXMgbGlrZSBgbmV4dGAsIGJ1dCBpbmNsdWRlc1xyXG4gICAgc3VjaCBtYXRjaGVzLlxyXG4gICAgKi9cclxuICAgIG5leHRPdmVybGFwcGluZygpIHtcclxuICAgICAgICBmb3IgKDs7KSB7XHJcbiAgICAgICAgICAgIGxldCBuZXh0ID0gdGhpcy5wZWVrKCk7XHJcbiAgICAgICAgICAgIGlmIChuZXh0IDwgMCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5kb25lID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGxldCBzdHIgPSBmcm9tQ29kZVBvaW50KG5leHQpLCBzdGFydCA9IHRoaXMuYnVmZmVyU3RhcnQgKyB0aGlzLmJ1ZmZlclBvcztcclxuICAgICAgICAgICAgdGhpcy5idWZmZXJQb3MgKz0gY29kZVBvaW50U2l6ZShuZXh0KTtcclxuICAgICAgICAgICAgbGV0IG5vcm0gPSB0aGlzLm5vcm1hbGl6ZShzdHIpO1xyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMCwgcG9zID0gc3RhcnQ7OyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGxldCBjb2RlID0gbm9ybS5jaGFyQ29kZUF0KGkpO1xyXG4gICAgICAgICAgICAgICAgbGV0IG1hdGNoID0gdGhpcy5tYXRjaChjb2RlLCBwb3MpO1xyXG4gICAgICAgICAgICAgICAgaWYgKG1hdGNoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy52YWx1ZSA9IG1hdGNoO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGkgPT0gbm9ybS5sZW5ndGggLSAxKVxyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgaWYgKHBvcyA9PSBzdGFydCAmJiBpIDwgc3RyLmxlbmd0aCAmJiBzdHIuY2hhckNvZGVBdChpKSA9PSBjb2RlKVxyXG4gICAgICAgICAgICAgICAgICAgIHBvcysrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgbWF0Y2goY29kZSwgcG9zKSB7XHJcbiAgICAgICAgbGV0IG1hdGNoID0gbnVsbDtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubWF0Y2hlcy5sZW5ndGg7IGkgKz0gMikge1xyXG4gICAgICAgICAgICBsZXQgaW5kZXggPSB0aGlzLm1hdGNoZXNbaV0sIGtlZXAgPSBmYWxzZTtcclxuICAgICAgICAgICAgaWYgKHRoaXMucXVlcnkuY2hhckNvZGVBdChpbmRleCkgPT0gY29kZSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGluZGV4ID09IHRoaXMucXVlcnkubGVuZ3RoIC0gMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIG1hdGNoID0geyBmcm9tOiB0aGlzLm1hdGNoZXNbaSArIDFdLCB0bzogcG9zICsgMSB9O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tYXRjaGVzW2ldKys7XHJcbiAgICAgICAgICAgICAgICAgICAga2VlcCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKCFrZWVwKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm1hdGNoZXMuc3BsaWNlKGksIDIpO1xyXG4gICAgICAgICAgICAgICAgaSAtPSAyO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLnF1ZXJ5LmNoYXJDb2RlQXQoMCkgPT0gY29kZSkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5xdWVyeS5sZW5ndGggPT0gMSlcclxuICAgICAgICAgICAgICAgIG1hdGNoID0geyBmcm9tOiBwb3MsIHRvOiBwb3MgKyAxIH07XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgIHRoaXMubWF0Y2hlcy5wdXNoKDEsIHBvcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChtYXRjaCAmJiB0aGlzLnRlc3QgJiYgIXRoaXMudGVzdChtYXRjaC5mcm9tLCBtYXRjaC50bywgdGhpcy5idWZmZXIsIHRoaXMuYnVmZmVyUG9zKSlcclxuICAgICAgICAgICAgbWF0Y2ggPSBudWxsO1xyXG4gICAgICAgIHJldHVybiBtYXRjaDtcclxuICAgIH1cclxufVxyXG5pZiAodHlwZW9mIFN5bWJvbCAhPSBcInVuZGVmaW5lZFwiKVxyXG4gICAgU2VhcmNoQ3Vyc29yLnByb3RvdHlwZVtTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfTtcclxuXHJcbmNvbnN0IGVtcHR5ID0geyBmcm9tOiAtMSwgdG86IC0xLCBtYXRjaDogLypAX19QVVJFX18qLy8uKi8uZXhlYyhcIlwiKSB9O1xyXG5jb25zdCBiYXNlRmxhZ3MgPSBcImdtXCIgKyAoL3gvLnVuaWNvZGUgPT0gbnVsbCA/IFwiXCIgOiBcInVcIik7XHJcbi8qKlxyXG5UaGlzIGNsYXNzIGlzIHNpbWlsYXIgdG8gW2BTZWFyY2hDdXJzb3JgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3NlYXJjaC5TZWFyY2hDdXJzb3IpXHJcbmJ1dCBzZWFyY2hlcyBmb3IgYSByZWd1bGFyIGV4cHJlc3Npb24gcGF0dGVybiBpbnN0ZWFkIG9mIGEgcGxhaW5cclxuc3RyaW5nLlxyXG4qL1xyXG5jbGFzcyBSZWdFeHBDdXJzb3Ige1xyXG4gICAgLyoqXHJcbiAgICBDcmVhdGUgYSBjdXJzb3IgdGhhdCB3aWxsIHNlYXJjaCB0aGUgZ2l2ZW4gcmFuZ2UgaW4gdGhlIGdpdmVuXHJcbiAgICBkb2N1bWVudC4gYHF1ZXJ5YCBzaG91bGQgYmUgdGhlIHJhdyBwYXR0ZXJuIChhcyB5b3UnZCBwYXNzIGl0IHRvXHJcbiAgICBgbmV3IFJlZ0V4cGApLlxyXG4gICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKHRleHQsIHF1ZXJ5LCBvcHRpb25zLCBmcm9tID0gMCwgdG8gPSB0ZXh0Lmxlbmd0aCkge1xyXG4gICAgICAgIHRoaXMudGV4dCA9IHRleHQ7XHJcbiAgICAgICAgdGhpcy50byA9IHRvO1xyXG4gICAgICAgIHRoaXMuY3VyTGluZSA9IFwiXCI7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgU2V0IHRvIGB0cnVlYCB3aGVuIHRoZSBjdXJzb3IgaGFzIHJlYWNoZWQgdGhlIGVuZCBvZiB0aGUgc2VhcmNoXHJcbiAgICAgICAgcmFuZ2UuXHJcbiAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmRvbmUgPSBmYWxzZTtcclxuICAgICAgICAvKipcclxuICAgICAgICBXaWxsIGNvbnRhaW4gYW4gb2JqZWN0IHdpdGggdGhlIGV4dGVudCBvZiB0aGUgbWF0Y2ggYW5kIHRoZVxyXG4gICAgICAgIG1hdGNoIG9iamVjdCB3aGVuIFtgbmV4dGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc2VhcmNoLlJlZ0V4cEN1cnNvci5uZXh0KVxyXG4gICAgICAgIHN1Y2Vzc2Z1bGx5IGZpbmRzIGEgbWF0Y2guXHJcbiAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnZhbHVlID0gZW1wdHk7XHJcbiAgICAgICAgaWYgKC9cXFxcW3NXRG5yXXxcXG58XFxyfFxcW1xcXi8udGVzdChxdWVyeSkpXHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgTXVsdGlsaW5lUmVnRXhwQ3Vyc29yKHRleHQsIHF1ZXJ5LCBvcHRpb25zLCBmcm9tLCB0byk7XHJcbiAgICAgICAgdGhpcy5yZSA9IG5ldyBSZWdFeHAocXVlcnksIGJhc2VGbGFncyArICgob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmlnbm9yZUNhc2UpID8gXCJpXCIgOiBcIlwiKSk7XHJcbiAgICAgICAgdGhpcy50ZXN0ID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnRlc3Q7XHJcbiAgICAgICAgdGhpcy5pdGVyID0gdGV4dC5pdGVyKCk7XHJcbiAgICAgICAgbGV0IHN0YXJ0TGluZSA9IHRleHQubGluZUF0KGZyb20pO1xyXG4gICAgICAgIHRoaXMuY3VyTGluZVN0YXJ0ID0gc3RhcnRMaW5lLmZyb207XHJcbiAgICAgICAgdGhpcy5tYXRjaFBvcyA9IHRvQ2hhckVuZCh0ZXh0LCBmcm9tKTtcclxuICAgICAgICB0aGlzLmdldExpbmUodGhpcy5jdXJMaW5lU3RhcnQpO1xyXG4gICAgfVxyXG4gICAgZ2V0TGluZShza2lwKSB7XHJcbiAgICAgICAgdGhpcy5pdGVyLm5leHQoc2tpcCk7XHJcbiAgICAgICAgaWYgKHRoaXMuaXRlci5saW5lQnJlYWspIHtcclxuICAgICAgICAgICAgdGhpcy5jdXJMaW5lID0gXCJcIjtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuY3VyTGluZSA9IHRoaXMuaXRlci52YWx1ZTtcclxuICAgICAgICAgICAgaWYgKHRoaXMuY3VyTGluZVN0YXJ0ICsgdGhpcy5jdXJMaW5lLmxlbmd0aCA+IHRoaXMudG8pXHJcbiAgICAgICAgICAgICAgICB0aGlzLmN1ckxpbmUgPSB0aGlzLmN1ckxpbmUuc2xpY2UoMCwgdGhpcy50byAtIHRoaXMuY3VyTGluZVN0YXJ0KTtcclxuICAgICAgICAgICAgdGhpcy5pdGVyLm5leHQoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBuZXh0TGluZSgpIHtcclxuICAgICAgICB0aGlzLmN1ckxpbmVTdGFydCA9IHRoaXMuY3VyTGluZVN0YXJ0ICsgdGhpcy5jdXJMaW5lLmxlbmd0aCArIDE7XHJcbiAgICAgICAgaWYgKHRoaXMuY3VyTGluZVN0YXJ0ID4gdGhpcy50bylcclxuICAgICAgICAgICAgdGhpcy5jdXJMaW5lID0gXCJcIjtcclxuICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHRoaXMuZ2V0TGluZSgwKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgTW92ZSB0byB0aGUgbmV4dCBtYXRjaCwgaWYgdGhlcmUgaXMgb25lLlxyXG4gICAgKi9cclxuICAgIG5leHQoKSB7XHJcbiAgICAgICAgZm9yIChsZXQgb2ZmID0gdGhpcy5tYXRjaFBvcyAtIHRoaXMuY3VyTGluZVN0YXJ0OzspIHtcclxuICAgICAgICAgICAgdGhpcy5yZS5sYXN0SW5kZXggPSBvZmY7XHJcbiAgICAgICAgICAgIGxldCBtYXRjaCA9IHRoaXMubWF0Y2hQb3MgPD0gdGhpcy50byAmJiB0aGlzLnJlLmV4ZWModGhpcy5jdXJMaW5lKTtcclxuICAgICAgICAgICAgaWYgKG1hdGNoKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgZnJvbSA9IHRoaXMuY3VyTGluZVN0YXJ0ICsgbWF0Y2guaW5kZXgsIHRvID0gZnJvbSArIG1hdGNoWzBdLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgIHRoaXMubWF0Y2hQb3MgPSB0b0NoYXJFbmQodGhpcy50ZXh0LCB0byArIChmcm9tID09IHRvID8gMSA6IDApKTtcclxuICAgICAgICAgICAgICAgIGlmIChmcm9tID09IHRoaXMuY3VyTGluZVN0YXJ0ICsgdGhpcy5jdXJMaW5lLmxlbmd0aClcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLm5leHRMaW5lKCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoKGZyb20gPCB0byB8fCBmcm9tID4gdGhpcy52YWx1ZS50bykgJiYgKCF0aGlzLnRlc3QgfHwgdGhpcy50ZXN0KGZyb20sIHRvLCBtYXRjaCkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy52YWx1ZSA9IHsgZnJvbSwgdG8sIG1hdGNoIH07XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBvZmYgPSB0aGlzLm1hdGNoUG9zIC0gdGhpcy5jdXJMaW5lU3RhcnQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5jdXJMaW5lU3RhcnQgKyB0aGlzLmN1ckxpbmUubGVuZ3RoIDwgdGhpcy50bykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5uZXh0TGluZSgpO1xyXG4gICAgICAgICAgICAgICAgb2ZmID0gMDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZG9uZSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5jb25zdCBmbGF0dGVuZWQgPSAvKkBfX1BVUkVfXyovbmV3IFdlYWtNYXAoKTtcclxuLy8gUmV1c2FibGUgKHBhcnRpYWxseSkgZmxhdHRlbmVkIGRvY3VtZW50IHN0cmluZ3NcclxuY2xhc3MgRmxhdHRlbmVkRG9jIHtcclxuICAgIGNvbnN0cnVjdG9yKGZyb20sIHRleHQpIHtcclxuICAgICAgICB0aGlzLmZyb20gPSBmcm9tO1xyXG4gICAgICAgIHRoaXMudGV4dCA9IHRleHQ7XHJcbiAgICB9XHJcbiAgICBnZXQgdG8oKSB7IHJldHVybiB0aGlzLmZyb20gKyB0aGlzLnRleHQubGVuZ3RoOyB9XHJcbiAgICBzdGF0aWMgZ2V0KGRvYywgZnJvbSwgdG8pIHtcclxuICAgICAgICBsZXQgY2FjaGVkID0gZmxhdHRlbmVkLmdldChkb2MpO1xyXG4gICAgICAgIGlmICghY2FjaGVkIHx8IGNhY2hlZC5mcm9tID49IHRvIHx8IGNhY2hlZC50byA8PSBmcm9tKSB7XHJcbiAgICAgICAgICAgIGxldCBmbGF0ID0gbmV3IEZsYXR0ZW5lZERvYyhmcm9tLCBkb2Muc2xpY2VTdHJpbmcoZnJvbSwgdG8pKTtcclxuICAgICAgICAgICAgZmxhdHRlbmVkLnNldChkb2MsIGZsYXQpO1xyXG4gICAgICAgICAgICByZXR1cm4gZmxhdDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGNhY2hlZC5mcm9tID09IGZyb20gJiYgY2FjaGVkLnRvID09IHRvKVxyXG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkO1xyXG4gICAgICAgIGxldCB7IHRleHQsIGZyb206IGNhY2hlZEZyb20gfSA9IGNhY2hlZDtcclxuICAgICAgICBpZiAoY2FjaGVkRnJvbSA+IGZyb20pIHtcclxuICAgICAgICAgICAgdGV4dCA9IGRvYy5zbGljZVN0cmluZyhmcm9tLCBjYWNoZWRGcm9tKSArIHRleHQ7XHJcbiAgICAgICAgICAgIGNhY2hlZEZyb20gPSBmcm9tO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoY2FjaGVkLnRvIDwgdG8pXHJcbiAgICAgICAgICAgIHRleHQgKz0gZG9jLnNsaWNlU3RyaW5nKGNhY2hlZC50bywgdG8pO1xyXG4gICAgICAgIGZsYXR0ZW5lZC5zZXQoZG9jLCBuZXcgRmxhdHRlbmVkRG9jKGNhY2hlZEZyb20sIHRleHQpKTtcclxuICAgICAgICByZXR1cm4gbmV3IEZsYXR0ZW5lZERvYyhmcm9tLCB0ZXh0LnNsaWNlKGZyb20gLSBjYWNoZWRGcm9tLCB0byAtIGNhY2hlZEZyb20pKTtcclxuICAgIH1cclxufVxyXG5jbGFzcyBNdWx0aWxpbmVSZWdFeHBDdXJzb3Ige1xyXG4gICAgY29uc3RydWN0b3IodGV4dCwgcXVlcnksIG9wdGlvbnMsIGZyb20sIHRvKSB7XHJcbiAgICAgICAgdGhpcy50ZXh0ID0gdGV4dDtcclxuICAgICAgICB0aGlzLnRvID0gdG87XHJcbiAgICAgICAgdGhpcy5kb25lID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy52YWx1ZSA9IGVtcHR5O1xyXG4gICAgICAgIHRoaXMubWF0Y2hQb3MgPSB0b0NoYXJFbmQodGV4dCwgZnJvbSk7XHJcbiAgICAgICAgdGhpcy5yZSA9IG5ldyBSZWdFeHAocXVlcnksIGJhc2VGbGFncyArICgob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmlnbm9yZUNhc2UpID8gXCJpXCIgOiBcIlwiKSk7XHJcbiAgICAgICAgdGhpcy50ZXN0ID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnRlc3Q7XHJcbiAgICAgICAgdGhpcy5mbGF0ID0gRmxhdHRlbmVkRG9jLmdldCh0ZXh0LCBmcm9tLCB0aGlzLmNodW5rRW5kKGZyb20gKyA1MDAwIC8qIENodW5rLkJhc2UgKi8pKTtcclxuICAgIH1cclxuICAgIGNodW5rRW5kKHBvcykge1xyXG4gICAgICAgIHJldHVybiBwb3MgPj0gdGhpcy50byA/IHRoaXMudG8gOiB0aGlzLnRleHQubGluZUF0KHBvcykudG87XHJcbiAgICB9XHJcbiAgICBuZXh0KCkge1xyXG4gICAgICAgIGZvciAoOzspIHtcclxuICAgICAgICAgICAgbGV0IG9mZiA9IHRoaXMucmUubGFzdEluZGV4ID0gdGhpcy5tYXRjaFBvcyAtIHRoaXMuZmxhdC5mcm9tO1xyXG4gICAgICAgICAgICBsZXQgbWF0Y2ggPSB0aGlzLnJlLmV4ZWModGhpcy5mbGF0LnRleHQpO1xyXG4gICAgICAgICAgICAvLyBTa2lwIGVtcHR5IG1hdGNoZXMgZGlyZWN0bHkgYWZ0ZXIgdGhlIGxhc3QgbWF0Y2hcclxuICAgICAgICAgICAgaWYgKG1hdGNoICYmICFtYXRjaFswXSAmJiBtYXRjaC5pbmRleCA9PSBvZmYpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMucmUubGFzdEluZGV4ID0gb2ZmICsgMTtcclxuICAgICAgICAgICAgICAgIG1hdGNoID0gdGhpcy5yZS5leGVjKHRoaXMuZmxhdC50ZXh0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAobWF0Y2gpIHtcclxuICAgICAgICAgICAgICAgIGxldCBmcm9tID0gdGhpcy5mbGF0LmZyb20gKyBtYXRjaC5pbmRleCwgdG8gPSBmcm9tICsgbWF0Y2hbMF0ubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgLy8gSWYgYSBtYXRjaCBnb2VzIGFsbW9zdCB0byB0aGUgZW5kIG9mIGEgbm9uY29tcGxldGUgY2h1bmssIHRyeVxyXG4gICAgICAgICAgICAgICAgLy8gYWdhaW4sIHNpbmNlIGl0J2xsIGxpa2VseSBiZSBhYmxlIHRvIG1hdGNoIG1vcmVcclxuICAgICAgICAgICAgICAgIGlmICgodGhpcy5mbGF0LnRvID49IHRoaXMudG8gfHwgbWF0Y2guaW5kZXggKyBtYXRjaFswXS5sZW5ndGggPD0gdGhpcy5mbGF0LnRleHQubGVuZ3RoIC0gMTApICYmXHJcbiAgICAgICAgICAgICAgICAgICAgKCF0aGlzLnRlc3QgfHwgdGhpcy50ZXN0KGZyb20sIHRvLCBtYXRjaCkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy52YWx1ZSA9IHsgZnJvbSwgdG8sIG1hdGNoIH07XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tYXRjaFBvcyA9IHRvQ2hhckVuZCh0aGlzLnRleHQsIHRvICsgKGZyb20gPT0gdG8gPyAxIDogMCkpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmZsYXQudG8gPT0gdGhpcy50bykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5kb25lID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIEdyb3cgdGhlIGZsYXR0ZW5lZCBkb2NcclxuICAgICAgICAgICAgdGhpcy5mbGF0ID0gRmxhdHRlbmVkRG9jLmdldCh0aGlzLnRleHQsIHRoaXMuZmxhdC5mcm9tLCB0aGlzLmNodW5rRW5kKHRoaXMuZmxhdC5mcm9tICsgdGhpcy5mbGF0LnRleHQubGVuZ3RoICogMikpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5pZiAodHlwZW9mIFN5bWJvbCAhPSBcInVuZGVmaW5lZFwiKSB7XHJcbiAgICBSZWdFeHBDdXJzb3IucHJvdG90eXBlW1N5bWJvbC5pdGVyYXRvcl0gPSBNdWx0aWxpbmVSZWdFeHBDdXJzb3IucHJvdG90eXBlW1N5bWJvbC5pdGVyYXRvcl0gPVxyXG4gICAgICAgIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH07XHJcbn1cclxuZnVuY3Rpb24gdmFsaWRSZWdFeHAoc291cmNlKSB7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIG5ldyBSZWdFeHAoc291cmNlLCBiYXNlRmxhZ3MpO1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gICAgY2F0Y2ggKF9hKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIHRvQ2hhckVuZCh0ZXh0LCBwb3MpIHtcclxuICAgIGlmIChwb3MgPj0gdGV4dC5sZW5ndGgpXHJcbiAgICAgICAgcmV0dXJuIHBvcztcclxuICAgIGxldCBsaW5lID0gdGV4dC5saW5lQXQocG9zKSwgbmV4dDtcclxuICAgIHdoaWxlIChwb3MgPCBsaW5lLnRvICYmIChuZXh0ID0gbGluZS50ZXh0LmNoYXJDb2RlQXQocG9zIC0gbGluZS5mcm9tKSkgPj0gMHhEQzAwICYmIG5leHQgPCAweEUwMDApXHJcbiAgICAgICAgcG9zKys7XHJcbiAgICByZXR1cm4gcG9zO1xyXG59XHJcblxyXG5mdW5jdGlvbiBjcmVhdGVMaW5lRGlhbG9nKHZpZXcpIHtcclxuICAgIGxldCBpbnB1dCA9IGVsdChcImlucHV0XCIsIHsgY2xhc3M6IFwiY20tdGV4dGZpZWxkXCIsIG5hbWU6IFwibGluZVwiIH0pO1xyXG4gICAgbGV0IGRvbSA9IGVsdChcImZvcm1cIiwge1xyXG4gICAgICAgIGNsYXNzOiBcImNtLWdvdG9MaW5lXCIsXHJcbiAgICAgICAgb25rZXlkb3duOiAoZXZlbnQpID0+IHtcclxuICAgICAgICAgICAgaWYgKGV2ZW50LmtleUNvZGUgPT0gMjcpIHsgLy8gRXNjYXBlXHJcbiAgICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgICAgICAgICAgdmlldy5kaXNwYXRjaCh7IGVmZmVjdHM6IGRpYWxvZ0VmZmVjdC5vZihmYWxzZSkgfSk7XHJcbiAgICAgICAgICAgICAgICB2aWV3LmZvY3VzKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoZXZlbnQua2V5Q29kZSA9PSAxMykgeyAvLyBFbnRlclxyXG4gICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICAgICAgICAgIGdvKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIG9uc3VibWl0OiAoZXZlbnQpID0+IHtcclxuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICAgICAgZ28oKTtcclxuICAgICAgICB9XHJcbiAgICB9LCBlbHQoXCJsYWJlbFwiLCB2aWV3LnN0YXRlLnBocmFzZShcIkdvIHRvIGxpbmVcIiksIFwiOiBcIiwgaW5wdXQpLCBcIiBcIiwgZWx0KFwiYnV0dG9uXCIsIHsgY2xhc3M6IFwiY20tYnV0dG9uXCIsIHR5cGU6IFwic3VibWl0XCIgfSwgdmlldy5zdGF0ZS5waHJhc2UoXCJnb1wiKSkpO1xyXG4gICAgZnVuY3Rpb24gZ28oKSB7XHJcbiAgICAgICAgbGV0IG1hdGNoID0gL14oWystXSk/KFxcZCspPyg6XFxkKyk/KCUpPyQvLmV4ZWMoaW5wdXQudmFsdWUpO1xyXG4gICAgICAgIGlmICghbWF0Y2gpXHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICBsZXQgeyBzdGF0ZSB9ID0gdmlldywgc3RhcnRMaW5lID0gc3RhdGUuZG9jLmxpbmVBdChzdGF0ZS5zZWxlY3Rpb24ubWFpbi5oZWFkKTtcclxuICAgICAgICBsZXQgWywgc2lnbiwgbG4sIGNsLCBwZXJjZW50XSA9IG1hdGNoO1xyXG4gICAgICAgIGxldCBjb2wgPSBjbCA/ICtjbC5zbGljZSgxKSA6IDA7XHJcbiAgICAgICAgbGV0IGxpbmUgPSBsbiA/ICtsbiA6IHN0YXJ0TGluZS5udW1iZXI7XHJcbiAgICAgICAgaWYgKGxuICYmIHBlcmNlbnQpIHtcclxuICAgICAgICAgICAgbGV0IHBjID0gbGluZSAvIDEwMDtcclxuICAgICAgICAgICAgaWYgKHNpZ24pXHJcbiAgICAgICAgICAgICAgICBwYyA9IHBjICogKHNpZ24gPT0gXCItXCIgPyAtMSA6IDEpICsgKHN0YXJ0TGluZS5udW1iZXIgLyBzdGF0ZS5kb2MubGluZXMpO1xyXG4gICAgICAgICAgICBsaW5lID0gTWF0aC5yb3VuZChzdGF0ZS5kb2MubGluZXMgKiBwYyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGxuICYmIHNpZ24pIHtcclxuICAgICAgICAgICAgbGluZSA9IGxpbmUgKiAoc2lnbiA9PSBcIi1cIiA/IC0xIDogMSkgKyBzdGFydExpbmUubnVtYmVyO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgZG9jTGluZSA9IHN0YXRlLmRvYy5saW5lKE1hdGgubWF4KDEsIE1hdGgubWluKHN0YXRlLmRvYy5saW5lcywgbGluZSkpKTtcclxuICAgICAgICB2aWV3LmRpc3BhdGNoKHtcclxuICAgICAgICAgICAgZWZmZWN0czogZGlhbG9nRWZmZWN0Lm9mKGZhbHNlKSxcclxuICAgICAgICAgICAgc2VsZWN0aW9uOiBFZGl0b3JTZWxlY3Rpb24uY3Vyc29yKGRvY0xpbmUuZnJvbSArIE1hdGgubWF4KDAsIE1hdGgubWluKGNvbCwgZG9jTGluZS5sZW5ndGgpKSksXHJcbiAgICAgICAgICAgIHNjcm9sbEludG9WaWV3OiB0cnVlXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdmlldy5mb2N1cygpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHsgZG9tIH07XHJcbn1cclxuY29uc3QgZGlhbG9nRWZmZWN0ID0gLypAX19QVVJFX18qL1N0YXRlRWZmZWN0LmRlZmluZSgpO1xyXG5jb25zdCBkaWFsb2dGaWVsZCA9IC8qQF9fUFVSRV9fKi9TdGF0ZUZpZWxkLmRlZmluZSh7XHJcbiAgICBjcmVhdGUoKSB7IHJldHVybiB0cnVlOyB9LFxyXG4gICAgdXBkYXRlKHZhbHVlLCB0cikge1xyXG4gICAgICAgIGZvciAobGV0IGUgb2YgdHIuZWZmZWN0cylcclxuICAgICAgICAgICAgaWYgKGUuaXMoZGlhbG9nRWZmZWN0KSlcclxuICAgICAgICAgICAgICAgIHZhbHVlID0gZS52YWx1ZTtcclxuICAgICAgICByZXR1cm4gdmFsdWU7XHJcbiAgICB9LFxyXG4gICAgcHJvdmlkZTogZiA9PiBzaG93UGFuZWwuZnJvbShmLCB2YWwgPT4gdmFsID8gY3JlYXRlTGluZURpYWxvZyA6IG51bGwpXHJcbn0pO1xyXG4vKipcclxuQ29tbWFuZCB0aGF0IHNob3dzIGEgZGlhbG9nIGFza2luZyB0aGUgdXNlciBmb3IgYSBsaW5lIG51bWJlciwgYW5kXHJcbndoZW4gYSB2YWxpZCBwb3NpdGlvbiBpcyBwcm92aWRlZCwgbW92ZXMgdGhlIGN1cnNvciB0byB0aGF0IGxpbmUuXHJcblxyXG5TdXBwb3J0cyBsaW5lIG51bWJlcnMsIHJlbGF0aXZlIGxpbmUgb2Zmc2V0cyBwcmVmaXhlZCB3aXRoIGArYCBvclxyXG5gLWAsIGRvY3VtZW50IHBlcmNlbnRhZ2VzIHN1ZmZpeGVkIHdpdGggYCVgLCBhbmQgYW4gb3B0aW9uYWxcclxuY29sdW1uIHBvc2l0aW9uIGJ5IGFkZGluZyBgOmAgYW5kIGEgc2Vjb25kIG51bWJlciBhZnRlciB0aGUgbGluZVxyXG5udW1iZXIuXHJcblxyXG5UaGUgZGlhbG9nIGNhbiBiZSBzdHlsZWQgd2l0aCB0aGUgYHBhbmVsLmdvdG9MaW5lYCB0aGVtZVxyXG5zZWxlY3Rvci5cclxuKi9cclxuY29uc3QgZ290b0xpbmUgPSB2aWV3ID0+IHtcclxuICAgIGxldCBwYW5lbCA9IGdldFBhbmVsKHZpZXcsIGNyZWF0ZUxpbmVEaWFsb2cpO1xyXG4gICAgaWYgKCFwYW5lbCkge1xyXG4gICAgICAgIGxldCBlZmZlY3RzID0gW2RpYWxvZ0VmZmVjdC5vZih0cnVlKV07XHJcbiAgICAgICAgaWYgKHZpZXcuc3RhdGUuZmllbGQoZGlhbG9nRmllbGQsIGZhbHNlKSA9PSBudWxsKVxyXG4gICAgICAgICAgICBlZmZlY3RzLnB1c2goU3RhdGVFZmZlY3QuYXBwZW5kQ29uZmlnLm9mKFtkaWFsb2dGaWVsZCwgYmFzZVRoZW1lJDFdKSk7XHJcbiAgICAgICAgdmlldy5kaXNwYXRjaCh7IGVmZmVjdHMgfSk7XHJcbiAgICAgICAgcGFuZWwgPSBnZXRQYW5lbCh2aWV3LCBjcmVhdGVMaW5lRGlhbG9nKTtcclxuICAgIH1cclxuICAgIGlmIChwYW5lbClcclxuICAgICAgICBwYW5lbC5kb20ucXVlcnlTZWxlY3RvcihcImlucHV0XCIpLmZvY3VzKCk7XHJcbiAgICByZXR1cm4gdHJ1ZTtcclxufTtcclxuY29uc3QgYmFzZVRoZW1lJDEgPSAvKkBfX1BVUkVfXyovRWRpdG9yVmlldy5iYXNlVGhlbWUoe1xyXG4gICAgXCIuY20tcGFuZWwuY20tZ290b0xpbmVcIjoge1xyXG4gICAgICAgIHBhZGRpbmc6IFwiMnB4IDZweCA0cHhcIixcclxuICAgICAgICBcIiYgbGFiZWxcIjogeyBmb250U2l6ZTogXCI4MCVcIiB9XHJcbiAgICB9XHJcbn0pO1xyXG5cclxuY29uc3QgZGVmYXVsdEhpZ2hsaWdodE9wdGlvbnMgPSB7XHJcbiAgICBoaWdobGlnaHRXb3JkQXJvdW5kQ3Vyc29yOiBmYWxzZSxcclxuICAgIG1pblNlbGVjdGlvbkxlbmd0aDogMSxcclxuICAgIG1heE1hdGNoZXM6IDEwMCxcclxuICAgIHdob2xlV29yZHM6IGZhbHNlXHJcbn07XHJcbmNvbnN0IGhpZ2hsaWdodENvbmZpZyA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoe1xyXG4gICAgY29tYmluZShvcHRpb25zKSB7XHJcbiAgICAgICAgcmV0dXJuIGNvbWJpbmVDb25maWcob3B0aW9ucywgZGVmYXVsdEhpZ2hsaWdodE9wdGlvbnMsIHtcclxuICAgICAgICAgICAgaGlnaGxpZ2h0V29yZEFyb3VuZEN1cnNvcjogKGEsIGIpID0+IGEgfHwgYixcclxuICAgICAgICAgICAgbWluU2VsZWN0aW9uTGVuZ3RoOiBNYXRoLm1pbixcclxuICAgICAgICAgICAgbWF4TWF0Y2hlczogTWF0aC5taW5cclxuICAgICAgICB9KTtcclxuICAgIH1cclxufSk7XHJcbi8qKlxyXG5UaGlzIGV4dGVuc2lvbiBoaWdobGlnaHRzIHRleHQgdGhhdCBtYXRjaGVzIHRoZSBzZWxlY3Rpb24uIEl0IHVzZXNcclxudGhlIGBcImNtLXNlbGVjdGlvbk1hdGNoXCJgIGNsYXNzIGZvciB0aGUgaGlnaGxpZ2h0aW5nLiBXaGVuXHJcbmBoaWdobGlnaHRXb3JkQXJvdW5kQ3Vyc29yYCBpcyBlbmFibGVkLCB0aGUgd29yZCBhdCB0aGUgY3Vyc29yXHJcbml0c2VsZiB3aWxsIGJlIGhpZ2hsaWdodGVkIHdpdGggYFwiY20tc2VsZWN0aW9uTWF0Y2gtbWFpblwiYC5cclxuKi9cclxuZnVuY3Rpb24gaGlnaGxpZ2h0U2VsZWN0aW9uTWF0Y2hlcyhvcHRpb25zKSB7XHJcbiAgICBsZXQgZXh0ID0gW2RlZmF1bHRUaGVtZSwgbWF0Y2hIaWdobGlnaHRlcl07XHJcbiAgICBpZiAob3B0aW9ucylcclxuICAgICAgICBleHQucHVzaChoaWdobGlnaHRDb25maWcub2Yob3B0aW9ucykpO1xyXG4gICAgcmV0dXJuIGV4dDtcclxufVxyXG5jb25zdCBtYXRjaERlY28gPSAvKkBfX1BVUkVfXyovRGVjb3JhdGlvbi5tYXJrKHsgY2xhc3M6IFwiY20tc2VsZWN0aW9uTWF0Y2hcIiB9KTtcclxuY29uc3QgbWFpbk1hdGNoRGVjbyA9IC8qQF9fUFVSRV9fKi9EZWNvcmF0aW9uLm1hcmsoeyBjbGFzczogXCJjbS1zZWxlY3Rpb25NYXRjaCBjbS1zZWxlY3Rpb25NYXRjaC1tYWluXCIgfSk7XHJcbi8vIFdoZXRoZXIgdGhlIGNoYXJhY3RlcnMgZGlyZWN0bHkgb3V0c2lkZSB0aGUgZ2l2ZW4gcG9zaXRpb25zIGFyZSBub24td29yZCBjaGFyYWN0ZXJzXHJcbmZ1bmN0aW9uIGluc2lkZVdvcmRCb3VuZGFyaWVzKGNoZWNrLCBzdGF0ZSwgZnJvbSwgdG8pIHtcclxuICAgIHJldHVybiAoZnJvbSA9PSAwIHx8IGNoZWNrKHN0YXRlLnNsaWNlRG9jKGZyb20gLSAxLCBmcm9tKSkgIT0gQ2hhckNhdGVnb3J5LldvcmQpICYmXHJcbiAgICAgICAgKHRvID09IHN0YXRlLmRvYy5sZW5ndGggfHwgY2hlY2soc3RhdGUuc2xpY2VEb2ModG8sIHRvICsgMSkpICE9IENoYXJDYXRlZ29yeS5Xb3JkKTtcclxufVxyXG4vLyBXaGV0aGVyIHRoZSBjaGFyYWN0ZXJzIGRpcmVjdGx5IGF0IHRoZSBnaXZlbiBwb3NpdGlvbnMgYXJlIHdvcmQgY2hhcmFjdGVyc1xyXG5mdW5jdGlvbiBpbnNpZGVXb3JkKGNoZWNrLCBzdGF0ZSwgZnJvbSwgdG8pIHtcclxuICAgIHJldHVybiBjaGVjayhzdGF0ZS5zbGljZURvYyhmcm9tLCBmcm9tICsgMSkpID09IENoYXJDYXRlZ29yeS5Xb3JkXHJcbiAgICAgICAgJiYgY2hlY2soc3RhdGUuc2xpY2VEb2ModG8gLSAxLCB0bykpID09IENoYXJDYXRlZ29yeS5Xb3JkO1xyXG59XHJcbmNvbnN0IG1hdGNoSGlnaGxpZ2h0ZXIgPSAvKkBfX1BVUkVfXyovVmlld1BsdWdpbi5mcm9tQ2xhc3MoY2xhc3Mge1xyXG4gICAgY29uc3RydWN0b3Iodmlldykge1xyXG4gICAgICAgIHRoaXMuZGVjb3JhdGlvbnMgPSB0aGlzLmdldERlY28odmlldyk7XHJcbiAgICB9XHJcbiAgICB1cGRhdGUodXBkYXRlKSB7XHJcbiAgICAgICAgaWYgKHVwZGF0ZS5zZWxlY3Rpb25TZXQgfHwgdXBkYXRlLmRvY0NoYW5nZWQgfHwgdXBkYXRlLnZpZXdwb3J0Q2hhbmdlZClcclxuICAgICAgICAgICAgdGhpcy5kZWNvcmF0aW9ucyA9IHRoaXMuZ2V0RGVjbyh1cGRhdGUudmlldyk7XHJcbiAgICB9XHJcbiAgICBnZXREZWNvKHZpZXcpIHtcclxuICAgICAgICBsZXQgY29uZiA9IHZpZXcuc3RhdGUuZmFjZXQoaGlnaGxpZ2h0Q29uZmlnKTtcclxuICAgICAgICBsZXQgeyBzdGF0ZSB9ID0gdmlldywgc2VsID0gc3RhdGUuc2VsZWN0aW9uO1xyXG4gICAgICAgIGlmIChzZWwucmFuZ2VzLmxlbmd0aCA+IDEpXHJcbiAgICAgICAgICAgIHJldHVybiBEZWNvcmF0aW9uLm5vbmU7XHJcbiAgICAgICAgbGV0IHJhbmdlID0gc2VsLm1haW4sIHF1ZXJ5LCBjaGVjayA9IG51bGw7XHJcbiAgICAgICAgaWYgKHJhbmdlLmVtcHR5KSB7XHJcbiAgICAgICAgICAgIGlmICghY29uZi5oaWdobGlnaHRXb3JkQXJvdW5kQ3Vyc29yKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIERlY29yYXRpb24ubm9uZTtcclxuICAgICAgICAgICAgbGV0IHdvcmQgPSBzdGF0ZS53b3JkQXQocmFuZ2UuaGVhZCk7XHJcbiAgICAgICAgICAgIGlmICghd29yZClcclxuICAgICAgICAgICAgICAgIHJldHVybiBEZWNvcmF0aW9uLm5vbmU7XHJcbiAgICAgICAgICAgIGNoZWNrID0gc3RhdGUuY2hhckNhdGVnb3JpemVyKHJhbmdlLmhlYWQpO1xyXG4gICAgICAgICAgICBxdWVyeSA9IHN0YXRlLnNsaWNlRG9jKHdvcmQuZnJvbSwgd29yZC50byk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBsZXQgbGVuID0gcmFuZ2UudG8gLSByYW5nZS5mcm9tO1xyXG4gICAgICAgICAgICBpZiAobGVuIDwgY29uZi5taW5TZWxlY3Rpb25MZW5ndGggfHwgbGVuID4gMjAwKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIERlY29yYXRpb24ubm9uZTtcclxuICAgICAgICAgICAgaWYgKGNvbmYud2hvbGVXb3Jkcykge1xyXG4gICAgICAgICAgICAgICAgcXVlcnkgPSBzdGF0ZS5zbGljZURvYyhyYW5nZS5mcm9tLCByYW5nZS50byk7IC8vIFRPRE86IGFsbG93IGFuZCBpbmNsdWRlIGxlYWRpbmcvdHJhaWxpbmcgc3BhY2U/XHJcbiAgICAgICAgICAgICAgICBjaGVjayA9IHN0YXRlLmNoYXJDYXRlZ29yaXplcihyYW5nZS5oZWFkKTtcclxuICAgICAgICAgICAgICAgIGlmICghKGluc2lkZVdvcmRCb3VuZGFyaWVzKGNoZWNrLCBzdGF0ZSwgcmFuZ2UuZnJvbSwgcmFuZ2UudG8pXHJcbiAgICAgICAgICAgICAgICAgICAgJiYgaW5zaWRlV29yZChjaGVjaywgc3RhdGUsIHJhbmdlLmZyb20sIHJhbmdlLnRvKSkpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIERlY29yYXRpb24ubm9uZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHF1ZXJ5ID0gc3RhdGUuc2xpY2VEb2MocmFuZ2UuZnJvbSwgcmFuZ2UudG8pLnRyaW0oKTtcclxuICAgICAgICAgICAgICAgIGlmICghcXVlcnkpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIERlY29yYXRpb24ubm9uZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgZGVjbyA9IFtdO1xyXG4gICAgICAgIGZvciAobGV0IHBhcnQgb2Ygdmlldy52aXNpYmxlUmFuZ2VzKSB7XHJcbiAgICAgICAgICAgIGxldCBjdXJzb3IgPSBuZXcgU2VhcmNoQ3Vyc29yKHN0YXRlLmRvYywgcXVlcnksIHBhcnQuZnJvbSwgcGFydC50byk7XHJcbiAgICAgICAgICAgIHdoaWxlICghY3Vyc29yLm5leHQoKS5kb25lKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgeyBmcm9tLCB0byB9ID0gY3Vyc29yLnZhbHVlO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFjaGVjayB8fCBpbnNpZGVXb3JkQm91bmRhcmllcyhjaGVjaywgc3RhdGUsIGZyb20sIHRvKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChyYW5nZS5lbXB0eSAmJiBmcm9tIDw9IHJhbmdlLmZyb20gJiYgdG8gPj0gcmFuZ2UudG8pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlY28ucHVzaChtYWluTWF0Y2hEZWNvLnJhbmdlKGZyb20sIHRvKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoZnJvbSA+PSByYW5nZS50byB8fCB0byA8PSByYW5nZS5mcm9tKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWNvLnB1c2gobWF0Y2hEZWNvLnJhbmdlKGZyb20sIHRvKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRlY28ubGVuZ3RoID4gY29uZi5tYXhNYXRjaGVzKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gRGVjb3JhdGlvbi5ub25lO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBEZWNvcmF0aW9uLnNldChkZWNvKTtcclxuICAgIH1cclxufSwge1xyXG4gICAgZGVjb3JhdGlvbnM6IHYgPT4gdi5kZWNvcmF0aW9uc1xyXG59KTtcclxuY29uc3QgZGVmYXVsdFRoZW1lID0gLypAX19QVVJFX18qL0VkaXRvclZpZXcuYmFzZVRoZW1lKHtcclxuICAgIFwiLmNtLXNlbGVjdGlvbk1hdGNoXCI6IHsgYmFja2dyb3VuZENvbG9yOiBcIiM5OWZmNzc4MFwiIH0sXHJcbiAgICBcIi5jbS1zZWFyY2hNYXRjaCAuY20tc2VsZWN0aW9uTWF0Y2hcIjogeyBiYWNrZ3JvdW5kQ29sb3I6IFwidHJhbnNwYXJlbnRcIiB9XHJcbn0pO1xyXG4vLyBTZWxlY3QgdGhlIHdvcmRzIGFyb3VuZCB0aGUgY3Vyc29ycy5cclxuY29uc3Qgc2VsZWN0V29yZCA9ICh7IHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB7XHJcbiAgICBsZXQgeyBzZWxlY3Rpb24gfSA9IHN0YXRlO1xyXG4gICAgbGV0IG5ld1NlbCA9IEVkaXRvclNlbGVjdGlvbi5jcmVhdGUoc2VsZWN0aW9uLnJhbmdlcy5tYXAocmFuZ2UgPT4gc3RhdGUud29yZEF0KHJhbmdlLmhlYWQpIHx8IEVkaXRvclNlbGVjdGlvbi5jdXJzb3IocmFuZ2UuaGVhZCkpLCBzZWxlY3Rpb24ubWFpbkluZGV4KTtcclxuICAgIGlmIChuZXdTZWwuZXEoc2VsZWN0aW9uKSlcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICBkaXNwYXRjaChzdGF0ZS51cGRhdGUoeyBzZWxlY3Rpb246IG5ld1NlbCB9KSk7XHJcbiAgICByZXR1cm4gdHJ1ZTtcclxufTtcclxuLy8gRmluZCBuZXh0IG9jY3VycmVuY2Ugb2YgcXVlcnkgcmVsYXRpdmUgdG8gbGFzdCBjdXJzb3IuIFdyYXAgYXJvdW5kXHJcbi8vIHRoZSBkb2N1bWVudCBpZiB0aGVyZSBhcmUgbm8gbW9yZSBtYXRjaGVzLlxyXG5mdW5jdGlvbiBmaW5kTmV4dE9jY3VycmVuY2Uoc3RhdGUsIHF1ZXJ5KSB7XHJcbiAgICBsZXQgeyBtYWluLCByYW5nZXMgfSA9IHN0YXRlLnNlbGVjdGlvbjtcclxuICAgIGxldCB3b3JkID0gc3RhdGUud29yZEF0KG1haW4uaGVhZCksIGZ1bGxXb3JkID0gd29yZCAmJiB3b3JkLmZyb20gPT0gbWFpbi5mcm9tICYmIHdvcmQudG8gPT0gbWFpbi50bztcclxuICAgIGZvciAobGV0IGN5Y2xlZCA9IGZhbHNlLCBjdXJzb3IgPSBuZXcgU2VhcmNoQ3Vyc29yKHN0YXRlLmRvYywgcXVlcnksIHJhbmdlc1tyYW5nZXMubGVuZ3RoIC0gMV0udG8pOzspIHtcclxuICAgICAgICBjdXJzb3IubmV4dCgpO1xyXG4gICAgICAgIGlmIChjdXJzb3IuZG9uZSkge1xyXG4gICAgICAgICAgICBpZiAoY3ljbGVkKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgIGN1cnNvciA9IG5ldyBTZWFyY2hDdXJzb3Ioc3RhdGUuZG9jLCBxdWVyeSwgMCwgTWF0aC5tYXgoMCwgcmFuZ2VzW3Jhbmdlcy5sZW5ndGggLSAxXS5mcm9tIC0gMSkpO1xyXG4gICAgICAgICAgICBjeWNsZWQgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgaWYgKGN5Y2xlZCAmJiByYW5nZXMuc29tZShyID0+IHIuZnJvbSA9PSBjdXJzb3IudmFsdWUuZnJvbSkpXHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgaWYgKGZ1bGxXb3JkKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgd29yZCA9IHN0YXRlLndvcmRBdChjdXJzb3IudmFsdWUuZnJvbSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoIXdvcmQgfHwgd29yZC5mcm9tICE9IGN1cnNvci52YWx1ZS5mcm9tIHx8IHdvcmQudG8gIT0gY3Vyc29yLnZhbHVlLnRvKVxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBjdXJzb3IudmFsdWU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbi8qKlxyXG5TZWxlY3QgbmV4dCBvY2N1cnJlbmNlIG9mIHRoZSBjdXJyZW50IHNlbGVjdGlvbi4gRXhwYW5kIHNlbGVjdGlvblxyXG50byB0aGUgc3Vycm91bmRpbmcgd29yZCB3aGVuIHRoZSBzZWxlY3Rpb24gaXMgZW1wdHkuXHJcbiovXHJcbmNvbnN0IHNlbGVjdE5leHRPY2N1cnJlbmNlID0gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcclxuICAgIGxldCB7IHJhbmdlcyB9ID0gc3RhdGUuc2VsZWN0aW9uO1xyXG4gICAgaWYgKHJhbmdlcy5zb21lKHNlbCA9PiBzZWwuZnJvbSA9PT0gc2VsLnRvKSlcclxuICAgICAgICByZXR1cm4gc2VsZWN0V29yZCh7IHN0YXRlLCBkaXNwYXRjaCB9KTtcclxuICAgIGxldCBzZWFyY2hlZFRleHQgPSBzdGF0ZS5zbGljZURvYyhyYW5nZXNbMF0uZnJvbSwgcmFuZ2VzWzBdLnRvKTtcclxuICAgIGlmIChzdGF0ZS5zZWxlY3Rpb24ucmFuZ2VzLnNvbWUociA9PiBzdGF0ZS5zbGljZURvYyhyLmZyb20sIHIudG8pICE9IHNlYXJjaGVkVGV4dCkpXHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgbGV0IHJhbmdlID0gZmluZE5leHRPY2N1cnJlbmNlKHN0YXRlLCBzZWFyY2hlZFRleHQpO1xyXG4gICAgaWYgKCFyYW5nZSlcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICBkaXNwYXRjaChzdGF0ZS51cGRhdGUoe1xyXG4gICAgICAgIHNlbGVjdGlvbjogc3RhdGUuc2VsZWN0aW9uLmFkZFJhbmdlKEVkaXRvclNlbGVjdGlvbi5yYW5nZShyYW5nZS5mcm9tLCByYW5nZS50byksIGZhbHNlKSxcclxuICAgICAgICBlZmZlY3RzOiBFZGl0b3JWaWV3LnNjcm9sbEludG9WaWV3KHJhbmdlLnRvKVxyXG4gICAgfSkpO1xyXG4gICAgcmV0dXJuIHRydWU7XHJcbn07XHJcblxyXG5jb25zdCBzZWFyY2hDb25maWdGYWNldCA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoe1xyXG4gICAgY29tYmluZShjb25maWdzKSB7XHJcbiAgICAgICAgcmV0dXJuIGNvbWJpbmVDb25maWcoY29uZmlncywge1xyXG4gICAgICAgICAgICB0b3A6IGZhbHNlLFxyXG4gICAgICAgICAgICBjYXNlU2Vuc2l0aXZlOiBmYWxzZSxcclxuICAgICAgICAgICAgbGl0ZXJhbDogZmFsc2UsXHJcbiAgICAgICAgICAgIHdob2xlV29yZDogZmFsc2UsXHJcbiAgICAgICAgICAgIGNyZWF0ZVBhbmVsOiB2aWV3ID0+IG5ldyBTZWFyY2hQYW5lbCh2aWV3KVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG59KTtcclxuLyoqXHJcbkFkZCBzZWFyY2ggc3RhdGUgdG8gdGhlIGVkaXRvciBjb25maWd1cmF0aW9uLCBhbmQgb3B0aW9uYWxseVxyXG5jb25maWd1cmUgdGhlIHNlYXJjaCBleHRlbnNpb24uXHJcbihbYG9wZW5TZWFyY2hQYW5lbGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc2VhcmNoLm9wZW5TZWFyY2hQYW5lbCkgd2lsbCBhdXRvbWF0aWNhbGx5XHJcbmVuYWJsZSB0aGlzIGlmIGl0IGlzbid0IGFscmVhZHkgb24pLlxyXG4qL1xyXG5mdW5jdGlvbiBzZWFyY2goY29uZmlnKSB7XHJcbiAgICByZXR1cm4gY29uZmlnID8gW3NlYXJjaENvbmZpZ0ZhY2V0Lm9mKGNvbmZpZyksIHNlYXJjaEV4dGVuc2lvbnNdIDogc2VhcmNoRXh0ZW5zaW9ucztcclxufVxyXG4vKipcclxuQSBzZWFyY2ggcXVlcnkuIFBhcnQgb2YgdGhlIGVkaXRvcidzIHNlYXJjaCBzdGF0ZS5cclxuKi9cclxuY2xhc3MgU2VhcmNoUXVlcnkge1xyXG4gICAgLyoqXHJcbiAgICBDcmVhdGUgYSBxdWVyeSBvYmplY3QuXHJcbiAgICAqL1xyXG4gICAgY29uc3RydWN0b3IoY29uZmlnKSB7XHJcbiAgICAgICAgdGhpcy5zZWFyY2ggPSBjb25maWcuc2VhcmNoO1xyXG4gICAgICAgIHRoaXMuY2FzZVNlbnNpdGl2ZSA9ICEhY29uZmlnLmNhc2VTZW5zaXRpdmU7XHJcbiAgICAgICAgdGhpcy5saXRlcmFsID0gISFjb25maWcubGl0ZXJhbDtcclxuICAgICAgICB0aGlzLnJlZ2V4cCA9ICEhY29uZmlnLnJlZ2V4cDtcclxuICAgICAgICB0aGlzLnJlcGxhY2UgPSBjb25maWcucmVwbGFjZSB8fCBcIlwiO1xyXG4gICAgICAgIHRoaXMudmFsaWQgPSAhIXRoaXMuc2VhcmNoICYmICghdGhpcy5yZWdleHAgfHwgdmFsaWRSZWdFeHAodGhpcy5zZWFyY2gpKTtcclxuICAgICAgICB0aGlzLnVucXVvdGVkID0gdGhpcy51bnF1b3RlKHRoaXMuc2VhcmNoKTtcclxuICAgICAgICB0aGlzLndob2xlV29yZCA9ICEhY29uZmlnLndob2xlV29yZDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgQGludGVybmFsXHJcbiAgICAqL1xyXG4gICAgdW5xdW90ZSh0ZXh0KSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubGl0ZXJhbCA/IHRleHQgOlxyXG4gICAgICAgICAgICB0ZXh0LnJlcGxhY2UoL1xcXFwoW25ydFxcXFxdKS9nLCAoXywgY2gpID0+IGNoID09IFwiblwiID8gXCJcXG5cIiA6IGNoID09IFwiclwiID8gXCJcXHJcIiA6IGNoID09IFwidFwiID8gXCJcXHRcIiA6IFwiXFxcXFwiKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgQ29tcGFyZSB0aGlzIHF1ZXJ5IHRvIGFub3RoZXIgcXVlcnkuXHJcbiAgICAqL1xyXG4gICAgZXEob3RoZXIpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5zZWFyY2ggPT0gb3RoZXIuc2VhcmNoICYmIHRoaXMucmVwbGFjZSA9PSBvdGhlci5yZXBsYWNlICYmXHJcbiAgICAgICAgICAgIHRoaXMuY2FzZVNlbnNpdGl2ZSA9PSBvdGhlci5jYXNlU2Vuc2l0aXZlICYmIHRoaXMucmVnZXhwID09IG90aGVyLnJlZ2V4cCAmJlxyXG4gICAgICAgICAgICB0aGlzLndob2xlV29yZCA9PSBvdGhlci53aG9sZVdvcmQ7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgIEBpbnRlcm5hbFxyXG4gICAgKi9cclxuICAgIGNyZWF0ZSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5yZWdleHAgPyBuZXcgUmVnRXhwUXVlcnkodGhpcykgOiBuZXcgU3RyaW5nUXVlcnkodGhpcyk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgIEdldCBhIHNlYXJjaCBjdXJzb3IgZm9yIHRoaXMgcXVlcnksIHNlYXJjaGluZyB0aHJvdWdoIHRoZSBnaXZlblxyXG4gICAgcmFuZ2UgaW4gdGhlIGdpdmVuIHN0YXRlLlxyXG4gICAgKi9cclxuICAgIGdldEN1cnNvcihzdGF0ZSwgZnJvbSA9IDAsIHRvKSB7XHJcbiAgICAgICAgbGV0IHN0ID0gc3RhdGUuZG9jID8gc3RhdGUgOiBFZGl0b3JTdGF0ZS5jcmVhdGUoeyBkb2M6IHN0YXRlIH0pO1xyXG4gICAgICAgIGlmICh0byA9PSBudWxsKVxyXG4gICAgICAgICAgICB0byA9IHN0LmRvYy5sZW5ndGg7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucmVnZXhwID8gcmVnZXhwQ3Vyc29yKHRoaXMsIHN0LCBmcm9tLCB0bykgOiBzdHJpbmdDdXJzb3IodGhpcywgc3QsIGZyb20sIHRvKTtcclxuICAgIH1cclxufVxyXG5jbGFzcyBRdWVyeVR5cGUge1xyXG4gICAgY29uc3RydWN0b3Ioc3BlYykge1xyXG4gICAgICAgIHRoaXMuc3BlYyA9IHNwZWM7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gc3RyaW5nQ3Vyc29yKHNwZWMsIHN0YXRlLCBmcm9tLCB0bykge1xyXG4gICAgcmV0dXJuIG5ldyBTZWFyY2hDdXJzb3Ioc3RhdGUuZG9jLCBzcGVjLnVucXVvdGVkLCBmcm9tLCB0bywgc3BlYy5jYXNlU2Vuc2l0aXZlID8gdW5kZWZpbmVkIDogeCA9PiB4LnRvTG93ZXJDYXNlKCksIHNwZWMud2hvbGVXb3JkID8gc3RyaW5nV29yZFRlc3Qoc3RhdGUuZG9jLCBzdGF0ZS5jaGFyQ2F0ZWdvcml6ZXIoc3RhdGUuc2VsZWN0aW9uLm1haW4uaGVhZCkpIDogdW5kZWZpbmVkKTtcclxufVxyXG5mdW5jdGlvbiBzdHJpbmdXb3JkVGVzdChkb2MsIGNhdGVnb3JpemVyKSB7XHJcbiAgICByZXR1cm4gKGZyb20sIHRvLCBidWYsIGJ1ZlBvcykgPT4ge1xyXG4gICAgICAgIGlmIChidWZQb3MgPiBmcm9tIHx8IGJ1ZlBvcyArIGJ1Zi5sZW5ndGggPCB0bykge1xyXG4gICAgICAgICAgICBidWZQb3MgPSBNYXRoLm1heCgwLCBmcm9tIC0gMik7XHJcbiAgICAgICAgICAgIGJ1ZiA9IGRvYy5zbGljZVN0cmluZyhidWZQb3MsIE1hdGgubWluKGRvYy5sZW5ndGgsIHRvICsgMikpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gKGNhdGVnb3JpemVyKGNoYXJCZWZvcmUoYnVmLCBmcm9tIC0gYnVmUG9zKSkgIT0gQ2hhckNhdGVnb3J5LldvcmQgfHxcclxuICAgICAgICAgICAgY2F0ZWdvcml6ZXIoY2hhckFmdGVyKGJ1ZiwgZnJvbSAtIGJ1ZlBvcykpICE9IENoYXJDYXRlZ29yeS5Xb3JkKSAmJlxyXG4gICAgICAgICAgICAoY2F0ZWdvcml6ZXIoY2hhckFmdGVyKGJ1ZiwgdG8gLSBidWZQb3MpKSAhPSBDaGFyQ2F0ZWdvcnkuV29yZCB8fFxyXG4gICAgICAgICAgICAgICAgY2F0ZWdvcml6ZXIoY2hhckJlZm9yZShidWYsIHRvIC0gYnVmUG9zKSkgIT0gQ2hhckNhdGVnb3J5LldvcmQpO1xyXG4gICAgfTtcclxufVxyXG5jbGFzcyBTdHJpbmdRdWVyeSBleHRlbmRzIFF1ZXJ5VHlwZSB7XHJcbiAgICBjb25zdHJ1Y3RvcihzcGVjKSB7XHJcbiAgICAgICAgc3VwZXIoc3BlYyk7XHJcbiAgICB9XHJcbiAgICBuZXh0TWF0Y2goc3RhdGUsIGN1ckZyb20sIGN1clRvKSB7XHJcbiAgICAgICAgbGV0IGN1cnNvciA9IHN0cmluZ0N1cnNvcih0aGlzLnNwZWMsIHN0YXRlLCBjdXJUbywgc3RhdGUuZG9jLmxlbmd0aCkubmV4dE92ZXJsYXBwaW5nKCk7XHJcbiAgICAgICAgaWYgKGN1cnNvci5kb25lKVxyXG4gICAgICAgICAgICBjdXJzb3IgPSBzdHJpbmdDdXJzb3IodGhpcy5zcGVjLCBzdGF0ZSwgMCwgY3VyRnJvbSkubmV4dE92ZXJsYXBwaW5nKCk7XHJcbiAgICAgICAgcmV0dXJuIGN1cnNvci5kb25lID8gbnVsbCA6IGN1cnNvci52YWx1ZTtcclxuICAgIH1cclxuICAgIC8vIFNlYXJjaGluZyBpbiByZXZlcnNlIGlzLCByYXRoZXIgdGhhbiBpbXBsZW1lbnRpbmcgaW52ZXJ0ZWQgc2VhcmNoXHJcbiAgICAvLyBjdXJzb3IsIGRvbmUgYnkgc2Nhbm5pbmcgY2h1bmsgYWZ0ZXIgY2h1bmsgZm9yd2FyZC5cclxuICAgIHByZXZNYXRjaEluUmFuZ2Uoc3RhdGUsIGZyb20sIHRvKSB7XHJcbiAgICAgICAgZm9yIChsZXQgcG9zID0gdG87Oykge1xyXG4gICAgICAgICAgICBsZXQgc3RhcnQgPSBNYXRoLm1heChmcm9tLCBwb3MgLSAxMDAwMCAvKiBGaW5kUHJldi5DaHVua1NpemUgKi8gLSB0aGlzLnNwZWMudW5xdW90ZWQubGVuZ3RoKTtcclxuICAgICAgICAgICAgbGV0IGN1cnNvciA9IHN0cmluZ0N1cnNvcih0aGlzLnNwZWMsIHN0YXRlLCBzdGFydCwgcG9zKSwgcmFuZ2UgPSBudWxsO1xyXG4gICAgICAgICAgICB3aGlsZSAoIWN1cnNvci5uZXh0T3ZlcmxhcHBpbmcoKS5kb25lKVxyXG4gICAgICAgICAgICAgICAgcmFuZ2UgPSBjdXJzb3IudmFsdWU7XHJcbiAgICAgICAgICAgIGlmIChyYW5nZSlcclxuICAgICAgICAgICAgICAgIHJldHVybiByYW5nZTtcclxuICAgICAgICAgICAgaWYgKHN0YXJ0ID09IGZyb20pXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgcG9zIC09IDEwMDAwIC8qIEZpbmRQcmV2LkNodW5rU2l6ZSAqLztcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBwcmV2TWF0Y2goc3RhdGUsIGN1ckZyb20sIGN1clRvKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucHJldk1hdGNoSW5SYW5nZShzdGF0ZSwgMCwgY3VyRnJvbSkgfHxcclxuICAgICAgICAgICAgdGhpcy5wcmV2TWF0Y2hJblJhbmdlKHN0YXRlLCBjdXJUbywgc3RhdGUuZG9jLmxlbmd0aCk7XHJcbiAgICB9XHJcbiAgICBnZXRSZXBsYWNlbWVudChfcmVzdWx0KSB7IHJldHVybiB0aGlzLnNwZWMudW5xdW90ZSh0aGlzLnNwZWMucmVwbGFjZSk7IH1cclxuICAgIG1hdGNoQWxsKHN0YXRlLCBsaW1pdCkge1xyXG4gICAgICAgIGxldCBjdXJzb3IgPSBzdHJpbmdDdXJzb3IodGhpcy5zcGVjLCBzdGF0ZSwgMCwgc3RhdGUuZG9jLmxlbmd0aCksIHJhbmdlcyA9IFtdO1xyXG4gICAgICAgIHdoaWxlICghY3Vyc29yLm5leHQoKS5kb25lKSB7XHJcbiAgICAgICAgICAgIGlmIChyYW5nZXMubGVuZ3RoID49IGxpbWl0KVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgIHJhbmdlcy5wdXNoKGN1cnNvci52YWx1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByYW5nZXM7XHJcbiAgICB9XHJcbiAgICBoaWdobGlnaHQoc3RhdGUsIGZyb20sIHRvLCBhZGQpIHtcclxuICAgICAgICBsZXQgY3Vyc29yID0gc3RyaW5nQ3Vyc29yKHRoaXMuc3BlYywgc3RhdGUsIE1hdGgubWF4KDAsIGZyb20gLSB0aGlzLnNwZWMudW5xdW90ZWQubGVuZ3RoKSwgTWF0aC5taW4odG8gKyB0aGlzLnNwZWMudW5xdW90ZWQubGVuZ3RoLCBzdGF0ZS5kb2MubGVuZ3RoKSk7XHJcbiAgICAgICAgd2hpbGUgKCFjdXJzb3IubmV4dCgpLmRvbmUpXHJcbiAgICAgICAgICAgIGFkZChjdXJzb3IudmFsdWUuZnJvbSwgY3Vyc29yLnZhbHVlLnRvKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiByZWdleHBDdXJzb3Ioc3BlYywgc3RhdGUsIGZyb20sIHRvKSB7XHJcbiAgICByZXR1cm4gbmV3IFJlZ0V4cEN1cnNvcihzdGF0ZS5kb2MsIHNwZWMuc2VhcmNoLCB7XHJcbiAgICAgICAgaWdub3JlQ2FzZTogIXNwZWMuY2FzZVNlbnNpdGl2ZSxcclxuICAgICAgICB0ZXN0OiBzcGVjLndob2xlV29yZCA/IHJlZ2V4cFdvcmRUZXN0KHN0YXRlLmNoYXJDYXRlZ29yaXplcihzdGF0ZS5zZWxlY3Rpb24ubWFpbi5oZWFkKSkgOiB1bmRlZmluZWRcclxuICAgIH0sIGZyb20sIHRvKTtcclxufVxyXG5mdW5jdGlvbiBjaGFyQmVmb3JlKHN0ciwgaW5kZXgpIHtcclxuICAgIHJldHVybiBzdHIuc2xpY2UoZmluZENsdXN0ZXJCcmVhayhzdHIsIGluZGV4LCBmYWxzZSksIGluZGV4KTtcclxufVxyXG5mdW5jdGlvbiBjaGFyQWZ0ZXIoc3RyLCBpbmRleCkge1xyXG4gICAgcmV0dXJuIHN0ci5zbGljZShpbmRleCwgZmluZENsdXN0ZXJCcmVhayhzdHIsIGluZGV4KSk7XHJcbn1cclxuZnVuY3Rpb24gcmVnZXhwV29yZFRlc3QoY2F0ZWdvcml6ZXIpIHtcclxuICAgIHJldHVybiAoX2Zyb20sIF90bywgbWF0Y2gpID0+ICFtYXRjaFswXS5sZW5ndGggfHxcclxuICAgICAgICAoY2F0ZWdvcml6ZXIoY2hhckJlZm9yZShtYXRjaC5pbnB1dCwgbWF0Y2guaW5kZXgpKSAhPSBDaGFyQ2F0ZWdvcnkuV29yZCB8fFxyXG4gICAgICAgICAgICBjYXRlZ29yaXplcihjaGFyQWZ0ZXIobWF0Y2guaW5wdXQsIG1hdGNoLmluZGV4KSkgIT0gQ2hhckNhdGVnb3J5LldvcmQpICYmXHJcbiAgICAgICAgICAgIChjYXRlZ29yaXplcihjaGFyQWZ0ZXIobWF0Y2guaW5wdXQsIG1hdGNoLmluZGV4ICsgbWF0Y2hbMF0ubGVuZ3RoKSkgIT0gQ2hhckNhdGVnb3J5LldvcmQgfHxcclxuICAgICAgICAgICAgICAgIGNhdGVnb3JpemVyKGNoYXJCZWZvcmUobWF0Y2guaW5wdXQsIG1hdGNoLmluZGV4ICsgbWF0Y2hbMF0ubGVuZ3RoKSkgIT0gQ2hhckNhdGVnb3J5LldvcmQpO1xyXG59XHJcbmNsYXNzIFJlZ0V4cFF1ZXJ5IGV4dGVuZHMgUXVlcnlUeXBlIHtcclxuICAgIG5leHRNYXRjaChzdGF0ZSwgY3VyRnJvbSwgY3VyVG8pIHtcclxuICAgICAgICBsZXQgY3Vyc29yID0gcmVnZXhwQ3Vyc29yKHRoaXMuc3BlYywgc3RhdGUsIGN1clRvLCBzdGF0ZS5kb2MubGVuZ3RoKS5uZXh0KCk7XHJcbiAgICAgICAgaWYgKGN1cnNvci5kb25lKVxyXG4gICAgICAgICAgICBjdXJzb3IgPSByZWdleHBDdXJzb3IodGhpcy5zcGVjLCBzdGF0ZSwgMCwgY3VyRnJvbSkubmV4dCgpO1xyXG4gICAgICAgIHJldHVybiBjdXJzb3IuZG9uZSA/IG51bGwgOiBjdXJzb3IudmFsdWU7XHJcbiAgICB9XHJcbiAgICBwcmV2TWF0Y2hJblJhbmdlKHN0YXRlLCBmcm9tLCB0bykge1xyXG4gICAgICAgIGZvciAobGV0IHNpemUgPSAxOzsgc2l6ZSsrKSB7XHJcbiAgICAgICAgICAgIGxldCBzdGFydCA9IE1hdGgubWF4KGZyb20sIHRvIC0gc2l6ZSAqIDEwMDAwIC8qIEZpbmRQcmV2LkNodW5rU2l6ZSAqLyk7XHJcbiAgICAgICAgICAgIGxldCBjdXJzb3IgPSByZWdleHBDdXJzb3IodGhpcy5zcGVjLCBzdGF0ZSwgc3RhcnQsIHRvKSwgcmFuZ2UgPSBudWxsO1xyXG4gICAgICAgICAgICB3aGlsZSAoIWN1cnNvci5uZXh0KCkuZG9uZSlcclxuICAgICAgICAgICAgICAgIHJhbmdlID0gY3Vyc29yLnZhbHVlO1xyXG4gICAgICAgICAgICBpZiAocmFuZ2UgJiYgKHN0YXJ0ID09IGZyb20gfHwgcmFuZ2UuZnJvbSA+IHN0YXJ0ICsgMTApKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJhbmdlO1xyXG4gICAgICAgICAgICBpZiAoc3RhcnQgPT0gZnJvbSlcclxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHByZXZNYXRjaChzdGF0ZSwgY3VyRnJvbSwgY3VyVG8pIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5wcmV2TWF0Y2hJblJhbmdlKHN0YXRlLCAwLCBjdXJGcm9tKSB8fFxyXG4gICAgICAgICAgICB0aGlzLnByZXZNYXRjaEluUmFuZ2Uoc3RhdGUsIGN1clRvLCBzdGF0ZS5kb2MubGVuZ3RoKTtcclxuICAgIH1cclxuICAgIGdldFJlcGxhY2VtZW50KHJlc3VsdCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnNwZWMudW5xdW90ZSh0aGlzLnNwZWMucmVwbGFjZS5yZXBsYWNlKC9cXCQoWyQmXFxkK10pL2csIChtLCBpKSA9PiBpID09IFwiJFwiID8gXCIkXCJcclxuICAgICAgICAgICAgOiBpID09IFwiJlwiID8gcmVzdWx0Lm1hdGNoWzBdXHJcbiAgICAgICAgICAgICAgICA6IGkgIT0gXCIwXCIgJiYgK2kgPCByZXN1bHQubWF0Y2gubGVuZ3RoID8gcmVzdWx0Lm1hdGNoW2ldXHJcbiAgICAgICAgICAgICAgICAgICAgOiBtKSk7XHJcbiAgICB9XHJcbiAgICBtYXRjaEFsbChzdGF0ZSwgbGltaXQpIHtcclxuICAgICAgICBsZXQgY3Vyc29yID0gcmVnZXhwQ3Vyc29yKHRoaXMuc3BlYywgc3RhdGUsIDAsIHN0YXRlLmRvYy5sZW5ndGgpLCByYW5nZXMgPSBbXTtcclxuICAgICAgICB3aGlsZSAoIWN1cnNvci5uZXh0KCkuZG9uZSkge1xyXG4gICAgICAgICAgICBpZiAocmFuZ2VzLmxlbmd0aCA+PSBsaW1pdClcclxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICByYW5nZXMucHVzaChjdXJzb3IudmFsdWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmFuZ2VzO1xyXG4gICAgfVxyXG4gICAgaGlnaGxpZ2h0KHN0YXRlLCBmcm9tLCB0bywgYWRkKSB7XHJcbiAgICAgICAgbGV0IGN1cnNvciA9IHJlZ2V4cEN1cnNvcih0aGlzLnNwZWMsIHN0YXRlLCBNYXRoLm1heCgwLCBmcm9tIC0gMjUwIC8qIFJlZ0V4cC5IaWdobGlnaHRNYXJnaW4gKi8pLCBNYXRoLm1pbih0byArIDI1MCAvKiBSZWdFeHAuSGlnaGxpZ2h0TWFyZ2luICovLCBzdGF0ZS5kb2MubGVuZ3RoKSk7XHJcbiAgICAgICAgd2hpbGUgKCFjdXJzb3IubmV4dCgpLmRvbmUpXHJcbiAgICAgICAgICAgIGFkZChjdXJzb3IudmFsdWUuZnJvbSwgY3Vyc29yLnZhbHVlLnRvKTtcclxuICAgIH1cclxufVxyXG4vKipcclxuQSBzdGF0ZSBlZmZlY3QgdGhhdCB1cGRhdGVzIHRoZSBjdXJyZW50IHNlYXJjaCBxdWVyeS4gTm90ZSB0aGF0XHJcbnRoaXMgb25seSBoYXMgYW4gZWZmZWN0IGlmIHRoZSBzZWFyY2ggc3RhdGUgaGFzIGJlZW4gaW5pdGlhbGl6ZWRcclxuKGJ5IGluY2x1ZGluZyBbYHNlYXJjaGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc2VhcmNoLnNlYXJjaCkgaW4geW91ciBjb25maWd1cmF0aW9uIG9yXHJcbmJ5IHJ1bm5pbmcgW2BvcGVuU2VhcmNoUGFuZWxgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3NlYXJjaC5vcGVuU2VhcmNoUGFuZWwpIGF0IGxlYXN0XHJcbm9uY2UpLlxyXG4qL1xyXG5jb25zdCBzZXRTZWFyY2hRdWVyeSA9IC8qQF9fUFVSRV9fKi9TdGF0ZUVmZmVjdC5kZWZpbmUoKTtcclxuY29uc3QgdG9nZ2xlUGFuZWwgPSAvKkBfX1BVUkVfXyovU3RhdGVFZmZlY3QuZGVmaW5lKCk7XHJcbmNvbnN0IHNlYXJjaFN0YXRlID0gLypAX19QVVJFX18qL1N0YXRlRmllbGQuZGVmaW5lKHtcclxuICAgIGNyZWF0ZShzdGF0ZSkge1xyXG4gICAgICAgIHJldHVybiBuZXcgU2VhcmNoU3RhdGUoZGVmYXVsdFF1ZXJ5KHN0YXRlKS5jcmVhdGUoKSwgbnVsbCk7XHJcbiAgICB9LFxyXG4gICAgdXBkYXRlKHZhbHVlLCB0cikge1xyXG4gICAgICAgIGZvciAobGV0IGVmZmVjdCBvZiB0ci5lZmZlY3RzKSB7XHJcbiAgICAgICAgICAgIGlmIChlZmZlY3QuaXMoc2V0U2VhcmNoUXVlcnkpKVxyXG4gICAgICAgICAgICAgICAgdmFsdWUgPSBuZXcgU2VhcmNoU3RhdGUoZWZmZWN0LnZhbHVlLmNyZWF0ZSgpLCB2YWx1ZS5wYW5lbCk7XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGVmZmVjdC5pcyh0b2dnbGVQYW5lbCkpXHJcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IG5ldyBTZWFyY2hTdGF0ZSh2YWx1ZS5xdWVyeSwgZWZmZWN0LnZhbHVlID8gY3JlYXRlU2VhcmNoUGFuZWwgOiBudWxsKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgfSxcclxuICAgIHByb3ZpZGU6IGYgPT4gc2hvd1BhbmVsLmZyb20oZiwgdmFsID0+IHZhbC5wYW5lbClcclxufSk7XHJcbi8qKlxyXG5HZXQgdGhlIGN1cnJlbnQgc2VhcmNoIHF1ZXJ5IGZyb20gYW4gZWRpdG9yIHN0YXRlLlxyXG4qL1xyXG5mdW5jdGlvbiBnZXRTZWFyY2hRdWVyeShzdGF0ZSkge1xyXG4gICAgbGV0IGN1clN0YXRlID0gc3RhdGUuZmllbGQoc2VhcmNoU3RhdGUsIGZhbHNlKTtcclxuICAgIHJldHVybiBjdXJTdGF0ZSA/IGN1clN0YXRlLnF1ZXJ5LnNwZWMgOiBkZWZhdWx0UXVlcnkoc3RhdGUpO1xyXG59XHJcbi8qKlxyXG5RdWVyeSB3aGV0aGVyIHRoZSBzZWFyY2ggcGFuZWwgaXMgb3BlbiBpbiB0aGUgZ2l2ZW4gZWRpdG9yIHN0YXRlLlxyXG4qL1xyXG5mdW5jdGlvbiBzZWFyY2hQYW5lbE9wZW4oc3RhdGUpIHtcclxuICAgIHZhciBfYTtcclxuICAgIHJldHVybiAoKF9hID0gc3RhdGUuZmllbGQoc2VhcmNoU3RhdGUsIGZhbHNlKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnBhbmVsKSAhPSBudWxsO1xyXG59XHJcbmNsYXNzIFNlYXJjaFN0YXRlIHtcclxuICAgIGNvbnN0cnVjdG9yKHF1ZXJ5LCBwYW5lbCkge1xyXG4gICAgICAgIHRoaXMucXVlcnkgPSBxdWVyeTtcclxuICAgICAgICB0aGlzLnBhbmVsID0gcGFuZWw7XHJcbiAgICB9XHJcbn1cclxuY29uc3QgbWF0Y2hNYXJrID0gLypAX19QVVJFX18qL0RlY29yYXRpb24ubWFyayh7IGNsYXNzOiBcImNtLXNlYXJjaE1hdGNoXCIgfSksIHNlbGVjdGVkTWF0Y2hNYXJrID0gLypAX19QVVJFX18qL0RlY29yYXRpb24ubWFyayh7IGNsYXNzOiBcImNtLXNlYXJjaE1hdGNoIGNtLXNlYXJjaE1hdGNoLXNlbGVjdGVkXCIgfSk7XHJcbmNvbnN0IHNlYXJjaEhpZ2hsaWdodGVyID0gLypAX19QVVJFX18qL1ZpZXdQbHVnaW4uZnJvbUNsYXNzKGNsYXNzIHtcclxuICAgIGNvbnN0cnVjdG9yKHZpZXcpIHtcclxuICAgICAgICB0aGlzLnZpZXcgPSB2aWV3O1xyXG4gICAgICAgIHRoaXMuZGVjb3JhdGlvbnMgPSB0aGlzLmhpZ2hsaWdodCh2aWV3LnN0YXRlLmZpZWxkKHNlYXJjaFN0YXRlKSk7XHJcbiAgICB9XHJcbiAgICB1cGRhdGUodXBkYXRlKSB7XHJcbiAgICAgICAgbGV0IHN0YXRlID0gdXBkYXRlLnN0YXRlLmZpZWxkKHNlYXJjaFN0YXRlKTtcclxuICAgICAgICBpZiAoc3RhdGUgIT0gdXBkYXRlLnN0YXJ0U3RhdGUuZmllbGQoc2VhcmNoU3RhdGUpIHx8IHVwZGF0ZS5kb2NDaGFuZ2VkIHx8IHVwZGF0ZS5zZWxlY3Rpb25TZXQgfHwgdXBkYXRlLnZpZXdwb3J0Q2hhbmdlZClcclxuICAgICAgICAgICAgdGhpcy5kZWNvcmF0aW9ucyA9IHRoaXMuaGlnaGxpZ2h0KHN0YXRlKTtcclxuICAgIH1cclxuICAgIGhpZ2hsaWdodCh7IHF1ZXJ5LCBwYW5lbCB9KSB7XHJcbiAgICAgICAgaWYgKCFwYW5lbCB8fCAhcXVlcnkuc3BlYy52YWxpZClcclxuICAgICAgICAgICAgcmV0dXJuIERlY29yYXRpb24ubm9uZTtcclxuICAgICAgICBsZXQgeyB2aWV3IH0gPSB0aGlzO1xyXG4gICAgICAgIGxldCBidWlsZGVyID0gbmV3IFJhbmdlU2V0QnVpbGRlcigpO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwLCByYW5nZXMgPSB2aWV3LnZpc2libGVSYW5nZXMsIGwgPSByYW5nZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGxldCB7IGZyb20sIHRvIH0gPSByYW5nZXNbaV07XHJcbiAgICAgICAgICAgIHdoaWxlIChpIDwgbCAtIDEgJiYgdG8gPiByYW5nZXNbaSArIDFdLmZyb20gLSAyICogMjUwIC8qIFJlZ0V4cC5IaWdobGlnaHRNYXJnaW4gKi8pXHJcbiAgICAgICAgICAgICAgICB0byA9IHJhbmdlc1srK2ldLnRvO1xyXG4gICAgICAgICAgICBxdWVyeS5oaWdobGlnaHQodmlldy5zdGF0ZSwgZnJvbSwgdG8sIChmcm9tLCB0bykgPT4ge1xyXG4gICAgICAgICAgICAgICAgbGV0IHNlbGVjdGVkID0gdmlldy5zdGF0ZS5zZWxlY3Rpb24ucmFuZ2VzLnNvbWUociA9PiByLmZyb20gPT0gZnJvbSAmJiByLnRvID09IHRvKTtcclxuICAgICAgICAgICAgICAgIGJ1aWxkZXIuYWRkKGZyb20sIHRvLCBzZWxlY3RlZCA/IHNlbGVjdGVkTWF0Y2hNYXJrIDogbWF0Y2hNYXJrKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBidWlsZGVyLmZpbmlzaCgpO1xyXG4gICAgfVxyXG59LCB7XHJcbiAgICBkZWNvcmF0aW9uczogdiA9PiB2LmRlY29yYXRpb25zXHJcbn0pO1xyXG5mdW5jdGlvbiBzZWFyY2hDb21tYW5kKGYpIHtcclxuICAgIHJldHVybiB2aWV3ID0+IHtcclxuICAgICAgICBsZXQgc3RhdGUgPSB2aWV3LnN0YXRlLmZpZWxkKHNlYXJjaFN0YXRlLCBmYWxzZSk7XHJcbiAgICAgICAgcmV0dXJuIHN0YXRlICYmIHN0YXRlLnF1ZXJ5LnNwZWMudmFsaWQgPyBmKHZpZXcsIHN0YXRlKSA6IG9wZW5TZWFyY2hQYW5lbCh2aWV3KTtcclxuICAgIH07XHJcbn1cclxuLyoqXHJcbk9wZW4gdGhlIHNlYXJjaCBwYW5lbCBpZiBpdCBpc24ndCBhbHJlYWR5IG9wZW4sIGFuZCBtb3ZlIHRoZVxyXG5zZWxlY3Rpb24gdG8gdGhlIGZpcnN0IG1hdGNoIGFmdGVyIHRoZSBjdXJyZW50IG1haW4gc2VsZWN0aW9uLlxyXG5XaWxsIHdyYXAgYXJvdW5kIHRvIHRoZSBzdGFydCBvZiB0aGUgZG9jdW1lbnQgd2hlbiBpdCByZWFjaGVzIHRoZVxyXG5lbmQuXHJcbiovXHJcbmNvbnN0IGZpbmROZXh0ID0gLypAX19QVVJFX18qL3NlYXJjaENvbW1hbmQoKHZpZXcsIHsgcXVlcnkgfSkgPT4ge1xyXG4gICAgbGV0IHsgdG8gfSA9IHZpZXcuc3RhdGUuc2VsZWN0aW9uLm1haW47XHJcbiAgICBsZXQgbmV4dCA9IHF1ZXJ5Lm5leHRNYXRjaCh2aWV3LnN0YXRlLCB0bywgdG8pO1xyXG4gICAgaWYgKCFuZXh0KVxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIHZpZXcuZGlzcGF0Y2goe1xyXG4gICAgICAgIHNlbGVjdGlvbjogeyBhbmNob3I6IG5leHQuZnJvbSwgaGVhZDogbmV4dC50byB9LFxyXG4gICAgICAgIHNjcm9sbEludG9WaWV3OiB0cnVlLFxyXG4gICAgICAgIGVmZmVjdHM6IGFubm91bmNlTWF0Y2godmlldywgbmV4dCksXHJcbiAgICAgICAgdXNlckV2ZW50OiBcInNlbGVjdC5zZWFyY2hcIlxyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gdHJ1ZTtcclxufSk7XHJcbi8qKlxyXG5Nb3ZlIHRoZSBzZWxlY3Rpb24gdG8gdGhlIHByZXZpb3VzIGluc3RhbmNlIG9mIHRoZSBzZWFyY2ggcXVlcnksXHJcbmJlZm9yZSB0aGUgY3VycmVudCBtYWluIHNlbGVjdGlvbi4gV2lsbCB3cmFwIHBhc3QgdGhlIHN0YXJ0XHJcbm9mIHRoZSBkb2N1bWVudCB0byBzdGFydCBzZWFyY2hpbmcgYXQgdGhlIGVuZCBhZ2Fpbi5cclxuKi9cclxuY29uc3QgZmluZFByZXZpb3VzID0gLypAX19QVVJFX18qL3NlYXJjaENvbW1hbmQoKHZpZXcsIHsgcXVlcnkgfSkgPT4ge1xyXG4gICAgbGV0IHsgc3RhdGUgfSA9IHZpZXcsIHsgZnJvbSB9ID0gc3RhdGUuc2VsZWN0aW9uLm1haW47XHJcbiAgICBsZXQgcmFuZ2UgPSBxdWVyeS5wcmV2TWF0Y2goc3RhdGUsIGZyb20sIGZyb20pO1xyXG4gICAgaWYgKCFyYW5nZSlcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB2aWV3LmRpc3BhdGNoKHtcclxuICAgICAgICBzZWxlY3Rpb246IHsgYW5jaG9yOiByYW5nZS5mcm9tLCBoZWFkOiByYW5nZS50byB9LFxyXG4gICAgICAgIHNjcm9sbEludG9WaWV3OiB0cnVlLFxyXG4gICAgICAgIGVmZmVjdHM6IGFubm91bmNlTWF0Y2godmlldywgcmFuZ2UpLFxyXG4gICAgICAgIHVzZXJFdmVudDogXCJzZWxlY3Quc2VhcmNoXCJcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIHRydWU7XHJcbn0pO1xyXG4vKipcclxuU2VsZWN0IGFsbCBpbnN0YW5jZXMgb2YgdGhlIHNlYXJjaCBxdWVyeS5cclxuKi9cclxuY29uc3Qgc2VsZWN0TWF0Y2hlcyA9IC8qQF9fUFVSRV9fKi9zZWFyY2hDb21tYW5kKCh2aWV3LCB7IHF1ZXJ5IH0pID0+IHtcclxuICAgIGxldCByYW5nZXMgPSBxdWVyeS5tYXRjaEFsbCh2aWV3LnN0YXRlLCAxMDAwKTtcclxuICAgIGlmICghcmFuZ2VzIHx8ICFyYW5nZXMubGVuZ3RoKVxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIHZpZXcuZGlzcGF0Y2goe1xyXG4gICAgICAgIHNlbGVjdGlvbjogRWRpdG9yU2VsZWN0aW9uLmNyZWF0ZShyYW5nZXMubWFwKHIgPT4gRWRpdG9yU2VsZWN0aW9uLnJhbmdlKHIuZnJvbSwgci50bykpKSxcclxuICAgICAgICB1c2VyRXZlbnQ6IFwic2VsZWN0LnNlYXJjaC5tYXRjaGVzXCJcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIHRydWU7XHJcbn0pO1xyXG4vKipcclxuU2VsZWN0IGFsbCBpbnN0YW5jZXMgb2YgdGhlIGN1cnJlbnRseSBzZWxlY3RlZCB0ZXh0LlxyXG4qL1xyXG5jb25zdCBzZWxlY3RTZWxlY3Rpb25NYXRjaGVzID0gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcclxuICAgIGxldCBzZWwgPSBzdGF0ZS5zZWxlY3Rpb247XHJcbiAgICBpZiAoc2VsLnJhbmdlcy5sZW5ndGggPiAxIHx8IHNlbC5tYWluLmVtcHR5KVxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIGxldCB7IGZyb20sIHRvIH0gPSBzZWwubWFpbjtcclxuICAgIGxldCByYW5nZXMgPSBbXSwgbWFpbiA9IDA7XHJcbiAgICBmb3IgKGxldCBjdXIgPSBuZXcgU2VhcmNoQ3Vyc29yKHN0YXRlLmRvYywgc3RhdGUuc2xpY2VEb2MoZnJvbSwgdG8pKTsgIWN1ci5uZXh0KCkuZG9uZTspIHtcclxuICAgICAgICBpZiAocmFuZ2VzLmxlbmd0aCA+IDEwMDApXHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICBpZiAoY3VyLnZhbHVlLmZyb20gPT0gZnJvbSlcclxuICAgICAgICAgICAgbWFpbiA9IHJhbmdlcy5sZW5ndGg7XHJcbiAgICAgICAgcmFuZ2VzLnB1c2goRWRpdG9yU2VsZWN0aW9uLnJhbmdlKGN1ci52YWx1ZS5mcm9tLCBjdXIudmFsdWUudG8pKTtcclxuICAgIH1cclxuICAgIGRpc3BhdGNoKHN0YXRlLnVwZGF0ZSh7XHJcbiAgICAgICAgc2VsZWN0aW9uOiBFZGl0b3JTZWxlY3Rpb24uY3JlYXRlKHJhbmdlcywgbWFpbiksXHJcbiAgICAgICAgdXNlckV2ZW50OiBcInNlbGVjdC5zZWFyY2gubWF0Y2hlc1wiXHJcbiAgICB9KSk7XHJcbiAgICByZXR1cm4gdHJ1ZTtcclxufTtcclxuLyoqXHJcblJlcGxhY2UgdGhlIGN1cnJlbnQgbWF0Y2ggb2YgdGhlIHNlYXJjaCBxdWVyeS5cclxuKi9cclxuY29uc3QgcmVwbGFjZU5leHQgPSAvKkBfX1BVUkVfXyovc2VhcmNoQ29tbWFuZCgodmlldywgeyBxdWVyeSB9KSA9PiB7XHJcbiAgICBsZXQgeyBzdGF0ZSB9ID0gdmlldywgeyBmcm9tLCB0byB9ID0gc3RhdGUuc2VsZWN0aW9uLm1haW47XHJcbiAgICBpZiAoc3RhdGUucmVhZE9ubHkpXHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgbGV0IG5leHQgPSBxdWVyeS5uZXh0TWF0Y2goc3RhdGUsIGZyb20sIGZyb20pO1xyXG4gICAgaWYgKCFuZXh0KVxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIGxldCBjaGFuZ2VzID0gW10sIHNlbGVjdGlvbiwgcmVwbGFjZW1lbnQ7XHJcbiAgICBsZXQgYW5ub3VuY2UgPSBbXTtcclxuICAgIGlmIChuZXh0LmZyb20gPT0gZnJvbSAmJiBuZXh0LnRvID09IHRvKSB7XHJcbiAgICAgICAgcmVwbGFjZW1lbnQgPSBzdGF0ZS50b1RleHQocXVlcnkuZ2V0UmVwbGFjZW1lbnQobmV4dCkpO1xyXG4gICAgICAgIGNoYW5nZXMucHVzaCh7IGZyb206IG5leHQuZnJvbSwgdG86IG5leHQudG8sIGluc2VydDogcmVwbGFjZW1lbnQgfSk7XHJcbiAgICAgICAgbmV4dCA9IHF1ZXJ5Lm5leHRNYXRjaChzdGF0ZSwgbmV4dC5mcm9tLCBuZXh0LnRvKTtcclxuICAgICAgICBhbm5vdW5jZS5wdXNoKEVkaXRvclZpZXcuYW5ub3VuY2Uub2Yoc3RhdGUucGhyYXNlKFwicmVwbGFjZWQgbWF0Y2ggb24gbGluZSAkXCIsIHN0YXRlLmRvYy5saW5lQXQoZnJvbSkubnVtYmVyKSArIFwiLlwiKSk7XHJcbiAgICB9XHJcbiAgICBpZiAobmV4dCkge1xyXG4gICAgICAgIGxldCBvZmYgPSBjaGFuZ2VzLmxlbmd0aCA9PSAwIHx8IGNoYW5nZXNbMF0uZnJvbSA+PSBuZXh0LnRvID8gMCA6IG5leHQudG8gLSBuZXh0LmZyb20gLSByZXBsYWNlbWVudC5sZW5ndGg7XHJcbiAgICAgICAgc2VsZWN0aW9uID0geyBhbmNob3I6IG5leHQuZnJvbSAtIG9mZiwgaGVhZDogbmV4dC50byAtIG9mZiB9O1xyXG4gICAgICAgIGFubm91bmNlLnB1c2goYW5ub3VuY2VNYXRjaCh2aWV3LCBuZXh0KSk7XHJcbiAgICB9XHJcbiAgICB2aWV3LmRpc3BhdGNoKHtcclxuICAgICAgICBjaGFuZ2VzLCBzZWxlY3Rpb24sXHJcbiAgICAgICAgc2Nyb2xsSW50b1ZpZXc6ICEhc2VsZWN0aW9uLFxyXG4gICAgICAgIGVmZmVjdHM6IGFubm91bmNlLFxyXG4gICAgICAgIHVzZXJFdmVudDogXCJpbnB1dC5yZXBsYWNlXCJcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIHRydWU7XHJcbn0pO1xyXG4vKipcclxuUmVwbGFjZSBhbGwgaW5zdGFuY2VzIG9mIHRoZSBzZWFyY2ggcXVlcnkgd2l0aCB0aGUgZ2l2ZW5cclxucmVwbGFjZW1lbnQuXHJcbiovXHJcbmNvbnN0IHJlcGxhY2VBbGwgPSAvKkBfX1BVUkVfXyovc2VhcmNoQ29tbWFuZCgodmlldywgeyBxdWVyeSB9KSA9PiB7XHJcbiAgICBpZiAodmlldy5zdGF0ZS5yZWFkT25seSlcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICBsZXQgY2hhbmdlcyA9IHF1ZXJ5Lm1hdGNoQWxsKHZpZXcuc3RhdGUsIDFlOSkubWFwKG1hdGNoID0+IHtcclxuICAgICAgICBsZXQgeyBmcm9tLCB0byB9ID0gbWF0Y2g7XHJcbiAgICAgICAgcmV0dXJuIHsgZnJvbSwgdG8sIGluc2VydDogcXVlcnkuZ2V0UmVwbGFjZW1lbnQobWF0Y2gpIH07XHJcbiAgICB9KTtcclxuICAgIGlmICghY2hhbmdlcy5sZW5ndGgpXHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgbGV0IGFubm91bmNlVGV4dCA9IHZpZXcuc3RhdGUucGhyYXNlKFwicmVwbGFjZWQgJCBtYXRjaGVzXCIsIGNoYW5nZXMubGVuZ3RoKSArIFwiLlwiO1xyXG4gICAgdmlldy5kaXNwYXRjaCh7XHJcbiAgICAgICAgY2hhbmdlcyxcclxuICAgICAgICBlZmZlY3RzOiBFZGl0b3JWaWV3LmFubm91bmNlLm9mKGFubm91bmNlVGV4dCksXHJcbiAgICAgICAgdXNlckV2ZW50OiBcImlucHV0LnJlcGxhY2UuYWxsXCJcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIHRydWU7XHJcbn0pO1xyXG5mdW5jdGlvbiBjcmVhdGVTZWFyY2hQYW5lbCh2aWV3KSB7XHJcbiAgICByZXR1cm4gdmlldy5zdGF0ZS5mYWNldChzZWFyY2hDb25maWdGYWNldCkuY3JlYXRlUGFuZWwodmlldyk7XHJcbn1cclxuZnVuY3Rpb24gZGVmYXVsdFF1ZXJ5KHN0YXRlLCBmYWxsYmFjaykge1xyXG4gICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xyXG4gICAgbGV0IHNlbCA9IHN0YXRlLnNlbGVjdGlvbi5tYWluO1xyXG4gICAgbGV0IHNlbFRleHQgPSBzZWwuZW1wdHkgfHwgc2VsLnRvID4gc2VsLmZyb20gKyAxMDAgPyBcIlwiIDogc3RhdGUuc2xpY2VEb2Moc2VsLmZyb20sIHNlbC50byk7XHJcbiAgICBpZiAoZmFsbGJhY2sgJiYgIXNlbFRleHQpXHJcbiAgICAgICAgcmV0dXJuIGZhbGxiYWNrO1xyXG4gICAgbGV0IGNvbmZpZyA9IHN0YXRlLmZhY2V0KHNlYXJjaENvbmZpZ0ZhY2V0KTtcclxuICAgIHJldHVybiBuZXcgU2VhcmNoUXVlcnkoe1xyXG4gICAgICAgIHNlYXJjaDogKChfYSA9IGZhbGxiYWNrID09PSBudWxsIHx8IGZhbGxiYWNrID09PSB2b2lkIDAgPyB2b2lkIDAgOiBmYWxsYmFjay5saXRlcmFsKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBjb25maWcubGl0ZXJhbCkgPyBzZWxUZXh0IDogc2VsVGV4dC5yZXBsYWNlKC9cXG4vZywgXCJcXFxcblwiKSxcclxuICAgICAgICBjYXNlU2Vuc2l0aXZlOiAoX2IgPSBmYWxsYmFjayA9PT0gbnVsbCB8fCBmYWxsYmFjayA9PT0gdm9pZCAwID8gdm9pZCAwIDogZmFsbGJhY2suY2FzZVNlbnNpdGl2ZSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogY29uZmlnLmNhc2VTZW5zaXRpdmUsXHJcbiAgICAgICAgbGl0ZXJhbDogKF9jID0gZmFsbGJhY2sgPT09IG51bGwgfHwgZmFsbGJhY2sgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGZhbGxiYWNrLmxpdGVyYWwpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IGNvbmZpZy5saXRlcmFsLFxyXG4gICAgICAgIHdob2xlV29yZDogKF9kID0gZmFsbGJhY2sgPT09IG51bGwgfHwgZmFsbGJhY2sgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGZhbGxiYWNrLndob2xlV29yZCkgIT09IG51bGwgJiYgX2QgIT09IHZvaWQgMCA/IF9kIDogY29uZmlnLndob2xlV29yZFxyXG4gICAgfSk7XHJcbn1cclxuLyoqXHJcbk1ha2Ugc3VyZSB0aGUgc2VhcmNoIHBhbmVsIGlzIG9wZW4gYW5kIGZvY3VzZWQuXHJcbiovXHJcbmNvbnN0IG9wZW5TZWFyY2hQYW5lbCA9IHZpZXcgPT4ge1xyXG4gICAgbGV0IHN0YXRlID0gdmlldy5zdGF0ZS5maWVsZChzZWFyY2hTdGF0ZSwgZmFsc2UpO1xyXG4gICAgaWYgKHN0YXRlICYmIHN0YXRlLnBhbmVsKSB7XHJcbiAgICAgICAgbGV0IHBhbmVsID0gZ2V0UGFuZWwodmlldywgY3JlYXRlU2VhcmNoUGFuZWwpO1xyXG4gICAgICAgIGlmICghcGFuZWwpXHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICBsZXQgc2VhcmNoSW5wdXQgPSBwYW5lbC5kb20ucXVlcnlTZWxlY3RvcihcIlttYWluLWZpZWxkXVwiKTtcclxuICAgICAgICBpZiAoc2VhcmNoSW5wdXQgJiYgc2VhcmNoSW5wdXQgIT0gdmlldy5yb290LmFjdGl2ZUVsZW1lbnQpIHtcclxuICAgICAgICAgICAgbGV0IHF1ZXJ5ID0gZGVmYXVsdFF1ZXJ5KHZpZXcuc3RhdGUsIHN0YXRlLnF1ZXJ5LnNwZWMpO1xyXG4gICAgICAgICAgICBpZiAocXVlcnkudmFsaWQpXHJcbiAgICAgICAgICAgICAgICB2aWV3LmRpc3BhdGNoKHsgZWZmZWN0czogc2V0U2VhcmNoUXVlcnkub2YocXVlcnkpIH0pO1xyXG4gICAgICAgICAgICBzZWFyY2hJbnB1dC5mb2N1cygpO1xyXG4gICAgICAgICAgICBzZWFyY2hJbnB1dC5zZWxlY3QoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICB2aWV3LmRpc3BhdGNoKHsgZWZmZWN0czogW1xyXG4gICAgICAgICAgICAgICAgdG9nZ2xlUGFuZWwub2YodHJ1ZSksXHJcbiAgICAgICAgICAgICAgICBzdGF0ZSA/IHNldFNlYXJjaFF1ZXJ5Lm9mKGRlZmF1bHRRdWVyeSh2aWV3LnN0YXRlLCBzdGF0ZS5xdWVyeS5zcGVjKSkgOiBTdGF0ZUVmZmVjdC5hcHBlbmRDb25maWcub2Yoc2VhcmNoRXh0ZW5zaW9ucylcclxuICAgICAgICAgICAgXSB9KTtcclxuICAgIH1cclxuICAgIHJldHVybiB0cnVlO1xyXG59O1xyXG4vKipcclxuQ2xvc2UgdGhlIHNlYXJjaCBwYW5lbC5cclxuKi9cclxuY29uc3QgY2xvc2VTZWFyY2hQYW5lbCA9IHZpZXcgPT4ge1xyXG4gICAgbGV0IHN0YXRlID0gdmlldy5zdGF0ZS5maWVsZChzZWFyY2hTdGF0ZSwgZmFsc2UpO1xyXG4gICAgaWYgKCFzdGF0ZSB8fCAhc3RhdGUucGFuZWwpXHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgbGV0IHBhbmVsID0gZ2V0UGFuZWwodmlldywgY3JlYXRlU2VhcmNoUGFuZWwpO1xyXG4gICAgaWYgKHBhbmVsICYmIHBhbmVsLmRvbS5jb250YWlucyh2aWV3LnJvb3QuYWN0aXZlRWxlbWVudCkpXHJcbiAgICAgICAgdmlldy5mb2N1cygpO1xyXG4gICAgdmlldy5kaXNwYXRjaCh7IGVmZmVjdHM6IHRvZ2dsZVBhbmVsLm9mKGZhbHNlKSB9KTtcclxuICAgIHJldHVybiB0cnVlO1xyXG59O1xyXG4vKipcclxuRGVmYXVsdCBzZWFyY2gtcmVsYXRlZCBrZXkgYmluZGluZ3MuXHJcblxyXG4gLSBNb2QtZjogW2BvcGVuU2VhcmNoUGFuZWxgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3NlYXJjaC5vcGVuU2VhcmNoUGFuZWwpXHJcbiAtIEYzLCBNb2QtZzogW2BmaW5kTmV4dGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc2VhcmNoLmZpbmROZXh0KVxyXG4gLSBTaGlmdC1GMywgU2hpZnQtTW9kLWc6IFtgZmluZFByZXZpb3VzYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzZWFyY2guZmluZFByZXZpb3VzKVxyXG4gLSBBbHQtZzogW2Bnb3RvTGluZWBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc2VhcmNoLmdvdG9MaW5lKVxyXG4gLSBNb2QtZDogW2BzZWxlY3ROZXh0T2NjdXJyZW5jZWBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc2VhcmNoLnNlbGVjdE5leHRPY2N1cnJlbmNlKVxyXG4qL1xyXG5jb25zdCBzZWFyY2hLZXltYXAgPSBbXHJcbiAgICB7IGtleTogXCJNb2QtZlwiLCBydW46IG9wZW5TZWFyY2hQYW5lbCwgc2NvcGU6IFwiZWRpdG9yIHNlYXJjaC1wYW5lbFwiIH0sXHJcbiAgICB7IGtleTogXCJGM1wiLCBydW46IGZpbmROZXh0LCBzaGlmdDogZmluZFByZXZpb3VzLCBzY29wZTogXCJlZGl0b3Igc2VhcmNoLXBhbmVsXCIsIHByZXZlbnREZWZhdWx0OiB0cnVlIH0sXHJcbiAgICB7IGtleTogXCJNb2QtZ1wiLCBydW46IGZpbmROZXh0LCBzaGlmdDogZmluZFByZXZpb3VzLCBzY29wZTogXCJlZGl0b3Igc2VhcmNoLXBhbmVsXCIsIHByZXZlbnREZWZhdWx0OiB0cnVlIH0sXHJcbiAgICB7IGtleTogXCJFc2NhcGVcIiwgcnVuOiBjbG9zZVNlYXJjaFBhbmVsLCBzY29wZTogXCJlZGl0b3Igc2VhcmNoLXBhbmVsXCIgfSxcclxuICAgIHsga2V5OiBcIk1vZC1TaGlmdC1sXCIsIHJ1bjogc2VsZWN0U2VsZWN0aW9uTWF0Y2hlcyB9LFxyXG4gICAgeyBrZXk6IFwiQWx0LWdcIiwgcnVuOiBnb3RvTGluZSB9LFxyXG4gICAgeyBrZXk6IFwiTW9kLWRcIiwgcnVuOiBzZWxlY3ROZXh0T2NjdXJyZW5jZSwgcHJldmVudERlZmF1bHQ6IHRydWUgfSxcclxuXTtcclxuY2xhc3MgU2VhcmNoUGFuZWwge1xyXG4gICAgY29uc3RydWN0b3Iodmlldykge1xyXG4gICAgICAgIHRoaXMudmlldyA9IHZpZXc7XHJcbiAgICAgICAgbGV0IHF1ZXJ5ID0gdGhpcy5xdWVyeSA9IHZpZXcuc3RhdGUuZmllbGQoc2VhcmNoU3RhdGUpLnF1ZXJ5LnNwZWM7XHJcbiAgICAgICAgdGhpcy5jb21taXQgPSB0aGlzLmNvbW1pdC5iaW5kKHRoaXMpO1xyXG4gICAgICAgIHRoaXMuc2VhcmNoRmllbGQgPSBlbHQoXCJpbnB1dFwiLCB7XHJcbiAgICAgICAgICAgIHZhbHVlOiBxdWVyeS5zZWFyY2gsXHJcbiAgICAgICAgICAgIHBsYWNlaG9sZGVyOiBwaHJhc2UodmlldywgXCJGaW5kXCIpLFxyXG4gICAgICAgICAgICBcImFyaWEtbGFiZWxcIjogcGhyYXNlKHZpZXcsIFwiRmluZFwiKSxcclxuICAgICAgICAgICAgY2xhc3M6IFwiY20tdGV4dGZpZWxkXCIsXHJcbiAgICAgICAgICAgIG5hbWU6IFwic2VhcmNoXCIsXHJcbiAgICAgICAgICAgIGZvcm06IFwiXCIsXHJcbiAgICAgICAgICAgIFwibWFpbi1maWVsZFwiOiBcInRydWVcIixcclxuICAgICAgICAgICAgb25jaGFuZ2U6IHRoaXMuY29tbWl0LFxyXG4gICAgICAgICAgICBvbmtleXVwOiB0aGlzLmNvbW1pdFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMucmVwbGFjZUZpZWxkID0gZWx0KFwiaW5wdXRcIiwge1xyXG4gICAgICAgICAgICB2YWx1ZTogcXVlcnkucmVwbGFjZSxcclxuICAgICAgICAgICAgcGxhY2Vob2xkZXI6IHBocmFzZSh2aWV3LCBcIlJlcGxhY2VcIiksXHJcbiAgICAgICAgICAgIFwiYXJpYS1sYWJlbFwiOiBwaHJhc2UodmlldywgXCJSZXBsYWNlXCIpLFxyXG4gICAgICAgICAgICBjbGFzczogXCJjbS10ZXh0ZmllbGRcIixcclxuICAgICAgICAgICAgbmFtZTogXCJyZXBsYWNlXCIsXHJcbiAgICAgICAgICAgIGZvcm06IFwiXCIsXHJcbiAgICAgICAgICAgIG9uY2hhbmdlOiB0aGlzLmNvbW1pdCxcclxuICAgICAgICAgICAgb25rZXl1cDogdGhpcy5jb21taXRcclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLmNhc2VGaWVsZCA9IGVsdChcImlucHV0XCIsIHtcclxuICAgICAgICAgICAgdHlwZTogXCJjaGVja2JveFwiLFxyXG4gICAgICAgICAgICBuYW1lOiBcImNhc2VcIixcclxuICAgICAgICAgICAgZm9ybTogXCJcIixcclxuICAgICAgICAgICAgY2hlY2tlZDogcXVlcnkuY2FzZVNlbnNpdGl2ZSxcclxuICAgICAgICAgICAgb25jaGFuZ2U6IHRoaXMuY29tbWl0XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5yZUZpZWxkID0gZWx0KFwiaW5wdXRcIiwge1xyXG4gICAgICAgICAgICB0eXBlOiBcImNoZWNrYm94XCIsXHJcbiAgICAgICAgICAgIG5hbWU6IFwicmVcIixcclxuICAgICAgICAgICAgZm9ybTogXCJcIixcclxuICAgICAgICAgICAgY2hlY2tlZDogcXVlcnkucmVnZXhwLFxyXG4gICAgICAgICAgICBvbmNoYW5nZTogdGhpcy5jb21taXRcclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLndvcmRGaWVsZCA9IGVsdChcImlucHV0XCIsIHtcclxuICAgICAgICAgICAgdHlwZTogXCJjaGVja2JveFwiLFxyXG4gICAgICAgICAgICBuYW1lOiBcIndvcmRcIixcclxuICAgICAgICAgICAgZm9ybTogXCJcIixcclxuICAgICAgICAgICAgY2hlY2tlZDogcXVlcnkud2hvbGVXb3JkLFxyXG4gICAgICAgICAgICBvbmNoYW5nZTogdGhpcy5jb21taXRcclxuICAgICAgICB9KTtcclxuICAgICAgICBmdW5jdGlvbiBidXR0b24obmFtZSwgb25jbGljaywgY29udGVudCkge1xyXG4gICAgICAgICAgICByZXR1cm4gZWx0KFwiYnV0dG9uXCIsIHsgY2xhc3M6IFwiY20tYnV0dG9uXCIsIG5hbWUsIG9uY2xpY2ssIHR5cGU6IFwiYnV0dG9uXCIgfSwgY29udGVudCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuZG9tID0gZWx0KFwiZGl2XCIsIHsgb25rZXlkb3duOiAoZSkgPT4gdGhpcy5rZXlkb3duKGUpLCBjbGFzczogXCJjbS1zZWFyY2hcIiB9LCBbXHJcbiAgICAgICAgICAgIHRoaXMuc2VhcmNoRmllbGQsXHJcbiAgICAgICAgICAgIGJ1dHRvbihcIm5leHRcIiwgKCkgPT4gZmluZE5leHQodmlldyksIFtwaHJhc2UodmlldywgXCJuZXh0XCIpXSksXHJcbiAgICAgICAgICAgIGJ1dHRvbihcInByZXZcIiwgKCkgPT4gZmluZFByZXZpb3VzKHZpZXcpLCBbcGhyYXNlKHZpZXcsIFwicHJldmlvdXNcIildKSxcclxuICAgICAgICAgICAgYnV0dG9uKFwic2VsZWN0XCIsICgpID0+IHNlbGVjdE1hdGNoZXModmlldyksIFtwaHJhc2UodmlldywgXCJhbGxcIildKSxcclxuICAgICAgICAgICAgZWx0KFwibGFiZWxcIiwgbnVsbCwgW3RoaXMuY2FzZUZpZWxkLCBwaHJhc2UodmlldywgXCJtYXRjaCBjYXNlXCIpXSksXHJcbiAgICAgICAgICAgIGVsdChcImxhYmVsXCIsIG51bGwsIFt0aGlzLnJlRmllbGQsIHBocmFzZSh2aWV3LCBcInJlZ2V4cFwiKV0pLFxyXG4gICAgICAgICAgICBlbHQoXCJsYWJlbFwiLCBudWxsLCBbdGhpcy53b3JkRmllbGQsIHBocmFzZSh2aWV3LCBcImJ5IHdvcmRcIildKSxcclxuICAgICAgICAgICAgLi4udmlldy5zdGF0ZS5yZWFkT25seSA/IFtdIDogW1xyXG4gICAgICAgICAgICAgICAgZWx0KFwiYnJcIiksXHJcbiAgICAgICAgICAgICAgICB0aGlzLnJlcGxhY2VGaWVsZCxcclxuICAgICAgICAgICAgICAgIGJ1dHRvbihcInJlcGxhY2VcIiwgKCkgPT4gcmVwbGFjZU5leHQodmlldyksIFtwaHJhc2UodmlldywgXCJyZXBsYWNlXCIpXSksXHJcbiAgICAgICAgICAgICAgICBidXR0b24oXCJyZXBsYWNlQWxsXCIsICgpID0+IHJlcGxhY2VBbGwodmlldyksIFtwaHJhc2UodmlldywgXCJyZXBsYWNlIGFsbFwiKV0pXHJcbiAgICAgICAgICAgIF0sXHJcbiAgICAgICAgICAgIGVsdChcImJ1dHRvblwiLCB7XHJcbiAgICAgICAgICAgICAgICBuYW1lOiBcImNsb3NlXCIsXHJcbiAgICAgICAgICAgICAgICBvbmNsaWNrOiAoKSA9PiBjbG9zZVNlYXJjaFBhbmVsKHZpZXcpLFxyXG4gICAgICAgICAgICAgICAgXCJhcmlhLWxhYmVsXCI6IHBocmFzZSh2aWV3LCBcImNsb3NlXCIpLFxyXG4gICAgICAgICAgICAgICAgdHlwZTogXCJidXR0b25cIlxyXG4gICAgICAgICAgICB9LCBbXCLDl1wiXSlcclxuICAgICAgICBdKTtcclxuICAgIH1cclxuICAgIGNvbW1pdCgpIHtcclxuICAgICAgICBsZXQgcXVlcnkgPSBuZXcgU2VhcmNoUXVlcnkoe1xyXG4gICAgICAgICAgICBzZWFyY2g6IHRoaXMuc2VhcmNoRmllbGQudmFsdWUsXHJcbiAgICAgICAgICAgIGNhc2VTZW5zaXRpdmU6IHRoaXMuY2FzZUZpZWxkLmNoZWNrZWQsXHJcbiAgICAgICAgICAgIHJlZ2V4cDogdGhpcy5yZUZpZWxkLmNoZWNrZWQsXHJcbiAgICAgICAgICAgIHdob2xlV29yZDogdGhpcy53b3JkRmllbGQuY2hlY2tlZCxcclxuICAgICAgICAgICAgcmVwbGFjZTogdGhpcy5yZXBsYWNlRmllbGQudmFsdWUsXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgaWYgKCFxdWVyeS5lcSh0aGlzLnF1ZXJ5KSkge1xyXG4gICAgICAgICAgICB0aGlzLnF1ZXJ5ID0gcXVlcnk7XHJcbiAgICAgICAgICAgIHRoaXMudmlldy5kaXNwYXRjaCh7IGVmZmVjdHM6IHNldFNlYXJjaFF1ZXJ5Lm9mKHF1ZXJ5KSB9KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBrZXlkb3duKGUpIHtcclxuICAgICAgICBpZiAocnVuU2NvcGVIYW5kbGVycyh0aGlzLnZpZXcsIGUsIFwic2VhcmNoLXBhbmVsXCIpKSB7XHJcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoZS5rZXlDb2RlID09IDEzICYmIGUudGFyZ2V0ID09IHRoaXMuc2VhcmNoRmllbGQpIHtcclxuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgICAgICAoZS5zaGlmdEtleSA/IGZpbmRQcmV2aW91cyA6IGZpbmROZXh0KSh0aGlzLnZpZXcpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChlLmtleUNvZGUgPT0gMTMgJiYgZS50YXJnZXQgPT0gdGhpcy5yZXBsYWNlRmllbGQpIHtcclxuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgICAgICByZXBsYWNlTmV4dCh0aGlzLnZpZXcpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHVwZGF0ZSh1cGRhdGUpIHtcclxuICAgICAgICBmb3IgKGxldCB0ciBvZiB1cGRhdGUudHJhbnNhY3Rpb25zKVxyXG4gICAgICAgICAgICBmb3IgKGxldCBlZmZlY3Qgb2YgdHIuZWZmZWN0cykge1xyXG4gICAgICAgICAgICAgICAgaWYgKGVmZmVjdC5pcyhzZXRTZWFyY2hRdWVyeSkgJiYgIWVmZmVjdC52YWx1ZS5lcSh0aGlzLnF1ZXJ5KSlcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldFF1ZXJ5KGVmZmVjdC52YWx1ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgIH1cclxuICAgIHNldFF1ZXJ5KHF1ZXJ5KSB7XHJcbiAgICAgICAgdGhpcy5xdWVyeSA9IHF1ZXJ5O1xyXG4gICAgICAgIHRoaXMuc2VhcmNoRmllbGQudmFsdWUgPSBxdWVyeS5zZWFyY2g7XHJcbiAgICAgICAgdGhpcy5yZXBsYWNlRmllbGQudmFsdWUgPSBxdWVyeS5yZXBsYWNlO1xyXG4gICAgICAgIHRoaXMuY2FzZUZpZWxkLmNoZWNrZWQgPSBxdWVyeS5jYXNlU2Vuc2l0aXZlO1xyXG4gICAgICAgIHRoaXMucmVGaWVsZC5jaGVja2VkID0gcXVlcnkucmVnZXhwO1xyXG4gICAgICAgIHRoaXMud29yZEZpZWxkLmNoZWNrZWQgPSBxdWVyeS53aG9sZVdvcmQ7XHJcbiAgICB9XHJcbiAgICBtb3VudCgpIHtcclxuICAgICAgICB0aGlzLnNlYXJjaEZpZWxkLnNlbGVjdCgpO1xyXG4gICAgfVxyXG4gICAgZ2V0IHBvcygpIHsgcmV0dXJuIDgwOyB9XHJcbiAgICBnZXQgdG9wKCkgeyByZXR1cm4gdGhpcy52aWV3LnN0YXRlLmZhY2V0KHNlYXJjaENvbmZpZ0ZhY2V0KS50b3A7IH1cclxufVxyXG5mdW5jdGlvbiBwaHJhc2UodmlldywgcGhyYXNlKSB7IHJldHVybiB2aWV3LnN0YXRlLnBocmFzZShwaHJhc2UpOyB9XHJcbmNvbnN0IEFubm91bmNlTWFyZ2luID0gMzA7XHJcbmNvbnN0IEJyZWFrID0gL1tcXHNcXC4sOjs/IV0vO1xyXG5mdW5jdGlvbiBhbm5vdW5jZU1hdGNoKHZpZXcsIHsgZnJvbSwgdG8gfSkge1xyXG4gICAgbGV0IGxpbmUgPSB2aWV3LnN0YXRlLmRvYy5saW5lQXQoZnJvbSksIGxpbmVFbmQgPSB2aWV3LnN0YXRlLmRvYy5saW5lQXQodG8pLnRvO1xyXG4gICAgbGV0IHN0YXJ0ID0gTWF0aC5tYXgobGluZS5mcm9tLCBmcm9tIC0gQW5ub3VuY2VNYXJnaW4pLCBlbmQgPSBNYXRoLm1pbihsaW5lRW5kLCB0byArIEFubm91bmNlTWFyZ2luKTtcclxuICAgIGxldCB0ZXh0ID0gdmlldy5zdGF0ZS5zbGljZURvYyhzdGFydCwgZW5kKTtcclxuICAgIGlmIChzdGFydCAhPSBsaW5lLmZyb20pIHtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IEFubm91bmNlTWFyZ2luOyBpKyspXHJcbiAgICAgICAgICAgIGlmICghQnJlYWsudGVzdCh0ZXh0W2kgKyAxXSkgJiYgQnJlYWsudGVzdCh0ZXh0W2ldKSkge1xyXG4gICAgICAgICAgICAgICAgdGV4dCA9IHRleHQuc2xpY2UoaSk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKGVuZCAhPSBsaW5lRW5kKSB7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IHRleHQubGVuZ3RoIC0gMTsgaSA+IHRleHQubGVuZ3RoIC0gQW5ub3VuY2VNYXJnaW47IGktLSlcclxuICAgICAgICAgICAgaWYgKCFCcmVhay50ZXN0KHRleHRbaSAtIDFdKSAmJiBCcmVhay50ZXN0KHRleHRbaV0pKSB7XHJcbiAgICAgICAgICAgICAgICB0ZXh0ID0gdGV4dC5zbGljZSgwLCBpKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gRWRpdG9yVmlldy5hbm5vdW5jZS5vZihgJHt2aWV3LnN0YXRlLnBocmFzZShcImN1cnJlbnQgbWF0Y2hcIil9LiAke3RleHR9ICR7dmlldy5zdGF0ZS5waHJhc2UoXCJvbiBsaW5lXCIpfSAke2xpbmUubnVtYmVyfS5gKTtcclxufVxyXG5jb25zdCBiYXNlVGhlbWUgPSAvKkBfX1BVUkVfXyovRWRpdG9yVmlldy5iYXNlVGhlbWUoe1xyXG4gICAgXCIuY20tcGFuZWwuY20tc2VhcmNoXCI6IHtcclxuICAgICAgICBwYWRkaW5nOiBcIjJweCA2cHggNHB4XCIsXHJcbiAgICAgICAgcG9zaXRpb246IFwicmVsYXRpdmVcIixcclxuICAgICAgICBcIiYgW25hbWU9Y2xvc2VdXCI6IHtcclxuICAgICAgICAgICAgcG9zaXRpb246IFwiYWJzb2x1dGVcIixcclxuICAgICAgICAgICAgdG9wOiBcIjBcIixcclxuICAgICAgICAgICAgcmlnaHQ6IFwiNHB4XCIsXHJcbiAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogXCJpbmhlcml0XCIsXHJcbiAgICAgICAgICAgIGJvcmRlcjogXCJub25lXCIsXHJcbiAgICAgICAgICAgIGZvbnQ6IFwiaW5oZXJpdFwiLFxyXG4gICAgICAgICAgICBwYWRkaW5nOiAwLFxyXG4gICAgICAgICAgICBtYXJnaW46IDBcclxuICAgICAgICB9LFxyXG4gICAgICAgIFwiJiBpbnB1dCwgJiBidXR0b24sICYgbGFiZWxcIjoge1xyXG4gICAgICAgICAgICBtYXJnaW46IFwiLjJlbSAuNmVtIC4yZW0gMFwiXHJcbiAgICAgICAgfSxcclxuICAgICAgICBcIiYgaW5wdXRbdHlwZT1jaGVja2JveF1cIjoge1xyXG4gICAgICAgICAgICBtYXJnaW5SaWdodDogXCIuMmVtXCJcclxuICAgICAgICB9LFxyXG4gICAgICAgIFwiJiBsYWJlbFwiOiB7XHJcbiAgICAgICAgICAgIGZvbnRTaXplOiBcIjgwJVwiLFxyXG4gICAgICAgICAgICB3aGl0ZVNwYWNlOiBcInByZVwiXHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIFwiJmxpZ2h0IC5jbS1zZWFyY2hNYXRjaFwiOiB7IGJhY2tncm91bmRDb2xvcjogXCIjZmZmZjAwNTRcIiB9LFxyXG4gICAgXCImZGFyayAuY20tc2VhcmNoTWF0Y2hcIjogeyBiYWNrZ3JvdW5kQ29sb3I6IFwiIzAwZmZmZjhhXCIgfSxcclxuICAgIFwiJmxpZ2h0IC5jbS1zZWFyY2hNYXRjaC1zZWxlY3RlZFwiOiB7IGJhY2tncm91bmRDb2xvcjogXCIjZmY2YTAwNTRcIiB9LFxyXG4gICAgXCImZGFyayAuY20tc2VhcmNoTWF0Y2gtc2VsZWN0ZWRcIjogeyBiYWNrZ3JvdW5kQ29sb3I6IFwiI2ZmMDBmZjhhXCIgfVxyXG59KTtcclxuY29uc3Qgc2VhcmNoRXh0ZW5zaW9ucyA9IFtcclxuICAgIHNlYXJjaFN0YXRlLFxyXG4gICAgLypAX19QVVJFX18qL1ByZWMubG93ZXN0KHNlYXJjaEhpZ2hsaWdodGVyKSxcclxuICAgIGJhc2VUaGVtZVxyXG5dO1xyXG5cclxuZXhwb3J0IHsgUmVnRXhwQ3Vyc29yLCBTZWFyY2hDdXJzb3IsIFNlYXJjaFF1ZXJ5LCBjbG9zZVNlYXJjaFBhbmVsLCBmaW5kTmV4dCwgZmluZFByZXZpb3VzLCBnZXRTZWFyY2hRdWVyeSwgZ290b0xpbmUsIGhpZ2hsaWdodFNlbGVjdGlvbk1hdGNoZXMsIG9wZW5TZWFyY2hQYW5lbCwgcmVwbGFjZUFsbCwgcmVwbGFjZU5leHQsIHNlYXJjaCwgc2VhcmNoS2V5bWFwLCBzZWFyY2hQYW5lbE9wZW4sIHNlbGVjdE1hdGNoZXMsIHNlbGVjdE5leHRPY2N1cnJlbmNlLCBzZWxlY3RTZWxlY3Rpb25NYXRjaGVzLCBzZXRTZWFyY2hRdWVyeSB9O1xyXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@codemirror/search/dist/index.js\n"));

/***/ }),

/***/ "./node_modules/@codemirror/state/dist/index.js":
/*!******************************************************!*\
  !*** ./node_modules/@codemirror/state/dist/index.js ***!
  \******************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Annotation\": function() { return /* binding */ Annotation; },\n/* harmony export */   \"AnnotationType\": function() { return /* binding */ AnnotationType; },\n/* harmony export */   \"ChangeDesc\": function() { return /* binding */ ChangeDesc; },\n/* harmony export */   \"ChangeSet\": function() { return /* binding */ ChangeSet; },\n/* harmony export */   \"CharCategory\": function() { return /* binding */ CharCategory; },\n/* harmony export */   \"Compartment\": function() { return /* binding */ Compartment; },\n/* harmony export */   \"EditorSelection\": function() { return /* binding */ EditorSelection; },\n/* harmony export */   \"EditorState\": function() { return /* binding */ EditorState; },\n/* harmony export */   \"Facet\": function() { return /* binding */ Facet; },\n/* harmony export */   \"Line\": function() { return /* binding */ Line; },\n/* harmony export */   \"MapMode\": function() { return /* binding */ MapMode; },\n/* harmony export */   \"Prec\": function() { return /* binding */ Prec; },\n/* harmony export */   \"Range\": function() { return /* binding */ Range; },\n/* harmony export */   \"RangeSet\": function() { return /* binding */ RangeSet; },\n/* harmony export */   \"RangeSetBuilder\": function() { return /* binding */ RangeSetBuilder; },\n/* harmony export */   \"RangeValue\": function() { return /* binding */ RangeValue; },\n/* harmony export */   \"SelectionRange\": function() { return /* binding */ SelectionRange; },\n/* harmony export */   \"StateEffect\": function() { return /* binding */ StateEffect; },\n/* harmony export */   \"StateEffectType\": function() { return /* binding */ StateEffectType; },\n/* harmony export */   \"StateField\": function() { return /* binding */ StateField; },\n/* harmony export */   \"Text\": function() { return /* binding */ Text; },\n/* harmony export */   \"Transaction\": function() { return /* binding */ Transaction; },\n/* harmony export */   \"codePointAt\": function() { return /* binding */ codePointAt; },\n/* harmony export */   \"codePointSize\": function() { return /* binding */ codePointSize; },\n/* harmony export */   \"combineConfig\": function() { return /* binding */ combineConfig; },\n/* harmony export */   \"countColumn\": function() { return /* binding */ countColumn; },\n/* harmony export */   \"findClusterBreak\": function() { return /* binding */ findClusterBreak; },\n/* harmony export */   \"findColumn\": function() { return /* binding */ findColumn; },\n/* harmony export */   \"fromCodePoint\": function() { return /* binding */ fromCodePoint; }\n/* harmony export */ });\n/**\r\nThe data structure for documents. @nonabstract\r\n*/\r\nclass Text {\r\n    /**\r\n    @internal\r\n    */\r\n    constructor() { }\r\n    /**\r\n    Get the line description around the given position.\r\n    */\r\n    lineAt(pos) {\r\n        if (pos < 0 || pos > this.length)\r\n            throw new RangeError(`Invalid position ${pos} in document of length ${this.length}`);\r\n        return this.lineInner(pos, false, 1, 0);\r\n    }\r\n    /**\r\n    Get the description for the given (1-based) line number.\r\n    */\r\n    line(n) {\r\n        if (n < 1 || n > this.lines)\r\n            throw new RangeError(`Invalid line number ${n} in ${this.lines}-line document`);\r\n        return this.lineInner(n, true, 1, 0);\r\n    }\r\n    /**\r\n    Replace a range of the text with the given content.\r\n    */\r\n    replace(from, to, text) {\r\n        let parts = [];\r\n        this.decompose(0, from, parts, 2 /* Open.To */);\r\n        if (text.length)\r\n            text.decompose(0, text.length, parts, 1 /* Open.From */ | 2 /* Open.To */);\r\n        this.decompose(to, this.length, parts, 1 /* Open.From */);\r\n        return TextNode.from(parts, this.length - (to - from) + text.length);\r\n    }\r\n    /**\r\n    Append another document to this one.\r\n    */\r\n    append(other) {\r\n        return this.replace(this.length, this.length, other);\r\n    }\r\n    /**\r\n    Retrieve the text between the given points.\r\n    */\r\n    slice(from, to = this.length) {\r\n        let parts = [];\r\n        this.decompose(from, to, parts, 0);\r\n        return TextNode.from(parts, to - from);\r\n    }\r\n    /**\r\n    Test whether this text is equal to another instance.\r\n    */\r\n    eq(other) {\r\n        if (other == this)\r\n            return true;\r\n        if (other.length != this.length || other.lines != this.lines)\r\n            return false;\r\n        let start = this.scanIdentical(other, 1), end = this.length - this.scanIdentical(other, -1);\r\n        let a = new RawTextCursor(this), b = new RawTextCursor(other);\r\n        for (let skip = start, pos = start;;) {\r\n            a.next(skip);\r\n            b.next(skip);\r\n            skip = 0;\r\n            if (a.lineBreak != b.lineBreak || a.done != b.done || a.value != b.value)\r\n                return false;\r\n            pos += a.value.length;\r\n            if (a.done || pos >= end)\r\n                return true;\r\n        }\r\n    }\r\n    /**\r\n    Iterate over the text. When `dir` is `-1`, iteration happens\r\n    from end to start. This will return lines and the breaks between\r\n    them as separate strings.\r\n    */\r\n    iter(dir = 1) { return new RawTextCursor(this, dir); }\r\n    /**\r\n    Iterate over a range of the text. When `from` > `to`, the\r\n    iterator will run in reverse.\r\n    */\r\n    iterRange(from, to = this.length) { return new PartialTextCursor(this, from, to); }\r\n    /**\r\n    Return a cursor that iterates over the given range of lines,\r\n    _without_ returning the line breaks between, and yielding empty\r\n    strings for empty lines.\r\n    \r\n    When `from` and `to` are given, they should be 1-based line numbers.\r\n    */\r\n    iterLines(from, to) {\r\n        let inner;\r\n        if (from == null) {\r\n            inner = this.iter();\r\n        }\r\n        else {\r\n            if (to == null)\r\n                to = this.lines + 1;\r\n            let start = this.line(from).from;\r\n            inner = this.iterRange(start, Math.max(start, to == this.lines + 1 ? this.length : to <= 1 ? 0 : this.line(to - 1).to));\r\n        }\r\n        return new LineCursor(inner);\r\n    }\r\n    /**\r\n    @internal\r\n    */\r\n    toString() { return this.sliceString(0); }\r\n    /**\r\n    Convert the document to an array of lines (which can be\r\n    deserialized again via [`Text.of`](https://codemirror.net/6/docs/ref/#state.Text^of)).\r\n    */\r\n    toJSON() {\r\n        let lines = [];\r\n        this.flatten(lines);\r\n        return lines;\r\n    }\r\n    /**\r\n    Create a `Text` instance for the given array of lines.\r\n    */\r\n    static of(text) {\r\n        if (text.length == 0)\r\n            throw new RangeError(\"A document must have at least one line\");\r\n        if (text.length == 1 && !text[0])\r\n            return Text.empty;\r\n        return text.length <= 32 /* Tree.Branch */ ? new TextLeaf(text) : TextNode.from(TextLeaf.split(text, []));\r\n    }\r\n}\r\n// Leaves store an array of line strings. There are always line breaks\r\n// between these strings. Leaves are limited in size and have to be\r\n// contained in TextNode instances for bigger documents.\r\nclass TextLeaf extends Text {\r\n    constructor(text, length = textLength(text)) {\r\n        super();\r\n        this.text = text;\r\n        this.length = length;\r\n    }\r\n    get lines() { return this.text.length; }\r\n    get children() { return null; }\r\n    lineInner(target, isLine, line, offset) {\r\n        for (let i = 0;; i++) {\r\n            let string = this.text[i], end = offset + string.length;\r\n            if ((isLine ? line : end) >= target)\r\n                return new Line(offset, end, line, string);\r\n            offset = end + 1;\r\n            line++;\r\n        }\r\n    }\r\n    decompose(from, to, target, open) {\r\n        let text = from <= 0 && to >= this.length ? this\r\n            : new TextLeaf(sliceText(this.text, from, to), Math.min(to, this.length) - Math.max(0, from));\r\n        if (open & 1 /* Open.From */) {\r\n            let prev = target.pop();\r\n            let joined = appendText(text.text, prev.text.slice(), 0, text.length);\r\n            if (joined.length <= 32 /* Tree.Branch */) {\r\n                target.push(new TextLeaf(joined, prev.length + text.length));\r\n            }\r\n            else {\r\n                let mid = joined.length >> 1;\r\n                target.push(new TextLeaf(joined.slice(0, mid)), new TextLeaf(joined.slice(mid)));\r\n            }\r\n        }\r\n        else {\r\n            target.push(text);\r\n        }\r\n    }\r\n    replace(from, to, text) {\r\n        if (!(text instanceof TextLeaf))\r\n            return super.replace(from, to, text);\r\n        let lines = appendText(this.text, appendText(text.text, sliceText(this.text, 0, from)), to);\r\n        let newLen = this.length + text.length - (to - from);\r\n        if (lines.length <= 32 /* Tree.Branch */)\r\n            return new TextLeaf(lines, newLen);\r\n        return TextNode.from(TextLeaf.split(lines, []), newLen);\r\n    }\r\n    sliceString(from, to = this.length, lineSep = \"\\n\") {\r\n        let result = \"\";\r\n        for (let pos = 0, i = 0; pos <= to && i < this.text.length; i++) {\r\n            let line = this.text[i], end = pos + line.length;\r\n            if (pos > from && i)\r\n                result += lineSep;\r\n            if (from < end && to > pos)\r\n                result += line.slice(Math.max(0, from - pos), to - pos);\r\n            pos = end + 1;\r\n        }\r\n        return result;\r\n    }\r\n    flatten(target) {\r\n        for (let line of this.text)\r\n            target.push(line);\r\n    }\r\n    scanIdentical() { return 0; }\r\n    static split(text, target) {\r\n        let part = [], len = -1;\r\n        for (let line of text) {\r\n            part.push(line);\r\n            len += line.length + 1;\r\n            if (part.length == 32 /* Tree.Branch */) {\r\n                target.push(new TextLeaf(part, len));\r\n                part = [];\r\n                len = -1;\r\n            }\r\n        }\r\n        if (len > -1)\r\n            target.push(new TextLeaf(part, len));\r\n        return target;\r\n    }\r\n}\r\n// Nodes provide the tree structure of the `Text` type. They store a\r\n// number of other nodes or leaves, taking care to balance themselves\r\n// on changes. There are implied line breaks _between_ the children of\r\n// a node (but not before the first or after the last child).\r\nclass TextNode extends Text {\r\n    constructor(children, length) {\r\n        super();\r\n        this.children = children;\r\n        this.length = length;\r\n        this.lines = 0;\r\n        for (let child of children)\r\n            this.lines += child.lines;\r\n    }\r\n    lineInner(target, isLine, line, offset) {\r\n        for (let i = 0;; i++) {\r\n            let child = this.children[i], end = offset + child.length, endLine = line + child.lines - 1;\r\n            if ((isLine ? endLine : end) >= target)\r\n                return child.lineInner(target, isLine, line, offset);\r\n            offset = end + 1;\r\n            line = endLine + 1;\r\n        }\r\n    }\r\n    decompose(from, to, target, open) {\r\n        for (let i = 0, pos = 0; pos <= to && i < this.children.length; i++) {\r\n            let child = this.children[i], end = pos + child.length;\r\n            if (from <= end && to >= pos) {\r\n                let childOpen = open & ((pos <= from ? 1 /* Open.From */ : 0) | (end >= to ? 2 /* Open.To */ : 0));\r\n                if (pos >= from && end <= to && !childOpen)\r\n                    target.push(child);\r\n                else\r\n                    child.decompose(from - pos, to - pos, target, childOpen);\r\n            }\r\n            pos = end + 1;\r\n        }\r\n    }\r\n    replace(from, to, text) {\r\n        if (text.lines < this.lines)\r\n            for (let i = 0, pos = 0; i < this.children.length; i++) {\r\n                let child = this.children[i], end = pos + child.length;\r\n                // Fast path: if the change only affects one child and the\r\n                // child's size remains in the acceptable range, only update\r\n                // that child\r\n                if (from >= pos && to <= end) {\r\n                    let updated = child.replace(from - pos, to - pos, text);\r\n                    let totalLines = this.lines - child.lines + updated.lines;\r\n                    if (updated.lines < (totalLines >> (5 /* Tree.BranchShift */ - 1)) &&\r\n                        updated.lines > (totalLines >> (5 /* Tree.BranchShift */ + 1))) {\r\n                        let copy = this.children.slice();\r\n                        copy[i] = updated;\r\n                        return new TextNode(copy, this.length - (to - from) + text.length);\r\n                    }\r\n                    return super.replace(pos, end, updated);\r\n                }\r\n                pos = end + 1;\r\n            }\r\n        return super.replace(from, to, text);\r\n    }\r\n    sliceString(from, to = this.length, lineSep = \"\\n\") {\r\n        let result = \"\";\r\n        for (let i = 0, pos = 0; i < this.children.length && pos <= to; i++) {\r\n            let child = this.children[i], end = pos + child.length;\r\n            if (pos > from && i)\r\n                result += lineSep;\r\n            if (from < end && to > pos)\r\n                result += child.sliceString(from - pos, to - pos, lineSep);\r\n            pos = end + 1;\r\n        }\r\n        return result;\r\n    }\r\n    flatten(target) {\r\n        for (let child of this.children)\r\n            child.flatten(target);\r\n    }\r\n    scanIdentical(other, dir) {\r\n        if (!(other instanceof TextNode))\r\n            return 0;\r\n        let length = 0;\r\n        let [iA, iB, eA, eB] = dir > 0 ? [0, 0, this.children.length, other.children.length]\r\n            : [this.children.length - 1, other.children.length - 1, -1, -1];\r\n        for (;; iA += dir, iB += dir) {\r\n            if (iA == eA || iB == eB)\r\n                return length;\r\n            let chA = this.children[iA], chB = other.children[iB];\r\n            if (chA != chB)\r\n                return length + chA.scanIdentical(chB, dir);\r\n            length += chA.length + 1;\r\n        }\r\n    }\r\n    static from(children, length = children.reduce((l, ch) => l + ch.length + 1, -1)) {\r\n        let lines = 0;\r\n        for (let ch of children)\r\n            lines += ch.lines;\r\n        if (lines < 32 /* Tree.Branch */) {\r\n            let flat = [];\r\n            for (let ch of children)\r\n                ch.flatten(flat);\r\n            return new TextLeaf(flat, length);\r\n        }\r\n        let chunk = Math.max(32 /* Tree.Branch */, lines >> 5 /* Tree.BranchShift */), maxChunk = chunk << 1, minChunk = chunk >> 1;\r\n        let chunked = [], currentLines = 0, currentLen = -1, currentChunk = [];\r\n        function add(child) {\r\n            let last;\r\n            if (child.lines > maxChunk && child instanceof TextNode) {\r\n                for (let node of child.children)\r\n                    add(node);\r\n            }\r\n            else if (child.lines > minChunk && (currentLines > minChunk || !currentLines)) {\r\n                flush();\r\n                chunked.push(child);\r\n            }\r\n            else if (child instanceof TextLeaf && currentLines &&\r\n                (last = currentChunk[currentChunk.length - 1]) instanceof TextLeaf &&\r\n                child.lines + last.lines <= 32 /* Tree.Branch */) {\r\n                currentLines += child.lines;\r\n                currentLen += child.length + 1;\r\n                currentChunk[currentChunk.length - 1] = new TextLeaf(last.text.concat(child.text), last.length + 1 + child.length);\r\n            }\r\n            else {\r\n                if (currentLines + child.lines > chunk)\r\n                    flush();\r\n                currentLines += child.lines;\r\n                currentLen += child.length + 1;\r\n                currentChunk.push(child);\r\n            }\r\n        }\r\n        function flush() {\r\n            if (currentLines == 0)\r\n                return;\r\n            chunked.push(currentChunk.length == 1 ? currentChunk[0] : TextNode.from(currentChunk, currentLen));\r\n            currentLen = -1;\r\n            currentLines = currentChunk.length = 0;\r\n        }\r\n        for (let child of children)\r\n            add(child);\r\n        flush();\r\n        return chunked.length == 1 ? chunked[0] : new TextNode(chunked, length);\r\n    }\r\n}\r\nText.empty = /*@__PURE__*/new TextLeaf([\"\"], 0);\r\nfunction textLength(text) {\r\n    let length = -1;\r\n    for (let line of text)\r\n        length += line.length + 1;\r\n    return length;\r\n}\r\nfunction appendText(text, target, from = 0, to = 1e9) {\r\n    for (let pos = 0, i = 0, first = true; i < text.length && pos <= to; i++) {\r\n        let line = text[i], end = pos + line.length;\r\n        if (end >= from) {\r\n            if (end > to)\r\n                line = line.slice(0, to - pos);\r\n            if (pos < from)\r\n                line = line.slice(from - pos);\r\n            if (first) {\r\n                target[target.length - 1] += line;\r\n                first = false;\r\n            }\r\n            else\r\n                target.push(line);\r\n        }\r\n        pos = end + 1;\r\n    }\r\n    return target;\r\n}\r\nfunction sliceText(text, from, to) {\r\n    return appendText(text, [\"\"], from, to);\r\n}\r\nclass RawTextCursor {\r\n    constructor(text, dir = 1) {\r\n        this.dir = dir;\r\n        this.done = false;\r\n        this.lineBreak = false;\r\n        this.value = \"\";\r\n        this.nodes = [text];\r\n        this.offsets = [dir > 0 ? 1 : (text instanceof TextLeaf ? text.text.length : text.children.length) << 1];\r\n    }\r\n    nextInner(skip, dir) {\r\n        this.done = this.lineBreak = false;\r\n        for (;;) {\r\n            let last = this.nodes.length - 1;\r\n            let top = this.nodes[last], offsetValue = this.offsets[last], offset = offsetValue >> 1;\r\n            let size = top instanceof TextLeaf ? top.text.length : top.children.length;\r\n            if (offset == (dir > 0 ? size : 0)) {\r\n                if (last == 0) {\r\n                    this.done = true;\r\n                    this.value = \"\";\r\n                    return this;\r\n                }\r\n                if (dir > 0)\r\n                    this.offsets[last - 1]++;\r\n                this.nodes.pop();\r\n                this.offsets.pop();\r\n            }\r\n            else if ((offsetValue & 1) == (dir > 0 ? 0 : 1)) {\r\n                this.offsets[last] += dir;\r\n                if (skip == 0) {\r\n                    this.lineBreak = true;\r\n                    this.value = \"\\n\";\r\n                    return this;\r\n                }\r\n                skip--;\r\n            }\r\n            else if (top instanceof TextLeaf) {\r\n                // Move to the next string\r\n                let next = top.text[offset + (dir < 0 ? -1 : 0)];\r\n                this.offsets[last] += dir;\r\n                if (next.length > Math.max(0, skip)) {\r\n                    this.value = skip == 0 ? next : dir > 0 ? next.slice(skip) : next.slice(0, next.length - skip);\r\n                    return this;\r\n                }\r\n                skip -= next.length;\r\n            }\r\n            else {\r\n                let next = top.children[offset + (dir < 0 ? -1 : 0)];\r\n                if (skip > next.length) {\r\n                    skip -= next.length;\r\n                    this.offsets[last] += dir;\r\n                }\r\n                else {\r\n                    if (dir < 0)\r\n                        this.offsets[last]--;\r\n                    this.nodes.push(next);\r\n                    this.offsets.push(dir > 0 ? 1 : (next instanceof TextLeaf ? next.text.length : next.children.length) << 1);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    next(skip = 0) {\r\n        if (skip < 0) {\r\n            this.nextInner(-skip, (-this.dir));\r\n            skip = this.value.length;\r\n        }\r\n        return this.nextInner(skip, this.dir);\r\n    }\r\n}\r\nclass PartialTextCursor {\r\n    constructor(text, start, end) {\r\n        this.value = \"\";\r\n        this.done = false;\r\n        this.cursor = new RawTextCursor(text, start > end ? -1 : 1);\r\n        this.pos = start > end ? text.length : 0;\r\n        this.from = Math.min(start, end);\r\n        this.to = Math.max(start, end);\r\n    }\r\n    nextInner(skip, dir) {\r\n        if (dir < 0 ? this.pos <= this.from : this.pos >= this.to) {\r\n            this.value = \"\";\r\n            this.done = true;\r\n            return this;\r\n        }\r\n        skip += Math.max(0, dir < 0 ? this.pos - this.to : this.from - this.pos);\r\n        let limit = dir < 0 ? this.pos - this.from : this.to - this.pos;\r\n        if (skip > limit)\r\n            skip = limit;\r\n        limit -= skip;\r\n        let { value } = this.cursor.next(skip);\r\n        this.pos += (value.length + skip) * dir;\r\n        this.value = value.length <= limit ? value : dir < 0 ? value.slice(value.length - limit) : value.slice(0, limit);\r\n        this.done = !this.value;\r\n        return this;\r\n    }\r\n    next(skip = 0) {\r\n        if (skip < 0)\r\n            skip = Math.max(skip, this.from - this.pos);\r\n        else if (skip > 0)\r\n            skip = Math.min(skip, this.to - this.pos);\r\n        return this.nextInner(skip, this.cursor.dir);\r\n    }\r\n    get lineBreak() { return this.cursor.lineBreak && this.value != \"\"; }\r\n}\r\nclass LineCursor {\r\n    constructor(inner) {\r\n        this.inner = inner;\r\n        this.afterBreak = true;\r\n        this.value = \"\";\r\n        this.done = false;\r\n    }\r\n    next(skip = 0) {\r\n        let { done, lineBreak, value } = this.inner.next(skip);\r\n        if (done) {\r\n            this.done = true;\r\n            this.value = \"\";\r\n        }\r\n        else if (lineBreak) {\r\n            if (this.afterBreak) {\r\n                this.value = \"\";\r\n            }\r\n            else {\r\n                this.afterBreak = true;\r\n                this.next();\r\n            }\r\n        }\r\n        else {\r\n            this.value = value;\r\n            this.afterBreak = false;\r\n        }\r\n        return this;\r\n    }\r\n    get lineBreak() { return false; }\r\n}\r\nif (typeof Symbol != \"undefined\") {\r\n    Text.prototype[Symbol.iterator] = function () { return this.iter(); };\r\n    RawTextCursor.prototype[Symbol.iterator] = PartialTextCursor.prototype[Symbol.iterator] =\r\n        LineCursor.prototype[Symbol.iterator] = function () { return this; };\r\n}\r\n/**\r\nThis type describes a line in the document. It is created\r\non-demand when lines are [queried](https://codemirror.net/6/docs/ref/#state.Text.lineAt).\r\n*/\r\nclass Line {\r\n    /**\r\n    @internal\r\n    */\r\n    constructor(\r\n    /**\r\n    The position of the start of the line.\r\n    */\r\n    from, \r\n    /**\r\n    The position at the end of the line (_before_ the line break,\r\n    or at the end of document for the last line).\r\n    */\r\n    to, \r\n    /**\r\n    This line's line number (1-based).\r\n    */\r\n    number, \r\n    /**\r\n    The line's content.\r\n    */\r\n    text) {\r\n        this.from = from;\r\n        this.to = to;\r\n        this.number = number;\r\n        this.text = text;\r\n    }\r\n    /**\r\n    The length of the line (not including any line break after it).\r\n    */\r\n    get length() { return this.to - this.from; }\r\n}\r\n\r\n// Compressed representation of the Grapheme_Cluster_Break=Extend\r\n// information from\r\n// http://www.unicode.org/Public/13.0.0/ucd/auxiliary/GraphemeBreakProperty.txt.\r\n// Each pair of elements represents a range, as an offet from the\r\n// previous range and a length. Numbers are in base-36, with the empty\r\n// string being a shorthand for 1.\r\nlet extend = /*@__PURE__*/\"lc,34,7n,7,7b,19,,,,2,,2,,,20,b,1c,l,g,,2t,7,2,6,2,2,,4,z,,u,r,2j,b,1m,9,9,,o,4,,9,,3,,5,17,3,3b,f,,w,1j,,,,4,8,4,,3,7,a,2,t,,1m,,,,2,4,8,,9,,a,2,q,,2,2,1l,,4,2,4,2,2,3,3,,u,2,3,,b,2,1l,,4,5,,2,4,,k,2,m,6,,,1m,,,2,,4,8,,7,3,a,2,u,,1n,,,,c,,9,,14,,3,,1l,3,5,3,,4,7,2,b,2,t,,1m,,2,,2,,3,,5,2,7,2,b,2,s,2,1l,2,,,2,4,8,,9,,a,2,t,,20,,4,,2,3,,,8,,29,,2,7,c,8,2q,,2,9,b,6,22,2,r,,,,,,1j,e,,5,,2,5,b,,10,9,,2u,4,,6,,2,2,2,p,2,4,3,g,4,d,,2,2,6,,f,,jj,3,qa,3,t,3,t,2,u,2,1s,2,,7,8,,2,b,9,,19,3,3b,2,y,,3a,3,4,2,9,,6,3,63,2,2,,1m,,,7,,,,,2,8,6,a,2,,1c,h,1r,4,1c,7,,,5,,14,9,c,2,w,4,2,2,,3,1k,,,2,3,,,3,1m,8,2,2,48,3,,d,,7,4,,6,,3,2,5i,1m,,5,ek,,5f,x,2da,3,3x,,2o,w,fe,6,2x,2,n9w,4,,a,w,2,28,2,7k,,3,,4,,p,2,5,,47,2,q,i,d,,12,8,p,b,1a,3,1c,,2,4,2,2,13,,1v,6,2,2,2,2,c,,8,,1b,,1f,,,3,2,2,5,2,,,16,2,8,,6m,,2,,4,,fn4,,kh,g,g,g,a6,2,gt,,6a,,45,5,1ae,3,,2,5,4,14,3,4,,4l,2,fx,4,ar,2,49,b,4w,,1i,f,1k,3,1d,4,2,2,1x,3,10,5,,8,1q,,c,2,1g,9,a,4,2,,2n,3,2,,,2,6,,4g,,3,8,l,2,1l,2,,,,,m,,e,7,3,5,5f,8,2,3,,,n,,29,,2,6,,,2,,,2,,2,6j,,2,4,6,2,,2,r,2,2d,8,2,,,2,2y,,,,2,6,,,2t,3,2,4,,5,77,9,,2,6t,,a,2,,,4,,40,4,2,2,4,,w,a,14,6,2,4,8,,9,6,2,3,1a,d,,2,ba,7,,6,,,2a,m,2,7,,2,,2,3e,6,3,,,2,,7,,,20,2,3,,,,9n,2,f0b,5,1n,7,t4,,1r,4,29,,f5k,2,43q,,,3,4,5,8,8,2,7,u,4,44,3,1iz,1j,4,1e,8,,e,,m,5,,f,11s,7,,h,2,7,,2,,5,79,7,c5,4,15s,7,31,7,240,5,gx7k,2o,3k,6o\".split(\",\").map(s => s ? parseInt(s, 36) : 1);\r\n// Convert offsets into absolute values\r\nfor (let i = 1; i < extend.length; i++)\r\n    extend[i] += extend[i - 1];\r\nfunction isExtendingChar(code) {\r\n    for (let i = 1; i < extend.length; i += 2)\r\n        if (extend[i] > code)\r\n            return extend[i - 1] <= code;\r\n    return false;\r\n}\r\nfunction isRegionalIndicator(code) {\r\n    return code >= 0x1F1E6 && code <= 0x1F1FF;\r\n}\r\nconst ZWJ = 0x200d;\r\n/**\r\nReturns a next grapheme cluster break _after_ (not equal to)\r\n`pos`, if `forward` is true, or before otherwise. Returns `pos`\r\nitself if no further cluster break is available in the string.\r\nMoves across surrogate pairs, extending characters (when\r\n`includeExtending` is true), characters joined with zero-width\r\njoiners, and flag emoji.\r\n*/\r\nfunction findClusterBreak(str, pos, forward = true, includeExtending = true) {\r\n    return (forward ? nextClusterBreak : prevClusterBreak)(str, pos, includeExtending);\r\n}\r\nfunction nextClusterBreak(str, pos, includeExtending) {\r\n    if (pos == str.length)\r\n        return pos;\r\n    // If pos is in the middle of a surrogate pair, move to its start\r\n    if (pos && surrogateLow(str.charCodeAt(pos)) && surrogateHigh(str.charCodeAt(pos - 1)))\r\n        pos--;\r\n    let prev = codePointAt(str, pos);\r\n    pos += codePointSize(prev);\r\n    while (pos < str.length) {\r\n        let next = codePointAt(str, pos);\r\n        if (prev == ZWJ || next == ZWJ || includeExtending && isExtendingChar(next)) {\r\n            pos += codePointSize(next);\r\n            prev = next;\r\n        }\r\n        else if (isRegionalIndicator(next)) {\r\n            let countBefore = 0, i = pos - 2;\r\n            while (i >= 0 && isRegionalIndicator(codePointAt(str, i))) {\r\n                countBefore++;\r\n                i -= 2;\r\n            }\r\n            if (countBefore % 2 == 0)\r\n                break;\r\n            else\r\n                pos += 2;\r\n        }\r\n        else {\r\n            break;\r\n        }\r\n    }\r\n    return pos;\r\n}\r\nfunction prevClusterBreak(str, pos, includeExtending) {\r\n    while (pos > 0) {\r\n        let found = nextClusterBreak(str, pos - 2, includeExtending);\r\n        if (found < pos)\r\n            return found;\r\n        pos--;\r\n    }\r\n    return 0;\r\n}\r\nfunction surrogateLow(ch) { return ch >= 0xDC00 && ch < 0xE000; }\r\nfunction surrogateHigh(ch) { return ch >= 0xD800 && ch < 0xDC00; }\r\n/**\r\nFind the code point at the given position in a string (like the\r\n[`codePointAt`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/codePointAt)\r\nstring method).\r\n*/\r\nfunction codePointAt(str, pos) {\r\n    let code0 = str.charCodeAt(pos);\r\n    if (!surrogateHigh(code0) || pos + 1 == str.length)\r\n        return code0;\r\n    let code1 = str.charCodeAt(pos + 1);\r\n    if (!surrogateLow(code1))\r\n        return code0;\r\n    return ((code0 - 0xd800) << 10) + (code1 - 0xdc00) + 0x10000;\r\n}\r\n/**\r\nGiven a Unicode codepoint, return the JavaScript string that\r\nrespresents it (like\r\n[`String.fromCodePoint`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/fromCodePoint)).\r\n*/\r\nfunction fromCodePoint(code) {\r\n    if (code <= 0xffff)\r\n        return String.fromCharCode(code);\r\n    code -= 0x10000;\r\n    return String.fromCharCode((code >> 10) + 0xd800, (code & 1023) + 0xdc00);\r\n}\r\n/**\r\nThe amount of positions a character takes up a JavaScript string.\r\n*/\r\nfunction codePointSize(code) { return code < 0x10000 ? 1 : 2; }\r\n\r\nconst DefaultSplit = /\\r\\n?|\\n/;\r\n/**\r\nDistinguishes different ways in which positions can be mapped.\r\n*/\r\nvar MapMode = /*@__PURE__*/(function (MapMode) {\r\n    /**\r\n    Map a position to a valid new position, even when its context\r\n    was deleted.\r\n    */\r\n    MapMode[MapMode[\"Simple\"] = 0] = \"Simple\";\r\n    /**\r\n    Return null if deletion happens across the position.\r\n    */\r\n    MapMode[MapMode[\"TrackDel\"] = 1] = \"TrackDel\";\r\n    /**\r\n    Return null if the character _before_ the position is deleted.\r\n    */\r\n    MapMode[MapMode[\"TrackBefore\"] = 2] = \"TrackBefore\";\r\n    /**\r\n    Return null if the character _after_ the position is deleted.\r\n    */\r\n    MapMode[MapMode[\"TrackAfter\"] = 3] = \"TrackAfter\";\r\nreturn MapMode})(MapMode || (MapMode = {}));\r\n/**\r\nA change description is a variant of [change set](https://codemirror.net/6/docs/ref/#state.ChangeSet)\r\nthat doesn't store the inserted text. As such, it can't be\r\napplied, but is cheaper to store and manipulate.\r\n*/\r\nclass ChangeDesc {\r\n    // Sections are encoded as pairs of integers. The first is the\r\n    // length in the current document, and the second is -1 for\r\n    // unaffected sections, and the length of the replacement content\r\n    // otherwise. So an insertion would be (0, n>0), a deletion (n>0,\r\n    // 0), and a replacement two positive numbers.\r\n    /**\r\n    @internal\r\n    */\r\n    constructor(\r\n    /**\r\n    @internal\r\n    */\r\n    sections) {\r\n        this.sections = sections;\r\n    }\r\n    /**\r\n    The length of the document before the change.\r\n    */\r\n    get length() {\r\n        let result = 0;\r\n        for (let i = 0; i < this.sections.length; i += 2)\r\n            result += this.sections[i];\r\n        return result;\r\n    }\r\n    /**\r\n    The length of the document after the change.\r\n    */\r\n    get newLength() {\r\n        let result = 0;\r\n        for (let i = 0; i < this.sections.length; i += 2) {\r\n            let ins = this.sections[i + 1];\r\n            result += ins < 0 ? this.sections[i] : ins;\r\n        }\r\n        return result;\r\n    }\r\n    /**\r\n    False when there are actual changes in this set.\r\n    */\r\n    get empty() { return this.sections.length == 0 || this.sections.length == 2 && this.sections[1] < 0; }\r\n    /**\r\n    Iterate over the unchanged parts left by these changes. `posA`\r\n    provides the position of the range in the old document, `posB`\r\n    the new position in the changed document.\r\n    */\r\n    iterGaps(f) {\r\n        for (let i = 0, posA = 0, posB = 0; i < this.sections.length;) {\r\n            let len = this.sections[i++], ins = this.sections[i++];\r\n            if (ins < 0) {\r\n                f(posA, posB, len);\r\n                posB += len;\r\n            }\r\n            else {\r\n                posB += ins;\r\n            }\r\n            posA += len;\r\n        }\r\n    }\r\n    /**\r\n    Iterate over the ranges changed by these changes. (See\r\n    [`ChangeSet.iterChanges`](https://codemirror.net/6/docs/ref/#state.ChangeSet.iterChanges) for a\r\n    variant that also provides you with the inserted text.)\r\n    `fromA`/`toA` provides the extent of the change in the starting\r\n    document, `fromB`/`toB` the extent of the replacement in the\r\n    changed document.\r\n    \r\n    When `individual` is true, adjacent changes (which are kept\r\n    separate for [position mapping](https://codemirror.net/6/docs/ref/#state.ChangeDesc.mapPos)) are\r\n    reported separately.\r\n    */\r\n    iterChangedRanges(f, individual = false) {\r\n        iterChanges(this, f, individual);\r\n    }\r\n    /**\r\n    Get a description of the inverted form of these changes.\r\n    */\r\n    get invertedDesc() {\r\n        let sections = [];\r\n        for (let i = 0; i < this.sections.length;) {\r\n            let len = this.sections[i++], ins = this.sections[i++];\r\n            if (ins < 0)\r\n                sections.push(len, ins);\r\n            else\r\n                sections.push(ins, len);\r\n        }\r\n        return new ChangeDesc(sections);\r\n    }\r\n    /**\r\n    Compute the combined effect of applying another set of changes\r\n    after this one. The length of the document after this set should\r\n    match the length before `other`.\r\n    */\r\n    composeDesc(other) { return this.empty ? other : other.empty ? this : composeSets(this, other); }\r\n    /**\r\n    Map this description, which should start with the same document\r\n    as `other`, over another set of changes, so that it can be\r\n    applied after it. When `before` is true, map as if the changes\r\n    in `other` happened before the ones in `this`.\r\n    */\r\n    mapDesc(other, before = false) { return other.empty ? this : mapSet(this, other, before); }\r\n    mapPos(pos, assoc = -1, mode = MapMode.Simple) {\r\n        let posA = 0, posB = 0;\r\n        for (let i = 0; i < this.sections.length;) {\r\n            let len = this.sections[i++], ins = this.sections[i++], endA = posA + len;\r\n            if (ins < 0) {\r\n                if (endA > pos)\r\n                    return posB + (pos - posA);\r\n                posB += len;\r\n            }\r\n            else {\r\n                if (mode != MapMode.Simple && endA >= pos &&\r\n                    (mode == MapMode.TrackDel && posA < pos && endA > pos ||\r\n                        mode == MapMode.TrackBefore && posA < pos ||\r\n                        mode == MapMode.TrackAfter && endA > pos))\r\n                    return null;\r\n                if (endA > pos || endA == pos && assoc < 0 && !len)\r\n                    return pos == posA || assoc < 0 ? posB : posB + ins;\r\n                posB += ins;\r\n            }\r\n            posA = endA;\r\n        }\r\n        if (pos > posA)\r\n            throw new RangeError(`Position ${pos} is out of range for changeset of length ${posA}`);\r\n        return posB;\r\n    }\r\n    /**\r\n    Check whether these changes touch a given range. When one of the\r\n    changes entirely covers the range, the string `\"cover\"` is\r\n    returned.\r\n    */\r\n    touchesRange(from, to = from) {\r\n        for (let i = 0, pos = 0; i < this.sections.length && pos <= to;) {\r\n            let len = this.sections[i++], ins = this.sections[i++], end = pos + len;\r\n            if (ins >= 0 && pos <= to && end >= from)\r\n                return pos < from && end > to ? \"cover\" : true;\r\n            pos = end;\r\n        }\r\n        return false;\r\n    }\r\n    /**\r\n    @internal\r\n    */\r\n    toString() {\r\n        let result = \"\";\r\n        for (let i = 0; i < this.sections.length;) {\r\n            let len = this.sections[i++], ins = this.sections[i++];\r\n            result += (result ? \" \" : \"\") + len + (ins >= 0 ? \":\" + ins : \"\");\r\n        }\r\n        return result;\r\n    }\r\n    /**\r\n    Serialize this change desc to a JSON-representable value.\r\n    */\r\n    toJSON() { return this.sections; }\r\n    /**\r\n    Create a change desc from its JSON representation (as produced\r\n    by [`toJSON`](https://codemirror.net/6/docs/ref/#state.ChangeDesc.toJSON).\r\n    */\r\n    static fromJSON(json) {\r\n        if (!Array.isArray(json) || json.length % 2 || json.some(a => typeof a != \"number\"))\r\n            throw new RangeError(\"Invalid JSON representation of ChangeDesc\");\r\n        return new ChangeDesc(json);\r\n    }\r\n    /**\r\n    @internal\r\n    */\r\n    static create(sections) { return new ChangeDesc(sections); }\r\n}\r\n/**\r\nA change set represents a group of modifications to a document. It\r\nstores the document length, and can only be applied to documents\r\nwith exactly that length.\r\n*/\r\nclass ChangeSet extends ChangeDesc {\r\n    constructor(sections, \r\n    /**\r\n    @internal\r\n    */\r\n    inserted) {\r\n        super(sections);\r\n        this.inserted = inserted;\r\n    }\r\n    /**\r\n    Apply the changes to a document, returning the modified\r\n    document.\r\n    */\r\n    apply(doc) {\r\n        if (this.length != doc.length)\r\n            throw new RangeError(\"Applying change set to a document with the wrong length\");\r\n        iterChanges(this, (fromA, toA, fromB, _toB, text) => doc = doc.replace(fromB, fromB + (toA - fromA), text), false);\r\n        return doc;\r\n    }\r\n    mapDesc(other, before = false) { return mapSet(this, other, before, true); }\r\n    /**\r\n    Given the document as it existed _before_ the changes, return a\r\n    change set that represents the inverse of this set, which could\r\n    be used to go from the document created by the changes back to\r\n    the document as it existed before the changes.\r\n    */\r\n    invert(doc) {\r\n        let sections = this.sections.slice(), inserted = [];\r\n        for (let i = 0, pos = 0; i < sections.length; i += 2) {\r\n            let len = sections[i], ins = sections[i + 1];\r\n            if (ins >= 0) {\r\n                sections[i] = ins;\r\n                sections[i + 1] = len;\r\n                let index = i >> 1;\r\n                while (inserted.length < index)\r\n                    inserted.push(Text.empty);\r\n                inserted.push(len ? doc.slice(pos, pos + len) : Text.empty);\r\n            }\r\n            pos += len;\r\n        }\r\n        return new ChangeSet(sections, inserted);\r\n    }\r\n    /**\r\n    Combine two subsequent change sets into a single set. `other`\r\n    must start in the document produced by `this`. If `this` goes\r\n    `docA` → `docB` and `other` represents `docB` → `docC`, the\r\n    returned value will represent the change `docA` → `docC`.\r\n    */\r\n    compose(other) { return this.empty ? other : other.empty ? this : composeSets(this, other, true); }\r\n    /**\r\n    Given another change set starting in the same document, maps this\r\n    change set over the other, producing a new change set that can be\r\n    applied to the document produced by applying `other`. When\r\n    `before` is `true`, order changes as if `this` comes before\r\n    `other`, otherwise (the default) treat `other` as coming first.\r\n    \r\n    Given two changes `A` and `B`, `A.compose(B.map(A))` and\r\n    `B.compose(A.map(B, true))` will produce the same document. This\r\n    provides a basic form of [operational\r\n    transformation](https://en.wikipedia.org/wiki/Operational_transformation),\r\n    and can be used for collaborative editing.\r\n    */\r\n    map(other, before = false) { return other.empty ? this : mapSet(this, other, before, true); }\r\n    /**\r\n    Iterate over the changed ranges in the document, calling `f` for\r\n    each, with the range in the original document (`fromA`-`toA`)\r\n    and the range that replaces it in the new document\r\n    (`fromB`-`toB`).\r\n    \r\n    When `individual` is true, adjacent changes are reported\r\n    separately.\r\n    */\r\n    iterChanges(f, individual = false) {\r\n        iterChanges(this, f, individual);\r\n    }\r\n    /**\r\n    Get a [change description](https://codemirror.net/6/docs/ref/#state.ChangeDesc) for this change\r\n    set.\r\n    */\r\n    get desc() { return ChangeDesc.create(this.sections); }\r\n    /**\r\n    @internal\r\n    */\r\n    filter(ranges) {\r\n        let resultSections = [], resultInserted = [], filteredSections = [];\r\n        let iter = new SectionIter(this);\r\n        done: for (let i = 0, pos = 0;;) {\r\n            let next = i == ranges.length ? 1e9 : ranges[i++];\r\n            while (pos < next || pos == next && iter.len == 0) {\r\n                if (iter.done)\r\n                    break done;\r\n                let len = Math.min(iter.len, next - pos);\r\n                addSection(filteredSections, len, -1);\r\n                let ins = iter.ins == -1 ? -1 : iter.off == 0 ? iter.ins : 0;\r\n                addSection(resultSections, len, ins);\r\n                if (ins > 0)\r\n                    addInsert(resultInserted, resultSections, iter.text);\r\n                iter.forward(len);\r\n                pos += len;\r\n            }\r\n            let end = ranges[i++];\r\n            while (pos < end) {\r\n                if (iter.done)\r\n                    break done;\r\n                let len = Math.min(iter.len, end - pos);\r\n                addSection(resultSections, len, -1);\r\n                addSection(filteredSections, len, iter.ins == -1 ? -1 : iter.off == 0 ? iter.ins : 0);\r\n                iter.forward(len);\r\n                pos += len;\r\n            }\r\n        }\r\n        return { changes: new ChangeSet(resultSections, resultInserted),\r\n            filtered: ChangeDesc.create(filteredSections) };\r\n    }\r\n    /**\r\n    Serialize this change set to a JSON-representable value.\r\n    */\r\n    toJSON() {\r\n        let parts = [];\r\n        for (let i = 0; i < this.sections.length; i += 2) {\r\n            let len = this.sections[i], ins = this.sections[i + 1];\r\n            if (ins < 0)\r\n                parts.push(len);\r\n            else if (ins == 0)\r\n                parts.push([len]);\r\n            else\r\n                parts.push([len].concat(this.inserted[i >> 1].toJSON()));\r\n        }\r\n        return parts;\r\n    }\r\n    /**\r\n    Create a change set for the given changes, for a document of the\r\n    given length, using `lineSep` as line separator.\r\n    */\r\n    static of(changes, length, lineSep) {\r\n        let sections = [], inserted = [], pos = 0;\r\n        let total = null;\r\n        function flush(force = false) {\r\n            if (!force && !sections.length)\r\n                return;\r\n            if (pos < length)\r\n                addSection(sections, length - pos, -1);\r\n            let set = new ChangeSet(sections, inserted);\r\n            total = total ? total.compose(set.map(total)) : set;\r\n            sections = [];\r\n            inserted = [];\r\n            pos = 0;\r\n        }\r\n        function process(spec) {\r\n            if (Array.isArray(spec)) {\r\n                for (let sub of spec)\r\n                    process(sub);\r\n            }\r\n            else if (spec instanceof ChangeSet) {\r\n                if (spec.length != length)\r\n                    throw new RangeError(`Mismatched change set length (got ${spec.length}, expected ${length})`);\r\n                flush();\r\n                total = total ? total.compose(spec.map(total)) : spec;\r\n            }\r\n            else {\r\n                let { from, to = from, insert } = spec;\r\n                if (from > to || from < 0 || to > length)\r\n                    throw new RangeError(`Invalid change range ${from} to ${to} (in doc of length ${length})`);\r\n                let insText = !insert ? Text.empty : typeof insert == \"string\" ? Text.of(insert.split(lineSep || DefaultSplit)) : insert;\r\n                let insLen = insText.length;\r\n                if (from == to && insLen == 0)\r\n                    return;\r\n                if (from < pos)\r\n                    flush();\r\n                if (from > pos)\r\n                    addSection(sections, from - pos, -1);\r\n                addSection(sections, to - from, insLen);\r\n                addInsert(inserted, sections, insText);\r\n                pos = to;\r\n            }\r\n        }\r\n        process(changes);\r\n        flush(!total);\r\n        return total;\r\n    }\r\n    /**\r\n    Create an empty changeset of the given length.\r\n    */\r\n    static empty(length) {\r\n        return new ChangeSet(length ? [length, -1] : [], []);\r\n    }\r\n    /**\r\n    Create a changeset from its JSON representation (as produced by\r\n    [`toJSON`](https://codemirror.net/6/docs/ref/#state.ChangeSet.toJSON).\r\n    */\r\n    static fromJSON(json) {\r\n        if (!Array.isArray(json))\r\n            throw new RangeError(\"Invalid JSON representation of ChangeSet\");\r\n        let sections = [], inserted = [];\r\n        for (let i = 0; i < json.length; i++) {\r\n            let part = json[i];\r\n            if (typeof part == \"number\") {\r\n                sections.push(part, -1);\r\n            }\r\n            else if (!Array.isArray(part) || typeof part[0] != \"number\" || part.some((e, i) => i && typeof e != \"string\")) {\r\n                throw new RangeError(\"Invalid JSON representation of ChangeSet\");\r\n            }\r\n            else if (part.length == 1) {\r\n                sections.push(part[0], 0);\r\n            }\r\n            else {\r\n                while (inserted.length < i)\r\n                    inserted.push(Text.empty);\r\n                inserted[i] = Text.of(part.slice(1));\r\n                sections.push(part[0], inserted[i].length);\r\n            }\r\n        }\r\n        return new ChangeSet(sections, inserted);\r\n    }\r\n    /**\r\n    @internal\r\n    */\r\n    static createSet(sections, inserted) {\r\n        return new ChangeSet(sections, inserted);\r\n    }\r\n}\r\nfunction addSection(sections, len, ins, forceJoin = false) {\r\n    if (len == 0 && ins <= 0)\r\n        return;\r\n    let last = sections.length - 2;\r\n    if (last >= 0 && ins <= 0 && ins == sections[last + 1])\r\n        sections[last] += len;\r\n    else if (len == 0 && sections[last] == 0)\r\n        sections[last + 1] += ins;\r\n    else if (forceJoin) {\r\n        sections[last] += len;\r\n        sections[last + 1] += ins;\r\n    }\r\n    else\r\n        sections.push(len, ins);\r\n}\r\nfunction addInsert(values, sections, value) {\r\n    if (value.length == 0)\r\n        return;\r\n    let index = (sections.length - 2) >> 1;\r\n    if (index < values.length) {\r\n        values[values.length - 1] = values[values.length - 1].append(value);\r\n    }\r\n    else {\r\n        while (values.length < index)\r\n            values.push(Text.empty);\r\n        values.push(value);\r\n    }\r\n}\r\nfunction iterChanges(desc, f, individual) {\r\n    let inserted = desc.inserted;\r\n    for (let posA = 0, posB = 0, i = 0; i < desc.sections.length;) {\r\n        let len = desc.sections[i++], ins = desc.sections[i++];\r\n        if (ins < 0) {\r\n            posA += len;\r\n            posB += len;\r\n        }\r\n        else {\r\n            let endA = posA, endB = posB, text = Text.empty;\r\n            for (;;) {\r\n                endA += len;\r\n                endB += ins;\r\n                if (ins && inserted)\r\n                    text = text.append(inserted[(i - 2) >> 1]);\r\n                if (individual || i == desc.sections.length || desc.sections[i + 1] < 0)\r\n                    break;\r\n                len = desc.sections[i++];\r\n                ins = desc.sections[i++];\r\n            }\r\n            f(posA, endA, posB, endB, text);\r\n            posA = endA;\r\n            posB = endB;\r\n        }\r\n    }\r\n}\r\nfunction mapSet(setA, setB, before, mkSet = false) {\r\n    // Produce a copy of setA that applies to the document after setB\r\n    // has been applied (assuming both start at the same document).\r\n    let sections = [], insert = mkSet ? [] : null;\r\n    let a = new SectionIter(setA), b = new SectionIter(setB);\r\n    // Iterate over both sets in parallel. inserted tracks, for changes\r\n    // in A that have to be processed piece-by-piece, whether their\r\n    // content has been inserted already, and refers to the section\r\n    // index.\r\n    for (let inserted = -1;;) {\r\n        if (a.ins == -1 && b.ins == -1) {\r\n            // Move across ranges skipped by both sets.\r\n            let len = Math.min(a.len, b.len);\r\n            addSection(sections, len, -1);\r\n            a.forward(len);\r\n            b.forward(len);\r\n        }\r\n        else if (b.ins >= 0 && (a.ins < 0 || inserted == a.i || a.off == 0 && (b.len < a.len || b.len == a.len && !before))) {\r\n            // If there's a change in B that comes before the next change in\r\n            // A (ordered by start pos, then len, then before flag), skip\r\n            // that (and process any changes in A it covers).\r\n            let len = b.len;\r\n            addSection(sections, b.ins, -1);\r\n            while (len) {\r\n                let piece = Math.min(a.len, len);\r\n                if (a.ins >= 0 && inserted < a.i && a.len <= piece) {\r\n                    addSection(sections, 0, a.ins);\r\n                    if (insert)\r\n                        addInsert(insert, sections, a.text);\r\n                    inserted = a.i;\r\n                }\r\n                a.forward(piece);\r\n                len -= piece;\r\n            }\r\n            b.next();\r\n        }\r\n        else if (a.ins >= 0) {\r\n            // Process the part of a change in A up to the start of the next\r\n            // non-deletion change in B (if overlapping).\r\n            let len = 0, left = a.len;\r\n            while (left) {\r\n                if (b.ins == -1) {\r\n                    let piece = Math.min(left, b.len);\r\n                    len += piece;\r\n                    left -= piece;\r\n                    b.forward(piece);\r\n                }\r\n                else if (b.ins == 0 && b.len < left) {\r\n                    left -= b.len;\r\n                    b.next();\r\n                }\r\n                else {\r\n                    break;\r\n                }\r\n            }\r\n            addSection(sections, len, inserted < a.i ? a.ins : 0);\r\n            if (insert && inserted < a.i)\r\n                addInsert(insert, sections, a.text);\r\n            inserted = a.i;\r\n            a.forward(a.len - left);\r\n        }\r\n        else if (a.done && b.done) {\r\n            return insert ? ChangeSet.createSet(sections, insert) : ChangeDesc.create(sections);\r\n        }\r\n        else {\r\n            throw new Error(\"Mismatched change set lengths\");\r\n        }\r\n    }\r\n}\r\nfunction composeSets(setA, setB, mkSet = false) {\r\n    let sections = [];\r\n    let insert = mkSet ? [] : null;\r\n    let a = new SectionIter(setA), b = new SectionIter(setB);\r\n    for (let open = false;;) {\r\n        if (a.done && b.done) {\r\n            return insert ? ChangeSet.createSet(sections, insert) : ChangeDesc.create(sections);\r\n        }\r\n        else if (a.ins == 0) { // Deletion in A\r\n            addSection(sections, a.len, 0, open);\r\n            a.next();\r\n        }\r\n        else if (b.len == 0 && !b.done) { // Insertion in B\r\n            addSection(sections, 0, b.ins, open);\r\n            if (insert)\r\n                addInsert(insert, sections, b.text);\r\n            b.next();\r\n        }\r\n        else if (a.done || b.done) {\r\n            throw new Error(\"Mismatched change set lengths\");\r\n        }\r\n        else {\r\n            let len = Math.min(a.len2, b.len), sectionLen = sections.length;\r\n            if (a.ins == -1) {\r\n                let insB = b.ins == -1 ? -1 : b.off ? 0 : b.ins;\r\n                addSection(sections, len, insB, open);\r\n                if (insert && insB)\r\n                    addInsert(insert, sections, b.text);\r\n            }\r\n            else if (b.ins == -1) {\r\n                addSection(sections, a.off ? 0 : a.len, len, open);\r\n                if (insert)\r\n                    addInsert(insert, sections, a.textBit(len));\r\n            }\r\n            else {\r\n                addSection(sections, a.off ? 0 : a.len, b.off ? 0 : b.ins, open);\r\n                if (insert && !b.off)\r\n                    addInsert(insert, sections, b.text);\r\n            }\r\n            open = (a.ins > len || b.ins >= 0 && b.len > len) && (open || sections.length > sectionLen);\r\n            a.forward2(len);\r\n            b.forward(len);\r\n        }\r\n    }\r\n}\r\nclass SectionIter {\r\n    constructor(set) {\r\n        this.set = set;\r\n        this.i = 0;\r\n        this.next();\r\n    }\r\n    next() {\r\n        let { sections } = this.set;\r\n        if (this.i < sections.length) {\r\n            this.len = sections[this.i++];\r\n            this.ins = sections[this.i++];\r\n        }\r\n        else {\r\n            this.len = 0;\r\n            this.ins = -2;\r\n        }\r\n        this.off = 0;\r\n    }\r\n    get done() { return this.ins == -2; }\r\n    get len2() { return this.ins < 0 ? this.len : this.ins; }\r\n    get text() {\r\n        let { inserted } = this.set, index = (this.i - 2) >> 1;\r\n        return index >= inserted.length ? Text.empty : inserted[index];\r\n    }\r\n    textBit(len) {\r\n        let { inserted } = this.set, index = (this.i - 2) >> 1;\r\n        return index >= inserted.length && !len ? Text.empty\r\n            : inserted[index].slice(this.off, len == null ? undefined : this.off + len);\r\n    }\r\n    forward(len) {\r\n        if (len == this.len)\r\n            this.next();\r\n        else {\r\n            this.len -= len;\r\n            this.off += len;\r\n        }\r\n    }\r\n    forward2(len) {\r\n        if (this.ins == -1)\r\n            this.forward(len);\r\n        else if (len == this.ins)\r\n            this.next();\r\n        else {\r\n            this.ins -= len;\r\n            this.off += len;\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\nA single selection range. When\r\n[`allowMultipleSelections`](https://codemirror.net/6/docs/ref/#state.EditorState^allowMultipleSelections)\r\nis enabled, a [selection](https://codemirror.net/6/docs/ref/#state.EditorSelection) may hold\r\nmultiple ranges. By default, selections hold exactly one range.\r\n*/\r\nclass SelectionRange {\r\n    constructor(\r\n    /**\r\n    The lower boundary of the range.\r\n    */\r\n    from, \r\n    /**\r\n    The upper boundary of the range.\r\n    */\r\n    to, flags) {\r\n        this.from = from;\r\n        this.to = to;\r\n        this.flags = flags;\r\n    }\r\n    /**\r\n    The anchor of the range—the side that doesn't move when you\r\n    extend it.\r\n    */\r\n    get anchor() { return this.flags & 16 /* RangeFlag.Inverted */ ? this.to : this.from; }\r\n    /**\r\n    The head of the range, which is moved when the range is\r\n    [extended](https://codemirror.net/6/docs/ref/#state.SelectionRange.extend).\r\n    */\r\n    get head() { return this.flags & 16 /* RangeFlag.Inverted */ ? this.from : this.to; }\r\n    /**\r\n    True when `anchor` and `head` are at the same position.\r\n    */\r\n    get empty() { return this.from == this.to; }\r\n    /**\r\n    If this is a cursor that is explicitly associated with the\r\n    character on one of its sides, this returns the side. -1 means\r\n    the character before its position, 1 the character after, and 0\r\n    means no association.\r\n    */\r\n    get assoc() { return this.flags & 4 /* RangeFlag.AssocBefore */ ? -1 : this.flags & 8 /* RangeFlag.AssocAfter */ ? 1 : 0; }\r\n    /**\r\n    The bidirectional text level associated with this cursor, if\r\n    any.\r\n    */\r\n    get bidiLevel() {\r\n        let level = this.flags & 3 /* RangeFlag.BidiLevelMask */;\r\n        return level == 3 ? null : level;\r\n    }\r\n    /**\r\n    The goal column (stored vertical offset) associated with a\r\n    cursor. This is used to preserve the vertical position when\r\n    [moving](https://codemirror.net/6/docs/ref/#view.EditorView.moveVertically) across\r\n    lines of different length.\r\n    */\r\n    get goalColumn() {\r\n        let value = this.flags >> 5 /* RangeFlag.GoalColumnOffset */;\r\n        return value == 33554431 /* RangeFlag.NoGoalColumn */ ? undefined : value;\r\n    }\r\n    /**\r\n    Map this range through a change, producing a valid range in the\r\n    updated document.\r\n    */\r\n    map(change, assoc = -1) {\r\n        let from, to;\r\n        if (this.empty) {\r\n            from = to = change.mapPos(this.from, assoc);\r\n        }\r\n        else {\r\n            from = change.mapPos(this.from, 1);\r\n            to = change.mapPos(this.to, -1);\r\n        }\r\n        return from == this.from && to == this.to ? this : new SelectionRange(from, to, this.flags);\r\n    }\r\n    /**\r\n    Extend this range to cover at least `from` to `to`.\r\n    */\r\n    extend(from, to = from) {\r\n        if (from <= this.anchor && to >= this.anchor)\r\n            return EditorSelection.range(from, to);\r\n        let head = Math.abs(from - this.anchor) > Math.abs(to - this.anchor) ? from : to;\r\n        return EditorSelection.range(this.anchor, head);\r\n    }\r\n    /**\r\n    Compare this range to another range.\r\n    */\r\n    eq(other) {\r\n        return this.anchor == other.anchor && this.head == other.head;\r\n    }\r\n    /**\r\n    Return a JSON-serializable object representing the range.\r\n    */\r\n    toJSON() { return { anchor: this.anchor, head: this.head }; }\r\n    /**\r\n    Convert a JSON representation of a range to a `SelectionRange`\r\n    instance.\r\n    */\r\n    static fromJSON(json) {\r\n        if (!json || typeof json.anchor != \"number\" || typeof json.head != \"number\")\r\n            throw new RangeError(\"Invalid JSON representation for SelectionRange\");\r\n        return EditorSelection.range(json.anchor, json.head);\r\n    }\r\n    /**\r\n    @internal\r\n    */\r\n    static create(from, to, flags) {\r\n        return new SelectionRange(from, to, flags);\r\n    }\r\n}\r\n/**\r\nAn editor selection holds one or more selection ranges.\r\n*/\r\nclass EditorSelection {\r\n    constructor(\r\n    /**\r\n    The ranges in the selection, sorted by position. Ranges cannot\r\n    overlap (but they may touch, if they aren't empty).\r\n    */\r\n    ranges, \r\n    /**\r\n    The index of the _main_ range in the selection (which is\r\n    usually the range that was added last).\r\n    */\r\n    mainIndex) {\r\n        this.ranges = ranges;\r\n        this.mainIndex = mainIndex;\r\n    }\r\n    /**\r\n    Map a selection through a change. Used to adjust the selection\r\n    position for changes.\r\n    */\r\n    map(change, assoc = -1) {\r\n        if (change.empty)\r\n            return this;\r\n        return EditorSelection.create(this.ranges.map(r => r.map(change, assoc)), this.mainIndex);\r\n    }\r\n    /**\r\n    Compare this selection to another selection.\r\n    */\r\n    eq(other) {\r\n        if (this.ranges.length != other.ranges.length ||\r\n            this.mainIndex != other.mainIndex)\r\n            return false;\r\n        for (let i = 0; i < this.ranges.length; i++)\r\n            if (!this.ranges[i].eq(other.ranges[i]))\r\n                return false;\r\n        return true;\r\n    }\r\n    /**\r\n    Get the primary selection range. Usually, you should make sure\r\n    your code applies to _all_ ranges, by using methods like\r\n    [`changeByRange`](https://codemirror.net/6/docs/ref/#state.EditorState.changeByRange).\r\n    */\r\n    get main() { return this.ranges[this.mainIndex]; }\r\n    /**\r\n    Make sure the selection only has one range. Returns a selection\r\n    holding only the main range from this selection.\r\n    */\r\n    asSingle() {\r\n        return this.ranges.length == 1 ? this : new EditorSelection([this.main], 0);\r\n    }\r\n    /**\r\n    Extend this selection with an extra range.\r\n    */\r\n    addRange(range, main = true) {\r\n        return EditorSelection.create([range].concat(this.ranges), main ? 0 : this.mainIndex + 1);\r\n    }\r\n    /**\r\n    Replace a given range with another range, and then normalize the\r\n    selection to merge and sort ranges if necessary.\r\n    */\r\n    replaceRange(range, which = this.mainIndex) {\r\n        let ranges = this.ranges.slice();\r\n        ranges[which] = range;\r\n        return EditorSelection.create(ranges, this.mainIndex);\r\n    }\r\n    /**\r\n    Convert this selection to an object that can be serialized to\r\n    JSON.\r\n    */\r\n    toJSON() {\r\n        return { ranges: this.ranges.map(r => r.toJSON()), main: this.mainIndex };\r\n    }\r\n    /**\r\n    Create a selection from a JSON representation.\r\n    */\r\n    static fromJSON(json) {\r\n        if (!json || !Array.isArray(json.ranges) || typeof json.main != \"number\" || json.main >= json.ranges.length)\r\n            throw new RangeError(\"Invalid JSON representation for EditorSelection\");\r\n        return new EditorSelection(json.ranges.map((r) => SelectionRange.fromJSON(r)), json.main);\r\n    }\r\n    /**\r\n    Create a selection holding a single range.\r\n    */\r\n    static single(anchor, head = anchor) {\r\n        return new EditorSelection([EditorSelection.range(anchor, head)], 0);\r\n    }\r\n    /**\r\n    Sort and merge the given set of ranges, creating a valid\r\n    selection.\r\n    */\r\n    static create(ranges, mainIndex = 0) {\r\n        if (ranges.length == 0)\r\n            throw new RangeError(\"A selection needs at least one range\");\r\n        for (let pos = 0, i = 0; i < ranges.length; i++) {\r\n            let range = ranges[i];\r\n            if (range.empty ? range.from <= pos : range.from < pos)\r\n                return EditorSelection.normalized(ranges.slice(), mainIndex);\r\n            pos = range.to;\r\n        }\r\n        return new EditorSelection(ranges, mainIndex);\r\n    }\r\n    /**\r\n    Create a cursor selection range at the given position. You can\r\n    safely ignore the optional arguments in most situations.\r\n    */\r\n    static cursor(pos, assoc = 0, bidiLevel, goalColumn) {\r\n        return SelectionRange.create(pos, pos, (assoc == 0 ? 0 : assoc < 0 ? 4 /* RangeFlag.AssocBefore */ : 8 /* RangeFlag.AssocAfter */) |\r\n            (bidiLevel == null ? 3 : Math.min(2, bidiLevel)) |\r\n            ((goalColumn !== null && goalColumn !== void 0 ? goalColumn : 33554431 /* RangeFlag.NoGoalColumn */) << 5 /* RangeFlag.GoalColumnOffset */));\r\n    }\r\n    /**\r\n    Create a selection range.\r\n    */\r\n    static range(anchor, head, goalColumn, bidiLevel) {\r\n        let flags = ((goalColumn !== null && goalColumn !== void 0 ? goalColumn : 33554431 /* RangeFlag.NoGoalColumn */) << 5 /* RangeFlag.GoalColumnOffset */) |\r\n            (bidiLevel == null ? 3 : Math.min(2, bidiLevel));\r\n        return head < anchor ? SelectionRange.create(head, anchor, 16 /* RangeFlag.Inverted */ | 8 /* RangeFlag.AssocAfter */ | flags)\r\n            : SelectionRange.create(anchor, head, (head > anchor ? 4 /* RangeFlag.AssocBefore */ : 0) | flags);\r\n    }\r\n    /**\r\n    @internal\r\n    */\r\n    static normalized(ranges, mainIndex = 0) {\r\n        let main = ranges[mainIndex];\r\n        ranges.sort((a, b) => a.from - b.from);\r\n        mainIndex = ranges.indexOf(main);\r\n        for (let i = 1; i < ranges.length; i++) {\r\n            let range = ranges[i], prev = ranges[i - 1];\r\n            if (range.empty ? range.from <= prev.to : range.from < prev.to) {\r\n                let from = prev.from, to = Math.max(range.to, prev.to);\r\n                if (i <= mainIndex)\r\n                    mainIndex--;\r\n                ranges.splice(--i, 2, range.anchor > range.head ? EditorSelection.range(to, from) : EditorSelection.range(from, to));\r\n            }\r\n        }\r\n        return new EditorSelection(ranges, mainIndex);\r\n    }\r\n}\r\nfunction checkSelection(selection, docLength) {\r\n    for (let range of selection.ranges)\r\n        if (range.to > docLength)\r\n            throw new RangeError(\"Selection points outside of document\");\r\n}\r\n\r\nlet nextID = 0;\r\n/**\r\nA facet is a labeled value that is associated with an editor\r\nstate. It takes inputs from any number of extensions, and combines\r\nthose into a single output value.\r\n\r\nExamples of uses of facets are the [tab\r\nsize](https://codemirror.net/6/docs/ref/#state.EditorState^tabSize), [editor\r\nattributes](https://codemirror.net/6/docs/ref/#view.EditorView^editorAttributes), and [update\r\nlisteners](https://codemirror.net/6/docs/ref/#view.EditorView^updateListener).\r\n*/\r\nclass Facet {\r\n    constructor(\r\n    /**\r\n    @internal\r\n    */\r\n    combine, \r\n    /**\r\n    @internal\r\n    */\r\n    compareInput, \r\n    /**\r\n    @internal\r\n    */\r\n    compare, isStatic, enables) {\r\n        this.combine = combine;\r\n        this.compareInput = compareInput;\r\n        this.compare = compare;\r\n        this.isStatic = isStatic;\r\n        /**\r\n        @internal\r\n        */\r\n        this.id = nextID++;\r\n        this.default = combine([]);\r\n        this.extensions = typeof enables == \"function\" ? enables(this) : enables;\r\n    }\r\n    /**\r\n    Define a new facet.\r\n    */\r\n    static define(config = {}) {\r\n        return new Facet(config.combine || ((a) => a), config.compareInput || ((a, b) => a === b), config.compare || (!config.combine ? sameArray : (a, b) => a === b), !!config.static, config.enables);\r\n    }\r\n    /**\r\n    Returns an extension that adds the given value to this facet.\r\n    */\r\n    of(value) {\r\n        return new FacetProvider([], this, 0 /* Provider.Static */, value);\r\n    }\r\n    /**\r\n    Create an extension that computes a value for the facet from a\r\n    state. You must take care to declare the parts of the state that\r\n    this value depends on, since your function is only called again\r\n    for a new state when one of those parts changed.\r\n    \r\n    In cases where your value depends only on a single field, you'll\r\n    want to use the [`from`](https://codemirror.net/6/docs/ref/#state.Facet.from) method instead.\r\n    */\r\n    compute(deps, get) {\r\n        if (this.isStatic)\r\n            throw new Error(\"Can't compute a static facet\");\r\n        return new FacetProvider(deps, this, 1 /* Provider.Single */, get);\r\n    }\r\n    /**\r\n    Create an extension that computes zero or more values for this\r\n    facet from a state.\r\n    */\r\n    computeN(deps, get) {\r\n        if (this.isStatic)\r\n            throw new Error(\"Can't compute a static facet\");\r\n        return new FacetProvider(deps, this, 2 /* Provider.Multi */, get);\r\n    }\r\n    from(field, get) {\r\n        if (!get)\r\n            get = x => x;\r\n        return this.compute([field], state => get(state.field(field)));\r\n    }\r\n}\r\nfunction sameArray(a, b) {\r\n    return a == b || a.length == b.length && a.every((e, i) => e === b[i]);\r\n}\r\nclass FacetProvider {\r\n    constructor(dependencies, facet, type, value) {\r\n        this.dependencies = dependencies;\r\n        this.facet = facet;\r\n        this.type = type;\r\n        this.value = value;\r\n        this.id = nextID++;\r\n    }\r\n    dynamicSlot(addresses) {\r\n        var _a;\r\n        let getter = this.value;\r\n        let compare = this.facet.compareInput;\r\n        let id = this.id, idx = addresses[id] >> 1, multi = this.type == 2 /* Provider.Multi */;\r\n        let depDoc = false, depSel = false, depAddrs = [];\r\n        for (let dep of this.dependencies) {\r\n            if (dep == \"doc\")\r\n                depDoc = true;\r\n            else if (dep == \"selection\")\r\n                depSel = true;\r\n            else if ((((_a = addresses[dep.id]) !== null && _a !== void 0 ? _a : 1) & 1) == 0)\r\n                depAddrs.push(addresses[dep.id]);\r\n        }\r\n        return {\r\n            create(state) {\r\n                state.values[idx] = getter(state);\r\n                return 1 /* SlotStatus.Changed */;\r\n            },\r\n            update(state, tr) {\r\n                if ((depDoc && tr.docChanged) || (depSel && (tr.docChanged || tr.selection)) || ensureAll(state, depAddrs)) {\r\n                    let newVal = getter(state);\r\n                    if (multi ? !compareArray(newVal, state.values[idx], compare) : !compare(newVal, state.values[idx])) {\r\n                        state.values[idx] = newVal;\r\n                        return 1 /* SlotStatus.Changed */;\r\n                    }\r\n                }\r\n                return 0;\r\n            },\r\n            reconfigure: (state, oldState) => {\r\n                let newVal, oldAddr = oldState.config.address[id];\r\n                if (oldAddr != null) {\r\n                    let oldVal = getAddr(oldState, oldAddr);\r\n                    if (this.dependencies.every(dep => {\r\n                        return dep instanceof Facet ? oldState.facet(dep) === state.facet(dep) :\r\n                            dep instanceof StateField ? oldState.field(dep, false) == state.field(dep, false) : true;\r\n                    }) || (multi ? compareArray(newVal = getter(state), oldVal, compare) : compare(newVal = getter(state), oldVal))) {\r\n                        state.values[idx] = oldVal;\r\n                        return 0;\r\n                    }\r\n                }\r\n                else {\r\n                    newVal = getter(state);\r\n                }\r\n                state.values[idx] = newVal;\r\n                return 1 /* SlotStatus.Changed */;\r\n            }\r\n        };\r\n    }\r\n}\r\nfunction compareArray(a, b, compare) {\r\n    if (a.length != b.length)\r\n        return false;\r\n    for (let i = 0; i < a.length; i++)\r\n        if (!compare(a[i], b[i]))\r\n            return false;\r\n    return true;\r\n}\r\nfunction ensureAll(state, addrs) {\r\n    let changed = false;\r\n    for (let addr of addrs)\r\n        if (ensureAddr(state, addr) & 1 /* SlotStatus.Changed */)\r\n            changed = true;\r\n    return changed;\r\n}\r\nfunction dynamicFacetSlot(addresses, facet, providers) {\r\n    let providerAddrs = providers.map(p => addresses[p.id]);\r\n    let providerTypes = providers.map(p => p.type);\r\n    let dynamic = providerAddrs.filter(p => !(p & 1));\r\n    let idx = addresses[facet.id] >> 1;\r\n    function get(state) {\r\n        let values = [];\r\n        for (let i = 0; i < providerAddrs.length; i++) {\r\n            let value = getAddr(state, providerAddrs[i]);\r\n            if (providerTypes[i] == 2 /* Provider.Multi */)\r\n                for (let val of value)\r\n                    values.push(val);\r\n            else\r\n                values.push(value);\r\n        }\r\n        return facet.combine(values);\r\n    }\r\n    return {\r\n        create(state) {\r\n            for (let addr of providerAddrs)\r\n                ensureAddr(state, addr);\r\n            state.values[idx] = get(state);\r\n            return 1 /* SlotStatus.Changed */;\r\n        },\r\n        update(state, tr) {\r\n            if (!ensureAll(state, dynamic))\r\n                return 0;\r\n            let value = get(state);\r\n            if (facet.compare(value, state.values[idx]))\r\n                return 0;\r\n            state.values[idx] = value;\r\n            return 1 /* SlotStatus.Changed */;\r\n        },\r\n        reconfigure(state, oldState) {\r\n            let depChanged = ensureAll(state, providerAddrs);\r\n            let oldProviders = oldState.config.facets[facet.id], oldValue = oldState.facet(facet);\r\n            if (oldProviders && !depChanged && sameArray(providers, oldProviders)) {\r\n                state.values[idx] = oldValue;\r\n                return 0;\r\n            }\r\n            let value = get(state);\r\n            if (facet.compare(value, oldValue)) {\r\n                state.values[idx] = oldValue;\r\n                return 0;\r\n            }\r\n            state.values[idx] = value;\r\n            return 1 /* SlotStatus.Changed */;\r\n        }\r\n    };\r\n}\r\nconst initField = /*@__PURE__*/Facet.define({ static: true });\r\n/**\r\nFields can store additional information in an editor state, and\r\nkeep it in sync with the rest of the state.\r\n*/\r\nclass StateField {\r\n    constructor(\r\n    /**\r\n    @internal\r\n    */\r\n    id, createF, updateF, compareF, \r\n    /**\r\n    @internal\r\n    */\r\n    spec) {\r\n        this.id = id;\r\n        this.createF = createF;\r\n        this.updateF = updateF;\r\n        this.compareF = compareF;\r\n        this.spec = spec;\r\n        /**\r\n        @internal\r\n        */\r\n        this.provides = undefined;\r\n    }\r\n    /**\r\n    Define a state field.\r\n    */\r\n    static define(config) {\r\n        let field = new StateField(nextID++, config.create, config.update, config.compare || ((a, b) => a === b), config);\r\n        if (config.provide)\r\n            field.provides = config.provide(field);\r\n        return field;\r\n    }\r\n    create(state) {\r\n        let init = state.facet(initField).find(i => i.field == this);\r\n        return ((init === null || init === void 0 ? void 0 : init.create) || this.createF)(state);\r\n    }\r\n    /**\r\n    @internal\r\n    */\r\n    slot(addresses) {\r\n        let idx = addresses[this.id] >> 1;\r\n        return {\r\n            create: (state) => {\r\n                state.values[idx] = this.create(state);\r\n                return 1 /* SlotStatus.Changed */;\r\n            },\r\n            update: (state, tr) => {\r\n                let oldVal = state.values[idx];\r\n                let value = this.updateF(oldVal, tr);\r\n                if (this.compareF(oldVal, value))\r\n                    return 0;\r\n                state.values[idx] = value;\r\n                return 1 /* SlotStatus.Changed */;\r\n            },\r\n            reconfigure: (state, oldState) => {\r\n                if (oldState.config.address[this.id] != null) {\r\n                    state.values[idx] = oldState.field(this);\r\n                    return 0;\r\n                }\r\n                state.values[idx] = this.create(state);\r\n                return 1 /* SlotStatus.Changed */;\r\n            }\r\n        };\r\n    }\r\n    /**\r\n    Returns an extension that enables this field and overrides the\r\n    way it is initialized. Can be useful when you need to provide a\r\n    non-default starting value for the field.\r\n    */\r\n    init(create) {\r\n        return [this, initField.of({ field: this, create })];\r\n    }\r\n    /**\r\n    State field instances can be used as\r\n    [`Extension`](https://codemirror.net/6/docs/ref/#state.Extension) values to enable the field in a\r\n    given state.\r\n    */\r\n    get extension() { return this; }\r\n}\r\nconst Prec_ = { lowest: 4, low: 3, default: 2, high: 1, highest: 0 };\r\nfunction prec(value) {\r\n    return (ext) => new PrecExtension(ext, value);\r\n}\r\n/**\r\nBy default extensions are registered in the order they are found\r\nin the flattened form of nested array that was provided.\r\nIndividual extension values can be assigned a precedence to\r\noverride this. Extensions that do not have a precedence set get\r\nthe precedence of the nearest parent with a precedence, or\r\n[`default`](https://codemirror.net/6/docs/ref/#state.Prec.default) if there is no such parent. The\r\nfinal ordering of extensions is determined by first sorting by\r\nprecedence and then by order within each precedence.\r\n*/\r\nconst Prec = {\r\n    /**\r\n    The highest precedence level, for extensions that should end up\r\n    near the start of the precedence ordering.\r\n    */\r\n    highest: /*@__PURE__*/prec(Prec_.highest),\r\n    /**\r\n    A higher-than-default precedence, for extensions that should\r\n    come before those with default precedence.\r\n    */\r\n    high: /*@__PURE__*/prec(Prec_.high),\r\n    /**\r\n    The default precedence, which is also used for extensions\r\n    without an explicit precedence.\r\n    */\r\n    default: /*@__PURE__*/prec(Prec_.default),\r\n    /**\r\n    A lower-than-default precedence.\r\n    */\r\n    low: /*@__PURE__*/prec(Prec_.low),\r\n    /**\r\n    The lowest precedence level. Meant for things that should end up\r\n    near the end of the extension order.\r\n    */\r\n    lowest: /*@__PURE__*/prec(Prec_.lowest)\r\n};\r\nclass PrecExtension {\r\n    constructor(inner, prec) {\r\n        this.inner = inner;\r\n        this.prec = prec;\r\n    }\r\n}\r\n/**\r\nExtension compartments can be used to make a configuration\r\ndynamic. By [wrapping](https://codemirror.net/6/docs/ref/#state.Compartment.of) part of your\r\nconfiguration in a compartment, you can later\r\n[replace](https://codemirror.net/6/docs/ref/#state.Compartment.reconfigure) that part through a\r\ntransaction.\r\n*/\r\nclass Compartment {\r\n    /**\r\n    Create an instance of this compartment to add to your [state\r\n    configuration](https://codemirror.net/6/docs/ref/#state.EditorStateConfig.extensions).\r\n    */\r\n    of(ext) { return new CompartmentInstance(this, ext); }\r\n    /**\r\n    Create an [effect](https://codemirror.net/6/docs/ref/#state.TransactionSpec.effects) that\r\n    reconfigures this compartment.\r\n    */\r\n    reconfigure(content) {\r\n        return Compartment.reconfigure.of({ compartment: this, extension: content });\r\n    }\r\n    /**\r\n    Get the current content of the compartment in the state, or\r\n    `undefined` if it isn't present.\r\n    */\r\n    get(state) {\r\n        return state.config.compartments.get(this);\r\n    }\r\n}\r\nclass CompartmentInstance {\r\n    constructor(compartment, inner) {\r\n        this.compartment = compartment;\r\n        this.inner = inner;\r\n    }\r\n}\r\nclass Configuration {\r\n    constructor(base, compartments, dynamicSlots, address, staticValues, facets) {\r\n        this.base = base;\r\n        this.compartments = compartments;\r\n        this.dynamicSlots = dynamicSlots;\r\n        this.address = address;\r\n        this.staticValues = staticValues;\r\n        this.facets = facets;\r\n        this.statusTemplate = [];\r\n        while (this.statusTemplate.length < dynamicSlots.length)\r\n            this.statusTemplate.push(0 /* SlotStatus.Unresolved */);\r\n    }\r\n    staticFacet(facet) {\r\n        let addr = this.address[facet.id];\r\n        return addr == null ? facet.default : this.staticValues[addr >> 1];\r\n    }\r\n    static resolve(base, compartments, oldState) {\r\n        let fields = [];\r\n        let facets = Object.create(null);\r\n        let newCompartments = new Map();\r\n        for (let ext of flatten(base, compartments, newCompartments)) {\r\n            if (ext instanceof StateField)\r\n                fields.push(ext);\r\n            else\r\n                (facets[ext.facet.id] || (facets[ext.facet.id] = [])).push(ext);\r\n        }\r\n        let address = Object.create(null);\r\n        let staticValues = [];\r\n        let dynamicSlots = [];\r\n        for (let field of fields) {\r\n            address[field.id] = dynamicSlots.length << 1;\r\n            dynamicSlots.push(a => field.slot(a));\r\n        }\r\n        let oldFacets = oldState === null || oldState === void 0 ? void 0 : oldState.config.facets;\r\n        for (let id in facets) {\r\n            let providers = facets[id], facet = providers[0].facet;\r\n            let oldProviders = oldFacets && oldFacets[id] || [];\r\n            if (providers.every(p => p.type == 0 /* Provider.Static */)) {\r\n                address[facet.id] = (staticValues.length << 1) | 1;\r\n                if (sameArray(oldProviders, providers)) {\r\n                    staticValues.push(oldState.facet(facet));\r\n                }\r\n                else {\r\n                    let value = facet.combine(providers.map(p => p.value));\r\n                    staticValues.push(oldState && facet.compare(value, oldState.facet(facet)) ? oldState.facet(facet) : value);\r\n                }\r\n            }\r\n            else {\r\n                for (let p of providers) {\r\n                    if (p.type == 0 /* Provider.Static */) {\r\n                        address[p.id] = (staticValues.length << 1) | 1;\r\n                        staticValues.push(p.value);\r\n                    }\r\n                    else {\r\n                        address[p.id] = dynamicSlots.length << 1;\r\n                        dynamicSlots.push(a => p.dynamicSlot(a));\r\n                    }\r\n                }\r\n                address[facet.id] = dynamicSlots.length << 1;\r\n                dynamicSlots.push(a => dynamicFacetSlot(a, facet, providers));\r\n            }\r\n        }\r\n        let dynamic = dynamicSlots.map(f => f(address));\r\n        return new Configuration(base, newCompartments, dynamic, address, staticValues, facets);\r\n    }\r\n}\r\nfunction flatten(extension, compartments, newCompartments) {\r\n    let result = [[], [], [], [], []];\r\n    let seen = new Map();\r\n    function inner(ext, prec) {\r\n        let known = seen.get(ext);\r\n        if (known != null) {\r\n            if (known <= prec)\r\n                return;\r\n            let found = result[known].indexOf(ext);\r\n            if (found > -1)\r\n                result[known].splice(found, 1);\r\n            if (ext instanceof CompartmentInstance)\r\n                newCompartments.delete(ext.compartment);\r\n        }\r\n        seen.set(ext, prec);\r\n        if (Array.isArray(ext)) {\r\n            for (let e of ext)\r\n                inner(e, prec);\r\n        }\r\n        else if (ext instanceof CompartmentInstance) {\r\n            if (newCompartments.has(ext.compartment))\r\n                throw new RangeError(`Duplicate use of compartment in extensions`);\r\n            let content = compartments.get(ext.compartment) || ext.inner;\r\n            newCompartments.set(ext.compartment, content);\r\n            inner(content, prec);\r\n        }\r\n        else if (ext instanceof PrecExtension) {\r\n            inner(ext.inner, ext.prec);\r\n        }\r\n        else if (ext instanceof StateField) {\r\n            result[prec].push(ext);\r\n            if (ext.provides)\r\n                inner(ext.provides, prec);\r\n        }\r\n        else if (ext instanceof FacetProvider) {\r\n            result[prec].push(ext);\r\n            if (ext.facet.extensions)\r\n                inner(ext.facet.extensions, Prec_.default);\r\n        }\r\n        else {\r\n            let content = ext.extension;\r\n            if (!content)\r\n                throw new Error(`Unrecognized extension value in extension set (${ext}). This sometimes happens because multiple instances of @codemirror/state are loaded, breaking instanceof checks.`);\r\n            inner(content, prec);\r\n        }\r\n    }\r\n    inner(extension, Prec_.default);\r\n    return result.reduce((a, b) => a.concat(b));\r\n}\r\nfunction ensureAddr(state, addr) {\r\n    if (addr & 1)\r\n        return 2 /* SlotStatus.Computed */;\r\n    let idx = addr >> 1;\r\n    let status = state.status[idx];\r\n    if (status == 4 /* SlotStatus.Computing */)\r\n        throw new Error(\"Cyclic dependency between fields and/or facets\");\r\n    if (status & 2 /* SlotStatus.Computed */)\r\n        return status;\r\n    state.status[idx] = 4 /* SlotStatus.Computing */;\r\n    let changed = state.computeSlot(state, state.config.dynamicSlots[idx]);\r\n    return state.status[idx] = 2 /* SlotStatus.Computed */ | changed;\r\n}\r\nfunction getAddr(state, addr) {\r\n    return addr & 1 ? state.config.staticValues[addr >> 1] : state.values[addr >> 1];\r\n}\r\n\r\nconst languageData = /*@__PURE__*/Facet.define();\r\nconst allowMultipleSelections = /*@__PURE__*/Facet.define({\r\n    combine: values => values.some(v => v),\r\n    static: true\r\n});\r\nconst lineSeparator = /*@__PURE__*/Facet.define({\r\n    combine: values => values.length ? values[0] : undefined,\r\n    static: true\r\n});\r\nconst changeFilter = /*@__PURE__*/Facet.define();\r\nconst transactionFilter = /*@__PURE__*/Facet.define();\r\nconst transactionExtender = /*@__PURE__*/Facet.define();\r\nconst readOnly = /*@__PURE__*/Facet.define({\r\n    combine: values => values.length ? values[0] : false\r\n});\r\n\r\n/**\r\nAnnotations are tagged values that are used to add metadata to\r\ntransactions in an extensible way. They should be used to model\r\nthings that effect the entire transaction (such as its [time\r\nstamp](https://codemirror.net/6/docs/ref/#state.Transaction^time) or information about its\r\n[origin](https://codemirror.net/6/docs/ref/#state.Transaction^userEvent)). For effects that happen\r\n_alongside_ the other changes made by the transaction, [state\r\neffects](https://codemirror.net/6/docs/ref/#state.StateEffect) are more appropriate.\r\n*/\r\nclass Annotation {\r\n    /**\r\n    @internal\r\n    */\r\n    constructor(\r\n    /**\r\n    The annotation type.\r\n    */\r\n    type, \r\n    /**\r\n    The value of this annotation.\r\n    */\r\n    value) {\r\n        this.type = type;\r\n        this.value = value;\r\n    }\r\n    /**\r\n    Define a new type of annotation.\r\n    */\r\n    static define() { return new AnnotationType(); }\r\n}\r\n/**\r\nMarker that identifies a type of [annotation](https://codemirror.net/6/docs/ref/#state.Annotation).\r\n*/\r\nclass AnnotationType {\r\n    /**\r\n    Create an instance of this annotation.\r\n    */\r\n    of(value) { return new Annotation(this, value); }\r\n}\r\n/**\r\nRepresentation of a type of state effect. Defined with\r\n[`StateEffect.define`](https://codemirror.net/6/docs/ref/#state.StateEffect^define).\r\n*/\r\nclass StateEffectType {\r\n    /**\r\n    @internal\r\n    */\r\n    constructor(\r\n    // The `any` types in these function types are there to work\r\n    // around TypeScript issue #37631, where the type guard on\r\n    // `StateEffect.is` mysteriously stops working when these properly\r\n    // have type `Value`.\r\n    /**\r\n    @internal\r\n    */\r\n    map) {\r\n        this.map = map;\r\n    }\r\n    /**\r\n    Create a [state effect](https://codemirror.net/6/docs/ref/#state.StateEffect) instance of this\r\n    type.\r\n    */\r\n    of(value) { return new StateEffect(this, value); }\r\n}\r\n/**\r\nState effects can be used to represent additional effects\r\nassociated with a [transaction](https://codemirror.net/6/docs/ref/#state.Transaction.effects). They\r\nare often useful to model changes to custom [state\r\nfields](https://codemirror.net/6/docs/ref/#state.StateField), when those changes aren't implicit in\r\ndocument or selection changes.\r\n*/\r\nclass StateEffect {\r\n    /**\r\n    @internal\r\n    */\r\n    constructor(\r\n    /**\r\n    @internal\r\n    */\r\n    type, \r\n    /**\r\n    The value of this effect.\r\n    */\r\n    value) {\r\n        this.type = type;\r\n        this.value = value;\r\n    }\r\n    /**\r\n    Map this effect through a position mapping. Will return\r\n    `undefined` when that ends up deleting the effect.\r\n    */\r\n    map(mapping) {\r\n        let mapped = this.type.map(this.value, mapping);\r\n        return mapped === undefined ? undefined : mapped == this.value ? this : new StateEffect(this.type, mapped);\r\n    }\r\n    /**\r\n    Tells you whether this effect object is of a given\r\n    [type](https://codemirror.net/6/docs/ref/#state.StateEffectType).\r\n    */\r\n    is(type) { return this.type == type; }\r\n    /**\r\n    Define a new effect type. The type parameter indicates the type\r\n    of values that his effect holds.\r\n    */\r\n    static define(spec = {}) {\r\n        return new StateEffectType(spec.map || (v => v));\r\n    }\r\n    /**\r\n    Map an array of effects through a change set.\r\n    */\r\n    static mapEffects(effects, mapping) {\r\n        if (!effects.length)\r\n            return effects;\r\n        let result = [];\r\n        for (let effect of effects) {\r\n            let mapped = effect.map(mapping);\r\n            if (mapped)\r\n                result.push(mapped);\r\n        }\r\n        return result;\r\n    }\r\n}\r\n/**\r\nThis effect can be used to reconfigure the root extensions of\r\nthe editor. Doing this will discard any extensions\r\n[appended](https://codemirror.net/6/docs/ref/#state.StateEffect^appendConfig), but does not reset\r\nthe content of [reconfigured](https://codemirror.net/6/docs/ref/#state.Compartment.reconfigure)\r\ncompartments.\r\n*/\r\nStateEffect.reconfigure = /*@__PURE__*/StateEffect.define();\r\n/**\r\nAppend extensions to the top-level configuration of the editor.\r\n*/\r\nStateEffect.appendConfig = /*@__PURE__*/StateEffect.define();\r\n/**\r\nChanges to the editor state are grouped into transactions.\r\nTypically, a user action creates a single transaction, which may\r\ncontain any number of document changes, may change the selection,\r\nor have other effects. Create a transaction by calling\r\n[`EditorState.update`](https://codemirror.net/6/docs/ref/#state.EditorState.update), or immediately\r\ndispatch one by calling\r\n[`EditorView.dispatch`](https://codemirror.net/6/docs/ref/#view.EditorView.dispatch).\r\n*/\r\nclass Transaction {\r\n    constructor(\r\n    /**\r\n    The state from which the transaction starts.\r\n    */\r\n    startState, \r\n    /**\r\n    The document changes made by this transaction.\r\n    */\r\n    changes, \r\n    /**\r\n    The selection set by this transaction, or undefined if it\r\n    doesn't explicitly set a selection.\r\n    */\r\n    selection, \r\n    /**\r\n    The effects added to the transaction.\r\n    */\r\n    effects, \r\n    /**\r\n    @internal\r\n    */\r\n    annotations, \r\n    /**\r\n    Whether the selection should be scrolled into view after this\r\n    transaction is dispatched.\r\n    */\r\n    scrollIntoView) {\r\n        this.startState = startState;\r\n        this.changes = changes;\r\n        this.selection = selection;\r\n        this.effects = effects;\r\n        this.annotations = annotations;\r\n        this.scrollIntoView = scrollIntoView;\r\n        /**\r\n        @internal\r\n        */\r\n        this._doc = null;\r\n        /**\r\n        @internal\r\n        */\r\n        this._state = null;\r\n        if (selection)\r\n            checkSelection(selection, changes.newLength);\r\n        if (!annotations.some((a) => a.type == Transaction.time))\r\n            this.annotations = annotations.concat(Transaction.time.of(Date.now()));\r\n    }\r\n    /**\r\n    @internal\r\n    */\r\n    static create(startState, changes, selection, effects, annotations, scrollIntoView) {\r\n        return new Transaction(startState, changes, selection, effects, annotations, scrollIntoView);\r\n    }\r\n    /**\r\n    The new document produced by the transaction. Contrary to\r\n    [`.state`](https://codemirror.net/6/docs/ref/#state.Transaction.state)`.doc`, accessing this won't\r\n    force the entire new state to be computed right away, so it is\r\n    recommended that [transaction\r\n    filters](https://codemirror.net/6/docs/ref/#state.EditorState^transactionFilter) use this getter\r\n    when they need to look at the new document.\r\n    */\r\n    get newDoc() {\r\n        return this._doc || (this._doc = this.changes.apply(this.startState.doc));\r\n    }\r\n    /**\r\n    The new selection produced by the transaction. If\r\n    [`this.selection`](https://codemirror.net/6/docs/ref/#state.Transaction.selection) is undefined,\r\n    this will [map](https://codemirror.net/6/docs/ref/#state.EditorSelection.map) the start state's\r\n    current selection through the changes made by the transaction.\r\n    */\r\n    get newSelection() {\r\n        return this.selection || this.startState.selection.map(this.changes);\r\n    }\r\n    /**\r\n    The new state created by the transaction. Computed on demand\r\n    (but retained for subsequent access), so it is recommended not to\r\n    access it in [transaction\r\n    filters](https://codemirror.net/6/docs/ref/#state.EditorState^transactionFilter) when possible.\r\n    */\r\n    get state() {\r\n        if (!this._state)\r\n            this.startState.applyTransaction(this);\r\n        return this._state;\r\n    }\r\n    /**\r\n    Get the value of the given annotation type, if any.\r\n    */\r\n    annotation(type) {\r\n        for (let ann of this.annotations)\r\n            if (ann.type == type)\r\n                return ann.value;\r\n        return undefined;\r\n    }\r\n    /**\r\n    Indicates whether the transaction changed the document.\r\n    */\r\n    get docChanged() { return !this.changes.empty; }\r\n    /**\r\n    Indicates whether this transaction reconfigures the state\r\n    (through a [configuration compartment](https://codemirror.net/6/docs/ref/#state.Compartment) or\r\n    with a top-level configuration\r\n    [effect](https://codemirror.net/6/docs/ref/#state.StateEffect^reconfigure).\r\n    */\r\n    get reconfigured() { return this.startState.config != this.state.config; }\r\n    /**\r\n    Returns true if the transaction has a [user\r\n    event](https://codemirror.net/6/docs/ref/#state.Transaction^userEvent) annotation that is equal to\r\n    or more specific than `event`. For example, if the transaction\r\n    has `\"select.pointer\"` as user event, `\"select\"` and\r\n    `\"select.pointer\"` will match it.\r\n    */\r\n    isUserEvent(event) {\r\n        let e = this.annotation(Transaction.userEvent);\r\n        return !!(e && (e == event || e.length > event.length && e.slice(0, event.length) == event && e[event.length] == \".\"));\r\n    }\r\n}\r\n/**\r\nAnnotation used to store transaction timestamps. Automatically\r\nadded to every transaction, holding `Date.now()`.\r\n*/\r\nTransaction.time = /*@__PURE__*/Annotation.define();\r\n/**\r\nAnnotation used to associate a transaction with a user interface\r\nevent. Holds a string identifying the event, using a\r\ndot-separated format to support attaching more specific\r\ninformation. The events used by the core libraries are:\r\n\r\n - `\"input\"` when content is entered\r\n   - `\"input.type\"` for typed input\r\n     - `\"input.type.compose\"` for composition\r\n   - `\"input.paste\"` for pasted input\r\n   - `\"input.drop\"` when adding content with drag-and-drop\r\n   - `\"input.complete\"` when autocompleting\r\n - `\"delete\"` when the user deletes content\r\n   - `\"delete.selection\"` when deleting the selection\r\n   - `\"delete.forward\"` when deleting forward from the selection\r\n   - `\"delete.backward\"` when deleting backward from the selection\r\n   - `\"delete.cut\"` when cutting to the clipboard\r\n - `\"move\"` when content is moved\r\n   - `\"move.drop\"` when content is moved within the editor through drag-and-drop\r\n - `\"select\"` when explicitly changing the selection\r\n   - `\"select.pointer\"` when selecting with a mouse or other pointing device\r\n - `\"undo\"` and `\"redo\"` for history actions\r\n\r\nUse [`isUserEvent`](https://codemirror.net/6/docs/ref/#state.Transaction.isUserEvent) to check\r\nwhether the annotation matches a given event.\r\n*/\r\nTransaction.userEvent = /*@__PURE__*/Annotation.define();\r\n/**\r\nAnnotation indicating whether a transaction should be added to\r\nthe undo history or not.\r\n*/\r\nTransaction.addToHistory = /*@__PURE__*/Annotation.define();\r\n/**\r\nAnnotation indicating (when present and true) that a transaction\r\nrepresents a change made by some other actor, not the user. This\r\nis used, for example, to tag other people's changes in\r\ncollaborative editing.\r\n*/\r\nTransaction.remote = /*@__PURE__*/Annotation.define();\r\nfunction joinRanges(a, b) {\r\n    let result = [];\r\n    for (let iA = 0, iB = 0;;) {\r\n        let from, to;\r\n        if (iA < a.length && (iB == b.length || b[iB] >= a[iA])) {\r\n            from = a[iA++];\r\n            to = a[iA++];\r\n        }\r\n        else if (iB < b.length) {\r\n            from = b[iB++];\r\n            to = b[iB++];\r\n        }\r\n        else\r\n            return result;\r\n        if (!result.length || result[result.length - 1] < from)\r\n            result.push(from, to);\r\n        else if (result[result.length - 1] < to)\r\n            result[result.length - 1] = to;\r\n    }\r\n}\r\nfunction mergeTransaction(a, b, sequential) {\r\n    var _a;\r\n    let mapForA, mapForB, changes;\r\n    if (sequential) {\r\n        mapForA = b.changes;\r\n        mapForB = ChangeSet.empty(b.changes.length);\r\n        changes = a.changes.compose(b.changes);\r\n    }\r\n    else {\r\n        mapForA = b.changes.map(a.changes);\r\n        mapForB = a.changes.mapDesc(b.changes, true);\r\n        changes = a.changes.compose(mapForA);\r\n    }\r\n    return {\r\n        changes,\r\n        selection: b.selection ? b.selection.map(mapForB) : (_a = a.selection) === null || _a === void 0 ? void 0 : _a.map(mapForA),\r\n        effects: StateEffect.mapEffects(a.effects, mapForA).concat(StateEffect.mapEffects(b.effects, mapForB)),\r\n        annotations: a.annotations.length ? a.annotations.concat(b.annotations) : b.annotations,\r\n        scrollIntoView: a.scrollIntoView || b.scrollIntoView\r\n    };\r\n}\r\nfunction resolveTransactionInner(state, spec, docSize) {\r\n    let sel = spec.selection, annotations = asArray(spec.annotations);\r\n    if (spec.userEvent)\r\n        annotations = annotations.concat(Transaction.userEvent.of(spec.userEvent));\r\n    return {\r\n        changes: spec.changes instanceof ChangeSet ? spec.changes\r\n            : ChangeSet.of(spec.changes || [], docSize, state.facet(lineSeparator)),\r\n        selection: sel && (sel instanceof EditorSelection ? sel : EditorSelection.single(sel.anchor, sel.head)),\r\n        effects: asArray(spec.effects),\r\n        annotations,\r\n        scrollIntoView: !!spec.scrollIntoView\r\n    };\r\n}\r\nfunction resolveTransaction(state, specs, filter) {\r\n    let s = resolveTransactionInner(state, specs.length ? specs[0] : {}, state.doc.length);\r\n    if (specs.length && specs[0].filter === false)\r\n        filter = false;\r\n    for (let i = 1; i < specs.length; i++) {\r\n        if (specs[i].filter === false)\r\n            filter = false;\r\n        let seq = !!specs[i].sequential;\r\n        s = mergeTransaction(s, resolveTransactionInner(state, specs[i], seq ? s.changes.newLength : state.doc.length), seq);\r\n    }\r\n    let tr = Transaction.create(state, s.changes, s.selection, s.effects, s.annotations, s.scrollIntoView);\r\n    return extendTransaction(filter ? filterTransaction(tr) : tr);\r\n}\r\n// Finish a transaction by applying filters if necessary.\r\nfunction filterTransaction(tr) {\r\n    let state = tr.startState;\r\n    // Change filters\r\n    let result = true;\r\n    for (let filter of state.facet(changeFilter)) {\r\n        let value = filter(tr);\r\n        if (value === false) {\r\n            result = false;\r\n            break;\r\n        }\r\n        if (Array.isArray(value))\r\n            result = result === true ? value : joinRanges(result, value);\r\n    }\r\n    if (result !== true) {\r\n        let changes, back;\r\n        if (result === false) {\r\n            back = tr.changes.invertedDesc;\r\n            changes = ChangeSet.empty(state.doc.length);\r\n        }\r\n        else {\r\n            let filtered = tr.changes.filter(result);\r\n            changes = filtered.changes;\r\n            back = filtered.filtered.mapDesc(filtered.changes).invertedDesc;\r\n        }\r\n        tr = Transaction.create(state, changes, tr.selection && tr.selection.map(back), StateEffect.mapEffects(tr.effects, back), tr.annotations, tr.scrollIntoView);\r\n    }\r\n    // Transaction filters\r\n    let filters = state.facet(transactionFilter);\r\n    for (let i = filters.length - 1; i >= 0; i--) {\r\n        let filtered = filters[i](tr);\r\n        if (filtered instanceof Transaction)\r\n            tr = filtered;\r\n        else if (Array.isArray(filtered) && filtered.length == 1 && filtered[0] instanceof Transaction)\r\n            tr = filtered[0];\r\n        else\r\n            tr = resolveTransaction(state, asArray(filtered), false);\r\n    }\r\n    return tr;\r\n}\r\nfunction extendTransaction(tr) {\r\n    let state = tr.startState, extenders = state.facet(transactionExtender), spec = tr;\r\n    for (let i = extenders.length - 1; i >= 0; i--) {\r\n        let extension = extenders[i](tr);\r\n        if (extension && Object.keys(extension).length)\r\n            spec = mergeTransaction(spec, resolveTransactionInner(state, extension, tr.changes.newLength), true);\r\n    }\r\n    return spec == tr ? tr : Transaction.create(state, tr.changes, tr.selection, spec.effects, spec.annotations, spec.scrollIntoView);\r\n}\r\nconst none = [];\r\nfunction asArray(value) {\r\n    return value == null ? none : Array.isArray(value) ? value : [value];\r\n}\r\n\r\n/**\r\nThe categories produced by a [character\r\ncategorizer](https://codemirror.net/6/docs/ref/#state.EditorState.charCategorizer). These are used\r\ndo things like selecting by word.\r\n*/\r\nvar CharCategory = /*@__PURE__*/(function (CharCategory) {\r\n    /**\r\n    Word characters.\r\n    */\r\n    CharCategory[CharCategory[\"Word\"] = 0] = \"Word\";\r\n    /**\r\n    Whitespace.\r\n    */\r\n    CharCategory[CharCategory[\"Space\"] = 1] = \"Space\";\r\n    /**\r\n    Anything else.\r\n    */\r\n    CharCategory[CharCategory[\"Other\"] = 2] = \"Other\";\r\nreturn CharCategory})(CharCategory || (CharCategory = {}));\r\nconst nonASCIISingleCaseWordChar = /[\\u00df\\u0587\\u0590-\\u05f4\\u0600-\\u06ff\\u3040-\\u309f\\u30a0-\\u30ff\\u3400-\\u4db5\\u4e00-\\u9fcc\\uac00-\\ud7af]/;\r\nlet wordChar;\r\ntry {\r\n    wordChar = /*@__PURE__*/new RegExp(\"[\\\\p{Alphabetic}\\\\p{Number}_]\", \"u\");\r\n}\r\ncatch (_) { }\r\nfunction hasWordChar(str) {\r\n    if (wordChar)\r\n        return wordChar.test(str);\r\n    for (let i = 0; i < str.length; i++) {\r\n        let ch = str[i];\r\n        if (/\\w/.test(ch) || ch > \"\\x80\" && (ch.toUpperCase() != ch.toLowerCase() || nonASCIISingleCaseWordChar.test(ch)))\r\n            return true;\r\n    }\r\n    return false;\r\n}\r\nfunction makeCategorizer(wordChars) {\r\n    return (char) => {\r\n        if (!/\\S/.test(char))\r\n            return CharCategory.Space;\r\n        if (hasWordChar(char))\r\n            return CharCategory.Word;\r\n        for (let i = 0; i < wordChars.length; i++)\r\n            if (char.indexOf(wordChars[i]) > -1)\r\n                return CharCategory.Word;\r\n        return CharCategory.Other;\r\n    };\r\n}\r\n\r\n/**\r\nThe editor state class is a persistent (immutable) data structure.\r\nTo update a state, you [create](https://codemirror.net/6/docs/ref/#state.EditorState.update) a\r\n[transaction](https://codemirror.net/6/docs/ref/#state.Transaction), which produces a _new_ state\r\ninstance, without modifying the original object.\r\n\r\nAs such, _never_ mutate properties of a state directly. That'll\r\njust break things.\r\n*/\r\nclass EditorState {\r\n    constructor(\r\n    /**\r\n    @internal\r\n    */\r\n    config, \r\n    /**\r\n    The current document.\r\n    */\r\n    doc, \r\n    /**\r\n    The current selection.\r\n    */\r\n    selection, \r\n    /**\r\n    @internal\r\n    */\r\n    values, computeSlot, tr) {\r\n        this.config = config;\r\n        this.doc = doc;\r\n        this.selection = selection;\r\n        this.values = values;\r\n        this.status = config.statusTemplate.slice();\r\n        this.computeSlot = computeSlot;\r\n        // Fill in the computed state immediately, so that further queries\r\n        // for it made during the update return this state\r\n        if (tr)\r\n            tr._state = this;\r\n        for (let i = 0; i < this.config.dynamicSlots.length; i++)\r\n            ensureAddr(this, i << 1);\r\n        this.computeSlot = null;\r\n    }\r\n    field(field, require = true) {\r\n        let addr = this.config.address[field.id];\r\n        if (addr == null) {\r\n            if (require)\r\n                throw new RangeError(\"Field is not present in this state\");\r\n            return undefined;\r\n        }\r\n        ensureAddr(this, addr);\r\n        return getAddr(this, addr);\r\n    }\r\n    /**\r\n    Create a [transaction](https://codemirror.net/6/docs/ref/#state.Transaction) that updates this\r\n    state. Any number of [transaction specs](https://codemirror.net/6/docs/ref/#state.TransactionSpec)\r\n    can be passed. Unless\r\n    [`sequential`](https://codemirror.net/6/docs/ref/#state.TransactionSpec.sequential) is set, the\r\n    [changes](https://codemirror.net/6/docs/ref/#state.TransactionSpec.changes) (if any) of each spec\r\n    are assumed to start in the _current_ document (not the document\r\n    produced by previous specs), and its\r\n    [selection](https://codemirror.net/6/docs/ref/#state.TransactionSpec.selection) and\r\n    [effects](https://codemirror.net/6/docs/ref/#state.TransactionSpec.effects) are assumed to refer\r\n    to the document created by its _own_ changes. The resulting\r\n    transaction contains the combined effect of all the different\r\n    specs. For [selection](https://codemirror.net/6/docs/ref/#state.TransactionSpec.selection), later\r\n    specs take precedence over earlier ones.\r\n    */\r\n    update(...specs) {\r\n        return resolveTransaction(this, specs, true);\r\n    }\r\n    /**\r\n    @internal\r\n    */\r\n    applyTransaction(tr) {\r\n        let conf = this.config, { base, compartments } = conf;\r\n        for (let effect of tr.effects) {\r\n            if (effect.is(Compartment.reconfigure)) {\r\n                if (conf) {\r\n                    compartments = new Map;\r\n                    conf.compartments.forEach((val, key) => compartments.set(key, val));\r\n                    conf = null;\r\n                }\r\n                compartments.set(effect.value.compartment, effect.value.extension);\r\n            }\r\n            else if (effect.is(StateEffect.reconfigure)) {\r\n                conf = null;\r\n                base = effect.value;\r\n            }\r\n            else if (effect.is(StateEffect.appendConfig)) {\r\n                conf = null;\r\n                base = asArray(base).concat(effect.value);\r\n            }\r\n        }\r\n        let startValues;\r\n        if (!conf) {\r\n            conf = Configuration.resolve(base, compartments, this);\r\n            let intermediateState = new EditorState(conf, this.doc, this.selection, conf.dynamicSlots.map(() => null), (state, slot) => slot.reconfigure(state, this), null);\r\n            startValues = intermediateState.values;\r\n        }\r\n        else {\r\n            startValues = tr.startState.values.slice();\r\n        }\r\n        new EditorState(conf, tr.newDoc, tr.newSelection, startValues, (state, slot) => slot.update(state, tr), tr);\r\n    }\r\n    /**\r\n    Create a [transaction spec](https://codemirror.net/6/docs/ref/#state.TransactionSpec) that\r\n    replaces every selection range with the given content.\r\n    */\r\n    replaceSelection(text) {\r\n        if (typeof text == \"string\")\r\n            text = this.toText(text);\r\n        return this.changeByRange(range => ({ changes: { from: range.from, to: range.to, insert: text },\r\n            range: EditorSelection.cursor(range.from + text.length) }));\r\n    }\r\n    /**\r\n    Create a set of changes and a new selection by running the given\r\n    function for each range in the active selection. The function\r\n    can return an optional set of changes (in the coordinate space\r\n    of the start document), plus an updated range (in the coordinate\r\n    space of the document produced by the call's own changes). This\r\n    method will merge all the changes and ranges into a single\r\n    changeset and selection, and return it as a [transaction\r\n    spec](https://codemirror.net/6/docs/ref/#state.TransactionSpec), which can be passed to\r\n    [`update`](https://codemirror.net/6/docs/ref/#state.EditorState.update).\r\n    */\r\n    changeByRange(f) {\r\n        let sel = this.selection;\r\n        let result1 = f(sel.ranges[0]);\r\n        let changes = this.changes(result1.changes), ranges = [result1.range];\r\n        let effects = asArray(result1.effects);\r\n        for (let i = 1; i < sel.ranges.length; i++) {\r\n            let result = f(sel.ranges[i]);\r\n            let newChanges = this.changes(result.changes), newMapped = newChanges.map(changes);\r\n            for (let j = 0; j < i; j++)\r\n                ranges[j] = ranges[j].map(newMapped);\r\n            let mapBy = changes.mapDesc(newChanges, true);\r\n            ranges.push(result.range.map(mapBy));\r\n            changes = changes.compose(newMapped);\r\n            effects = StateEffect.mapEffects(effects, newMapped).concat(StateEffect.mapEffects(asArray(result.effects), mapBy));\r\n        }\r\n        return {\r\n            changes,\r\n            selection: EditorSelection.create(ranges, sel.mainIndex),\r\n            effects\r\n        };\r\n    }\r\n    /**\r\n    Create a [change set](https://codemirror.net/6/docs/ref/#state.ChangeSet) from the given change\r\n    description, taking the state's document length and line\r\n    separator into account.\r\n    */\r\n    changes(spec = []) {\r\n        if (spec instanceof ChangeSet)\r\n            return spec;\r\n        return ChangeSet.of(spec, this.doc.length, this.facet(EditorState.lineSeparator));\r\n    }\r\n    /**\r\n    Using the state's [line\r\n    separator](https://codemirror.net/6/docs/ref/#state.EditorState^lineSeparator), create a\r\n    [`Text`](https://codemirror.net/6/docs/ref/#state.Text) instance from the given string.\r\n    */\r\n    toText(string) {\r\n        return Text.of(string.split(this.facet(EditorState.lineSeparator) || DefaultSplit));\r\n    }\r\n    /**\r\n    Return the given range of the document as a string.\r\n    */\r\n    sliceDoc(from = 0, to = this.doc.length) {\r\n        return this.doc.sliceString(from, to, this.lineBreak);\r\n    }\r\n    /**\r\n    Get the value of a state [facet](https://codemirror.net/6/docs/ref/#state.Facet).\r\n    */\r\n    facet(facet) {\r\n        let addr = this.config.address[facet.id];\r\n        if (addr == null)\r\n            return facet.default;\r\n        ensureAddr(this, addr);\r\n        return getAddr(this, addr);\r\n    }\r\n    /**\r\n    Convert this state to a JSON-serializable object. When custom\r\n    fields should be serialized, you can pass them in as an object\r\n    mapping property names (in the resulting object, which should\r\n    not use `doc` or `selection`) to fields.\r\n    */\r\n    toJSON(fields) {\r\n        let result = {\r\n            doc: this.sliceDoc(),\r\n            selection: this.selection.toJSON()\r\n        };\r\n        if (fields)\r\n            for (let prop in fields) {\r\n                let value = fields[prop];\r\n                if (value instanceof StateField && this.config.address[value.id] != null)\r\n                    result[prop] = value.spec.toJSON(this.field(fields[prop]), this);\r\n            }\r\n        return result;\r\n    }\r\n    /**\r\n    Deserialize a state from its JSON representation. When custom\r\n    fields should be deserialized, pass the same object you passed\r\n    to [`toJSON`](https://codemirror.net/6/docs/ref/#state.EditorState.toJSON) when serializing as\r\n    third argument.\r\n    */\r\n    static fromJSON(json, config = {}, fields) {\r\n        if (!json || typeof json.doc != \"string\")\r\n            throw new RangeError(\"Invalid JSON representation for EditorState\");\r\n        let fieldInit = [];\r\n        if (fields)\r\n            for (let prop in fields) {\r\n                if (Object.prototype.hasOwnProperty.call(json, prop)) {\r\n                    let field = fields[prop], value = json[prop];\r\n                    fieldInit.push(field.init(state => field.spec.fromJSON(value, state)));\r\n                }\r\n            }\r\n        return EditorState.create({\r\n            doc: json.doc,\r\n            selection: EditorSelection.fromJSON(json.selection),\r\n            extensions: config.extensions ? fieldInit.concat([config.extensions]) : fieldInit\r\n        });\r\n    }\r\n    /**\r\n    Create a new state. You'll usually only need this when\r\n    initializing an editor—updated states are created by applying\r\n    transactions.\r\n    */\r\n    static create(config = {}) {\r\n        let configuration = Configuration.resolve(config.extensions || [], new Map);\r\n        let doc = config.doc instanceof Text ? config.doc\r\n            : Text.of((config.doc || \"\").split(configuration.staticFacet(EditorState.lineSeparator) || DefaultSplit));\r\n        let selection = !config.selection ? EditorSelection.single(0)\r\n            : config.selection instanceof EditorSelection ? config.selection\r\n                : EditorSelection.single(config.selection.anchor, config.selection.head);\r\n        checkSelection(selection, doc.length);\r\n        if (!configuration.staticFacet(allowMultipleSelections))\r\n            selection = selection.asSingle();\r\n        return new EditorState(configuration, doc, selection, configuration.dynamicSlots.map(() => null), (state, slot) => slot.create(state), null);\r\n    }\r\n    /**\r\n    The size (in columns) of a tab in the document, determined by\r\n    the [`tabSize`](https://codemirror.net/6/docs/ref/#state.EditorState^tabSize) facet.\r\n    */\r\n    get tabSize() { return this.facet(EditorState.tabSize); }\r\n    /**\r\n    Get the proper [line-break](https://codemirror.net/6/docs/ref/#state.EditorState^lineSeparator)\r\n    string for this state.\r\n    */\r\n    get lineBreak() { return this.facet(EditorState.lineSeparator) || \"\\n\"; }\r\n    /**\r\n    Returns true when the editor is\r\n    [configured](https://codemirror.net/6/docs/ref/#state.EditorState^readOnly) to be read-only.\r\n    */\r\n    get readOnly() { return this.facet(readOnly); }\r\n    /**\r\n    Look up a translation for the given phrase (via the\r\n    [`phrases`](https://codemirror.net/6/docs/ref/#state.EditorState^phrases) facet), or return the\r\n    original string if no translation is found.\r\n    \r\n    If additional arguments are passed, they will be inserted in\r\n    place of markers like `$1` (for the first value) and `$2`, etc.\r\n    A single `$` is equivalent to `$1`, and `$$` will produce a\r\n    literal dollar sign.\r\n    */\r\n    phrase(phrase, ...insert) {\r\n        for (let map of this.facet(EditorState.phrases))\r\n            if (Object.prototype.hasOwnProperty.call(map, phrase)) {\r\n                phrase = map[phrase];\r\n                break;\r\n            }\r\n        if (insert.length)\r\n            phrase = phrase.replace(/\\$(\\$|\\d*)/g, (m, i) => {\r\n                if (i == \"$\")\r\n                    return \"$\";\r\n                let n = +(i || 1);\r\n                return !n || n > insert.length ? m : insert[n - 1];\r\n            });\r\n        return phrase;\r\n    }\r\n    /**\r\n    Find the values for a given language data field, provided by the\r\n    the [`languageData`](https://codemirror.net/6/docs/ref/#state.EditorState^languageData) facet.\r\n    \r\n    Examples of language data fields are...\r\n    \r\n    - [`\"commentTokens\"`](https://codemirror.net/6/docs/ref/#commands.CommentTokens) for specifying\r\n      comment syntax.\r\n    - [`\"autocomplete\"`](https://codemirror.net/6/docs/ref/#autocomplete.autocompletion^config.override)\r\n      for providing language-specific completion sources.\r\n    - [`\"wordChars\"`](https://codemirror.net/6/docs/ref/#state.EditorState.charCategorizer) for adding\r\n      characters that should be considered part of words in this\r\n      language.\r\n    - [`\"closeBrackets\"`](https://codemirror.net/6/docs/ref/#autocomplete.CloseBracketConfig) controls\r\n      bracket closing behavior.\r\n    */\r\n    languageDataAt(name, pos, side = -1) {\r\n        let values = [];\r\n        for (let provider of this.facet(languageData)) {\r\n            for (let result of provider(this, pos, side)) {\r\n                if (Object.prototype.hasOwnProperty.call(result, name))\r\n                    values.push(result[name]);\r\n            }\r\n        }\r\n        return values;\r\n    }\r\n    /**\r\n    Return a function that can categorize strings (expected to\r\n    represent a single [grapheme cluster](https://codemirror.net/6/docs/ref/#state.findClusterBreak))\r\n    into one of:\r\n    \r\n     - Word (contains an alphanumeric character or a character\r\n       explicitly listed in the local language's `\"wordChars\"`\r\n       language data, which should be a string)\r\n     - Space (contains only whitespace)\r\n     - Other (anything else)\r\n    */\r\n    charCategorizer(at) {\r\n        return makeCategorizer(this.languageDataAt(\"wordChars\", at).join(\"\"));\r\n    }\r\n    /**\r\n    Find the word at the given position, meaning the range\r\n    containing all [word](https://codemirror.net/6/docs/ref/#state.CharCategory.Word) characters\r\n    around it. If no word characters are adjacent to the position,\r\n    this returns null.\r\n    */\r\n    wordAt(pos) {\r\n        let { text, from, length } = this.doc.lineAt(pos);\r\n        let cat = this.charCategorizer(pos);\r\n        let start = pos - from, end = pos - from;\r\n        while (start > 0) {\r\n            let prev = findClusterBreak(text, start, false);\r\n            if (cat(text.slice(prev, start)) != CharCategory.Word)\r\n                break;\r\n            start = prev;\r\n        }\r\n        while (end < length) {\r\n            let next = findClusterBreak(text, end);\r\n            if (cat(text.slice(end, next)) != CharCategory.Word)\r\n                break;\r\n            end = next;\r\n        }\r\n        return start == end ? null : EditorSelection.range(start + from, end + from);\r\n    }\r\n}\r\n/**\r\nA facet that, when enabled, causes the editor to allow multiple\r\nranges to be selected. Be careful though, because by default the\r\neditor relies on the native DOM selection, which cannot handle\r\nmultiple selections. An extension like\r\n[`drawSelection`](https://codemirror.net/6/docs/ref/#view.drawSelection) can be used to make\r\nsecondary selections visible to the user.\r\n*/\r\nEditorState.allowMultipleSelections = allowMultipleSelections;\r\n/**\r\nConfigures the tab size to use in this state. The first\r\n(highest-precedence) value of the facet is used. If no value is\r\ngiven, this defaults to 4.\r\n*/\r\nEditorState.tabSize = /*@__PURE__*/Facet.define({\r\n    combine: values => values.length ? values[0] : 4\r\n});\r\n/**\r\nThe line separator to use. By default, any of `\"\\n\"`, `\"\\r\\n\"`\r\nand `\"\\r\"` is treated as a separator when splitting lines, and\r\nlines are joined with `\"\\n\"`.\r\n\r\nWhen you configure a value here, only that precise separator\r\nwill be used, allowing you to round-trip documents through the\r\neditor without normalizing line separators.\r\n*/\r\nEditorState.lineSeparator = lineSeparator;\r\n/**\r\nThis facet controls the value of the\r\n[`readOnly`](https://codemirror.net/6/docs/ref/#state.EditorState.readOnly) getter, which is\r\nconsulted by commands and extensions that implement editing\r\nfunctionality to determine whether they should apply. It\r\ndefaults to false, but when its highest-precedence value is\r\n`true`, such functionality disables itself.\r\n\r\nNot to be confused with\r\n[`EditorView.editable`](https://codemirror.net/6/docs/ref/#view.EditorView^editable), which\r\ncontrols whether the editor's DOM is set to be editable (and\r\nthus focusable).\r\n*/\r\nEditorState.readOnly = readOnly;\r\n/**\r\nRegisters translation phrases. The\r\n[`phrase`](https://codemirror.net/6/docs/ref/#state.EditorState.phrase) method will look through\r\nall objects registered with this facet to find translations for\r\nits argument.\r\n*/\r\nEditorState.phrases = /*@__PURE__*/Facet.define({\r\n    compare(a, b) {\r\n        let kA = Object.keys(a), kB = Object.keys(b);\r\n        return kA.length == kB.length && kA.every(k => a[k] == b[k]);\r\n    }\r\n});\r\n/**\r\nA facet used to register [language\r\ndata](https://codemirror.net/6/docs/ref/#state.EditorState.languageDataAt) providers.\r\n*/\r\nEditorState.languageData = languageData;\r\n/**\r\nFacet used to register change filters, which are called for each\r\ntransaction (unless explicitly\r\n[disabled](https://codemirror.net/6/docs/ref/#state.TransactionSpec.filter)), and can suppress\r\npart of the transaction's changes.\r\n\r\nSuch a function can return `true` to indicate that it doesn't\r\nwant to do anything, `false` to completely stop the changes in\r\nthe transaction, or a set of ranges in which changes should be\r\nsuppressed. Such ranges are represented as an array of numbers,\r\nwith each pair of two numbers indicating the start and end of a\r\nrange. So for example `[10, 20, 100, 110]` suppresses changes\r\nbetween 10 and 20, and between 100 and 110.\r\n*/\r\nEditorState.changeFilter = changeFilter;\r\n/**\r\nFacet used to register a hook that gets a chance to update or\r\nreplace transaction specs before they are applied. This will\r\nonly be applied for transactions that don't have\r\n[`filter`](https://codemirror.net/6/docs/ref/#state.TransactionSpec.filter) set to `false`. You\r\ncan either return a single transaction spec (possibly the input\r\ntransaction), or an array of specs (which will be combined in\r\nthe same way as the arguments to\r\n[`EditorState.update`](https://codemirror.net/6/docs/ref/#state.EditorState.update)).\r\n\r\nWhen possible, it is recommended to avoid accessing\r\n[`Transaction.state`](https://codemirror.net/6/docs/ref/#state.Transaction.state) in a filter,\r\nsince it will force creation of a state that will then be\r\ndiscarded again, if the transaction is actually filtered.\r\n\r\n(This functionality should be used with care. Indiscriminately\r\nmodifying transaction is likely to break something or degrade\r\nthe user experience.)\r\n*/\r\nEditorState.transactionFilter = transactionFilter;\r\n/**\r\nThis is a more limited form of\r\n[`transactionFilter`](https://codemirror.net/6/docs/ref/#state.EditorState^transactionFilter),\r\nwhich can only add\r\n[annotations](https://codemirror.net/6/docs/ref/#state.TransactionSpec.annotations) and\r\n[effects](https://codemirror.net/6/docs/ref/#state.TransactionSpec.effects). _But_, this type\r\nof filter runs even if the transaction has disabled regular\r\n[filtering](https://codemirror.net/6/docs/ref/#state.TransactionSpec.filter), making it suitable\r\nfor effects that don't need to touch the changes or selection,\r\nbut do want to process every transaction.\r\n\r\nExtenders run _after_ filters, when both are present.\r\n*/\r\nEditorState.transactionExtender = transactionExtender;\r\nCompartment.reconfigure = /*@__PURE__*/StateEffect.define();\r\n\r\n/**\r\nUtility function for combining behaviors to fill in a config\r\nobject from an array of provided configs. `defaults` should hold\r\ndefault values for all optional fields in `Config`.\r\n\r\nThe function will, by default, error\r\nwhen a field gets two values that aren't `===`-equal, but you can\r\nprovide combine functions per field to do something else.\r\n*/\r\nfunction combineConfig(configs, defaults, // Should hold only the optional properties of Config, but I haven't managed to express that\r\ncombine = {}) {\r\n    let result = {};\r\n    for (let config of configs)\r\n        for (let key of Object.keys(config)) {\r\n            let value = config[key], current = result[key];\r\n            if (current === undefined)\r\n                result[key] = value;\r\n            else if (current === value || value === undefined) ; // No conflict\r\n            else if (Object.hasOwnProperty.call(combine, key))\r\n                result[key] = combine[key](current, value);\r\n            else\r\n                throw new Error(\"Config merge conflict for field \" + key);\r\n        }\r\n    for (let key in defaults)\r\n        if (result[key] === undefined)\r\n            result[key] = defaults[key];\r\n    return result;\r\n}\r\n\r\n/**\r\nEach range is associated with a value, which must inherit from\r\nthis class.\r\n*/\r\nclass RangeValue {\r\n    /**\r\n    Compare this value with another value. Used when comparing\r\n    rangesets. The default implementation compares by identity.\r\n    Unless you are only creating a fixed number of unique instances\r\n    of your value type, it is a good idea to implement this\r\n    properly.\r\n    */\r\n    eq(other) { return this == other; }\r\n    /**\r\n    Create a [range](https://codemirror.net/6/docs/ref/#state.Range) with this value.\r\n    */\r\n    range(from, to = from) { return Range.create(from, to, this); }\r\n}\r\nRangeValue.prototype.startSide = RangeValue.prototype.endSide = 0;\r\nRangeValue.prototype.point = false;\r\nRangeValue.prototype.mapMode = MapMode.TrackDel;\r\n/**\r\nA range associates a value with a range of positions.\r\n*/\r\nclass Range {\r\n    constructor(\r\n    /**\r\n    The range's start position.\r\n    */\r\n    from, \r\n    /**\r\n    Its end position.\r\n    */\r\n    to, \r\n    /**\r\n    The value associated with this range.\r\n    */\r\n    value) {\r\n        this.from = from;\r\n        this.to = to;\r\n        this.value = value;\r\n    }\r\n    /**\r\n    @internal\r\n    */\r\n    static create(from, to, value) {\r\n        return new Range(from, to, value);\r\n    }\r\n}\r\nfunction cmpRange(a, b) {\r\n    return a.from - b.from || a.value.startSide - b.value.startSide;\r\n}\r\nclass Chunk {\r\n    constructor(from, to, value, \r\n    // Chunks are marked with the largest point that occurs\r\n    // in them (or -1 for no points), so that scans that are\r\n    // only interested in points (such as the\r\n    // heightmap-related logic) can skip range-only chunks.\r\n    maxPoint) {\r\n        this.from = from;\r\n        this.to = to;\r\n        this.value = value;\r\n        this.maxPoint = maxPoint;\r\n    }\r\n    get length() { return this.to[this.to.length - 1]; }\r\n    // Find the index of the given position and side. Use the ranges'\r\n    // `from` pos when `end == false`, `to` when `end == true`.\r\n    findIndex(pos, side, end, startAt = 0) {\r\n        let arr = end ? this.to : this.from;\r\n        for (let lo = startAt, hi = arr.length;;) {\r\n            if (lo == hi)\r\n                return lo;\r\n            let mid = (lo + hi) >> 1;\r\n            let diff = arr[mid] - pos || (end ? this.value[mid].endSide : this.value[mid].startSide) - side;\r\n            if (mid == lo)\r\n                return diff >= 0 ? lo : hi;\r\n            if (diff >= 0)\r\n                hi = mid;\r\n            else\r\n                lo = mid + 1;\r\n        }\r\n    }\r\n    between(offset, from, to, f) {\r\n        for (let i = this.findIndex(from, -1000000000 /* C.Far */, true), e = this.findIndex(to, 1000000000 /* C.Far */, false, i); i < e; i++)\r\n            if (f(this.from[i] + offset, this.to[i] + offset, this.value[i]) === false)\r\n                return false;\r\n    }\r\n    map(offset, changes) {\r\n        let value = [], from = [], to = [], newPos = -1, maxPoint = -1;\r\n        for (let i = 0; i < this.value.length; i++) {\r\n            let val = this.value[i], curFrom = this.from[i] + offset, curTo = this.to[i] + offset, newFrom, newTo;\r\n            if (curFrom == curTo) {\r\n                let mapped = changes.mapPos(curFrom, val.startSide, val.mapMode);\r\n                if (mapped == null)\r\n                    continue;\r\n                newFrom = newTo = mapped;\r\n                if (val.startSide != val.endSide) {\r\n                    newTo = changes.mapPos(curFrom, val.endSide);\r\n                    if (newTo < newFrom)\r\n                        continue;\r\n                }\r\n            }\r\n            else {\r\n                newFrom = changes.mapPos(curFrom, val.startSide);\r\n                newTo = changes.mapPos(curTo, val.endSide);\r\n                if (newFrom > newTo || newFrom == newTo && val.startSide > 0 && val.endSide <= 0)\r\n                    continue;\r\n            }\r\n            if ((newTo - newFrom || val.endSide - val.startSide) < 0)\r\n                continue;\r\n            if (newPos < 0)\r\n                newPos = newFrom;\r\n            if (val.point)\r\n                maxPoint = Math.max(maxPoint, newTo - newFrom);\r\n            value.push(val);\r\n            from.push(newFrom - newPos);\r\n            to.push(newTo - newPos);\r\n        }\r\n        return { mapped: value.length ? new Chunk(from, to, value, maxPoint) : null, pos: newPos };\r\n    }\r\n}\r\n/**\r\nA range set stores a collection of [ranges](https://codemirror.net/6/docs/ref/#state.Range) in a\r\nway that makes them efficient to [map](https://codemirror.net/6/docs/ref/#state.RangeSet.map) and\r\n[update](https://codemirror.net/6/docs/ref/#state.RangeSet.update). This is an immutable data\r\nstructure.\r\n*/\r\nclass RangeSet {\r\n    constructor(\r\n    /**\r\n    @internal\r\n    */\r\n    chunkPos, \r\n    /**\r\n    @internal\r\n    */\r\n    chunk, \r\n    /**\r\n    @internal\r\n    */\r\n    nextLayer, \r\n    /**\r\n    @internal\r\n    */\r\n    maxPoint) {\r\n        this.chunkPos = chunkPos;\r\n        this.chunk = chunk;\r\n        this.nextLayer = nextLayer;\r\n        this.maxPoint = maxPoint;\r\n    }\r\n    /**\r\n    @internal\r\n    */\r\n    static create(chunkPos, chunk, nextLayer, maxPoint) {\r\n        return new RangeSet(chunkPos, chunk, nextLayer, maxPoint);\r\n    }\r\n    /**\r\n    @internal\r\n    */\r\n    get length() {\r\n        let last = this.chunk.length - 1;\r\n        return last < 0 ? 0 : Math.max(this.chunkEnd(last), this.nextLayer.length);\r\n    }\r\n    /**\r\n    The number of ranges in the set.\r\n    */\r\n    get size() {\r\n        if (this.isEmpty)\r\n            return 0;\r\n        let size = this.nextLayer.size;\r\n        for (let chunk of this.chunk)\r\n            size += chunk.value.length;\r\n        return size;\r\n    }\r\n    /**\r\n    @internal\r\n    */\r\n    chunkEnd(index) {\r\n        return this.chunkPos[index] + this.chunk[index].length;\r\n    }\r\n    /**\r\n    Update the range set, optionally adding new ranges or filtering\r\n    out existing ones.\r\n    \r\n    (Note: The type parameter is just there as a kludge to work\r\n    around TypeScript variance issues that prevented `RangeSet<X>`\r\n    from being a subtype of `RangeSet<Y>` when `X` is a subtype of\r\n    `Y`.)\r\n    */\r\n    update(updateSpec) {\r\n        let { add = [], sort = false, filterFrom = 0, filterTo = this.length } = updateSpec;\r\n        let filter = updateSpec.filter;\r\n        if (add.length == 0 && !filter)\r\n            return this;\r\n        if (sort)\r\n            add = add.slice().sort(cmpRange);\r\n        if (this.isEmpty)\r\n            return add.length ? RangeSet.of(add) : this;\r\n        let cur = new LayerCursor(this, null, -1).goto(0), i = 0, spill = [];\r\n        let builder = new RangeSetBuilder();\r\n        while (cur.value || i < add.length) {\r\n            if (i < add.length && (cur.from - add[i].from || cur.startSide - add[i].value.startSide) >= 0) {\r\n                let range = add[i++];\r\n                if (!builder.addInner(range.from, range.to, range.value))\r\n                    spill.push(range);\r\n            }\r\n            else if (cur.rangeIndex == 1 && cur.chunkIndex < this.chunk.length &&\r\n                (i == add.length || this.chunkEnd(cur.chunkIndex) < add[i].from) &&\r\n                (!filter || filterFrom > this.chunkEnd(cur.chunkIndex) || filterTo < this.chunkPos[cur.chunkIndex]) &&\r\n                builder.addChunk(this.chunkPos[cur.chunkIndex], this.chunk[cur.chunkIndex])) {\r\n                cur.nextChunk();\r\n            }\r\n            else {\r\n                if (!filter || filterFrom > cur.to || filterTo < cur.from || filter(cur.from, cur.to, cur.value)) {\r\n                    if (!builder.addInner(cur.from, cur.to, cur.value))\r\n                        spill.push(Range.create(cur.from, cur.to, cur.value));\r\n                }\r\n                cur.next();\r\n            }\r\n        }\r\n        return builder.finishInner(this.nextLayer.isEmpty && !spill.length ? RangeSet.empty\r\n            : this.nextLayer.update({ add: spill, filter, filterFrom, filterTo }));\r\n    }\r\n    /**\r\n    Map this range set through a set of changes, return the new set.\r\n    */\r\n    map(changes) {\r\n        if (changes.empty || this.isEmpty)\r\n            return this;\r\n        let chunks = [], chunkPos = [], maxPoint = -1;\r\n        for (let i = 0; i < this.chunk.length; i++) {\r\n            let start = this.chunkPos[i], chunk = this.chunk[i];\r\n            let touch = changes.touchesRange(start, start + chunk.length);\r\n            if (touch === false) {\r\n                maxPoint = Math.max(maxPoint, chunk.maxPoint);\r\n                chunks.push(chunk);\r\n                chunkPos.push(changes.mapPos(start));\r\n            }\r\n            else if (touch === true) {\r\n                let { mapped, pos } = chunk.map(start, changes);\r\n                if (mapped) {\r\n                    maxPoint = Math.max(maxPoint, mapped.maxPoint);\r\n                    chunks.push(mapped);\r\n                    chunkPos.push(pos);\r\n                }\r\n            }\r\n        }\r\n        let next = this.nextLayer.map(changes);\r\n        return chunks.length == 0 ? next : new RangeSet(chunkPos, chunks, next || RangeSet.empty, maxPoint);\r\n    }\r\n    /**\r\n    Iterate over the ranges that touch the region `from` to `to`,\r\n    calling `f` for each. There is no guarantee that the ranges will\r\n    be reported in any specific order. When the callback returns\r\n    `false`, iteration stops.\r\n    */\r\n    between(from, to, f) {\r\n        if (this.isEmpty)\r\n            return;\r\n        for (let i = 0; i < this.chunk.length; i++) {\r\n            let start = this.chunkPos[i], chunk = this.chunk[i];\r\n            if (to >= start && from <= start + chunk.length &&\r\n                chunk.between(start, from - start, to - start, f) === false)\r\n                return;\r\n        }\r\n        this.nextLayer.between(from, to, f);\r\n    }\r\n    /**\r\n    Iterate over the ranges in this set, in order, including all\r\n    ranges that end at or after `from`.\r\n    */\r\n    iter(from = 0) {\r\n        return HeapCursor.from([this]).goto(from);\r\n    }\r\n    /**\r\n    @internal\r\n    */\r\n    get isEmpty() { return this.nextLayer == this; }\r\n    /**\r\n    Iterate over the ranges in a collection of sets, in order,\r\n    starting from `from`.\r\n    */\r\n    static iter(sets, from = 0) {\r\n        return HeapCursor.from(sets).goto(from);\r\n    }\r\n    /**\r\n    Iterate over two groups of sets, calling methods on `comparator`\r\n    to notify it of possible differences.\r\n    */\r\n    static compare(oldSets, newSets, \r\n    /**\r\n    This indicates how the underlying data changed between these\r\n    ranges, and is needed to synchronize the iteration. `from` and\r\n    `to` are coordinates in the _new_ space, after these changes.\r\n    */\r\n    textDiff, comparator, \r\n    /**\r\n    Can be used to ignore all non-point ranges, and points below\r\n    the given size. When -1, all ranges are compared.\r\n    */\r\n    minPointSize = -1) {\r\n        let a = oldSets.filter(set => set.maxPoint > 0 || !set.isEmpty && set.maxPoint >= minPointSize);\r\n        let b = newSets.filter(set => set.maxPoint > 0 || !set.isEmpty && set.maxPoint >= minPointSize);\r\n        let sharedChunks = findSharedChunks(a, b, textDiff);\r\n        let sideA = new SpanCursor(a, sharedChunks, minPointSize);\r\n        let sideB = new SpanCursor(b, sharedChunks, minPointSize);\r\n        textDiff.iterGaps((fromA, fromB, length) => compare(sideA, fromA, sideB, fromB, length, comparator));\r\n        if (textDiff.empty && textDiff.length == 0)\r\n            compare(sideA, 0, sideB, 0, 0, comparator);\r\n    }\r\n    /**\r\n    Compare the contents of two groups of range sets, returning true\r\n    if they are equivalent in the given range.\r\n    */\r\n    static eq(oldSets, newSets, from = 0, to) {\r\n        if (to == null)\r\n            to = 1000000000 /* C.Far */ - 1;\r\n        let a = oldSets.filter(set => !set.isEmpty && newSets.indexOf(set) < 0);\r\n        let b = newSets.filter(set => !set.isEmpty && oldSets.indexOf(set) < 0);\r\n        if (a.length != b.length)\r\n            return false;\r\n        if (!a.length)\r\n            return true;\r\n        let sharedChunks = findSharedChunks(a, b);\r\n        let sideA = new SpanCursor(a, sharedChunks, 0).goto(from), sideB = new SpanCursor(b, sharedChunks, 0).goto(from);\r\n        for (;;) {\r\n            if (sideA.to != sideB.to ||\r\n                !sameValues(sideA.active, sideB.active) ||\r\n                sideA.point && (!sideB.point || !sideA.point.eq(sideB.point)))\r\n                return false;\r\n            if (sideA.to > to)\r\n                return true;\r\n            sideA.next();\r\n            sideB.next();\r\n        }\r\n    }\r\n    /**\r\n    Iterate over a group of range sets at the same time, notifying\r\n    the iterator about the ranges covering every given piece of\r\n    content. Returns the open count (see\r\n    [`SpanIterator.span`](https://codemirror.net/6/docs/ref/#state.SpanIterator.span)) at the end\r\n    of the iteration.\r\n    */\r\n    static spans(sets, from, to, iterator, \r\n    /**\r\n    When given and greater than -1, only points of at least this\r\n    size are taken into account.\r\n    */\r\n    minPointSize = -1) {\r\n        let cursor = new SpanCursor(sets, null, minPointSize).goto(from), pos = from;\r\n        let openRanges = cursor.openStart;\r\n        for (;;) {\r\n            let curTo = Math.min(cursor.to, to);\r\n            if (cursor.point) {\r\n                let active = cursor.activeForPoint(cursor.to);\r\n                let openCount = cursor.pointFrom < from ? active.length + 1 : Math.min(active.length, openRanges);\r\n                iterator.point(pos, curTo, cursor.point, active, openCount, cursor.pointRank);\r\n                openRanges = Math.min(cursor.openEnd(curTo), active.length);\r\n            }\r\n            else if (curTo > pos) {\r\n                iterator.span(pos, curTo, cursor.active, openRanges);\r\n                openRanges = cursor.openEnd(curTo);\r\n            }\r\n            if (cursor.to > to)\r\n                return openRanges + (cursor.point && cursor.to > to ? 1 : 0);\r\n            pos = cursor.to;\r\n            cursor.next();\r\n        }\r\n    }\r\n    /**\r\n    Create a range set for the given range or array of ranges. By\r\n    default, this expects the ranges to be _sorted_ (by start\r\n    position and, if two start at the same position,\r\n    `value.startSide`). You can pass `true` as second argument to\r\n    cause the method to sort them.\r\n    */\r\n    static of(ranges, sort = false) {\r\n        let build = new RangeSetBuilder();\r\n        for (let range of ranges instanceof Range ? [ranges] : sort ? lazySort(ranges) : ranges)\r\n            build.add(range.from, range.to, range.value);\r\n        return build.finish();\r\n    }\r\n}\r\n/**\r\nThe empty set of ranges.\r\n*/\r\nRangeSet.empty = /*@__PURE__*/new RangeSet([], [], null, -1);\r\nfunction lazySort(ranges) {\r\n    if (ranges.length > 1)\r\n        for (let prev = ranges[0], i = 1; i < ranges.length; i++) {\r\n            let cur = ranges[i];\r\n            if (cmpRange(prev, cur) > 0)\r\n                return ranges.slice().sort(cmpRange);\r\n            prev = cur;\r\n        }\r\n    return ranges;\r\n}\r\nRangeSet.empty.nextLayer = RangeSet.empty;\r\n/**\r\nA range set builder is a data structure that helps build up a\r\n[range set](https://codemirror.net/6/docs/ref/#state.RangeSet) directly, without first allocating\r\nan array of [`Range`](https://codemirror.net/6/docs/ref/#state.Range) objects.\r\n*/\r\nclass RangeSetBuilder {\r\n    /**\r\n    Create an empty builder.\r\n    */\r\n    constructor() {\r\n        this.chunks = [];\r\n        this.chunkPos = [];\r\n        this.chunkStart = -1;\r\n        this.last = null;\r\n        this.lastFrom = -1000000000 /* C.Far */;\r\n        this.lastTo = -1000000000 /* C.Far */;\r\n        this.from = [];\r\n        this.to = [];\r\n        this.value = [];\r\n        this.maxPoint = -1;\r\n        this.setMaxPoint = -1;\r\n        this.nextLayer = null;\r\n    }\r\n    finishChunk(newArrays) {\r\n        this.chunks.push(new Chunk(this.from, this.to, this.value, this.maxPoint));\r\n        this.chunkPos.push(this.chunkStart);\r\n        this.chunkStart = -1;\r\n        this.setMaxPoint = Math.max(this.setMaxPoint, this.maxPoint);\r\n        this.maxPoint = -1;\r\n        if (newArrays) {\r\n            this.from = [];\r\n            this.to = [];\r\n            this.value = [];\r\n        }\r\n    }\r\n    /**\r\n    Add a range. Ranges should be added in sorted (by `from` and\r\n    `value.startSide`) order.\r\n    */\r\n    add(from, to, value) {\r\n        if (!this.addInner(from, to, value))\r\n            (this.nextLayer || (this.nextLayer = new RangeSetBuilder)).add(from, to, value);\r\n    }\r\n    /**\r\n    @internal\r\n    */\r\n    addInner(from, to, value) {\r\n        let diff = from - this.lastTo || value.startSide - this.last.endSide;\r\n        if (diff <= 0 && (from - this.lastFrom || value.startSide - this.last.startSide) < 0)\r\n            throw new Error(\"Ranges must be added sorted by `from` position and `startSide`\");\r\n        if (diff < 0)\r\n            return false;\r\n        if (this.from.length == 250 /* C.ChunkSize */)\r\n            this.finishChunk(true);\r\n        if (this.chunkStart < 0)\r\n            this.chunkStart = from;\r\n        this.from.push(from - this.chunkStart);\r\n        this.to.push(to - this.chunkStart);\r\n        this.last = value;\r\n        this.lastFrom = from;\r\n        this.lastTo = to;\r\n        this.value.push(value);\r\n        if (value.point)\r\n            this.maxPoint = Math.max(this.maxPoint, to - from);\r\n        return true;\r\n    }\r\n    /**\r\n    @internal\r\n    */\r\n    addChunk(from, chunk) {\r\n        if ((from - this.lastTo || chunk.value[0].startSide - this.last.endSide) < 0)\r\n            return false;\r\n        if (this.from.length)\r\n            this.finishChunk(true);\r\n        this.setMaxPoint = Math.max(this.setMaxPoint, chunk.maxPoint);\r\n        this.chunks.push(chunk);\r\n        this.chunkPos.push(from);\r\n        let last = chunk.value.length - 1;\r\n        this.last = chunk.value[last];\r\n        this.lastFrom = chunk.from[last] + from;\r\n        this.lastTo = chunk.to[last] + from;\r\n        return true;\r\n    }\r\n    /**\r\n    Finish the range set. Returns the new set. The builder can't be\r\n    used anymore after this has been called.\r\n    */\r\n    finish() { return this.finishInner(RangeSet.empty); }\r\n    /**\r\n    @internal\r\n    */\r\n    finishInner(next) {\r\n        if (this.from.length)\r\n            this.finishChunk(false);\r\n        if (this.chunks.length == 0)\r\n            return next;\r\n        let result = RangeSet.create(this.chunkPos, this.chunks, this.nextLayer ? this.nextLayer.finishInner(next) : next, this.setMaxPoint);\r\n        this.from = null; // Make sure further `add` calls produce errors\r\n        return result;\r\n    }\r\n}\r\nfunction findSharedChunks(a, b, textDiff) {\r\n    let inA = new Map();\r\n    for (let set of a)\r\n        for (let i = 0; i < set.chunk.length; i++)\r\n            if (set.chunk[i].maxPoint <= 0)\r\n                inA.set(set.chunk[i], set.chunkPos[i]);\r\n    let shared = new Set();\r\n    for (let set of b)\r\n        for (let i = 0; i < set.chunk.length; i++) {\r\n            let known = inA.get(set.chunk[i]);\r\n            if (known != null && (textDiff ? textDiff.mapPos(known) : known) == set.chunkPos[i] &&\r\n                !(textDiff === null || textDiff === void 0 ? void 0 : textDiff.touchesRange(known, known + set.chunk[i].length)))\r\n                shared.add(set.chunk[i]);\r\n        }\r\n    return shared;\r\n}\r\nclass LayerCursor {\r\n    constructor(layer, skip, minPoint, rank = 0) {\r\n        this.layer = layer;\r\n        this.skip = skip;\r\n        this.minPoint = minPoint;\r\n        this.rank = rank;\r\n    }\r\n    get startSide() { return this.value ? this.value.startSide : 0; }\r\n    get endSide() { return this.value ? this.value.endSide : 0; }\r\n    goto(pos, side = -1000000000 /* C.Far */) {\r\n        this.chunkIndex = this.rangeIndex = 0;\r\n        this.gotoInner(pos, side, false);\r\n        return this;\r\n    }\r\n    gotoInner(pos, side, forward) {\r\n        while (this.chunkIndex < this.layer.chunk.length) {\r\n            let next = this.layer.chunk[this.chunkIndex];\r\n            if (!(this.skip && this.skip.has(next) ||\r\n                this.layer.chunkEnd(this.chunkIndex) < pos ||\r\n                next.maxPoint < this.minPoint))\r\n                break;\r\n            this.chunkIndex++;\r\n            forward = false;\r\n        }\r\n        if (this.chunkIndex < this.layer.chunk.length) {\r\n            let rangeIndex = this.layer.chunk[this.chunkIndex].findIndex(pos - this.layer.chunkPos[this.chunkIndex], side, true);\r\n            if (!forward || this.rangeIndex < rangeIndex)\r\n                this.setRangeIndex(rangeIndex);\r\n        }\r\n        this.next();\r\n    }\r\n    forward(pos, side) {\r\n        if ((this.to - pos || this.endSide - side) < 0)\r\n            this.gotoInner(pos, side, true);\r\n    }\r\n    next() {\r\n        for (;;) {\r\n            if (this.chunkIndex == this.layer.chunk.length) {\r\n                this.from = this.to = 1000000000 /* C.Far */;\r\n                this.value = null;\r\n                break;\r\n            }\r\n            else {\r\n                let chunkPos = this.layer.chunkPos[this.chunkIndex], chunk = this.layer.chunk[this.chunkIndex];\r\n                let from = chunkPos + chunk.from[this.rangeIndex];\r\n                this.from = from;\r\n                this.to = chunkPos + chunk.to[this.rangeIndex];\r\n                this.value = chunk.value[this.rangeIndex];\r\n                this.setRangeIndex(this.rangeIndex + 1);\r\n                if (this.minPoint < 0 || this.value.point && this.to - this.from >= this.minPoint)\r\n                    break;\r\n            }\r\n        }\r\n    }\r\n    setRangeIndex(index) {\r\n        if (index == this.layer.chunk[this.chunkIndex].value.length) {\r\n            this.chunkIndex++;\r\n            if (this.skip) {\r\n                while (this.chunkIndex < this.layer.chunk.length && this.skip.has(this.layer.chunk[this.chunkIndex]))\r\n                    this.chunkIndex++;\r\n            }\r\n            this.rangeIndex = 0;\r\n        }\r\n        else {\r\n            this.rangeIndex = index;\r\n        }\r\n    }\r\n    nextChunk() {\r\n        this.chunkIndex++;\r\n        this.rangeIndex = 0;\r\n        this.next();\r\n    }\r\n    compare(other) {\r\n        return this.from - other.from || this.startSide - other.startSide || this.rank - other.rank ||\r\n            this.to - other.to || this.endSide - other.endSide;\r\n    }\r\n}\r\nclass HeapCursor {\r\n    constructor(heap) {\r\n        this.heap = heap;\r\n    }\r\n    static from(sets, skip = null, minPoint = -1) {\r\n        let heap = [];\r\n        for (let i = 0; i < sets.length; i++) {\r\n            for (let cur = sets[i]; !cur.isEmpty; cur = cur.nextLayer) {\r\n                if (cur.maxPoint >= minPoint)\r\n                    heap.push(new LayerCursor(cur, skip, minPoint, i));\r\n            }\r\n        }\r\n        return heap.length == 1 ? heap[0] : new HeapCursor(heap);\r\n    }\r\n    get startSide() { return this.value ? this.value.startSide : 0; }\r\n    goto(pos, side = -1000000000 /* C.Far */) {\r\n        for (let cur of this.heap)\r\n            cur.goto(pos, side);\r\n        for (let i = this.heap.length >> 1; i >= 0; i--)\r\n            heapBubble(this.heap, i);\r\n        this.next();\r\n        return this;\r\n    }\r\n    forward(pos, side) {\r\n        for (let cur of this.heap)\r\n            cur.forward(pos, side);\r\n        for (let i = this.heap.length >> 1; i >= 0; i--)\r\n            heapBubble(this.heap, i);\r\n        if ((this.to - pos || this.value.endSide - side) < 0)\r\n            this.next();\r\n    }\r\n    next() {\r\n        if (this.heap.length == 0) {\r\n            this.from = this.to = 1000000000 /* C.Far */;\r\n            this.value = null;\r\n            this.rank = -1;\r\n        }\r\n        else {\r\n            let top = this.heap[0];\r\n            this.from = top.from;\r\n            this.to = top.to;\r\n            this.value = top.value;\r\n            this.rank = top.rank;\r\n            if (top.value)\r\n                top.next();\r\n            heapBubble(this.heap, 0);\r\n        }\r\n    }\r\n}\r\nfunction heapBubble(heap, index) {\r\n    for (let cur = heap[index];;) {\r\n        let childIndex = (index << 1) + 1;\r\n        if (childIndex >= heap.length)\r\n            break;\r\n        let child = heap[childIndex];\r\n        if (childIndex + 1 < heap.length && child.compare(heap[childIndex + 1]) >= 0) {\r\n            child = heap[childIndex + 1];\r\n            childIndex++;\r\n        }\r\n        if (cur.compare(child) < 0)\r\n            break;\r\n        heap[childIndex] = cur;\r\n        heap[index] = child;\r\n        index = childIndex;\r\n    }\r\n}\r\nclass SpanCursor {\r\n    constructor(sets, skip, minPoint) {\r\n        this.minPoint = minPoint;\r\n        this.active = [];\r\n        this.activeTo = [];\r\n        this.activeRank = [];\r\n        this.minActive = -1;\r\n        // A currently active point range, if any\r\n        this.point = null;\r\n        this.pointFrom = 0;\r\n        this.pointRank = 0;\r\n        this.to = -1000000000 /* C.Far */;\r\n        this.endSide = 0;\r\n        // The amount of open active ranges at the start of the iterator.\r\n        // Not including points.\r\n        this.openStart = -1;\r\n        this.cursor = HeapCursor.from(sets, skip, minPoint);\r\n    }\r\n    goto(pos, side = -1000000000 /* C.Far */) {\r\n        this.cursor.goto(pos, side);\r\n        this.active.length = this.activeTo.length = this.activeRank.length = 0;\r\n        this.minActive = -1;\r\n        this.to = pos;\r\n        this.endSide = side;\r\n        this.openStart = -1;\r\n        this.next();\r\n        return this;\r\n    }\r\n    forward(pos, side) {\r\n        while (this.minActive > -1 && (this.activeTo[this.minActive] - pos || this.active[this.minActive].endSide - side) < 0)\r\n            this.removeActive(this.minActive);\r\n        this.cursor.forward(pos, side);\r\n    }\r\n    removeActive(index) {\r\n        remove(this.active, index);\r\n        remove(this.activeTo, index);\r\n        remove(this.activeRank, index);\r\n        this.minActive = findMinIndex(this.active, this.activeTo);\r\n    }\r\n    addActive(trackOpen) {\r\n        let i = 0, { value, to, rank } = this.cursor;\r\n        while (i < this.activeRank.length && this.activeRank[i] <= rank)\r\n            i++;\r\n        insert(this.active, i, value);\r\n        insert(this.activeTo, i, to);\r\n        insert(this.activeRank, i, rank);\r\n        if (trackOpen)\r\n            insert(trackOpen, i, this.cursor.from);\r\n        this.minActive = findMinIndex(this.active, this.activeTo);\r\n    }\r\n    // After calling this, if `this.point` != null, the next range is a\r\n    // point. Otherwise, it's a regular range, covered by `this.active`.\r\n    next() {\r\n        let from = this.to, wasPoint = this.point;\r\n        this.point = null;\r\n        let trackOpen = this.openStart < 0 ? [] : null;\r\n        for (;;) {\r\n            let a = this.minActive;\r\n            if (a > -1 && (this.activeTo[a] - this.cursor.from || this.active[a].endSide - this.cursor.startSide) < 0) {\r\n                if (this.activeTo[a] > from) {\r\n                    this.to = this.activeTo[a];\r\n                    this.endSide = this.active[a].endSide;\r\n                    break;\r\n                }\r\n                this.removeActive(a);\r\n                if (trackOpen)\r\n                    remove(trackOpen, a);\r\n            }\r\n            else if (!this.cursor.value) {\r\n                this.to = this.endSide = 1000000000 /* C.Far */;\r\n                break;\r\n            }\r\n            else if (this.cursor.from > from) {\r\n                this.to = this.cursor.from;\r\n                this.endSide = this.cursor.startSide;\r\n                break;\r\n            }\r\n            else {\r\n                let nextVal = this.cursor.value;\r\n                if (!nextVal.point) { // Opening a range\r\n                    this.addActive(trackOpen);\r\n                    this.cursor.next();\r\n                }\r\n                else if (wasPoint && this.cursor.to == this.to && this.cursor.from < this.cursor.to) {\r\n                    // Ignore any non-empty points that end precisely at the end of the prev point\r\n                    this.cursor.next();\r\n                }\r\n                else { // New point\r\n                    this.point = nextVal;\r\n                    this.pointFrom = this.cursor.from;\r\n                    this.pointRank = this.cursor.rank;\r\n                    this.to = this.cursor.to;\r\n                    this.endSide = nextVal.endSide;\r\n                    this.cursor.next();\r\n                    this.forward(this.to, this.endSide);\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        if (trackOpen) {\r\n            this.openStart = 0;\r\n            for (let i = trackOpen.length - 1; i >= 0 && trackOpen[i] < from; i--)\r\n                this.openStart++;\r\n        }\r\n    }\r\n    activeForPoint(to) {\r\n        if (!this.active.length)\r\n            return this.active;\r\n        let active = [];\r\n        for (let i = this.active.length - 1; i >= 0; i--) {\r\n            if (this.activeRank[i] < this.pointRank)\r\n                break;\r\n            if (this.activeTo[i] > to || this.activeTo[i] == to && this.active[i].endSide >= this.point.endSide)\r\n                active.push(this.active[i]);\r\n        }\r\n        return active.reverse();\r\n    }\r\n    openEnd(to) {\r\n        let open = 0;\r\n        for (let i = this.activeTo.length - 1; i >= 0 && this.activeTo[i] > to; i--)\r\n            open++;\r\n        return open;\r\n    }\r\n}\r\nfunction compare(a, startA, b, startB, length, comparator) {\r\n    a.goto(startA);\r\n    b.goto(startB);\r\n    let endB = startB + length;\r\n    let pos = startB, dPos = startB - startA;\r\n    for (;;) {\r\n        let diff = (a.to + dPos) - b.to || a.endSide - b.endSide;\r\n        let end = diff < 0 ? a.to + dPos : b.to, clipEnd = Math.min(end, endB);\r\n        if (a.point || b.point) {\r\n            if (!(a.point && b.point && (a.point == b.point || a.point.eq(b.point)) &&\r\n                sameValues(a.activeForPoint(a.to + dPos), b.activeForPoint(b.to))))\r\n                comparator.comparePoint(pos, clipEnd, a.point, b.point);\r\n        }\r\n        else {\r\n            if (clipEnd > pos && !sameValues(a.active, b.active))\r\n                comparator.compareRange(pos, clipEnd, a.active, b.active);\r\n        }\r\n        if (end > endB)\r\n            break;\r\n        pos = end;\r\n        if (diff <= 0)\r\n            a.next();\r\n        if (diff >= 0)\r\n            b.next();\r\n    }\r\n}\r\nfunction sameValues(a, b) {\r\n    if (a.length != b.length)\r\n        return false;\r\n    for (let i = 0; i < a.length; i++)\r\n        if (a[i] != b[i] && !a[i].eq(b[i]))\r\n            return false;\r\n    return true;\r\n}\r\nfunction remove(array, index) {\r\n    for (let i = index, e = array.length - 1; i < e; i++)\r\n        array[i] = array[i + 1];\r\n    array.pop();\r\n}\r\nfunction insert(array, index, value) {\r\n    for (let i = array.length - 1; i >= index; i--)\r\n        array[i + 1] = array[i];\r\n    array[index] = value;\r\n}\r\nfunction findMinIndex(value, array) {\r\n    let found = -1, foundPos = 1000000000 /* C.Far */;\r\n    for (let i = 0; i < array.length; i++)\r\n        if ((array[i] - foundPos || value[i].endSide - value[found].endSide) < 0) {\r\n            found = i;\r\n            foundPos = array[i];\r\n        }\r\n    return found;\r\n}\r\n\r\n/**\r\nCount the column position at the given offset into the string,\r\ntaking extending characters and tab size into account.\r\n*/\r\nfunction countColumn(string, tabSize, to = string.length) {\r\n    let n = 0;\r\n    for (let i = 0; i < to;) {\r\n        if (string.charCodeAt(i) == 9) {\r\n            n += tabSize - (n % tabSize);\r\n            i++;\r\n        }\r\n        else {\r\n            n++;\r\n            i = findClusterBreak(string, i);\r\n        }\r\n    }\r\n    return n;\r\n}\r\n/**\r\nFind the offset that corresponds to the given column position in a\r\nstring, taking extending characters and tab size into account. By\r\ndefault, the string length is returned when it is too short to\r\nreach the column. Pass `strict` true to make it return -1 in that\r\nsituation.\r\n*/\r\nfunction findColumn(string, col, tabSize, strict) {\r\n    for (let i = 0, n = 0;;) {\r\n        if (n >= col)\r\n            return i;\r\n        if (i == string.length)\r\n            break;\r\n        n += string.charCodeAt(i) == 9 ? tabSize - (n % tabSize) : 1;\r\n        i = findClusterBreak(string, i);\r\n    }\r\n    return strict === true ? -1 : string.length;\r\n}\r\n\r\n\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGNvZGVtaXJyb3Ivc3RhdGUvZGlzdC9pbmRleC5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFELEtBQUssd0JBQXdCLFlBQVk7QUFDOUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0QsR0FBRyxLQUFLLFdBQVc7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQixxQkFBcUI7QUFDckI7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLG1DQUFtQztBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyx1Q0FBdUM7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsMEJBQTBCO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyx1Q0FBdUM7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLDhCQUE4QjtBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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O0FBQ0E7QUFDQSxjQUFjLFdBQVc7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHdCQUF3QjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLG1CQUFtQjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLG1CQUFtQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsY0FBYztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsMEJBQTBCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxxQkFBcUI7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLHVDQUF1QztBQUNuRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrRkFBa0YsSUFBSTtBQUN0RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1RUFBdUU7QUFDdkU7QUFDQTtBQUNBLG9CQUFvQixrQkFBa0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsUUFBUTtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsUUFBUTtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG9DQUFvQztBQUN4RDtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsV0FBVyxJQUFJLE9BQU87QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixnQkFBZ0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHNCQUFzQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixxQ0FBcUM7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxxQkFBcUI7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLFdBQVcsOENBQThDO0FBQ3ZHLHFFQUFxRTtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHVCQUF1QjtBQUMvQztBQUNBO0FBQ0EsNEJBQTRCLE9BQU87QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLHFCQUFxQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0Q7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvSUFBb0ksT0FBTztBQUMzSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHVCQUF1QjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxpRUFBaUU7QUFDL0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLDBDQUEwQztBQUNoRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHVCQUF1QjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGNBQWM7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsdUJBQXVCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxtQkFBbUI7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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Q0FBK0MsK0JBQStCO0FBQzlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLFFBQVE7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLGlDQUFpQztBQUNoRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixjQUFjO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsT0FBTztBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxZQUFZO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isa0JBQWtCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDa1giLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0Bjb2RlbWlycm9yL3N0YXRlL2Rpc3QvaW5kZXguanM/YThlNSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcclxuVGhlIGRhdGEgc3RydWN0dXJlIGZvciBkb2N1bWVudHMuIEBub25hYnN0cmFjdFxyXG4qL1xyXG5jbGFzcyBUZXh0IHtcclxuICAgIC8qKlxyXG4gICAgQGludGVybmFsXHJcbiAgICAqL1xyXG4gICAgY29uc3RydWN0b3IoKSB7IH1cclxuICAgIC8qKlxyXG4gICAgR2V0IHRoZSBsaW5lIGRlc2NyaXB0aW9uIGFyb3VuZCB0aGUgZ2l2ZW4gcG9zaXRpb24uXHJcbiAgICAqL1xyXG4gICAgbGluZUF0KHBvcykge1xyXG4gICAgICAgIGlmIChwb3MgPCAwIHx8IHBvcyA+IHRoaXMubGVuZ3RoKVxyXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgSW52YWxpZCBwb3NpdGlvbiAke3Bvc30gaW4gZG9jdW1lbnQgb2YgbGVuZ3RoICR7dGhpcy5sZW5ndGh9YCk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubGluZUlubmVyKHBvcywgZmFsc2UsIDEsIDApO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICBHZXQgdGhlIGRlc2NyaXB0aW9uIGZvciB0aGUgZ2l2ZW4gKDEtYmFzZWQpIGxpbmUgbnVtYmVyLlxyXG4gICAgKi9cclxuICAgIGxpbmUobikge1xyXG4gICAgICAgIGlmIChuIDwgMSB8fCBuID4gdGhpcy5saW5lcylcclxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYEludmFsaWQgbGluZSBudW1iZXIgJHtufSBpbiAke3RoaXMubGluZXN9LWxpbmUgZG9jdW1lbnRgKTtcclxuICAgICAgICByZXR1cm4gdGhpcy5saW5lSW5uZXIobiwgdHJ1ZSwgMSwgMCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgIFJlcGxhY2UgYSByYW5nZSBvZiB0aGUgdGV4dCB3aXRoIHRoZSBnaXZlbiBjb250ZW50LlxyXG4gICAgKi9cclxuICAgIHJlcGxhY2UoZnJvbSwgdG8sIHRleHQpIHtcclxuICAgICAgICBsZXQgcGFydHMgPSBbXTtcclxuICAgICAgICB0aGlzLmRlY29tcG9zZSgwLCBmcm9tLCBwYXJ0cywgMiAvKiBPcGVuLlRvICovKTtcclxuICAgICAgICBpZiAodGV4dC5sZW5ndGgpXHJcbiAgICAgICAgICAgIHRleHQuZGVjb21wb3NlKDAsIHRleHQubGVuZ3RoLCBwYXJ0cywgMSAvKiBPcGVuLkZyb20gKi8gfCAyIC8qIE9wZW4uVG8gKi8pO1xyXG4gICAgICAgIHRoaXMuZGVjb21wb3NlKHRvLCB0aGlzLmxlbmd0aCwgcGFydHMsIDEgLyogT3Blbi5Gcm9tICovKTtcclxuICAgICAgICByZXR1cm4gVGV4dE5vZGUuZnJvbShwYXJ0cywgdGhpcy5sZW5ndGggLSAodG8gLSBmcm9tKSArIHRleHQubGVuZ3RoKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgQXBwZW5kIGFub3RoZXIgZG9jdW1lbnQgdG8gdGhpcyBvbmUuXHJcbiAgICAqL1xyXG4gICAgYXBwZW5kKG90aGVyKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucmVwbGFjZSh0aGlzLmxlbmd0aCwgdGhpcy5sZW5ndGgsIG90aGVyKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgUmV0cmlldmUgdGhlIHRleHQgYmV0d2VlbiB0aGUgZ2l2ZW4gcG9pbnRzLlxyXG4gICAgKi9cclxuICAgIHNsaWNlKGZyb20sIHRvID0gdGhpcy5sZW5ndGgpIHtcclxuICAgICAgICBsZXQgcGFydHMgPSBbXTtcclxuICAgICAgICB0aGlzLmRlY29tcG9zZShmcm9tLCB0bywgcGFydHMsIDApO1xyXG4gICAgICAgIHJldHVybiBUZXh0Tm9kZS5mcm9tKHBhcnRzLCB0byAtIGZyb20pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICBUZXN0IHdoZXRoZXIgdGhpcyB0ZXh0IGlzIGVxdWFsIHRvIGFub3RoZXIgaW5zdGFuY2UuXHJcbiAgICAqL1xyXG4gICAgZXEob3RoZXIpIHtcclxuICAgICAgICBpZiAob3RoZXIgPT0gdGhpcylcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgaWYgKG90aGVyLmxlbmd0aCAhPSB0aGlzLmxlbmd0aCB8fCBvdGhlci5saW5lcyAhPSB0aGlzLmxpbmVzKVxyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgbGV0IHN0YXJ0ID0gdGhpcy5zY2FuSWRlbnRpY2FsKG90aGVyLCAxKSwgZW5kID0gdGhpcy5sZW5ndGggLSB0aGlzLnNjYW5JZGVudGljYWwob3RoZXIsIC0xKTtcclxuICAgICAgICBsZXQgYSA9IG5ldyBSYXdUZXh0Q3Vyc29yKHRoaXMpLCBiID0gbmV3IFJhd1RleHRDdXJzb3Iob3RoZXIpO1xyXG4gICAgICAgIGZvciAobGV0IHNraXAgPSBzdGFydCwgcG9zID0gc3RhcnQ7Oykge1xyXG4gICAgICAgICAgICBhLm5leHQoc2tpcCk7XHJcbiAgICAgICAgICAgIGIubmV4dChza2lwKTtcclxuICAgICAgICAgICAgc2tpcCA9IDA7XHJcbiAgICAgICAgICAgIGlmIChhLmxpbmVCcmVhayAhPSBiLmxpbmVCcmVhayB8fCBhLmRvbmUgIT0gYi5kb25lIHx8IGEudmFsdWUgIT0gYi52YWx1ZSlcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgcG9zICs9IGEudmFsdWUubGVuZ3RoO1xyXG4gICAgICAgICAgICBpZiAoYS5kb25lIHx8IHBvcyA+PSBlbmQpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgIEl0ZXJhdGUgb3ZlciB0aGUgdGV4dC4gV2hlbiBgZGlyYCBpcyBgLTFgLCBpdGVyYXRpb24gaGFwcGVuc1xyXG4gICAgZnJvbSBlbmQgdG8gc3RhcnQuIFRoaXMgd2lsbCByZXR1cm4gbGluZXMgYW5kIHRoZSBicmVha3MgYmV0d2VlblxyXG4gICAgdGhlbSBhcyBzZXBhcmF0ZSBzdHJpbmdzLlxyXG4gICAgKi9cclxuICAgIGl0ZXIoZGlyID0gMSkgeyByZXR1cm4gbmV3IFJhd1RleHRDdXJzb3IodGhpcywgZGlyKTsgfVxyXG4gICAgLyoqXHJcbiAgICBJdGVyYXRlIG92ZXIgYSByYW5nZSBvZiB0aGUgdGV4dC4gV2hlbiBgZnJvbWAgPiBgdG9gLCB0aGVcclxuICAgIGl0ZXJhdG9yIHdpbGwgcnVuIGluIHJldmVyc2UuXHJcbiAgICAqL1xyXG4gICAgaXRlclJhbmdlKGZyb20sIHRvID0gdGhpcy5sZW5ndGgpIHsgcmV0dXJuIG5ldyBQYXJ0aWFsVGV4dEN1cnNvcih0aGlzLCBmcm9tLCB0byk7IH1cclxuICAgIC8qKlxyXG4gICAgUmV0dXJuIGEgY3Vyc29yIHRoYXQgaXRlcmF0ZXMgb3ZlciB0aGUgZ2l2ZW4gcmFuZ2Ugb2YgbGluZXMsXHJcbiAgICBfd2l0aG91dF8gcmV0dXJuaW5nIHRoZSBsaW5lIGJyZWFrcyBiZXR3ZWVuLCBhbmQgeWllbGRpbmcgZW1wdHlcclxuICAgIHN0cmluZ3MgZm9yIGVtcHR5IGxpbmVzLlxyXG4gICAgXHJcbiAgICBXaGVuIGBmcm9tYCBhbmQgYHRvYCBhcmUgZ2l2ZW4sIHRoZXkgc2hvdWxkIGJlIDEtYmFzZWQgbGluZSBudW1iZXJzLlxyXG4gICAgKi9cclxuICAgIGl0ZXJMaW5lcyhmcm9tLCB0bykge1xyXG4gICAgICAgIGxldCBpbm5lcjtcclxuICAgICAgICBpZiAoZnJvbSA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIGlubmVyID0gdGhpcy5pdGVyKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAodG8gPT0gbnVsbClcclxuICAgICAgICAgICAgICAgIHRvID0gdGhpcy5saW5lcyArIDE7XHJcbiAgICAgICAgICAgIGxldCBzdGFydCA9IHRoaXMubGluZShmcm9tKS5mcm9tO1xyXG4gICAgICAgICAgICBpbm5lciA9IHRoaXMuaXRlclJhbmdlKHN0YXJ0LCBNYXRoLm1heChzdGFydCwgdG8gPT0gdGhpcy5saW5lcyArIDEgPyB0aGlzLmxlbmd0aCA6IHRvIDw9IDEgPyAwIDogdGhpcy5saW5lKHRvIC0gMSkudG8pKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5ldyBMaW5lQ3Vyc29yKGlubmVyKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgQGludGVybmFsXHJcbiAgICAqL1xyXG4gICAgdG9TdHJpbmcoKSB7IHJldHVybiB0aGlzLnNsaWNlU3RyaW5nKDApOyB9XHJcbiAgICAvKipcclxuICAgIENvbnZlcnQgdGhlIGRvY3VtZW50IHRvIGFuIGFycmF5IG9mIGxpbmVzICh3aGljaCBjYW4gYmVcclxuICAgIGRlc2VyaWFsaXplZCBhZ2FpbiB2aWEgW2BUZXh0Lm9mYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5UZXh0Xm9mKSkuXHJcbiAgICAqL1xyXG4gICAgdG9KU09OKCkge1xyXG4gICAgICAgIGxldCBsaW5lcyA9IFtdO1xyXG4gICAgICAgIHRoaXMuZmxhdHRlbihsaW5lcyk7XHJcbiAgICAgICAgcmV0dXJuIGxpbmVzO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICBDcmVhdGUgYSBgVGV4dGAgaW5zdGFuY2UgZm9yIHRoZSBnaXZlbiBhcnJheSBvZiBsaW5lcy5cclxuICAgICovXHJcbiAgICBzdGF0aWMgb2YodGV4dCkge1xyXG4gICAgICAgIGlmICh0ZXh0Lmxlbmd0aCA9PSAwKVxyXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkEgZG9jdW1lbnQgbXVzdCBoYXZlIGF0IGxlYXN0IG9uZSBsaW5lXCIpO1xyXG4gICAgICAgIGlmICh0ZXh0Lmxlbmd0aCA9PSAxICYmICF0ZXh0WzBdKVxyXG4gICAgICAgICAgICByZXR1cm4gVGV4dC5lbXB0eTtcclxuICAgICAgICByZXR1cm4gdGV4dC5sZW5ndGggPD0gMzIgLyogVHJlZS5CcmFuY2ggKi8gPyBuZXcgVGV4dExlYWYodGV4dCkgOiBUZXh0Tm9kZS5mcm9tKFRleHRMZWFmLnNwbGl0KHRleHQsIFtdKSk7XHJcbiAgICB9XHJcbn1cclxuLy8gTGVhdmVzIHN0b3JlIGFuIGFycmF5IG9mIGxpbmUgc3RyaW5ncy4gVGhlcmUgYXJlIGFsd2F5cyBsaW5lIGJyZWFrc1xyXG4vLyBiZXR3ZWVuIHRoZXNlIHN0cmluZ3MuIExlYXZlcyBhcmUgbGltaXRlZCBpbiBzaXplIGFuZCBoYXZlIHRvIGJlXHJcbi8vIGNvbnRhaW5lZCBpbiBUZXh0Tm9kZSBpbnN0YW5jZXMgZm9yIGJpZ2dlciBkb2N1bWVudHMuXHJcbmNsYXNzIFRleHRMZWFmIGV4dGVuZHMgVGV4dCB7XHJcbiAgICBjb25zdHJ1Y3Rvcih0ZXh0LCBsZW5ndGggPSB0ZXh0TGVuZ3RoKHRleHQpKSB7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuICAgICAgICB0aGlzLnRleHQgPSB0ZXh0O1xyXG4gICAgICAgIHRoaXMubGVuZ3RoID0gbGVuZ3RoO1xyXG4gICAgfVxyXG4gICAgZ2V0IGxpbmVzKCkgeyByZXR1cm4gdGhpcy50ZXh0Lmxlbmd0aDsgfVxyXG4gICAgZ2V0IGNoaWxkcmVuKCkgeyByZXR1cm4gbnVsbDsgfVxyXG4gICAgbGluZUlubmVyKHRhcmdldCwgaXNMaW5lLCBsaW5lLCBvZmZzZXQpIHtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDs7IGkrKykge1xyXG4gICAgICAgICAgICBsZXQgc3RyaW5nID0gdGhpcy50ZXh0W2ldLCBlbmQgPSBvZmZzZXQgKyBzdHJpbmcubGVuZ3RoO1xyXG4gICAgICAgICAgICBpZiAoKGlzTGluZSA/IGxpbmUgOiBlbmQpID49IHRhcmdldClcclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgTGluZShvZmZzZXQsIGVuZCwgbGluZSwgc3RyaW5nKTtcclxuICAgICAgICAgICAgb2Zmc2V0ID0gZW5kICsgMTtcclxuICAgICAgICAgICAgbGluZSsrO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGRlY29tcG9zZShmcm9tLCB0bywgdGFyZ2V0LCBvcGVuKSB7XHJcbiAgICAgICAgbGV0IHRleHQgPSBmcm9tIDw9IDAgJiYgdG8gPj0gdGhpcy5sZW5ndGggPyB0aGlzXHJcbiAgICAgICAgICAgIDogbmV3IFRleHRMZWFmKHNsaWNlVGV4dCh0aGlzLnRleHQsIGZyb20sIHRvKSwgTWF0aC5taW4odG8sIHRoaXMubGVuZ3RoKSAtIE1hdGgubWF4KDAsIGZyb20pKTtcclxuICAgICAgICBpZiAob3BlbiAmIDEgLyogT3Blbi5Gcm9tICovKSB7XHJcbiAgICAgICAgICAgIGxldCBwcmV2ID0gdGFyZ2V0LnBvcCgpO1xyXG4gICAgICAgICAgICBsZXQgam9pbmVkID0gYXBwZW5kVGV4dCh0ZXh0LnRleHQsIHByZXYudGV4dC5zbGljZSgpLCAwLCB0ZXh0Lmxlbmd0aCk7XHJcbiAgICAgICAgICAgIGlmIChqb2luZWQubGVuZ3RoIDw9IDMyIC8qIFRyZWUuQnJhbmNoICovKSB7XHJcbiAgICAgICAgICAgICAgICB0YXJnZXQucHVzaChuZXcgVGV4dExlYWYoam9pbmVkLCBwcmV2Lmxlbmd0aCArIHRleHQubGVuZ3RoKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgbWlkID0gam9pbmVkLmxlbmd0aCA+PiAxO1xyXG4gICAgICAgICAgICAgICAgdGFyZ2V0LnB1c2gobmV3IFRleHRMZWFmKGpvaW5lZC5zbGljZSgwLCBtaWQpKSwgbmV3IFRleHRMZWFmKGpvaW5lZC5zbGljZShtaWQpKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRhcmdldC5wdXNoKHRleHQpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJlcGxhY2UoZnJvbSwgdG8sIHRleHQpIHtcclxuICAgICAgICBpZiAoISh0ZXh0IGluc3RhbmNlb2YgVGV4dExlYWYpKVxyXG4gICAgICAgICAgICByZXR1cm4gc3VwZXIucmVwbGFjZShmcm9tLCB0bywgdGV4dCk7XHJcbiAgICAgICAgbGV0IGxpbmVzID0gYXBwZW5kVGV4dCh0aGlzLnRleHQsIGFwcGVuZFRleHQodGV4dC50ZXh0LCBzbGljZVRleHQodGhpcy50ZXh0LCAwLCBmcm9tKSksIHRvKTtcclxuICAgICAgICBsZXQgbmV3TGVuID0gdGhpcy5sZW5ndGggKyB0ZXh0Lmxlbmd0aCAtICh0byAtIGZyb20pO1xyXG4gICAgICAgIGlmIChsaW5lcy5sZW5ndGggPD0gMzIgLyogVHJlZS5CcmFuY2ggKi8pXHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgVGV4dExlYWYobGluZXMsIG5ld0xlbik7XHJcbiAgICAgICAgcmV0dXJuIFRleHROb2RlLmZyb20oVGV4dExlYWYuc3BsaXQobGluZXMsIFtdKSwgbmV3TGVuKTtcclxuICAgIH1cclxuICAgIHNsaWNlU3RyaW5nKGZyb20sIHRvID0gdGhpcy5sZW5ndGgsIGxpbmVTZXAgPSBcIlxcblwiKSB7XHJcbiAgICAgICAgbGV0IHJlc3VsdCA9IFwiXCI7XHJcbiAgICAgICAgZm9yIChsZXQgcG9zID0gMCwgaSA9IDA7IHBvcyA8PSB0byAmJiBpIDwgdGhpcy50ZXh0Lmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGxldCBsaW5lID0gdGhpcy50ZXh0W2ldLCBlbmQgPSBwb3MgKyBsaW5lLmxlbmd0aDtcclxuICAgICAgICAgICAgaWYgKHBvcyA+IGZyb20gJiYgaSlcclxuICAgICAgICAgICAgICAgIHJlc3VsdCArPSBsaW5lU2VwO1xyXG4gICAgICAgICAgICBpZiAoZnJvbSA8IGVuZCAmJiB0byA+IHBvcylcclxuICAgICAgICAgICAgICAgIHJlc3VsdCArPSBsaW5lLnNsaWNlKE1hdGgubWF4KDAsIGZyb20gLSBwb3MpLCB0byAtIHBvcyk7XHJcbiAgICAgICAgICAgIHBvcyA9IGVuZCArIDE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcbiAgICBmbGF0dGVuKHRhcmdldCkge1xyXG4gICAgICAgIGZvciAobGV0IGxpbmUgb2YgdGhpcy50ZXh0KVxyXG4gICAgICAgICAgICB0YXJnZXQucHVzaChsaW5lKTtcclxuICAgIH1cclxuICAgIHNjYW5JZGVudGljYWwoKSB7IHJldHVybiAwOyB9XHJcbiAgICBzdGF0aWMgc3BsaXQodGV4dCwgdGFyZ2V0KSB7XHJcbiAgICAgICAgbGV0IHBhcnQgPSBbXSwgbGVuID0gLTE7XHJcbiAgICAgICAgZm9yIChsZXQgbGluZSBvZiB0ZXh0KSB7XHJcbiAgICAgICAgICAgIHBhcnQucHVzaChsaW5lKTtcclxuICAgICAgICAgICAgbGVuICs9IGxpbmUubGVuZ3RoICsgMTtcclxuICAgICAgICAgICAgaWYgKHBhcnQubGVuZ3RoID09IDMyIC8qIFRyZWUuQnJhbmNoICovKSB7XHJcbiAgICAgICAgICAgICAgICB0YXJnZXQucHVzaChuZXcgVGV4dExlYWYocGFydCwgbGVuKSk7XHJcbiAgICAgICAgICAgICAgICBwYXJ0ID0gW107XHJcbiAgICAgICAgICAgICAgICBsZW4gPSAtMTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobGVuID4gLTEpXHJcbiAgICAgICAgICAgIHRhcmdldC5wdXNoKG5ldyBUZXh0TGVhZihwYXJ0LCBsZW4pKTtcclxuICAgICAgICByZXR1cm4gdGFyZ2V0O1xyXG4gICAgfVxyXG59XHJcbi8vIE5vZGVzIHByb3ZpZGUgdGhlIHRyZWUgc3RydWN0dXJlIG9mIHRoZSBgVGV4dGAgdHlwZS4gVGhleSBzdG9yZSBhXHJcbi8vIG51bWJlciBvZiBvdGhlciBub2RlcyBvciBsZWF2ZXMsIHRha2luZyBjYXJlIHRvIGJhbGFuY2UgdGhlbXNlbHZlc1xyXG4vLyBvbiBjaGFuZ2VzLiBUaGVyZSBhcmUgaW1wbGllZCBsaW5lIGJyZWFrcyBfYmV0d2Vlbl8gdGhlIGNoaWxkcmVuIG9mXHJcbi8vIGEgbm9kZSAoYnV0IG5vdCBiZWZvcmUgdGhlIGZpcnN0IG9yIGFmdGVyIHRoZSBsYXN0IGNoaWxkKS5cclxuY2xhc3MgVGV4dE5vZGUgZXh0ZW5kcyBUZXh0IHtcclxuICAgIGNvbnN0cnVjdG9yKGNoaWxkcmVuLCBsZW5ndGgpIHtcclxuICAgICAgICBzdXBlcigpO1xyXG4gICAgICAgIHRoaXMuY2hpbGRyZW4gPSBjaGlsZHJlbjtcclxuICAgICAgICB0aGlzLmxlbmd0aCA9IGxlbmd0aDtcclxuICAgICAgICB0aGlzLmxpbmVzID0gMDtcclxuICAgICAgICBmb3IgKGxldCBjaGlsZCBvZiBjaGlsZHJlbilcclxuICAgICAgICAgICAgdGhpcy5saW5lcyArPSBjaGlsZC5saW5lcztcclxuICAgIH1cclxuICAgIGxpbmVJbm5lcih0YXJnZXQsIGlzTGluZSwgbGluZSwgb2Zmc2V0KSB7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7OyBpKyspIHtcclxuICAgICAgICAgICAgbGV0IGNoaWxkID0gdGhpcy5jaGlsZHJlbltpXSwgZW5kID0gb2Zmc2V0ICsgY2hpbGQubGVuZ3RoLCBlbmRMaW5lID0gbGluZSArIGNoaWxkLmxpbmVzIC0gMTtcclxuICAgICAgICAgICAgaWYgKChpc0xpbmUgPyBlbmRMaW5lIDogZW5kKSA+PSB0YXJnZXQpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY2hpbGQubGluZUlubmVyKHRhcmdldCwgaXNMaW5lLCBsaW5lLCBvZmZzZXQpO1xyXG4gICAgICAgICAgICBvZmZzZXQgPSBlbmQgKyAxO1xyXG4gICAgICAgICAgICBsaW5lID0gZW5kTGluZSArIDE7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZGVjb21wb3NlKGZyb20sIHRvLCB0YXJnZXQsIG9wZW4pIHtcclxuICAgICAgICBmb3IgKGxldCBpID0gMCwgcG9zID0gMDsgcG9zIDw9IHRvICYmIGkgPCB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGxldCBjaGlsZCA9IHRoaXMuY2hpbGRyZW5baV0sIGVuZCA9IHBvcyArIGNoaWxkLmxlbmd0aDtcclxuICAgICAgICAgICAgaWYgKGZyb20gPD0gZW5kICYmIHRvID49IHBvcykge1xyXG4gICAgICAgICAgICAgICAgbGV0IGNoaWxkT3BlbiA9IG9wZW4gJiAoKHBvcyA8PSBmcm9tID8gMSAvKiBPcGVuLkZyb20gKi8gOiAwKSB8IChlbmQgPj0gdG8gPyAyIC8qIE9wZW4uVG8gKi8gOiAwKSk7XHJcbiAgICAgICAgICAgICAgICBpZiAocG9zID49IGZyb20gJiYgZW5kIDw9IHRvICYmICFjaGlsZE9wZW4pXHJcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0LnB1c2goY2hpbGQpO1xyXG4gICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgIGNoaWxkLmRlY29tcG9zZShmcm9tIC0gcG9zLCB0byAtIHBvcywgdGFyZ2V0LCBjaGlsZE9wZW4pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHBvcyA9IGVuZCArIDE7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmVwbGFjZShmcm9tLCB0bywgdGV4dCkge1xyXG4gICAgICAgIGlmICh0ZXh0LmxpbmVzIDwgdGhpcy5saW5lcylcclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDAsIHBvcyA9IDA7IGkgPCB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgY2hpbGQgPSB0aGlzLmNoaWxkcmVuW2ldLCBlbmQgPSBwb3MgKyBjaGlsZC5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICAvLyBGYXN0IHBhdGg6IGlmIHRoZSBjaGFuZ2Ugb25seSBhZmZlY3RzIG9uZSBjaGlsZCBhbmQgdGhlXHJcbiAgICAgICAgICAgICAgICAvLyBjaGlsZCdzIHNpemUgcmVtYWlucyBpbiB0aGUgYWNjZXB0YWJsZSByYW5nZSwgb25seSB1cGRhdGVcclxuICAgICAgICAgICAgICAgIC8vIHRoYXQgY2hpbGRcclxuICAgICAgICAgICAgICAgIGlmIChmcm9tID49IHBvcyAmJiB0byA8PSBlbmQpIHtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgdXBkYXRlZCA9IGNoaWxkLnJlcGxhY2UoZnJvbSAtIHBvcywgdG8gLSBwb3MsIHRleHQpO1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCB0b3RhbExpbmVzID0gdGhpcy5saW5lcyAtIGNoaWxkLmxpbmVzICsgdXBkYXRlZC5saW5lcztcclxuICAgICAgICAgICAgICAgICAgICBpZiAodXBkYXRlZC5saW5lcyA8ICh0b3RhbExpbmVzID4+ICg1IC8qIFRyZWUuQnJhbmNoU2hpZnQgKi8gLSAxKSkgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgdXBkYXRlZC5saW5lcyA+ICh0b3RhbExpbmVzID4+ICg1IC8qIFRyZWUuQnJhbmNoU2hpZnQgKi8gKyAxKSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGNvcHkgPSB0aGlzLmNoaWxkcmVuLnNsaWNlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvcHlbaV0gPSB1cGRhdGVkO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFRleHROb2RlKGNvcHksIHRoaXMubGVuZ3RoIC0gKHRvIC0gZnJvbSkgKyB0ZXh0Lmxlbmd0aCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzdXBlci5yZXBsYWNlKHBvcywgZW5kLCB1cGRhdGVkKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHBvcyA9IGVuZCArIDE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICByZXR1cm4gc3VwZXIucmVwbGFjZShmcm9tLCB0bywgdGV4dCk7XHJcbiAgICB9XHJcbiAgICBzbGljZVN0cmluZyhmcm9tLCB0byA9IHRoaXMubGVuZ3RoLCBsaW5lU2VwID0gXCJcXG5cIikge1xyXG4gICAgICAgIGxldCByZXN1bHQgPSBcIlwiO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBwb3MgPSAwOyBpIDwgdGhpcy5jaGlsZHJlbi5sZW5ndGggJiYgcG9zIDw9IHRvOyBpKyspIHtcclxuICAgICAgICAgICAgbGV0IGNoaWxkID0gdGhpcy5jaGlsZHJlbltpXSwgZW5kID0gcG9zICsgY2hpbGQubGVuZ3RoO1xyXG4gICAgICAgICAgICBpZiAocG9zID4gZnJvbSAmJiBpKVxyXG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IGxpbmVTZXA7XHJcbiAgICAgICAgICAgIGlmIChmcm9tIDwgZW5kICYmIHRvID4gcG9zKVxyXG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IGNoaWxkLnNsaWNlU3RyaW5nKGZyb20gLSBwb3MsIHRvIC0gcG9zLCBsaW5lU2VwKTtcclxuICAgICAgICAgICAgcG9zID0gZW5kICsgMTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuICAgIGZsYXR0ZW4odGFyZ2V0KSB7XHJcbiAgICAgICAgZm9yIChsZXQgY2hpbGQgb2YgdGhpcy5jaGlsZHJlbilcclxuICAgICAgICAgICAgY2hpbGQuZmxhdHRlbih0YXJnZXQpO1xyXG4gICAgfVxyXG4gICAgc2NhbklkZW50aWNhbChvdGhlciwgZGlyKSB7XHJcbiAgICAgICAgaWYgKCEob3RoZXIgaW5zdGFuY2VvZiBUZXh0Tm9kZSkpXHJcbiAgICAgICAgICAgIHJldHVybiAwO1xyXG4gICAgICAgIGxldCBsZW5ndGggPSAwO1xyXG4gICAgICAgIGxldCBbaUEsIGlCLCBlQSwgZUJdID0gZGlyID4gMCA/IFswLCAwLCB0aGlzLmNoaWxkcmVuLmxlbmd0aCwgb3RoZXIuY2hpbGRyZW4ubGVuZ3RoXVxyXG4gICAgICAgICAgICA6IFt0aGlzLmNoaWxkcmVuLmxlbmd0aCAtIDEsIG90aGVyLmNoaWxkcmVuLmxlbmd0aCAtIDEsIC0xLCAtMV07XHJcbiAgICAgICAgZm9yICg7OyBpQSArPSBkaXIsIGlCICs9IGRpcikge1xyXG4gICAgICAgICAgICBpZiAoaUEgPT0gZUEgfHwgaUIgPT0gZUIpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbGVuZ3RoO1xyXG4gICAgICAgICAgICBsZXQgY2hBID0gdGhpcy5jaGlsZHJlbltpQV0sIGNoQiA9IG90aGVyLmNoaWxkcmVuW2lCXTtcclxuICAgICAgICAgICAgaWYgKGNoQSAhPSBjaEIpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbGVuZ3RoICsgY2hBLnNjYW5JZGVudGljYWwoY2hCLCBkaXIpO1xyXG4gICAgICAgICAgICBsZW5ndGggKz0gY2hBLmxlbmd0aCArIDE7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgc3RhdGljIGZyb20oY2hpbGRyZW4sIGxlbmd0aCA9IGNoaWxkcmVuLnJlZHVjZSgobCwgY2gpID0+IGwgKyBjaC5sZW5ndGggKyAxLCAtMSkpIHtcclxuICAgICAgICBsZXQgbGluZXMgPSAwO1xyXG4gICAgICAgIGZvciAobGV0IGNoIG9mIGNoaWxkcmVuKVxyXG4gICAgICAgICAgICBsaW5lcyArPSBjaC5saW5lcztcclxuICAgICAgICBpZiAobGluZXMgPCAzMiAvKiBUcmVlLkJyYW5jaCAqLykge1xyXG4gICAgICAgICAgICBsZXQgZmxhdCA9IFtdO1xyXG4gICAgICAgICAgICBmb3IgKGxldCBjaCBvZiBjaGlsZHJlbilcclxuICAgICAgICAgICAgICAgIGNoLmZsYXR0ZW4oZmxhdCk7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgVGV4dExlYWYoZmxhdCwgbGVuZ3RoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IGNodW5rID0gTWF0aC5tYXgoMzIgLyogVHJlZS5CcmFuY2ggKi8sIGxpbmVzID4+IDUgLyogVHJlZS5CcmFuY2hTaGlmdCAqLyksIG1heENodW5rID0gY2h1bmsgPDwgMSwgbWluQ2h1bmsgPSBjaHVuayA+PiAxO1xyXG4gICAgICAgIGxldCBjaHVua2VkID0gW10sIGN1cnJlbnRMaW5lcyA9IDAsIGN1cnJlbnRMZW4gPSAtMSwgY3VycmVudENodW5rID0gW107XHJcbiAgICAgICAgZnVuY3Rpb24gYWRkKGNoaWxkKSB7XHJcbiAgICAgICAgICAgIGxldCBsYXN0O1xyXG4gICAgICAgICAgICBpZiAoY2hpbGQubGluZXMgPiBtYXhDaHVuayAmJiBjaGlsZCBpbnN0YW5jZW9mIFRleHROb2RlKSB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBub2RlIG9mIGNoaWxkLmNoaWxkcmVuKVxyXG4gICAgICAgICAgICAgICAgICAgIGFkZChub2RlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChjaGlsZC5saW5lcyA+IG1pbkNodW5rICYmIChjdXJyZW50TGluZXMgPiBtaW5DaHVuayB8fCAhY3VycmVudExpbmVzKSkge1xyXG4gICAgICAgICAgICAgICAgZmx1c2goKTtcclxuICAgICAgICAgICAgICAgIGNodW5rZWQucHVzaChjaGlsZCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoY2hpbGQgaW5zdGFuY2VvZiBUZXh0TGVhZiAmJiBjdXJyZW50TGluZXMgJiZcclxuICAgICAgICAgICAgICAgIChsYXN0ID0gY3VycmVudENodW5rW2N1cnJlbnRDaHVuay5sZW5ndGggLSAxXSkgaW5zdGFuY2VvZiBUZXh0TGVhZiAmJlxyXG4gICAgICAgICAgICAgICAgY2hpbGQubGluZXMgKyBsYXN0LmxpbmVzIDw9IDMyIC8qIFRyZWUuQnJhbmNoICovKSB7XHJcbiAgICAgICAgICAgICAgICBjdXJyZW50TGluZXMgKz0gY2hpbGQubGluZXM7XHJcbiAgICAgICAgICAgICAgICBjdXJyZW50TGVuICs9IGNoaWxkLmxlbmd0aCArIDE7XHJcbiAgICAgICAgICAgICAgICBjdXJyZW50Q2h1bmtbY3VycmVudENodW5rLmxlbmd0aCAtIDFdID0gbmV3IFRleHRMZWFmKGxhc3QudGV4dC5jb25jYXQoY2hpbGQudGV4dCksIGxhc3QubGVuZ3RoICsgMSArIGNoaWxkLmxlbmd0aCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudExpbmVzICsgY2hpbGQubGluZXMgPiBjaHVuaylcclxuICAgICAgICAgICAgICAgICAgICBmbHVzaCgpO1xyXG4gICAgICAgICAgICAgICAgY3VycmVudExpbmVzICs9IGNoaWxkLmxpbmVzO1xyXG4gICAgICAgICAgICAgICAgY3VycmVudExlbiArPSBjaGlsZC5sZW5ndGggKyAxO1xyXG4gICAgICAgICAgICAgICAgY3VycmVudENodW5rLnB1c2goY2hpbGQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZ1bmN0aW9uIGZsdXNoKCkge1xyXG4gICAgICAgICAgICBpZiAoY3VycmVudExpbmVzID09IDApXHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIGNodW5rZWQucHVzaChjdXJyZW50Q2h1bmsubGVuZ3RoID09IDEgPyBjdXJyZW50Q2h1bmtbMF0gOiBUZXh0Tm9kZS5mcm9tKGN1cnJlbnRDaHVuaywgY3VycmVudExlbikpO1xyXG4gICAgICAgICAgICBjdXJyZW50TGVuID0gLTE7XHJcbiAgICAgICAgICAgIGN1cnJlbnRMaW5lcyA9IGN1cnJlbnRDaHVuay5sZW5ndGggPSAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmb3IgKGxldCBjaGlsZCBvZiBjaGlsZHJlbilcclxuICAgICAgICAgICAgYWRkKGNoaWxkKTtcclxuICAgICAgICBmbHVzaCgpO1xyXG4gICAgICAgIHJldHVybiBjaHVua2VkLmxlbmd0aCA9PSAxID8gY2h1bmtlZFswXSA6IG5ldyBUZXh0Tm9kZShjaHVua2VkLCBsZW5ndGgpO1xyXG4gICAgfVxyXG59XHJcblRleHQuZW1wdHkgPSAvKkBfX1BVUkVfXyovbmV3IFRleHRMZWFmKFtcIlwiXSwgMCk7XHJcbmZ1bmN0aW9uIHRleHRMZW5ndGgodGV4dCkge1xyXG4gICAgbGV0IGxlbmd0aCA9IC0xO1xyXG4gICAgZm9yIChsZXQgbGluZSBvZiB0ZXh0KVxyXG4gICAgICAgIGxlbmd0aCArPSBsaW5lLmxlbmd0aCArIDE7XHJcbiAgICByZXR1cm4gbGVuZ3RoO1xyXG59XHJcbmZ1bmN0aW9uIGFwcGVuZFRleHQodGV4dCwgdGFyZ2V0LCBmcm9tID0gMCwgdG8gPSAxZTkpIHtcclxuICAgIGZvciAobGV0IHBvcyA9IDAsIGkgPSAwLCBmaXJzdCA9IHRydWU7IGkgPCB0ZXh0Lmxlbmd0aCAmJiBwb3MgPD0gdG87IGkrKykge1xyXG4gICAgICAgIGxldCBsaW5lID0gdGV4dFtpXSwgZW5kID0gcG9zICsgbGluZS5sZW5ndGg7XHJcbiAgICAgICAgaWYgKGVuZCA+PSBmcm9tKSB7XHJcbiAgICAgICAgICAgIGlmIChlbmQgPiB0bylcclxuICAgICAgICAgICAgICAgIGxpbmUgPSBsaW5lLnNsaWNlKDAsIHRvIC0gcG9zKTtcclxuICAgICAgICAgICAgaWYgKHBvcyA8IGZyb20pXHJcbiAgICAgICAgICAgICAgICBsaW5lID0gbGluZS5zbGljZShmcm9tIC0gcG9zKTtcclxuICAgICAgICAgICAgaWYgKGZpcnN0KSB7XHJcbiAgICAgICAgICAgICAgICB0YXJnZXRbdGFyZ2V0Lmxlbmd0aCAtIDFdICs9IGxpbmU7XHJcbiAgICAgICAgICAgICAgICBmaXJzdCA9IGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgIHRhcmdldC5wdXNoKGxpbmUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBwb3MgPSBlbmQgKyAxO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRhcmdldDtcclxufVxyXG5mdW5jdGlvbiBzbGljZVRleHQodGV4dCwgZnJvbSwgdG8pIHtcclxuICAgIHJldHVybiBhcHBlbmRUZXh0KHRleHQsIFtcIlwiXSwgZnJvbSwgdG8pO1xyXG59XHJcbmNsYXNzIFJhd1RleHRDdXJzb3Ige1xyXG4gICAgY29uc3RydWN0b3IodGV4dCwgZGlyID0gMSkge1xyXG4gICAgICAgIHRoaXMuZGlyID0gZGlyO1xyXG4gICAgICAgIHRoaXMuZG9uZSA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMubGluZUJyZWFrID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy52YWx1ZSA9IFwiXCI7XHJcbiAgICAgICAgdGhpcy5ub2RlcyA9IFt0ZXh0XTtcclxuICAgICAgICB0aGlzLm9mZnNldHMgPSBbZGlyID4gMCA/IDEgOiAodGV4dCBpbnN0YW5jZW9mIFRleHRMZWFmID8gdGV4dC50ZXh0Lmxlbmd0aCA6IHRleHQuY2hpbGRyZW4ubGVuZ3RoKSA8PCAxXTtcclxuICAgIH1cclxuICAgIG5leHRJbm5lcihza2lwLCBkaXIpIHtcclxuICAgICAgICB0aGlzLmRvbmUgPSB0aGlzLmxpbmVCcmVhayA9IGZhbHNlO1xyXG4gICAgICAgIGZvciAoOzspIHtcclxuICAgICAgICAgICAgbGV0IGxhc3QgPSB0aGlzLm5vZGVzLmxlbmd0aCAtIDE7XHJcbiAgICAgICAgICAgIGxldCB0b3AgPSB0aGlzLm5vZGVzW2xhc3RdLCBvZmZzZXRWYWx1ZSA9IHRoaXMub2Zmc2V0c1tsYXN0XSwgb2Zmc2V0ID0gb2Zmc2V0VmFsdWUgPj4gMTtcclxuICAgICAgICAgICAgbGV0IHNpemUgPSB0b3AgaW5zdGFuY2VvZiBUZXh0TGVhZiA/IHRvcC50ZXh0Lmxlbmd0aCA6IHRvcC5jaGlsZHJlbi5sZW5ndGg7XHJcbiAgICAgICAgICAgIGlmIChvZmZzZXQgPT0gKGRpciA+IDAgPyBzaXplIDogMCkpIHtcclxuICAgICAgICAgICAgICAgIGlmIChsYXN0ID09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRvbmUgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudmFsdWUgPSBcIlwiO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGRpciA+IDApXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vZmZzZXRzW2xhc3QgLSAxXSsrO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5ub2Rlcy5wb3AoKTtcclxuICAgICAgICAgICAgICAgIHRoaXMub2Zmc2V0cy5wb3AoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICgob2Zmc2V0VmFsdWUgJiAxKSA9PSAoZGlyID4gMCA/IDAgOiAxKSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5vZmZzZXRzW2xhc3RdICs9IGRpcjtcclxuICAgICAgICAgICAgICAgIGlmIChza2lwID09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmxpbmVCcmVhayA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy52YWx1ZSA9IFwiXFxuXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBza2lwLS07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAodG9wIGluc3RhbmNlb2YgVGV4dExlYWYpIHtcclxuICAgICAgICAgICAgICAgIC8vIE1vdmUgdG8gdGhlIG5leHQgc3RyaW5nXHJcbiAgICAgICAgICAgICAgICBsZXQgbmV4dCA9IHRvcC50ZXh0W29mZnNldCArIChkaXIgPCAwID8gLTEgOiAwKV07XHJcbiAgICAgICAgICAgICAgICB0aGlzLm9mZnNldHNbbGFzdF0gKz0gZGlyO1xyXG4gICAgICAgICAgICAgICAgaWYgKG5leHQubGVuZ3RoID4gTWF0aC5tYXgoMCwgc2tpcCkpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnZhbHVlID0gc2tpcCA9PSAwID8gbmV4dCA6IGRpciA+IDAgPyBuZXh0LnNsaWNlKHNraXApIDogbmV4dC5zbGljZSgwLCBuZXh0Lmxlbmd0aCAtIHNraXApO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgc2tpcCAtPSBuZXh0Lmxlbmd0aDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGxldCBuZXh0ID0gdG9wLmNoaWxkcmVuW29mZnNldCArIChkaXIgPCAwID8gLTEgOiAwKV07XHJcbiAgICAgICAgICAgICAgICBpZiAoc2tpcCA+IG5leHQubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2tpcCAtPSBuZXh0Lmxlbmd0aDtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLm9mZnNldHNbbGFzdF0gKz0gZGlyO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRpciA8IDApXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMub2Zmc2V0c1tsYXN0XS0tO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubm9kZXMucHVzaChuZXh0KTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLm9mZnNldHMucHVzaChkaXIgPiAwID8gMSA6IChuZXh0IGluc3RhbmNlb2YgVGV4dExlYWYgPyBuZXh0LnRleHQubGVuZ3RoIDogbmV4dC5jaGlsZHJlbi5sZW5ndGgpIDw8IDEpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgbmV4dChza2lwID0gMCkge1xyXG4gICAgICAgIGlmIChza2lwIDwgMCkge1xyXG4gICAgICAgICAgICB0aGlzLm5leHRJbm5lcigtc2tpcCwgKC10aGlzLmRpcikpO1xyXG4gICAgICAgICAgICBza2lwID0gdGhpcy52YWx1ZS5sZW5ndGg7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLm5leHRJbm5lcihza2lwLCB0aGlzLmRpcik7XHJcbiAgICB9XHJcbn1cclxuY2xhc3MgUGFydGlhbFRleHRDdXJzb3Ige1xyXG4gICAgY29uc3RydWN0b3IodGV4dCwgc3RhcnQsIGVuZCkge1xyXG4gICAgICAgIHRoaXMudmFsdWUgPSBcIlwiO1xyXG4gICAgICAgIHRoaXMuZG9uZSA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuY3Vyc29yID0gbmV3IFJhd1RleHRDdXJzb3IodGV4dCwgc3RhcnQgPiBlbmQgPyAtMSA6IDEpO1xyXG4gICAgICAgIHRoaXMucG9zID0gc3RhcnQgPiBlbmQgPyB0ZXh0Lmxlbmd0aCA6IDA7XHJcbiAgICAgICAgdGhpcy5mcm9tID0gTWF0aC5taW4oc3RhcnQsIGVuZCk7XHJcbiAgICAgICAgdGhpcy50byA9IE1hdGgubWF4KHN0YXJ0LCBlbmQpO1xyXG4gICAgfVxyXG4gICAgbmV4dElubmVyKHNraXAsIGRpcikge1xyXG4gICAgICAgIGlmIChkaXIgPCAwID8gdGhpcy5wb3MgPD0gdGhpcy5mcm9tIDogdGhpcy5wb3MgPj0gdGhpcy50bykge1xyXG4gICAgICAgICAgICB0aGlzLnZhbHVlID0gXCJcIjtcclxuICAgICAgICAgICAgdGhpcy5kb25lID0gdHJ1ZTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHNraXAgKz0gTWF0aC5tYXgoMCwgZGlyIDwgMCA/IHRoaXMucG9zIC0gdGhpcy50byA6IHRoaXMuZnJvbSAtIHRoaXMucG9zKTtcclxuICAgICAgICBsZXQgbGltaXQgPSBkaXIgPCAwID8gdGhpcy5wb3MgLSB0aGlzLmZyb20gOiB0aGlzLnRvIC0gdGhpcy5wb3M7XHJcbiAgICAgICAgaWYgKHNraXAgPiBsaW1pdClcclxuICAgICAgICAgICAgc2tpcCA9IGxpbWl0O1xyXG4gICAgICAgIGxpbWl0IC09IHNraXA7XHJcbiAgICAgICAgbGV0IHsgdmFsdWUgfSA9IHRoaXMuY3Vyc29yLm5leHQoc2tpcCk7XHJcbiAgICAgICAgdGhpcy5wb3MgKz0gKHZhbHVlLmxlbmd0aCArIHNraXApICogZGlyO1xyXG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZS5sZW5ndGggPD0gbGltaXQgPyB2YWx1ZSA6IGRpciA8IDAgPyB2YWx1ZS5zbGljZSh2YWx1ZS5sZW5ndGggLSBsaW1pdCkgOiB2YWx1ZS5zbGljZSgwLCBsaW1pdCk7XHJcbiAgICAgICAgdGhpcy5kb25lID0gIXRoaXMudmFsdWU7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbiAgICBuZXh0KHNraXAgPSAwKSB7XHJcbiAgICAgICAgaWYgKHNraXAgPCAwKVxyXG4gICAgICAgICAgICBza2lwID0gTWF0aC5tYXgoc2tpcCwgdGhpcy5mcm9tIC0gdGhpcy5wb3MpO1xyXG4gICAgICAgIGVsc2UgaWYgKHNraXAgPiAwKVxyXG4gICAgICAgICAgICBza2lwID0gTWF0aC5taW4oc2tpcCwgdGhpcy50byAtIHRoaXMucG9zKTtcclxuICAgICAgICByZXR1cm4gdGhpcy5uZXh0SW5uZXIoc2tpcCwgdGhpcy5jdXJzb3IuZGlyKTtcclxuICAgIH1cclxuICAgIGdldCBsaW5lQnJlYWsoKSB7IHJldHVybiB0aGlzLmN1cnNvci5saW5lQnJlYWsgJiYgdGhpcy52YWx1ZSAhPSBcIlwiOyB9XHJcbn1cclxuY2xhc3MgTGluZUN1cnNvciB7XHJcbiAgICBjb25zdHJ1Y3Rvcihpbm5lcikge1xyXG4gICAgICAgIHRoaXMuaW5uZXIgPSBpbm5lcjtcclxuICAgICAgICB0aGlzLmFmdGVyQnJlYWsgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMudmFsdWUgPSBcIlwiO1xyXG4gICAgICAgIHRoaXMuZG9uZSA9IGZhbHNlO1xyXG4gICAgfVxyXG4gICAgbmV4dChza2lwID0gMCkge1xyXG4gICAgICAgIGxldCB7IGRvbmUsIGxpbmVCcmVhaywgdmFsdWUgfSA9IHRoaXMuaW5uZXIubmV4dChza2lwKTtcclxuICAgICAgICBpZiAoZG9uZSkge1xyXG4gICAgICAgICAgICB0aGlzLmRvbmUgPSB0cnVlO1xyXG4gICAgICAgICAgICB0aGlzLnZhbHVlID0gXCJcIjtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAobGluZUJyZWFrKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmFmdGVyQnJlYWspIHtcclxuICAgICAgICAgICAgICAgIHRoaXMudmFsdWUgPSBcIlwiO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5hZnRlckJyZWFrID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIHRoaXMubmV4dCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XHJcbiAgICAgICAgICAgIHRoaXMuYWZ0ZXJCcmVhayA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuICAgIGdldCBsaW5lQnJlYWsoKSB7IHJldHVybiBmYWxzZTsgfVxyXG59XHJcbmlmICh0eXBlb2YgU3ltYm9sICE9IFwidW5kZWZpbmVkXCIpIHtcclxuICAgIFRleHQucHJvdG90eXBlW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLml0ZXIoKTsgfTtcclxuICAgIFJhd1RleHRDdXJzb3IucHJvdG90eXBlW1N5bWJvbC5pdGVyYXRvcl0gPSBQYXJ0aWFsVGV4dEN1cnNvci5wcm90b3R5cGVbU3ltYm9sLml0ZXJhdG9yXSA9XHJcbiAgICAgICAgTGluZUN1cnNvci5wcm90b3R5cGVbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH07XHJcbn1cclxuLyoqXHJcblRoaXMgdHlwZSBkZXNjcmliZXMgYSBsaW5lIGluIHRoZSBkb2N1bWVudC4gSXQgaXMgY3JlYXRlZFxyXG5vbi1kZW1hbmQgd2hlbiBsaW5lcyBhcmUgW3F1ZXJpZWRdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuVGV4dC5saW5lQXQpLlxyXG4qL1xyXG5jbGFzcyBMaW5lIHtcclxuICAgIC8qKlxyXG4gICAgQGludGVybmFsXHJcbiAgICAqL1xyXG4gICAgY29uc3RydWN0b3IoXHJcbiAgICAvKipcclxuICAgIFRoZSBwb3NpdGlvbiBvZiB0aGUgc3RhcnQgb2YgdGhlIGxpbmUuXHJcbiAgICAqL1xyXG4gICAgZnJvbSwgXHJcbiAgICAvKipcclxuICAgIFRoZSBwb3NpdGlvbiBhdCB0aGUgZW5kIG9mIHRoZSBsaW5lIChfYmVmb3JlXyB0aGUgbGluZSBicmVhayxcclxuICAgIG9yIGF0IHRoZSBlbmQgb2YgZG9jdW1lbnQgZm9yIHRoZSBsYXN0IGxpbmUpLlxyXG4gICAgKi9cclxuICAgIHRvLCBcclxuICAgIC8qKlxyXG4gICAgVGhpcyBsaW5lJ3MgbGluZSBudW1iZXIgKDEtYmFzZWQpLlxyXG4gICAgKi9cclxuICAgIG51bWJlciwgXHJcbiAgICAvKipcclxuICAgIFRoZSBsaW5lJ3MgY29udGVudC5cclxuICAgICovXHJcbiAgICB0ZXh0KSB7XHJcbiAgICAgICAgdGhpcy5mcm9tID0gZnJvbTtcclxuICAgICAgICB0aGlzLnRvID0gdG87XHJcbiAgICAgICAgdGhpcy5udW1iZXIgPSBudW1iZXI7XHJcbiAgICAgICAgdGhpcy50ZXh0ID0gdGV4dDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgVGhlIGxlbmd0aCBvZiB0aGUgbGluZSAobm90IGluY2x1ZGluZyBhbnkgbGluZSBicmVhayBhZnRlciBpdCkuXHJcbiAgICAqL1xyXG4gICAgZ2V0IGxlbmd0aCgpIHsgcmV0dXJuIHRoaXMudG8gLSB0aGlzLmZyb207IH1cclxufVxyXG5cclxuLy8gQ29tcHJlc3NlZCByZXByZXNlbnRhdGlvbiBvZiB0aGUgR3JhcGhlbWVfQ2x1c3Rlcl9CcmVhaz1FeHRlbmRcclxuLy8gaW5mb3JtYXRpb24gZnJvbVxyXG4vLyBodHRwOi8vd3d3LnVuaWNvZGUub3JnL1B1YmxpYy8xMy4wLjAvdWNkL2F1eGlsaWFyeS9HcmFwaGVtZUJyZWFrUHJvcGVydHkudHh0LlxyXG4vLyBFYWNoIHBhaXIgb2YgZWxlbWVudHMgcmVwcmVzZW50cyBhIHJhbmdlLCBhcyBhbiBvZmZldCBmcm9tIHRoZVxyXG4vLyBwcmV2aW91cyByYW5nZSBhbmQgYSBsZW5ndGguIE51bWJlcnMgYXJlIGluIGJhc2UtMzYsIHdpdGggdGhlIGVtcHR5XHJcbi8vIHN0cmluZyBiZWluZyBhIHNob3J0aGFuZCBmb3IgMS5cclxubGV0IGV4dGVuZCA9IC8qQF9fUFVSRV9fKi9cImxjLDM0LDduLDcsN2IsMTksLCwsMiwsMiwsLDIwLGIsMWMsbCxnLCwydCw3LDIsNiwyLDIsLDQseiwsdSxyLDJqLGIsMW0sOSw5LCxvLDQsLDksLDMsLDUsMTcsMywzYixmLCx3LDFqLCwsLDQsOCw0LCwzLDcsYSwyLHQsLDFtLCwsLDIsNCw4LCw5LCxhLDIscSwsMiwyLDFsLCw0LDIsNCwyLDIsMywzLCx1LDIsMywsYiwyLDFsLCw0LDUsLDIsNCwsaywyLG0sNiwsLDFtLCwsMiwsNCw4LCw3LDMsYSwyLHUsLDFuLCwsLGMsLDksLDE0LCwzLCwxbCwzLDUsMywsNCw3LDIsYiwyLHQsLDFtLCwyLCwyLCwzLCw1LDIsNywyLGIsMixzLDIsMWwsMiwsLDIsNCw4LCw5LCxhLDIsdCwsMjAsLDQsLDIsMywsLDgsLDI5LCwyLDcsYyw4LDJxLCwyLDksYiw2LDIyLDIsciwsLCwsLDFqLGUsLDUsLDIsNSxiLCwxMCw5LCwydSw0LCw2LCwyLDIsMixwLDIsNCwzLGcsNCxkLCwyLDIsNiwsZiwsamosMyxxYSwzLHQsMyx0LDIsdSwyLDFzLDIsLDcsOCwsMixiLDksLDE5LDMsM2IsMix5LCwzYSwzLDQsMiw5LCw2LDMsNjMsMiwyLCwxbSwsLDcsLCwsLDIsOCw2LGEsMiwsMWMsaCwxciw0LDFjLDcsLCw1LCwxNCw5LGMsMix3LDQsMiwyLCwzLDFrLCwsMiwzLCwsMywxbSw4LDIsMiw0OCwzLCxkLCw3LDQsLDYsLDMsMiw1aSwxbSwsNSxlaywsNWYseCwyZGEsMywzeCwsMm8sdyxmZSw2LDJ4LDIsbjl3LDQsLGEsdywyLDI4LDIsN2ssLDMsLDQsLHAsMiw1LCw0NywyLHEsaSxkLCwxMiw4LHAsYiwxYSwzLDFjLCwyLDQsMiwyLDEzLCwxdiw2LDIsMiwyLDIsYywsOCwsMWIsLDFmLCwsMywyLDIsNSwyLCwsMTYsMiw4LCw2bSwsMiwsNCwsZm40LCxraCxnLGcsZyxhNiwyLGd0LCw2YSwsNDUsNSwxYWUsMywsMiw1LDQsMTQsMyw0LCw0bCwyLGZ4LDQsYXIsMiw0OSxiLDR3LCwxaSxmLDFrLDMsMWQsNCwyLDIsMXgsMywxMCw1LCw4LDFxLCxjLDIsMWcsOSxhLDQsMiwsMm4sMywyLCwsMiw2LCw0ZywsMyw4LGwsMiwxbCwyLCwsLCxtLCxlLDcsMyw1LDVmLDgsMiwzLCwsbiwsMjksLDIsNiwsLDIsLCwyLCwyLDZqLCwyLDQsNiwyLCwyLHIsMiwyZCw4LDIsLCwyLDJ5LCwsLDIsNiwsLDJ0LDMsMiw0LCw1LDc3LDksLDIsNnQsLGEsMiwsLDQsLDQwLDQsMiwyLDQsLHcsYSwxNCw2LDIsNCw4LCw5LDYsMiwzLDFhLGQsLDIsYmEsNywsNiwsLDJhLG0sMiw3LCwyLCwyLDNlLDYsMywsLDIsLDcsLCwyMCwyLDMsLCwsOW4sMixmMGIsNSwxbiw3LHQ0LCwxciw0LDI5LCxmNWssMiw0M3EsLCwzLDQsNSw4LDgsMiw3LHUsNCw0NCwzLDFpeiwxaiw0LDFlLDgsLGUsLG0sNSwsZiwxMXMsNywsaCwyLDcsLDIsLDUsNzksNyxjNSw0LDE1cyw3LDMxLDcsMjQwLDUsZ3g3aywybywzayw2b1wiLnNwbGl0KFwiLFwiKS5tYXAocyA9PiBzID8gcGFyc2VJbnQocywgMzYpIDogMSk7XHJcbi8vIENvbnZlcnQgb2Zmc2V0cyBpbnRvIGFic29sdXRlIHZhbHVlc1xyXG5mb3IgKGxldCBpID0gMTsgaSA8IGV4dGVuZC5sZW5ndGg7IGkrKylcclxuICAgIGV4dGVuZFtpXSArPSBleHRlbmRbaSAtIDFdO1xyXG5mdW5jdGlvbiBpc0V4dGVuZGluZ0NoYXIoY29kZSkge1xyXG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPCBleHRlbmQubGVuZ3RoOyBpICs9IDIpXHJcbiAgICAgICAgaWYgKGV4dGVuZFtpXSA+IGNvZGUpXHJcbiAgICAgICAgICAgIHJldHVybiBleHRlbmRbaSAtIDFdIDw9IGNvZGU7XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbn1cclxuZnVuY3Rpb24gaXNSZWdpb25hbEluZGljYXRvcihjb2RlKSB7XHJcbiAgICByZXR1cm4gY29kZSA+PSAweDFGMUU2ICYmIGNvZGUgPD0gMHgxRjFGRjtcclxufVxyXG5jb25zdCBaV0ogPSAweDIwMGQ7XHJcbi8qKlxyXG5SZXR1cm5zIGEgbmV4dCBncmFwaGVtZSBjbHVzdGVyIGJyZWFrIF9hZnRlcl8gKG5vdCBlcXVhbCB0bylcclxuYHBvc2AsIGlmIGBmb3J3YXJkYCBpcyB0cnVlLCBvciBiZWZvcmUgb3RoZXJ3aXNlLiBSZXR1cm5zIGBwb3NgXHJcbml0c2VsZiBpZiBubyBmdXJ0aGVyIGNsdXN0ZXIgYnJlYWsgaXMgYXZhaWxhYmxlIGluIHRoZSBzdHJpbmcuXHJcbk1vdmVzIGFjcm9zcyBzdXJyb2dhdGUgcGFpcnMsIGV4dGVuZGluZyBjaGFyYWN0ZXJzICh3aGVuXHJcbmBpbmNsdWRlRXh0ZW5kaW5nYCBpcyB0cnVlKSwgY2hhcmFjdGVycyBqb2luZWQgd2l0aCB6ZXJvLXdpZHRoXHJcbmpvaW5lcnMsIGFuZCBmbGFnIGVtb2ppLlxyXG4qL1xyXG5mdW5jdGlvbiBmaW5kQ2x1c3RlckJyZWFrKHN0ciwgcG9zLCBmb3J3YXJkID0gdHJ1ZSwgaW5jbHVkZUV4dGVuZGluZyA9IHRydWUpIHtcclxuICAgIHJldHVybiAoZm9yd2FyZCA/IG5leHRDbHVzdGVyQnJlYWsgOiBwcmV2Q2x1c3RlckJyZWFrKShzdHIsIHBvcywgaW5jbHVkZUV4dGVuZGluZyk7XHJcbn1cclxuZnVuY3Rpb24gbmV4dENsdXN0ZXJCcmVhayhzdHIsIHBvcywgaW5jbHVkZUV4dGVuZGluZykge1xyXG4gICAgaWYgKHBvcyA9PSBzdHIubGVuZ3RoKVxyXG4gICAgICAgIHJldHVybiBwb3M7XHJcbiAgICAvLyBJZiBwb3MgaXMgaW4gdGhlIG1pZGRsZSBvZiBhIHN1cnJvZ2F0ZSBwYWlyLCBtb3ZlIHRvIGl0cyBzdGFydFxyXG4gICAgaWYgKHBvcyAmJiBzdXJyb2dhdGVMb3coc3RyLmNoYXJDb2RlQXQocG9zKSkgJiYgc3Vycm9nYXRlSGlnaChzdHIuY2hhckNvZGVBdChwb3MgLSAxKSkpXHJcbiAgICAgICAgcG9zLS07XHJcbiAgICBsZXQgcHJldiA9IGNvZGVQb2ludEF0KHN0ciwgcG9zKTtcclxuICAgIHBvcyArPSBjb2RlUG9pbnRTaXplKHByZXYpO1xyXG4gICAgd2hpbGUgKHBvcyA8IHN0ci5sZW5ndGgpIHtcclxuICAgICAgICBsZXQgbmV4dCA9IGNvZGVQb2ludEF0KHN0ciwgcG9zKTtcclxuICAgICAgICBpZiAocHJldiA9PSBaV0ogfHwgbmV4dCA9PSBaV0ogfHwgaW5jbHVkZUV4dGVuZGluZyAmJiBpc0V4dGVuZGluZ0NoYXIobmV4dCkpIHtcclxuICAgICAgICAgICAgcG9zICs9IGNvZGVQb2ludFNpemUobmV4dCk7XHJcbiAgICAgICAgICAgIHByZXYgPSBuZXh0O1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChpc1JlZ2lvbmFsSW5kaWNhdG9yKG5leHQpKSB7XHJcbiAgICAgICAgICAgIGxldCBjb3VudEJlZm9yZSA9IDAsIGkgPSBwb3MgLSAyO1xyXG4gICAgICAgICAgICB3aGlsZSAoaSA+PSAwICYmIGlzUmVnaW9uYWxJbmRpY2F0b3IoY29kZVBvaW50QXQoc3RyLCBpKSkpIHtcclxuICAgICAgICAgICAgICAgIGNvdW50QmVmb3JlKys7XHJcbiAgICAgICAgICAgICAgICBpIC09IDI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGNvdW50QmVmb3JlICUgMiA9PSAwKVxyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgIHBvcyArPSAyO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHBvcztcclxufVxyXG5mdW5jdGlvbiBwcmV2Q2x1c3RlckJyZWFrKHN0ciwgcG9zLCBpbmNsdWRlRXh0ZW5kaW5nKSB7XHJcbiAgICB3aGlsZSAocG9zID4gMCkge1xyXG4gICAgICAgIGxldCBmb3VuZCA9IG5leHRDbHVzdGVyQnJlYWsoc3RyLCBwb3MgLSAyLCBpbmNsdWRlRXh0ZW5kaW5nKTtcclxuICAgICAgICBpZiAoZm91bmQgPCBwb3MpXHJcbiAgICAgICAgICAgIHJldHVybiBmb3VuZDtcclxuICAgICAgICBwb3MtLTtcclxuICAgIH1cclxuICAgIHJldHVybiAwO1xyXG59XHJcbmZ1bmN0aW9uIHN1cnJvZ2F0ZUxvdyhjaCkgeyByZXR1cm4gY2ggPj0gMHhEQzAwICYmIGNoIDwgMHhFMDAwOyB9XHJcbmZ1bmN0aW9uIHN1cnJvZ2F0ZUhpZ2goY2gpIHsgcmV0dXJuIGNoID49IDB4RDgwMCAmJiBjaCA8IDB4REMwMDsgfVxyXG4vKipcclxuRmluZCB0aGUgY29kZSBwb2ludCBhdCB0aGUgZ2l2ZW4gcG9zaXRpb24gaW4gYSBzdHJpbmcgKGxpa2UgdGhlXHJcbltgY29kZVBvaW50QXRgXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9TdHJpbmcvY29kZVBvaW50QXQpXHJcbnN0cmluZyBtZXRob2QpLlxyXG4qL1xyXG5mdW5jdGlvbiBjb2RlUG9pbnRBdChzdHIsIHBvcykge1xyXG4gICAgbGV0IGNvZGUwID0gc3RyLmNoYXJDb2RlQXQocG9zKTtcclxuICAgIGlmICghc3Vycm9nYXRlSGlnaChjb2RlMCkgfHwgcG9zICsgMSA9PSBzdHIubGVuZ3RoKVxyXG4gICAgICAgIHJldHVybiBjb2RlMDtcclxuICAgIGxldCBjb2RlMSA9IHN0ci5jaGFyQ29kZUF0KHBvcyArIDEpO1xyXG4gICAgaWYgKCFzdXJyb2dhdGVMb3coY29kZTEpKVxyXG4gICAgICAgIHJldHVybiBjb2RlMDtcclxuICAgIHJldHVybiAoKGNvZGUwIC0gMHhkODAwKSA8PCAxMCkgKyAoY29kZTEgLSAweGRjMDApICsgMHgxMDAwMDtcclxufVxyXG4vKipcclxuR2l2ZW4gYSBVbmljb2RlIGNvZGVwb2ludCwgcmV0dXJuIHRoZSBKYXZhU2NyaXB0IHN0cmluZyB0aGF0XHJcbnJlc3ByZXNlbnRzIGl0IChsaWtlXHJcbltgU3RyaW5nLmZyb21Db2RlUG9pbnRgXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9TdHJpbmcvZnJvbUNvZGVQb2ludCkpLlxyXG4qL1xyXG5mdW5jdGlvbiBmcm9tQ29kZVBvaW50KGNvZGUpIHtcclxuICAgIGlmIChjb2RlIDw9IDB4ZmZmZilcclxuICAgICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlKTtcclxuICAgIGNvZGUgLT0gMHgxMDAwMDtcclxuICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKChjb2RlID4+IDEwKSArIDB4ZDgwMCwgKGNvZGUgJiAxMDIzKSArIDB4ZGMwMCk7XHJcbn1cclxuLyoqXHJcblRoZSBhbW91bnQgb2YgcG9zaXRpb25zIGEgY2hhcmFjdGVyIHRha2VzIHVwIGEgSmF2YVNjcmlwdCBzdHJpbmcuXHJcbiovXHJcbmZ1bmN0aW9uIGNvZGVQb2ludFNpemUoY29kZSkgeyByZXR1cm4gY29kZSA8IDB4MTAwMDAgPyAxIDogMjsgfVxyXG5cclxuY29uc3QgRGVmYXVsdFNwbGl0ID0gL1xcclxcbj98XFxuLztcclxuLyoqXHJcbkRpc3Rpbmd1aXNoZXMgZGlmZmVyZW50IHdheXMgaW4gd2hpY2ggcG9zaXRpb25zIGNhbiBiZSBtYXBwZWQuXHJcbiovXHJcbnZhciBNYXBNb2RlID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoTWFwTW9kZSkge1xyXG4gICAgLyoqXHJcbiAgICBNYXAgYSBwb3NpdGlvbiB0byBhIHZhbGlkIG5ldyBwb3NpdGlvbiwgZXZlbiB3aGVuIGl0cyBjb250ZXh0XHJcbiAgICB3YXMgZGVsZXRlZC5cclxuICAgICovXHJcbiAgICBNYXBNb2RlW01hcE1vZGVbXCJTaW1wbGVcIl0gPSAwXSA9IFwiU2ltcGxlXCI7XHJcbiAgICAvKipcclxuICAgIFJldHVybiBudWxsIGlmIGRlbGV0aW9uIGhhcHBlbnMgYWNyb3NzIHRoZSBwb3NpdGlvbi5cclxuICAgICovXHJcbiAgICBNYXBNb2RlW01hcE1vZGVbXCJUcmFja0RlbFwiXSA9IDFdID0gXCJUcmFja0RlbFwiO1xyXG4gICAgLyoqXHJcbiAgICBSZXR1cm4gbnVsbCBpZiB0aGUgY2hhcmFjdGVyIF9iZWZvcmVfIHRoZSBwb3NpdGlvbiBpcyBkZWxldGVkLlxyXG4gICAgKi9cclxuICAgIE1hcE1vZGVbTWFwTW9kZVtcIlRyYWNrQmVmb3JlXCJdID0gMl0gPSBcIlRyYWNrQmVmb3JlXCI7XHJcbiAgICAvKipcclxuICAgIFJldHVybiBudWxsIGlmIHRoZSBjaGFyYWN0ZXIgX2FmdGVyXyB0aGUgcG9zaXRpb24gaXMgZGVsZXRlZC5cclxuICAgICovXHJcbiAgICBNYXBNb2RlW01hcE1vZGVbXCJUcmFja0FmdGVyXCJdID0gM10gPSBcIlRyYWNrQWZ0ZXJcIjtcclxucmV0dXJuIE1hcE1vZGV9KShNYXBNb2RlIHx8IChNYXBNb2RlID0ge30pKTtcclxuLyoqXHJcbkEgY2hhbmdlIGRlc2NyaXB0aW9uIGlzIGEgdmFyaWFudCBvZiBbY2hhbmdlIHNldF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5DaGFuZ2VTZXQpXHJcbnRoYXQgZG9lc24ndCBzdG9yZSB0aGUgaW5zZXJ0ZWQgdGV4dC4gQXMgc3VjaCwgaXQgY2FuJ3QgYmVcclxuYXBwbGllZCwgYnV0IGlzIGNoZWFwZXIgdG8gc3RvcmUgYW5kIG1hbmlwdWxhdGUuXHJcbiovXHJcbmNsYXNzIENoYW5nZURlc2Mge1xyXG4gICAgLy8gU2VjdGlvbnMgYXJlIGVuY29kZWQgYXMgcGFpcnMgb2YgaW50ZWdlcnMuIFRoZSBmaXJzdCBpcyB0aGVcclxuICAgIC8vIGxlbmd0aCBpbiB0aGUgY3VycmVudCBkb2N1bWVudCwgYW5kIHRoZSBzZWNvbmQgaXMgLTEgZm9yXHJcbiAgICAvLyB1bmFmZmVjdGVkIHNlY3Rpb25zLCBhbmQgdGhlIGxlbmd0aCBvZiB0aGUgcmVwbGFjZW1lbnQgY29udGVudFxyXG4gICAgLy8gb3RoZXJ3aXNlLiBTbyBhbiBpbnNlcnRpb24gd291bGQgYmUgKDAsIG4+MCksIGEgZGVsZXRpb24gKG4+MCxcclxuICAgIC8vIDApLCBhbmQgYSByZXBsYWNlbWVudCB0d28gcG9zaXRpdmUgbnVtYmVycy5cclxuICAgIC8qKlxyXG4gICAgQGludGVybmFsXHJcbiAgICAqL1xyXG4gICAgY29uc3RydWN0b3IoXHJcbiAgICAvKipcclxuICAgIEBpbnRlcm5hbFxyXG4gICAgKi9cclxuICAgIHNlY3Rpb25zKSB7XHJcbiAgICAgICAgdGhpcy5zZWN0aW9ucyA9IHNlY3Rpb25zO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICBUaGUgbGVuZ3RoIG9mIHRoZSBkb2N1bWVudCBiZWZvcmUgdGhlIGNoYW5nZS5cclxuICAgICovXHJcbiAgICBnZXQgbGVuZ3RoKCkge1xyXG4gICAgICAgIGxldCByZXN1bHQgPSAwO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5zZWN0aW9ucy5sZW5ndGg7IGkgKz0gMilcclxuICAgICAgICAgICAgcmVzdWx0ICs9IHRoaXMuc2VjdGlvbnNbaV07XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgVGhlIGxlbmd0aCBvZiB0aGUgZG9jdW1lbnQgYWZ0ZXIgdGhlIGNoYW5nZS5cclxuICAgICovXHJcbiAgICBnZXQgbmV3TGVuZ3RoKCkge1xyXG4gICAgICAgIGxldCByZXN1bHQgPSAwO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5zZWN0aW9ucy5sZW5ndGg7IGkgKz0gMikge1xyXG4gICAgICAgICAgICBsZXQgaW5zID0gdGhpcy5zZWN0aW9uc1tpICsgMV07XHJcbiAgICAgICAgICAgIHJlc3VsdCArPSBpbnMgPCAwID8gdGhpcy5zZWN0aW9uc1tpXSA6IGlucztcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgRmFsc2Ugd2hlbiB0aGVyZSBhcmUgYWN0dWFsIGNoYW5nZXMgaW4gdGhpcyBzZXQuXHJcbiAgICAqL1xyXG4gICAgZ2V0IGVtcHR5KCkgeyByZXR1cm4gdGhpcy5zZWN0aW9ucy5sZW5ndGggPT0gMCB8fCB0aGlzLnNlY3Rpb25zLmxlbmd0aCA9PSAyICYmIHRoaXMuc2VjdGlvbnNbMV0gPCAwOyB9XHJcbiAgICAvKipcclxuICAgIEl0ZXJhdGUgb3ZlciB0aGUgdW5jaGFuZ2VkIHBhcnRzIGxlZnQgYnkgdGhlc2UgY2hhbmdlcy4gYHBvc0FgXHJcbiAgICBwcm92aWRlcyB0aGUgcG9zaXRpb24gb2YgdGhlIHJhbmdlIGluIHRoZSBvbGQgZG9jdW1lbnQsIGBwb3NCYFxyXG4gICAgdGhlIG5ldyBwb3NpdGlvbiBpbiB0aGUgY2hhbmdlZCBkb2N1bWVudC5cclxuICAgICovXHJcbiAgICBpdGVyR2FwcyhmKSB7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIHBvc0EgPSAwLCBwb3NCID0gMDsgaSA8IHRoaXMuc2VjdGlvbnMubGVuZ3RoOykge1xyXG4gICAgICAgICAgICBsZXQgbGVuID0gdGhpcy5zZWN0aW9uc1tpKytdLCBpbnMgPSB0aGlzLnNlY3Rpb25zW2krK107XHJcbiAgICAgICAgICAgIGlmIChpbnMgPCAwKSB7XHJcbiAgICAgICAgICAgICAgICBmKHBvc0EsIHBvc0IsIGxlbik7XHJcbiAgICAgICAgICAgICAgICBwb3NCICs9IGxlbjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHBvc0IgKz0gaW5zO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHBvc0EgKz0gbGVuO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgSXRlcmF0ZSBvdmVyIHRoZSByYW5nZXMgY2hhbmdlZCBieSB0aGVzZSBjaGFuZ2VzLiAoU2VlXHJcbiAgICBbYENoYW5nZVNldC5pdGVyQ2hhbmdlc2BdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuQ2hhbmdlU2V0Lml0ZXJDaGFuZ2VzKSBmb3IgYVxyXG4gICAgdmFyaWFudCB0aGF0IGFsc28gcHJvdmlkZXMgeW91IHdpdGggdGhlIGluc2VydGVkIHRleHQuKVxyXG4gICAgYGZyb21BYC9gdG9BYCBwcm92aWRlcyB0aGUgZXh0ZW50IG9mIHRoZSBjaGFuZ2UgaW4gdGhlIHN0YXJ0aW5nXHJcbiAgICBkb2N1bWVudCwgYGZyb21CYC9gdG9CYCB0aGUgZXh0ZW50IG9mIHRoZSByZXBsYWNlbWVudCBpbiB0aGVcclxuICAgIGNoYW5nZWQgZG9jdW1lbnQuXHJcbiAgICBcclxuICAgIFdoZW4gYGluZGl2aWR1YWxgIGlzIHRydWUsIGFkamFjZW50IGNoYW5nZXMgKHdoaWNoIGFyZSBrZXB0XHJcbiAgICBzZXBhcmF0ZSBmb3IgW3Bvc2l0aW9uIG1hcHBpbmddKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuQ2hhbmdlRGVzYy5tYXBQb3MpKSBhcmVcclxuICAgIHJlcG9ydGVkIHNlcGFyYXRlbHkuXHJcbiAgICAqL1xyXG4gICAgaXRlckNoYW5nZWRSYW5nZXMoZiwgaW5kaXZpZHVhbCA9IGZhbHNlKSB7XHJcbiAgICAgICAgaXRlckNoYW5nZXModGhpcywgZiwgaW5kaXZpZHVhbCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgIEdldCBhIGRlc2NyaXB0aW9uIG9mIHRoZSBpbnZlcnRlZCBmb3JtIG9mIHRoZXNlIGNoYW5nZXMuXHJcbiAgICAqL1xyXG4gICAgZ2V0IGludmVydGVkRGVzYygpIHtcclxuICAgICAgICBsZXQgc2VjdGlvbnMgPSBbXTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuc2VjdGlvbnMubGVuZ3RoOykge1xyXG4gICAgICAgICAgICBsZXQgbGVuID0gdGhpcy5zZWN0aW9uc1tpKytdLCBpbnMgPSB0aGlzLnNlY3Rpb25zW2krK107XHJcbiAgICAgICAgICAgIGlmIChpbnMgPCAwKVxyXG4gICAgICAgICAgICAgICAgc2VjdGlvbnMucHVzaChsZW4sIGlucyk7XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgIHNlY3Rpb25zLnB1c2goaW5zLCBsZW4pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbmV3IENoYW5nZURlc2Moc2VjdGlvbnMpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICBDb21wdXRlIHRoZSBjb21iaW5lZCBlZmZlY3Qgb2YgYXBwbHlpbmcgYW5vdGhlciBzZXQgb2YgY2hhbmdlc1xyXG4gICAgYWZ0ZXIgdGhpcyBvbmUuIFRoZSBsZW5ndGggb2YgdGhlIGRvY3VtZW50IGFmdGVyIHRoaXMgc2V0IHNob3VsZFxyXG4gICAgbWF0Y2ggdGhlIGxlbmd0aCBiZWZvcmUgYG90aGVyYC5cclxuICAgICovXHJcbiAgICBjb21wb3NlRGVzYyhvdGhlcikgeyByZXR1cm4gdGhpcy5lbXB0eSA/IG90aGVyIDogb3RoZXIuZW1wdHkgPyB0aGlzIDogY29tcG9zZVNldHModGhpcywgb3RoZXIpOyB9XHJcbiAgICAvKipcclxuICAgIE1hcCB0aGlzIGRlc2NyaXB0aW9uLCB3aGljaCBzaG91bGQgc3RhcnQgd2l0aCB0aGUgc2FtZSBkb2N1bWVudFxyXG4gICAgYXMgYG90aGVyYCwgb3ZlciBhbm90aGVyIHNldCBvZiBjaGFuZ2VzLCBzbyB0aGF0IGl0IGNhbiBiZVxyXG4gICAgYXBwbGllZCBhZnRlciBpdC4gV2hlbiBgYmVmb3JlYCBpcyB0cnVlLCBtYXAgYXMgaWYgdGhlIGNoYW5nZXNcclxuICAgIGluIGBvdGhlcmAgaGFwcGVuZWQgYmVmb3JlIHRoZSBvbmVzIGluIGB0aGlzYC5cclxuICAgICovXHJcbiAgICBtYXBEZXNjKG90aGVyLCBiZWZvcmUgPSBmYWxzZSkgeyByZXR1cm4gb3RoZXIuZW1wdHkgPyB0aGlzIDogbWFwU2V0KHRoaXMsIG90aGVyLCBiZWZvcmUpOyB9XHJcbiAgICBtYXBQb3MocG9zLCBhc3NvYyA9IC0xLCBtb2RlID0gTWFwTW9kZS5TaW1wbGUpIHtcclxuICAgICAgICBsZXQgcG9zQSA9IDAsIHBvc0IgPSAwO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5zZWN0aW9ucy5sZW5ndGg7KSB7XHJcbiAgICAgICAgICAgIGxldCBsZW4gPSB0aGlzLnNlY3Rpb25zW2krK10sIGlucyA9IHRoaXMuc2VjdGlvbnNbaSsrXSwgZW5kQSA9IHBvc0EgKyBsZW47XHJcbiAgICAgICAgICAgIGlmIChpbnMgPCAwKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZW5kQSA+IHBvcylcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcG9zQiArIChwb3MgLSBwb3NBKTtcclxuICAgICAgICAgICAgICAgIHBvc0IgKz0gbGVuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgaWYgKG1vZGUgIT0gTWFwTW9kZS5TaW1wbGUgJiYgZW5kQSA+PSBwb3MgJiZcclxuICAgICAgICAgICAgICAgICAgICAobW9kZSA9PSBNYXBNb2RlLlRyYWNrRGVsICYmIHBvc0EgPCBwb3MgJiYgZW5kQSA+IHBvcyB8fFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBtb2RlID09IE1hcE1vZGUuVHJhY2tCZWZvcmUgJiYgcG9zQSA8IHBvcyB8fFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBtb2RlID09IE1hcE1vZGUuVHJhY2tBZnRlciAmJiBlbmRBID4gcG9zKSlcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgICAgIGlmIChlbmRBID4gcG9zIHx8IGVuZEEgPT0gcG9zICYmIGFzc29jIDwgMCAmJiAhbGVuKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwb3MgPT0gcG9zQSB8fCBhc3NvYyA8IDAgPyBwb3NCIDogcG9zQiArIGlucztcclxuICAgICAgICAgICAgICAgIHBvc0IgKz0gaW5zO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHBvc0EgPSBlbmRBO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAocG9zID4gcG9zQSlcclxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYFBvc2l0aW9uICR7cG9zfSBpcyBvdXQgb2YgcmFuZ2UgZm9yIGNoYW5nZXNldCBvZiBsZW5ndGggJHtwb3NBfWApO1xyXG4gICAgICAgIHJldHVybiBwb3NCO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICBDaGVjayB3aGV0aGVyIHRoZXNlIGNoYW5nZXMgdG91Y2ggYSBnaXZlbiByYW5nZS4gV2hlbiBvbmUgb2YgdGhlXHJcbiAgICBjaGFuZ2VzIGVudGlyZWx5IGNvdmVycyB0aGUgcmFuZ2UsIHRoZSBzdHJpbmcgYFwiY292ZXJcImAgaXNcclxuICAgIHJldHVybmVkLlxyXG4gICAgKi9cclxuICAgIHRvdWNoZXNSYW5nZShmcm9tLCB0byA9IGZyb20pIHtcclxuICAgICAgICBmb3IgKGxldCBpID0gMCwgcG9zID0gMDsgaSA8IHRoaXMuc2VjdGlvbnMubGVuZ3RoICYmIHBvcyA8PSB0bzspIHtcclxuICAgICAgICAgICAgbGV0IGxlbiA9IHRoaXMuc2VjdGlvbnNbaSsrXSwgaW5zID0gdGhpcy5zZWN0aW9uc1tpKytdLCBlbmQgPSBwb3MgKyBsZW47XHJcbiAgICAgICAgICAgIGlmIChpbnMgPj0gMCAmJiBwb3MgPD0gdG8gJiYgZW5kID49IGZyb20pXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcG9zIDwgZnJvbSAmJiBlbmQgPiB0byA/IFwiY292ZXJcIiA6IHRydWU7XHJcbiAgICAgICAgICAgIHBvcyA9IGVuZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICBAaW50ZXJuYWxcclxuICAgICovXHJcbiAgICB0b1N0cmluZygpIHtcclxuICAgICAgICBsZXQgcmVzdWx0ID0gXCJcIjtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuc2VjdGlvbnMubGVuZ3RoOykge1xyXG4gICAgICAgICAgICBsZXQgbGVuID0gdGhpcy5zZWN0aW9uc1tpKytdLCBpbnMgPSB0aGlzLnNlY3Rpb25zW2krK107XHJcbiAgICAgICAgICAgIHJlc3VsdCArPSAocmVzdWx0ID8gXCIgXCIgOiBcIlwiKSArIGxlbiArIChpbnMgPj0gMCA/IFwiOlwiICsgaW5zIDogXCJcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgIFNlcmlhbGl6ZSB0aGlzIGNoYW5nZSBkZXNjIHRvIGEgSlNPTi1yZXByZXNlbnRhYmxlIHZhbHVlLlxyXG4gICAgKi9cclxuICAgIHRvSlNPTigpIHsgcmV0dXJuIHRoaXMuc2VjdGlvbnM7IH1cclxuICAgIC8qKlxyXG4gICAgQ3JlYXRlIGEgY2hhbmdlIGRlc2MgZnJvbSBpdHMgSlNPTiByZXByZXNlbnRhdGlvbiAoYXMgcHJvZHVjZWRcclxuICAgIGJ5IFtgdG9KU09OYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5DaGFuZ2VEZXNjLnRvSlNPTikuXHJcbiAgICAqL1xyXG4gICAgc3RhdGljIGZyb21KU09OKGpzb24pIHtcclxuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoanNvbikgfHwganNvbi5sZW5ndGggJSAyIHx8IGpzb24uc29tZShhID0+IHR5cGVvZiBhICE9IFwibnVtYmVyXCIpKVxyXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgSlNPTiByZXByZXNlbnRhdGlvbiBvZiBDaGFuZ2VEZXNjXCIpO1xyXG4gICAgICAgIHJldHVybiBuZXcgQ2hhbmdlRGVzYyhqc29uKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgQGludGVybmFsXHJcbiAgICAqL1xyXG4gICAgc3RhdGljIGNyZWF0ZShzZWN0aW9ucykgeyByZXR1cm4gbmV3IENoYW5nZURlc2Moc2VjdGlvbnMpOyB9XHJcbn1cclxuLyoqXHJcbkEgY2hhbmdlIHNldCByZXByZXNlbnRzIGEgZ3JvdXAgb2YgbW9kaWZpY2F0aW9ucyB0byBhIGRvY3VtZW50LiBJdFxyXG5zdG9yZXMgdGhlIGRvY3VtZW50IGxlbmd0aCwgYW5kIGNhbiBvbmx5IGJlIGFwcGxpZWQgdG8gZG9jdW1lbnRzXHJcbndpdGggZXhhY3RseSB0aGF0IGxlbmd0aC5cclxuKi9cclxuY2xhc3MgQ2hhbmdlU2V0IGV4dGVuZHMgQ2hhbmdlRGVzYyB7XHJcbiAgICBjb25zdHJ1Y3RvcihzZWN0aW9ucywgXHJcbiAgICAvKipcclxuICAgIEBpbnRlcm5hbFxyXG4gICAgKi9cclxuICAgIGluc2VydGVkKSB7XHJcbiAgICAgICAgc3VwZXIoc2VjdGlvbnMpO1xyXG4gICAgICAgIHRoaXMuaW5zZXJ0ZWQgPSBpbnNlcnRlZDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgQXBwbHkgdGhlIGNoYW5nZXMgdG8gYSBkb2N1bWVudCwgcmV0dXJuaW5nIHRoZSBtb2RpZmllZFxyXG4gICAgZG9jdW1lbnQuXHJcbiAgICAqL1xyXG4gICAgYXBwbHkoZG9jKSB7XHJcbiAgICAgICAgaWYgKHRoaXMubGVuZ3RoICE9IGRvYy5sZW5ndGgpXHJcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiQXBwbHlpbmcgY2hhbmdlIHNldCB0byBhIGRvY3VtZW50IHdpdGggdGhlIHdyb25nIGxlbmd0aFwiKTtcclxuICAgICAgICBpdGVyQ2hhbmdlcyh0aGlzLCAoZnJvbUEsIHRvQSwgZnJvbUIsIF90b0IsIHRleHQpID0+IGRvYyA9IGRvYy5yZXBsYWNlKGZyb21CLCBmcm9tQiArICh0b0EgLSBmcm9tQSksIHRleHQpLCBmYWxzZSk7XHJcbiAgICAgICAgcmV0dXJuIGRvYztcclxuICAgIH1cclxuICAgIG1hcERlc2Mob3RoZXIsIGJlZm9yZSA9IGZhbHNlKSB7IHJldHVybiBtYXBTZXQodGhpcywgb3RoZXIsIGJlZm9yZSwgdHJ1ZSk7IH1cclxuICAgIC8qKlxyXG4gICAgR2l2ZW4gdGhlIGRvY3VtZW50IGFzIGl0IGV4aXN0ZWQgX2JlZm9yZV8gdGhlIGNoYW5nZXMsIHJldHVybiBhXHJcbiAgICBjaGFuZ2Ugc2V0IHRoYXQgcmVwcmVzZW50cyB0aGUgaW52ZXJzZSBvZiB0aGlzIHNldCwgd2hpY2ggY291bGRcclxuICAgIGJlIHVzZWQgdG8gZ28gZnJvbSB0aGUgZG9jdW1lbnQgY3JlYXRlZCBieSB0aGUgY2hhbmdlcyBiYWNrIHRvXHJcbiAgICB0aGUgZG9jdW1lbnQgYXMgaXQgZXhpc3RlZCBiZWZvcmUgdGhlIGNoYW5nZXMuXHJcbiAgICAqL1xyXG4gICAgaW52ZXJ0KGRvYykge1xyXG4gICAgICAgIGxldCBzZWN0aW9ucyA9IHRoaXMuc2VjdGlvbnMuc2xpY2UoKSwgaW5zZXJ0ZWQgPSBbXTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMCwgcG9zID0gMDsgaSA8IHNlY3Rpb25zLmxlbmd0aDsgaSArPSAyKSB7XHJcbiAgICAgICAgICAgIGxldCBsZW4gPSBzZWN0aW9uc1tpXSwgaW5zID0gc2VjdGlvbnNbaSArIDFdO1xyXG4gICAgICAgICAgICBpZiAoaW5zID49IDApIHtcclxuICAgICAgICAgICAgICAgIHNlY3Rpb25zW2ldID0gaW5zO1xyXG4gICAgICAgICAgICAgICAgc2VjdGlvbnNbaSArIDFdID0gbGVuO1xyXG4gICAgICAgICAgICAgICAgbGV0IGluZGV4ID0gaSA+PiAxO1xyXG4gICAgICAgICAgICAgICAgd2hpbGUgKGluc2VydGVkLmxlbmd0aCA8IGluZGV4KVxyXG4gICAgICAgICAgICAgICAgICAgIGluc2VydGVkLnB1c2goVGV4dC5lbXB0eSk7XHJcbiAgICAgICAgICAgICAgICBpbnNlcnRlZC5wdXNoKGxlbiA/IGRvYy5zbGljZShwb3MsIHBvcyArIGxlbikgOiBUZXh0LmVtcHR5KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBwb3MgKz0gbGVuO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbmV3IENoYW5nZVNldChzZWN0aW9ucywgaW5zZXJ0ZWQpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICBDb21iaW5lIHR3byBzdWJzZXF1ZW50IGNoYW5nZSBzZXRzIGludG8gYSBzaW5nbGUgc2V0LiBgb3RoZXJgXHJcbiAgICBtdXN0IHN0YXJ0IGluIHRoZSBkb2N1bWVudCBwcm9kdWNlZCBieSBgdGhpc2AuIElmIGB0aGlzYCBnb2VzXHJcbiAgICBgZG9jQWAg4oaSIGBkb2NCYCBhbmQgYG90aGVyYCByZXByZXNlbnRzIGBkb2NCYCDihpIgYGRvY0NgLCB0aGVcclxuICAgIHJldHVybmVkIHZhbHVlIHdpbGwgcmVwcmVzZW50IHRoZSBjaGFuZ2UgYGRvY0FgIOKGkiBgZG9jQ2AuXHJcbiAgICAqL1xyXG4gICAgY29tcG9zZShvdGhlcikgeyByZXR1cm4gdGhpcy5lbXB0eSA/IG90aGVyIDogb3RoZXIuZW1wdHkgPyB0aGlzIDogY29tcG9zZVNldHModGhpcywgb3RoZXIsIHRydWUpOyB9XHJcbiAgICAvKipcclxuICAgIEdpdmVuIGFub3RoZXIgY2hhbmdlIHNldCBzdGFydGluZyBpbiB0aGUgc2FtZSBkb2N1bWVudCwgbWFwcyB0aGlzXHJcbiAgICBjaGFuZ2Ugc2V0IG92ZXIgdGhlIG90aGVyLCBwcm9kdWNpbmcgYSBuZXcgY2hhbmdlIHNldCB0aGF0IGNhbiBiZVxyXG4gICAgYXBwbGllZCB0byB0aGUgZG9jdW1lbnQgcHJvZHVjZWQgYnkgYXBwbHlpbmcgYG90aGVyYC4gV2hlblxyXG4gICAgYGJlZm9yZWAgaXMgYHRydWVgLCBvcmRlciBjaGFuZ2VzIGFzIGlmIGB0aGlzYCBjb21lcyBiZWZvcmVcclxuICAgIGBvdGhlcmAsIG90aGVyd2lzZSAodGhlIGRlZmF1bHQpIHRyZWF0IGBvdGhlcmAgYXMgY29taW5nIGZpcnN0LlxyXG4gICAgXHJcbiAgICBHaXZlbiB0d28gY2hhbmdlcyBgQWAgYW5kIGBCYCwgYEEuY29tcG9zZShCLm1hcChBKSlgIGFuZFxyXG4gICAgYEIuY29tcG9zZShBLm1hcChCLCB0cnVlKSlgIHdpbGwgcHJvZHVjZSB0aGUgc2FtZSBkb2N1bWVudC4gVGhpc1xyXG4gICAgcHJvdmlkZXMgYSBiYXNpYyBmb3JtIG9mIFtvcGVyYXRpb25hbFxyXG4gICAgdHJhbnNmb3JtYXRpb25dKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL09wZXJhdGlvbmFsX3RyYW5zZm9ybWF0aW9uKSxcclxuICAgIGFuZCBjYW4gYmUgdXNlZCBmb3IgY29sbGFib3JhdGl2ZSBlZGl0aW5nLlxyXG4gICAgKi9cclxuICAgIG1hcChvdGhlciwgYmVmb3JlID0gZmFsc2UpIHsgcmV0dXJuIG90aGVyLmVtcHR5ID8gdGhpcyA6IG1hcFNldCh0aGlzLCBvdGhlciwgYmVmb3JlLCB0cnVlKTsgfVxyXG4gICAgLyoqXHJcbiAgICBJdGVyYXRlIG92ZXIgdGhlIGNoYW5nZWQgcmFuZ2VzIGluIHRoZSBkb2N1bWVudCwgY2FsbGluZyBgZmAgZm9yXHJcbiAgICBlYWNoLCB3aXRoIHRoZSByYW5nZSBpbiB0aGUgb3JpZ2luYWwgZG9jdW1lbnQgKGBmcm9tQWAtYHRvQWApXHJcbiAgICBhbmQgdGhlIHJhbmdlIHRoYXQgcmVwbGFjZXMgaXQgaW4gdGhlIG5ldyBkb2N1bWVudFxyXG4gICAgKGBmcm9tQmAtYHRvQmApLlxyXG4gICAgXHJcbiAgICBXaGVuIGBpbmRpdmlkdWFsYCBpcyB0cnVlLCBhZGphY2VudCBjaGFuZ2VzIGFyZSByZXBvcnRlZFxyXG4gICAgc2VwYXJhdGVseS5cclxuICAgICovXHJcbiAgICBpdGVyQ2hhbmdlcyhmLCBpbmRpdmlkdWFsID0gZmFsc2UpIHtcclxuICAgICAgICBpdGVyQ2hhbmdlcyh0aGlzLCBmLCBpbmRpdmlkdWFsKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgR2V0IGEgW2NoYW5nZSBkZXNjcmlwdGlvbl0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5DaGFuZ2VEZXNjKSBmb3IgdGhpcyBjaGFuZ2VcclxuICAgIHNldC5cclxuICAgICovXHJcbiAgICBnZXQgZGVzYygpIHsgcmV0dXJuIENoYW5nZURlc2MuY3JlYXRlKHRoaXMuc2VjdGlvbnMpOyB9XHJcbiAgICAvKipcclxuICAgIEBpbnRlcm5hbFxyXG4gICAgKi9cclxuICAgIGZpbHRlcihyYW5nZXMpIHtcclxuICAgICAgICBsZXQgcmVzdWx0U2VjdGlvbnMgPSBbXSwgcmVzdWx0SW5zZXJ0ZWQgPSBbXSwgZmlsdGVyZWRTZWN0aW9ucyA9IFtdO1xyXG4gICAgICAgIGxldCBpdGVyID0gbmV3IFNlY3Rpb25JdGVyKHRoaXMpO1xyXG4gICAgICAgIGRvbmU6IGZvciAobGV0IGkgPSAwLCBwb3MgPSAwOzspIHtcclxuICAgICAgICAgICAgbGV0IG5leHQgPSBpID09IHJhbmdlcy5sZW5ndGggPyAxZTkgOiByYW5nZXNbaSsrXTtcclxuICAgICAgICAgICAgd2hpbGUgKHBvcyA8IG5leHQgfHwgcG9zID09IG5leHQgJiYgaXRlci5sZW4gPT0gMCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGl0ZXIuZG9uZSlcclxuICAgICAgICAgICAgICAgICAgICBicmVhayBkb25lO1xyXG4gICAgICAgICAgICAgICAgbGV0IGxlbiA9IE1hdGgubWluKGl0ZXIubGVuLCBuZXh0IC0gcG9zKTtcclxuICAgICAgICAgICAgICAgIGFkZFNlY3Rpb24oZmlsdGVyZWRTZWN0aW9ucywgbGVuLCAtMSk7XHJcbiAgICAgICAgICAgICAgICBsZXQgaW5zID0gaXRlci5pbnMgPT0gLTEgPyAtMSA6IGl0ZXIub2ZmID09IDAgPyBpdGVyLmlucyA6IDA7XHJcbiAgICAgICAgICAgICAgICBhZGRTZWN0aW9uKHJlc3VsdFNlY3Rpb25zLCBsZW4sIGlucyk7XHJcbiAgICAgICAgICAgICAgICBpZiAoaW5zID4gMClcclxuICAgICAgICAgICAgICAgICAgICBhZGRJbnNlcnQocmVzdWx0SW5zZXJ0ZWQsIHJlc3VsdFNlY3Rpb25zLCBpdGVyLnRleHQpO1xyXG4gICAgICAgICAgICAgICAgaXRlci5mb3J3YXJkKGxlbik7XHJcbiAgICAgICAgICAgICAgICBwb3MgKz0gbGVuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGxldCBlbmQgPSByYW5nZXNbaSsrXTtcclxuICAgICAgICAgICAgd2hpbGUgKHBvcyA8IGVuZCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGl0ZXIuZG9uZSlcclxuICAgICAgICAgICAgICAgICAgICBicmVhayBkb25lO1xyXG4gICAgICAgICAgICAgICAgbGV0IGxlbiA9IE1hdGgubWluKGl0ZXIubGVuLCBlbmQgLSBwb3MpO1xyXG4gICAgICAgICAgICAgICAgYWRkU2VjdGlvbihyZXN1bHRTZWN0aW9ucywgbGVuLCAtMSk7XHJcbiAgICAgICAgICAgICAgICBhZGRTZWN0aW9uKGZpbHRlcmVkU2VjdGlvbnMsIGxlbiwgaXRlci5pbnMgPT0gLTEgPyAtMSA6IGl0ZXIub2ZmID09IDAgPyBpdGVyLmlucyA6IDApO1xyXG4gICAgICAgICAgICAgICAgaXRlci5mb3J3YXJkKGxlbik7XHJcbiAgICAgICAgICAgICAgICBwb3MgKz0gbGVuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB7IGNoYW5nZXM6IG5ldyBDaGFuZ2VTZXQocmVzdWx0U2VjdGlvbnMsIHJlc3VsdEluc2VydGVkKSxcclxuICAgICAgICAgICAgZmlsdGVyZWQ6IENoYW5nZURlc2MuY3JlYXRlKGZpbHRlcmVkU2VjdGlvbnMpIH07XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgIFNlcmlhbGl6ZSB0aGlzIGNoYW5nZSBzZXQgdG8gYSBKU09OLXJlcHJlc2VudGFibGUgdmFsdWUuXHJcbiAgICAqL1xyXG4gICAgdG9KU09OKCkge1xyXG4gICAgICAgIGxldCBwYXJ0cyA9IFtdO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5zZWN0aW9ucy5sZW5ndGg7IGkgKz0gMikge1xyXG4gICAgICAgICAgICBsZXQgbGVuID0gdGhpcy5zZWN0aW9uc1tpXSwgaW5zID0gdGhpcy5zZWN0aW9uc1tpICsgMV07XHJcbiAgICAgICAgICAgIGlmIChpbnMgPCAwKVxyXG4gICAgICAgICAgICAgICAgcGFydHMucHVzaChsZW4pO1xyXG4gICAgICAgICAgICBlbHNlIGlmIChpbnMgPT0gMClcclxuICAgICAgICAgICAgICAgIHBhcnRzLnB1c2goW2xlbl0pO1xyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICBwYXJ0cy5wdXNoKFtsZW5dLmNvbmNhdCh0aGlzLmluc2VydGVkW2kgPj4gMV0udG9KU09OKCkpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHBhcnRzO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICBDcmVhdGUgYSBjaGFuZ2Ugc2V0IGZvciB0aGUgZ2l2ZW4gY2hhbmdlcywgZm9yIGEgZG9jdW1lbnQgb2YgdGhlXHJcbiAgICBnaXZlbiBsZW5ndGgsIHVzaW5nIGBsaW5lU2VwYCBhcyBsaW5lIHNlcGFyYXRvci5cclxuICAgICovXHJcbiAgICBzdGF0aWMgb2YoY2hhbmdlcywgbGVuZ3RoLCBsaW5lU2VwKSB7XHJcbiAgICAgICAgbGV0IHNlY3Rpb25zID0gW10sIGluc2VydGVkID0gW10sIHBvcyA9IDA7XHJcbiAgICAgICAgbGV0IHRvdGFsID0gbnVsbDtcclxuICAgICAgICBmdW5jdGlvbiBmbHVzaChmb3JjZSA9IGZhbHNlKSB7XHJcbiAgICAgICAgICAgIGlmICghZm9yY2UgJiYgIXNlY3Rpb25zLmxlbmd0aClcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgaWYgKHBvcyA8IGxlbmd0aClcclxuICAgICAgICAgICAgICAgIGFkZFNlY3Rpb24oc2VjdGlvbnMsIGxlbmd0aCAtIHBvcywgLTEpO1xyXG4gICAgICAgICAgICBsZXQgc2V0ID0gbmV3IENoYW5nZVNldChzZWN0aW9ucywgaW5zZXJ0ZWQpO1xyXG4gICAgICAgICAgICB0b3RhbCA9IHRvdGFsID8gdG90YWwuY29tcG9zZShzZXQubWFwKHRvdGFsKSkgOiBzZXQ7XHJcbiAgICAgICAgICAgIHNlY3Rpb25zID0gW107XHJcbiAgICAgICAgICAgIGluc2VydGVkID0gW107XHJcbiAgICAgICAgICAgIHBvcyA9IDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZ1bmN0aW9uIHByb2Nlc3Moc3BlYykge1xyXG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShzcGVjKSkge1xyXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgc3ViIG9mIHNwZWMpXHJcbiAgICAgICAgICAgICAgICAgICAgcHJvY2VzcyhzdWIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHNwZWMgaW5zdGFuY2VvZiBDaGFuZ2VTZXQpIHtcclxuICAgICAgICAgICAgICAgIGlmIChzcGVjLmxlbmd0aCAhPSBsZW5ndGgpXHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYE1pc21hdGNoZWQgY2hhbmdlIHNldCBsZW5ndGggKGdvdCAke3NwZWMubGVuZ3RofSwgZXhwZWN0ZWQgJHtsZW5ndGh9KWApO1xyXG4gICAgICAgICAgICAgICAgZmx1c2goKTtcclxuICAgICAgICAgICAgICAgIHRvdGFsID0gdG90YWwgPyB0b3RhbC5jb21wb3NlKHNwZWMubWFwKHRvdGFsKSkgOiBzcGVjO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgbGV0IHsgZnJvbSwgdG8gPSBmcm9tLCBpbnNlcnQgfSA9IHNwZWM7XHJcbiAgICAgICAgICAgICAgICBpZiAoZnJvbSA+IHRvIHx8IGZyb20gPCAwIHx8IHRvID4gbGVuZ3RoKVxyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGBJbnZhbGlkIGNoYW5nZSByYW5nZSAke2Zyb219IHRvICR7dG99IChpbiBkb2Mgb2YgbGVuZ3RoICR7bGVuZ3RofSlgKTtcclxuICAgICAgICAgICAgICAgIGxldCBpbnNUZXh0ID0gIWluc2VydCA/IFRleHQuZW1wdHkgOiB0eXBlb2YgaW5zZXJ0ID09IFwic3RyaW5nXCIgPyBUZXh0Lm9mKGluc2VydC5zcGxpdChsaW5lU2VwIHx8IERlZmF1bHRTcGxpdCkpIDogaW5zZXJ0O1xyXG4gICAgICAgICAgICAgICAgbGV0IGluc0xlbiA9IGluc1RleHQubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgaWYgKGZyb20gPT0gdG8gJiYgaW5zTGVuID09IDApXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgaWYgKGZyb20gPCBwb3MpXHJcbiAgICAgICAgICAgICAgICAgICAgZmx1c2goKTtcclxuICAgICAgICAgICAgICAgIGlmIChmcm9tID4gcG9zKVxyXG4gICAgICAgICAgICAgICAgICAgIGFkZFNlY3Rpb24oc2VjdGlvbnMsIGZyb20gLSBwb3MsIC0xKTtcclxuICAgICAgICAgICAgICAgIGFkZFNlY3Rpb24oc2VjdGlvbnMsIHRvIC0gZnJvbSwgaW5zTGVuKTtcclxuICAgICAgICAgICAgICAgIGFkZEluc2VydChpbnNlcnRlZCwgc2VjdGlvbnMsIGluc1RleHQpO1xyXG4gICAgICAgICAgICAgICAgcG9zID0gdG87XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcHJvY2VzcyhjaGFuZ2VzKTtcclxuICAgICAgICBmbHVzaCghdG90YWwpO1xyXG4gICAgICAgIHJldHVybiB0b3RhbDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgQ3JlYXRlIGFuIGVtcHR5IGNoYW5nZXNldCBvZiB0aGUgZ2l2ZW4gbGVuZ3RoLlxyXG4gICAgKi9cclxuICAgIHN0YXRpYyBlbXB0eShsZW5ndGgpIHtcclxuICAgICAgICByZXR1cm4gbmV3IENoYW5nZVNldChsZW5ndGggPyBbbGVuZ3RoLCAtMV0gOiBbXSwgW10pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICBDcmVhdGUgYSBjaGFuZ2VzZXQgZnJvbSBpdHMgSlNPTiByZXByZXNlbnRhdGlvbiAoYXMgcHJvZHVjZWQgYnlcclxuICAgIFtgdG9KU09OYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5DaGFuZ2VTZXQudG9KU09OKS5cclxuICAgICovXHJcbiAgICBzdGF0aWMgZnJvbUpTT04oanNvbikge1xyXG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShqc29uKSlcclxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIEpTT04gcmVwcmVzZW50YXRpb24gb2YgQ2hhbmdlU2V0XCIpO1xyXG4gICAgICAgIGxldCBzZWN0aW9ucyA9IFtdLCBpbnNlcnRlZCA9IFtdO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwganNvbi5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBsZXQgcGFydCA9IGpzb25baV07XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcGFydCA9PSBcIm51bWJlclwiKSB7XHJcbiAgICAgICAgICAgICAgICBzZWN0aW9ucy5wdXNoKHBhcnQsIC0xKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICghQXJyYXkuaXNBcnJheShwYXJ0KSB8fCB0eXBlb2YgcGFydFswXSAhPSBcIm51bWJlclwiIHx8IHBhcnQuc29tZSgoZSwgaSkgPT4gaSAmJiB0eXBlb2YgZSAhPSBcInN0cmluZ1wiKSkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIEpTT04gcmVwcmVzZW50YXRpb24gb2YgQ2hhbmdlU2V0XCIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHBhcnQubGVuZ3RoID09IDEpIHtcclxuICAgICAgICAgICAgICAgIHNlY3Rpb25zLnB1c2gocGFydFswXSwgMCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB3aGlsZSAoaW5zZXJ0ZWQubGVuZ3RoIDwgaSlcclxuICAgICAgICAgICAgICAgICAgICBpbnNlcnRlZC5wdXNoKFRleHQuZW1wdHkpO1xyXG4gICAgICAgICAgICAgICAgaW5zZXJ0ZWRbaV0gPSBUZXh0Lm9mKHBhcnQuc2xpY2UoMSkpO1xyXG4gICAgICAgICAgICAgICAgc2VjdGlvbnMucHVzaChwYXJ0WzBdLCBpbnNlcnRlZFtpXS5sZW5ndGgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBuZXcgQ2hhbmdlU2V0KHNlY3Rpb25zLCBpbnNlcnRlZCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgIEBpbnRlcm5hbFxyXG4gICAgKi9cclxuICAgIHN0YXRpYyBjcmVhdGVTZXQoc2VjdGlvbnMsIGluc2VydGVkKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBDaGFuZ2VTZXQoc2VjdGlvbnMsIGluc2VydGVkKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBhZGRTZWN0aW9uKHNlY3Rpb25zLCBsZW4sIGlucywgZm9yY2VKb2luID0gZmFsc2UpIHtcclxuICAgIGlmIChsZW4gPT0gMCAmJiBpbnMgPD0gMClcclxuICAgICAgICByZXR1cm47XHJcbiAgICBsZXQgbGFzdCA9IHNlY3Rpb25zLmxlbmd0aCAtIDI7XHJcbiAgICBpZiAobGFzdCA+PSAwICYmIGlucyA8PSAwICYmIGlucyA9PSBzZWN0aW9uc1tsYXN0ICsgMV0pXHJcbiAgICAgICAgc2VjdGlvbnNbbGFzdF0gKz0gbGVuO1xyXG4gICAgZWxzZSBpZiAobGVuID09IDAgJiYgc2VjdGlvbnNbbGFzdF0gPT0gMClcclxuICAgICAgICBzZWN0aW9uc1tsYXN0ICsgMV0gKz0gaW5zO1xyXG4gICAgZWxzZSBpZiAoZm9yY2VKb2luKSB7XHJcbiAgICAgICAgc2VjdGlvbnNbbGFzdF0gKz0gbGVuO1xyXG4gICAgICAgIHNlY3Rpb25zW2xhc3QgKyAxXSArPSBpbnM7XHJcbiAgICB9XHJcbiAgICBlbHNlXHJcbiAgICAgICAgc2VjdGlvbnMucHVzaChsZW4sIGlucyk7XHJcbn1cclxuZnVuY3Rpb24gYWRkSW5zZXJ0KHZhbHVlcywgc2VjdGlvbnMsIHZhbHVlKSB7XHJcbiAgICBpZiAodmFsdWUubGVuZ3RoID09IDApXHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgbGV0IGluZGV4ID0gKHNlY3Rpb25zLmxlbmd0aCAtIDIpID4+IDE7XHJcbiAgICBpZiAoaW5kZXggPCB2YWx1ZXMubGVuZ3RoKSB7XHJcbiAgICAgICAgdmFsdWVzW3ZhbHVlcy5sZW5ndGggLSAxXSA9IHZhbHVlc1t2YWx1ZXMubGVuZ3RoIC0gMV0uYXBwZW5kKHZhbHVlKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHdoaWxlICh2YWx1ZXMubGVuZ3RoIDwgaW5kZXgpXHJcbiAgICAgICAgICAgIHZhbHVlcy5wdXNoKFRleHQuZW1wdHkpO1xyXG4gICAgICAgIHZhbHVlcy5wdXNoKHZhbHVlKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBpdGVyQ2hhbmdlcyhkZXNjLCBmLCBpbmRpdmlkdWFsKSB7XHJcbiAgICBsZXQgaW5zZXJ0ZWQgPSBkZXNjLmluc2VydGVkO1xyXG4gICAgZm9yIChsZXQgcG9zQSA9IDAsIHBvc0IgPSAwLCBpID0gMDsgaSA8IGRlc2Muc2VjdGlvbnMubGVuZ3RoOykge1xyXG4gICAgICAgIGxldCBsZW4gPSBkZXNjLnNlY3Rpb25zW2krK10sIGlucyA9IGRlc2Muc2VjdGlvbnNbaSsrXTtcclxuICAgICAgICBpZiAoaW5zIDwgMCkge1xyXG4gICAgICAgICAgICBwb3NBICs9IGxlbjtcclxuICAgICAgICAgICAgcG9zQiArPSBsZW47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBsZXQgZW5kQSA9IHBvc0EsIGVuZEIgPSBwb3NCLCB0ZXh0ID0gVGV4dC5lbXB0eTtcclxuICAgICAgICAgICAgZm9yICg7Oykge1xyXG4gICAgICAgICAgICAgICAgZW5kQSArPSBsZW47XHJcbiAgICAgICAgICAgICAgICBlbmRCICs9IGlucztcclxuICAgICAgICAgICAgICAgIGlmIChpbnMgJiYgaW5zZXJ0ZWQpXHJcbiAgICAgICAgICAgICAgICAgICAgdGV4dCA9IHRleHQuYXBwZW5kKGluc2VydGVkWyhpIC0gMikgPj4gMV0pO1xyXG4gICAgICAgICAgICAgICAgaWYgKGluZGl2aWR1YWwgfHwgaSA9PSBkZXNjLnNlY3Rpb25zLmxlbmd0aCB8fCBkZXNjLnNlY3Rpb25zW2kgKyAxXSA8IDApXHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBsZW4gPSBkZXNjLnNlY3Rpb25zW2krK107XHJcbiAgICAgICAgICAgICAgICBpbnMgPSBkZXNjLnNlY3Rpb25zW2krK107XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZihwb3NBLCBlbmRBLCBwb3NCLCBlbmRCLCB0ZXh0KTtcclxuICAgICAgICAgICAgcG9zQSA9IGVuZEE7XHJcbiAgICAgICAgICAgIHBvc0IgPSBlbmRCO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBtYXBTZXQoc2V0QSwgc2V0QiwgYmVmb3JlLCBta1NldCA9IGZhbHNlKSB7XHJcbiAgICAvLyBQcm9kdWNlIGEgY29weSBvZiBzZXRBIHRoYXQgYXBwbGllcyB0byB0aGUgZG9jdW1lbnQgYWZ0ZXIgc2V0QlxyXG4gICAgLy8gaGFzIGJlZW4gYXBwbGllZCAoYXNzdW1pbmcgYm90aCBzdGFydCBhdCB0aGUgc2FtZSBkb2N1bWVudCkuXHJcbiAgICBsZXQgc2VjdGlvbnMgPSBbXSwgaW5zZXJ0ID0gbWtTZXQgPyBbXSA6IG51bGw7XHJcbiAgICBsZXQgYSA9IG5ldyBTZWN0aW9uSXRlcihzZXRBKSwgYiA9IG5ldyBTZWN0aW9uSXRlcihzZXRCKTtcclxuICAgIC8vIEl0ZXJhdGUgb3ZlciBib3RoIHNldHMgaW4gcGFyYWxsZWwuIGluc2VydGVkIHRyYWNrcywgZm9yIGNoYW5nZXNcclxuICAgIC8vIGluIEEgdGhhdCBoYXZlIHRvIGJlIHByb2Nlc3NlZCBwaWVjZS1ieS1waWVjZSwgd2hldGhlciB0aGVpclxyXG4gICAgLy8gY29udGVudCBoYXMgYmVlbiBpbnNlcnRlZCBhbHJlYWR5LCBhbmQgcmVmZXJzIHRvIHRoZSBzZWN0aW9uXHJcbiAgICAvLyBpbmRleC5cclxuICAgIGZvciAobGV0IGluc2VydGVkID0gLTE7Oykge1xyXG4gICAgICAgIGlmIChhLmlucyA9PSAtMSAmJiBiLmlucyA9PSAtMSkge1xyXG4gICAgICAgICAgICAvLyBNb3ZlIGFjcm9zcyByYW5nZXMgc2tpcHBlZCBieSBib3RoIHNldHMuXHJcbiAgICAgICAgICAgIGxldCBsZW4gPSBNYXRoLm1pbihhLmxlbiwgYi5sZW4pO1xyXG4gICAgICAgICAgICBhZGRTZWN0aW9uKHNlY3Rpb25zLCBsZW4sIC0xKTtcclxuICAgICAgICAgICAgYS5mb3J3YXJkKGxlbik7XHJcbiAgICAgICAgICAgIGIuZm9yd2FyZChsZW4pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChiLmlucyA+PSAwICYmIChhLmlucyA8IDAgfHwgaW5zZXJ0ZWQgPT0gYS5pIHx8IGEub2ZmID09IDAgJiYgKGIubGVuIDwgYS5sZW4gfHwgYi5sZW4gPT0gYS5sZW4gJiYgIWJlZm9yZSkpKSB7XHJcbiAgICAgICAgICAgIC8vIElmIHRoZXJlJ3MgYSBjaGFuZ2UgaW4gQiB0aGF0IGNvbWVzIGJlZm9yZSB0aGUgbmV4dCBjaGFuZ2UgaW5cclxuICAgICAgICAgICAgLy8gQSAob3JkZXJlZCBieSBzdGFydCBwb3MsIHRoZW4gbGVuLCB0aGVuIGJlZm9yZSBmbGFnKSwgc2tpcFxyXG4gICAgICAgICAgICAvLyB0aGF0IChhbmQgcHJvY2VzcyBhbnkgY2hhbmdlcyBpbiBBIGl0IGNvdmVycykuXHJcbiAgICAgICAgICAgIGxldCBsZW4gPSBiLmxlbjtcclxuICAgICAgICAgICAgYWRkU2VjdGlvbihzZWN0aW9ucywgYi5pbnMsIC0xKTtcclxuICAgICAgICAgICAgd2hpbGUgKGxlbikge1xyXG4gICAgICAgICAgICAgICAgbGV0IHBpZWNlID0gTWF0aC5taW4oYS5sZW4sIGxlbik7XHJcbiAgICAgICAgICAgICAgICBpZiAoYS5pbnMgPj0gMCAmJiBpbnNlcnRlZCA8IGEuaSAmJiBhLmxlbiA8PSBwaWVjZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGFkZFNlY3Rpb24oc2VjdGlvbnMsIDAsIGEuaW5zKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaW5zZXJ0KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRJbnNlcnQoaW5zZXJ0LCBzZWN0aW9ucywgYS50ZXh0KTtcclxuICAgICAgICAgICAgICAgICAgICBpbnNlcnRlZCA9IGEuaTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGEuZm9yd2FyZChwaWVjZSk7XHJcbiAgICAgICAgICAgICAgICBsZW4gLT0gcGllY2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgYi5uZXh0KCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGEuaW5zID49IDApIHtcclxuICAgICAgICAgICAgLy8gUHJvY2VzcyB0aGUgcGFydCBvZiBhIGNoYW5nZSBpbiBBIHVwIHRvIHRoZSBzdGFydCBvZiB0aGUgbmV4dFxyXG4gICAgICAgICAgICAvLyBub24tZGVsZXRpb24gY2hhbmdlIGluIEIgKGlmIG92ZXJsYXBwaW5nKS5cclxuICAgICAgICAgICAgbGV0IGxlbiA9IDAsIGxlZnQgPSBhLmxlbjtcclxuICAgICAgICAgICAgd2hpbGUgKGxlZnQpIHtcclxuICAgICAgICAgICAgICAgIGlmIChiLmlucyA9PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBwaWVjZSA9IE1hdGgubWluKGxlZnQsIGIubGVuKTtcclxuICAgICAgICAgICAgICAgICAgICBsZW4gKz0gcGllY2U7XHJcbiAgICAgICAgICAgICAgICAgICAgbGVmdCAtPSBwaWVjZTtcclxuICAgICAgICAgICAgICAgICAgICBiLmZvcndhcmQocGllY2UpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoYi5pbnMgPT0gMCAmJiBiLmxlbiA8IGxlZnQpIHtcclxuICAgICAgICAgICAgICAgICAgICBsZWZ0IC09IGIubGVuO1xyXG4gICAgICAgICAgICAgICAgICAgIGIubmV4dCgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgYWRkU2VjdGlvbihzZWN0aW9ucywgbGVuLCBpbnNlcnRlZCA8IGEuaSA/IGEuaW5zIDogMCk7XHJcbiAgICAgICAgICAgIGlmIChpbnNlcnQgJiYgaW5zZXJ0ZWQgPCBhLmkpXHJcbiAgICAgICAgICAgICAgICBhZGRJbnNlcnQoaW5zZXJ0LCBzZWN0aW9ucywgYS50ZXh0KTtcclxuICAgICAgICAgICAgaW5zZXJ0ZWQgPSBhLmk7XHJcbiAgICAgICAgICAgIGEuZm9yd2FyZChhLmxlbiAtIGxlZnQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChhLmRvbmUgJiYgYi5kb25lKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBpbnNlcnQgPyBDaGFuZ2VTZXQuY3JlYXRlU2V0KHNlY3Rpb25zLCBpbnNlcnQpIDogQ2hhbmdlRGVzYy5jcmVhdGUoc2VjdGlvbnMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTWlzbWF0Y2hlZCBjaGFuZ2Ugc2V0IGxlbmd0aHNcIik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGNvbXBvc2VTZXRzKHNldEEsIHNldEIsIG1rU2V0ID0gZmFsc2UpIHtcclxuICAgIGxldCBzZWN0aW9ucyA9IFtdO1xyXG4gICAgbGV0IGluc2VydCA9IG1rU2V0ID8gW10gOiBudWxsO1xyXG4gICAgbGV0IGEgPSBuZXcgU2VjdGlvbkl0ZXIoc2V0QSksIGIgPSBuZXcgU2VjdGlvbkl0ZXIoc2V0Qik7XHJcbiAgICBmb3IgKGxldCBvcGVuID0gZmFsc2U7Oykge1xyXG4gICAgICAgIGlmIChhLmRvbmUgJiYgYi5kb25lKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBpbnNlcnQgPyBDaGFuZ2VTZXQuY3JlYXRlU2V0KHNlY3Rpb25zLCBpbnNlcnQpIDogQ2hhbmdlRGVzYy5jcmVhdGUoc2VjdGlvbnMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChhLmlucyA9PSAwKSB7IC8vIERlbGV0aW9uIGluIEFcclxuICAgICAgICAgICAgYWRkU2VjdGlvbihzZWN0aW9ucywgYS5sZW4sIDAsIG9wZW4pO1xyXG4gICAgICAgICAgICBhLm5leHQoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoYi5sZW4gPT0gMCAmJiAhYi5kb25lKSB7IC8vIEluc2VydGlvbiBpbiBCXHJcbiAgICAgICAgICAgIGFkZFNlY3Rpb24oc2VjdGlvbnMsIDAsIGIuaW5zLCBvcGVuKTtcclxuICAgICAgICAgICAgaWYgKGluc2VydClcclxuICAgICAgICAgICAgICAgIGFkZEluc2VydChpbnNlcnQsIHNlY3Rpb25zLCBiLnRleHQpO1xyXG4gICAgICAgICAgICBiLm5leHQoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoYS5kb25lIHx8IGIuZG9uZSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNaXNtYXRjaGVkIGNoYW5nZSBzZXQgbGVuZ3Roc1wiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGxldCBsZW4gPSBNYXRoLm1pbihhLmxlbjIsIGIubGVuKSwgc2VjdGlvbkxlbiA9IHNlY3Rpb25zLmxlbmd0aDtcclxuICAgICAgICAgICAgaWYgKGEuaW5zID09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgaW5zQiA9IGIuaW5zID09IC0xID8gLTEgOiBiLm9mZiA/IDAgOiBiLmlucztcclxuICAgICAgICAgICAgICAgIGFkZFNlY3Rpb24oc2VjdGlvbnMsIGxlbiwgaW5zQiwgb3Blbik7XHJcbiAgICAgICAgICAgICAgICBpZiAoaW5zZXJ0ICYmIGluc0IpXHJcbiAgICAgICAgICAgICAgICAgICAgYWRkSW5zZXJ0KGluc2VydCwgc2VjdGlvbnMsIGIudGV4dCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoYi5pbnMgPT0gLTEpIHtcclxuICAgICAgICAgICAgICAgIGFkZFNlY3Rpb24oc2VjdGlvbnMsIGEub2ZmID8gMCA6IGEubGVuLCBsZW4sIG9wZW4pO1xyXG4gICAgICAgICAgICAgICAgaWYgKGluc2VydClcclxuICAgICAgICAgICAgICAgICAgICBhZGRJbnNlcnQoaW5zZXJ0LCBzZWN0aW9ucywgYS50ZXh0Qml0KGxlbikpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgYWRkU2VjdGlvbihzZWN0aW9ucywgYS5vZmYgPyAwIDogYS5sZW4sIGIub2ZmID8gMCA6IGIuaW5zLCBvcGVuKTtcclxuICAgICAgICAgICAgICAgIGlmIChpbnNlcnQgJiYgIWIub2ZmKVxyXG4gICAgICAgICAgICAgICAgICAgIGFkZEluc2VydChpbnNlcnQsIHNlY3Rpb25zLCBiLnRleHQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIG9wZW4gPSAoYS5pbnMgPiBsZW4gfHwgYi5pbnMgPj0gMCAmJiBiLmxlbiA+IGxlbikgJiYgKG9wZW4gfHwgc2VjdGlvbnMubGVuZ3RoID4gc2VjdGlvbkxlbik7XHJcbiAgICAgICAgICAgIGEuZm9yd2FyZDIobGVuKTtcclxuICAgICAgICAgICAgYi5mb3J3YXJkKGxlbik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbmNsYXNzIFNlY3Rpb25JdGVyIHtcclxuICAgIGNvbnN0cnVjdG9yKHNldCkge1xyXG4gICAgICAgIHRoaXMuc2V0ID0gc2V0O1xyXG4gICAgICAgIHRoaXMuaSA9IDA7XHJcbiAgICAgICAgdGhpcy5uZXh0KCk7XHJcbiAgICB9XHJcbiAgICBuZXh0KCkge1xyXG4gICAgICAgIGxldCB7IHNlY3Rpb25zIH0gPSB0aGlzLnNldDtcclxuICAgICAgICBpZiAodGhpcy5pIDwgc2VjdGlvbnMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHRoaXMubGVuID0gc2VjdGlvbnNbdGhpcy5pKytdO1xyXG4gICAgICAgICAgICB0aGlzLmlucyA9IHNlY3Rpb25zW3RoaXMuaSsrXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMubGVuID0gMDtcclxuICAgICAgICAgICAgdGhpcy5pbnMgPSAtMjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5vZmYgPSAwO1xyXG4gICAgfVxyXG4gICAgZ2V0IGRvbmUoKSB7IHJldHVybiB0aGlzLmlucyA9PSAtMjsgfVxyXG4gICAgZ2V0IGxlbjIoKSB7IHJldHVybiB0aGlzLmlucyA8IDAgPyB0aGlzLmxlbiA6IHRoaXMuaW5zOyB9XHJcbiAgICBnZXQgdGV4dCgpIHtcclxuICAgICAgICBsZXQgeyBpbnNlcnRlZCB9ID0gdGhpcy5zZXQsIGluZGV4ID0gKHRoaXMuaSAtIDIpID4+IDE7XHJcbiAgICAgICAgcmV0dXJuIGluZGV4ID49IGluc2VydGVkLmxlbmd0aCA/IFRleHQuZW1wdHkgOiBpbnNlcnRlZFtpbmRleF07XHJcbiAgICB9XHJcbiAgICB0ZXh0Qml0KGxlbikge1xyXG4gICAgICAgIGxldCB7IGluc2VydGVkIH0gPSB0aGlzLnNldCwgaW5kZXggPSAodGhpcy5pIC0gMikgPj4gMTtcclxuICAgICAgICByZXR1cm4gaW5kZXggPj0gaW5zZXJ0ZWQubGVuZ3RoICYmICFsZW4gPyBUZXh0LmVtcHR5XHJcbiAgICAgICAgICAgIDogaW5zZXJ0ZWRbaW5kZXhdLnNsaWNlKHRoaXMub2ZmLCBsZW4gPT0gbnVsbCA/IHVuZGVmaW5lZCA6IHRoaXMub2ZmICsgbGVuKTtcclxuICAgIH1cclxuICAgIGZvcndhcmQobGVuKSB7XHJcbiAgICAgICAgaWYgKGxlbiA9PSB0aGlzLmxlbilcclxuICAgICAgICAgICAgdGhpcy5uZXh0KCk7XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMubGVuIC09IGxlbjtcclxuICAgICAgICAgICAgdGhpcy5vZmYgKz0gbGVuO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGZvcndhcmQyKGxlbikge1xyXG4gICAgICAgIGlmICh0aGlzLmlucyA9PSAtMSlcclxuICAgICAgICAgICAgdGhpcy5mb3J3YXJkKGxlbik7XHJcbiAgICAgICAgZWxzZSBpZiAobGVuID09IHRoaXMuaW5zKVxyXG4gICAgICAgICAgICB0aGlzLm5leHQoKTtcclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5pbnMgLT0gbGVuO1xyXG4gICAgICAgICAgICB0aGlzLm9mZiArPSBsZW47XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcblxyXG4vKipcclxuQSBzaW5nbGUgc2VsZWN0aW9uIHJhbmdlLiBXaGVuXHJcbltgYWxsb3dNdWx0aXBsZVNlbGVjdGlvbnNgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkVkaXRvclN0YXRlXmFsbG93TXVsdGlwbGVTZWxlY3Rpb25zKVxyXG5pcyBlbmFibGVkLCBhIFtzZWxlY3Rpb25dKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuRWRpdG9yU2VsZWN0aW9uKSBtYXkgaG9sZFxyXG5tdWx0aXBsZSByYW5nZXMuIEJ5IGRlZmF1bHQsIHNlbGVjdGlvbnMgaG9sZCBleGFjdGx5IG9uZSByYW5nZS5cclxuKi9cclxuY2xhc3MgU2VsZWN0aW9uUmFuZ2Uge1xyXG4gICAgY29uc3RydWN0b3IoXHJcbiAgICAvKipcclxuICAgIFRoZSBsb3dlciBib3VuZGFyeSBvZiB0aGUgcmFuZ2UuXHJcbiAgICAqL1xyXG4gICAgZnJvbSwgXHJcbiAgICAvKipcclxuICAgIFRoZSB1cHBlciBib3VuZGFyeSBvZiB0aGUgcmFuZ2UuXHJcbiAgICAqL1xyXG4gICAgdG8sIGZsYWdzKSB7XHJcbiAgICAgICAgdGhpcy5mcm9tID0gZnJvbTtcclxuICAgICAgICB0aGlzLnRvID0gdG87XHJcbiAgICAgICAgdGhpcy5mbGFncyA9IGZsYWdzO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICBUaGUgYW5jaG9yIG9mIHRoZSByYW5nZeKAlHRoZSBzaWRlIHRoYXQgZG9lc24ndCBtb3ZlIHdoZW4geW91XHJcbiAgICBleHRlbmQgaXQuXHJcbiAgICAqL1xyXG4gICAgZ2V0IGFuY2hvcigpIHsgcmV0dXJuIHRoaXMuZmxhZ3MgJiAxNiAvKiBSYW5nZUZsYWcuSW52ZXJ0ZWQgKi8gPyB0aGlzLnRvIDogdGhpcy5mcm9tOyB9XHJcbiAgICAvKipcclxuICAgIFRoZSBoZWFkIG9mIHRoZSByYW5nZSwgd2hpY2ggaXMgbW92ZWQgd2hlbiB0aGUgcmFuZ2UgaXNcclxuICAgIFtleHRlbmRlZF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5TZWxlY3Rpb25SYW5nZS5leHRlbmQpLlxyXG4gICAgKi9cclxuICAgIGdldCBoZWFkKCkgeyByZXR1cm4gdGhpcy5mbGFncyAmIDE2IC8qIFJhbmdlRmxhZy5JbnZlcnRlZCAqLyA/IHRoaXMuZnJvbSA6IHRoaXMudG87IH1cclxuICAgIC8qKlxyXG4gICAgVHJ1ZSB3aGVuIGBhbmNob3JgIGFuZCBgaGVhZGAgYXJlIGF0IHRoZSBzYW1lIHBvc2l0aW9uLlxyXG4gICAgKi9cclxuICAgIGdldCBlbXB0eSgpIHsgcmV0dXJuIHRoaXMuZnJvbSA9PSB0aGlzLnRvOyB9XHJcbiAgICAvKipcclxuICAgIElmIHRoaXMgaXMgYSBjdXJzb3IgdGhhdCBpcyBleHBsaWNpdGx5IGFzc29jaWF0ZWQgd2l0aCB0aGVcclxuICAgIGNoYXJhY3RlciBvbiBvbmUgb2YgaXRzIHNpZGVzLCB0aGlzIHJldHVybnMgdGhlIHNpZGUuIC0xIG1lYW5zXHJcbiAgICB0aGUgY2hhcmFjdGVyIGJlZm9yZSBpdHMgcG9zaXRpb24sIDEgdGhlIGNoYXJhY3RlciBhZnRlciwgYW5kIDBcclxuICAgIG1lYW5zIG5vIGFzc29jaWF0aW9uLlxyXG4gICAgKi9cclxuICAgIGdldCBhc3NvYygpIHsgcmV0dXJuIHRoaXMuZmxhZ3MgJiA0IC8qIFJhbmdlRmxhZy5Bc3NvY0JlZm9yZSAqLyA/IC0xIDogdGhpcy5mbGFncyAmIDggLyogUmFuZ2VGbGFnLkFzc29jQWZ0ZXIgKi8gPyAxIDogMDsgfVxyXG4gICAgLyoqXHJcbiAgICBUaGUgYmlkaXJlY3Rpb25hbCB0ZXh0IGxldmVsIGFzc29jaWF0ZWQgd2l0aCB0aGlzIGN1cnNvciwgaWZcclxuICAgIGFueS5cclxuICAgICovXHJcbiAgICBnZXQgYmlkaUxldmVsKCkge1xyXG4gICAgICAgIGxldCBsZXZlbCA9IHRoaXMuZmxhZ3MgJiAzIC8qIFJhbmdlRmxhZy5CaWRpTGV2ZWxNYXNrICovO1xyXG4gICAgICAgIHJldHVybiBsZXZlbCA9PSAzID8gbnVsbCA6IGxldmVsO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICBUaGUgZ29hbCBjb2x1bW4gKHN0b3JlZCB2ZXJ0aWNhbCBvZmZzZXQpIGFzc29jaWF0ZWQgd2l0aCBhXHJcbiAgICBjdXJzb3IuIFRoaXMgaXMgdXNlZCB0byBwcmVzZXJ2ZSB0aGUgdmVydGljYWwgcG9zaXRpb24gd2hlblxyXG4gICAgW21vdmluZ10oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LkVkaXRvclZpZXcubW92ZVZlcnRpY2FsbHkpIGFjcm9zc1xyXG4gICAgbGluZXMgb2YgZGlmZmVyZW50IGxlbmd0aC5cclxuICAgICovXHJcbiAgICBnZXQgZ29hbENvbHVtbigpIHtcclxuICAgICAgICBsZXQgdmFsdWUgPSB0aGlzLmZsYWdzID4+IDUgLyogUmFuZ2VGbGFnLkdvYWxDb2x1bW5PZmZzZXQgKi87XHJcbiAgICAgICAgcmV0dXJuIHZhbHVlID09IDMzNTU0NDMxIC8qIFJhbmdlRmxhZy5Ob0dvYWxDb2x1bW4gKi8gPyB1bmRlZmluZWQgOiB2YWx1ZTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgTWFwIHRoaXMgcmFuZ2UgdGhyb3VnaCBhIGNoYW5nZSwgcHJvZHVjaW5nIGEgdmFsaWQgcmFuZ2UgaW4gdGhlXHJcbiAgICB1cGRhdGVkIGRvY3VtZW50LlxyXG4gICAgKi9cclxuICAgIG1hcChjaGFuZ2UsIGFzc29jID0gLTEpIHtcclxuICAgICAgICBsZXQgZnJvbSwgdG87XHJcbiAgICAgICAgaWYgKHRoaXMuZW1wdHkpIHtcclxuICAgICAgICAgICAgZnJvbSA9IHRvID0gY2hhbmdlLm1hcFBvcyh0aGlzLmZyb20sIGFzc29jKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGZyb20gPSBjaGFuZ2UubWFwUG9zKHRoaXMuZnJvbSwgMSk7XHJcbiAgICAgICAgICAgIHRvID0gY2hhbmdlLm1hcFBvcyh0aGlzLnRvLCAtMSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBmcm9tID09IHRoaXMuZnJvbSAmJiB0byA9PSB0aGlzLnRvID8gdGhpcyA6IG5ldyBTZWxlY3Rpb25SYW5nZShmcm9tLCB0bywgdGhpcy5mbGFncyk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgIEV4dGVuZCB0aGlzIHJhbmdlIHRvIGNvdmVyIGF0IGxlYXN0IGBmcm9tYCB0byBgdG9gLlxyXG4gICAgKi9cclxuICAgIGV4dGVuZChmcm9tLCB0byA9IGZyb20pIHtcclxuICAgICAgICBpZiAoZnJvbSA8PSB0aGlzLmFuY2hvciAmJiB0byA+PSB0aGlzLmFuY2hvcilcclxuICAgICAgICAgICAgcmV0dXJuIEVkaXRvclNlbGVjdGlvbi5yYW5nZShmcm9tLCB0byk7XHJcbiAgICAgICAgbGV0IGhlYWQgPSBNYXRoLmFicyhmcm9tIC0gdGhpcy5hbmNob3IpID4gTWF0aC5hYnModG8gLSB0aGlzLmFuY2hvcikgPyBmcm9tIDogdG87XHJcbiAgICAgICAgcmV0dXJuIEVkaXRvclNlbGVjdGlvbi5yYW5nZSh0aGlzLmFuY2hvciwgaGVhZCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgIENvbXBhcmUgdGhpcyByYW5nZSB0byBhbm90aGVyIHJhbmdlLlxyXG4gICAgKi9cclxuICAgIGVxKG90aGVyKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuYW5jaG9yID09IG90aGVyLmFuY2hvciAmJiB0aGlzLmhlYWQgPT0gb3RoZXIuaGVhZDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgUmV0dXJuIGEgSlNPTi1zZXJpYWxpemFibGUgb2JqZWN0IHJlcHJlc2VudGluZyB0aGUgcmFuZ2UuXHJcbiAgICAqL1xyXG4gICAgdG9KU09OKCkgeyByZXR1cm4geyBhbmNob3I6IHRoaXMuYW5jaG9yLCBoZWFkOiB0aGlzLmhlYWQgfTsgfVxyXG4gICAgLyoqXHJcbiAgICBDb252ZXJ0IGEgSlNPTiByZXByZXNlbnRhdGlvbiBvZiBhIHJhbmdlIHRvIGEgYFNlbGVjdGlvblJhbmdlYFxyXG4gICAgaW5zdGFuY2UuXHJcbiAgICAqL1xyXG4gICAgc3RhdGljIGZyb21KU09OKGpzb24pIHtcclxuICAgICAgICBpZiAoIWpzb24gfHwgdHlwZW9mIGpzb24uYW5jaG9yICE9IFwibnVtYmVyXCIgfHwgdHlwZW9mIGpzb24uaGVhZCAhPSBcIm51bWJlclwiKVxyXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgSlNPTiByZXByZXNlbnRhdGlvbiBmb3IgU2VsZWN0aW9uUmFuZ2VcIik7XHJcbiAgICAgICAgcmV0dXJuIEVkaXRvclNlbGVjdGlvbi5yYW5nZShqc29uLmFuY2hvciwganNvbi5oZWFkKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgQGludGVybmFsXHJcbiAgICAqL1xyXG4gICAgc3RhdGljIGNyZWF0ZShmcm9tLCB0bywgZmxhZ3MpIHtcclxuICAgICAgICByZXR1cm4gbmV3IFNlbGVjdGlvblJhbmdlKGZyb20sIHRvLCBmbGFncyk7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbkFuIGVkaXRvciBzZWxlY3Rpb24gaG9sZHMgb25lIG9yIG1vcmUgc2VsZWN0aW9uIHJhbmdlcy5cclxuKi9cclxuY2xhc3MgRWRpdG9yU2VsZWN0aW9uIHtcclxuICAgIGNvbnN0cnVjdG9yKFxyXG4gICAgLyoqXHJcbiAgICBUaGUgcmFuZ2VzIGluIHRoZSBzZWxlY3Rpb24sIHNvcnRlZCBieSBwb3NpdGlvbi4gUmFuZ2VzIGNhbm5vdFxyXG4gICAgb3ZlcmxhcCAoYnV0IHRoZXkgbWF5IHRvdWNoLCBpZiB0aGV5IGFyZW4ndCBlbXB0eSkuXHJcbiAgICAqL1xyXG4gICAgcmFuZ2VzLCBcclxuICAgIC8qKlxyXG4gICAgVGhlIGluZGV4IG9mIHRoZSBfbWFpbl8gcmFuZ2UgaW4gdGhlIHNlbGVjdGlvbiAod2hpY2ggaXNcclxuICAgIHVzdWFsbHkgdGhlIHJhbmdlIHRoYXQgd2FzIGFkZGVkIGxhc3QpLlxyXG4gICAgKi9cclxuICAgIG1haW5JbmRleCkge1xyXG4gICAgICAgIHRoaXMucmFuZ2VzID0gcmFuZ2VzO1xyXG4gICAgICAgIHRoaXMubWFpbkluZGV4ID0gbWFpbkluZGV4O1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICBNYXAgYSBzZWxlY3Rpb24gdGhyb3VnaCBhIGNoYW5nZS4gVXNlZCB0byBhZGp1c3QgdGhlIHNlbGVjdGlvblxyXG4gICAgcG9zaXRpb24gZm9yIGNoYW5nZXMuXHJcbiAgICAqL1xyXG4gICAgbWFwKGNoYW5nZSwgYXNzb2MgPSAtMSkge1xyXG4gICAgICAgIGlmIChjaGFuZ2UuZW1wdHkpXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgIHJldHVybiBFZGl0b3JTZWxlY3Rpb24uY3JlYXRlKHRoaXMucmFuZ2VzLm1hcChyID0+IHIubWFwKGNoYW5nZSwgYXNzb2MpKSwgdGhpcy5tYWluSW5kZXgpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICBDb21wYXJlIHRoaXMgc2VsZWN0aW9uIHRvIGFub3RoZXIgc2VsZWN0aW9uLlxyXG4gICAgKi9cclxuICAgIGVxKG90aGVyKSB7XHJcbiAgICAgICAgaWYgKHRoaXMucmFuZ2VzLmxlbmd0aCAhPSBvdGhlci5yYW5nZXMubGVuZ3RoIHx8XHJcbiAgICAgICAgICAgIHRoaXMubWFpbkluZGV4ICE9IG90aGVyLm1haW5JbmRleClcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5yYW5nZXMubGVuZ3RoOyBpKyspXHJcbiAgICAgICAgICAgIGlmICghdGhpcy5yYW5nZXNbaV0uZXEob3RoZXIucmFuZ2VzW2ldKSlcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgR2V0IHRoZSBwcmltYXJ5IHNlbGVjdGlvbiByYW5nZS4gVXN1YWxseSwgeW91IHNob3VsZCBtYWtlIHN1cmVcclxuICAgIHlvdXIgY29kZSBhcHBsaWVzIHRvIF9hbGxfIHJhbmdlcywgYnkgdXNpbmcgbWV0aG9kcyBsaWtlXHJcbiAgICBbYGNoYW5nZUJ5UmFuZ2VgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkVkaXRvclN0YXRlLmNoYW5nZUJ5UmFuZ2UpLlxyXG4gICAgKi9cclxuICAgIGdldCBtYWluKCkgeyByZXR1cm4gdGhpcy5yYW5nZXNbdGhpcy5tYWluSW5kZXhdOyB9XHJcbiAgICAvKipcclxuICAgIE1ha2Ugc3VyZSB0aGUgc2VsZWN0aW9uIG9ubHkgaGFzIG9uZSByYW5nZS4gUmV0dXJucyBhIHNlbGVjdGlvblxyXG4gICAgaG9sZGluZyBvbmx5IHRoZSBtYWluIHJhbmdlIGZyb20gdGhpcyBzZWxlY3Rpb24uXHJcbiAgICAqL1xyXG4gICAgYXNTaW5nbGUoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucmFuZ2VzLmxlbmd0aCA9PSAxID8gdGhpcyA6IG5ldyBFZGl0b3JTZWxlY3Rpb24oW3RoaXMubWFpbl0sIDApO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICBFeHRlbmQgdGhpcyBzZWxlY3Rpb24gd2l0aCBhbiBleHRyYSByYW5nZS5cclxuICAgICovXHJcbiAgICBhZGRSYW5nZShyYW5nZSwgbWFpbiA9IHRydWUpIHtcclxuICAgICAgICByZXR1cm4gRWRpdG9yU2VsZWN0aW9uLmNyZWF0ZShbcmFuZ2VdLmNvbmNhdCh0aGlzLnJhbmdlcyksIG1haW4gPyAwIDogdGhpcy5tYWluSW5kZXggKyAxKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgUmVwbGFjZSBhIGdpdmVuIHJhbmdlIHdpdGggYW5vdGhlciByYW5nZSwgYW5kIHRoZW4gbm9ybWFsaXplIHRoZVxyXG4gICAgc2VsZWN0aW9uIHRvIG1lcmdlIGFuZCBzb3J0IHJhbmdlcyBpZiBuZWNlc3NhcnkuXHJcbiAgICAqL1xyXG4gICAgcmVwbGFjZVJhbmdlKHJhbmdlLCB3aGljaCA9IHRoaXMubWFpbkluZGV4KSB7XHJcbiAgICAgICAgbGV0IHJhbmdlcyA9IHRoaXMucmFuZ2VzLnNsaWNlKCk7XHJcbiAgICAgICAgcmFuZ2VzW3doaWNoXSA9IHJhbmdlO1xyXG4gICAgICAgIHJldHVybiBFZGl0b3JTZWxlY3Rpb24uY3JlYXRlKHJhbmdlcywgdGhpcy5tYWluSW5kZXgpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICBDb252ZXJ0IHRoaXMgc2VsZWN0aW9uIHRvIGFuIG9iamVjdCB0aGF0IGNhbiBiZSBzZXJpYWxpemVkIHRvXHJcbiAgICBKU09OLlxyXG4gICAgKi9cclxuICAgIHRvSlNPTigpIHtcclxuICAgICAgICByZXR1cm4geyByYW5nZXM6IHRoaXMucmFuZ2VzLm1hcChyID0+IHIudG9KU09OKCkpLCBtYWluOiB0aGlzLm1haW5JbmRleCB9O1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICBDcmVhdGUgYSBzZWxlY3Rpb24gZnJvbSBhIEpTT04gcmVwcmVzZW50YXRpb24uXHJcbiAgICAqL1xyXG4gICAgc3RhdGljIGZyb21KU09OKGpzb24pIHtcclxuICAgICAgICBpZiAoIWpzb24gfHwgIUFycmF5LmlzQXJyYXkoanNvbi5yYW5nZXMpIHx8IHR5cGVvZiBqc29uLm1haW4gIT0gXCJudW1iZXJcIiB8fCBqc29uLm1haW4gPj0ganNvbi5yYW5nZXMubGVuZ3RoKVxyXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgSlNPTiByZXByZXNlbnRhdGlvbiBmb3IgRWRpdG9yU2VsZWN0aW9uXCIpO1xyXG4gICAgICAgIHJldHVybiBuZXcgRWRpdG9yU2VsZWN0aW9uKGpzb24ucmFuZ2VzLm1hcCgocikgPT4gU2VsZWN0aW9uUmFuZ2UuZnJvbUpTT04ocikpLCBqc29uLm1haW4pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICBDcmVhdGUgYSBzZWxlY3Rpb24gaG9sZGluZyBhIHNpbmdsZSByYW5nZS5cclxuICAgICovXHJcbiAgICBzdGF0aWMgc2luZ2xlKGFuY2hvciwgaGVhZCA9IGFuY2hvcikge1xyXG4gICAgICAgIHJldHVybiBuZXcgRWRpdG9yU2VsZWN0aW9uKFtFZGl0b3JTZWxlY3Rpb24ucmFuZ2UoYW5jaG9yLCBoZWFkKV0sIDApO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICBTb3J0IGFuZCBtZXJnZSB0aGUgZ2l2ZW4gc2V0IG9mIHJhbmdlcywgY3JlYXRpbmcgYSB2YWxpZFxyXG4gICAgc2VsZWN0aW9uLlxyXG4gICAgKi9cclxuICAgIHN0YXRpYyBjcmVhdGUocmFuZ2VzLCBtYWluSW5kZXggPSAwKSB7XHJcbiAgICAgICAgaWYgKHJhbmdlcy5sZW5ndGggPT0gMClcclxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJBIHNlbGVjdGlvbiBuZWVkcyBhdCBsZWFzdCBvbmUgcmFuZ2VcIik7XHJcbiAgICAgICAgZm9yIChsZXQgcG9zID0gMCwgaSA9IDA7IGkgPCByYW5nZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgbGV0IHJhbmdlID0gcmFuZ2VzW2ldO1xyXG4gICAgICAgICAgICBpZiAocmFuZ2UuZW1wdHkgPyByYW5nZS5mcm9tIDw9IHBvcyA6IHJhbmdlLmZyb20gPCBwb3MpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gRWRpdG9yU2VsZWN0aW9uLm5vcm1hbGl6ZWQocmFuZ2VzLnNsaWNlKCksIG1haW5JbmRleCk7XHJcbiAgICAgICAgICAgIHBvcyA9IHJhbmdlLnRvO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbmV3IEVkaXRvclNlbGVjdGlvbihyYW5nZXMsIG1haW5JbmRleCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgIENyZWF0ZSBhIGN1cnNvciBzZWxlY3Rpb24gcmFuZ2UgYXQgdGhlIGdpdmVuIHBvc2l0aW9uLiBZb3UgY2FuXHJcbiAgICBzYWZlbHkgaWdub3JlIHRoZSBvcHRpb25hbCBhcmd1bWVudHMgaW4gbW9zdCBzaXR1YXRpb25zLlxyXG4gICAgKi9cclxuICAgIHN0YXRpYyBjdXJzb3IocG9zLCBhc3NvYyA9IDAsIGJpZGlMZXZlbCwgZ29hbENvbHVtbikge1xyXG4gICAgICAgIHJldHVybiBTZWxlY3Rpb25SYW5nZS5jcmVhdGUocG9zLCBwb3MsIChhc3NvYyA9PSAwID8gMCA6IGFzc29jIDwgMCA/IDQgLyogUmFuZ2VGbGFnLkFzc29jQmVmb3JlICovIDogOCAvKiBSYW5nZUZsYWcuQXNzb2NBZnRlciAqLykgfFxyXG4gICAgICAgICAgICAoYmlkaUxldmVsID09IG51bGwgPyAzIDogTWF0aC5taW4oMiwgYmlkaUxldmVsKSkgfFxyXG4gICAgICAgICAgICAoKGdvYWxDb2x1bW4gIT09IG51bGwgJiYgZ29hbENvbHVtbiAhPT0gdm9pZCAwID8gZ29hbENvbHVtbiA6IDMzNTU0NDMxIC8qIFJhbmdlRmxhZy5Ob0dvYWxDb2x1bW4gKi8pIDw8IDUgLyogUmFuZ2VGbGFnLkdvYWxDb2x1bW5PZmZzZXQgKi8pKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgQ3JlYXRlIGEgc2VsZWN0aW9uIHJhbmdlLlxyXG4gICAgKi9cclxuICAgIHN0YXRpYyByYW5nZShhbmNob3IsIGhlYWQsIGdvYWxDb2x1bW4sIGJpZGlMZXZlbCkge1xyXG4gICAgICAgIGxldCBmbGFncyA9ICgoZ29hbENvbHVtbiAhPT0gbnVsbCAmJiBnb2FsQ29sdW1uICE9PSB2b2lkIDAgPyBnb2FsQ29sdW1uIDogMzM1NTQ0MzEgLyogUmFuZ2VGbGFnLk5vR29hbENvbHVtbiAqLykgPDwgNSAvKiBSYW5nZUZsYWcuR29hbENvbHVtbk9mZnNldCAqLykgfFxyXG4gICAgICAgICAgICAoYmlkaUxldmVsID09IG51bGwgPyAzIDogTWF0aC5taW4oMiwgYmlkaUxldmVsKSk7XHJcbiAgICAgICAgcmV0dXJuIGhlYWQgPCBhbmNob3IgPyBTZWxlY3Rpb25SYW5nZS5jcmVhdGUoaGVhZCwgYW5jaG9yLCAxNiAvKiBSYW5nZUZsYWcuSW52ZXJ0ZWQgKi8gfCA4IC8qIFJhbmdlRmxhZy5Bc3NvY0FmdGVyICovIHwgZmxhZ3MpXHJcbiAgICAgICAgICAgIDogU2VsZWN0aW9uUmFuZ2UuY3JlYXRlKGFuY2hvciwgaGVhZCwgKGhlYWQgPiBhbmNob3IgPyA0IC8qIFJhbmdlRmxhZy5Bc3NvY0JlZm9yZSAqLyA6IDApIHwgZmxhZ3MpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICBAaW50ZXJuYWxcclxuICAgICovXHJcbiAgICBzdGF0aWMgbm9ybWFsaXplZChyYW5nZXMsIG1haW5JbmRleCA9IDApIHtcclxuICAgICAgICBsZXQgbWFpbiA9IHJhbmdlc1ttYWluSW5kZXhdO1xyXG4gICAgICAgIHJhbmdlcy5zb3J0KChhLCBiKSA9PiBhLmZyb20gLSBiLmZyb20pO1xyXG4gICAgICAgIG1haW5JbmRleCA9IHJhbmdlcy5pbmRleE9mKG1haW4pO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgcmFuZ2VzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGxldCByYW5nZSA9IHJhbmdlc1tpXSwgcHJldiA9IHJhbmdlc1tpIC0gMV07XHJcbiAgICAgICAgICAgIGlmIChyYW5nZS5lbXB0eSA/IHJhbmdlLmZyb20gPD0gcHJldi50byA6IHJhbmdlLmZyb20gPCBwcmV2LnRvKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgZnJvbSA9IHByZXYuZnJvbSwgdG8gPSBNYXRoLm1heChyYW5nZS50bywgcHJldi50byk7XHJcbiAgICAgICAgICAgICAgICBpZiAoaSA8PSBtYWluSW5kZXgpXHJcbiAgICAgICAgICAgICAgICAgICAgbWFpbkluZGV4LS07XHJcbiAgICAgICAgICAgICAgICByYW5nZXMuc3BsaWNlKC0taSwgMiwgcmFuZ2UuYW5jaG9yID4gcmFuZ2UuaGVhZCA/IEVkaXRvclNlbGVjdGlvbi5yYW5nZSh0bywgZnJvbSkgOiBFZGl0b3JTZWxlY3Rpb24ucmFuZ2UoZnJvbSwgdG8pKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbmV3IEVkaXRvclNlbGVjdGlvbihyYW5nZXMsIG1haW5JbmRleCk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gY2hlY2tTZWxlY3Rpb24oc2VsZWN0aW9uLCBkb2NMZW5ndGgpIHtcclxuICAgIGZvciAobGV0IHJhbmdlIG9mIHNlbGVjdGlvbi5yYW5nZXMpXHJcbiAgICAgICAgaWYgKHJhbmdlLnRvID4gZG9jTGVuZ3RoKVxyXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIlNlbGVjdGlvbiBwb2ludHMgb3V0c2lkZSBvZiBkb2N1bWVudFwiKTtcclxufVxyXG5cclxubGV0IG5leHRJRCA9IDA7XHJcbi8qKlxyXG5BIGZhY2V0IGlzIGEgbGFiZWxlZCB2YWx1ZSB0aGF0IGlzIGFzc29jaWF0ZWQgd2l0aCBhbiBlZGl0b3Jcclxuc3RhdGUuIEl0IHRha2VzIGlucHV0cyBmcm9tIGFueSBudW1iZXIgb2YgZXh0ZW5zaW9ucywgYW5kIGNvbWJpbmVzXHJcbnRob3NlIGludG8gYSBzaW5nbGUgb3V0cHV0IHZhbHVlLlxyXG5cclxuRXhhbXBsZXMgb2YgdXNlcyBvZiBmYWNldHMgYXJlIHRoZSBbdGFiXHJcbnNpemVdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuRWRpdG9yU3RhdGVedGFiU2l6ZSksIFtlZGl0b3JcclxuYXR0cmlidXRlc10oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LkVkaXRvclZpZXdeZWRpdG9yQXR0cmlidXRlcyksIGFuZCBbdXBkYXRlXHJcbmxpc3RlbmVyc10oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LkVkaXRvclZpZXdedXBkYXRlTGlzdGVuZXIpLlxyXG4qL1xyXG5jbGFzcyBGYWNldCB7XHJcbiAgICBjb25zdHJ1Y3RvcihcclxuICAgIC8qKlxyXG4gICAgQGludGVybmFsXHJcbiAgICAqL1xyXG4gICAgY29tYmluZSwgXHJcbiAgICAvKipcclxuICAgIEBpbnRlcm5hbFxyXG4gICAgKi9cclxuICAgIGNvbXBhcmVJbnB1dCwgXHJcbiAgICAvKipcclxuICAgIEBpbnRlcm5hbFxyXG4gICAgKi9cclxuICAgIGNvbXBhcmUsIGlzU3RhdGljLCBlbmFibGVzKSB7XHJcbiAgICAgICAgdGhpcy5jb21iaW5lID0gY29tYmluZTtcclxuICAgICAgICB0aGlzLmNvbXBhcmVJbnB1dCA9IGNvbXBhcmVJbnB1dDtcclxuICAgICAgICB0aGlzLmNvbXBhcmUgPSBjb21wYXJlO1xyXG4gICAgICAgIHRoaXMuaXNTdGF0aWMgPSBpc1N0YXRpYztcclxuICAgICAgICAvKipcclxuICAgICAgICBAaW50ZXJuYWxcclxuICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuaWQgPSBuZXh0SUQrKztcclxuICAgICAgICB0aGlzLmRlZmF1bHQgPSBjb21iaW5lKFtdKTtcclxuICAgICAgICB0aGlzLmV4dGVuc2lvbnMgPSB0eXBlb2YgZW5hYmxlcyA9PSBcImZ1bmN0aW9uXCIgPyBlbmFibGVzKHRoaXMpIDogZW5hYmxlcztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgRGVmaW5lIGEgbmV3IGZhY2V0LlxyXG4gICAgKi9cclxuICAgIHN0YXRpYyBkZWZpbmUoY29uZmlnID0ge30pIHtcclxuICAgICAgICByZXR1cm4gbmV3IEZhY2V0KGNvbmZpZy5jb21iaW5lIHx8ICgoYSkgPT4gYSksIGNvbmZpZy5jb21wYXJlSW5wdXQgfHwgKChhLCBiKSA9PiBhID09PSBiKSwgY29uZmlnLmNvbXBhcmUgfHwgKCFjb25maWcuY29tYmluZSA/IHNhbWVBcnJheSA6IChhLCBiKSA9PiBhID09PSBiKSwgISFjb25maWcuc3RhdGljLCBjb25maWcuZW5hYmxlcyk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgIFJldHVybnMgYW4gZXh0ZW5zaW9uIHRoYXQgYWRkcyB0aGUgZ2l2ZW4gdmFsdWUgdG8gdGhpcyBmYWNldC5cclxuICAgICovXHJcbiAgICBvZih2YWx1ZSkge1xyXG4gICAgICAgIHJldHVybiBuZXcgRmFjZXRQcm92aWRlcihbXSwgdGhpcywgMCAvKiBQcm92aWRlci5TdGF0aWMgKi8sIHZhbHVlKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgQ3JlYXRlIGFuIGV4dGVuc2lvbiB0aGF0IGNvbXB1dGVzIGEgdmFsdWUgZm9yIHRoZSBmYWNldCBmcm9tIGFcclxuICAgIHN0YXRlLiBZb3UgbXVzdCB0YWtlIGNhcmUgdG8gZGVjbGFyZSB0aGUgcGFydHMgb2YgdGhlIHN0YXRlIHRoYXRcclxuICAgIHRoaXMgdmFsdWUgZGVwZW5kcyBvbiwgc2luY2UgeW91ciBmdW5jdGlvbiBpcyBvbmx5IGNhbGxlZCBhZ2FpblxyXG4gICAgZm9yIGEgbmV3IHN0YXRlIHdoZW4gb25lIG9mIHRob3NlIHBhcnRzIGNoYW5nZWQuXHJcbiAgICBcclxuICAgIEluIGNhc2VzIHdoZXJlIHlvdXIgdmFsdWUgZGVwZW5kcyBvbmx5IG9uIGEgc2luZ2xlIGZpZWxkLCB5b3UnbGxcclxuICAgIHdhbnQgdG8gdXNlIHRoZSBbYGZyb21gXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkZhY2V0LmZyb20pIG1ldGhvZCBpbnN0ZWFkLlxyXG4gICAgKi9cclxuICAgIGNvbXB1dGUoZGVwcywgZ2V0KSB7XHJcbiAgICAgICAgaWYgKHRoaXMuaXNTdGF0aWMpXHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbid0IGNvbXB1dGUgYSBzdGF0aWMgZmFjZXRcIik7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBGYWNldFByb3ZpZGVyKGRlcHMsIHRoaXMsIDEgLyogUHJvdmlkZXIuU2luZ2xlICovLCBnZXQpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICBDcmVhdGUgYW4gZXh0ZW5zaW9uIHRoYXQgY29tcHV0ZXMgemVybyBvciBtb3JlIHZhbHVlcyBmb3IgdGhpc1xyXG4gICAgZmFjZXQgZnJvbSBhIHN0YXRlLlxyXG4gICAgKi9cclxuICAgIGNvbXB1dGVOKGRlcHMsIGdldCkge1xyXG4gICAgICAgIGlmICh0aGlzLmlzU3RhdGljKVxyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW4ndCBjb21wdXRlIGEgc3RhdGljIGZhY2V0XCIpO1xyXG4gICAgICAgIHJldHVybiBuZXcgRmFjZXRQcm92aWRlcihkZXBzLCB0aGlzLCAyIC8qIFByb3ZpZGVyLk11bHRpICovLCBnZXQpO1xyXG4gICAgfVxyXG4gICAgZnJvbShmaWVsZCwgZ2V0KSB7XHJcbiAgICAgICAgaWYgKCFnZXQpXHJcbiAgICAgICAgICAgIGdldCA9IHggPT4geDtcclxuICAgICAgICByZXR1cm4gdGhpcy5jb21wdXRlKFtmaWVsZF0sIHN0YXRlID0+IGdldChzdGF0ZS5maWVsZChmaWVsZCkpKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBzYW1lQXJyYXkoYSwgYikge1xyXG4gICAgcmV0dXJuIGEgPT0gYiB8fCBhLmxlbmd0aCA9PSBiLmxlbmd0aCAmJiBhLmV2ZXJ5KChlLCBpKSA9PiBlID09PSBiW2ldKTtcclxufVxyXG5jbGFzcyBGYWNldFByb3ZpZGVyIHtcclxuICAgIGNvbnN0cnVjdG9yKGRlcGVuZGVuY2llcywgZmFjZXQsIHR5cGUsIHZhbHVlKSB7XHJcbiAgICAgICAgdGhpcy5kZXBlbmRlbmNpZXMgPSBkZXBlbmRlbmNpZXM7XHJcbiAgICAgICAgdGhpcy5mYWNldCA9IGZhY2V0O1xyXG4gICAgICAgIHRoaXMudHlwZSA9IHR5cGU7XHJcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xyXG4gICAgICAgIHRoaXMuaWQgPSBuZXh0SUQrKztcclxuICAgIH1cclxuICAgIGR5bmFtaWNTbG90KGFkZHJlc3Nlcykge1xyXG4gICAgICAgIHZhciBfYTtcclxuICAgICAgICBsZXQgZ2V0dGVyID0gdGhpcy52YWx1ZTtcclxuICAgICAgICBsZXQgY29tcGFyZSA9IHRoaXMuZmFjZXQuY29tcGFyZUlucHV0O1xyXG4gICAgICAgIGxldCBpZCA9IHRoaXMuaWQsIGlkeCA9IGFkZHJlc3Nlc1tpZF0gPj4gMSwgbXVsdGkgPSB0aGlzLnR5cGUgPT0gMiAvKiBQcm92aWRlci5NdWx0aSAqLztcclxuICAgICAgICBsZXQgZGVwRG9jID0gZmFsc2UsIGRlcFNlbCA9IGZhbHNlLCBkZXBBZGRycyA9IFtdO1xyXG4gICAgICAgIGZvciAobGV0IGRlcCBvZiB0aGlzLmRlcGVuZGVuY2llcykge1xyXG4gICAgICAgICAgICBpZiAoZGVwID09IFwiZG9jXCIpXHJcbiAgICAgICAgICAgICAgICBkZXBEb2MgPSB0cnVlO1xyXG4gICAgICAgICAgICBlbHNlIGlmIChkZXAgPT0gXCJzZWxlY3Rpb25cIilcclxuICAgICAgICAgICAgICAgIGRlcFNlbCA9IHRydWU7XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKCgoKF9hID0gYWRkcmVzc2VzW2RlcC5pZF0pICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IDEpICYgMSkgPT0gMClcclxuICAgICAgICAgICAgICAgIGRlcEFkZHJzLnB1c2goYWRkcmVzc2VzW2RlcC5pZF0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBjcmVhdGUoc3RhdGUpIHtcclxuICAgICAgICAgICAgICAgIHN0YXRlLnZhbHVlc1tpZHhdID0gZ2V0dGVyKHN0YXRlKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiAxIC8qIFNsb3RTdGF0dXMuQ2hhbmdlZCAqLztcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgdXBkYXRlKHN0YXRlLCB0cikge1xyXG4gICAgICAgICAgICAgICAgaWYgKChkZXBEb2MgJiYgdHIuZG9jQ2hhbmdlZCkgfHwgKGRlcFNlbCAmJiAodHIuZG9jQ2hhbmdlZCB8fCB0ci5zZWxlY3Rpb24pKSB8fCBlbnN1cmVBbGwoc3RhdGUsIGRlcEFkZHJzKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBuZXdWYWwgPSBnZXR0ZXIoc3RhdGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChtdWx0aSA/ICFjb21wYXJlQXJyYXkobmV3VmFsLCBzdGF0ZS52YWx1ZXNbaWR4XSwgY29tcGFyZSkgOiAhY29tcGFyZShuZXdWYWwsIHN0YXRlLnZhbHVlc1tpZHhdKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZS52YWx1ZXNbaWR4XSA9IG5ld1ZhbDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDEgLyogU2xvdFN0YXR1cy5DaGFuZ2VkICovO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiAwO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICByZWNvbmZpZ3VyZTogKHN0YXRlLCBvbGRTdGF0ZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgbGV0IG5ld1ZhbCwgb2xkQWRkciA9IG9sZFN0YXRlLmNvbmZpZy5hZGRyZXNzW2lkXTtcclxuICAgICAgICAgICAgICAgIGlmIChvbGRBZGRyICE9IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgb2xkVmFsID0gZ2V0QWRkcihvbGRTdGF0ZSwgb2xkQWRkcik7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuZGVwZW5kZW5jaWVzLmV2ZXJ5KGRlcCA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBkZXAgaW5zdGFuY2VvZiBGYWNldCA/IG9sZFN0YXRlLmZhY2V0KGRlcCkgPT09IHN0YXRlLmZhY2V0KGRlcCkgOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVwIGluc3RhbmNlb2YgU3RhdGVGaWVsZCA/IG9sZFN0YXRlLmZpZWxkKGRlcCwgZmFsc2UpID09IHN0YXRlLmZpZWxkKGRlcCwgZmFsc2UpIDogdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICB9KSB8fCAobXVsdGkgPyBjb21wYXJlQXJyYXkobmV3VmFsID0gZ2V0dGVyKHN0YXRlKSwgb2xkVmFsLCBjb21wYXJlKSA6IGNvbXBhcmUobmV3VmFsID0gZ2V0dGVyKHN0YXRlKSwgb2xkVmFsKSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUudmFsdWVzW2lkeF0gPSBvbGRWYWw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAwO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIG5ld1ZhbCA9IGdldHRlcihzdGF0ZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBzdGF0ZS52YWx1ZXNbaWR4XSA9IG5ld1ZhbDtcclxuICAgICAgICAgICAgICAgIHJldHVybiAxIC8qIFNsb3RTdGF0dXMuQ2hhbmdlZCAqLztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gY29tcGFyZUFycmF5KGEsIGIsIGNvbXBhcmUpIHtcclxuICAgIGlmIChhLmxlbmd0aCAhPSBiLmxlbmd0aClcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGEubGVuZ3RoOyBpKyspXHJcbiAgICAgICAgaWYgKCFjb21wYXJlKGFbaV0sIGJbaV0pKVxyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICByZXR1cm4gdHJ1ZTtcclxufVxyXG5mdW5jdGlvbiBlbnN1cmVBbGwoc3RhdGUsIGFkZHJzKSB7XHJcbiAgICBsZXQgY2hhbmdlZCA9IGZhbHNlO1xyXG4gICAgZm9yIChsZXQgYWRkciBvZiBhZGRycylcclxuICAgICAgICBpZiAoZW5zdXJlQWRkcihzdGF0ZSwgYWRkcikgJiAxIC8qIFNsb3RTdGF0dXMuQ2hhbmdlZCAqLylcclxuICAgICAgICAgICAgY2hhbmdlZCA9IHRydWU7XHJcbiAgICByZXR1cm4gY2hhbmdlZDtcclxufVxyXG5mdW5jdGlvbiBkeW5hbWljRmFjZXRTbG90KGFkZHJlc3NlcywgZmFjZXQsIHByb3ZpZGVycykge1xyXG4gICAgbGV0IHByb3ZpZGVyQWRkcnMgPSBwcm92aWRlcnMubWFwKHAgPT4gYWRkcmVzc2VzW3AuaWRdKTtcclxuICAgIGxldCBwcm92aWRlclR5cGVzID0gcHJvdmlkZXJzLm1hcChwID0+IHAudHlwZSk7XHJcbiAgICBsZXQgZHluYW1pYyA9IHByb3ZpZGVyQWRkcnMuZmlsdGVyKHAgPT4gIShwICYgMSkpO1xyXG4gICAgbGV0IGlkeCA9IGFkZHJlc3Nlc1tmYWNldC5pZF0gPj4gMTtcclxuICAgIGZ1bmN0aW9uIGdldChzdGF0ZSkge1xyXG4gICAgICAgIGxldCB2YWx1ZXMgPSBbXTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHByb3ZpZGVyQWRkcnMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgbGV0IHZhbHVlID0gZ2V0QWRkcihzdGF0ZSwgcHJvdmlkZXJBZGRyc1tpXSk7XHJcbiAgICAgICAgICAgIGlmIChwcm92aWRlclR5cGVzW2ldID09IDIgLyogUHJvdmlkZXIuTXVsdGkgKi8pXHJcbiAgICAgICAgICAgICAgICBmb3IgKGxldCB2YWwgb2YgdmFsdWUpXHJcbiAgICAgICAgICAgICAgICAgICAgdmFsdWVzLnB1c2godmFsKTtcclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgdmFsdWVzLnB1c2godmFsdWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZmFjZXQuY29tYmluZSh2YWx1ZXMpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBjcmVhdGUoc3RhdGUpIHtcclxuICAgICAgICAgICAgZm9yIChsZXQgYWRkciBvZiBwcm92aWRlckFkZHJzKVxyXG4gICAgICAgICAgICAgICAgZW5zdXJlQWRkcihzdGF0ZSwgYWRkcik7XHJcbiAgICAgICAgICAgIHN0YXRlLnZhbHVlc1tpZHhdID0gZ2V0KHN0YXRlKTtcclxuICAgICAgICAgICAgcmV0dXJuIDEgLyogU2xvdFN0YXR1cy5DaGFuZ2VkICovO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgdXBkYXRlKHN0YXRlLCB0cikge1xyXG4gICAgICAgICAgICBpZiAoIWVuc3VyZUFsbChzdGF0ZSwgZHluYW1pYykpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcclxuICAgICAgICAgICAgbGV0IHZhbHVlID0gZ2V0KHN0YXRlKTtcclxuICAgICAgICAgICAgaWYgKGZhY2V0LmNvbXBhcmUodmFsdWUsIHN0YXRlLnZhbHVlc1tpZHhdKSlcclxuICAgICAgICAgICAgICAgIHJldHVybiAwO1xyXG4gICAgICAgICAgICBzdGF0ZS52YWx1ZXNbaWR4XSA9IHZhbHVlO1xyXG4gICAgICAgICAgICByZXR1cm4gMSAvKiBTbG90U3RhdHVzLkNoYW5nZWQgKi87XHJcbiAgICAgICAgfSxcclxuICAgICAgICByZWNvbmZpZ3VyZShzdGF0ZSwgb2xkU3RhdGUpIHtcclxuICAgICAgICAgICAgbGV0IGRlcENoYW5nZWQgPSBlbnN1cmVBbGwoc3RhdGUsIHByb3ZpZGVyQWRkcnMpO1xyXG4gICAgICAgICAgICBsZXQgb2xkUHJvdmlkZXJzID0gb2xkU3RhdGUuY29uZmlnLmZhY2V0c1tmYWNldC5pZF0sIG9sZFZhbHVlID0gb2xkU3RhdGUuZmFjZXQoZmFjZXQpO1xyXG4gICAgICAgICAgICBpZiAob2xkUHJvdmlkZXJzICYmICFkZXBDaGFuZ2VkICYmIHNhbWVBcnJheShwcm92aWRlcnMsIG9sZFByb3ZpZGVycykpIHtcclxuICAgICAgICAgICAgICAgIHN0YXRlLnZhbHVlc1tpZHhdID0gb2xkVmFsdWU7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBsZXQgdmFsdWUgPSBnZXQoc3RhdGUpO1xyXG4gICAgICAgICAgICBpZiAoZmFjZXQuY29tcGFyZSh2YWx1ZSwgb2xkVmFsdWUpKSB7XHJcbiAgICAgICAgICAgICAgICBzdGF0ZS52YWx1ZXNbaWR4XSA9IG9sZFZhbHVlO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgc3RhdGUudmFsdWVzW2lkeF0gPSB2YWx1ZTtcclxuICAgICAgICAgICAgcmV0dXJuIDEgLyogU2xvdFN0YXR1cy5DaGFuZ2VkICovO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbn1cclxuY29uc3QgaW5pdEZpZWxkID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSh7IHN0YXRpYzogdHJ1ZSB9KTtcclxuLyoqXHJcbkZpZWxkcyBjYW4gc3RvcmUgYWRkaXRpb25hbCBpbmZvcm1hdGlvbiBpbiBhbiBlZGl0b3Igc3RhdGUsIGFuZFxyXG5rZWVwIGl0IGluIHN5bmMgd2l0aCB0aGUgcmVzdCBvZiB0aGUgc3RhdGUuXHJcbiovXHJcbmNsYXNzIFN0YXRlRmllbGQge1xyXG4gICAgY29uc3RydWN0b3IoXHJcbiAgICAvKipcclxuICAgIEBpbnRlcm5hbFxyXG4gICAgKi9cclxuICAgIGlkLCBjcmVhdGVGLCB1cGRhdGVGLCBjb21wYXJlRiwgXHJcbiAgICAvKipcclxuICAgIEBpbnRlcm5hbFxyXG4gICAgKi9cclxuICAgIHNwZWMpIHtcclxuICAgICAgICB0aGlzLmlkID0gaWQ7XHJcbiAgICAgICAgdGhpcy5jcmVhdGVGID0gY3JlYXRlRjtcclxuICAgICAgICB0aGlzLnVwZGF0ZUYgPSB1cGRhdGVGO1xyXG4gICAgICAgIHRoaXMuY29tcGFyZUYgPSBjb21wYXJlRjtcclxuICAgICAgICB0aGlzLnNwZWMgPSBzcGVjO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgIEBpbnRlcm5hbFxyXG4gICAgICAgICovXHJcbiAgICAgICAgdGhpcy5wcm92aWRlcyA9IHVuZGVmaW5lZDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgRGVmaW5lIGEgc3RhdGUgZmllbGQuXHJcbiAgICAqL1xyXG4gICAgc3RhdGljIGRlZmluZShjb25maWcpIHtcclxuICAgICAgICBsZXQgZmllbGQgPSBuZXcgU3RhdGVGaWVsZChuZXh0SUQrKywgY29uZmlnLmNyZWF0ZSwgY29uZmlnLnVwZGF0ZSwgY29uZmlnLmNvbXBhcmUgfHwgKChhLCBiKSA9PiBhID09PSBiKSwgY29uZmlnKTtcclxuICAgICAgICBpZiAoY29uZmlnLnByb3ZpZGUpXHJcbiAgICAgICAgICAgIGZpZWxkLnByb3ZpZGVzID0gY29uZmlnLnByb3ZpZGUoZmllbGQpO1xyXG4gICAgICAgIHJldHVybiBmaWVsZDtcclxuICAgIH1cclxuICAgIGNyZWF0ZShzdGF0ZSkge1xyXG4gICAgICAgIGxldCBpbml0ID0gc3RhdGUuZmFjZXQoaW5pdEZpZWxkKS5maW5kKGkgPT4gaS5maWVsZCA9PSB0aGlzKTtcclxuICAgICAgICByZXR1cm4gKChpbml0ID09PSBudWxsIHx8IGluaXQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGluaXQuY3JlYXRlKSB8fCB0aGlzLmNyZWF0ZUYpKHN0YXRlKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgQGludGVybmFsXHJcbiAgICAqL1xyXG4gICAgc2xvdChhZGRyZXNzZXMpIHtcclxuICAgICAgICBsZXQgaWR4ID0gYWRkcmVzc2VzW3RoaXMuaWRdID4+IDE7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgY3JlYXRlOiAoc3RhdGUpID0+IHtcclxuICAgICAgICAgICAgICAgIHN0YXRlLnZhbHVlc1tpZHhdID0gdGhpcy5jcmVhdGUoc3RhdGUpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIDEgLyogU2xvdFN0YXR1cy5DaGFuZ2VkICovO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICB1cGRhdGU6IChzdGF0ZSwgdHIpID0+IHtcclxuICAgICAgICAgICAgICAgIGxldCBvbGRWYWwgPSBzdGF0ZS52YWx1ZXNbaWR4XTtcclxuICAgICAgICAgICAgICAgIGxldCB2YWx1ZSA9IHRoaXMudXBkYXRlRihvbGRWYWwsIHRyKTtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmNvbXBhcmVGKG9sZFZhbCwgdmFsdWUpKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAwO1xyXG4gICAgICAgICAgICAgICAgc3RhdGUudmFsdWVzW2lkeF0gPSB2YWx1ZTtcclxuICAgICAgICAgICAgICAgIHJldHVybiAxIC8qIFNsb3RTdGF0dXMuQ2hhbmdlZCAqLztcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgcmVjb25maWd1cmU6IChzdGF0ZSwgb2xkU3RhdGUpID0+IHtcclxuICAgICAgICAgICAgICAgIGlmIChvbGRTdGF0ZS5jb25maWcuYWRkcmVzc1t0aGlzLmlkXSAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUudmFsdWVzW2lkeF0gPSBvbGRTdGF0ZS5maWVsZCh0aGlzKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gMDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHN0YXRlLnZhbHVlc1tpZHhdID0gdGhpcy5jcmVhdGUoc3RhdGUpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIDEgLyogU2xvdFN0YXR1cy5DaGFuZ2VkICovO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgUmV0dXJucyBhbiBleHRlbnNpb24gdGhhdCBlbmFibGVzIHRoaXMgZmllbGQgYW5kIG92ZXJyaWRlcyB0aGVcclxuICAgIHdheSBpdCBpcyBpbml0aWFsaXplZC4gQ2FuIGJlIHVzZWZ1bCB3aGVuIHlvdSBuZWVkIHRvIHByb3ZpZGUgYVxyXG4gICAgbm9uLWRlZmF1bHQgc3RhcnRpbmcgdmFsdWUgZm9yIHRoZSBmaWVsZC5cclxuICAgICovXHJcbiAgICBpbml0KGNyZWF0ZSkge1xyXG4gICAgICAgIHJldHVybiBbdGhpcywgaW5pdEZpZWxkLm9mKHsgZmllbGQ6IHRoaXMsIGNyZWF0ZSB9KV07XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgIFN0YXRlIGZpZWxkIGluc3RhbmNlcyBjYW4gYmUgdXNlZCBhc1xyXG4gICAgW2BFeHRlbnNpb25gXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkV4dGVuc2lvbikgdmFsdWVzIHRvIGVuYWJsZSB0aGUgZmllbGQgaW4gYVxyXG4gICAgZ2l2ZW4gc3RhdGUuXHJcbiAgICAqL1xyXG4gICAgZ2V0IGV4dGVuc2lvbigpIHsgcmV0dXJuIHRoaXM7IH1cclxufVxyXG5jb25zdCBQcmVjXyA9IHsgbG93ZXN0OiA0LCBsb3c6IDMsIGRlZmF1bHQ6IDIsIGhpZ2g6IDEsIGhpZ2hlc3Q6IDAgfTtcclxuZnVuY3Rpb24gcHJlYyh2YWx1ZSkge1xyXG4gICAgcmV0dXJuIChleHQpID0+IG5ldyBQcmVjRXh0ZW5zaW9uKGV4dCwgdmFsdWUpO1xyXG59XHJcbi8qKlxyXG5CeSBkZWZhdWx0IGV4dGVuc2lvbnMgYXJlIHJlZ2lzdGVyZWQgaW4gdGhlIG9yZGVyIHRoZXkgYXJlIGZvdW5kXHJcbmluIHRoZSBmbGF0dGVuZWQgZm9ybSBvZiBuZXN0ZWQgYXJyYXkgdGhhdCB3YXMgcHJvdmlkZWQuXHJcbkluZGl2aWR1YWwgZXh0ZW5zaW9uIHZhbHVlcyBjYW4gYmUgYXNzaWduZWQgYSBwcmVjZWRlbmNlIHRvXHJcbm92ZXJyaWRlIHRoaXMuIEV4dGVuc2lvbnMgdGhhdCBkbyBub3QgaGF2ZSBhIHByZWNlZGVuY2Ugc2V0IGdldFxyXG50aGUgcHJlY2VkZW5jZSBvZiB0aGUgbmVhcmVzdCBwYXJlbnQgd2l0aCBhIHByZWNlZGVuY2UsIG9yXHJcbltgZGVmYXVsdGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuUHJlYy5kZWZhdWx0KSBpZiB0aGVyZSBpcyBubyBzdWNoIHBhcmVudC4gVGhlXHJcbmZpbmFsIG9yZGVyaW5nIG9mIGV4dGVuc2lvbnMgaXMgZGV0ZXJtaW5lZCBieSBmaXJzdCBzb3J0aW5nIGJ5XHJcbnByZWNlZGVuY2UgYW5kIHRoZW4gYnkgb3JkZXIgd2l0aGluIGVhY2ggcHJlY2VkZW5jZS5cclxuKi9cclxuY29uc3QgUHJlYyA9IHtcclxuICAgIC8qKlxyXG4gICAgVGhlIGhpZ2hlc3QgcHJlY2VkZW5jZSBsZXZlbCwgZm9yIGV4dGVuc2lvbnMgdGhhdCBzaG91bGQgZW5kIHVwXHJcbiAgICBuZWFyIHRoZSBzdGFydCBvZiB0aGUgcHJlY2VkZW5jZSBvcmRlcmluZy5cclxuICAgICovXHJcbiAgICBoaWdoZXN0OiAvKkBfX1BVUkVfXyovcHJlYyhQcmVjXy5oaWdoZXN0KSxcclxuICAgIC8qKlxyXG4gICAgQSBoaWdoZXItdGhhbi1kZWZhdWx0IHByZWNlZGVuY2UsIGZvciBleHRlbnNpb25zIHRoYXQgc2hvdWxkXHJcbiAgICBjb21lIGJlZm9yZSB0aG9zZSB3aXRoIGRlZmF1bHQgcHJlY2VkZW5jZS5cclxuICAgICovXHJcbiAgICBoaWdoOiAvKkBfX1BVUkVfXyovcHJlYyhQcmVjXy5oaWdoKSxcclxuICAgIC8qKlxyXG4gICAgVGhlIGRlZmF1bHQgcHJlY2VkZW5jZSwgd2hpY2ggaXMgYWxzbyB1c2VkIGZvciBleHRlbnNpb25zXHJcbiAgICB3aXRob3V0IGFuIGV4cGxpY2l0IHByZWNlZGVuY2UuXHJcbiAgICAqL1xyXG4gICAgZGVmYXVsdDogLypAX19QVVJFX18qL3ByZWMoUHJlY18uZGVmYXVsdCksXHJcbiAgICAvKipcclxuICAgIEEgbG93ZXItdGhhbi1kZWZhdWx0IHByZWNlZGVuY2UuXHJcbiAgICAqL1xyXG4gICAgbG93OiAvKkBfX1BVUkVfXyovcHJlYyhQcmVjXy5sb3cpLFxyXG4gICAgLyoqXHJcbiAgICBUaGUgbG93ZXN0IHByZWNlZGVuY2UgbGV2ZWwuIE1lYW50IGZvciB0aGluZ3MgdGhhdCBzaG91bGQgZW5kIHVwXHJcbiAgICBuZWFyIHRoZSBlbmQgb2YgdGhlIGV4dGVuc2lvbiBvcmRlci5cclxuICAgICovXHJcbiAgICBsb3dlc3Q6IC8qQF9fUFVSRV9fKi9wcmVjKFByZWNfLmxvd2VzdClcclxufTtcclxuY2xhc3MgUHJlY0V4dGVuc2lvbiB7XHJcbiAgICBjb25zdHJ1Y3Rvcihpbm5lciwgcHJlYykge1xyXG4gICAgICAgIHRoaXMuaW5uZXIgPSBpbm5lcjtcclxuICAgICAgICB0aGlzLnByZWMgPSBwcmVjO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG5FeHRlbnNpb24gY29tcGFydG1lbnRzIGNhbiBiZSB1c2VkIHRvIG1ha2UgYSBjb25maWd1cmF0aW9uXHJcbmR5bmFtaWMuIEJ5IFt3cmFwcGluZ10oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5Db21wYXJ0bWVudC5vZikgcGFydCBvZiB5b3VyXHJcbmNvbmZpZ3VyYXRpb24gaW4gYSBjb21wYXJ0bWVudCwgeW91IGNhbiBsYXRlclxyXG5bcmVwbGFjZV0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5Db21wYXJ0bWVudC5yZWNvbmZpZ3VyZSkgdGhhdCBwYXJ0IHRocm91Z2ggYVxyXG50cmFuc2FjdGlvbi5cclxuKi9cclxuY2xhc3MgQ29tcGFydG1lbnQge1xyXG4gICAgLyoqXHJcbiAgICBDcmVhdGUgYW4gaW5zdGFuY2Ugb2YgdGhpcyBjb21wYXJ0bWVudCB0byBhZGQgdG8geW91ciBbc3RhdGVcclxuICAgIGNvbmZpZ3VyYXRpb25dKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuRWRpdG9yU3RhdGVDb25maWcuZXh0ZW5zaW9ucykuXHJcbiAgICAqL1xyXG4gICAgb2YoZXh0KSB7IHJldHVybiBuZXcgQ29tcGFydG1lbnRJbnN0YW5jZSh0aGlzLCBleHQpOyB9XHJcbiAgICAvKipcclxuICAgIENyZWF0ZSBhbiBbZWZmZWN0XShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlRyYW5zYWN0aW9uU3BlYy5lZmZlY3RzKSB0aGF0XHJcbiAgICByZWNvbmZpZ3VyZXMgdGhpcyBjb21wYXJ0bWVudC5cclxuICAgICovXHJcbiAgICByZWNvbmZpZ3VyZShjb250ZW50KSB7XHJcbiAgICAgICAgcmV0dXJuIENvbXBhcnRtZW50LnJlY29uZmlndXJlLm9mKHsgY29tcGFydG1lbnQ6IHRoaXMsIGV4dGVuc2lvbjogY29udGVudCB9KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgR2V0IHRoZSBjdXJyZW50IGNvbnRlbnQgb2YgdGhlIGNvbXBhcnRtZW50IGluIHRoZSBzdGF0ZSwgb3JcclxuICAgIGB1bmRlZmluZWRgIGlmIGl0IGlzbid0IHByZXNlbnQuXHJcbiAgICAqL1xyXG4gICAgZ2V0KHN0YXRlKSB7XHJcbiAgICAgICAgcmV0dXJuIHN0YXRlLmNvbmZpZy5jb21wYXJ0bWVudHMuZ2V0KHRoaXMpO1xyXG4gICAgfVxyXG59XHJcbmNsYXNzIENvbXBhcnRtZW50SW5zdGFuY2Uge1xyXG4gICAgY29uc3RydWN0b3IoY29tcGFydG1lbnQsIGlubmVyKSB7XHJcbiAgICAgICAgdGhpcy5jb21wYXJ0bWVudCA9IGNvbXBhcnRtZW50O1xyXG4gICAgICAgIHRoaXMuaW5uZXIgPSBpbm5lcjtcclxuICAgIH1cclxufVxyXG5jbGFzcyBDb25maWd1cmF0aW9uIHtcclxuICAgIGNvbnN0cnVjdG9yKGJhc2UsIGNvbXBhcnRtZW50cywgZHluYW1pY1Nsb3RzLCBhZGRyZXNzLCBzdGF0aWNWYWx1ZXMsIGZhY2V0cykge1xyXG4gICAgICAgIHRoaXMuYmFzZSA9IGJhc2U7XHJcbiAgICAgICAgdGhpcy5jb21wYXJ0bWVudHMgPSBjb21wYXJ0bWVudHM7XHJcbiAgICAgICAgdGhpcy5keW5hbWljU2xvdHMgPSBkeW5hbWljU2xvdHM7XHJcbiAgICAgICAgdGhpcy5hZGRyZXNzID0gYWRkcmVzcztcclxuICAgICAgICB0aGlzLnN0YXRpY1ZhbHVlcyA9IHN0YXRpY1ZhbHVlcztcclxuICAgICAgICB0aGlzLmZhY2V0cyA9IGZhY2V0cztcclxuICAgICAgICB0aGlzLnN0YXR1c1RlbXBsYXRlID0gW107XHJcbiAgICAgICAgd2hpbGUgKHRoaXMuc3RhdHVzVGVtcGxhdGUubGVuZ3RoIDwgZHluYW1pY1Nsb3RzLmxlbmd0aClcclxuICAgICAgICAgICAgdGhpcy5zdGF0dXNUZW1wbGF0ZS5wdXNoKDAgLyogU2xvdFN0YXR1cy5VbnJlc29sdmVkICovKTtcclxuICAgIH1cclxuICAgIHN0YXRpY0ZhY2V0KGZhY2V0KSB7XHJcbiAgICAgICAgbGV0IGFkZHIgPSB0aGlzLmFkZHJlc3NbZmFjZXQuaWRdO1xyXG4gICAgICAgIHJldHVybiBhZGRyID09IG51bGwgPyBmYWNldC5kZWZhdWx0IDogdGhpcy5zdGF0aWNWYWx1ZXNbYWRkciA+PiAxXTtcclxuICAgIH1cclxuICAgIHN0YXRpYyByZXNvbHZlKGJhc2UsIGNvbXBhcnRtZW50cywgb2xkU3RhdGUpIHtcclxuICAgICAgICBsZXQgZmllbGRzID0gW107XHJcbiAgICAgICAgbGV0IGZhY2V0cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XHJcbiAgICAgICAgbGV0IG5ld0NvbXBhcnRtZW50cyA9IG5ldyBNYXAoKTtcclxuICAgICAgICBmb3IgKGxldCBleHQgb2YgZmxhdHRlbihiYXNlLCBjb21wYXJ0bWVudHMsIG5ld0NvbXBhcnRtZW50cykpIHtcclxuICAgICAgICAgICAgaWYgKGV4dCBpbnN0YW5jZW9mIFN0YXRlRmllbGQpXHJcbiAgICAgICAgICAgICAgICBmaWVsZHMucHVzaChleHQpO1xyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAoZmFjZXRzW2V4dC5mYWNldC5pZF0gfHwgKGZhY2V0c1tleHQuZmFjZXQuaWRdID0gW10pKS5wdXNoKGV4dCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCBhZGRyZXNzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcclxuICAgICAgICBsZXQgc3RhdGljVmFsdWVzID0gW107XHJcbiAgICAgICAgbGV0IGR5bmFtaWNTbG90cyA9IFtdO1xyXG4gICAgICAgIGZvciAobGV0IGZpZWxkIG9mIGZpZWxkcykge1xyXG4gICAgICAgICAgICBhZGRyZXNzW2ZpZWxkLmlkXSA9IGR5bmFtaWNTbG90cy5sZW5ndGggPDwgMTtcclxuICAgICAgICAgICAgZHluYW1pY1Nsb3RzLnB1c2goYSA9PiBmaWVsZC5zbG90KGEpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IG9sZEZhY2V0cyA9IG9sZFN0YXRlID09PSBudWxsIHx8IG9sZFN0YXRlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvbGRTdGF0ZS5jb25maWcuZmFjZXRzO1xyXG4gICAgICAgIGZvciAobGV0IGlkIGluIGZhY2V0cykge1xyXG4gICAgICAgICAgICBsZXQgcHJvdmlkZXJzID0gZmFjZXRzW2lkXSwgZmFjZXQgPSBwcm92aWRlcnNbMF0uZmFjZXQ7XHJcbiAgICAgICAgICAgIGxldCBvbGRQcm92aWRlcnMgPSBvbGRGYWNldHMgJiYgb2xkRmFjZXRzW2lkXSB8fCBbXTtcclxuICAgICAgICAgICAgaWYgKHByb3ZpZGVycy5ldmVyeShwID0+IHAudHlwZSA9PSAwIC8qIFByb3ZpZGVyLlN0YXRpYyAqLykpIHtcclxuICAgICAgICAgICAgICAgIGFkZHJlc3NbZmFjZXQuaWRdID0gKHN0YXRpY1ZhbHVlcy5sZW5ndGggPDwgMSkgfCAxO1xyXG4gICAgICAgICAgICAgICAgaWYgKHNhbWVBcnJheShvbGRQcm92aWRlcnMsIHByb3ZpZGVycykpIHtcclxuICAgICAgICAgICAgICAgICAgICBzdGF0aWNWYWx1ZXMucHVzaChvbGRTdGF0ZS5mYWNldChmYWNldCkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IHZhbHVlID0gZmFjZXQuY29tYmluZShwcm92aWRlcnMubWFwKHAgPT4gcC52YWx1ZSkpO1xyXG4gICAgICAgICAgICAgICAgICAgIHN0YXRpY1ZhbHVlcy5wdXNoKG9sZFN0YXRlICYmIGZhY2V0LmNvbXBhcmUodmFsdWUsIG9sZFN0YXRlLmZhY2V0KGZhY2V0KSkgPyBvbGRTdGF0ZS5mYWNldChmYWNldCkgOiB2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBwIG9mIHByb3ZpZGVycykge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChwLnR5cGUgPT0gMCAvKiBQcm92aWRlci5TdGF0aWMgKi8pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYWRkcmVzc1twLmlkXSA9IChzdGF0aWNWYWx1ZXMubGVuZ3RoIDw8IDEpIHwgMTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGljVmFsdWVzLnB1c2gocC52YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRyZXNzW3AuaWRdID0gZHluYW1pY1Nsb3RzLmxlbmd0aCA8PCAxO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkeW5hbWljU2xvdHMucHVzaChhID0+IHAuZHluYW1pY1Nsb3QoYSkpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGFkZHJlc3NbZmFjZXQuaWRdID0gZHluYW1pY1Nsb3RzLmxlbmd0aCA8PCAxO1xyXG4gICAgICAgICAgICAgICAgZHluYW1pY1Nsb3RzLnB1c2goYSA9PiBkeW5hbWljRmFjZXRTbG90KGEsIGZhY2V0LCBwcm92aWRlcnMpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgZHluYW1pYyA9IGR5bmFtaWNTbG90cy5tYXAoZiA9PiBmKGFkZHJlc3MpKTtcclxuICAgICAgICByZXR1cm4gbmV3IENvbmZpZ3VyYXRpb24oYmFzZSwgbmV3Q29tcGFydG1lbnRzLCBkeW5hbWljLCBhZGRyZXNzLCBzdGF0aWNWYWx1ZXMsIGZhY2V0cyk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gZmxhdHRlbihleHRlbnNpb24sIGNvbXBhcnRtZW50cywgbmV3Q29tcGFydG1lbnRzKSB7XHJcbiAgICBsZXQgcmVzdWx0ID0gW1tdLCBbXSwgW10sIFtdLCBbXV07XHJcbiAgICBsZXQgc2VlbiA9IG5ldyBNYXAoKTtcclxuICAgIGZ1bmN0aW9uIGlubmVyKGV4dCwgcHJlYykge1xyXG4gICAgICAgIGxldCBrbm93biA9IHNlZW4uZ2V0KGV4dCk7XHJcbiAgICAgICAgaWYgKGtub3duICE9IG51bGwpIHtcclxuICAgICAgICAgICAgaWYgKGtub3duIDw9IHByZWMpXHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIGxldCBmb3VuZCA9IHJlc3VsdFtrbm93bl0uaW5kZXhPZihleHQpO1xyXG4gICAgICAgICAgICBpZiAoZm91bmQgPiAtMSlcclxuICAgICAgICAgICAgICAgIHJlc3VsdFtrbm93bl0uc3BsaWNlKGZvdW5kLCAxKTtcclxuICAgICAgICAgICAgaWYgKGV4dCBpbnN0YW5jZW9mIENvbXBhcnRtZW50SW5zdGFuY2UpXHJcbiAgICAgICAgICAgICAgICBuZXdDb21wYXJ0bWVudHMuZGVsZXRlKGV4dC5jb21wYXJ0bWVudCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHNlZW4uc2V0KGV4dCwgcHJlYyk7XHJcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZXh0KSkge1xyXG4gICAgICAgICAgICBmb3IgKGxldCBlIG9mIGV4dClcclxuICAgICAgICAgICAgICAgIGlubmVyKGUsIHByZWMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChleHQgaW5zdGFuY2VvZiBDb21wYXJ0bWVudEluc3RhbmNlKSB7XHJcbiAgICAgICAgICAgIGlmIChuZXdDb21wYXJ0bWVudHMuaGFzKGV4dC5jb21wYXJ0bWVudCkpXHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgRHVwbGljYXRlIHVzZSBvZiBjb21wYXJ0bWVudCBpbiBleHRlbnNpb25zYCk7XHJcbiAgICAgICAgICAgIGxldCBjb250ZW50ID0gY29tcGFydG1lbnRzLmdldChleHQuY29tcGFydG1lbnQpIHx8IGV4dC5pbm5lcjtcclxuICAgICAgICAgICAgbmV3Q29tcGFydG1lbnRzLnNldChleHQuY29tcGFydG1lbnQsIGNvbnRlbnQpO1xyXG4gICAgICAgICAgICBpbm5lcihjb250ZW50LCBwcmVjKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoZXh0IGluc3RhbmNlb2YgUHJlY0V4dGVuc2lvbikge1xyXG4gICAgICAgICAgICBpbm5lcihleHQuaW5uZXIsIGV4dC5wcmVjKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoZXh0IGluc3RhbmNlb2YgU3RhdGVGaWVsZCkge1xyXG4gICAgICAgICAgICByZXN1bHRbcHJlY10ucHVzaChleHQpO1xyXG4gICAgICAgICAgICBpZiAoZXh0LnByb3ZpZGVzKVxyXG4gICAgICAgICAgICAgICAgaW5uZXIoZXh0LnByb3ZpZGVzLCBwcmVjKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoZXh0IGluc3RhbmNlb2YgRmFjZXRQcm92aWRlcikge1xyXG4gICAgICAgICAgICByZXN1bHRbcHJlY10ucHVzaChleHQpO1xyXG4gICAgICAgICAgICBpZiAoZXh0LmZhY2V0LmV4dGVuc2lvbnMpXHJcbiAgICAgICAgICAgICAgICBpbm5lcihleHQuZmFjZXQuZXh0ZW5zaW9ucywgUHJlY18uZGVmYXVsdCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBsZXQgY29udGVudCA9IGV4dC5leHRlbnNpb247XHJcbiAgICAgICAgICAgIGlmICghY29udGVudClcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5yZWNvZ25pemVkIGV4dGVuc2lvbiB2YWx1ZSBpbiBleHRlbnNpb24gc2V0ICgke2V4dH0pLiBUaGlzIHNvbWV0aW1lcyBoYXBwZW5zIGJlY2F1c2UgbXVsdGlwbGUgaW5zdGFuY2VzIG9mIEBjb2RlbWlycm9yL3N0YXRlIGFyZSBsb2FkZWQsIGJyZWFraW5nIGluc3RhbmNlb2YgY2hlY2tzLmApO1xyXG4gICAgICAgICAgICBpbm5lcihjb250ZW50LCBwcmVjKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpbm5lcihleHRlbnNpb24sIFByZWNfLmRlZmF1bHQpO1xyXG4gICAgcmV0dXJuIHJlc3VsdC5yZWR1Y2UoKGEsIGIpID0+IGEuY29uY2F0KGIpKTtcclxufVxyXG5mdW5jdGlvbiBlbnN1cmVBZGRyKHN0YXRlLCBhZGRyKSB7XHJcbiAgICBpZiAoYWRkciAmIDEpXHJcbiAgICAgICAgcmV0dXJuIDIgLyogU2xvdFN0YXR1cy5Db21wdXRlZCAqLztcclxuICAgIGxldCBpZHggPSBhZGRyID4+IDE7XHJcbiAgICBsZXQgc3RhdHVzID0gc3RhdGUuc3RhdHVzW2lkeF07XHJcbiAgICBpZiAoc3RhdHVzID09IDQgLyogU2xvdFN0YXR1cy5Db21wdXRpbmcgKi8pXHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ3ljbGljIGRlcGVuZGVuY3kgYmV0d2VlbiBmaWVsZHMgYW5kL29yIGZhY2V0c1wiKTtcclxuICAgIGlmIChzdGF0dXMgJiAyIC8qIFNsb3RTdGF0dXMuQ29tcHV0ZWQgKi8pXHJcbiAgICAgICAgcmV0dXJuIHN0YXR1cztcclxuICAgIHN0YXRlLnN0YXR1c1tpZHhdID0gNCAvKiBTbG90U3RhdHVzLkNvbXB1dGluZyAqLztcclxuICAgIGxldCBjaGFuZ2VkID0gc3RhdGUuY29tcHV0ZVNsb3Qoc3RhdGUsIHN0YXRlLmNvbmZpZy5keW5hbWljU2xvdHNbaWR4XSk7XHJcbiAgICByZXR1cm4gc3RhdGUuc3RhdHVzW2lkeF0gPSAyIC8qIFNsb3RTdGF0dXMuQ29tcHV0ZWQgKi8gfCBjaGFuZ2VkO1xyXG59XHJcbmZ1bmN0aW9uIGdldEFkZHIoc3RhdGUsIGFkZHIpIHtcclxuICAgIHJldHVybiBhZGRyICYgMSA/IHN0YXRlLmNvbmZpZy5zdGF0aWNWYWx1ZXNbYWRkciA+PiAxXSA6IHN0YXRlLnZhbHVlc1thZGRyID4+IDFdO1xyXG59XHJcblxyXG5jb25zdCBsYW5ndWFnZURhdGEgPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKCk7XHJcbmNvbnN0IGFsbG93TXVsdGlwbGVTZWxlY3Rpb25zID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSh7XHJcbiAgICBjb21iaW5lOiB2YWx1ZXMgPT4gdmFsdWVzLnNvbWUodiA9PiB2KSxcclxuICAgIHN0YXRpYzogdHJ1ZVxyXG59KTtcclxuY29uc3QgbGluZVNlcGFyYXRvciA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoe1xyXG4gICAgY29tYmluZTogdmFsdWVzID0+IHZhbHVlcy5sZW5ndGggPyB2YWx1ZXNbMF0gOiB1bmRlZmluZWQsXHJcbiAgICBzdGF0aWM6IHRydWVcclxufSk7XHJcbmNvbnN0IGNoYW5nZUZpbHRlciA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoKTtcclxuY29uc3QgdHJhbnNhY3Rpb25GaWx0ZXIgPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKCk7XHJcbmNvbnN0IHRyYW5zYWN0aW9uRXh0ZW5kZXIgPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKCk7XHJcbmNvbnN0IHJlYWRPbmx5ID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSh7XHJcbiAgICBjb21iaW5lOiB2YWx1ZXMgPT4gdmFsdWVzLmxlbmd0aCA/IHZhbHVlc1swXSA6IGZhbHNlXHJcbn0pO1xyXG5cclxuLyoqXHJcbkFubm90YXRpb25zIGFyZSB0YWdnZWQgdmFsdWVzIHRoYXQgYXJlIHVzZWQgdG8gYWRkIG1ldGFkYXRhIHRvXHJcbnRyYW5zYWN0aW9ucyBpbiBhbiBleHRlbnNpYmxlIHdheS4gVGhleSBzaG91bGQgYmUgdXNlZCB0byBtb2RlbFxyXG50aGluZ3MgdGhhdCBlZmZlY3QgdGhlIGVudGlyZSB0cmFuc2FjdGlvbiAoc3VjaCBhcyBpdHMgW3RpbWVcclxuc3RhbXBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuVHJhbnNhY3Rpb25edGltZSkgb3IgaW5mb3JtYXRpb24gYWJvdXQgaXRzXHJcbltvcmlnaW5dKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuVHJhbnNhY3Rpb25edXNlckV2ZW50KSkuIEZvciBlZmZlY3RzIHRoYXQgaGFwcGVuXHJcbl9hbG9uZ3NpZGVfIHRoZSBvdGhlciBjaGFuZ2VzIG1hZGUgYnkgdGhlIHRyYW5zYWN0aW9uLCBbc3RhdGVcclxuZWZmZWN0c10oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5TdGF0ZUVmZmVjdCkgYXJlIG1vcmUgYXBwcm9wcmlhdGUuXHJcbiovXHJcbmNsYXNzIEFubm90YXRpb24ge1xyXG4gICAgLyoqXHJcbiAgICBAaW50ZXJuYWxcclxuICAgICovXHJcbiAgICBjb25zdHJ1Y3RvcihcclxuICAgIC8qKlxyXG4gICAgVGhlIGFubm90YXRpb24gdHlwZS5cclxuICAgICovXHJcbiAgICB0eXBlLCBcclxuICAgIC8qKlxyXG4gICAgVGhlIHZhbHVlIG9mIHRoaXMgYW5ub3RhdGlvbi5cclxuICAgICovXHJcbiAgICB2YWx1ZSkge1xyXG4gICAgICAgIHRoaXMudHlwZSA9IHR5cGU7XHJcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICBEZWZpbmUgYSBuZXcgdHlwZSBvZiBhbm5vdGF0aW9uLlxyXG4gICAgKi9cclxuICAgIHN0YXRpYyBkZWZpbmUoKSB7IHJldHVybiBuZXcgQW5ub3RhdGlvblR5cGUoKTsgfVxyXG59XHJcbi8qKlxyXG5NYXJrZXIgdGhhdCBpZGVudGlmaWVzIGEgdHlwZSBvZiBbYW5ub3RhdGlvbl0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5Bbm5vdGF0aW9uKS5cclxuKi9cclxuY2xhc3MgQW5ub3RhdGlvblR5cGUge1xyXG4gICAgLyoqXHJcbiAgICBDcmVhdGUgYW4gaW5zdGFuY2Ugb2YgdGhpcyBhbm5vdGF0aW9uLlxyXG4gICAgKi9cclxuICAgIG9mKHZhbHVlKSB7IHJldHVybiBuZXcgQW5ub3RhdGlvbih0aGlzLCB2YWx1ZSk7IH1cclxufVxyXG4vKipcclxuUmVwcmVzZW50YXRpb24gb2YgYSB0eXBlIG9mIHN0YXRlIGVmZmVjdC4gRGVmaW5lZCB3aXRoXHJcbltgU3RhdGVFZmZlY3QuZGVmaW5lYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5TdGF0ZUVmZmVjdF5kZWZpbmUpLlxyXG4qL1xyXG5jbGFzcyBTdGF0ZUVmZmVjdFR5cGUge1xyXG4gICAgLyoqXHJcbiAgICBAaW50ZXJuYWxcclxuICAgICovXHJcbiAgICBjb25zdHJ1Y3RvcihcclxuICAgIC8vIFRoZSBgYW55YCB0eXBlcyBpbiB0aGVzZSBmdW5jdGlvbiB0eXBlcyBhcmUgdGhlcmUgdG8gd29ya1xyXG4gICAgLy8gYXJvdW5kIFR5cGVTY3JpcHQgaXNzdWUgIzM3NjMxLCB3aGVyZSB0aGUgdHlwZSBndWFyZCBvblxyXG4gICAgLy8gYFN0YXRlRWZmZWN0LmlzYCBteXN0ZXJpb3VzbHkgc3RvcHMgd29ya2luZyB3aGVuIHRoZXNlIHByb3Blcmx5XHJcbiAgICAvLyBoYXZlIHR5cGUgYFZhbHVlYC5cclxuICAgIC8qKlxyXG4gICAgQGludGVybmFsXHJcbiAgICAqL1xyXG4gICAgbWFwKSB7XHJcbiAgICAgICAgdGhpcy5tYXAgPSBtYXA7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgIENyZWF0ZSBhIFtzdGF0ZSBlZmZlY3RdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuU3RhdGVFZmZlY3QpIGluc3RhbmNlIG9mIHRoaXNcclxuICAgIHR5cGUuXHJcbiAgICAqL1xyXG4gICAgb2YodmFsdWUpIHsgcmV0dXJuIG5ldyBTdGF0ZUVmZmVjdCh0aGlzLCB2YWx1ZSk7IH1cclxufVxyXG4vKipcclxuU3RhdGUgZWZmZWN0cyBjYW4gYmUgdXNlZCB0byByZXByZXNlbnQgYWRkaXRpb25hbCBlZmZlY3RzXHJcbmFzc29jaWF0ZWQgd2l0aCBhIFt0cmFuc2FjdGlvbl0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5UcmFuc2FjdGlvbi5lZmZlY3RzKS4gVGhleVxyXG5hcmUgb2Z0ZW4gdXNlZnVsIHRvIG1vZGVsIGNoYW5nZXMgdG8gY3VzdG9tIFtzdGF0ZVxyXG5maWVsZHNdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuU3RhdGVGaWVsZCksIHdoZW4gdGhvc2UgY2hhbmdlcyBhcmVuJ3QgaW1wbGljaXQgaW5cclxuZG9jdW1lbnQgb3Igc2VsZWN0aW9uIGNoYW5nZXMuXHJcbiovXHJcbmNsYXNzIFN0YXRlRWZmZWN0IHtcclxuICAgIC8qKlxyXG4gICAgQGludGVybmFsXHJcbiAgICAqL1xyXG4gICAgY29uc3RydWN0b3IoXHJcbiAgICAvKipcclxuICAgIEBpbnRlcm5hbFxyXG4gICAgKi9cclxuICAgIHR5cGUsIFxyXG4gICAgLyoqXHJcbiAgICBUaGUgdmFsdWUgb2YgdGhpcyBlZmZlY3QuXHJcbiAgICAqL1xyXG4gICAgdmFsdWUpIHtcclxuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xyXG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgTWFwIHRoaXMgZWZmZWN0IHRocm91Z2ggYSBwb3NpdGlvbiBtYXBwaW5nLiBXaWxsIHJldHVyblxyXG4gICAgYHVuZGVmaW5lZGAgd2hlbiB0aGF0IGVuZHMgdXAgZGVsZXRpbmcgdGhlIGVmZmVjdC5cclxuICAgICovXHJcbiAgICBtYXAobWFwcGluZykge1xyXG4gICAgICAgIGxldCBtYXBwZWQgPSB0aGlzLnR5cGUubWFwKHRoaXMudmFsdWUsIG1hcHBpbmcpO1xyXG4gICAgICAgIHJldHVybiBtYXBwZWQgPT09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZCA6IG1hcHBlZCA9PSB0aGlzLnZhbHVlID8gdGhpcyA6IG5ldyBTdGF0ZUVmZmVjdCh0aGlzLnR5cGUsIG1hcHBlZCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgIFRlbGxzIHlvdSB3aGV0aGVyIHRoaXMgZWZmZWN0IG9iamVjdCBpcyBvZiBhIGdpdmVuXHJcbiAgICBbdHlwZV0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5TdGF0ZUVmZmVjdFR5cGUpLlxyXG4gICAgKi9cclxuICAgIGlzKHR5cGUpIHsgcmV0dXJuIHRoaXMudHlwZSA9PSB0eXBlOyB9XHJcbiAgICAvKipcclxuICAgIERlZmluZSBhIG5ldyBlZmZlY3QgdHlwZS4gVGhlIHR5cGUgcGFyYW1ldGVyIGluZGljYXRlcyB0aGUgdHlwZVxyXG4gICAgb2YgdmFsdWVzIHRoYXQgaGlzIGVmZmVjdCBob2xkcy5cclxuICAgICovXHJcbiAgICBzdGF0aWMgZGVmaW5lKHNwZWMgPSB7fSkge1xyXG4gICAgICAgIHJldHVybiBuZXcgU3RhdGVFZmZlY3RUeXBlKHNwZWMubWFwIHx8ICh2ID0+IHYpKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgTWFwIGFuIGFycmF5IG9mIGVmZmVjdHMgdGhyb3VnaCBhIGNoYW5nZSBzZXQuXHJcbiAgICAqL1xyXG4gICAgc3RhdGljIG1hcEVmZmVjdHMoZWZmZWN0cywgbWFwcGluZykge1xyXG4gICAgICAgIGlmICghZWZmZWN0cy5sZW5ndGgpXHJcbiAgICAgICAgICAgIHJldHVybiBlZmZlY3RzO1xyXG4gICAgICAgIGxldCByZXN1bHQgPSBbXTtcclxuICAgICAgICBmb3IgKGxldCBlZmZlY3Qgb2YgZWZmZWN0cykge1xyXG4gICAgICAgICAgICBsZXQgbWFwcGVkID0gZWZmZWN0Lm1hcChtYXBwaW5nKTtcclxuICAgICAgICAgICAgaWYgKG1hcHBlZClcclxuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKG1hcHBlZCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcblRoaXMgZWZmZWN0IGNhbiBiZSB1c2VkIHRvIHJlY29uZmlndXJlIHRoZSByb290IGV4dGVuc2lvbnMgb2ZcclxudGhlIGVkaXRvci4gRG9pbmcgdGhpcyB3aWxsIGRpc2NhcmQgYW55IGV4dGVuc2lvbnNcclxuW2FwcGVuZGVkXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlN0YXRlRWZmZWN0XmFwcGVuZENvbmZpZyksIGJ1dCBkb2VzIG5vdCByZXNldFxyXG50aGUgY29udGVudCBvZiBbcmVjb25maWd1cmVkXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkNvbXBhcnRtZW50LnJlY29uZmlndXJlKVxyXG5jb21wYXJ0bWVudHMuXHJcbiovXHJcblN0YXRlRWZmZWN0LnJlY29uZmlndXJlID0gLypAX19QVVJFX18qL1N0YXRlRWZmZWN0LmRlZmluZSgpO1xyXG4vKipcclxuQXBwZW5kIGV4dGVuc2lvbnMgdG8gdGhlIHRvcC1sZXZlbCBjb25maWd1cmF0aW9uIG9mIHRoZSBlZGl0b3IuXHJcbiovXHJcblN0YXRlRWZmZWN0LmFwcGVuZENvbmZpZyA9IC8qQF9fUFVSRV9fKi9TdGF0ZUVmZmVjdC5kZWZpbmUoKTtcclxuLyoqXHJcbkNoYW5nZXMgdG8gdGhlIGVkaXRvciBzdGF0ZSBhcmUgZ3JvdXBlZCBpbnRvIHRyYW5zYWN0aW9ucy5cclxuVHlwaWNhbGx5LCBhIHVzZXIgYWN0aW9uIGNyZWF0ZXMgYSBzaW5nbGUgdHJhbnNhY3Rpb24sIHdoaWNoIG1heVxyXG5jb250YWluIGFueSBudW1iZXIgb2YgZG9jdW1lbnQgY2hhbmdlcywgbWF5IGNoYW5nZSB0aGUgc2VsZWN0aW9uLFxyXG5vciBoYXZlIG90aGVyIGVmZmVjdHMuIENyZWF0ZSBhIHRyYW5zYWN0aW9uIGJ5IGNhbGxpbmdcclxuW2BFZGl0b3JTdGF0ZS51cGRhdGVgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkVkaXRvclN0YXRlLnVwZGF0ZSksIG9yIGltbWVkaWF0ZWx5XHJcbmRpc3BhdGNoIG9uZSBieSBjYWxsaW5nXHJcbltgRWRpdG9yVmlldy5kaXNwYXRjaGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5FZGl0b3JWaWV3LmRpc3BhdGNoKS5cclxuKi9cclxuY2xhc3MgVHJhbnNhY3Rpb24ge1xyXG4gICAgY29uc3RydWN0b3IoXHJcbiAgICAvKipcclxuICAgIFRoZSBzdGF0ZSBmcm9tIHdoaWNoIHRoZSB0cmFuc2FjdGlvbiBzdGFydHMuXHJcbiAgICAqL1xyXG4gICAgc3RhcnRTdGF0ZSwgXHJcbiAgICAvKipcclxuICAgIFRoZSBkb2N1bWVudCBjaGFuZ2VzIG1hZGUgYnkgdGhpcyB0cmFuc2FjdGlvbi5cclxuICAgICovXHJcbiAgICBjaGFuZ2VzLCBcclxuICAgIC8qKlxyXG4gICAgVGhlIHNlbGVjdGlvbiBzZXQgYnkgdGhpcyB0cmFuc2FjdGlvbiwgb3IgdW5kZWZpbmVkIGlmIGl0XHJcbiAgICBkb2Vzbid0IGV4cGxpY2l0bHkgc2V0IGEgc2VsZWN0aW9uLlxyXG4gICAgKi9cclxuICAgIHNlbGVjdGlvbiwgXHJcbiAgICAvKipcclxuICAgIFRoZSBlZmZlY3RzIGFkZGVkIHRvIHRoZSB0cmFuc2FjdGlvbi5cclxuICAgICovXHJcbiAgICBlZmZlY3RzLCBcclxuICAgIC8qKlxyXG4gICAgQGludGVybmFsXHJcbiAgICAqL1xyXG4gICAgYW5ub3RhdGlvbnMsIFxyXG4gICAgLyoqXHJcbiAgICBXaGV0aGVyIHRoZSBzZWxlY3Rpb24gc2hvdWxkIGJlIHNjcm9sbGVkIGludG8gdmlldyBhZnRlciB0aGlzXHJcbiAgICB0cmFuc2FjdGlvbiBpcyBkaXNwYXRjaGVkLlxyXG4gICAgKi9cclxuICAgIHNjcm9sbEludG9WaWV3KSB7XHJcbiAgICAgICAgdGhpcy5zdGFydFN0YXRlID0gc3RhcnRTdGF0ZTtcclxuICAgICAgICB0aGlzLmNoYW5nZXMgPSBjaGFuZ2VzO1xyXG4gICAgICAgIHRoaXMuc2VsZWN0aW9uID0gc2VsZWN0aW9uO1xyXG4gICAgICAgIHRoaXMuZWZmZWN0cyA9IGVmZmVjdHM7XHJcbiAgICAgICAgdGhpcy5hbm5vdGF0aW9ucyA9IGFubm90YXRpb25zO1xyXG4gICAgICAgIHRoaXMuc2Nyb2xsSW50b1ZpZXcgPSBzY3JvbGxJbnRvVmlldztcclxuICAgICAgICAvKipcclxuICAgICAgICBAaW50ZXJuYWxcclxuICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuX2RvYyA9IG51bGw7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgQGludGVybmFsXHJcbiAgICAgICAgKi9cclxuICAgICAgICB0aGlzLl9zdGF0ZSA9IG51bGw7XHJcbiAgICAgICAgaWYgKHNlbGVjdGlvbilcclxuICAgICAgICAgICAgY2hlY2tTZWxlY3Rpb24oc2VsZWN0aW9uLCBjaGFuZ2VzLm5ld0xlbmd0aCk7XHJcbiAgICAgICAgaWYgKCFhbm5vdGF0aW9ucy5zb21lKChhKSA9PiBhLnR5cGUgPT0gVHJhbnNhY3Rpb24udGltZSkpXHJcbiAgICAgICAgICAgIHRoaXMuYW5ub3RhdGlvbnMgPSBhbm5vdGF0aW9ucy5jb25jYXQoVHJhbnNhY3Rpb24udGltZS5vZihEYXRlLm5vdygpKSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgIEBpbnRlcm5hbFxyXG4gICAgKi9cclxuICAgIHN0YXRpYyBjcmVhdGUoc3RhcnRTdGF0ZSwgY2hhbmdlcywgc2VsZWN0aW9uLCBlZmZlY3RzLCBhbm5vdGF0aW9ucywgc2Nyb2xsSW50b1ZpZXcpIHtcclxuICAgICAgICByZXR1cm4gbmV3IFRyYW5zYWN0aW9uKHN0YXJ0U3RhdGUsIGNoYW5nZXMsIHNlbGVjdGlvbiwgZWZmZWN0cywgYW5ub3RhdGlvbnMsIHNjcm9sbEludG9WaWV3KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgVGhlIG5ldyBkb2N1bWVudCBwcm9kdWNlZCBieSB0aGUgdHJhbnNhY3Rpb24uIENvbnRyYXJ5IHRvXHJcbiAgICBbYC5zdGF0ZWBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuVHJhbnNhY3Rpb24uc3RhdGUpYC5kb2NgLCBhY2Nlc3NpbmcgdGhpcyB3b24ndFxyXG4gICAgZm9yY2UgdGhlIGVudGlyZSBuZXcgc3RhdGUgdG8gYmUgY29tcHV0ZWQgcmlnaHQgYXdheSwgc28gaXQgaXNcclxuICAgIHJlY29tbWVuZGVkIHRoYXQgW3RyYW5zYWN0aW9uXHJcbiAgICBmaWx0ZXJzXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkVkaXRvclN0YXRlXnRyYW5zYWN0aW9uRmlsdGVyKSB1c2UgdGhpcyBnZXR0ZXJcclxuICAgIHdoZW4gdGhleSBuZWVkIHRvIGxvb2sgYXQgdGhlIG5ldyBkb2N1bWVudC5cclxuICAgICovXHJcbiAgICBnZXQgbmV3RG9jKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9kb2MgfHwgKHRoaXMuX2RvYyA9IHRoaXMuY2hhbmdlcy5hcHBseSh0aGlzLnN0YXJ0U3RhdGUuZG9jKSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgIFRoZSBuZXcgc2VsZWN0aW9uIHByb2R1Y2VkIGJ5IHRoZSB0cmFuc2FjdGlvbi4gSWZcclxuICAgIFtgdGhpcy5zZWxlY3Rpb25gXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlRyYW5zYWN0aW9uLnNlbGVjdGlvbikgaXMgdW5kZWZpbmVkLFxyXG4gICAgdGhpcyB3aWxsIFttYXBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuRWRpdG9yU2VsZWN0aW9uLm1hcCkgdGhlIHN0YXJ0IHN0YXRlJ3NcclxuICAgIGN1cnJlbnQgc2VsZWN0aW9uIHRocm91Z2ggdGhlIGNoYW5nZXMgbWFkZSBieSB0aGUgdHJhbnNhY3Rpb24uXHJcbiAgICAqL1xyXG4gICAgZ2V0IG5ld1NlbGVjdGlvbigpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5zZWxlY3Rpb24gfHwgdGhpcy5zdGFydFN0YXRlLnNlbGVjdGlvbi5tYXAodGhpcy5jaGFuZ2VzKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgVGhlIG5ldyBzdGF0ZSBjcmVhdGVkIGJ5IHRoZSB0cmFuc2FjdGlvbi4gQ29tcHV0ZWQgb24gZGVtYW5kXHJcbiAgICAoYnV0IHJldGFpbmVkIGZvciBzdWJzZXF1ZW50IGFjY2VzcyksIHNvIGl0IGlzIHJlY29tbWVuZGVkIG5vdCB0b1xyXG4gICAgYWNjZXNzIGl0IGluIFt0cmFuc2FjdGlvblxyXG4gICAgZmlsdGVyc10oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5FZGl0b3JTdGF0ZV50cmFuc2FjdGlvbkZpbHRlcikgd2hlbiBwb3NzaWJsZS5cclxuICAgICovXHJcbiAgICBnZXQgc3RhdGUoKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLl9zdGF0ZSlcclxuICAgICAgICAgICAgdGhpcy5zdGFydFN0YXRlLmFwcGx5VHJhbnNhY3Rpb24odGhpcyk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3N0YXRlO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICBHZXQgdGhlIHZhbHVlIG9mIHRoZSBnaXZlbiBhbm5vdGF0aW9uIHR5cGUsIGlmIGFueS5cclxuICAgICovXHJcbiAgICBhbm5vdGF0aW9uKHR5cGUpIHtcclxuICAgICAgICBmb3IgKGxldCBhbm4gb2YgdGhpcy5hbm5vdGF0aW9ucylcclxuICAgICAgICAgICAgaWYgKGFubi50eXBlID09IHR5cGUpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYW5uLnZhbHVlO1xyXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgIEluZGljYXRlcyB3aGV0aGVyIHRoZSB0cmFuc2FjdGlvbiBjaGFuZ2VkIHRoZSBkb2N1bWVudC5cclxuICAgICovXHJcbiAgICBnZXQgZG9jQ2hhbmdlZCgpIHsgcmV0dXJuICF0aGlzLmNoYW5nZXMuZW1wdHk7IH1cclxuICAgIC8qKlxyXG4gICAgSW5kaWNhdGVzIHdoZXRoZXIgdGhpcyB0cmFuc2FjdGlvbiByZWNvbmZpZ3VyZXMgdGhlIHN0YXRlXHJcbiAgICAodGhyb3VnaCBhIFtjb25maWd1cmF0aW9uIGNvbXBhcnRtZW50XShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkNvbXBhcnRtZW50KSBvclxyXG4gICAgd2l0aCBhIHRvcC1sZXZlbCBjb25maWd1cmF0aW9uXHJcbiAgICBbZWZmZWN0XShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlN0YXRlRWZmZWN0XnJlY29uZmlndXJlKS5cclxuICAgICovXHJcbiAgICBnZXQgcmVjb25maWd1cmVkKCkgeyByZXR1cm4gdGhpcy5zdGFydFN0YXRlLmNvbmZpZyAhPSB0aGlzLnN0YXRlLmNvbmZpZzsgfVxyXG4gICAgLyoqXHJcbiAgICBSZXR1cm5zIHRydWUgaWYgdGhlIHRyYW5zYWN0aW9uIGhhcyBhIFt1c2VyXHJcbiAgICBldmVudF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5UcmFuc2FjdGlvbl51c2VyRXZlbnQpIGFubm90YXRpb24gdGhhdCBpcyBlcXVhbCB0b1xyXG4gICAgb3IgbW9yZSBzcGVjaWZpYyB0aGFuIGBldmVudGAuIEZvciBleGFtcGxlLCBpZiB0aGUgdHJhbnNhY3Rpb25cclxuICAgIGhhcyBgXCJzZWxlY3QucG9pbnRlclwiYCBhcyB1c2VyIGV2ZW50LCBgXCJzZWxlY3RcImAgYW5kXHJcbiAgICBgXCJzZWxlY3QucG9pbnRlclwiYCB3aWxsIG1hdGNoIGl0LlxyXG4gICAgKi9cclxuICAgIGlzVXNlckV2ZW50KGV2ZW50KSB7XHJcbiAgICAgICAgbGV0IGUgPSB0aGlzLmFubm90YXRpb24oVHJhbnNhY3Rpb24udXNlckV2ZW50KTtcclxuICAgICAgICByZXR1cm4gISEoZSAmJiAoZSA9PSBldmVudCB8fCBlLmxlbmd0aCA+IGV2ZW50Lmxlbmd0aCAmJiBlLnNsaWNlKDAsIGV2ZW50Lmxlbmd0aCkgPT0gZXZlbnQgJiYgZVtldmVudC5sZW5ndGhdID09IFwiLlwiKSk7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbkFubm90YXRpb24gdXNlZCB0byBzdG9yZSB0cmFuc2FjdGlvbiB0aW1lc3RhbXBzLiBBdXRvbWF0aWNhbGx5XHJcbmFkZGVkIHRvIGV2ZXJ5IHRyYW5zYWN0aW9uLCBob2xkaW5nIGBEYXRlLm5vdygpYC5cclxuKi9cclxuVHJhbnNhY3Rpb24udGltZSA9IC8qQF9fUFVSRV9fKi9Bbm5vdGF0aW9uLmRlZmluZSgpO1xyXG4vKipcclxuQW5ub3RhdGlvbiB1c2VkIHRvIGFzc29jaWF0ZSBhIHRyYW5zYWN0aW9uIHdpdGggYSB1c2VyIGludGVyZmFjZVxyXG5ldmVudC4gSG9sZHMgYSBzdHJpbmcgaWRlbnRpZnlpbmcgdGhlIGV2ZW50LCB1c2luZyBhXHJcbmRvdC1zZXBhcmF0ZWQgZm9ybWF0IHRvIHN1cHBvcnQgYXR0YWNoaW5nIG1vcmUgc3BlY2lmaWNcclxuaW5mb3JtYXRpb24uIFRoZSBldmVudHMgdXNlZCBieSB0aGUgY29yZSBsaWJyYXJpZXMgYXJlOlxyXG5cclxuIC0gYFwiaW5wdXRcImAgd2hlbiBjb250ZW50IGlzIGVudGVyZWRcclxuICAgLSBgXCJpbnB1dC50eXBlXCJgIGZvciB0eXBlZCBpbnB1dFxyXG4gICAgIC0gYFwiaW5wdXQudHlwZS5jb21wb3NlXCJgIGZvciBjb21wb3NpdGlvblxyXG4gICAtIGBcImlucHV0LnBhc3RlXCJgIGZvciBwYXN0ZWQgaW5wdXRcclxuICAgLSBgXCJpbnB1dC5kcm9wXCJgIHdoZW4gYWRkaW5nIGNvbnRlbnQgd2l0aCBkcmFnLWFuZC1kcm9wXHJcbiAgIC0gYFwiaW5wdXQuY29tcGxldGVcImAgd2hlbiBhdXRvY29tcGxldGluZ1xyXG4gLSBgXCJkZWxldGVcImAgd2hlbiB0aGUgdXNlciBkZWxldGVzIGNvbnRlbnRcclxuICAgLSBgXCJkZWxldGUuc2VsZWN0aW9uXCJgIHdoZW4gZGVsZXRpbmcgdGhlIHNlbGVjdGlvblxyXG4gICAtIGBcImRlbGV0ZS5mb3J3YXJkXCJgIHdoZW4gZGVsZXRpbmcgZm9yd2FyZCBmcm9tIHRoZSBzZWxlY3Rpb25cclxuICAgLSBgXCJkZWxldGUuYmFja3dhcmRcImAgd2hlbiBkZWxldGluZyBiYWNrd2FyZCBmcm9tIHRoZSBzZWxlY3Rpb25cclxuICAgLSBgXCJkZWxldGUuY3V0XCJgIHdoZW4gY3V0dGluZyB0byB0aGUgY2xpcGJvYXJkXHJcbiAtIGBcIm1vdmVcImAgd2hlbiBjb250ZW50IGlzIG1vdmVkXHJcbiAgIC0gYFwibW92ZS5kcm9wXCJgIHdoZW4gY29udGVudCBpcyBtb3ZlZCB3aXRoaW4gdGhlIGVkaXRvciB0aHJvdWdoIGRyYWctYW5kLWRyb3BcclxuIC0gYFwic2VsZWN0XCJgIHdoZW4gZXhwbGljaXRseSBjaGFuZ2luZyB0aGUgc2VsZWN0aW9uXHJcbiAgIC0gYFwic2VsZWN0LnBvaW50ZXJcImAgd2hlbiBzZWxlY3Rpbmcgd2l0aCBhIG1vdXNlIG9yIG90aGVyIHBvaW50aW5nIGRldmljZVxyXG4gLSBgXCJ1bmRvXCJgIGFuZCBgXCJyZWRvXCJgIGZvciBoaXN0b3J5IGFjdGlvbnNcclxuXHJcblVzZSBbYGlzVXNlckV2ZW50YF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5UcmFuc2FjdGlvbi5pc1VzZXJFdmVudCkgdG8gY2hlY2tcclxud2hldGhlciB0aGUgYW5ub3RhdGlvbiBtYXRjaGVzIGEgZ2l2ZW4gZXZlbnQuXHJcbiovXHJcblRyYW5zYWN0aW9uLnVzZXJFdmVudCA9IC8qQF9fUFVSRV9fKi9Bbm5vdGF0aW9uLmRlZmluZSgpO1xyXG4vKipcclxuQW5ub3RhdGlvbiBpbmRpY2F0aW5nIHdoZXRoZXIgYSB0cmFuc2FjdGlvbiBzaG91bGQgYmUgYWRkZWQgdG9cclxudGhlIHVuZG8gaGlzdG9yeSBvciBub3QuXHJcbiovXHJcblRyYW5zYWN0aW9uLmFkZFRvSGlzdG9yeSA9IC8qQF9fUFVSRV9fKi9Bbm5vdGF0aW9uLmRlZmluZSgpO1xyXG4vKipcclxuQW5ub3RhdGlvbiBpbmRpY2F0aW5nICh3aGVuIHByZXNlbnQgYW5kIHRydWUpIHRoYXQgYSB0cmFuc2FjdGlvblxyXG5yZXByZXNlbnRzIGEgY2hhbmdlIG1hZGUgYnkgc29tZSBvdGhlciBhY3Rvciwgbm90IHRoZSB1c2VyLiBUaGlzXHJcbmlzIHVzZWQsIGZvciBleGFtcGxlLCB0byB0YWcgb3RoZXIgcGVvcGxlJ3MgY2hhbmdlcyBpblxyXG5jb2xsYWJvcmF0aXZlIGVkaXRpbmcuXHJcbiovXHJcblRyYW5zYWN0aW9uLnJlbW90ZSA9IC8qQF9fUFVSRV9fKi9Bbm5vdGF0aW9uLmRlZmluZSgpO1xyXG5mdW5jdGlvbiBqb2luUmFuZ2VzKGEsIGIpIHtcclxuICAgIGxldCByZXN1bHQgPSBbXTtcclxuICAgIGZvciAobGV0IGlBID0gMCwgaUIgPSAwOzspIHtcclxuICAgICAgICBsZXQgZnJvbSwgdG87XHJcbiAgICAgICAgaWYgKGlBIDwgYS5sZW5ndGggJiYgKGlCID09IGIubGVuZ3RoIHx8IGJbaUJdID49IGFbaUFdKSkge1xyXG4gICAgICAgICAgICBmcm9tID0gYVtpQSsrXTtcclxuICAgICAgICAgICAgdG8gPSBhW2lBKytdO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChpQiA8IGIubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIGZyb20gPSBiW2lCKytdO1xyXG4gICAgICAgICAgICB0byA9IGJbaUIrK107XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2VcclxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICBpZiAoIXJlc3VsdC5sZW5ndGggfHwgcmVzdWx0W3Jlc3VsdC5sZW5ndGggLSAxXSA8IGZyb20pXHJcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGZyb20sIHRvKTtcclxuICAgICAgICBlbHNlIGlmIChyZXN1bHRbcmVzdWx0Lmxlbmd0aCAtIDFdIDwgdG8pXHJcbiAgICAgICAgICAgIHJlc3VsdFtyZXN1bHQubGVuZ3RoIC0gMV0gPSB0bztcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBtZXJnZVRyYW5zYWN0aW9uKGEsIGIsIHNlcXVlbnRpYWwpIHtcclxuICAgIHZhciBfYTtcclxuICAgIGxldCBtYXBGb3JBLCBtYXBGb3JCLCBjaGFuZ2VzO1xyXG4gICAgaWYgKHNlcXVlbnRpYWwpIHtcclxuICAgICAgICBtYXBGb3JBID0gYi5jaGFuZ2VzO1xyXG4gICAgICAgIG1hcEZvckIgPSBDaGFuZ2VTZXQuZW1wdHkoYi5jaGFuZ2VzLmxlbmd0aCk7XHJcbiAgICAgICAgY2hhbmdlcyA9IGEuY2hhbmdlcy5jb21wb3NlKGIuY2hhbmdlcyk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBtYXBGb3JBID0gYi5jaGFuZ2VzLm1hcChhLmNoYW5nZXMpO1xyXG4gICAgICAgIG1hcEZvckIgPSBhLmNoYW5nZXMubWFwRGVzYyhiLmNoYW5nZXMsIHRydWUpO1xyXG4gICAgICAgIGNoYW5nZXMgPSBhLmNoYW5nZXMuY29tcG9zZShtYXBGb3JBKTtcclxuICAgIH1cclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgY2hhbmdlcyxcclxuICAgICAgICBzZWxlY3Rpb246IGIuc2VsZWN0aW9uID8gYi5zZWxlY3Rpb24ubWFwKG1hcEZvckIpIDogKF9hID0gYS5zZWxlY3Rpb24pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5tYXAobWFwRm9yQSksXHJcbiAgICAgICAgZWZmZWN0czogU3RhdGVFZmZlY3QubWFwRWZmZWN0cyhhLmVmZmVjdHMsIG1hcEZvckEpLmNvbmNhdChTdGF0ZUVmZmVjdC5tYXBFZmZlY3RzKGIuZWZmZWN0cywgbWFwRm9yQikpLFxyXG4gICAgICAgIGFubm90YXRpb25zOiBhLmFubm90YXRpb25zLmxlbmd0aCA/IGEuYW5ub3RhdGlvbnMuY29uY2F0KGIuYW5ub3RhdGlvbnMpIDogYi5hbm5vdGF0aW9ucyxcclxuICAgICAgICBzY3JvbGxJbnRvVmlldzogYS5zY3JvbGxJbnRvVmlldyB8fCBiLnNjcm9sbEludG9WaWV3XHJcbiAgICB9O1xyXG59XHJcbmZ1bmN0aW9uIHJlc29sdmVUcmFuc2FjdGlvbklubmVyKHN0YXRlLCBzcGVjLCBkb2NTaXplKSB7XHJcbiAgICBsZXQgc2VsID0gc3BlYy5zZWxlY3Rpb24sIGFubm90YXRpb25zID0gYXNBcnJheShzcGVjLmFubm90YXRpb25zKTtcclxuICAgIGlmIChzcGVjLnVzZXJFdmVudClcclxuICAgICAgICBhbm5vdGF0aW9ucyA9IGFubm90YXRpb25zLmNvbmNhdChUcmFuc2FjdGlvbi51c2VyRXZlbnQub2Yoc3BlYy51c2VyRXZlbnQpKTtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgY2hhbmdlczogc3BlYy5jaGFuZ2VzIGluc3RhbmNlb2YgQ2hhbmdlU2V0ID8gc3BlYy5jaGFuZ2VzXHJcbiAgICAgICAgICAgIDogQ2hhbmdlU2V0Lm9mKHNwZWMuY2hhbmdlcyB8fCBbXSwgZG9jU2l6ZSwgc3RhdGUuZmFjZXQobGluZVNlcGFyYXRvcikpLFxyXG4gICAgICAgIHNlbGVjdGlvbjogc2VsICYmIChzZWwgaW5zdGFuY2VvZiBFZGl0b3JTZWxlY3Rpb24gPyBzZWwgOiBFZGl0b3JTZWxlY3Rpb24uc2luZ2xlKHNlbC5hbmNob3IsIHNlbC5oZWFkKSksXHJcbiAgICAgICAgZWZmZWN0czogYXNBcnJheShzcGVjLmVmZmVjdHMpLFxyXG4gICAgICAgIGFubm90YXRpb25zLFxyXG4gICAgICAgIHNjcm9sbEludG9WaWV3OiAhIXNwZWMuc2Nyb2xsSW50b1ZpZXdcclxuICAgIH07XHJcbn1cclxuZnVuY3Rpb24gcmVzb2x2ZVRyYW5zYWN0aW9uKHN0YXRlLCBzcGVjcywgZmlsdGVyKSB7XHJcbiAgICBsZXQgcyA9IHJlc29sdmVUcmFuc2FjdGlvbklubmVyKHN0YXRlLCBzcGVjcy5sZW5ndGggPyBzcGVjc1swXSA6IHt9LCBzdGF0ZS5kb2MubGVuZ3RoKTtcclxuICAgIGlmIChzcGVjcy5sZW5ndGggJiYgc3BlY3NbMF0uZmlsdGVyID09PSBmYWxzZSlcclxuICAgICAgICBmaWx0ZXIgPSBmYWxzZTtcclxuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgc3BlY3MubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBpZiAoc3BlY3NbaV0uZmlsdGVyID09PSBmYWxzZSlcclxuICAgICAgICAgICAgZmlsdGVyID0gZmFsc2U7XHJcbiAgICAgICAgbGV0IHNlcSA9ICEhc3BlY3NbaV0uc2VxdWVudGlhbDtcclxuICAgICAgICBzID0gbWVyZ2VUcmFuc2FjdGlvbihzLCByZXNvbHZlVHJhbnNhY3Rpb25Jbm5lcihzdGF0ZSwgc3BlY3NbaV0sIHNlcSA/IHMuY2hhbmdlcy5uZXdMZW5ndGggOiBzdGF0ZS5kb2MubGVuZ3RoKSwgc2VxKTtcclxuICAgIH1cclxuICAgIGxldCB0ciA9IFRyYW5zYWN0aW9uLmNyZWF0ZShzdGF0ZSwgcy5jaGFuZ2VzLCBzLnNlbGVjdGlvbiwgcy5lZmZlY3RzLCBzLmFubm90YXRpb25zLCBzLnNjcm9sbEludG9WaWV3KTtcclxuICAgIHJldHVybiBleHRlbmRUcmFuc2FjdGlvbihmaWx0ZXIgPyBmaWx0ZXJUcmFuc2FjdGlvbih0cikgOiB0cik7XHJcbn1cclxuLy8gRmluaXNoIGEgdHJhbnNhY3Rpb24gYnkgYXBwbHlpbmcgZmlsdGVycyBpZiBuZWNlc3NhcnkuXHJcbmZ1bmN0aW9uIGZpbHRlclRyYW5zYWN0aW9uKHRyKSB7XHJcbiAgICBsZXQgc3RhdGUgPSB0ci5zdGFydFN0YXRlO1xyXG4gICAgLy8gQ2hhbmdlIGZpbHRlcnNcclxuICAgIGxldCByZXN1bHQgPSB0cnVlO1xyXG4gICAgZm9yIChsZXQgZmlsdGVyIG9mIHN0YXRlLmZhY2V0KGNoYW5nZUZpbHRlcikpIHtcclxuICAgICAgICBsZXQgdmFsdWUgPSBmaWx0ZXIodHIpO1xyXG4gICAgICAgIGlmICh2YWx1ZSA9PT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgcmVzdWx0ID0gZmFsc2U7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpXHJcbiAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdCA9PT0gdHJ1ZSA/IHZhbHVlIDogam9pblJhbmdlcyhyZXN1bHQsIHZhbHVlKTtcclxuICAgIH1cclxuICAgIGlmIChyZXN1bHQgIT09IHRydWUpIHtcclxuICAgICAgICBsZXQgY2hhbmdlcywgYmFjaztcclxuICAgICAgICBpZiAocmVzdWx0ID09PSBmYWxzZSkge1xyXG4gICAgICAgICAgICBiYWNrID0gdHIuY2hhbmdlcy5pbnZlcnRlZERlc2M7XHJcbiAgICAgICAgICAgIGNoYW5nZXMgPSBDaGFuZ2VTZXQuZW1wdHkoc3RhdGUuZG9jLmxlbmd0aCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBsZXQgZmlsdGVyZWQgPSB0ci5jaGFuZ2VzLmZpbHRlcihyZXN1bHQpO1xyXG4gICAgICAgICAgICBjaGFuZ2VzID0gZmlsdGVyZWQuY2hhbmdlcztcclxuICAgICAgICAgICAgYmFjayA9IGZpbHRlcmVkLmZpbHRlcmVkLm1hcERlc2MoZmlsdGVyZWQuY2hhbmdlcykuaW52ZXJ0ZWREZXNjO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0ciA9IFRyYW5zYWN0aW9uLmNyZWF0ZShzdGF0ZSwgY2hhbmdlcywgdHIuc2VsZWN0aW9uICYmIHRyLnNlbGVjdGlvbi5tYXAoYmFjayksIFN0YXRlRWZmZWN0Lm1hcEVmZmVjdHModHIuZWZmZWN0cywgYmFjayksIHRyLmFubm90YXRpb25zLCB0ci5zY3JvbGxJbnRvVmlldyk7XHJcbiAgICB9XHJcbiAgICAvLyBUcmFuc2FjdGlvbiBmaWx0ZXJzXHJcbiAgICBsZXQgZmlsdGVycyA9IHN0YXRlLmZhY2V0KHRyYW5zYWN0aW9uRmlsdGVyKTtcclxuICAgIGZvciAobGV0IGkgPSBmaWx0ZXJzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XHJcbiAgICAgICAgbGV0IGZpbHRlcmVkID0gZmlsdGVyc1tpXSh0cik7XHJcbiAgICAgICAgaWYgKGZpbHRlcmVkIGluc3RhbmNlb2YgVHJhbnNhY3Rpb24pXHJcbiAgICAgICAgICAgIHRyID0gZmlsdGVyZWQ7XHJcbiAgICAgICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheShmaWx0ZXJlZCkgJiYgZmlsdGVyZWQubGVuZ3RoID09IDEgJiYgZmlsdGVyZWRbMF0gaW5zdGFuY2VvZiBUcmFuc2FjdGlvbilcclxuICAgICAgICAgICAgdHIgPSBmaWx0ZXJlZFswXTtcclxuICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHRyID0gcmVzb2x2ZVRyYW5zYWN0aW9uKHN0YXRlLCBhc0FycmF5KGZpbHRlcmVkKSwgZmFsc2UpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRyO1xyXG59XHJcbmZ1bmN0aW9uIGV4dGVuZFRyYW5zYWN0aW9uKHRyKSB7XHJcbiAgICBsZXQgc3RhdGUgPSB0ci5zdGFydFN0YXRlLCBleHRlbmRlcnMgPSBzdGF0ZS5mYWNldCh0cmFuc2FjdGlvbkV4dGVuZGVyKSwgc3BlYyA9IHRyO1xyXG4gICAgZm9yIChsZXQgaSA9IGV4dGVuZGVycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xyXG4gICAgICAgIGxldCBleHRlbnNpb24gPSBleHRlbmRlcnNbaV0odHIpO1xyXG4gICAgICAgIGlmIChleHRlbnNpb24gJiYgT2JqZWN0LmtleXMoZXh0ZW5zaW9uKS5sZW5ndGgpXHJcbiAgICAgICAgICAgIHNwZWMgPSBtZXJnZVRyYW5zYWN0aW9uKHNwZWMsIHJlc29sdmVUcmFuc2FjdGlvbklubmVyKHN0YXRlLCBleHRlbnNpb24sIHRyLmNoYW5nZXMubmV3TGVuZ3RoKSwgdHJ1ZSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gc3BlYyA9PSB0ciA/IHRyIDogVHJhbnNhY3Rpb24uY3JlYXRlKHN0YXRlLCB0ci5jaGFuZ2VzLCB0ci5zZWxlY3Rpb24sIHNwZWMuZWZmZWN0cywgc3BlYy5hbm5vdGF0aW9ucywgc3BlYy5zY3JvbGxJbnRvVmlldyk7XHJcbn1cclxuY29uc3Qgbm9uZSA9IFtdO1xyXG5mdW5jdGlvbiBhc0FycmF5KHZhbHVlKSB7XHJcbiAgICByZXR1cm4gdmFsdWUgPT0gbnVsbCA/IG5vbmUgOiBBcnJheS5pc0FycmF5KHZhbHVlKSA/IHZhbHVlIDogW3ZhbHVlXTtcclxufVxyXG5cclxuLyoqXHJcblRoZSBjYXRlZ29yaWVzIHByb2R1Y2VkIGJ5IGEgW2NoYXJhY3RlclxyXG5jYXRlZ29yaXplcl0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5FZGl0b3JTdGF0ZS5jaGFyQ2F0ZWdvcml6ZXIpLiBUaGVzZSBhcmUgdXNlZFxyXG5kbyB0aGluZ3MgbGlrZSBzZWxlY3RpbmcgYnkgd29yZC5cclxuKi9cclxudmFyIENoYXJDYXRlZ29yeSA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKENoYXJDYXRlZ29yeSkge1xyXG4gICAgLyoqXHJcbiAgICBXb3JkIGNoYXJhY3RlcnMuXHJcbiAgICAqL1xyXG4gICAgQ2hhckNhdGVnb3J5W0NoYXJDYXRlZ29yeVtcIldvcmRcIl0gPSAwXSA9IFwiV29yZFwiO1xyXG4gICAgLyoqXHJcbiAgICBXaGl0ZXNwYWNlLlxyXG4gICAgKi9cclxuICAgIENoYXJDYXRlZ29yeVtDaGFyQ2F0ZWdvcnlbXCJTcGFjZVwiXSA9IDFdID0gXCJTcGFjZVwiO1xyXG4gICAgLyoqXHJcbiAgICBBbnl0aGluZyBlbHNlLlxyXG4gICAgKi9cclxuICAgIENoYXJDYXRlZ29yeVtDaGFyQ2F0ZWdvcnlbXCJPdGhlclwiXSA9IDJdID0gXCJPdGhlclwiO1xyXG5yZXR1cm4gQ2hhckNhdGVnb3J5fSkoQ2hhckNhdGVnb3J5IHx8IChDaGFyQ2F0ZWdvcnkgPSB7fSkpO1xyXG5jb25zdCBub25BU0NJSVNpbmdsZUNhc2VXb3JkQ2hhciA9IC9bXFx1MDBkZlxcdTA1ODdcXHUwNTkwLVxcdTA1ZjRcXHUwNjAwLVxcdTA2ZmZcXHUzMDQwLVxcdTMwOWZcXHUzMGEwLVxcdTMwZmZcXHUzNDAwLVxcdTRkYjVcXHU0ZTAwLVxcdTlmY2NcXHVhYzAwLVxcdWQ3YWZdLztcclxubGV0IHdvcmRDaGFyO1xyXG50cnkge1xyXG4gICAgd29yZENoYXIgPSAvKkBfX1BVUkVfXyovbmV3IFJlZ0V4cChcIltcXFxccHtBbHBoYWJldGljfVxcXFxwe051bWJlcn1fXVwiLCBcInVcIik7XHJcbn1cclxuY2F0Y2ggKF8pIHsgfVxyXG5mdW5jdGlvbiBoYXNXb3JkQ2hhcihzdHIpIHtcclxuICAgIGlmICh3b3JkQ2hhcilcclxuICAgICAgICByZXR1cm4gd29yZENoYXIudGVzdChzdHIpO1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBsZXQgY2ggPSBzdHJbaV07XHJcbiAgICAgICAgaWYgKC9cXHcvLnRlc3QoY2gpIHx8IGNoID4gXCJcXHg4MFwiICYmIChjaC50b1VwcGVyQ2FzZSgpICE9IGNoLnRvTG93ZXJDYXNlKCkgfHwgbm9uQVNDSUlTaW5nbGVDYXNlV29yZENoYXIudGVzdChjaCkpKVxyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICAgIHJldHVybiBmYWxzZTtcclxufVxyXG5mdW5jdGlvbiBtYWtlQ2F0ZWdvcml6ZXIod29yZENoYXJzKSB7XHJcbiAgICByZXR1cm4gKGNoYXIpID0+IHtcclxuICAgICAgICBpZiAoIS9cXFMvLnRlc3QoY2hhcikpXHJcbiAgICAgICAgICAgIHJldHVybiBDaGFyQ2F0ZWdvcnkuU3BhY2U7XHJcbiAgICAgICAgaWYgKGhhc1dvcmRDaGFyKGNoYXIpKVxyXG4gICAgICAgICAgICByZXR1cm4gQ2hhckNhdGVnb3J5LldvcmQ7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB3b3JkQ2hhcnMubGVuZ3RoOyBpKyspXHJcbiAgICAgICAgICAgIGlmIChjaGFyLmluZGV4T2Yod29yZENoYXJzW2ldKSA+IC0xKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIENoYXJDYXRlZ29yeS5Xb3JkO1xyXG4gICAgICAgIHJldHVybiBDaGFyQ2F0ZWdvcnkuT3RoZXI7XHJcbiAgICB9O1xyXG59XHJcblxyXG4vKipcclxuVGhlIGVkaXRvciBzdGF0ZSBjbGFzcyBpcyBhIHBlcnNpc3RlbnQgKGltbXV0YWJsZSkgZGF0YSBzdHJ1Y3R1cmUuXHJcblRvIHVwZGF0ZSBhIHN0YXRlLCB5b3UgW2NyZWF0ZV0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5FZGl0b3JTdGF0ZS51cGRhdGUpIGFcclxuW3RyYW5zYWN0aW9uXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlRyYW5zYWN0aW9uKSwgd2hpY2ggcHJvZHVjZXMgYSBfbmV3XyBzdGF0ZVxyXG5pbnN0YW5jZSwgd2l0aG91dCBtb2RpZnlpbmcgdGhlIG9yaWdpbmFsIG9iamVjdC5cclxuXHJcbkFzIHN1Y2gsIF9uZXZlcl8gbXV0YXRlIHByb3BlcnRpZXMgb2YgYSBzdGF0ZSBkaXJlY3RseS4gVGhhdCdsbFxyXG5qdXN0IGJyZWFrIHRoaW5ncy5cclxuKi9cclxuY2xhc3MgRWRpdG9yU3RhdGUge1xyXG4gICAgY29uc3RydWN0b3IoXHJcbiAgICAvKipcclxuICAgIEBpbnRlcm5hbFxyXG4gICAgKi9cclxuICAgIGNvbmZpZywgXHJcbiAgICAvKipcclxuICAgIFRoZSBjdXJyZW50IGRvY3VtZW50LlxyXG4gICAgKi9cclxuICAgIGRvYywgXHJcbiAgICAvKipcclxuICAgIFRoZSBjdXJyZW50IHNlbGVjdGlvbi5cclxuICAgICovXHJcbiAgICBzZWxlY3Rpb24sIFxyXG4gICAgLyoqXHJcbiAgICBAaW50ZXJuYWxcclxuICAgICovXHJcbiAgICB2YWx1ZXMsIGNvbXB1dGVTbG90LCB0cikge1xyXG4gICAgICAgIHRoaXMuY29uZmlnID0gY29uZmlnO1xyXG4gICAgICAgIHRoaXMuZG9jID0gZG9jO1xyXG4gICAgICAgIHRoaXMuc2VsZWN0aW9uID0gc2VsZWN0aW9uO1xyXG4gICAgICAgIHRoaXMudmFsdWVzID0gdmFsdWVzO1xyXG4gICAgICAgIHRoaXMuc3RhdHVzID0gY29uZmlnLnN0YXR1c1RlbXBsYXRlLnNsaWNlKCk7XHJcbiAgICAgICAgdGhpcy5jb21wdXRlU2xvdCA9IGNvbXB1dGVTbG90O1xyXG4gICAgICAgIC8vIEZpbGwgaW4gdGhlIGNvbXB1dGVkIHN0YXRlIGltbWVkaWF0ZWx5LCBzbyB0aGF0IGZ1cnRoZXIgcXVlcmllc1xyXG4gICAgICAgIC8vIGZvciBpdCBtYWRlIGR1cmluZyB0aGUgdXBkYXRlIHJldHVybiB0aGlzIHN0YXRlXHJcbiAgICAgICAgaWYgKHRyKVxyXG4gICAgICAgICAgICB0ci5fc3RhdGUgPSB0aGlzO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5jb25maWcuZHluYW1pY1Nsb3RzLmxlbmd0aDsgaSsrKVxyXG4gICAgICAgICAgICBlbnN1cmVBZGRyKHRoaXMsIGkgPDwgMSk7XHJcbiAgICAgICAgdGhpcy5jb21wdXRlU2xvdCA9IG51bGw7XHJcbiAgICB9XHJcbiAgICBmaWVsZChmaWVsZCwgcmVxdWlyZSA9IHRydWUpIHtcclxuICAgICAgICBsZXQgYWRkciA9IHRoaXMuY29uZmlnLmFkZHJlc3NbZmllbGQuaWRdO1xyXG4gICAgICAgIGlmIChhZGRyID09IG51bGwpIHtcclxuICAgICAgICAgICAgaWYgKHJlcXVpcmUpXHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkZpZWxkIGlzIG5vdCBwcmVzZW50IGluIHRoaXMgc3RhdGVcIik7XHJcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVuc3VyZUFkZHIodGhpcywgYWRkcik7XHJcbiAgICAgICAgcmV0dXJuIGdldEFkZHIodGhpcywgYWRkcik7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgIENyZWF0ZSBhIFt0cmFuc2FjdGlvbl0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5UcmFuc2FjdGlvbikgdGhhdCB1cGRhdGVzIHRoaXNcclxuICAgIHN0YXRlLiBBbnkgbnVtYmVyIG9mIFt0cmFuc2FjdGlvbiBzcGVjc10oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5UcmFuc2FjdGlvblNwZWMpXHJcbiAgICBjYW4gYmUgcGFzc2VkLiBVbmxlc3NcclxuICAgIFtgc2VxdWVudGlhbGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuVHJhbnNhY3Rpb25TcGVjLnNlcXVlbnRpYWwpIGlzIHNldCwgdGhlXHJcbiAgICBbY2hhbmdlc10oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5UcmFuc2FjdGlvblNwZWMuY2hhbmdlcykgKGlmIGFueSkgb2YgZWFjaCBzcGVjXHJcbiAgICBhcmUgYXNzdW1lZCB0byBzdGFydCBpbiB0aGUgX2N1cnJlbnRfIGRvY3VtZW50IChub3QgdGhlIGRvY3VtZW50XHJcbiAgICBwcm9kdWNlZCBieSBwcmV2aW91cyBzcGVjcyksIGFuZCBpdHNcclxuICAgIFtzZWxlY3Rpb25dKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuVHJhbnNhY3Rpb25TcGVjLnNlbGVjdGlvbikgYW5kXHJcbiAgICBbZWZmZWN0c10oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5UcmFuc2FjdGlvblNwZWMuZWZmZWN0cykgYXJlIGFzc3VtZWQgdG8gcmVmZXJcclxuICAgIHRvIHRoZSBkb2N1bWVudCBjcmVhdGVkIGJ5IGl0cyBfb3duXyBjaGFuZ2VzLiBUaGUgcmVzdWx0aW5nXHJcbiAgICB0cmFuc2FjdGlvbiBjb250YWlucyB0aGUgY29tYmluZWQgZWZmZWN0IG9mIGFsbCB0aGUgZGlmZmVyZW50XHJcbiAgICBzcGVjcy4gRm9yIFtzZWxlY3Rpb25dKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuVHJhbnNhY3Rpb25TcGVjLnNlbGVjdGlvbiksIGxhdGVyXHJcbiAgICBzcGVjcyB0YWtlIHByZWNlZGVuY2Ugb3ZlciBlYXJsaWVyIG9uZXMuXHJcbiAgICAqL1xyXG4gICAgdXBkYXRlKC4uLnNwZWNzKSB7XHJcbiAgICAgICAgcmV0dXJuIHJlc29sdmVUcmFuc2FjdGlvbih0aGlzLCBzcGVjcywgdHJ1ZSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgIEBpbnRlcm5hbFxyXG4gICAgKi9cclxuICAgIGFwcGx5VHJhbnNhY3Rpb24odHIpIHtcclxuICAgICAgICBsZXQgY29uZiA9IHRoaXMuY29uZmlnLCB7IGJhc2UsIGNvbXBhcnRtZW50cyB9ID0gY29uZjtcclxuICAgICAgICBmb3IgKGxldCBlZmZlY3Qgb2YgdHIuZWZmZWN0cykge1xyXG4gICAgICAgICAgICBpZiAoZWZmZWN0LmlzKENvbXBhcnRtZW50LnJlY29uZmlndXJlKSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGNvbmYpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb21wYXJ0bWVudHMgPSBuZXcgTWFwO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbmYuY29tcGFydG1lbnRzLmZvckVhY2goKHZhbCwga2V5KSA9PiBjb21wYXJ0bWVudHMuc2V0KGtleSwgdmFsKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uZiA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjb21wYXJ0bWVudHMuc2V0KGVmZmVjdC52YWx1ZS5jb21wYXJ0bWVudCwgZWZmZWN0LnZhbHVlLmV4dGVuc2lvbik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoZWZmZWN0LmlzKFN0YXRlRWZmZWN0LnJlY29uZmlndXJlKSkge1xyXG4gICAgICAgICAgICAgICAgY29uZiA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICBiYXNlID0gZWZmZWN0LnZhbHVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGVmZmVjdC5pcyhTdGF0ZUVmZmVjdC5hcHBlbmRDb25maWcpKSB7XHJcbiAgICAgICAgICAgICAgICBjb25mID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIGJhc2UgPSBhc0FycmF5KGJhc2UpLmNvbmNhdChlZmZlY3QudmFsdWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCBzdGFydFZhbHVlcztcclxuICAgICAgICBpZiAoIWNvbmYpIHtcclxuICAgICAgICAgICAgY29uZiA9IENvbmZpZ3VyYXRpb24ucmVzb2x2ZShiYXNlLCBjb21wYXJ0bWVudHMsIHRoaXMpO1xyXG4gICAgICAgICAgICBsZXQgaW50ZXJtZWRpYXRlU3RhdGUgPSBuZXcgRWRpdG9yU3RhdGUoY29uZiwgdGhpcy5kb2MsIHRoaXMuc2VsZWN0aW9uLCBjb25mLmR5bmFtaWNTbG90cy5tYXAoKCkgPT4gbnVsbCksIChzdGF0ZSwgc2xvdCkgPT4gc2xvdC5yZWNvbmZpZ3VyZShzdGF0ZSwgdGhpcyksIG51bGwpO1xyXG4gICAgICAgICAgICBzdGFydFZhbHVlcyA9IGludGVybWVkaWF0ZVN0YXRlLnZhbHVlcztcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHN0YXJ0VmFsdWVzID0gdHIuc3RhcnRTdGF0ZS52YWx1ZXMuc2xpY2UoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbmV3IEVkaXRvclN0YXRlKGNvbmYsIHRyLm5ld0RvYywgdHIubmV3U2VsZWN0aW9uLCBzdGFydFZhbHVlcywgKHN0YXRlLCBzbG90KSA9PiBzbG90LnVwZGF0ZShzdGF0ZSwgdHIpLCB0cik7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgIENyZWF0ZSBhIFt0cmFuc2FjdGlvbiBzcGVjXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlRyYW5zYWN0aW9uU3BlYykgdGhhdFxyXG4gICAgcmVwbGFjZXMgZXZlcnkgc2VsZWN0aW9uIHJhbmdlIHdpdGggdGhlIGdpdmVuIGNvbnRlbnQuXHJcbiAgICAqL1xyXG4gICAgcmVwbGFjZVNlbGVjdGlvbih0ZXh0KSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiB0ZXh0ID09IFwic3RyaW5nXCIpXHJcbiAgICAgICAgICAgIHRleHQgPSB0aGlzLnRvVGV4dCh0ZXh0KTtcclxuICAgICAgICByZXR1cm4gdGhpcy5jaGFuZ2VCeVJhbmdlKHJhbmdlID0+ICh7IGNoYW5nZXM6IHsgZnJvbTogcmFuZ2UuZnJvbSwgdG86IHJhbmdlLnRvLCBpbnNlcnQ6IHRleHQgfSxcclxuICAgICAgICAgICAgcmFuZ2U6IEVkaXRvclNlbGVjdGlvbi5jdXJzb3IocmFuZ2UuZnJvbSArIHRleHQubGVuZ3RoKSB9KSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgIENyZWF0ZSBhIHNldCBvZiBjaGFuZ2VzIGFuZCBhIG5ldyBzZWxlY3Rpb24gYnkgcnVubmluZyB0aGUgZ2l2ZW5cclxuICAgIGZ1bmN0aW9uIGZvciBlYWNoIHJhbmdlIGluIHRoZSBhY3RpdmUgc2VsZWN0aW9uLiBUaGUgZnVuY3Rpb25cclxuICAgIGNhbiByZXR1cm4gYW4gb3B0aW9uYWwgc2V0IG9mIGNoYW5nZXMgKGluIHRoZSBjb29yZGluYXRlIHNwYWNlXHJcbiAgICBvZiB0aGUgc3RhcnQgZG9jdW1lbnQpLCBwbHVzIGFuIHVwZGF0ZWQgcmFuZ2UgKGluIHRoZSBjb29yZGluYXRlXHJcbiAgICBzcGFjZSBvZiB0aGUgZG9jdW1lbnQgcHJvZHVjZWQgYnkgdGhlIGNhbGwncyBvd24gY2hhbmdlcykuIFRoaXNcclxuICAgIG1ldGhvZCB3aWxsIG1lcmdlIGFsbCB0aGUgY2hhbmdlcyBhbmQgcmFuZ2VzIGludG8gYSBzaW5nbGVcclxuICAgIGNoYW5nZXNldCBhbmQgc2VsZWN0aW9uLCBhbmQgcmV0dXJuIGl0IGFzIGEgW3RyYW5zYWN0aW9uXHJcbiAgICBzcGVjXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlRyYW5zYWN0aW9uU3BlYyksIHdoaWNoIGNhbiBiZSBwYXNzZWQgdG9cclxuICAgIFtgdXBkYXRlYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5FZGl0b3JTdGF0ZS51cGRhdGUpLlxyXG4gICAgKi9cclxuICAgIGNoYW5nZUJ5UmFuZ2UoZikge1xyXG4gICAgICAgIGxldCBzZWwgPSB0aGlzLnNlbGVjdGlvbjtcclxuICAgICAgICBsZXQgcmVzdWx0MSA9IGYoc2VsLnJhbmdlc1swXSk7XHJcbiAgICAgICAgbGV0IGNoYW5nZXMgPSB0aGlzLmNoYW5nZXMocmVzdWx0MS5jaGFuZ2VzKSwgcmFuZ2VzID0gW3Jlc3VsdDEucmFuZ2VdO1xyXG4gICAgICAgIGxldCBlZmZlY3RzID0gYXNBcnJheShyZXN1bHQxLmVmZmVjdHMpO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgc2VsLnJhbmdlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBsZXQgcmVzdWx0ID0gZihzZWwucmFuZ2VzW2ldKTtcclxuICAgICAgICAgICAgbGV0IG5ld0NoYW5nZXMgPSB0aGlzLmNoYW5nZXMocmVzdWx0LmNoYW5nZXMpLCBuZXdNYXBwZWQgPSBuZXdDaGFuZ2VzLm1hcChjaGFuZ2VzKTtcclxuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBpOyBqKyspXHJcbiAgICAgICAgICAgICAgICByYW5nZXNbal0gPSByYW5nZXNbal0ubWFwKG5ld01hcHBlZCk7XHJcbiAgICAgICAgICAgIGxldCBtYXBCeSA9IGNoYW5nZXMubWFwRGVzYyhuZXdDaGFuZ2VzLCB0cnVlKTtcclxuICAgICAgICAgICAgcmFuZ2VzLnB1c2gocmVzdWx0LnJhbmdlLm1hcChtYXBCeSkpO1xyXG4gICAgICAgICAgICBjaGFuZ2VzID0gY2hhbmdlcy5jb21wb3NlKG5ld01hcHBlZCk7XHJcbiAgICAgICAgICAgIGVmZmVjdHMgPSBTdGF0ZUVmZmVjdC5tYXBFZmZlY3RzKGVmZmVjdHMsIG5ld01hcHBlZCkuY29uY2F0KFN0YXRlRWZmZWN0Lm1hcEVmZmVjdHMoYXNBcnJheShyZXN1bHQuZWZmZWN0cyksIG1hcEJ5KSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIGNoYW5nZXMsXHJcbiAgICAgICAgICAgIHNlbGVjdGlvbjogRWRpdG9yU2VsZWN0aW9uLmNyZWF0ZShyYW5nZXMsIHNlbC5tYWluSW5kZXgpLFxyXG4gICAgICAgICAgICBlZmZlY3RzXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgQ3JlYXRlIGEgW2NoYW5nZSBzZXRdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuQ2hhbmdlU2V0KSBmcm9tIHRoZSBnaXZlbiBjaGFuZ2VcclxuICAgIGRlc2NyaXB0aW9uLCB0YWtpbmcgdGhlIHN0YXRlJ3MgZG9jdW1lbnQgbGVuZ3RoIGFuZCBsaW5lXHJcbiAgICBzZXBhcmF0b3IgaW50byBhY2NvdW50LlxyXG4gICAgKi9cclxuICAgIGNoYW5nZXMoc3BlYyA9IFtdKSB7XHJcbiAgICAgICAgaWYgKHNwZWMgaW5zdGFuY2VvZiBDaGFuZ2VTZXQpXHJcbiAgICAgICAgICAgIHJldHVybiBzcGVjO1xyXG4gICAgICAgIHJldHVybiBDaGFuZ2VTZXQub2Yoc3BlYywgdGhpcy5kb2MubGVuZ3RoLCB0aGlzLmZhY2V0KEVkaXRvclN0YXRlLmxpbmVTZXBhcmF0b3IpKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgVXNpbmcgdGhlIHN0YXRlJ3MgW2xpbmVcclxuICAgIHNlcGFyYXRvcl0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5FZGl0b3JTdGF0ZV5saW5lU2VwYXJhdG9yKSwgY3JlYXRlIGFcclxuICAgIFtgVGV4dGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuVGV4dCkgaW5zdGFuY2UgZnJvbSB0aGUgZ2l2ZW4gc3RyaW5nLlxyXG4gICAgKi9cclxuICAgIHRvVGV4dChzdHJpbmcpIHtcclxuICAgICAgICByZXR1cm4gVGV4dC5vZihzdHJpbmcuc3BsaXQodGhpcy5mYWNldChFZGl0b3JTdGF0ZS5saW5lU2VwYXJhdG9yKSB8fCBEZWZhdWx0U3BsaXQpKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgUmV0dXJuIHRoZSBnaXZlbiByYW5nZSBvZiB0aGUgZG9jdW1lbnQgYXMgYSBzdHJpbmcuXHJcbiAgICAqL1xyXG4gICAgc2xpY2VEb2MoZnJvbSA9IDAsIHRvID0gdGhpcy5kb2MubGVuZ3RoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZG9jLnNsaWNlU3RyaW5nKGZyb20sIHRvLCB0aGlzLmxpbmVCcmVhayk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgIEdldCB0aGUgdmFsdWUgb2YgYSBzdGF0ZSBbZmFjZXRdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuRmFjZXQpLlxyXG4gICAgKi9cclxuICAgIGZhY2V0KGZhY2V0KSB7XHJcbiAgICAgICAgbGV0IGFkZHIgPSB0aGlzLmNvbmZpZy5hZGRyZXNzW2ZhY2V0LmlkXTtcclxuICAgICAgICBpZiAoYWRkciA9PSBudWxsKVxyXG4gICAgICAgICAgICByZXR1cm4gZmFjZXQuZGVmYXVsdDtcclxuICAgICAgICBlbnN1cmVBZGRyKHRoaXMsIGFkZHIpO1xyXG4gICAgICAgIHJldHVybiBnZXRBZGRyKHRoaXMsIGFkZHIpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICBDb252ZXJ0IHRoaXMgc3RhdGUgdG8gYSBKU09OLXNlcmlhbGl6YWJsZSBvYmplY3QuIFdoZW4gY3VzdG9tXHJcbiAgICBmaWVsZHMgc2hvdWxkIGJlIHNlcmlhbGl6ZWQsIHlvdSBjYW4gcGFzcyB0aGVtIGluIGFzIGFuIG9iamVjdFxyXG4gICAgbWFwcGluZyBwcm9wZXJ0eSBuYW1lcyAoaW4gdGhlIHJlc3VsdGluZyBvYmplY3QsIHdoaWNoIHNob3VsZFxyXG4gICAgbm90IHVzZSBgZG9jYCBvciBgc2VsZWN0aW9uYCkgdG8gZmllbGRzLlxyXG4gICAgKi9cclxuICAgIHRvSlNPTihmaWVsZHMpIHtcclxuICAgICAgICBsZXQgcmVzdWx0ID0ge1xyXG4gICAgICAgICAgICBkb2M6IHRoaXMuc2xpY2VEb2MoKSxcclxuICAgICAgICAgICAgc2VsZWN0aW9uOiB0aGlzLnNlbGVjdGlvbi50b0pTT04oKVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgaWYgKGZpZWxkcylcclxuICAgICAgICAgICAgZm9yIChsZXQgcHJvcCBpbiBmaWVsZHMpIHtcclxuICAgICAgICAgICAgICAgIGxldCB2YWx1ZSA9IGZpZWxkc1twcm9wXTtcclxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIFN0YXRlRmllbGQgJiYgdGhpcy5jb25maWcuYWRkcmVzc1t2YWx1ZS5pZF0gIT0gbnVsbClcclxuICAgICAgICAgICAgICAgICAgICByZXN1bHRbcHJvcF0gPSB2YWx1ZS5zcGVjLnRvSlNPTih0aGlzLmZpZWxkKGZpZWxkc1twcm9wXSksIHRoaXMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgRGVzZXJpYWxpemUgYSBzdGF0ZSBmcm9tIGl0cyBKU09OIHJlcHJlc2VudGF0aW9uLiBXaGVuIGN1c3RvbVxyXG4gICAgZmllbGRzIHNob3VsZCBiZSBkZXNlcmlhbGl6ZWQsIHBhc3MgdGhlIHNhbWUgb2JqZWN0IHlvdSBwYXNzZWRcclxuICAgIHRvIFtgdG9KU09OYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5FZGl0b3JTdGF0ZS50b0pTT04pIHdoZW4gc2VyaWFsaXppbmcgYXNcclxuICAgIHRoaXJkIGFyZ3VtZW50LlxyXG4gICAgKi9cclxuICAgIHN0YXRpYyBmcm9tSlNPTihqc29uLCBjb25maWcgPSB7fSwgZmllbGRzKSB7XHJcbiAgICAgICAgaWYgKCFqc29uIHx8IHR5cGVvZiBqc29uLmRvYyAhPSBcInN0cmluZ1wiKVxyXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgSlNPTiByZXByZXNlbnRhdGlvbiBmb3IgRWRpdG9yU3RhdGVcIik7XHJcbiAgICAgICAgbGV0IGZpZWxkSW5pdCA9IFtdO1xyXG4gICAgICAgIGlmIChmaWVsZHMpXHJcbiAgICAgICAgICAgIGZvciAobGV0IHByb3AgaW4gZmllbGRzKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGpzb24sIHByb3ApKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IGZpZWxkID0gZmllbGRzW3Byb3BdLCB2YWx1ZSA9IGpzb25bcHJvcF07XHJcbiAgICAgICAgICAgICAgICAgICAgZmllbGRJbml0LnB1c2goZmllbGQuaW5pdChzdGF0ZSA9PiBmaWVsZC5zcGVjLmZyb21KU09OKHZhbHVlLCBzdGF0ZSkpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBFZGl0b3JTdGF0ZS5jcmVhdGUoe1xyXG4gICAgICAgICAgICBkb2M6IGpzb24uZG9jLFxyXG4gICAgICAgICAgICBzZWxlY3Rpb246IEVkaXRvclNlbGVjdGlvbi5mcm9tSlNPTihqc29uLnNlbGVjdGlvbiksXHJcbiAgICAgICAgICAgIGV4dGVuc2lvbnM6IGNvbmZpZy5leHRlbnNpb25zID8gZmllbGRJbml0LmNvbmNhdChbY29uZmlnLmV4dGVuc2lvbnNdKSA6IGZpZWxkSW5pdFxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICBDcmVhdGUgYSBuZXcgc3RhdGUuIFlvdSdsbCB1c3VhbGx5IG9ubHkgbmVlZCB0aGlzIHdoZW5cclxuICAgIGluaXRpYWxpemluZyBhbiBlZGl0b3LigJR1cGRhdGVkIHN0YXRlcyBhcmUgY3JlYXRlZCBieSBhcHBseWluZ1xyXG4gICAgdHJhbnNhY3Rpb25zLlxyXG4gICAgKi9cclxuICAgIHN0YXRpYyBjcmVhdGUoY29uZmlnID0ge30pIHtcclxuICAgICAgICBsZXQgY29uZmlndXJhdGlvbiA9IENvbmZpZ3VyYXRpb24ucmVzb2x2ZShjb25maWcuZXh0ZW5zaW9ucyB8fCBbXSwgbmV3IE1hcCk7XHJcbiAgICAgICAgbGV0IGRvYyA9IGNvbmZpZy5kb2MgaW5zdGFuY2VvZiBUZXh0ID8gY29uZmlnLmRvY1xyXG4gICAgICAgICAgICA6IFRleHQub2YoKGNvbmZpZy5kb2MgfHwgXCJcIikuc3BsaXQoY29uZmlndXJhdGlvbi5zdGF0aWNGYWNldChFZGl0b3JTdGF0ZS5saW5lU2VwYXJhdG9yKSB8fCBEZWZhdWx0U3BsaXQpKTtcclxuICAgICAgICBsZXQgc2VsZWN0aW9uID0gIWNvbmZpZy5zZWxlY3Rpb24gPyBFZGl0b3JTZWxlY3Rpb24uc2luZ2xlKDApXHJcbiAgICAgICAgICAgIDogY29uZmlnLnNlbGVjdGlvbiBpbnN0YW5jZW9mIEVkaXRvclNlbGVjdGlvbiA/IGNvbmZpZy5zZWxlY3Rpb25cclxuICAgICAgICAgICAgICAgIDogRWRpdG9yU2VsZWN0aW9uLnNpbmdsZShjb25maWcuc2VsZWN0aW9uLmFuY2hvciwgY29uZmlnLnNlbGVjdGlvbi5oZWFkKTtcclxuICAgICAgICBjaGVja1NlbGVjdGlvbihzZWxlY3Rpb24sIGRvYy5sZW5ndGgpO1xyXG4gICAgICAgIGlmICghY29uZmlndXJhdGlvbi5zdGF0aWNGYWNldChhbGxvd011bHRpcGxlU2VsZWN0aW9ucykpXHJcbiAgICAgICAgICAgIHNlbGVjdGlvbiA9IHNlbGVjdGlvbi5hc1NpbmdsZSgpO1xyXG4gICAgICAgIHJldHVybiBuZXcgRWRpdG9yU3RhdGUoY29uZmlndXJhdGlvbiwgZG9jLCBzZWxlY3Rpb24sIGNvbmZpZ3VyYXRpb24uZHluYW1pY1Nsb3RzLm1hcCgoKSA9PiBudWxsKSwgKHN0YXRlLCBzbG90KSA9PiBzbG90LmNyZWF0ZShzdGF0ZSksIG51bGwpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICBUaGUgc2l6ZSAoaW4gY29sdW1ucykgb2YgYSB0YWIgaW4gdGhlIGRvY3VtZW50LCBkZXRlcm1pbmVkIGJ5XHJcbiAgICB0aGUgW2B0YWJTaXplYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5FZGl0b3JTdGF0ZV50YWJTaXplKSBmYWNldC5cclxuICAgICovXHJcbiAgICBnZXQgdGFiU2l6ZSgpIHsgcmV0dXJuIHRoaXMuZmFjZXQoRWRpdG9yU3RhdGUudGFiU2l6ZSk7IH1cclxuICAgIC8qKlxyXG4gICAgR2V0IHRoZSBwcm9wZXIgW2xpbmUtYnJlYWtdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuRWRpdG9yU3RhdGVebGluZVNlcGFyYXRvcilcclxuICAgIHN0cmluZyBmb3IgdGhpcyBzdGF0ZS5cclxuICAgICovXHJcbiAgICBnZXQgbGluZUJyZWFrKCkgeyByZXR1cm4gdGhpcy5mYWNldChFZGl0b3JTdGF0ZS5saW5lU2VwYXJhdG9yKSB8fCBcIlxcblwiOyB9XHJcbiAgICAvKipcclxuICAgIFJldHVybnMgdHJ1ZSB3aGVuIHRoZSBlZGl0b3IgaXNcclxuICAgIFtjb25maWd1cmVkXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkVkaXRvclN0YXRlXnJlYWRPbmx5KSB0byBiZSByZWFkLW9ubHkuXHJcbiAgICAqL1xyXG4gICAgZ2V0IHJlYWRPbmx5KCkgeyByZXR1cm4gdGhpcy5mYWNldChyZWFkT25seSk7IH1cclxuICAgIC8qKlxyXG4gICAgTG9vayB1cCBhIHRyYW5zbGF0aW9uIGZvciB0aGUgZ2l2ZW4gcGhyYXNlICh2aWEgdGhlXHJcbiAgICBbYHBocmFzZXNgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkVkaXRvclN0YXRlXnBocmFzZXMpIGZhY2V0KSwgb3IgcmV0dXJuIHRoZVxyXG4gICAgb3JpZ2luYWwgc3RyaW5nIGlmIG5vIHRyYW5zbGF0aW9uIGlzIGZvdW5kLlxyXG4gICAgXHJcbiAgICBJZiBhZGRpdGlvbmFsIGFyZ3VtZW50cyBhcmUgcGFzc2VkLCB0aGV5IHdpbGwgYmUgaW5zZXJ0ZWQgaW5cclxuICAgIHBsYWNlIG9mIG1hcmtlcnMgbGlrZSBgJDFgIChmb3IgdGhlIGZpcnN0IHZhbHVlKSBhbmQgYCQyYCwgZXRjLlxyXG4gICAgQSBzaW5nbGUgYCRgIGlzIGVxdWl2YWxlbnQgdG8gYCQxYCwgYW5kIGAkJGAgd2lsbCBwcm9kdWNlIGFcclxuICAgIGxpdGVyYWwgZG9sbGFyIHNpZ24uXHJcbiAgICAqL1xyXG4gICAgcGhyYXNlKHBocmFzZSwgLi4uaW5zZXJ0KSB7XHJcbiAgICAgICAgZm9yIChsZXQgbWFwIG9mIHRoaXMuZmFjZXQoRWRpdG9yU3RhdGUucGhyYXNlcykpXHJcbiAgICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobWFwLCBwaHJhc2UpKSB7XHJcbiAgICAgICAgICAgICAgICBwaHJhc2UgPSBtYXBbcGhyYXNlXTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgaWYgKGluc2VydC5sZW5ndGgpXHJcbiAgICAgICAgICAgIHBocmFzZSA9IHBocmFzZS5yZXBsYWNlKC9cXCQoXFwkfFxcZCopL2csIChtLCBpKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAoaSA9PSBcIiRcIilcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCIkXCI7XHJcbiAgICAgICAgICAgICAgICBsZXQgbiA9ICsoaSB8fCAxKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiAhbiB8fCBuID4gaW5zZXJ0Lmxlbmd0aCA/IG0gOiBpbnNlcnRbbiAtIDFdO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gcGhyYXNlO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICBGaW5kIHRoZSB2YWx1ZXMgZm9yIGEgZ2l2ZW4gbGFuZ3VhZ2UgZGF0YSBmaWVsZCwgcHJvdmlkZWQgYnkgdGhlXHJcbiAgICB0aGUgW2BsYW5ndWFnZURhdGFgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkVkaXRvclN0YXRlXmxhbmd1YWdlRGF0YSkgZmFjZXQuXHJcbiAgICBcclxuICAgIEV4YW1wbGVzIG9mIGxhbmd1YWdlIGRhdGEgZmllbGRzIGFyZS4uLlxyXG4gICAgXHJcbiAgICAtIFtgXCJjb21tZW50VG9rZW5zXCJgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLkNvbW1lbnRUb2tlbnMpIGZvciBzcGVjaWZ5aW5nXHJcbiAgICAgIGNvbW1lbnQgc3ludGF4LlxyXG4gICAgLSBbYFwiYXV0b2NvbXBsZXRlXCJgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2F1dG9jb21wbGV0ZS5hdXRvY29tcGxldGlvbl5jb25maWcub3ZlcnJpZGUpXHJcbiAgICAgIGZvciBwcm92aWRpbmcgbGFuZ3VhZ2Utc3BlY2lmaWMgY29tcGxldGlvbiBzb3VyY2VzLlxyXG4gICAgLSBbYFwid29yZENoYXJzXCJgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkVkaXRvclN0YXRlLmNoYXJDYXRlZ29yaXplcikgZm9yIGFkZGluZ1xyXG4gICAgICBjaGFyYWN0ZXJzIHRoYXQgc2hvdWxkIGJlIGNvbnNpZGVyZWQgcGFydCBvZiB3b3JkcyBpbiB0aGlzXHJcbiAgICAgIGxhbmd1YWdlLlxyXG4gICAgLSBbYFwiY2xvc2VCcmFja2V0c1wiYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNhdXRvY29tcGxldGUuQ2xvc2VCcmFja2V0Q29uZmlnKSBjb250cm9sc1xyXG4gICAgICBicmFja2V0IGNsb3NpbmcgYmVoYXZpb3IuXHJcbiAgICAqL1xyXG4gICAgbGFuZ3VhZ2VEYXRhQXQobmFtZSwgcG9zLCBzaWRlID0gLTEpIHtcclxuICAgICAgICBsZXQgdmFsdWVzID0gW107XHJcbiAgICAgICAgZm9yIChsZXQgcHJvdmlkZXIgb2YgdGhpcy5mYWNldChsYW5ndWFnZURhdGEpKSB7XHJcbiAgICAgICAgICAgIGZvciAobGV0IHJlc3VsdCBvZiBwcm92aWRlcih0aGlzLCBwb3MsIHNpZGUpKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHJlc3VsdCwgbmFtZSkpXHJcbiAgICAgICAgICAgICAgICAgICAgdmFsdWVzLnB1c2gocmVzdWx0W25hbWVdKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdmFsdWVzO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICBSZXR1cm4gYSBmdW5jdGlvbiB0aGF0IGNhbiBjYXRlZ29yaXplIHN0cmluZ3MgKGV4cGVjdGVkIHRvXHJcbiAgICByZXByZXNlbnQgYSBzaW5nbGUgW2dyYXBoZW1lIGNsdXN0ZXJdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuZmluZENsdXN0ZXJCcmVhaykpXHJcbiAgICBpbnRvIG9uZSBvZjpcclxuICAgIFxyXG4gICAgIC0gV29yZCAoY29udGFpbnMgYW4gYWxwaGFudW1lcmljIGNoYXJhY3RlciBvciBhIGNoYXJhY3RlclxyXG4gICAgICAgZXhwbGljaXRseSBsaXN0ZWQgaW4gdGhlIGxvY2FsIGxhbmd1YWdlJ3MgYFwid29yZENoYXJzXCJgXHJcbiAgICAgICBsYW5ndWFnZSBkYXRhLCB3aGljaCBzaG91bGQgYmUgYSBzdHJpbmcpXHJcbiAgICAgLSBTcGFjZSAoY29udGFpbnMgb25seSB3aGl0ZXNwYWNlKVxyXG4gICAgIC0gT3RoZXIgKGFueXRoaW5nIGVsc2UpXHJcbiAgICAqL1xyXG4gICAgY2hhckNhdGVnb3JpemVyKGF0KSB7XHJcbiAgICAgICAgcmV0dXJuIG1ha2VDYXRlZ29yaXplcih0aGlzLmxhbmd1YWdlRGF0YUF0KFwid29yZENoYXJzXCIsIGF0KS5qb2luKFwiXCIpKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgRmluZCB0aGUgd29yZCBhdCB0aGUgZ2l2ZW4gcG9zaXRpb24sIG1lYW5pbmcgdGhlIHJhbmdlXHJcbiAgICBjb250YWluaW5nIGFsbCBbd29yZF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5DaGFyQ2F0ZWdvcnkuV29yZCkgY2hhcmFjdGVyc1xyXG4gICAgYXJvdW5kIGl0LiBJZiBubyB3b3JkIGNoYXJhY3RlcnMgYXJlIGFkamFjZW50IHRvIHRoZSBwb3NpdGlvbixcclxuICAgIHRoaXMgcmV0dXJucyBudWxsLlxyXG4gICAgKi9cclxuICAgIHdvcmRBdChwb3MpIHtcclxuICAgICAgICBsZXQgeyB0ZXh0LCBmcm9tLCBsZW5ndGggfSA9IHRoaXMuZG9jLmxpbmVBdChwb3MpO1xyXG4gICAgICAgIGxldCBjYXQgPSB0aGlzLmNoYXJDYXRlZ29yaXplcihwb3MpO1xyXG4gICAgICAgIGxldCBzdGFydCA9IHBvcyAtIGZyb20sIGVuZCA9IHBvcyAtIGZyb207XHJcbiAgICAgICAgd2hpbGUgKHN0YXJ0ID4gMCkge1xyXG4gICAgICAgICAgICBsZXQgcHJldiA9IGZpbmRDbHVzdGVyQnJlYWsodGV4dCwgc3RhcnQsIGZhbHNlKTtcclxuICAgICAgICAgICAgaWYgKGNhdCh0ZXh0LnNsaWNlKHByZXYsIHN0YXJ0KSkgIT0gQ2hhckNhdGVnb3J5LldvcmQpXHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgc3RhcnQgPSBwcmV2O1xyXG4gICAgICAgIH1cclxuICAgICAgICB3aGlsZSAoZW5kIDwgbGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIGxldCBuZXh0ID0gZmluZENsdXN0ZXJCcmVhayh0ZXh0LCBlbmQpO1xyXG4gICAgICAgICAgICBpZiAoY2F0KHRleHQuc2xpY2UoZW5kLCBuZXh0KSkgIT0gQ2hhckNhdGVnb3J5LldvcmQpXHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgZW5kID0gbmV4dDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHN0YXJ0ID09IGVuZCA/IG51bGwgOiBFZGl0b3JTZWxlY3Rpb24ucmFuZ2Uoc3RhcnQgKyBmcm9tLCBlbmQgKyBmcm9tKTtcclxuICAgIH1cclxufVxyXG4vKipcclxuQSBmYWNldCB0aGF0LCB3aGVuIGVuYWJsZWQsIGNhdXNlcyB0aGUgZWRpdG9yIHRvIGFsbG93IG11bHRpcGxlXHJcbnJhbmdlcyB0byBiZSBzZWxlY3RlZC4gQmUgY2FyZWZ1bCB0aG91Z2gsIGJlY2F1c2UgYnkgZGVmYXVsdCB0aGVcclxuZWRpdG9yIHJlbGllcyBvbiB0aGUgbmF0aXZlIERPTSBzZWxlY3Rpb24sIHdoaWNoIGNhbm5vdCBoYW5kbGVcclxubXVsdGlwbGUgc2VsZWN0aW9ucy4gQW4gZXh0ZW5zaW9uIGxpa2VcclxuW2BkcmF3U2VsZWN0aW9uYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LmRyYXdTZWxlY3Rpb24pIGNhbiBiZSB1c2VkIHRvIG1ha2Vcclxuc2Vjb25kYXJ5IHNlbGVjdGlvbnMgdmlzaWJsZSB0byB0aGUgdXNlci5cclxuKi9cclxuRWRpdG9yU3RhdGUuYWxsb3dNdWx0aXBsZVNlbGVjdGlvbnMgPSBhbGxvd011bHRpcGxlU2VsZWN0aW9ucztcclxuLyoqXHJcbkNvbmZpZ3VyZXMgdGhlIHRhYiBzaXplIHRvIHVzZSBpbiB0aGlzIHN0YXRlLiBUaGUgZmlyc3RcclxuKGhpZ2hlc3QtcHJlY2VkZW5jZSkgdmFsdWUgb2YgdGhlIGZhY2V0IGlzIHVzZWQuIElmIG5vIHZhbHVlIGlzXHJcbmdpdmVuLCB0aGlzIGRlZmF1bHRzIHRvIDQuXHJcbiovXHJcbkVkaXRvclN0YXRlLnRhYlNpemUgPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKHtcclxuICAgIGNvbWJpbmU6IHZhbHVlcyA9PiB2YWx1ZXMubGVuZ3RoID8gdmFsdWVzWzBdIDogNFxyXG59KTtcclxuLyoqXHJcblRoZSBsaW5lIHNlcGFyYXRvciB0byB1c2UuIEJ5IGRlZmF1bHQsIGFueSBvZiBgXCJcXG5cImAsIGBcIlxcclxcblwiYFxyXG5hbmQgYFwiXFxyXCJgIGlzIHRyZWF0ZWQgYXMgYSBzZXBhcmF0b3Igd2hlbiBzcGxpdHRpbmcgbGluZXMsIGFuZFxyXG5saW5lcyBhcmUgam9pbmVkIHdpdGggYFwiXFxuXCJgLlxyXG5cclxuV2hlbiB5b3UgY29uZmlndXJlIGEgdmFsdWUgaGVyZSwgb25seSB0aGF0IHByZWNpc2Ugc2VwYXJhdG9yXHJcbndpbGwgYmUgdXNlZCwgYWxsb3dpbmcgeW91IHRvIHJvdW5kLXRyaXAgZG9jdW1lbnRzIHRocm91Z2ggdGhlXHJcbmVkaXRvciB3aXRob3V0IG5vcm1hbGl6aW5nIGxpbmUgc2VwYXJhdG9ycy5cclxuKi9cclxuRWRpdG9yU3RhdGUubGluZVNlcGFyYXRvciA9IGxpbmVTZXBhcmF0b3I7XHJcbi8qKlxyXG5UaGlzIGZhY2V0IGNvbnRyb2xzIHRoZSB2YWx1ZSBvZiB0aGVcclxuW2ByZWFkT25seWBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuRWRpdG9yU3RhdGUucmVhZE9ubHkpIGdldHRlciwgd2hpY2ggaXNcclxuY29uc3VsdGVkIGJ5IGNvbW1hbmRzIGFuZCBleHRlbnNpb25zIHRoYXQgaW1wbGVtZW50IGVkaXRpbmdcclxuZnVuY3Rpb25hbGl0eSB0byBkZXRlcm1pbmUgd2hldGhlciB0aGV5IHNob3VsZCBhcHBseS4gSXRcclxuZGVmYXVsdHMgdG8gZmFsc2UsIGJ1dCB3aGVuIGl0cyBoaWdoZXN0LXByZWNlZGVuY2UgdmFsdWUgaXNcclxuYHRydWVgLCBzdWNoIGZ1bmN0aW9uYWxpdHkgZGlzYWJsZXMgaXRzZWxmLlxyXG5cclxuTm90IHRvIGJlIGNvbmZ1c2VkIHdpdGhcclxuW2BFZGl0b3JWaWV3LmVkaXRhYmxlYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LkVkaXRvclZpZXdeZWRpdGFibGUpLCB3aGljaFxyXG5jb250cm9scyB3aGV0aGVyIHRoZSBlZGl0b3IncyBET00gaXMgc2V0IHRvIGJlIGVkaXRhYmxlIChhbmRcclxudGh1cyBmb2N1c2FibGUpLlxyXG4qL1xyXG5FZGl0b3JTdGF0ZS5yZWFkT25seSA9IHJlYWRPbmx5O1xyXG4vKipcclxuUmVnaXN0ZXJzIHRyYW5zbGF0aW9uIHBocmFzZXMuIFRoZVxyXG5bYHBocmFzZWBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuRWRpdG9yU3RhdGUucGhyYXNlKSBtZXRob2Qgd2lsbCBsb29rIHRocm91Z2hcclxuYWxsIG9iamVjdHMgcmVnaXN0ZXJlZCB3aXRoIHRoaXMgZmFjZXQgdG8gZmluZCB0cmFuc2xhdGlvbnMgZm9yXHJcbml0cyBhcmd1bWVudC5cclxuKi9cclxuRWRpdG9yU3RhdGUucGhyYXNlcyA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoe1xyXG4gICAgY29tcGFyZShhLCBiKSB7XHJcbiAgICAgICAgbGV0IGtBID0gT2JqZWN0LmtleXMoYSksIGtCID0gT2JqZWN0LmtleXMoYik7XHJcbiAgICAgICAgcmV0dXJuIGtBLmxlbmd0aCA9PSBrQi5sZW5ndGggJiYga0EuZXZlcnkoayA9PiBhW2tdID09IGJba10pO1xyXG4gICAgfVxyXG59KTtcclxuLyoqXHJcbkEgZmFjZXQgdXNlZCB0byByZWdpc3RlciBbbGFuZ3VhZ2VcclxuZGF0YV0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5FZGl0b3JTdGF0ZS5sYW5ndWFnZURhdGFBdCkgcHJvdmlkZXJzLlxyXG4qL1xyXG5FZGl0b3JTdGF0ZS5sYW5ndWFnZURhdGEgPSBsYW5ndWFnZURhdGE7XHJcbi8qKlxyXG5GYWNldCB1c2VkIHRvIHJlZ2lzdGVyIGNoYW5nZSBmaWx0ZXJzLCB3aGljaCBhcmUgY2FsbGVkIGZvciBlYWNoXHJcbnRyYW5zYWN0aW9uICh1bmxlc3MgZXhwbGljaXRseVxyXG5bZGlzYWJsZWRdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuVHJhbnNhY3Rpb25TcGVjLmZpbHRlcikpLCBhbmQgY2FuIHN1cHByZXNzXHJcbnBhcnQgb2YgdGhlIHRyYW5zYWN0aW9uJ3MgY2hhbmdlcy5cclxuXHJcblN1Y2ggYSBmdW5jdGlvbiBjYW4gcmV0dXJuIGB0cnVlYCB0byBpbmRpY2F0ZSB0aGF0IGl0IGRvZXNuJ3Rcclxud2FudCB0byBkbyBhbnl0aGluZywgYGZhbHNlYCB0byBjb21wbGV0ZWx5IHN0b3AgdGhlIGNoYW5nZXMgaW5cclxudGhlIHRyYW5zYWN0aW9uLCBvciBhIHNldCBvZiByYW5nZXMgaW4gd2hpY2ggY2hhbmdlcyBzaG91bGQgYmVcclxuc3VwcHJlc3NlZC4gU3VjaCByYW5nZXMgYXJlIHJlcHJlc2VudGVkIGFzIGFuIGFycmF5IG9mIG51bWJlcnMsXHJcbndpdGggZWFjaCBwYWlyIG9mIHR3byBudW1iZXJzIGluZGljYXRpbmcgdGhlIHN0YXJ0IGFuZCBlbmQgb2YgYVxyXG5yYW5nZS4gU28gZm9yIGV4YW1wbGUgYFsxMCwgMjAsIDEwMCwgMTEwXWAgc3VwcHJlc3NlcyBjaGFuZ2VzXHJcbmJldHdlZW4gMTAgYW5kIDIwLCBhbmQgYmV0d2VlbiAxMDAgYW5kIDExMC5cclxuKi9cclxuRWRpdG9yU3RhdGUuY2hhbmdlRmlsdGVyID0gY2hhbmdlRmlsdGVyO1xyXG4vKipcclxuRmFjZXQgdXNlZCB0byByZWdpc3RlciBhIGhvb2sgdGhhdCBnZXRzIGEgY2hhbmNlIHRvIHVwZGF0ZSBvclxyXG5yZXBsYWNlIHRyYW5zYWN0aW9uIHNwZWNzIGJlZm9yZSB0aGV5IGFyZSBhcHBsaWVkLiBUaGlzIHdpbGxcclxub25seSBiZSBhcHBsaWVkIGZvciB0cmFuc2FjdGlvbnMgdGhhdCBkb24ndCBoYXZlXHJcbltgZmlsdGVyYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5UcmFuc2FjdGlvblNwZWMuZmlsdGVyKSBzZXQgdG8gYGZhbHNlYC4gWW91XHJcbmNhbiBlaXRoZXIgcmV0dXJuIGEgc2luZ2xlIHRyYW5zYWN0aW9uIHNwZWMgKHBvc3NpYmx5IHRoZSBpbnB1dFxyXG50cmFuc2FjdGlvbiksIG9yIGFuIGFycmF5IG9mIHNwZWNzICh3aGljaCB3aWxsIGJlIGNvbWJpbmVkIGluXHJcbnRoZSBzYW1lIHdheSBhcyB0aGUgYXJndW1lbnRzIHRvXHJcbltgRWRpdG9yU3RhdGUudXBkYXRlYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5FZGl0b3JTdGF0ZS51cGRhdGUpKS5cclxuXHJcbldoZW4gcG9zc2libGUsIGl0IGlzIHJlY29tbWVuZGVkIHRvIGF2b2lkIGFjY2Vzc2luZ1xyXG5bYFRyYW5zYWN0aW9uLnN0YXRlYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5UcmFuc2FjdGlvbi5zdGF0ZSkgaW4gYSBmaWx0ZXIsXHJcbnNpbmNlIGl0IHdpbGwgZm9yY2UgY3JlYXRpb24gb2YgYSBzdGF0ZSB0aGF0IHdpbGwgdGhlbiBiZVxyXG5kaXNjYXJkZWQgYWdhaW4sIGlmIHRoZSB0cmFuc2FjdGlvbiBpcyBhY3R1YWxseSBmaWx0ZXJlZC5cclxuXHJcbihUaGlzIGZ1bmN0aW9uYWxpdHkgc2hvdWxkIGJlIHVzZWQgd2l0aCBjYXJlLiBJbmRpc2NyaW1pbmF0ZWx5XHJcbm1vZGlmeWluZyB0cmFuc2FjdGlvbiBpcyBsaWtlbHkgdG8gYnJlYWsgc29tZXRoaW5nIG9yIGRlZ3JhZGVcclxudGhlIHVzZXIgZXhwZXJpZW5jZS4pXHJcbiovXHJcbkVkaXRvclN0YXRlLnRyYW5zYWN0aW9uRmlsdGVyID0gdHJhbnNhY3Rpb25GaWx0ZXI7XHJcbi8qKlxyXG5UaGlzIGlzIGEgbW9yZSBsaW1pdGVkIGZvcm0gb2ZcclxuW2B0cmFuc2FjdGlvbkZpbHRlcmBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuRWRpdG9yU3RhdGVedHJhbnNhY3Rpb25GaWx0ZXIpLFxyXG53aGljaCBjYW4gb25seSBhZGRcclxuW2Fubm90YXRpb25zXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlRyYW5zYWN0aW9uU3BlYy5hbm5vdGF0aW9ucykgYW5kXHJcbltlZmZlY3RzXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlRyYW5zYWN0aW9uU3BlYy5lZmZlY3RzKS4gX0J1dF8sIHRoaXMgdHlwZVxyXG5vZiBmaWx0ZXIgcnVucyBldmVuIGlmIHRoZSB0cmFuc2FjdGlvbiBoYXMgZGlzYWJsZWQgcmVndWxhclxyXG5bZmlsdGVyaW5nXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlRyYW5zYWN0aW9uU3BlYy5maWx0ZXIpLCBtYWtpbmcgaXQgc3VpdGFibGVcclxuZm9yIGVmZmVjdHMgdGhhdCBkb24ndCBuZWVkIHRvIHRvdWNoIHRoZSBjaGFuZ2VzIG9yIHNlbGVjdGlvbixcclxuYnV0IGRvIHdhbnQgdG8gcHJvY2VzcyBldmVyeSB0cmFuc2FjdGlvbi5cclxuXHJcbkV4dGVuZGVycyBydW4gX2FmdGVyXyBmaWx0ZXJzLCB3aGVuIGJvdGggYXJlIHByZXNlbnQuXHJcbiovXHJcbkVkaXRvclN0YXRlLnRyYW5zYWN0aW9uRXh0ZW5kZXIgPSB0cmFuc2FjdGlvbkV4dGVuZGVyO1xyXG5Db21wYXJ0bWVudC5yZWNvbmZpZ3VyZSA9IC8qQF9fUFVSRV9fKi9TdGF0ZUVmZmVjdC5kZWZpbmUoKTtcclxuXHJcbi8qKlxyXG5VdGlsaXR5IGZ1bmN0aW9uIGZvciBjb21iaW5pbmcgYmVoYXZpb3JzIHRvIGZpbGwgaW4gYSBjb25maWdcclxub2JqZWN0IGZyb20gYW4gYXJyYXkgb2YgcHJvdmlkZWQgY29uZmlncy4gYGRlZmF1bHRzYCBzaG91bGQgaG9sZFxyXG5kZWZhdWx0IHZhbHVlcyBmb3IgYWxsIG9wdGlvbmFsIGZpZWxkcyBpbiBgQ29uZmlnYC5cclxuXHJcblRoZSBmdW5jdGlvbiB3aWxsLCBieSBkZWZhdWx0LCBlcnJvclxyXG53aGVuIGEgZmllbGQgZ2V0cyB0d28gdmFsdWVzIHRoYXQgYXJlbid0IGA9PT1gLWVxdWFsLCBidXQgeW91IGNhblxyXG5wcm92aWRlIGNvbWJpbmUgZnVuY3Rpb25zIHBlciBmaWVsZCB0byBkbyBzb21ldGhpbmcgZWxzZS5cclxuKi9cclxuZnVuY3Rpb24gY29tYmluZUNvbmZpZyhjb25maWdzLCBkZWZhdWx0cywgLy8gU2hvdWxkIGhvbGQgb25seSB0aGUgb3B0aW9uYWwgcHJvcGVydGllcyBvZiBDb25maWcsIGJ1dCBJIGhhdmVuJ3QgbWFuYWdlZCB0byBleHByZXNzIHRoYXRcclxuY29tYmluZSA9IHt9KSB7XHJcbiAgICBsZXQgcmVzdWx0ID0ge307XHJcbiAgICBmb3IgKGxldCBjb25maWcgb2YgY29uZmlncylcclxuICAgICAgICBmb3IgKGxldCBrZXkgb2YgT2JqZWN0LmtleXMoY29uZmlnKSkge1xyXG4gICAgICAgICAgICBsZXQgdmFsdWUgPSBjb25maWdba2V5XSwgY3VycmVudCA9IHJlc3VsdFtrZXldO1xyXG4gICAgICAgICAgICBpZiAoY3VycmVudCA9PT0gdW5kZWZpbmVkKVxyXG4gICAgICAgICAgICAgICAgcmVzdWx0W2tleV0gPSB2YWx1ZTtcclxuICAgICAgICAgICAgZWxzZSBpZiAoY3VycmVudCA9PT0gdmFsdWUgfHwgdmFsdWUgPT09IHVuZGVmaW5lZCkgOyAvLyBObyBjb25mbGljdFxyXG4gICAgICAgICAgICBlbHNlIGlmIChPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChjb21iaW5lLCBrZXkpKVxyXG4gICAgICAgICAgICAgICAgcmVzdWx0W2tleV0gPSBjb21iaW5lW2tleV0oY3VycmVudCwgdmFsdWUpO1xyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb25maWcgbWVyZ2UgY29uZmxpY3QgZm9yIGZpZWxkIFwiICsga2V5KTtcclxuICAgICAgICB9XHJcbiAgICBmb3IgKGxldCBrZXkgaW4gZGVmYXVsdHMpXHJcbiAgICAgICAgaWYgKHJlc3VsdFtrZXldID09PSB1bmRlZmluZWQpXHJcbiAgICAgICAgICAgIHJlc3VsdFtrZXldID0gZGVmYXVsdHNba2V5XTtcclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn1cclxuXHJcbi8qKlxyXG5FYWNoIHJhbmdlIGlzIGFzc29jaWF0ZWQgd2l0aCBhIHZhbHVlLCB3aGljaCBtdXN0IGluaGVyaXQgZnJvbVxyXG50aGlzIGNsYXNzLlxyXG4qL1xyXG5jbGFzcyBSYW5nZVZhbHVlIHtcclxuICAgIC8qKlxyXG4gICAgQ29tcGFyZSB0aGlzIHZhbHVlIHdpdGggYW5vdGhlciB2YWx1ZS4gVXNlZCB3aGVuIGNvbXBhcmluZ1xyXG4gICAgcmFuZ2VzZXRzLiBUaGUgZGVmYXVsdCBpbXBsZW1lbnRhdGlvbiBjb21wYXJlcyBieSBpZGVudGl0eS5cclxuICAgIFVubGVzcyB5b3UgYXJlIG9ubHkgY3JlYXRpbmcgYSBmaXhlZCBudW1iZXIgb2YgdW5pcXVlIGluc3RhbmNlc1xyXG4gICAgb2YgeW91ciB2YWx1ZSB0eXBlLCBpdCBpcyBhIGdvb2QgaWRlYSB0byBpbXBsZW1lbnQgdGhpc1xyXG4gICAgcHJvcGVybHkuXHJcbiAgICAqL1xyXG4gICAgZXEob3RoZXIpIHsgcmV0dXJuIHRoaXMgPT0gb3RoZXI7IH1cclxuICAgIC8qKlxyXG4gICAgQ3JlYXRlIGEgW3JhbmdlXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlJhbmdlKSB3aXRoIHRoaXMgdmFsdWUuXHJcbiAgICAqL1xyXG4gICAgcmFuZ2UoZnJvbSwgdG8gPSBmcm9tKSB7IHJldHVybiBSYW5nZS5jcmVhdGUoZnJvbSwgdG8sIHRoaXMpOyB9XHJcbn1cclxuUmFuZ2VWYWx1ZS5wcm90b3R5cGUuc3RhcnRTaWRlID0gUmFuZ2VWYWx1ZS5wcm90b3R5cGUuZW5kU2lkZSA9IDA7XHJcblJhbmdlVmFsdWUucHJvdG90eXBlLnBvaW50ID0gZmFsc2U7XHJcblJhbmdlVmFsdWUucHJvdG90eXBlLm1hcE1vZGUgPSBNYXBNb2RlLlRyYWNrRGVsO1xyXG4vKipcclxuQSByYW5nZSBhc3NvY2lhdGVzIGEgdmFsdWUgd2l0aCBhIHJhbmdlIG9mIHBvc2l0aW9ucy5cclxuKi9cclxuY2xhc3MgUmFuZ2Uge1xyXG4gICAgY29uc3RydWN0b3IoXHJcbiAgICAvKipcclxuICAgIFRoZSByYW5nZSdzIHN0YXJ0IHBvc2l0aW9uLlxyXG4gICAgKi9cclxuICAgIGZyb20sIFxyXG4gICAgLyoqXHJcbiAgICBJdHMgZW5kIHBvc2l0aW9uLlxyXG4gICAgKi9cclxuICAgIHRvLCBcclxuICAgIC8qKlxyXG4gICAgVGhlIHZhbHVlIGFzc29jaWF0ZWQgd2l0aCB0aGlzIHJhbmdlLlxyXG4gICAgKi9cclxuICAgIHZhbHVlKSB7XHJcbiAgICAgICAgdGhpcy5mcm9tID0gZnJvbTtcclxuICAgICAgICB0aGlzLnRvID0gdG87XHJcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICBAaW50ZXJuYWxcclxuICAgICovXHJcbiAgICBzdGF0aWMgY3JlYXRlKGZyb20sIHRvLCB2YWx1ZSkge1xyXG4gICAgICAgIHJldHVybiBuZXcgUmFuZ2UoZnJvbSwgdG8sIHZhbHVlKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBjbXBSYW5nZShhLCBiKSB7XHJcbiAgICByZXR1cm4gYS5mcm9tIC0gYi5mcm9tIHx8IGEudmFsdWUuc3RhcnRTaWRlIC0gYi52YWx1ZS5zdGFydFNpZGU7XHJcbn1cclxuY2xhc3MgQ2h1bmsge1xyXG4gICAgY29uc3RydWN0b3IoZnJvbSwgdG8sIHZhbHVlLCBcclxuICAgIC8vIENodW5rcyBhcmUgbWFya2VkIHdpdGggdGhlIGxhcmdlc3QgcG9pbnQgdGhhdCBvY2N1cnNcclxuICAgIC8vIGluIHRoZW0gKG9yIC0xIGZvciBubyBwb2ludHMpLCBzbyB0aGF0IHNjYW5zIHRoYXQgYXJlXHJcbiAgICAvLyBvbmx5IGludGVyZXN0ZWQgaW4gcG9pbnRzIChzdWNoIGFzIHRoZVxyXG4gICAgLy8gaGVpZ2h0bWFwLXJlbGF0ZWQgbG9naWMpIGNhbiBza2lwIHJhbmdlLW9ubHkgY2h1bmtzLlxyXG4gICAgbWF4UG9pbnQpIHtcclxuICAgICAgICB0aGlzLmZyb20gPSBmcm9tO1xyXG4gICAgICAgIHRoaXMudG8gPSB0bztcclxuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XHJcbiAgICAgICAgdGhpcy5tYXhQb2ludCA9IG1heFBvaW50O1xyXG4gICAgfVxyXG4gICAgZ2V0IGxlbmd0aCgpIHsgcmV0dXJuIHRoaXMudG9bdGhpcy50by5sZW5ndGggLSAxXTsgfVxyXG4gICAgLy8gRmluZCB0aGUgaW5kZXggb2YgdGhlIGdpdmVuIHBvc2l0aW9uIGFuZCBzaWRlLiBVc2UgdGhlIHJhbmdlcydcclxuICAgIC8vIGBmcm9tYCBwb3Mgd2hlbiBgZW5kID09IGZhbHNlYCwgYHRvYCB3aGVuIGBlbmQgPT0gdHJ1ZWAuXHJcbiAgICBmaW5kSW5kZXgocG9zLCBzaWRlLCBlbmQsIHN0YXJ0QXQgPSAwKSB7XHJcbiAgICAgICAgbGV0IGFyciA9IGVuZCA/IHRoaXMudG8gOiB0aGlzLmZyb207XHJcbiAgICAgICAgZm9yIChsZXQgbG8gPSBzdGFydEF0LCBoaSA9IGFyci5sZW5ndGg7Oykge1xyXG4gICAgICAgICAgICBpZiAobG8gPT0gaGkpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbG87XHJcbiAgICAgICAgICAgIGxldCBtaWQgPSAobG8gKyBoaSkgPj4gMTtcclxuICAgICAgICAgICAgbGV0IGRpZmYgPSBhcnJbbWlkXSAtIHBvcyB8fCAoZW5kID8gdGhpcy52YWx1ZVttaWRdLmVuZFNpZGUgOiB0aGlzLnZhbHVlW21pZF0uc3RhcnRTaWRlKSAtIHNpZGU7XHJcbiAgICAgICAgICAgIGlmIChtaWQgPT0gbG8pXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZGlmZiA+PSAwID8gbG8gOiBoaTtcclxuICAgICAgICAgICAgaWYgKGRpZmYgPj0gMClcclxuICAgICAgICAgICAgICAgIGhpID0gbWlkO1xyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICBsbyA9IG1pZCArIDE7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgYmV0d2VlbihvZmZzZXQsIGZyb20sIHRvLCBmKSB7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IHRoaXMuZmluZEluZGV4KGZyb20sIC0xMDAwMDAwMDAwIC8qIEMuRmFyICovLCB0cnVlKSwgZSA9IHRoaXMuZmluZEluZGV4KHRvLCAxMDAwMDAwMDAwIC8qIEMuRmFyICovLCBmYWxzZSwgaSk7IGkgPCBlOyBpKyspXHJcbiAgICAgICAgICAgIGlmIChmKHRoaXMuZnJvbVtpXSArIG9mZnNldCwgdGhpcy50b1tpXSArIG9mZnNldCwgdGhpcy52YWx1ZVtpXSkgPT09IGZhbHNlKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgbWFwKG9mZnNldCwgY2hhbmdlcykge1xyXG4gICAgICAgIGxldCB2YWx1ZSA9IFtdLCBmcm9tID0gW10sIHRvID0gW10sIG5ld1BvcyA9IC0xLCBtYXhQb2ludCA9IC0xO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy52YWx1ZS5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBsZXQgdmFsID0gdGhpcy52YWx1ZVtpXSwgY3VyRnJvbSA9IHRoaXMuZnJvbVtpXSArIG9mZnNldCwgY3VyVG8gPSB0aGlzLnRvW2ldICsgb2Zmc2V0LCBuZXdGcm9tLCBuZXdUbztcclxuICAgICAgICAgICAgaWYgKGN1ckZyb20gPT0gY3VyVG8pIHtcclxuICAgICAgICAgICAgICAgIGxldCBtYXBwZWQgPSBjaGFuZ2VzLm1hcFBvcyhjdXJGcm9tLCB2YWwuc3RhcnRTaWRlLCB2YWwubWFwTW9kZSk7XHJcbiAgICAgICAgICAgICAgICBpZiAobWFwcGVkID09IG51bGwpXHJcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICBuZXdGcm9tID0gbmV3VG8gPSBtYXBwZWQ7XHJcbiAgICAgICAgICAgICAgICBpZiAodmFsLnN0YXJ0U2lkZSAhPSB2YWwuZW5kU2lkZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIG5ld1RvID0gY2hhbmdlcy5tYXBQb3MoY3VyRnJvbSwgdmFsLmVuZFNpZGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChuZXdUbyA8IG5ld0Zyb20pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgbmV3RnJvbSA9IGNoYW5nZXMubWFwUG9zKGN1ckZyb20sIHZhbC5zdGFydFNpZGUpO1xyXG4gICAgICAgICAgICAgICAgbmV3VG8gPSBjaGFuZ2VzLm1hcFBvcyhjdXJUbywgdmFsLmVuZFNpZGUpO1xyXG4gICAgICAgICAgICAgICAgaWYgKG5ld0Zyb20gPiBuZXdUbyB8fCBuZXdGcm9tID09IG5ld1RvICYmIHZhbC5zdGFydFNpZGUgPiAwICYmIHZhbC5lbmRTaWRlIDw9IDApXHJcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKChuZXdUbyAtIG5ld0Zyb20gfHwgdmFsLmVuZFNpZGUgLSB2YWwuc3RhcnRTaWRlKSA8IDApXHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgaWYgKG5ld1BvcyA8IDApXHJcbiAgICAgICAgICAgICAgICBuZXdQb3MgPSBuZXdGcm9tO1xyXG4gICAgICAgICAgICBpZiAodmFsLnBvaW50KVxyXG4gICAgICAgICAgICAgICAgbWF4UG9pbnQgPSBNYXRoLm1heChtYXhQb2ludCwgbmV3VG8gLSBuZXdGcm9tKTtcclxuICAgICAgICAgICAgdmFsdWUucHVzaCh2YWwpO1xyXG4gICAgICAgICAgICBmcm9tLnB1c2gobmV3RnJvbSAtIG5ld1Bvcyk7XHJcbiAgICAgICAgICAgIHRvLnB1c2gobmV3VG8gLSBuZXdQb3MpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4geyBtYXBwZWQ6IHZhbHVlLmxlbmd0aCA/IG5ldyBDaHVuayhmcm9tLCB0bywgdmFsdWUsIG1heFBvaW50KSA6IG51bGwsIHBvczogbmV3UG9zIH07XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbkEgcmFuZ2Ugc2V0IHN0b3JlcyBhIGNvbGxlY3Rpb24gb2YgW3Jhbmdlc10oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5SYW5nZSkgaW4gYVxyXG53YXkgdGhhdCBtYWtlcyB0aGVtIGVmZmljaWVudCB0byBbbWFwXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlJhbmdlU2V0Lm1hcCkgYW5kXHJcblt1cGRhdGVdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuUmFuZ2VTZXQudXBkYXRlKS4gVGhpcyBpcyBhbiBpbW11dGFibGUgZGF0YVxyXG5zdHJ1Y3R1cmUuXHJcbiovXHJcbmNsYXNzIFJhbmdlU2V0IHtcclxuICAgIGNvbnN0cnVjdG9yKFxyXG4gICAgLyoqXHJcbiAgICBAaW50ZXJuYWxcclxuICAgICovXHJcbiAgICBjaHVua1BvcywgXHJcbiAgICAvKipcclxuICAgIEBpbnRlcm5hbFxyXG4gICAgKi9cclxuICAgIGNodW5rLCBcclxuICAgIC8qKlxyXG4gICAgQGludGVybmFsXHJcbiAgICAqL1xyXG4gICAgbmV4dExheWVyLCBcclxuICAgIC8qKlxyXG4gICAgQGludGVybmFsXHJcbiAgICAqL1xyXG4gICAgbWF4UG9pbnQpIHtcclxuICAgICAgICB0aGlzLmNodW5rUG9zID0gY2h1bmtQb3M7XHJcbiAgICAgICAgdGhpcy5jaHVuayA9IGNodW5rO1xyXG4gICAgICAgIHRoaXMubmV4dExheWVyID0gbmV4dExheWVyO1xyXG4gICAgICAgIHRoaXMubWF4UG9pbnQgPSBtYXhQb2ludDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgQGludGVybmFsXHJcbiAgICAqL1xyXG4gICAgc3RhdGljIGNyZWF0ZShjaHVua1BvcywgY2h1bmssIG5leHRMYXllciwgbWF4UG9pbnQpIHtcclxuICAgICAgICByZXR1cm4gbmV3IFJhbmdlU2V0KGNodW5rUG9zLCBjaHVuaywgbmV4dExheWVyLCBtYXhQb2ludCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgIEBpbnRlcm5hbFxyXG4gICAgKi9cclxuICAgIGdldCBsZW5ndGgoKSB7XHJcbiAgICAgICAgbGV0IGxhc3QgPSB0aGlzLmNodW5rLmxlbmd0aCAtIDE7XHJcbiAgICAgICAgcmV0dXJuIGxhc3QgPCAwID8gMCA6IE1hdGgubWF4KHRoaXMuY2h1bmtFbmQobGFzdCksIHRoaXMubmV4dExheWVyLmxlbmd0aCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgIFRoZSBudW1iZXIgb2YgcmFuZ2VzIGluIHRoZSBzZXQuXHJcbiAgICAqL1xyXG4gICAgZ2V0IHNpemUoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuaXNFbXB0eSlcclxuICAgICAgICAgICAgcmV0dXJuIDA7XHJcbiAgICAgICAgbGV0IHNpemUgPSB0aGlzLm5leHRMYXllci5zaXplO1xyXG4gICAgICAgIGZvciAobGV0IGNodW5rIG9mIHRoaXMuY2h1bmspXHJcbiAgICAgICAgICAgIHNpemUgKz0gY2h1bmsudmFsdWUubGVuZ3RoO1xyXG4gICAgICAgIHJldHVybiBzaXplO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICBAaW50ZXJuYWxcclxuICAgICovXHJcbiAgICBjaHVua0VuZChpbmRleCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNodW5rUG9zW2luZGV4XSArIHRoaXMuY2h1bmtbaW5kZXhdLmxlbmd0aDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgVXBkYXRlIHRoZSByYW5nZSBzZXQsIG9wdGlvbmFsbHkgYWRkaW5nIG5ldyByYW5nZXMgb3IgZmlsdGVyaW5nXHJcbiAgICBvdXQgZXhpc3Rpbmcgb25lcy5cclxuICAgIFxyXG4gICAgKE5vdGU6IFRoZSB0eXBlIHBhcmFtZXRlciBpcyBqdXN0IHRoZXJlIGFzIGEga2x1ZGdlIHRvIHdvcmtcclxuICAgIGFyb3VuZCBUeXBlU2NyaXB0IHZhcmlhbmNlIGlzc3VlcyB0aGF0IHByZXZlbnRlZCBgUmFuZ2VTZXQ8WD5gXHJcbiAgICBmcm9tIGJlaW5nIGEgc3VidHlwZSBvZiBgUmFuZ2VTZXQ8WT5gIHdoZW4gYFhgIGlzIGEgc3VidHlwZSBvZlxyXG4gICAgYFlgLilcclxuICAgICovXHJcbiAgICB1cGRhdGUodXBkYXRlU3BlYykge1xyXG4gICAgICAgIGxldCB7IGFkZCA9IFtdLCBzb3J0ID0gZmFsc2UsIGZpbHRlckZyb20gPSAwLCBmaWx0ZXJUbyA9IHRoaXMubGVuZ3RoIH0gPSB1cGRhdGVTcGVjO1xyXG4gICAgICAgIGxldCBmaWx0ZXIgPSB1cGRhdGVTcGVjLmZpbHRlcjtcclxuICAgICAgICBpZiAoYWRkLmxlbmd0aCA9PSAwICYmICFmaWx0ZXIpXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgIGlmIChzb3J0KVxyXG4gICAgICAgICAgICBhZGQgPSBhZGQuc2xpY2UoKS5zb3J0KGNtcFJhbmdlKTtcclxuICAgICAgICBpZiAodGhpcy5pc0VtcHR5KVxyXG4gICAgICAgICAgICByZXR1cm4gYWRkLmxlbmd0aCA/IFJhbmdlU2V0Lm9mKGFkZCkgOiB0aGlzO1xyXG4gICAgICAgIGxldCBjdXIgPSBuZXcgTGF5ZXJDdXJzb3IodGhpcywgbnVsbCwgLTEpLmdvdG8oMCksIGkgPSAwLCBzcGlsbCA9IFtdO1xyXG4gICAgICAgIGxldCBidWlsZGVyID0gbmV3IFJhbmdlU2V0QnVpbGRlcigpO1xyXG4gICAgICAgIHdoaWxlIChjdXIudmFsdWUgfHwgaSA8IGFkZC5sZW5ndGgpIHtcclxuICAgICAgICAgICAgaWYgKGkgPCBhZGQubGVuZ3RoICYmIChjdXIuZnJvbSAtIGFkZFtpXS5mcm9tIHx8IGN1ci5zdGFydFNpZGUgLSBhZGRbaV0udmFsdWUuc3RhcnRTaWRlKSA+PSAwKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgcmFuZ2UgPSBhZGRbaSsrXTtcclxuICAgICAgICAgICAgICAgIGlmICghYnVpbGRlci5hZGRJbm5lcihyYW5nZS5mcm9tLCByYW5nZS50bywgcmFuZ2UudmFsdWUpKVxyXG4gICAgICAgICAgICAgICAgICAgIHNwaWxsLnB1c2gocmFuZ2UpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGN1ci5yYW5nZUluZGV4ID09IDEgJiYgY3VyLmNodW5rSW5kZXggPCB0aGlzLmNodW5rLmxlbmd0aCAmJlxyXG4gICAgICAgICAgICAgICAgKGkgPT0gYWRkLmxlbmd0aCB8fCB0aGlzLmNodW5rRW5kKGN1ci5jaHVua0luZGV4KSA8IGFkZFtpXS5mcm9tKSAmJlxyXG4gICAgICAgICAgICAgICAgKCFmaWx0ZXIgfHwgZmlsdGVyRnJvbSA+IHRoaXMuY2h1bmtFbmQoY3VyLmNodW5rSW5kZXgpIHx8IGZpbHRlclRvIDwgdGhpcy5jaHVua1Bvc1tjdXIuY2h1bmtJbmRleF0pICYmXHJcbiAgICAgICAgICAgICAgICBidWlsZGVyLmFkZENodW5rKHRoaXMuY2h1bmtQb3NbY3VyLmNodW5rSW5kZXhdLCB0aGlzLmNodW5rW2N1ci5jaHVua0luZGV4XSkpIHtcclxuICAgICAgICAgICAgICAgIGN1ci5uZXh0Q2h1bmsoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGlmICghZmlsdGVyIHx8IGZpbHRlckZyb20gPiBjdXIudG8gfHwgZmlsdGVyVG8gPCBjdXIuZnJvbSB8fCBmaWx0ZXIoY3VyLmZyb20sIGN1ci50bywgY3VyLnZhbHVlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghYnVpbGRlci5hZGRJbm5lcihjdXIuZnJvbSwgY3VyLnRvLCBjdXIudmFsdWUpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzcGlsbC5wdXNoKFJhbmdlLmNyZWF0ZShjdXIuZnJvbSwgY3VyLnRvLCBjdXIudmFsdWUpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGN1ci5uZXh0KCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGJ1aWxkZXIuZmluaXNoSW5uZXIodGhpcy5uZXh0TGF5ZXIuaXNFbXB0eSAmJiAhc3BpbGwubGVuZ3RoID8gUmFuZ2VTZXQuZW1wdHlcclxuICAgICAgICAgICAgOiB0aGlzLm5leHRMYXllci51cGRhdGUoeyBhZGQ6IHNwaWxsLCBmaWx0ZXIsIGZpbHRlckZyb20sIGZpbHRlclRvIH0pKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgTWFwIHRoaXMgcmFuZ2Ugc2V0IHRocm91Z2ggYSBzZXQgb2YgY2hhbmdlcywgcmV0dXJuIHRoZSBuZXcgc2V0LlxyXG4gICAgKi9cclxuICAgIG1hcChjaGFuZ2VzKSB7XHJcbiAgICAgICAgaWYgKGNoYW5nZXMuZW1wdHkgfHwgdGhpcy5pc0VtcHR5KVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICBsZXQgY2h1bmtzID0gW10sIGNodW5rUG9zID0gW10sIG1heFBvaW50ID0gLTE7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmNodW5rLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGxldCBzdGFydCA9IHRoaXMuY2h1bmtQb3NbaV0sIGNodW5rID0gdGhpcy5jaHVua1tpXTtcclxuICAgICAgICAgICAgbGV0IHRvdWNoID0gY2hhbmdlcy50b3VjaGVzUmFuZ2Uoc3RhcnQsIHN0YXJ0ICsgY2h1bmsubGVuZ3RoKTtcclxuICAgICAgICAgICAgaWYgKHRvdWNoID09PSBmYWxzZSkge1xyXG4gICAgICAgICAgICAgICAgbWF4UG9pbnQgPSBNYXRoLm1heChtYXhQb2ludCwgY2h1bmsubWF4UG9pbnQpO1xyXG4gICAgICAgICAgICAgICAgY2h1bmtzLnB1c2goY2h1bmspO1xyXG4gICAgICAgICAgICAgICAgY2h1bmtQb3MucHVzaChjaGFuZ2VzLm1hcFBvcyhzdGFydCkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHRvdWNoID09PSB0cnVlKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgeyBtYXBwZWQsIHBvcyB9ID0gY2h1bmsubWFwKHN0YXJ0LCBjaGFuZ2VzKTtcclxuICAgICAgICAgICAgICAgIGlmIChtYXBwZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICBtYXhQb2ludCA9IE1hdGgubWF4KG1heFBvaW50LCBtYXBwZWQubWF4UG9pbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNodW5rcy5wdXNoKG1hcHBlZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgY2h1bmtQb3MucHVzaChwb3MpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCBuZXh0ID0gdGhpcy5uZXh0TGF5ZXIubWFwKGNoYW5nZXMpO1xyXG4gICAgICAgIHJldHVybiBjaHVua3MubGVuZ3RoID09IDAgPyBuZXh0IDogbmV3IFJhbmdlU2V0KGNodW5rUG9zLCBjaHVua3MsIG5leHQgfHwgUmFuZ2VTZXQuZW1wdHksIG1heFBvaW50KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgSXRlcmF0ZSBvdmVyIHRoZSByYW5nZXMgdGhhdCB0b3VjaCB0aGUgcmVnaW9uIGBmcm9tYCB0byBgdG9gLFxyXG4gICAgY2FsbGluZyBgZmAgZm9yIGVhY2guIFRoZXJlIGlzIG5vIGd1YXJhbnRlZSB0aGF0IHRoZSByYW5nZXMgd2lsbFxyXG4gICAgYmUgcmVwb3J0ZWQgaW4gYW55IHNwZWNpZmljIG9yZGVyLiBXaGVuIHRoZSBjYWxsYmFjayByZXR1cm5zXHJcbiAgICBgZmFsc2VgLCBpdGVyYXRpb24gc3RvcHMuXHJcbiAgICAqL1xyXG4gICAgYmV0d2Vlbihmcm9tLCB0bywgZikge1xyXG4gICAgICAgIGlmICh0aGlzLmlzRW1wdHkpXHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuY2h1bmsubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgbGV0IHN0YXJ0ID0gdGhpcy5jaHVua1Bvc1tpXSwgY2h1bmsgPSB0aGlzLmNodW5rW2ldO1xyXG4gICAgICAgICAgICBpZiAodG8gPj0gc3RhcnQgJiYgZnJvbSA8PSBzdGFydCArIGNodW5rLmxlbmd0aCAmJlxyXG4gICAgICAgICAgICAgICAgY2h1bmsuYmV0d2VlbihzdGFydCwgZnJvbSAtIHN0YXJ0LCB0byAtIHN0YXJ0LCBmKSA9PT0gZmFsc2UpXHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMubmV4dExheWVyLmJldHdlZW4oZnJvbSwgdG8sIGYpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICBJdGVyYXRlIG92ZXIgdGhlIHJhbmdlcyBpbiB0aGlzIHNldCwgaW4gb3JkZXIsIGluY2x1ZGluZyBhbGxcclxuICAgIHJhbmdlcyB0aGF0IGVuZCBhdCBvciBhZnRlciBgZnJvbWAuXHJcbiAgICAqL1xyXG4gICAgaXRlcihmcm9tID0gMCkge1xyXG4gICAgICAgIHJldHVybiBIZWFwQ3Vyc29yLmZyb20oW3RoaXNdKS5nb3RvKGZyb20pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICBAaW50ZXJuYWxcclxuICAgICovXHJcbiAgICBnZXQgaXNFbXB0eSgpIHsgcmV0dXJuIHRoaXMubmV4dExheWVyID09IHRoaXM7IH1cclxuICAgIC8qKlxyXG4gICAgSXRlcmF0ZSBvdmVyIHRoZSByYW5nZXMgaW4gYSBjb2xsZWN0aW9uIG9mIHNldHMsIGluIG9yZGVyLFxyXG4gICAgc3RhcnRpbmcgZnJvbSBgZnJvbWAuXHJcbiAgICAqL1xyXG4gICAgc3RhdGljIGl0ZXIoc2V0cywgZnJvbSA9IDApIHtcclxuICAgICAgICByZXR1cm4gSGVhcEN1cnNvci5mcm9tKHNldHMpLmdvdG8oZnJvbSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgIEl0ZXJhdGUgb3ZlciB0d28gZ3JvdXBzIG9mIHNldHMsIGNhbGxpbmcgbWV0aG9kcyBvbiBgY29tcGFyYXRvcmBcclxuICAgIHRvIG5vdGlmeSBpdCBvZiBwb3NzaWJsZSBkaWZmZXJlbmNlcy5cclxuICAgICovXHJcbiAgICBzdGF0aWMgY29tcGFyZShvbGRTZXRzLCBuZXdTZXRzLCBcclxuICAgIC8qKlxyXG4gICAgVGhpcyBpbmRpY2F0ZXMgaG93IHRoZSB1bmRlcmx5aW5nIGRhdGEgY2hhbmdlZCBiZXR3ZWVuIHRoZXNlXHJcbiAgICByYW5nZXMsIGFuZCBpcyBuZWVkZWQgdG8gc3luY2hyb25pemUgdGhlIGl0ZXJhdGlvbi4gYGZyb21gIGFuZFxyXG4gICAgYHRvYCBhcmUgY29vcmRpbmF0ZXMgaW4gdGhlIF9uZXdfIHNwYWNlLCBhZnRlciB0aGVzZSBjaGFuZ2VzLlxyXG4gICAgKi9cclxuICAgIHRleHREaWZmLCBjb21wYXJhdG9yLCBcclxuICAgIC8qKlxyXG4gICAgQ2FuIGJlIHVzZWQgdG8gaWdub3JlIGFsbCBub24tcG9pbnQgcmFuZ2VzLCBhbmQgcG9pbnRzIGJlbG93XHJcbiAgICB0aGUgZ2l2ZW4gc2l6ZS4gV2hlbiAtMSwgYWxsIHJhbmdlcyBhcmUgY29tcGFyZWQuXHJcbiAgICAqL1xyXG4gICAgbWluUG9pbnRTaXplID0gLTEpIHtcclxuICAgICAgICBsZXQgYSA9IG9sZFNldHMuZmlsdGVyKHNldCA9PiBzZXQubWF4UG9pbnQgPiAwIHx8ICFzZXQuaXNFbXB0eSAmJiBzZXQubWF4UG9pbnQgPj0gbWluUG9pbnRTaXplKTtcclxuICAgICAgICBsZXQgYiA9IG5ld1NldHMuZmlsdGVyKHNldCA9PiBzZXQubWF4UG9pbnQgPiAwIHx8ICFzZXQuaXNFbXB0eSAmJiBzZXQubWF4UG9pbnQgPj0gbWluUG9pbnRTaXplKTtcclxuICAgICAgICBsZXQgc2hhcmVkQ2h1bmtzID0gZmluZFNoYXJlZENodW5rcyhhLCBiLCB0ZXh0RGlmZik7XHJcbiAgICAgICAgbGV0IHNpZGVBID0gbmV3IFNwYW5DdXJzb3IoYSwgc2hhcmVkQ2h1bmtzLCBtaW5Qb2ludFNpemUpO1xyXG4gICAgICAgIGxldCBzaWRlQiA9IG5ldyBTcGFuQ3Vyc29yKGIsIHNoYXJlZENodW5rcywgbWluUG9pbnRTaXplKTtcclxuICAgICAgICB0ZXh0RGlmZi5pdGVyR2FwcygoZnJvbUEsIGZyb21CLCBsZW5ndGgpID0+IGNvbXBhcmUoc2lkZUEsIGZyb21BLCBzaWRlQiwgZnJvbUIsIGxlbmd0aCwgY29tcGFyYXRvcikpO1xyXG4gICAgICAgIGlmICh0ZXh0RGlmZi5lbXB0eSAmJiB0ZXh0RGlmZi5sZW5ndGggPT0gMClcclxuICAgICAgICAgICAgY29tcGFyZShzaWRlQSwgMCwgc2lkZUIsIDAsIDAsIGNvbXBhcmF0b3IpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICBDb21wYXJlIHRoZSBjb250ZW50cyBvZiB0d28gZ3JvdXBzIG9mIHJhbmdlIHNldHMsIHJldHVybmluZyB0cnVlXHJcbiAgICBpZiB0aGV5IGFyZSBlcXVpdmFsZW50IGluIHRoZSBnaXZlbiByYW5nZS5cclxuICAgICovXHJcbiAgICBzdGF0aWMgZXEob2xkU2V0cywgbmV3U2V0cywgZnJvbSA9IDAsIHRvKSB7XHJcbiAgICAgICAgaWYgKHRvID09IG51bGwpXHJcbiAgICAgICAgICAgIHRvID0gMTAwMDAwMDAwMCAvKiBDLkZhciAqLyAtIDE7XHJcbiAgICAgICAgbGV0IGEgPSBvbGRTZXRzLmZpbHRlcihzZXQgPT4gIXNldC5pc0VtcHR5ICYmIG5ld1NldHMuaW5kZXhPZihzZXQpIDwgMCk7XHJcbiAgICAgICAgbGV0IGIgPSBuZXdTZXRzLmZpbHRlcihzZXQgPT4gIXNldC5pc0VtcHR5ICYmIG9sZFNldHMuaW5kZXhPZihzZXQpIDwgMCk7XHJcbiAgICAgICAgaWYgKGEubGVuZ3RoICE9IGIubGVuZ3RoKVxyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgaWYgKCFhLmxlbmd0aClcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgbGV0IHNoYXJlZENodW5rcyA9IGZpbmRTaGFyZWRDaHVua3MoYSwgYik7XHJcbiAgICAgICAgbGV0IHNpZGVBID0gbmV3IFNwYW5DdXJzb3IoYSwgc2hhcmVkQ2h1bmtzLCAwKS5nb3RvKGZyb20pLCBzaWRlQiA9IG5ldyBTcGFuQ3Vyc29yKGIsIHNoYXJlZENodW5rcywgMCkuZ290byhmcm9tKTtcclxuICAgICAgICBmb3IgKDs7KSB7XHJcbiAgICAgICAgICAgIGlmIChzaWRlQS50byAhPSBzaWRlQi50byB8fFxyXG4gICAgICAgICAgICAgICAgIXNhbWVWYWx1ZXMoc2lkZUEuYWN0aXZlLCBzaWRlQi5hY3RpdmUpIHx8XHJcbiAgICAgICAgICAgICAgICBzaWRlQS5wb2ludCAmJiAoIXNpZGVCLnBvaW50IHx8ICFzaWRlQS5wb2ludC5lcShzaWRlQi5wb2ludCkpKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICBpZiAoc2lkZUEudG8gPiB0bylcclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICBzaWRlQS5uZXh0KCk7XHJcbiAgICAgICAgICAgIHNpZGVCLm5leHQoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgIEl0ZXJhdGUgb3ZlciBhIGdyb3VwIG9mIHJhbmdlIHNldHMgYXQgdGhlIHNhbWUgdGltZSwgbm90aWZ5aW5nXHJcbiAgICB0aGUgaXRlcmF0b3IgYWJvdXQgdGhlIHJhbmdlcyBjb3ZlcmluZyBldmVyeSBnaXZlbiBwaWVjZSBvZlxyXG4gICAgY29udGVudC4gUmV0dXJucyB0aGUgb3BlbiBjb3VudCAoc2VlXHJcbiAgICBbYFNwYW5JdGVyYXRvci5zcGFuYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5TcGFuSXRlcmF0b3Iuc3BhbikpIGF0IHRoZSBlbmRcclxuICAgIG9mIHRoZSBpdGVyYXRpb24uXHJcbiAgICAqL1xyXG4gICAgc3RhdGljIHNwYW5zKHNldHMsIGZyb20sIHRvLCBpdGVyYXRvciwgXHJcbiAgICAvKipcclxuICAgIFdoZW4gZ2l2ZW4gYW5kIGdyZWF0ZXIgdGhhbiAtMSwgb25seSBwb2ludHMgb2YgYXQgbGVhc3QgdGhpc1xyXG4gICAgc2l6ZSBhcmUgdGFrZW4gaW50byBhY2NvdW50LlxyXG4gICAgKi9cclxuICAgIG1pblBvaW50U2l6ZSA9IC0xKSB7XHJcbiAgICAgICAgbGV0IGN1cnNvciA9IG5ldyBTcGFuQ3Vyc29yKHNldHMsIG51bGwsIG1pblBvaW50U2l6ZSkuZ290byhmcm9tKSwgcG9zID0gZnJvbTtcclxuICAgICAgICBsZXQgb3BlblJhbmdlcyA9IGN1cnNvci5vcGVuU3RhcnQ7XHJcbiAgICAgICAgZm9yICg7Oykge1xyXG4gICAgICAgICAgICBsZXQgY3VyVG8gPSBNYXRoLm1pbihjdXJzb3IudG8sIHRvKTtcclxuICAgICAgICAgICAgaWYgKGN1cnNvci5wb2ludCkge1xyXG4gICAgICAgICAgICAgICAgbGV0IGFjdGl2ZSA9IGN1cnNvci5hY3RpdmVGb3JQb2ludChjdXJzb3IudG8pO1xyXG4gICAgICAgICAgICAgICAgbGV0IG9wZW5Db3VudCA9IGN1cnNvci5wb2ludEZyb20gPCBmcm9tID8gYWN0aXZlLmxlbmd0aCArIDEgOiBNYXRoLm1pbihhY3RpdmUubGVuZ3RoLCBvcGVuUmFuZ2VzKTtcclxuICAgICAgICAgICAgICAgIGl0ZXJhdG9yLnBvaW50KHBvcywgY3VyVG8sIGN1cnNvci5wb2ludCwgYWN0aXZlLCBvcGVuQ291bnQsIGN1cnNvci5wb2ludFJhbmspO1xyXG4gICAgICAgICAgICAgICAgb3BlblJhbmdlcyA9IE1hdGgubWluKGN1cnNvci5vcGVuRW5kKGN1clRvKSwgYWN0aXZlLmxlbmd0aCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoY3VyVG8gPiBwb3MpIHtcclxuICAgICAgICAgICAgICAgIGl0ZXJhdG9yLnNwYW4ocG9zLCBjdXJUbywgY3Vyc29yLmFjdGl2ZSwgb3BlblJhbmdlcyk7XHJcbiAgICAgICAgICAgICAgICBvcGVuUmFuZ2VzID0gY3Vyc29yLm9wZW5FbmQoY3VyVG8pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChjdXJzb3IudG8gPiB0bylcclxuICAgICAgICAgICAgICAgIHJldHVybiBvcGVuUmFuZ2VzICsgKGN1cnNvci5wb2ludCAmJiBjdXJzb3IudG8gPiB0byA/IDEgOiAwKTtcclxuICAgICAgICAgICAgcG9zID0gY3Vyc29yLnRvO1xyXG4gICAgICAgICAgICBjdXJzb3IubmV4dCgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgQ3JlYXRlIGEgcmFuZ2Ugc2V0IGZvciB0aGUgZ2l2ZW4gcmFuZ2Ugb3IgYXJyYXkgb2YgcmFuZ2VzLiBCeVxyXG4gICAgZGVmYXVsdCwgdGhpcyBleHBlY3RzIHRoZSByYW5nZXMgdG8gYmUgX3NvcnRlZF8gKGJ5IHN0YXJ0XHJcbiAgICBwb3NpdGlvbiBhbmQsIGlmIHR3byBzdGFydCBhdCB0aGUgc2FtZSBwb3NpdGlvbixcclxuICAgIGB2YWx1ZS5zdGFydFNpZGVgKS4gWW91IGNhbiBwYXNzIGB0cnVlYCBhcyBzZWNvbmQgYXJndW1lbnQgdG9cclxuICAgIGNhdXNlIHRoZSBtZXRob2QgdG8gc29ydCB0aGVtLlxyXG4gICAgKi9cclxuICAgIHN0YXRpYyBvZihyYW5nZXMsIHNvcnQgPSBmYWxzZSkge1xyXG4gICAgICAgIGxldCBidWlsZCA9IG5ldyBSYW5nZVNldEJ1aWxkZXIoKTtcclxuICAgICAgICBmb3IgKGxldCByYW5nZSBvZiByYW5nZXMgaW5zdGFuY2VvZiBSYW5nZSA/IFtyYW5nZXNdIDogc29ydCA/IGxhenlTb3J0KHJhbmdlcykgOiByYW5nZXMpXHJcbiAgICAgICAgICAgIGJ1aWxkLmFkZChyYW5nZS5mcm9tLCByYW5nZS50bywgcmFuZ2UudmFsdWUpO1xyXG4gICAgICAgIHJldHVybiBidWlsZC5maW5pc2goKTtcclxuICAgIH1cclxufVxyXG4vKipcclxuVGhlIGVtcHR5IHNldCBvZiByYW5nZXMuXHJcbiovXHJcblJhbmdlU2V0LmVtcHR5ID0gLypAX19QVVJFX18qL25ldyBSYW5nZVNldChbXSwgW10sIG51bGwsIC0xKTtcclxuZnVuY3Rpb24gbGF6eVNvcnQocmFuZ2VzKSB7XHJcbiAgICBpZiAocmFuZ2VzLmxlbmd0aCA+IDEpXHJcbiAgICAgICAgZm9yIChsZXQgcHJldiA9IHJhbmdlc1swXSwgaSA9IDE7IGkgPCByYW5nZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgbGV0IGN1ciA9IHJhbmdlc1tpXTtcclxuICAgICAgICAgICAgaWYgKGNtcFJhbmdlKHByZXYsIGN1cikgPiAwKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJhbmdlcy5zbGljZSgpLnNvcnQoY21wUmFuZ2UpO1xyXG4gICAgICAgICAgICBwcmV2ID0gY3VyO1xyXG4gICAgICAgIH1cclxuICAgIHJldHVybiByYW5nZXM7XHJcbn1cclxuUmFuZ2VTZXQuZW1wdHkubmV4dExheWVyID0gUmFuZ2VTZXQuZW1wdHk7XHJcbi8qKlxyXG5BIHJhbmdlIHNldCBidWlsZGVyIGlzIGEgZGF0YSBzdHJ1Y3R1cmUgdGhhdCBoZWxwcyBidWlsZCB1cCBhXHJcbltyYW5nZSBzZXRdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuUmFuZ2VTZXQpIGRpcmVjdGx5LCB3aXRob3V0IGZpcnN0IGFsbG9jYXRpbmdcclxuYW4gYXJyYXkgb2YgW2BSYW5nZWBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuUmFuZ2UpIG9iamVjdHMuXHJcbiovXHJcbmNsYXNzIFJhbmdlU2V0QnVpbGRlciB7XHJcbiAgICAvKipcclxuICAgIENyZWF0ZSBhbiBlbXB0eSBidWlsZGVyLlxyXG4gICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHRoaXMuY2h1bmtzID0gW107XHJcbiAgICAgICAgdGhpcy5jaHVua1BvcyA9IFtdO1xyXG4gICAgICAgIHRoaXMuY2h1bmtTdGFydCA9IC0xO1xyXG4gICAgICAgIHRoaXMubGFzdCA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5sYXN0RnJvbSA9IC0xMDAwMDAwMDAwIC8qIEMuRmFyICovO1xyXG4gICAgICAgIHRoaXMubGFzdFRvID0gLTEwMDAwMDAwMDAgLyogQy5GYXIgKi87XHJcbiAgICAgICAgdGhpcy5mcm9tID0gW107XHJcbiAgICAgICAgdGhpcy50byA9IFtdO1xyXG4gICAgICAgIHRoaXMudmFsdWUgPSBbXTtcclxuICAgICAgICB0aGlzLm1heFBvaW50ID0gLTE7XHJcbiAgICAgICAgdGhpcy5zZXRNYXhQb2ludCA9IC0xO1xyXG4gICAgICAgIHRoaXMubmV4dExheWVyID0gbnVsbDtcclxuICAgIH1cclxuICAgIGZpbmlzaENodW5rKG5ld0FycmF5cykge1xyXG4gICAgICAgIHRoaXMuY2h1bmtzLnB1c2gobmV3IENodW5rKHRoaXMuZnJvbSwgdGhpcy50bywgdGhpcy52YWx1ZSwgdGhpcy5tYXhQb2ludCkpO1xyXG4gICAgICAgIHRoaXMuY2h1bmtQb3MucHVzaCh0aGlzLmNodW5rU3RhcnQpO1xyXG4gICAgICAgIHRoaXMuY2h1bmtTdGFydCA9IC0xO1xyXG4gICAgICAgIHRoaXMuc2V0TWF4UG9pbnQgPSBNYXRoLm1heCh0aGlzLnNldE1heFBvaW50LCB0aGlzLm1heFBvaW50KTtcclxuICAgICAgICB0aGlzLm1heFBvaW50ID0gLTE7XHJcbiAgICAgICAgaWYgKG5ld0FycmF5cykge1xyXG4gICAgICAgICAgICB0aGlzLmZyb20gPSBbXTtcclxuICAgICAgICAgICAgdGhpcy50byA9IFtdO1xyXG4gICAgICAgICAgICB0aGlzLnZhbHVlID0gW107XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICBBZGQgYSByYW5nZS4gUmFuZ2VzIHNob3VsZCBiZSBhZGRlZCBpbiBzb3J0ZWQgKGJ5IGBmcm9tYCBhbmRcclxuICAgIGB2YWx1ZS5zdGFydFNpZGVgKSBvcmRlci5cclxuICAgICovXHJcbiAgICBhZGQoZnJvbSwgdG8sIHZhbHVlKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLmFkZElubmVyKGZyb20sIHRvLCB2YWx1ZSkpXHJcbiAgICAgICAgICAgICh0aGlzLm5leHRMYXllciB8fCAodGhpcy5uZXh0TGF5ZXIgPSBuZXcgUmFuZ2VTZXRCdWlsZGVyKSkuYWRkKGZyb20sIHRvLCB2YWx1ZSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgIEBpbnRlcm5hbFxyXG4gICAgKi9cclxuICAgIGFkZElubmVyKGZyb20sIHRvLCB2YWx1ZSkge1xyXG4gICAgICAgIGxldCBkaWZmID0gZnJvbSAtIHRoaXMubGFzdFRvIHx8IHZhbHVlLnN0YXJ0U2lkZSAtIHRoaXMubGFzdC5lbmRTaWRlO1xyXG4gICAgICAgIGlmIChkaWZmIDw9IDAgJiYgKGZyb20gLSB0aGlzLmxhc3RGcm9tIHx8IHZhbHVlLnN0YXJ0U2lkZSAtIHRoaXMubGFzdC5zdGFydFNpZGUpIDwgMClcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUmFuZ2VzIG11c3QgYmUgYWRkZWQgc29ydGVkIGJ5IGBmcm9tYCBwb3NpdGlvbiBhbmQgYHN0YXJ0U2lkZWBcIik7XHJcbiAgICAgICAgaWYgKGRpZmYgPCAwKVxyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgaWYgKHRoaXMuZnJvbS5sZW5ndGggPT0gMjUwIC8qIEMuQ2h1bmtTaXplICovKVxyXG4gICAgICAgICAgICB0aGlzLmZpbmlzaENodW5rKHRydWUpO1xyXG4gICAgICAgIGlmICh0aGlzLmNodW5rU3RhcnQgPCAwKVxyXG4gICAgICAgICAgICB0aGlzLmNodW5rU3RhcnQgPSBmcm9tO1xyXG4gICAgICAgIHRoaXMuZnJvbS5wdXNoKGZyb20gLSB0aGlzLmNodW5rU3RhcnQpO1xyXG4gICAgICAgIHRoaXMudG8ucHVzaCh0byAtIHRoaXMuY2h1bmtTdGFydCk7XHJcbiAgICAgICAgdGhpcy5sYXN0ID0gdmFsdWU7XHJcbiAgICAgICAgdGhpcy5sYXN0RnJvbSA9IGZyb207XHJcbiAgICAgICAgdGhpcy5sYXN0VG8gPSB0bztcclxuICAgICAgICB0aGlzLnZhbHVlLnB1c2godmFsdWUpO1xyXG4gICAgICAgIGlmICh2YWx1ZS5wb2ludClcclxuICAgICAgICAgICAgdGhpcy5tYXhQb2ludCA9IE1hdGgubWF4KHRoaXMubWF4UG9pbnQsIHRvIC0gZnJvbSk7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgIEBpbnRlcm5hbFxyXG4gICAgKi9cclxuICAgIGFkZENodW5rKGZyb20sIGNodW5rKSB7XHJcbiAgICAgICAgaWYgKChmcm9tIC0gdGhpcy5sYXN0VG8gfHwgY2h1bmsudmFsdWVbMF0uc3RhcnRTaWRlIC0gdGhpcy5sYXN0LmVuZFNpZGUpIDwgMClcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIGlmICh0aGlzLmZyb20ubGVuZ3RoKVxyXG4gICAgICAgICAgICB0aGlzLmZpbmlzaENodW5rKHRydWUpO1xyXG4gICAgICAgIHRoaXMuc2V0TWF4UG9pbnQgPSBNYXRoLm1heCh0aGlzLnNldE1heFBvaW50LCBjaHVuay5tYXhQb2ludCk7XHJcbiAgICAgICAgdGhpcy5jaHVua3MucHVzaChjaHVuayk7XHJcbiAgICAgICAgdGhpcy5jaHVua1Bvcy5wdXNoKGZyb20pO1xyXG4gICAgICAgIGxldCBsYXN0ID0gY2h1bmsudmFsdWUubGVuZ3RoIC0gMTtcclxuICAgICAgICB0aGlzLmxhc3QgPSBjaHVuay52YWx1ZVtsYXN0XTtcclxuICAgICAgICB0aGlzLmxhc3RGcm9tID0gY2h1bmsuZnJvbVtsYXN0XSArIGZyb207XHJcbiAgICAgICAgdGhpcy5sYXN0VG8gPSBjaHVuay50b1tsYXN0XSArIGZyb207XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgIEZpbmlzaCB0aGUgcmFuZ2Ugc2V0LiBSZXR1cm5zIHRoZSBuZXcgc2V0LiBUaGUgYnVpbGRlciBjYW4ndCBiZVxyXG4gICAgdXNlZCBhbnltb3JlIGFmdGVyIHRoaXMgaGFzIGJlZW4gY2FsbGVkLlxyXG4gICAgKi9cclxuICAgIGZpbmlzaCgpIHsgcmV0dXJuIHRoaXMuZmluaXNoSW5uZXIoUmFuZ2VTZXQuZW1wdHkpOyB9XHJcbiAgICAvKipcclxuICAgIEBpbnRlcm5hbFxyXG4gICAgKi9cclxuICAgIGZpbmlzaElubmVyKG5leHQpIHtcclxuICAgICAgICBpZiAodGhpcy5mcm9tLmxlbmd0aClcclxuICAgICAgICAgICAgdGhpcy5maW5pc2hDaHVuayhmYWxzZSk7XHJcbiAgICAgICAgaWYgKHRoaXMuY2h1bmtzLmxlbmd0aCA9PSAwKVxyXG4gICAgICAgICAgICByZXR1cm4gbmV4dDtcclxuICAgICAgICBsZXQgcmVzdWx0ID0gUmFuZ2VTZXQuY3JlYXRlKHRoaXMuY2h1bmtQb3MsIHRoaXMuY2h1bmtzLCB0aGlzLm5leHRMYXllciA/IHRoaXMubmV4dExheWVyLmZpbmlzaElubmVyKG5leHQpIDogbmV4dCwgdGhpcy5zZXRNYXhQb2ludCk7XHJcbiAgICAgICAgdGhpcy5mcm9tID0gbnVsbDsgLy8gTWFrZSBzdXJlIGZ1cnRoZXIgYGFkZGAgY2FsbHMgcHJvZHVjZSBlcnJvcnNcclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGZpbmRTaGFyZWRDaHVua3MoYSwgYiwgdGV4dERpZmYpIHtcclxuICAgIGxldCBpbkEgPSBuZXcgTWFwKCk7XHJcbiAgICBmb3IgKGxldCBzZXQgb2YgYSlcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNldC5jaHVuay5sZW5ndGg7IGkrKylcclxuICAgICAgICAgICAgaWYgKHNldC5jaHVua1tpXS5tYXhQb2ludCA8PSAwKVxyXG4gICAgICAgICAgICAgICAgaW5BLnNldChzZXQuY2h1bmtbaV0sIHNldC5jaHVua1Bvc1tpXSk7XHJcbiAgICBsZXQgc2hhcmVkID0gbmV3IFNldCgpO1xyXG4gICAgZm9yIChsZXQgc2V0IG9mIGIpXHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzZXQuY2h1bmsubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgbGV0IGtub3duID0gaW5BLmdldChzZXQuY2h1bmtbaV0pO1xyXG4gICAgICAgICAgICBpZiAoa25vd24gIT0gbnVsbCAmJiAodGV4dERpZmYgPyB0ZXh0RGlmZi5tYXBQb3Moa25vd24pIDoga25vd24pID09IHNldC5jaHVua1Bvc1tpXSAmJlxyXG4gICAgICAgICAgICAgICAgISh0ZXh0RGlmZiA9PT0gbnVsbCB8fCB0ZXh0RGlmZiA9PT0gdm9pZCAwID8gdm9pZCAwIDogdGV4dERpZmYudG91Y2hlc1JhbmdlKGtub3duLCBrbm93biArIHNldC5jaHVua1tpXS5sZW5ndGgpKSlcclxuICAgICAgICAgICAgICAgIHNoYXJlZC5hZGQoc2V0LmNodW5rW2ldKTtcclxuICAgICAgICB9XHJcbiAgICByZXR1cm4gc2hhcmVkO1xyXG59XHJcbmNsYXNzIExheWVyQ3Vyc29yIHtcclxuICAgIGNvbnN0cnVjdG9yKGxheWVyLCBza2lwLCBtaW5Qb2ludCwgcmFuayA9IDApIHtcclxuICAgICAgICB0aGlzLmxheWVyID0gbGF5ZXI7XHJcbiAgICAgICAgdGhpcy5za2lwID0gc2tpcDtcclxuICAgICAgICB0aGlzLm1pblBvaW50ID0gbWluUG9pbnQ7XHJcbiAgICAgICAgdGhpcy5yYW5rID0gcmFuaztcclxuICAgIH1cclxuICAgIGdldCBzdGFydFNpZGUoKSB7IHJldHVybiB0aGlzLnZhbHVlID8gdGhpcy52YWx1ZS5zdGFydFNpZGUgOiAwOyB9XHJcbiAgICBnZXQgZW5kU2lkZSgpIHsgcmV0dXJuIHRoaXMudmFsdWUgPyB0aGlzLnZhbHVlLmVuZFNpZGUgOiAwOyB9XHJcbiAgICBnb3RvKHBvcywgc2lkZSA9IC0xMDAwMDAwMDAwIC8qIEMuRmFyICovKSB7XHJcbiAgICAgICAgdGhpcy5jaHVua0luZGV4ID0gdGhpcy5yYW5nZUluZGV4ID0gMDtcclxuICAgICAgICB0aGlzLmdvdG9Jbm5lcihwb3MsIHNpZGUsIGZhbHNlKTtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuICAgIGdvdG9Jbm5lcihwb3MsIHNpZGUsIGZvcndhcmQpIHtcclxuICAgICAgICB3aGlsZSAodGhpcy5jaHVua0luZGV4IDwgdGhpcy5sYXllci5jaHVuay5sZW5ndGgpIHtcclxuICAgICAgICAgICAgbGV0IG5leHQgPSB0aGlzLmxheWVyLmNodW5rW3RoaXMuY2h1bmtJbmRleF07XHJcbiAgICAgICAgICAgIGlmICghKHRoaXMuc2tpcCAmJiB0aGlzLnNraXAuaGFzKG5leHQpIHx8XHJcbiAgICAgICAgICAgICAgICB0aGlzLmxheWVyLmNodW5rRW5kKHRoaXMuY2h1bmtJbmRleCkgPCBwb3MgfHxcclxuICAgICAgICAgICAgICAgIG5leHQubWF4UG9pbnQgPCB0aGlzLm1pblBvaW50KSlcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB0aGlzLmNodW5rSW5kZXgrKztcclxuICAgICAgICAgICAgZm9yd2FyZCA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5jaHVua0luZGV4IDwgdGhpcy5sYXllci5jaHVuay5sZW5ndGgpIHtcclxuICAgICAgICAgICAgbGV0IHJhbmdlSW5kZXggPSB0aGlzLmxheWVyLmNodW5rW3RoaXMuY2h1bmtJbmRleF0uZmluZEluZGV4KHBvcyAtIHRoaXMubGF5ZXIuY2h1bmtQb3NbdGhpcy5jaHVua0luZGV4XSwgc2lkZSwgdHJ1ZSk7XHJcbiAgICAgICAgICAgIGlmICghZm9yd2FyZCB8fCB0aGlzLnJhbmdlSW5kZXggPCByYW5nZUluZGV4KVxyXG4gICAgICAgICAgICAgICAgdGhpcy5zZXRSYW5nZUluZGV4KHJhbmdlSW5kZXgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLm5leHQoKTtcclxuICAgIH1cclxuICAgIGZvcndhcmQocG9zLCBzaWRlKSB7XHJcbiAgICAgICAgaWYgKCh0aGlzLnRvIC0gcG9zIHx8IHRoaXMuZW5kU2lkZSAtIHNpZGUpIDwgMClcclxuICAgICAgICAgICAgdGhpcy5nb3RvSW5uZXIocG9zLCBzaWRlLCB0cnVlKTtcclxuICAgIH1cclxuICAgIG5leHQoKSB7XHJcbiAgICAgICAgZm9yICg7Oykge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5jaHVua0luZGV4ID09IHRoaXMubGF5ZXIuY2h1bmsubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmZyb20gPSB0aGlzLnRvID0gMTAwMDAwMDAwMCAvKiBDLkZhciAqLztcclxuICAgICAgICAgICAgICAgIHRoaXMudmFsdWUgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgY2h1bmtQb3MgPSB0aGlzLmxheWVyLmNodW5rUG9zW3RoaXMuY2h1bmtJbmRleF0sIGNodW5rID0gdGhpcy5sYXllci5jaHVua1t0aGlzLmNodW5rSW5kZXhdO1xyXG4gICAgICAgICAgICAgICAgbGV0IGZyb20gPSBjaHVua1BvcyArIGNodW5rLmZyb21bdGhpcy5yYW5nZUluZGV4XTtcclxuICAgICAgICAgICAgICAgIHRoaXMuZnJvbSA9IGZyb207XHJcbiAgICAgICAgICAgICAgICB0aGlzLnRvID0gY2h1bmtQb3MgKyBjaHVuay50b1t0aGlzLnJhbmdlSW5kZXhdO1xyXG4gICAgICAgICAgICAgICAgdGhpcy52YWx1ZSA9IGNodW5rLnZhbHVlW3RoaXMucmFuZ2VJbmRleF07XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNldFJhbmdlSW5kZXgodGhpcy5yYW5nZUluZGV4ICsgMSk7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5taW5Qb2ludCA8IDAgfHwgdGhpcy52YWx1ZS5wb2ludCAmJiB0aGlzLnRvIC0gdGhpcy5mcm9tID49IHRoaXMubWluUG9pbnQpXHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBzZXRSYW5nZUluZGV4KGluZGV4KSB7XHJcbiAgICAgICAgaWYgKGluZGV4ID09IHRoaXMubGF5ZXIuY2h1bmtbdGhpcy5jaHVua0luZGV4XS52YWx1ZS5sZW5ndGgpIHtcclxuICAgICAgICAgICAgdGhpcy5jaHVua0luZGV4Kys7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnNraXApIHtcclxuICAgICAgICAgICAgICAgIHdoaWxlICh0aGlzLmNodW5rSW5kZXggPCB0aGlzLmxheWVyLmNodW5rLmxlbmd0aCAmJiB0aGlzLnNraXAuaGFzKHRoaXMubGF5ZXIuY2h1bmtbdGhpcy5jaHVua0luZGV4XSkpXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jaHVua0luZGV4Kys7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5yYW5nZUluZGV4ID0gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMucmFuZ2VJbmRleCA9IGluZGV4O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIG5leHRDaHVuaygpIHtcclxuICAgICAgICB0aGlzLmNodW5rSW5kZXgrKztcclxuICAgICAgICB0aGlzLnJhbmdlSW5kZXggPSAwO1xyXG4gICAgICAgIHRoaXMubmV4dCgpO1xyXG4gICAgfVxyXG4gICAgY29tcGFyZShvdGhlcikge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmZyb20gLSBvdGhlci5mcm9tIHx8IHRoaXMuc3RhcnRTaWRlIC0gb3RoZXIuc3RhcnRTaWRlIHx8IHRoaXMucmFuayAtIG90aGVyLnJhbmsgfHxcclxuICAgICAgICAgICAgdGhpcy50byAtIG90aGVyLnRvIHx8IHRoaXMuZW5kU2lkZSAtIG90aGVyLmVuZFNpZGU7XHJcbiAgICB9XHJcbn1cclxuY2xhc3MgSGVhcEN1cnNvciB7XHJcbiAgICBjb25zdHJ1Y3RvcihoZWFwKSB7XHJcbiAgICAgICAgdGhpcy5oZWFwID0gaGVhcDtcclxuICAgIH1cclxuICAgIHN0YXRpYyBmcm9tKHNldHMsIHNraXAgPSBudWxsLCBtaW5Qb2ludCA9IC0xKSB7XHJcbiAgICAgICAgbGV0IGhlYXAgPSBbXTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNldHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgZm9yIChsZXQgY3VyID0gc2V0c1tpXTsgIWN1ci5pc0VtcHR5OyBjdXIgPSBjdXIubmV4dExheWVyKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoY3VyLm1heFBvaW50ID49IG1pblBvaW50KVxyXG4gICAgICAgICAgICAgICAgICAgIGhlYXAucHVzaChuZXcgTGF5ZXJDdXJzb3IoY3VyLCBza2lwLCBtaW5Qb2ludCwgaSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBoZWFwLmxlbmd0aCA9PSAxID8gaGVhcFswXSA6IG5ldyBIZWFwQ3Vyc29yKGhlYXApO1xyXG4gICAgfVxyXG4gICAgZ2V0IHN0YXJ0U2lkZSgpIHsgcmV0dXJuIHRoaXMudmFsdWUgPyB0aGlzLnZhbHVlLnN0YXJ0U2lkZSA6IDA7IH1cclxuICAgIGdvdG8ocG9zLCBzaWRlID0gLTEwMDAwMDAwMDAgLyogQy5GYXIgKi8pIHtcclxuICAgICAgICBmb3IgKGxldCBjdXIgb2YgdGhpcy5oZWFwKVxyXG4gICAgICAgICAgICBjdXIuZ290byhwb3MsIHNpZGUpO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSB0aGlzLmhlYXAubGVuZ3RoID4+IDE7IGkgPj0gMDsgaS0tKVxyXG4gICAgICAgICAgICBoZWFwQnViYmxlKHRoaXMuaGVhcCwgaSk7XHJcbiAgICAgICAgdGhpcy5uZXh0KCk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbiAgICBmb3J3YXJkKHBvcywgc2lkZSkge1xyXG4gICAgICAgIGZvciAobGV0IGN1ciBvZiB0aGlzLmhlYXApXHJcbiAgICAgICAgICAgIGN1ci5mb3J3YXJkKHBvcywgc2lkZSk7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IHRoaXMuaGVhcC5sZW5ndGggPj4gMTsgaSA+PSAwOyBpLS0pXHJcbiAgICAgICAgICAgIGhlYXBCdWJibGUodGhpcy5oZWFwLCBpKTtcclxuICAgICAgICBpZiAoKHRoaXMudG8gLSBwb3MgfHwgdGhpcy52YWx1ZS5lbmRTaWRlIC0gc2lkZSkgPCAwKVxyXG4gICAgICAgICAgICB0aGlzLm5leHQoKTtcclxuICAgIH1cclxuICAgIG5leHQoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuaGVhcC5sZW5ndGggPT0gMCkge1xyXG4gICAgICAgICAgICB0aGlzLmZyb20gPSB0aGlzLnRvID0gMTAwMDAwMDAwMCAvKiBDLkZhciAqLztcclxuICAgICAgICAgICAgdGhpcy52YWx1ZSA9IG51bGw7XHJcbiAgICAgICAgICAgIHRoaXMucmFuayA9IC0xO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgbGV0IHRvcCA9IHRoaXMuaGVhcFswXTtcclxuICAgICAgICAgICAgdGhpcy5mcm9tID0gdG9wLmZyb207XHJcbiAgICAgICAgICAgIHRoaXMudG8gPSB0b3AudG87XHJcbiAgICAgICAgICAgIHRoaXMudmFsdWUgPSB0b3AudmFsdWU7XHJcbiAgICAgICAgICAgIHRoaXMucmFuayA9IHRvcC5yYW5rO1xyXG4gICAgICAgICAgICBpZiAodG9wLnZhbHVlKVxyXG4gICAgICAgICAgICAgICAgdG9wLm5leHQoKTtcclxuICAgICAgICAgICAgaGVhcEJ1YmJsZSh0aGlzLmhlYXAsIDApO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBoZWFwQnViYmxlKGhlYXAsIGluZGV4KSB7XHJcbiAgICBmb3IgKGxldCBjdXIgPSBoZWFwW2luZGV4XTs7KSB7XHJcbiAgICAgICAgbGV0IGNoaWxkSW5kZXggPSAoaW5kZXggPDwgMSkgKyAxO1xyXG4gICAgICAgIGlmIChjaGlsZEluZGV4ID49IGhlYXAubGVuZ3RoKVxyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICBsZXQgY2hpbGQgPSBoZWFwW2NoaWxkSW5kZXhdO1xyXG4gICAgICAgIGlmIChjaGlsZEluZGV4ICsgMSA8IGhlYXAubGVuZ3RoICYmIGNoaWxkLmNvbXBhcmUoaGVhcFtjaGlsZEluZGV4ICsgMV0pID49IDApIHtcclxuICAgICAgICAgICAgY2hpbGQgPSBoZWFwW2NoaWxkSW5kZXggKyAxXTtcclxuICAgICAgICAgICAgY2hpbGRJbmRleCsrO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoY3VyLmNvbXBhcmUoY2hpbGQpIDwgMClcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgaGVhcFtjaGlsZEluZGV4XSA9IGN1cjtcclxuICAgICAgICBoZWFwW2luZGV4XSA9IGNoaWxkO1xyXG4gICAgICAgIGluZGV4ID0gY2hpbGRJbmRleDtcclxuICAgIH1cclxufVxyXG5jbGFzcyBTcGFuQ3Vyc29yIHtcclxuICAgIGNvbnN0cnVjdG9yKHNldHMsIHNraXAsIG1pblBvaW50KSB7XHJcbiAgICAgICAgdGhpcy5taW5Qb2ludCA9IG1pblBvaW50O1xyXG4gICAgICAgIHRoaXMuYWN0aXZlID0gW107XHJcbiAgICAgICAgdGhpcy5hY3RpdmVUbyA9IFtdO1xyXG4gICAgICAgIHRoaXMuYWN0aXZlUmFuayA9IFtdO1xyXG4gICAgICAgIHRoaXMubWluQWN0aXZlID0gLTE7XHJcbiAgICAgICAgLy8gQSBjdXJyZW50bHkgYWN0aXZlIHBvaW50IHJhbmdlLCBpZiBhbnlcclxuICAgICAgICB0aGlzLnBvaW50ID0gbnVsbDtcclxuICAgICAgICB0aGlzLnBvaW50RnJvbSA9IDA7XHJcbiAgICAgICAgdGhpcy5wb2ludFJhbmsgPSAwO1xyXG4gICAgICAgIHRoaXMudG8gPSAtMTAwMDAwMDAwMCAvKiBDLkZhciAqLztcclxuICAgICAgICB0aGlzLmVuZFNpZGUgPSAwO1xyXG4gICAgICAgIC8vIFRoZSBhbW91bnQgb2Ygb3BlbiBhY3RpdmUgcmFuZ2VzIGF0IHRoZSBzdGFydCBvZiB0aGUgaXRlcmF0b3IuXHJcbiAgICAgICAgLy8gTm90IGluY2x1ZGluZyBwb2ludHMuXHJcbiAgICAgICAgdGhpcy5vcGVuU3RhcnQgPSAtMTtcclxuICAgICAgICB0aGlzLmN1cnNvciA9IEhlYXBDdXJzb3IuZnJvbShzZXRzLCBza2lwLCBtaW5Qb2ludCk7XHJcbiAgICB9XHJcbiAgICBnb3RvKHBvcywgc2lkZSA9IC0xMDAwMDAwMDAwIC8qIEMuRmFyICovKSB7XHJcbiAgICAgICAgdGhpcy5jdXJzb3IuZ290byhwb3MsIHNpZGUpO1xyXG4gICAgICAgIHRoaXMuYWN0aXZlLmxlbmd0aCA9IHRoaXMuYWN0aXZlVG8ubGVuZ3RoID0gdGhpcy5hY3RpdmVSYW5rLmxlbmd0aCA9IDA7XHJcbiAgICAgICAgdGhpcy5taW5BY3RpdmUgPSAtMTtcclxuICAgICAgICB0aGlzLnRvID0gcG9zO1xyXG4gICAgICAgIHRoaXMuZW5kU2lkZSA9IHNpZGU7XHJcbiAgICAgICAgdGhpcy5vcGVuU3RhcnQgPSAtMTtcclxuICAgICAgICB0aGlzLm5leHQoKTtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuICAgIGZvcndhcmQocG9zLCBzaWRlKSB7XHJcbiAgICAgICAgd2hpbGUgKHRoaXMubWluQWN0aXZlID4gLTEgJiYgKHRoaXMuYWN0aXZlVG9bdGhpcy5taW5BY3RpdmVdIC0gcG9zIHx8IHRoaXMuYWN0aXZlW3RoaXMubWluQWN0aXZlXS5lbmRTaWRlIC0gc2lkZSkgPCAwKVxyXG4gICAgICAgICAgICB0aGlzLnJlbW92ZUFjdGl2ZSh0aGlzLm1pbkFjdGl2ZSk7XHJcbiAgICAgICAgdGhpcy5jdXJzb3IuZm9yd2FyZChwb3MsIHNpZGUpO1xyXG4gICAgfVxyXG4gICAgcmVtb3ZlQWN0aXZlKGluZGV4KSB7XHJcbiAgICAgICAgcmVtb3ZlKHRoaXMuYWN0aXZlLCBpbmRleCk7XHJcbiAgICAgICAgcmVtb3ZlKHRoaXMuYWN0aXZlVG8sIGluZGV4KTtcclxuICAgICAgICByZW1vdmUodGhpcy5hY3RpdmVSYW5rLCBpbmRleCk7XHJcbiAgICAgICAgdGhpcy5taW5BY3RpdmUgPSBmaW5kTWluSW5kZXgodGhpcy5hY3RpdmUsIHRoaXMuYWN0aXZlVG8pO1xyXG4gICAgfVxyXG4gICAgYWRkQWN0aXZlKHRyYWNrT3Blbikge1xyXG4gICAgICAgIGxldCBpID0gMCwgeyB2YWx1ZSwgdG8sIHJhbmsgfSA9IHRoaXMuY3Vyc29yO1xyXG4gICAgICAgIHdoaWxlIChpIDwgdGhpcy5hY3RpdmVSYW5rLmxlbmd0aCAmJiB0aGlzLmFjdGl2ZVJhbmtbaV0gPD0gcmFuaylcclxuICAgICAgICAgICAgaSsrO1xyXG4gICAgICAgIGluc2VydCh0aGlzLmFjdGl2ZSwgaSwgdmFsdWUpO1xyXG4gICAgICAgIGluc2VydCh0aGlzLmFjdGl2ZVRvLCBpLCB0byk7XHJcbiAgICAgICAgaW5zZXJ0KHRoaXMuYWN0aXZlUmFuaywgaSwgcmFuayk7XHJcbiAgICAgICAgaWYgKHRyYWNrT3BlbilcclxuICAgICAgICAgICAgaW5zZXJ0KHRyYWNrT3BlbiwgaSwgdGhpcy5jdXJzb3IuZnJvbSk7XHJcbiAgICAgICAgdGhpcy5taW5BY3RpdmUgPSBmaW5kTWluSW5kZXgodGhpcy5hY3RpdmUsIHRoaXMuYWN0aXZlVG8pO1xyXG4gICAgfVxyXG4gICAgLy8gQWZ0ZXIgY2FsbGluZyB0aGlzLCBpZiBgdGhpcy5wb2ludGAgIT0gbnVsbCwgdGhlIG5leHQgcmFuZ2UgaXMgYVxyXG4gICAgLy8gcG9pbnQuIE90aGVyd2lzZSwgaXQncyBhIHJlZ3VsYXIgcmFuZ2UsIGNvdmVyZWQgYnkgYHRoaXMuYWN0aXZlYC5cclxuICAgIG5leHQoKSB7XHJcbiAgICAgICAgbGV0IGZyb20gPSB0aGlzLnRvLCB3YXNQb2ludCA9IHRoaXMucG9pbnQ7XHJcbiAgICAgICAgdGhpcy5wb2ludCA9IG51bGw7XHJcbiAgICAgICAgbGV0IHRyYWNrT3BlbiA9IHRoaXMub3BlblN0YXJ0IDwgMCA/IFtdIDogbnVsbDtcclxuICAgICAgICBmb3IgKDs7KSB7XHJcbiAgICAgICAgICAgIGxldCBhID0gdGhpcy5taW5BY3RpdmU7XHJcbiAgICAgICAgICAgIGlmIChhID4gLTEgJiYgKHRoaXMuYWN0aXZlVG9bYV0gLSB0aGlzLmN1cnNvci5mcm9tIHx8IHRoaXMuYWN0aXZlW2FdLmVuZFNpZGUgLSB0aGlzLmN1cnNvci5zdGFydFNpZGUpIDwgMCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuYWN0aXZlVG9bYV0gPiBmcm9tKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50byA9IHRoaXMuYWN0aXZlVG9bYV07XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbmRTaWRlID0gdGhpcy5hY3RpdmVbYV0uZW5kU2lkZTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlQWN0aXZlKGEpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRyYWNrT3BlbilcclxuICAgICAgICAgICAgICAgICAgICByZW1vdmUodHJhY2tPcGVuLCBhKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICghdGhpcy5jdXJzb3IudmFsdWUpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMudG8gPSB0aGlzLmVuZFNpZGUgPSAxMDAwMDAwMDAwIC8qIEMuRmFyICovO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5jdXJzb3IuZnJvbSA+IGZyb20pIHtcclxuICAgICAgICAgICAgICAgIHRoaXMudG8gPSB0aGlzLmN1cnNvci5mcm9tO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5lbmRTaWRlID0gdGhpcy5jdXJzb3Iuc3RhcnRTaWRlO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgbmV4dFZhbCA9IHRoaXMuY3Vyc29yLnZhbHVlO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFuZXh0VmFsLnBvaW50KSB7IC8vIE9wZW5pbmcgYSByYW5nZVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWRkQWN0aXZlKHRyYWNrT3Blbik7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jdXJzb3IubmV4dCgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAod2FzUG9pbnQgJiYgdGhpcy5jdXJzb3IudG8gPT0gdGhpcy50byAmJiB0aGlzLmN1cnNvci5mcm9tIDwgdGhpcy5jdXJzb3IudG8pIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBJZ25vcmUgYW55IG5vbi1lbXB0eSBwb2ludHMgdGhhdCBlbmQgcHJlY2lzZWx5IGF0IHRoZSBlbmQgb2YgdGhlIHByZXYgcG9pbnRcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmN1cnNvci5uZXh0KCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHsgLy8gTmV3IHBvaW50XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wb2ludCA9IG5leHRWYWw7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wb2ludEZyb20gPSB0aGlzLmN1cnNvci5mcm9tO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucG9pbnRSYW5rID0gdGhpcy5jdXJzb3IucmFuaztcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnRvID0gdGhpcy5jdXJzb3IudG87XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbmRTaWRlID0gbmV4dFZhbC5lbmRTaWRlO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY3Vyc29yLm5leHQoKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmZvcndhcmQodGhpcy50bywgdGhpcy5lbmRTaWRlKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodHJhY2tPcGVuKSB7XHJcbiAgICAgICAgICAgIHRoaXMub3BlblN0YXJ0ID0gMDtcclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IHRyYWNrT3Blbi5sZW5ndGggLSAxOyBpID49IDAgJiYgdHJhY2tPcGVuW2ldIDwgZnJvbTsgaS0tKVxyXG4gICAgICAgICAgICAgICAgdGhpcy5vcGVuU3RhcnQrKztcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBhY3RpdmVGb3JQb2ludCh0bykge1xyXG4gICAgICAgIGlmICghdGhpcy5hY3RpdmUubGVuZ3RoKVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hY3RpdmU7XHJcbiAgICAgICAgbGV0IGFjdGl2ZSA9IFtdO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSB0aGlzLmFjdGl2ZS5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5hY3RpdmVSYW5rW2ldIDwgdGhpcy5wb2ludFJhbmspXHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgaWYgKHRoaXMuYWN0aXZlVG9baV0gPiB0byB8fCB0aGlzLmFjdGl2ZVRvW2ldID09IHRvICYmIHRoaXMuYWN0aXZlW2ldLmVuZFNpZGUgPj0gdGhpcy5wb2ludC5lbmRTaWRlKVxyXG4gICAgICAgICAgICAgICAgYWN0aXZlLnB1c2godGhpcy5hY3RpdmVbaV0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gYWN0aXZlLnJldmVyc2UoKTtcclxuICAgIH1cclxuICAgIG9wZW5FbmQodG8pIHtcclxuICAgICAgICBsZXQgb3BlbiA9IDA7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IHRoaXMuYWN0aXZlVG8ubGVuZ3RoIC0gMTsgaSA+PSAwICYmIHRoaXMuYWN0aXZlVG9baV0gPiB0bzsgaS0tKVxyXG4gICAgICAgICAgICBvcGVuKys7XHJcbiAgICAgICAgcmV0dXJuIG9wZW47XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gY29tcGFyZShhLCBzdGFydEEsIGIsIHN0YXJ0QiwgbGVuZ3RoLCBjb21wYXJhdG9yKSB7XHJcbiAgICBhLmdvdG8oc3RhcnRBKTtcclxuICAgIGIuZ290byhzdGFydEIpO1xyXG4gICAgbGV0IGVuZEIgPSBzdGFydEIgKyBsZW5ndGg7XHJcbiAgICBsZXQgcG9zID0gc3RhcnRCLCBkUG9zID0gc3RhcnRCIC0gc3RhcnRBO1xyXG4gICAgZm9yICg7Oykge1xyXG4gICAgICAgIGxldCBkaWZmID0gKGEudG8gKyBkUG9zKSAtIGIudG8gfHwgYS5lbmRTaWRlIC0gYi5lbmRTaWRlO1xyXG4gICAgICAgIGxldCBlbmQgPSBkaWZmIDwgMCA/IGEudG8gKyBkUG9zIDogYi50bywgY2xpcEVuZCA9IE1hdGgubWluKGVuZCwgZW5kQik7XHJcbiAgICAgICAgaWYgKGEucG9pbnQgfHwgYi5wb2ludCkge1xyXG4gICAgICAgICAgICBpZiAoIShhLnBvaW50ICYmIGIucG9pbnQgJiYgKGEucG9pbnQgPT0gYi5wb2ludCB8fCBhLnBvaW50LmVxKGIucG9pbnQpKSAmJlxyXG4gICAgICAgICAgICAgICAgc2FtZVZhbHVlcyhhLmFjdGl2ZUZvclBvaW50KGEudG8gKyBkUG9zKSwgYi5hY3RpdmVGb3JQb2ludChiLnRvKSkpKVxyXG4gICAgICAgICAgICAgICAgY29tcGFyYXRvci5jb21wYXJlUG9pbnQocG9zLCBjbGlwRW5kLCBhLnBvaW50LCBiLnBvaW50KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGlmIChjbGlwRW5kID4gcG9zICYmICFzYW1lVmFsdWVzKGEuYWN0aXZlLCBiLmFjdGl2ZSkpXHJcbiAgICAgICAgICAgICAgICBjb21wYXJhdG9yLmNvbXBhcmVSYW5nZShwb3MsIGNsaXBFbmQsIGEuYWN0aXZlLCBiLmFjdGl2ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChlbmQgPiBlbmRCKVxyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICBwb3MgPSBlbmQ7XHJcbiAgICAgICAgaWYgKGRpZmYgPD0gMClcclxuICAgICAgICAgICAgYS5uZXh0KCk7XHJcbiAgICAgICAgaWYgKGRpZmYgPj0gMClcclxuICAgICAgICAgICAgYi5uZXh0KCk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gc2FtZVZhbHVlcyhhLCBiKSB7XHJcbiAgICBpZiAoYS5sZW5ndGggIT0gYi5sZW5ndGgpXHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhLmxlbmd0aDsgaSsrKVxyXG4gICAgICAgIGlmIChhW2ldICE9IGJbaV0gJiYgIWFbaV0uZXEoYltpXSkpXHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIHJldHVybiB0cnVlO1xyXG59XHJcbmZ1bmN0aW9uIHJlbW92ZShhcnJheSwgaW5kZXgpIHtcclxuICAgIGZvciAobGV0IGkgPSBpbmRleCwgZSA9IGFycmF5Lmxlbmd0aCAtIDE7IGkgPCBlOyBpKyspXHJcbiAgICAgICAgYXJyYXlbaV0gPSBhcnJheVtpICsgMV07XHJcbiAgICBhcnJheS5wb3AoKTtcclxufVxyXG5mdW5jdGlvbiBpbnNlcnQoYXJyYXksIGluZGV4LCB2YWx1ZSkge1xyXG4gICAgZm9yIChsZXQgaSA9IGFycmF5Lmxlbmd0aCAtIDE7IGkgPj0gaW5kZXg7IGktLSlcclxuICAgICAgICBhcnJheVtpICsgMV0gPSBhcnJheVtpXTtcclxuICAgIGFycmF5W2luZGV4XSA9IHZhbHVlO1xyXG59XHJcbmZ1bmN0aW9uIGZpbmRNaW5JbmRleCh2YWx1ZSwgYXJyYXkpIHtcclxuICAgIGxldCBmb3VuZCA9IC0xLCBmb3VuZFBvcyA9IDEwMDAwMDAwMDAgLyogQy5GYXIgKi87XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSsrKVxyXG4gICAgICAgIGlmICgoYXJyYXlbaV0gLSBmb3VuZFBvcyB8fCB2YWx1ZVtpXS5lbmRTaWRlIC0gdmFsdWVbZm91bmRdLmVuZFNpZGUpIDwgMCkge1xyXG4gICAgICAgICAgICBmb3VuZCA9IGk7XHJcbiAgICAgICAgICAgIGZvdW5kUG9zID0gYXJyYXlbaV07XHJcbiAgICAgICAgfVxyXG4gICAgcmV0dXJuIGZvdW5kO1xyXG59XHJcblxyXG4vKipcclxuQ291bnQgdGhlIGNvbHVtbiBwb3NpdGlvbiBhdCB0aGUgZ2l2ZW4gb2Zmc2V0IGludG8gdGhlIHN0cmluZyxcclxudGFraW5nIGV4dGVuZGluZyBjaGFyYWN0ZXJzIGFuZCB0YWIgc2l6ZSBpbnRvIGFjY291bnQuXHJcbiovXHJcbmZ1bmN0aW9uIGNvdW50Q29sdW1uKHN0cmluZywgdGFiU2l6ZSwgdG8gPSBzdHJpbmcubGVuZ3RoKSB7XHJcbiAgICBsZXQgbiA9IDA7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRvOykge1xyXG4gICAgICAgIGlmIChzdHJpbmcuY2hhckNvZGVBdChpKSA9PSA5KSB7XHJcbiAgICAgICAgICAgIG4gKz0gdGFiU2l6ZSAtIChuICUgdGFiU2l6ZSk7XHJcbiAgICAgICAgICAgIGkrKztcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIG4rKztcclxuICAgICAgICAgICAgaSA9IGZpbmRDbHVzdGVyQnJlYWsoc3RyaW5nLCBpKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbjtcclxufVxyXG4vKipcclxuRmluZCB0aGUgb2Zmc2V0IHRoYXQgY29ycmVzcG9uZHMgdG8gdGhlIGdpdmVuIGNvbHVtbiBwb3NpdGlvbiBpbiBhXHJcbnN0cmluZywgdGFraW5nIGV4dGVuZGluZyBjaGFyYWN0ZXJzIGFuZCB0YWIgc2l6ZSBpbnRvIGFjY291bnQuIEJ5XHJcbmRlZmF1bHQsIHRoZSBzdHJpbmcgbGVuZ3RoIGlzIHJldHVybmVkIHdoZW4gaXQgaXMgdG9vIHNob3J0IHRvXHJcbnJlYWNoIHRoZSBjb2x1bW4uIFBhc3MgYHN0cmljdGAgdHJ1ZSB0byBtYWtlIGl0IHJldHVybiAtMSBpbiB0aGF0XHJcbnNpdHVhdGlvbi5cclxuKi9cclxuZnVuY3Rpb24gZmluZENvbHVtbihzdHJpbmcsIGNvbCwgdGFiU2l6ZSwgc3RyaWN0KSB7XHJcbiAgICBmb3IgKGxldCBpID0gMCwgbiA9IDA7Oykge1xyXG4gICAgICAgIGlmIChuID49IGNvbClcclxuICAgICAgICAgICAgcmV0dXJuIGk7XHJcbiAgICAgICAgaWYgKGkgPT0gc3RyaW5nLmxlbmd0aClcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgbiArPSBzdHJpbmcuY2hhckNvZGVBdChpKSA9PSA5ID8gdGFiU2l6ZSAtIChuICUgdGFiU2l6ZSkgOiAxO1xyXG4gICAgICAgIGkgPSBmaW5kQ2x1c3RlckJyZWFrKHN0cmluZywgaSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gc3RyaWN0ID09PSB0cnVlID8gLTEgOiBzdHJpbmcubGVuZ3RoO1xyXG59XHJcblxyXG5leHBvcnQgeyBBbm5vdGF0aW9uLCBBbm5vdGF0aW9uVHlwZSwgQ2hhbmdlRGVzYywgQ2hhbmdlU2V0LCBDaGFyQ2F0ZWdvcnksIENvbXBhcnRtZW50LCBFZGl0b3JTZWxlY3Rpb24sIEVkaXRvclN0YXRlLCBGYWNldCwgTGluZSwgTWFwTW9kZSwgUHJlYywgUmFuZ2UsIFJhbmdlU2V0LCBSYW5nZVNldEJ1aWxkZXIsIFJhbmdlVmFsdWUsIFNlbGVjdGlvblJhbmdlLCBTdGF0ZUVmZmVjdCwgU3RhdGVFZmZlY3RUeXBlLCBTdGF0ZUZpZWxkLCBUZXh0LCBUcmFuc2FjdGlvbiwgY29kZVBvaW50QXQsIGNvZGVQb2ludFNpemUsIGNvbWJpbmVDb25maWcsIGNvdW50Q29sdW1uLCBmaW5kQ2x1c3RlckJyZWFrLCBmaW5kQ29sdW1uLCBmcm9tQ29kZVBvaW50IH07XHJcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@codemirror/state/dist/index.js\n"));

/***/ }),

/***/ "./node_modules/@codemirror/theme-one-dark/dist/index.js":
/*!***************************************************************!*\
  !*** ./node_modules/@codemirror/theme-one-dark/dist/index.js ***!
  \***************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"color\": function() { return /* binding */ color; },\n/* harmony export */   \"oneDark\": function() { return /* binding */ oneDark; },\n/* harmony export */   \"oneDarkHighlightStyle\": function() { return /* binding */ oneDarkHighlightStyle; },\n/* harmony export */   \"oneDarkTheme\": function() { return /* binding */ oneDarkTheme; }\n/* harmony export */ });\n/* harmony import */ var _codemirror_view__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @codemirror/view */ \"./node_modules/@codemirror/view/dist/index.js\");\n/* harmony import */ var _codemirror_language__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @codemirror/language */ \"./node_modules/@codemirror/language/dist/index.js\");\n/* harmony import */ var _lezer_highlight__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lezer/highlight */ \"./node_modules/@lezer/highlight/dist/index.js\");\n\r\n\r\n\r\n\r\n// Using https://github.com/one-dark/vscode-one-dark-theme/ as reference for the colors\r\nconst chalky = \"#e5c07b\", coral = \"#e06c75\", cyan = \"#56b6c2\", invalid = \"#ffffff\", ivory = \"#abb2bf\", stone = \"#7d8799\", // Brightened compared to original to increase contrast\r\nmalibu = \"#61afef\", sage = \"#98c379\", whiskey = \"#d19a66\", violet = \"#c678dd\", darkBackground = \"#21252b\", highlightBackground = \"#2c313a\", background = \"#282c34\", tooltipBackground = \"#353a42\", selection = \"#3E4451\", cursor = \"#528bff\";\r\n/**\r\nThe colors used in the theme, as CSS color strings.\r\n*/\r\nconst color = {\r\n    chalky,\r\n    coral,\r\n    cyan,\r\n    invalid,\r\n    ivory,\r\n    stone,\r\n    malibu,\r\n    sage,\r\n    whiskey,\r\n    violet,\r\n    darkBackground,\r\n    highlightBackground,\r\n    background,\r\n    tooltipBackground,\r\n    selection,\r\n    cursor\r\n};\r\n/**\r\nThe editor theme styles for One Dark.\r\n*/\r\nconst oneDarkTheme = /*@__PURE__*/_codemirror_view__WEBPACK_IMPORTED_MODULE_1__.EditorView.theme({\r\n    \"&\": {\r\n        color: ivory,\r\n        backgroundColor: background\r\n    },\r\n    \".cm-content\": {\r\n        caretColor: cursor\r\n    },\r\n    \".cm-cursor, .cm-dropCursor\": { borderLeftColor: cursor },\r\n    \"&.cm-focused .cm-selectionBackground, .cm-selectionBackground, .cm-content ::selection\": { backgroundColor: selection },\r\n    \".cm-panels\": { backgroundColor: darkBackground, color: ivory },\r\n    \".cm-panels.cm-panels-top\": { borderBottom: \"2px solid black\" },\r\n    \".cm-panels.cm-panels-bottom\": { borderTop: \"2px solid black\" },\r\n    \".cm-searchMatch\": {\r\n        backgroundColor: \"#72a1ff59\",\r\n        outline: \"1px solid #457dff\"\r\n    },\r\n    \".cm-searchMatch.cm-searchMatch-selected\": {\r\n        backgroundColor: \"#6199ff2f\"\r\n    },\r\n    \".cm-activeLine\": { backgroundColor: \"#6699ff0b\" },\r\n    \".cm-selectionMatch\": { backgroundColor: \"#aafe661a\" },\r\n    \"&.cm-focused .cm-matchingBracket, &.cm-focused .cm-nonmatchingBracket\": {\r\n        backgroundColor: \"#bad0f847\",\r\n        outline: \"1px solid #515a6b\"\r\n    },\r\n    \".cm-gutters\": {\r\n        backgroundColor: background,\r\n        color: stone,\r\n        border: \"none\"\r\n    },\r\n    \".cm-activeLineGutter\": {\r\n        backgroundColor: highlightBackground\r\n    },\r\n    \".cm-foldPlaceholder\": {\r\n        backgroundColor: \"transparent\",\r\n        border: \"none\",\r\n        color: \"#ddd\"\r\n    },\r\n    \".cm-tooltip\": {\r\n        border: \"none\",\r\n        backgroundColor: tooltipBackground\r\n    },\r\n    \".cm-tooltip .cm-tooltip-arrow:before\": {\r\n        borderTopColor: \"transparent\",\r\n        borderBottomColor: \"transparent\"\r\n    },\r\n    \".cm-tooltip .cm-tooltip-arrow:after\": {\r\n        borderTopColor: tooltipBackground,\r\n        borderBottomColor: tooltipBackground\r\n    },\r\n    \".cm-tooltip-autocomplete\": {\r\n        \"& > ul > li[aria-selected]\": {\r\n            backgroundColor: highlightBackground,\r\n            color: ivory\r\n        }\r\n    }\r\n}, { dark: true });\r\n/**\r\nThe highlighting style for code in the One Dark theme.\r\n*/\r\nconst oneDarkHighlightStyle = /*@__PURE__*/_codemirror_language__WEBPACK_IMPORTED_MODULE_2__.HighlightStyle.define([\r\n    { tag: _lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.keyword,\r\n        color: violet },\r\n    { tag: [_lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.name, _lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.deleted, _lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.character, _lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.propertyName, _lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.macroName],\r\n        color: coral },\r\n    { tag: [/*@__PURE__*/_lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags[\"function\"](_lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.variableName), _lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.labelName],\r\n        color: malibu },\r\n    { tag: [_lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.color, /*@__PURE__*/_lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.constant(_lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.name), /*@__PURE__*/_lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.standard(_lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.name)],\r\n        color: whiskey },\r\n    { tag: [/*@__PURE__*/_lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.definition(_lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.name), _lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.separator],\r\n        color: ivory },\r\n    { tag: [_lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.typeName, _lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.className, _lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.number, _lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.changed, _lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.annotation, _lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.modifier, _lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.self, _lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.namespace],\r\n        color: chalky },\r\n    { tag: [_lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.operator, _lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.operatorKeyword, _lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.url, _lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.escape, _lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.regexp, _lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.link, /*@__PURE__*/_lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.special(_lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.string)],\r\n        color: cyan },\r\n    { tag: [_lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.meta, _lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.comment],\r\n        color: stone },\r\n    { tag: _lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.strong,\r\n        fontWeight: \"bold\" },\r\n    { tag: _lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.emphasis,\r\n        fontStyle: \"italic\" },\r\n    { tag: _lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.strikethrough,\r\n        textDecoration: \"line-through\" },\r\n    { tag: _lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.link,\r\n        color: stone,\r\n        textDecoration: \"underline\" },\r\n    { tag: _lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.heading,\r\n        fontWeight: \"bold\",\r\n        color: coral },\r\n    { tag: [_lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.atom, _lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.bool, /*@__PURE__*/_lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.special(_lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.variableName)],\r\n        color: whiskey },\r\n    { tag: [_lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.processingInstruction, _lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.string, _lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.inserted],\r\n        color: sage },\r\n    { tag: _lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.invalid,\r\n        color: invalid },\r\n]);\r\n/**\r\nExtension to enable the One Dark theme (both the editor theme and\r\nthe highlight style).\r\n*/\r\nconst oneDark = [oneDarkTheme, /*@__PURE__*/(0,_codemirror_language__WEBPACK_IMPORTED_MODULE_2__.syntaxHighlighting)(oneDarkHighlightStyle)];\r\n\r\n\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGNvZGVtaXJyb3IvdGhlbWUtb25lLWRhcmsvZGlzdC9pbmRleC5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQThDO0FBQzRCO0FBQ2xDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLDhEQUFnQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTCxvQ0FBb0MseUJBQXlCO0FBQzdELGdHQUFnRyw0QkFBNEI7QUFDNUgsb0JBQW9CLCtDQUErQztBQUNuRSxrQ0FBa0MsaUNBQWlDO0FBQ25FLHFDQUFxQyw4QkFBOEI7QUFDbkU7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsd0JBQXdCLDhCQUE4QjtBQUN0RCw0QkFBNEIsOEJBQThCO0FBQzFEO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsSUFBSSxZQUFZO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyx1RUFBcUI7QUFDaEUsTUFBTSxLQUFLLDBEQUFZO0FBQ3ZCLHVCQUF1QjtBQUN2QixNQUFNLE1BQU0sdURBQVMsRUFBRSwwREFBWSxFQUFFLDREQUFjLEVBQUUsK0RBQWlCLEVBQUUsNERBQWM7QUFDdEYsc0JBQXNCO0FBQ3RCLE1BQU0sbUJBQW1CLDhEQUFhLENBQUMsK0RBQWlCLEdBQUcsNERBQWM7QUFDekUsdUJBQXVCO0FBQ3ZCLE1BQU0sTUFBTSx3REFBVSxlQUFlLDJEQUFhLENBQUMsdURBQVMsZ0JBQWdCLDJEQUFhLENBQUMsdURBQVM7QUFDbkcsd0JBQXdCO0FBQ3hCLE1BQU0sbUJBQW1CLDZEQUFlLENBQUMsdURBQVMsR0FBRyw0REFBYztBQUNuRSxzQkFBc0I7QUFDdEIsTUFBTSxNQUFNLDJEQUFhLEVBQUUsNERBQWMsRUFBRSx5REFBVyxFQUFFLDBEQUFZLEVBQUUsNkRBQWUsRUFBRSwyREFBYSxFQUFFLHVEQUFTLEVBQUUsNERBQWM7QUFDL0gsdUJBQXVCO0FBQ3ZCLE1BQU0sTUFBTSwyREFBYSxFQUFFLGtFQUFvQixFQUFFLHNEQUFRLEVBQUUseURBQVcsRUFBRSx5REFBVyxFQUFFLHVEQUFTLGVBQWUsMERBQVksQ0FBQyx5REFBVztBQUNySSxxQkFBcUI7QUFDckIsTUFBTSxNQUFNLHVEQUFTLEVBQUUsMERBQVk7QUFDbkMsc0JBQXNCO0FBQ3RCLE1BQU0sS0FBSyx5REFBVztBQUN0Qiw0QkFBNEI7QUFDNUIsTUFBTSxLQUFLLDJEQUFhO0FBQ3hCLDZCQUE2QjtBQUM3QixNQUFNLEtBQUssZ0VBQWtCO0FBQzdCLHdDQUF3QztBQUN4QyxNQUFNLEtBQUssdURBQVM7QUFDcEI7QUFDQSxxQ0FBcUM7QUFDckMsTUFBTSxLQUFLLDBEQUFZO0FBQ3ZCO0FBQ0Esc0JBQXNCO0FBQ3RCLE1BQU0sTUFBTSx1REFBUyxFQUFFLHVEQUFTLGVBQWUsMERBQVksQ0FBQywrREFBaUI7QUFDN0Usd0JBQXdCO0FBQ3hCLE1BQU0sTUFBTSx3RUFBMEIsRUFBRSx5REFBVyxFQUFFLDJEQUFhO0FBQ2xFLHFCQUFxQjtBQUNyQixNQUFNLEtBQUssMERBQVk7QUFDdkIsd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsd0VBQWtCO0FBQzlEO0FBQytEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AY29kZW1pcnJvci90aGVtZS1vbmUtZGFyay9kaXN0L2luZGV4LmpzPzM2YzUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgRWRpdG9yVmlldyB9IGZyb20gJ0Bjb2RlbWlycm9yL3ZpZXcnO1xyXG5pbXBvcnQgeyBIaWdobGlnaHRTdHlsZSwgc3ludGF4SGlnaGxpZ2h0aW5nIH0gZnJvbSAnQGNvZGVtaXJyb3IvbGFuZ3VhZ2UnO1xyXG5pbXBvcnQgeyB0YWdzIH0gZnJvbSAnQGxlemVyL2hpZ2hsaWdodCc7XHJcblxyXG4vLyBVc2luZyBodHRwczovL2dpdGh1Yi5jb20vb25lLWRhcmsvdnNjb2RlLW9uZS1kYXJrLXRoZW1lLyBhcyByZWZlcmVuY2UgZm9yIHRoZSBjb2xvcnNcclxuY29uc3QgY2hhbGt5ID0gXCIjZTVjMDdiXCIsIGNvcmFsID0gXCIjZTA2Yzc1XCIsIGN5YW4gPSBcIiM1NmI2YzJcIiwgaW52YWxpZCA9IFwiI2ZmZmZmZlwiLCBpdm9yeSA9IFwiI2FiYjJiZlwiLCBzdG9uZSA9IFwiIzdkODc5OVwiLCAvLyBCcmlnaHRlbmVkIGNvbXBhcmVkIHRvIG9yaWdpbmFsIHRvIGluY3JlYXNlIGNvbnRyYXN0XHJcbm1hbGlidSA9IFwiIzYxYWZlZlwiLCBzYWdlID0gXCIjOThjMzc5XCIsIHdoaXNrZXkgPSBcIiNkMTlhNjZcIiwgdmlvbGV0ID0gXCIjYzY3OGRkXCIsIGRhcmtCYWNrZ3JvdW5kID0gXCIjMjEyNTJiXCIsIGhpZ2hsaWdodEJhY2tncm91bmQgPSBcIiMyYzMxM2FcIiwgYmFja2dyb3VuZCA9IFwiIzI4MmMzNFwiLCB0b29sdGlwQmFja2dyb3VuZCA9IFwiIzM1M2E0MlwiLCBzZWxlY3Rpb24gPSBcIiMzRTQ0NTFcIiwgY3Vyc29yID0gXCIjNTI4YmZmXCI7XHJcbi8qKlxyXG5UaGUgY29sb3JzIHVzZWQgaW4gdGhlIHRoZW1lLCBhcyBDU1MgY29sb3Igc3RyaW5ncy5cclxuKi9cclxuY29uc3QgY29sb3IgPSB7XHJcbiAgICBjaGFsa3ksXHJcbiAgICBjb3JhbCxcclxuICAgIGN5YW4sXHJcbiAgICBpbnZhbGlkLFxyXG4gICAgaXZvcnksXHJcbiAgICBzdG9uZSxcclxuICAgIG1hbGlidSxcclxuICAgIHNhZ2UsXHJcbiAgICB3aGlza2V5LFxyXG4gICAgdmlvbGV0LFxyXG4gICAgZGFya0JhY2tncm91bmQsXHJcbiAgICBoaWdobGlnaHRCYWNrZ3JvdW5kLFxyXG4gICAgYmFja2dyb3VuZCxcclxuICAgIHRvb2x0aXBCYWNrZ3JvdW5kLFxyXG4gICAgc2VsZWN0aW9uLFxyXG4gICAgY3Vyc29yXHJcbn07XHJcbi8qKlxyXG5UaGUgZWRpdG9yIHRoZW1lIHN0eWxlcyBmb3IgT25lIERhcmsuXHJcbiovXHJcbmNvbnN0IG9uZURhcmtUaGVtZSA9IC8qQF9fUFVSRV9fKi9FZGl0b3JWaWV3LnRoZW1lKHtcclxuICAgIFwiJlwiOiB7XHJcbiAgICAgICAgY29sb3I6IGl2b3J5LFxyXG4gICAgICAgIGJhY2tncm91bmRDb2xvcjogYmFja2dyb3VuZFxyXG4gICAgfSxcclxuICAgIFwiLmNtLWNvbnRlbnRcIjoge1xyXG4gICAgICAgIGNhcmV0Q29sb3I6IGN1cnNvclxyXG4gICAgfSxcclxuICAgIFwiLmNtLWN1cnNvciwgLmNtLWRyb3BDdXJzb3JcIjogeyBib3JkZXJMZWZ0Q29sb3I6IGN1cnNvciB9LFxyXG4gICAgXCImLmNtLWZvY3VzZWQgLmNtLXNlbGVjdGlvbkJhY2tncm91bmQsIC5jbS1zZWxlY3Rpb25CYWNrZ3JvdW5kLCAuY20tY29udGVudCA6OnNlbGVjdGlvblwiOiB7IGJhY2tncm91bmRDb2xvcjogc2VsZWN0aW9uIH0sXHJcbiAgICBcIi5jbS1wYW5lbHNcIjogeyBiYWNrZ3JvdW5kQ29sb3I6IGRhcmtCYWNrZ3JvdW5kLCBjb2xvcjogaXZvcnkgfSxcclxuICAgIFwiLmNtLXBhbmVscy5jbS1wYW5lbHMtdG9wXCI6IHsgYm9yZGVyQm90dG9tOiBcIjJweCBzb2xpZCBibGFja1wiIH0sXHJcbiAgICBcIi5jbS1wYW5lbHMuY20tcGFuZWxzLWJvdHRvbVwiOiB7IGJvcmRlclRvcDogXCIycHggc29saWQgYmxhY2tcIiB9LFxyXG4gICAgXCIuY20tc2VhcmNoTWF0Y2hcIjoge1xyXG4gICAgICAgIGJhY2tncm91bmRDb2xvcjogXCIjNzJhMWZmNTlcIixcclxuICAgICAgICBvdXRsaW5lOiBcIjFweCBzb2xpZCAjNDU3ZGZmXCJcclxuICAgIH0sXHJcbiAgICBcIi5jbS1zZWFyY2hNYXRjaC5jbS1zZWFyY2hNYXRjaC1zZWxlY3RlZFwiOiB7XHJcbiAgICAgICAgYmFja2dyb3VuZENvbG9yOiBcIiM2MTk5ZmYyZlwiXHJcbiAgICB9LFxyXG4gICAgXCIuY20tYWN0aXZlTGluZVwiOiB7IGJhY2tncm91bmRDb2xvcjogXCIjNjY5OWZmMGJcIiB9LFxyXG4gICAgXCIuY20tc2VsZWN0aW9uTWF0Y2hcIjogeyBiYWNrZ3JvdW5kQ29sb3I6IFwiI2FhZmU2NjFhXCIgfSxcclxuICAgIFwiJi5jbS1mb2N1c2VkIC5jbS1tYXRjaGluZ0JyYWNrZXQsICYuY20tZm9jdXNlZCAuY20tbm9ubWF0Y2hpbmdCcmFja2V0XCI6IHtcclxuICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IFwiI2JhZDBmODQ3XCIsXHJcbiAgICAgICAgb3V0bGluZTogXCIxcHggc29saWQgIzUxNWE2YlwiXHJcbiAgICB9LFxyXG4gICAgXCIuY20tZ3V0dGVyc1wiOiB7XHJcbiAgICAgICAgYmFja2dyb3VuZENvbG9yOiBiYWNrZ3JvdW5kLFxyXG4gICAgICAgIGNvbG9yOiBzdG9uZSxcclxuICAgICAgICBib3JkZXI6IFwibm9uZVwiXHJcbiAgICB9LFxyXG4gICAgXCIuY20tYWN0aXZlTGluZUd1dHRlclwiOiB7XHJcbiAgICAgICAgYmFja2dyb3VuZENvbG9yOiBoaWdobGlnaHRCYWNrZ3JvdW5kXHJcbiAgICB9LFxyXG4gICAgXCIuY20tZm9sZFBsYWNlaG9sZGVyXCI6IHtcclxuICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IFwidHJhbnNwYXJlbnRcIixcclxuICAgICAgICBib3JkZXI6IFwibm9uZVwiLFxyXG4gICAgICAgIGNvbG9yOiBcIiNkZGRcIlxyXG4gICAgfSxcclxuICAgIFwiLmNtLXRvb2x0aXBcIjoge1xyXG4gICAgICAgIGJvcmRlcjogXCJub25lXCIsXHJcbiAgICAgICAgYmFja2dyb3VuZENvbG9yOiB0b29sdGlwQmFja2dyb3VuZFxyXG4gICAgfSxcclxuICAgIFwiLmNtLXRvb2x0aXAgLmNtLXRvb2x0aXAtYXJyb3c6YmVmb3JlXCI6IHtcclxuICAgICAgICBib3JkZXJUb3BDb2xvcjogXCJ0cmFuc3BhcmVudFwiLFxyXG4gICAgICAgIGJvcmRlckJvdHRvbUNvbG9yOiBcInRyYW5zcGFyZW50XCJcclxuICAgIH0sXHJcbiAgICBcIi5jbS10b29sdGlwIC5jbS10b29sdGlwLWFycm93OmFmdGVyXCI6IHtcclxuICAgICAgICBib3JkZXJUb3BDb2xvcjogdG9vbHRpcEJhY2tncm91bmQsXHJcbiAgICAgICAgYm9yZGVyQm90dG9tQ29sb3I6IHRvb2x0aXBCYWNrZ3JvdW5kXHJcbiAgICB9LFxyXG4gICAgXCIuY20tdG9vbHRpcC1hdXRvY29tcGxldGVcIjoge1xyXG4gICAgICAgIFwiJiA+IHVsID4gbGlbYXJpYS1zZWxlY3RlZF1cIjoge1xyXG4gICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IGhpZ2hsaWdodEJhY2tncm91bmQsXHJcbiAgICAgICAgICAgIGNvbG9yOiBpdm9yeVxyXG4gICAgICAgIH1cclxuICAgIH1cclxufSwgeyBkYXJrOiB0cnVlIH0pO1xyXG4vKipcclxuVGhlIGhpZ2hsaWdodGluZyBzdHlsZSBmb3IgY29kZSBpbiB0aGUgT25lIERhcmsgdGhlbWUuXHJcbiovXHJcbmNvbnN0IG9uZURhcmtIaWdobGlnaHRTdHlsZSA9IC8qQF9fUFVSRV9fKi9IaWdobGlnaHRTdHlsZS5kZWZpbmUoW1xyXG4gICAgeyB0YWc6IHRhZ3Mua2V5d29yZCxcclxuICAgICAgICBjb2xvcjogdmlvbGV0IH0sXHJcbiAgICB7IHRhZzogW3RhZ3MubmFtZSwgdGFncy5kZWxldGVkLCB0YWdzLmNoYXJhY3RlciwgdGFncy5wcm9wZXJ0eU5hbWUsIHRhZ3MubWFjcm9OYW1lXSxcclxuICAgICAgICBjb2xvcjogY29yYWwgfSxcclxuICAgIHsgdGFnOiBbLypAX19QVVJFX18qL3RhZ3MuZnVuY3Rpb24odGFncy52YXJpYWJsZU5hbWUpLCB0YWdzLmxhYmVsTmFtZV0sXHJcbiAgICAgICAgY29sb3I6IG1hbGlidSB9LFxyXG4gICAgeyB0YWc6IFt0YWdzLmNvbG9yLCAvKkBfX1BVUkVfXyovdGFncy5jb25zdGFudCh0YWdzLm5hbWUpLCAvKkBfX1BVUkVfXyovdGFncy5zdGFuZGFyZCh0YWdzLm5hbWUpXSxcclxuICAgICAgICBjb2xvcjogd2hpc2tleSB9LFxyXG4gICAgeyB0YWc6IFsvKkBfX1BVUkVfXyovdGFncy5kZWZpbml0aW9uKHRhZ3MubmFtZSksIHRhZ3Muc2VwYXJhdG9yXSxcclxuICAgICAgICBjb2xvcjogaXZvcnkgfSxcclxuICAgIHsgdGFnOiBbdGFncy50eXBlTmFtZSwgdGFncy5jbGFzc05hbWUsIHRhZ3MubnVtYmVyLCB0YWdzLmNoYW5nZWQsIHRhZ3MuYW5ub3RhdGlvbiwgdGFncy5tb2RpZmllciwgdGFncy5zZWxmLCB0YWdzLm5hbWVzcGFjZV0sXHJcbiAgICAgICAgY29sb3I6IGNoYWxreSB9LFxyXG4gICAgeyB0YWc6IFt0YWdzLm9wZXJhdG9yLCB0YWdzLm9wZXJhdG9yS2V5d29yZCwgdGFncy51cmwsIHRhZ3MuZXNjYXBlLCB0YWdzLnJlZ2V4cCwgdGFncy5saW5rLCAvKkBfX1BVUkVfXyovdGFncy5zcGVjaWFsKHRhZ3Muc3RyaW5nKV0sXHJcbiAgICAgICAgY29sb3I6IGN5YW4gfSxcclxuICAgIHsgdGFnOiBbdGFncy5tZXRhLCB0YWdzLmNvbW1lbnRdLFxyXG4gICAgICAgIGNvbG9yOiBzdG9uZSB9LFxyXG4gICAgeyB0YWc6IHRhZ3Muc3Ryb25nLFxyXG4gICAgICAgIGZvbnRXZWlnaHQ6IFwiYm9sZFwiIH0sXHJcbiAgICB7IHRhZzogdGFncy5lbXBoYXNpcyxcclxuICAgICAgICBmb250U3R5bGU6IFwiaXRhbGljXCIgfSxcclxuICAgIHsgdGFnOiB0YWdzLnN0cmlrZXRocm91Z2gsXHJcbiAgICAgICAgdGV4dERlY29yYXRpb246IFwibGluZS10aHJvdWdoXCIgfSxcclxuICAgIHsgdGFnOiB0YWdzLmxpbmssXHJcbiAgICAgICAgY29sb3I6IHN0b25lLFxyXG4gICAgICAgIHRleHREZWNvcmF0aW9uOiBcInVuZGVybGluZVwiIH0sXHJcbiAgICB7IHRhZzogdGFncy5oZWFkaW5nLFxyXG4gICAgICAgIGZvbnRXZWlnaHQ6IFwiYm9sZFwiLFxyXG4gICAgICAgIGNvbG9yOiBjb3JhbCB9LFxyXG4gICAgeyB0YWc6IFt0YWdzLmF0b20sIHRhZ3MuYm9vbCwgLypAX19QVVJFX18qL3RhZ3Muc3BlY2lhbCh0YWdzLnZhcmlhYmxlTmFtZSldLFxyXG4gICAgICAgIGNvbG9yOiB3aGlza2V5IH0sXHJcbiAgICB7IHRhZzogW3RhZ3MucHJvY2Vzc2luZ0luc3RydWN0aW9uLCB0YWdzLnN0cmluZywgdGFncy5pbnNlcnRlZF0sXHJcbiAgICAgICAgY29sb3I6IHNhZ2UgfSxcclxuICAgIHsgdGFnOiB0YWdzLmludmFsaWQsXHJcbiAgICAgICAgY29sb3I6IGludmFsaWQgfSxcclxuXSk7XHJcbi8qKlxyXG5FeHRlbnNpb24gdG8gZW5hYmxlIHRoZSBPbmUgRGFyayB0aGVtZSAoYm90aCB0aGUgZWRpdG9yIHRoZW1lIGFuZFxyXG50aGUgaGlnaGxpZ2h0IHN0eWxlKS5cclxuKi9cclxuY29uc3Qgb25lRGFyayA9IFtvbmVEYXJrVGhlbWUsIC8qQF9fUFVSRV9fKi9zeW50YXhIaWdobGlnaHRpbmcob25lRGFya0hpZ2hsaWdodFN0eWxlKV07XHJcblxyXG5leHBvcnQgeyBjb2xvciwgb25lRGFyaywgb25lRGFya0hpZ2hsaWdodFN0eWxlLCBvbmVEYXJrVGhlbWUgfTtcclxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@codemirror/theme-one-dark/dist/index.js\n"));

/***/ }),

/***/ "./node_modules/@codemirror/view/dist/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/@codemirror/view/dist/index.js ***!
  \*****************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"BidiSpan\": function() { return /* binding */ BidiSpan; },\n/* harmony export */   \"BlockInfo\": function() { return /* binding */ BlockInfo; },\n/* harmony export */   \"BlockType\": function() { return /* binding */ BlockType; },\n/* harmony export */   \"Decoration\": function() { return /* binding */ Decoration; },\n/* harmony export */   \"Direction\": function() { return /* binding */ Direction; },\n/* harmony export */   \"EditorView\": function() { return /* binding */ EditorView; },\n/* harmony export */   \"GutterMarker\": function() { return /* binding */ GutterMarker; },\n/* harmony export */   \"MatchDecorator\": function() { return /* binding */ MatchDecorator; },\n/* harmony export */   \"RectangleMarker\": function() { return /* binding */ RectangleMarker; },\n/* harmony export */   \"ViewPlugin\": function() { return /* binding */ ViewPlugin; },\n/* harmony export */   \"ViewUpdate\": function() { return /* binding */ ViewUpdate; },\n/* harmony export */   \"WidgetType\": function() { return /* binding */ WidgetType; },\n/* harmony export */   \"__test\": function() { return /* binding */ __test; },\n/* harmony export */   \"closeHoverTooltips\": function() { return /* binding */ closeHoverTooltips; },\n/* harmony export */   \"crosshairCursor\": function() { return /* binding */ crosshairCursor; },\n/* harmony export */   \"drawSelection\": function() { return /* binding */ drawSelection; },\n/* harmony export */   \"dropCursor\": function() { return /* binding */ dropCursor; },\n/* harmony export */   \"getPanel\": function() { return /* binding */ getPanel; },\n/* harmony export */   \"getTooltip\": function() { return /* binding */ getTooltip; },\n/* harmony export */   \"gutter\": function() { return /* binding */ gutter; },\n/* harmony export */   \"gutterLineClass\": function() { return /* binding */ gutterLineClass; },\n/* harmony export */   \"gutters\": function() { return /* binding */ gutters; },\n/* harmony export */   \"hasHoverTooltips\": function() { return /* binding */ hasHoverTooltips; },\n/* harmony export */   \"highlightActiveLine\": function() { return /* binding */ highlightActiveLine; },\n/* harmony export */   \"highlightActiveLineGutter\": function() { return /* binding */ highlightActiveLineGutter; },\n/* harmony export */   \"highlightSpecialChars\": function() { return /* binding */ highlightSpecialChars; },\n/* harmony export */   \"highlightTrailingWhitespace\": function() { return /* binding */ highlightTrailingWhitespace; },\n/* harmony export */   \"highlightWhitespace\": function() { return /* binding */ highlightWhitespace; },\n/* harmony export */   \"hoverTooltip\": function() { return /* binding */ hoverTooltip; },\n/* harmony export */   \"keymap\": function() { return /* binding */ keymap; },\n/* harmony export */   \"layer\": function() { return /* binding */ layer; },\n/* harmony export */   \"lineNumberMarkers\": function() { return /* binding */ lineNumberMarkers; },\n/* harmony export */   \"lineNumbers\": function() { return /* binding */ lineNumbers; },\n/* harmony export */   \"logException\": function() { return /* binding */ logException; },\n/* harmony export */   \"panels\": function() { return /* binding */ panels; },\n/* harmony export */   \"placeholder\": function() { return /* binding */ placeholder; },\n/* harmony export */   \"rectangularSelection\": function() { return /* binding */ rectangularSelection; },\n/* harmony export */   \"repositionTooltips\": function() { return /* binding */ repositionTooltips; },\n/* harmony export */   \"runScopeHandlers\": function() { return /* binding */ runScopeHandlers; },\n/* harmony export */   \"scrollPastEnd\": function() { return /* binding */ scrollPastEnd; },\n/* harmony export */   \"showPanel\": function() { return /* binding */ showPanel; },\n/* harmony export */   \"showTooltip\": function() { return /* binding */ showTooltip; },\n/* harmony export */   \"tooltips\": function() { return /* binding */ tooltips; }\n/* harmony export */ });\n/* harmony import */ var _codemirror_state__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @codemirror/state */ \"./node_modules/@codemirror/state/dist/index.js\");\n/* harmony import */ var style_mod__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! style-mod */ \"./node_modules/style-mod/src/style-mod.js\");\n/* harmony import */ var w3c_keyname__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! w3c-keyname */ \"./node_modules/w3c-keyname/index.es.js\");\n\r\n\r\n\r\n\r\nfunction getSelection(root) {\r\n    let target;\r\n    // Browsers differ on whether shadow roots have a getSelection\r\n    // method. If it exists, use that, otherwise, call it on the\r\n    // document.\r\n    if (root.nodeType == 11) { // Shadow root\r\n        target = root.getSelection ? root : root.ownerDocument;\r\n    }\r\n    else {\r\n        target = root;\r\n    }\r\n    return target.getSelection();\r\n}\r\nfunction contains(dom, node) {\r\n    return node ? dom == node || dom.contains(node.nodeType != 1 ? node.parentNode : node) : false;\r\n}\r\nfunction deepActiveElement(doc) {\r\n    let elt = doc.activeElement;\r\n    while (elt && elt.shadowRoot)\r\n        elt = elt.shadowRoot.activeElement;\r\n    return elt;\r\n}\r\nfunction hasSelection(dom, selection) {\r\n    if (!selection.anchorNode)\r\n        return false;\r\n    try {\r\n        // Firefox will raise 'permission denied' errors when accessing\r\n        // properties of `sel.anchorNode` when it's in a generated CSS\r\n        // element.\r\n        return contains(dom, selection.anchorNode);\r\n    }\r\n    catch (_) {\r\n        return false;\r\n    }\r\n}\r\nfunction clientRectsFor(dom) {\r\n    if (dom.nodeType == 3)\r\n        return textRange(dom, 0, dom.nodeValue.length).getClientRects();\r\n    else if (dom.nodeType == 1)\r\n        return dom.getClientRects();\r\n    else\r\n        return [];\r\n}\r\n// Scans forward and backward through DOM positions equivalent to the\r\n// given one to see if the two are in the same place (i.e. after a\r\n// text node vs at the end of that text node)\r\nfunction isEquivalentPosition(node, off, targetNode, targetOff) {\r\n    return targetNode ? (scanFor(node, off, targetNode, targetOff, -1) ||\r\n        scanFor(node, off, targetNode, targetOff, 1)) : false;\r\n}\r\nfunction domIndex(node) {\r\n    for (var index = 0;; index++) {\r\n        node = node.previousSibling;\r\n        if (!node)\r\n            return index;\r\n    }\r\n}\r\nfunction scanFor(node, off, targetNode, targetOff, dir) {\r\n    for (;;) {\r\n        if (node == targetNode && off == targetOff)\r\n            return true;\r\n        if (off == (dir < 0 ? 0 : maxOffset(node))) {\r\n            if (node.nodeName == \"DIV\")\r\n                return false;\r\n            let parent = node.parentNode;\r\n            if (!parent || parent.nodeType != 1)\r\n                return false;\r\n            off = domIndex(node) + (dir < 0 ? 0 : 1);\r\n            node = parent;\r\n        }\r\n        else if (node.nodeType == 1) {\r\n            node = node.childNodes[off + (dir < 0 ? -1 : 0)];\r\n            if (node.nodeType == 1 && node.contentEditable == \"false\")\r\n                return false;\r\n            off = dir < 0 ? maxOffset(node) : 0;\r\n        }\r\n        else {\r\n            return false;\r\n        }\r\n    }\r\n}\r\nfunction maxOffset(node) {\r\n    return node.nodeType == 3 ? node.nodeValue.length : node.childNodes.length;\r\n}\r\nconst Rect0 = { left: 0, right: 0, top: 0, bottom: 0 };\r\nfunction flattenRect(rect, left) {\r\n    let x = left ? rect.left : rect.right;\r\n    return { left: x, right: x, top: rect.top, bottom: rect.bottom };\r\n}\r\nfunction windowRect(win) {\r\n    return { left: 0, right: win.innerWidth,\r\n        top: 0, bottom: win.innerHeight };\r\n}\r\nfunction scrollRectIntoView(dom, rect, side, x, y, xMargin, yMargin, ltr) {\r\n    let doc = dom.ownerDocument, win = doc.defaultView || window;\r\n    for (let cur = dom; cur;) {\r\n        if (cur.nodeType == 1) { // Element\r\n            let bounding, top = cur == doc.body;\r\n            if (top) {\r\n                bounding = windowRect(win);\r\n            }\r\n            else {\r\n                if (cur.scrollHeight <= cur.clientHeight && cur.scrollWidth <= cur.clientWidth) {\r\n                    cur = cur.assignedSlot || cur.parentNode;\r\n                    continue;\r\n                }\r\n                let rect = cur.getBoundingClientRect();\r\n                // Make sure scrollbar width isn't included in the rectangle\r\n                bounding = { left: rect.left, right: rect.left + cur.clientWidth,\r\n                    top: rect.top, bottom: rect.top + cur.clientHeight };\r\n            }\r\n            let moveX = 0, moveY = 0;\r\n            if (y == \"nearest\") {\r\n                if (rect.top < bounding.top) {\r\n                    moveY = -(bounding.top - rect.top + yMargin);\r\n                    if (side > 0 && rect.bottom > bounding.bottom + moveY)\r\n                        moveY = rect.bottom - bounding.bottom + moveY + yMargin;\r\n                }\r\n                else if (rect.bottom > bounding.bottom) {\r\n                    moveY = rect.bottom - bounding.bottom + yMargin;\r\n                    if (side < 0 && (rect.top - moveY) < bounding.top)\r\n                        moveY = -(bounding.top + moveY - rect.top + yMargin);\r\n                }\r\n            }\r\n            else {\r\n                let rectHeight = rect.bottom - rect.top, boundingHeight = bounding.bottom - bounding.top;\r\n                let targetTop = y == \"center\" && rectHeight <= boundingHeight ? rect.top + rectHeight / 2 - boundingHeight / 2 :\r\n                    y == \"start\" || y == \"center\" && side < 0 ? rect.top - yMargin :\r\n                        rect.bottom - boundingHeight + yMargin;\r\n                moveY = targetTop - bounding.top;\r\n            }\r\n            if (x == \"nearest\") {\r\n                if (rect.left < bounding.left) {\r\n                    moveX = -(bounding.left - rect.left + xMargin);\r\n                    if (side > 0 && rect.right > bounding.right + moveX)\r\n                        moveX = rect.right - bounding.right + moveX + xMargin;\r\n                }\r\n                else if (rect.right > bounding.right) {\r\n                    moveX = rect.right - bounding.right + xMargin;\r\n                    if (side < 0 && rect.left < bounding.left + moveX)\r\n                        moveX = -(bounding.left + moveX - rect.left + xMargin);\r\n                }\r\n            }\r\n            else {\r\n                let targetLeft = x == \"center\" ? rect.left + (rect.right - rect.left) / 2 - (bounding.right - bounding.left) / 2 :\r\n                    (x == \"start\") == ltr ? rect.left - xMargin :\r\n                        rect.right - (bounding.right - bounding.left) + xMargin;\r\n                moveX = targetLeft - bounding.left;\r\n            }\r\n            if (moveX || moveY) {\r\n                if (top) {\r\n                    win.scrollBy(moveX, moveY);\r\n                }\r\n                else {\r\n                    let movedX = 0, movedY = 0;\r\n                    if (moveY) {\r\n                        let start = cur.scrollTop;\r\n                        cur.scrollTop += moveY;\r\n                        movedY = cur.scrollTop - start;\r\n                    }\r\n                    if (moveX) {\r\n                        let start = cur.scrollLeft;\r\n                        cur.scrollLeft += moveX;\r\n                        movedX = cur.scrollLeft - start;\r\n                    }\r\n                    rect = { left: rect.left - movedX, top: rect.top - movedY,\r\n                        right: rect.right - movedX, bottom: rect.bottom - movedY };\r\n                    if (movedX && Math.abs(movedX - moveX) < 1)\r\n                        x = \"nearest\";\r\n                    if (movedY && Math.abs(movedY - moveY) < 1)\r\n                        y = \"nearest\";\r\n                }\r\n            }\r\n            if (top)\r\n                break;\r\n            cur = cur.assignedSlot || cur.parentNode;\r\n        }\r\n        else if (cur.nodeType == 11) { // A shadow root\r\n            cur = cur.host;\r\n        }\r\n        else {\r\n            break;\r\n        }\r\n    }\r\n}\r\nfunction scrollableParent(dom) {\r\n    let doc = dom.ownerDocument;\r\n    for (let cur = dom.parentNode; cur;) {\r\n        if (cur == doc.body) {\r\n            break;\r\n        }\r\n        else if (cur.nodeType == 1) {\r\n            if (cur.scrollHeight > cur.clientHeight || cur.scrollWidth > cur.clientWidth)\r\n                return cur;\r\n            cur = cur.assignedSlot || cur.parentNode;\r\n        }\r\n        else if (cur.nodeType == 11) {\r\n            cur = cur.host;\r\n        }\r\n        else {\r\n            break;\r\n        }\r\n    }\r\n    return null;\r\n}\r\nclass DOMSelectionState {\r\n    constructor() {\r\n        this.anchorNode = null;\r\n        this.anchorOffset = 0;\r\n        this.focusNode = null;\r\n        this.focusOffset = 0;\r\n    }\r\n    eq(domSel) {\r\n        return this.anchorNode == domSel.anchorNode && this.anchorOffset == domSel.anchorOffset &&\r\n            this.focusNode == domSel.focusNode && this.focusOffset == domSel.focusOffset;\r\n    }\r\n    setRange(range) {\r\n        this.set(range.anchorNode, range.anchorOffset, range.focusNode, range.focusOffset);\r\n    }\r\n    set(anchorNode, anchorOffset, focusNode, focusOffset) {\r\n        this.anchorNode = anchorNode;\r\n        this.anchorOffset = anchorOffset;\r\n        this.focusNode = focusNode;\r\n        this.focusOffset = focusOffset;\r\n    }\r\n}\r\nlet preventScrollSupported = null;\r\n// Feature-detects support for .focus({preventScroll: true}), and uses\r\n// a fallback kludge when not supported.\r\nfunction focusPreventScroll(dom) {\r\n    if (dom.setActive)\r\n        return dom.setActive(); // in IE\r\n    if (preventScrollSupported)\r\n        return dom.focus(preventScrollSupported);\r\n    let stack = [];\r\n    for (let cur = dom; cur; cur = cur.parentNode) {\r\n        stack.push(cur, cur.scrollTop, cur.scrollLeft);\r\n        if (cur == cur.ownerDocument)\r\n            break;\r\n    }\r\n    dom.focus(preventScrollSupported == null ? {\r\n        get preventScroll() {\r\n            preventScrollSupported = { preventScroll: true };\r\n            return true;\r\n        }\r\n    } : undefined);\r\n    if (!preventScrollSupported) {\r\n        preventScrollSupported = false;\r\n        for (let i = 0; i < stack.length;) {\r\n            let elt = stack[i++], top = stack[i++], left = stack[i++];\r\n            if (elt.scrollTop != top)\r\n                elt.scrollTop = top;\r\n            if (elt.scrollLeft != left)\r\n                elt.scrollLeft = left;\r\n        }\r\n    }\r\n}\r\nlet scratchRange;\r\nfunction textRange(node, from, to = from) {\r\n    let range = scratchRange || (scratchRange = document.createRange());\r\n    range.setEnd(node, to);\r\n    range.setStart(node, from);\r\n    return range;\r\n}\r\nfunction dispatchKey(elt, name, code) {\r\n    let options = { key: name, code: name, keyCode: code, which: code, cancelable: true };\r\n    let down = new KeyboardEvent(\"keydown\", options);\r\n    down.synthetic = true;\r\n    elt.dispatchEvent(down);\r\n    let up = new KeyboardEvent(\"keyup\", options);\r\n    up.synthetic = true;\r\n    elt.dispatchEvent(up);\r\n    return down.defaultPrevented || up.defaultPrevented;\r\n}\r\nfunction getRoot(node) {\r\n    while (node) {\r\n        if (node && (node.nodeType == 9 || node.nodeType == 11 && node.host))\r\n            return node;\r\n        node = node.assignedSlot || node.parentNode;\r\n    }\r\n    return null;\r\n}\r\nfunction clearAttributes(node) {\r\n    while (node.attributes.length)\r\n        node.removeAttributeNode(node.attributes[0]);\r\n}\r\nfunction atElementStart(doc, selection) {\r\n    let node = selection.focusNode, offset = selection.focusOffset;\r\n    if (!node || selection.anchorNode != node || selection.anchorOffset != offset)\r\n        return false;\r\n    for (;;) {\r\n        if (offset) {\r\n            if (node.nodeType != 1)\r\n                return false;\r\n            let prev = node.childNodes[offset - 1];\r\n            if (prev.contentEditable == \"false\")\r\n                offset--;\r\n            else {\r\n                node = prev;\r\n                offset = maxOffset(node);\r\n            }\r\n        }\r\n        else if (node == doc) {\r\n            return true;\r\n        }\r\n        else {\r\n            offset = domIndex(node);\r\n            node = node.parentNode;\r\n        }\r\n    }\r\n}\r\n\r\nclass DOMPos {\r\n    constructor(node, offset, precise = true) {\r\n        this.node = node;\r\n        this.offset = offset;\r\n        this.precise = precise;\r\n    }\r\n    static before(dom, precise) { return new DOMPos(dom.parentNode, domIndex(dom), precise); }\r\n    static after(dom, precise) { return new DOMPos(dom.parentNode, domIndex(dom) + 1, precise); }\r\n}\r\nconst noChildren = [];\r\nclass ContentView {\r\n    constructor() {\r\n        this.parent = null;\r\n        this.dom = null;\r\n        this.dirty = 2 /* Dirty.Node */;\r\n    }\r\n    get editorView() {\r\n        if (!this.parent)\r\n            throw new Error(\"Accessing view in orphan content view\");\r\n        return this.parent.editorView;\r\n    }\r\n    get overrideDOMText() { return null; }\r\n    get posAtStart() {\r\n        return this.parent ? this.parent.posBefore(this) : 0;\r\n    }\r\n    get posAtEnd() {\r\n        return this.posAtStart + this.length;\r\n    }\r\n    posBefore(view) {\r\n        let pos = this.posAtStart;\r\n        for (let child of this.children) {\r\n            if (child == view)\r\n                return pos;\r\n            pos += child.length + child.breakAfter;\r\n        }\r\n        throw new RangeError(\"Invalid child in posBefore\");\r\n    }\r\n    posAfter(view) {\r\n        return this.posBefore(view) + view.length;\r\n    }\r\n    // Will return a rectangle directly before (when side < 0), after\r\n    // (side > 0) or directly on (when the browser supports it) the\r\n    // given position.\r\n    coordsAt(_pos, _side) { return null; }\r\n    sync(track) {\r\n        if (this.dirty & 2 /* Dirty.Node */) {\r\n            let parent = this.dom;\r\n            let prev = null, next;\r\n            for (let child of this.children) {\r\n                if (child.dirty) {\r\n                    if (!child.dom && (next = prev ? prev.nextSibling : parent.firstChild)) {\r\n                        let contentView = ContentView.get(next);\r\n                        if (!contentView || !contentView.parent && contentView.canReuseDOM(child))\r\n                            child.reuseDOM(next);\r\n                    }\r\n                    child.sync(track);\r\n                    child.dirty = 0 /* Dirty.Not */;\r\n                }\r\n                next = prev ? prev.nextSibling : parent.firstChild;\r\n                if (track && !track.written && track.node == parent && next != child.dom)\r\n                    track.written = true;\r\n                if (child.dom.parentNode == parent) {\r\n                    while (next && next != child.dom)\r\n                        next = rm$1(next);\r\n                }\r\n                else {\r\n                    parent.insertBefore(child.dom, next);\r\n                }\r\n                prev = child.dom;\r\n            }\r\n            next = prev ? prev.nextSibling : parent.firstChild;\r\n            if (next && track && track.node == parent)\r\n                track.written = true;\r\n            while (next)\r\n                next = rm$1(next);\r\n        }\r\n        else if (this.dirty & 1 /* Dirty.Child */) {\r\n            for (let child of this.children)\r\n                if (child.dirty) {\r\n                    child.sync(track);\r\n                    child.dirty = 0 /* Dirty.Not */;\r\n                }\r\n        }\r\n    }\r\n    reuseDOM(_dom) { }\r\n    localPosFromDOM(node, offset) {\r\n        let after;\r\n        if (node == this.dom) {\r\n            after = this.dom.childNodes[offset];\r\n        }\r\n        else {\r\n            let bias = maxOffset(node) == 0 ? 0 : offset == 0 ? -1 : 1;\r\n            for (;;) {\r\n                let parent = node.parentNode;\r\n                if (parent == this.dom)\r\n                    break;\r\n                if (bias == 0 && parent.firstChild != parent.lastChild) {\r\n                    if (node == parent.firstChild)\r\n                        bias = -1;\r\n                    else\r\n                        bias = 1;\r\n                }\r\n                node = parent;\r\n            }\r\n            if (bias < 0)\r\n                after = node;\r\n            else\r\n                after = node.nextSibling;\r\n        }\r\n        if (after == this.dom.firstChild)\r\n            return 0;\r\n        while (after && !ContentView.get(after))\r\n            after = after.nextSibling;\r\n        if (!after)\r\n            return this.length;\r\n        for (let i = 0, pos = 0;; i++) {\r\n            let child = this.children[i];\r\n            if (child.dom == after)\r\n                return pos;\r\n            pos += child.length + child.breakAfter;\r\n        }\r\n    }\r\n    domBoundsAround(from, to, offset = 0) {\r\n        let fromI = -1, fromStart = -1, toI = -1, toEnd = -1;\r\n        for (let i = 0, pos = offset, prevEnd = offset; i < this.children.length; i++) {\r\n            let child = this.children[i], end = pos + child.length;\r\n            if (pos < from && end > to)\r\n                return child.domBoundsAround(from, to, pos);\r\n            if (end >= from && fromI == -1) {\r\n                fromI = i;\r\n                fromStart = pos;\r\n            }\r\n            if (pos > to && child.dom.parentNode == this.dom) {\r\n                toI = i;\r\n                toEnd = prevEnd;\r\n                break;\r\n            }\r\n            prevEnd = end;\r\n            pos = end + child.breakAfter;\r\n        }\r\n        return { from: fromStart, to: toEnd < 0 ? offset + this.length : toEnd,\r\n            startDOM: (fromI ? this.children[fromI - 1].dom.nextSibling : null) || this.dom.firstChild,\r\n            endDOM: toI < this.children.length && toI >= 0 ? this.children[toI].dom : null };\r\n    }\r\n    markDirty(andParent = false) {\r\n        this.dirty |= 2 /* Dirty.Node */;\r\n        this.markParentsDirty(andParent);\r\n    }\r\n    markParentsDirty(childList) {\r\n        for (let parent = this.parent; parent; parent = parent.parent) {\r\n            if (childList)\r\n                parent.dirty |= 2 /* Dirty.Node */;\r\n            if (parent.dirty & 1 /* Dirty.Child */)\r\n                return;\r\n            parent.dirty |= 1 /* Dirty.Child */;\r\n            childList = false;\r\n        }\r\n    }\r\n    setParent(parent) {\r\n        if (this.parent != parent) {\r\n            this.parent = parent;\r\n            if (this.dirty)\r\n                this.markParentsDirty(true);\r\n        }\r\n    }\r\n    setDOM(dom) {\r\n        if (this.dom)\r\n            this.dom.cmView = null;\r\n        this.dom = dom;\r\n        dom.cmView = this;\r\n    }\r\n    get rootView() {\r\n        for (let v = this;;) {\r\n            let parent = v.parent;\r\n            if (!parent)\r\n                return v;\r\n            v = parent;\r\n        }\r\n    }\r\n    replaceChildren(from, to, children = noChildren) {\r\n        this.markDirty();\r\n        for (let i = from; i < to; i++) {\r\n            let child = this.children[i];\r\n            if (child.parent == this)\r\n                child.destroy();\r\n        }\r\n        this.children.splice(from, to - from, ...children);\r\n        for (let i = 0; i < children.length; i++)\r\n            children[i].setParent(this);\r\n    }\r\n    ignoreMutation(_rec) { return false; }\r\n    ignoreEvent(_event) { return false; }\r\n    childCursor(pos = this.length) {\r\n        return new ChildCursor(this.children, pos, this.children.length);\r\n    }\r\n    childPos(pos, bias = 1) {\r\n        return this.childCursor().findPos(pos, bias);\r\n    }\r\n    toString() {\r\n        let name = this.constructor.name.replace(\"View\", \"\");\r\n        return name + (this.children.length ? \"(\" + this.children.join() + \")\" :\r\n            this.length ? \"[\" + (name == \"Text\" ? this.text : this.length) + \"]\" : \"\") +\r\n            (this.breakAfter ? \"#\" : \"\");\r\n    }\r\n    static get(node) { return node.cmView; }\r\n    get isEditable() { return true; }\r\n    merge(from, to, source, hasStart, openStart, openEnd) {\r\n        return false;\r\n    }\r\n    become(other) { return false; }\r\n    canReuseDOM(other) { return other.constructor == this.constructor; }\r\n    // When this is a zero-length view with a side, this should return a\r\n    // number <= 0 to indicate it is before its position, or a\r\n    // number > 0 when after its position.\r\n    getSide() { return 0; }\r\n    destroy() {\r\n        this.parent = null;\r\n    }\r\n}\r\nContentView.prototype.breakAfter = 0;\r\n// Remove a DOM node and return its next sibling.\r\nfunction rm$1(dom) {\r\n    let next = dom.nextSibling;\r\n    dom.parentNode.removeChild(dom);\r\n    return next;\r\n}\r\nclass ChildCursor {\r\n    constructor(children, pos, i) {\r\n        this.children = children;\r\n        this.pos = pos;\r\n        this.i = i;\r\n        this.off = 0;\r\n    }\r\n    findPos(pos, bias = 1) {\r\n        for (;;) {\r\n            if (pos > this.pos || pos == this.pos &&\r\n                (bias > 0 || this.i == 0 || this.children[this.i - 1].breakAfter)) {\r\n                this.off = pos - this.pos;\r\n                return this;\r\n            }\r\n            let next = this.children[--this.i];\r\n            this.pos -= next.length + next.breakAfter;\r\n        }\r\n    }\r\n}\r\nfunction replaceRange(parent, fromI, fromOff, toI, toOff, insert, breakAtStart, openStart, openEnd) {\r\n    let { children } = parent;\r\n    let before = children.length ? children[fromI] : null;\r\n    let last = insert.length ? insert[insert.length - 1] : null;\r\n    let breakAtEnd = last ? last.breakAfter : breakAtStart;\r\n    // Change within a single child\r\n    if (fromI == toI && before && !breakAtStart && !breakAtEnd && insert.length < 2 &&\r\n        before.merge(fromOff, toOff, insert.length ? last : null, fromOff == 0, openStart, openEnd))\r\n        return;\r\n    if (toI < children.length) {\r\n        let after = children[toI];\r\n        // Make sure the end of the child after the update is preserved in `after`\r\n        if (after && toOff < after.length) {\r\n            // If we're splitting a child, separate part of it to avoid that\r\n            // being mangled when updating the child before the update.\r\n            if (fromI == toI) {\r\n                after = after.split(toOff);\r\n                toOff = 0;\r\n            }\r\n            // If the element after the replacement should be merged with\r\n            // the last replacing element, update `content`\r\n            if (!breakAtEnd && last && after.merge(0, toOff, last, true, 0, openEnd)) {\r\n                insert[insert.length - 1] = after;\r\n            }\r\n            else {\r\n                // Remove the start of the after element, if necessary, and\r\n                // add it to `content`.\r\n                if (toOff)\r\n                    after.merge(0, toOff, null, false, 0, openEnd);\r\n                insert.push(after);\r\n            }\r\n        }\r\n        else if (after === null || after === void 0 ? void 0 : after.breakAfter) {\r\n            // The element at `toI` is entirely covered by this range.\r\n            // Preserve its line break, if any.\r\n            if (last)\r\n                last.breakAfter = 1;\r\n            else\r\n                breakAtStart = 1;\r\n        }\r\n        // Since we've handled the next element from the current elements\r\n        // now, make sure `toI` points after that.\r\n        toI++;\r\n    }\r\n    if (before) {\r\n        before.breakAfter = breakAtStart;\r\n        if (fromOff > 0) {\r\n            if (!breakAtStart && insert.length && before.merge(fromOff, before.length, insert[0], false, openStart, 0)) {\r\n                before.breakAfter = insert.shift().breakAfter;\r\n            }\r\n            else if (fromOff < before.length || before.children.length && before.children[before.children.length - 1].length == 0) {\r\n                before.merge(fromOff, before.length, null, false, openStart, 0);\r\n            }\r\n            fromI++;\r\n        }\r\n    }\r\n    // Try to merge widgets on the boundaries of the replacement\r\n    while (fromI < toI && insert.length) {\r\n        if (children[toI - 1].become(insert[insert.length - 1])) {\r\n            toI--;\r\n            insert.pop();\r\n            openEnd = insert.length ? 0 : openStart;\r\n        }\r\n        else if (children[fromI].become(insert[0])) {\r\n            fromI++;\r\n            insert.shift();\r\n            openStart = insert.length ? 0 : openEnd;\r\n        }\r\n        else {\r\n            break;\r\n        }\r\n    }\r\n    if (!insert.length && fromI && toI < children.length && !children[fromI - 1].breakAfter &&\r\n        children[toI].merge(0, 0, children[fromI - 1], false, openStart, openEnd))\r\n        fromI--;\r\n    if (fromI < toI || insert.length)\r\n        parent.replaceChildren(fromI, toI, insert);\r\n}\r\nfunction mergeChildrenInto(parent, from, to, insert, openStart, openEnd) {\r\n    let cur = parent.childCursor();\r\n    let { i: toI, off: toOff } = cur.findPos(to, 1);\r\n    let { i: fromI, off: fromOff } = cur.findPos(from, -1);\r\n    let dLen = from - to;\r\n    for (let view of insert)\r\n        dLen += view.length;\r\n    parent.length += dLen;\r\n    replaceRange(parent, fromI, fromOff, toI, toOff, insert, 0, openStart, openEnd);\r\n}\r\n\r\nlet nav = typeof navigator != \"undefined\" ? navigator : { userAgent: \"\", vendor: \"\", platform: \"\" };\r\nlet doc = typeof document != \"undefined\" ? document : { documentElement: { style: {} } };\r\nconst ie_edge = /*@__PURE__*//Edge\\/(\\d+)/.exec(nav.userAgent);\r\nconst ie_upto10 = /*@__PURE__*//MSIE \\d/.test(nav.userAgent);\r\nconst ie_11up = /*@__PURE__*//Trident\\/(?:[7-9]|\\d{2,})\\..*rv:(\\d+)/.exec(nav.userAgent);\r\nconst ie = !!(ie_upto10 || ie_11up || ie_edge);\r\nconst gecko = !ie && /*@__PURE__*//gecko\\/(\\d+)/i.test(nav.userAgent);\r\nconst chrome = !ie && /*@__PURE__*//Chrome\\/(\\d+)/.exec(nav.userAgent);\r\nconst webkit = \"webkitFontSmoothing\" in doc.documentElement.style;\r\nconst safari = !ie && /*@__PURE__*//Apple Computer/.test(nav.vendor);\r\nconst ios = safari && (/*@__PURE__*//Mobile\\/\\w+/.test(nav.userAgent) || nav.maxTouchPoints > 2);\r\nvar browser = {\r\n    mac: ios || /*@__PURE__*//Mac/.test(nav.platform),\r\n    windows: /*@__PURE__*//Win/.test(nav.platform),\r\n    linux: /*@__PURE__*//Linux|X11/.test(nav.platform),\r\n    ie,\r\n    ie_version: ie_upto10 ? doc.documentMode || 6 : ie_11up ? +ie_11up[1] : ie_edge ? +ie_edge[1] : 0,\r\n    gecko,\r\n    gecko_version: gecko ? +(/*@__PURE__*//Firefox\\/(\\d+)/.exec(nav.userAgent) || [0, 0])[1] : 0,\r\n    chrome: !!chrome,\r\n    chrome_version: chrome ? +chrome[1] : 0,\r\n    ios,\r\n    android: /*@__PURE__*//Android\\b/.test(nav.userAgent),\r\n    webkit,\r\n    safari,\r\n    webkit_version: webkit ? +(/*@__PURE__*//\\bAppleWebKit\\/(\\d+)/.exec(navigator.userAgent) || [0, 0])[1] : 0,\r\n    tabSize: doc.documentElement.style.tabSize != null ? \"tab-size\" : \"-moz-tab-size\"\r\n};\r\n\r\nconst MaxJoinLen = 256;\r\nclass TextView extends ContentView {\r\n    constructor(text) {\r\n        super();\r\n        this.text = text;\r\n    }\r\n    get length() { return this.text.length; }\r\n    createDOM(textDOM) {\r\n        this.setDOM(textDOM || document.createTextNode(this.text));\r\n    }\r\n    sync(track) {\r\n        if (!this.dom)\r\n            this.createDOM();\r\n        if (this.dom.nodeValue != this.text) {\r\n            if (track && track.node == this.dom)\r\n                track.written = true;\r\n            this.dom.nodeValue = this.text;\r\n        }\r\n    }\r\n    reuseDOM(dom) {\r\n        if (dom.nodeType == 3)\r\n            this.createDOM(dom);\r\n    }\r\n    merge(from, to, source) {\r\n        if (source && (!(source instanceof TextView) || this.length - (to - from) + source.length > MaxJoinLen))\r\n            return false;\r\n        this.text = this.text.slice(0, from) + (source ? source.text : \"\") + this.text.slice(to);\r\n        this.markDirty();\r\n        return true;\r\n    }\r\n    split(from) {\r\n        let result = new TextView(this.text.slice(from));\r\n        this.text = this.text.slice(0, from);\r\n        this.markDirty();\r\n        return result;\r\n    }\r\n    localPosFromDOM(node, offset) {\r\n        return node == this.dom ? offset : offset ? this.text.length : 0;\r\n    }\r\n    domAtPos(pos) { return new DOMPos(this.dom, pos); }\r\n    domBoundsAround(_from, _to, offset) {\r\n        return { from: offset, to: offset + this.length, startDOM: this.dom, endDOM: this.dom.nextSibling };\r\n    }\r\n    coordsAt(pos, side) {\r\n        return textCoords(this.dom, pos, side);\r\n    }\r\n}\r\nclass MarkView extends ContentView {\r\n    constructor(mark, children = [], length = 0) {\r\n        super();\r\n        this.mark = mark;\r\n        this.children = children;\r\n        this.length = length;\r\n        for (let ch of children)\r\n            ch.setParent(this);\r\n    }\r\n    setAttrs(dom) {\r\n        clearAttributes(dom);\r\n        if (this.mark.class)\r\n            dom.className = this.mark.class;\r\n        if (this.mark.attrs)\r\n            for (let name in this.mark.attrs)\r\n                dom.setAttribute(name, this.mark.attrs[name]);\r\n        return dom;\r\n    }\r\n    reuseDOM(node) {\r\n        if (node.nodeName == this.mark.tagName.toUpperCase()) {\r\n            this.setDOM(node);\r\n            this.dirty |= 4 /* Dirty.Attrs */ | 2 /* Dirty.Node */;\r\n        }\r\n    }\r\n    sync(track) {\r\n        if (!this.dom)\r\n            this.setDOM(this.setAttrs(document.createElement(this.mark.tagName)));\r\n        else if (this.dirty & 4 /* Dirty.Attrs */)\r\n            this.setAttrs(this.dom);\r\n        super.sync(track);\r\n    }\r\n    merge(from, to, source, _hasStart, openStart, openEnd) {\r\n        if (source && (!(source instanceof MarkView && source.mark.eq(this.mark)) ||\r\n            (from && openStart <= 0) || (to < this.length && openEnd <= 0)))\r\n            return false;\r\n        mergeChildrenInto(this, from, to, source ? source.children : [], openStart - 1, openEnd - 1);\r\n        this.markDirty();\r\n        return true;\r\n    }\r\n    split(from) {\r\n        let result = [], off = 0, detachFrom = -1, i = 0;\r\n        for (let elt of this.children) {\r\n            let end = off + elt.length;\r\n            if (end > from)\r\n                result.push(off < from ? elt.split(from - off) : elt);\r\n            if (detachFrom < 0 && off >= from)\r\n                detachFrom = i;\r\n            off = end;\r\n            i++;\r\n        }\r\n        let length = this.length - from;\r\n        this.length = from;\r\n        if (detachFrom > -1) {\r\n            this.children.length = detachFrom;\r\n            this.markDirty();\r\n        }\r\n        return new MarkView(this.mark, result, length);\r\n    }\r\n    domAtPos(pos) {\r\n        return inlineDOMAtPos(this, pos);\r\n    }\r\n    coordsAt(pos, side) {\r\n        return coordsInChildren(this, pos, side);\r\n    }\r\n}\r\nfunction textCoords(text, pos, side) {\r\n    let length = text.nodeValue.length;\r\n    if (pos > length)\r\n        pos = length;\r\n    let from = pos, to = pos, flatten = 0;\r\n    if (pos == 0 && side < 0 || pos == length && side >= 0) {\r\n        if (!(browser.chrome || browser.gecko)) { // These browsers reliably return valid rectangles for empty ranges\r\n            if (pos) {\r\n                from--;\r\n                flatten = 1;\r\n            } // FIXME this is wrong in RTL text\r\n            else if (to < length) {\r\n                to++;\r\n                flatten = -1;\r\n            }\r\n        }\r\n    }\r\n    else {\r\n        if (side < 0)\r\n            from--;\r\n        else if (to < length)\r\n            to++;\r\n    }\r\n    let rects = textRange(text, from, to).getClientRects();\r\n    if (!rects.length)\r\n        return Rect0;\r\n    let rect = rects[(flatten ? flatten < 0 : side >= 0) ? 0 : rects.length - 1];\r\n    if (browser.safari && !flatten && rect.width == 0)\r\n        rect = Array.prototype.find.call(rects, r => r.width) || rect;\r\n    return flatten ? flattenRect(rect, flatten < 0) : rect || null;\r\n}\r\n// Also used for collapsed ranges that don't have a placeholder widget!\r\nclass WidgetView extends ContentView {\r\n    constructor(widget, length, side) {\r\n        super();\r\n        this.widget = widget;\r\n        this.length = length;\r\n        this.side = side;\r\n        this.prevWidget = null;\r\n    }\r\n    static create(widget, length, side) {\r\n        return new (widget.customView || WidgetView)(widget, length, side);\r\n    }\r\n    split(from) {\r\n        let result = WidgetView.create(this.widget, this.length - from, this.side);\r\n        this.length -= from;\r\n        return result;\r\n    }\r\n    sync() {\r\n        if (!this.dom || !this.widget.updateDOM(this.dom)) {\r\n            if (this.dom && this.prevWidget)\r\n                this.prevWidget.destroy(this.dom);\r\n            this.prevWidget = null;\r\n            this.setDOM(this.widget.toDOM(this.editorView));\r\n            this.dom.contentEditable = \"false\";\r\n        }\r\n    }\r\n    getSide() { return this.side; }\r\n    merge(from, to, source, hasStart, openStart, openEnd) {\r\n        if (source && (!(source instanceof WidgetView) || !this.widget.compare(source.widget) ||\r\n            from > 0 && openStart <= 0 || to < this.length && openEnd <= 0))\r\n            return false;\r\n        this.length = from + (source ? source.length : 0) + (this.length - to);\r\n        return true;\r\n    }\r\n    become(other) {\r\n        if (other.length == this.length && other instanceof WidgetView && other.side == this.side) {\r\n            if (this.widget.constructor == other.widget.constructor) {\r\n                if (!this.widget.eq(other.widget))\r\n                    this.markDirty(true);\r\n                if (this.dom && !this.prevWidget)\r\n                    this.prevWidget = this.widget;\r\n                this.widget = other.widget;\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n    ignoreMutation() { return true; }\r\n    ignoreEvent(event) { return this.widget.ignoreEvent(event); }\r\n    get overrideDOMText() {\r\n        if (this.length == 0)\r\n            return _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Text.empty;\r\n        let top = this;\r\n        while (top.parent)\r\n            top = top.parent;\r\n        let view = top.editorView, text = view && view.state.doc, start = this.posAtStart;\r\n        return text ? text.slice(start, start + this.length) : _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Text.empty;\r\n    }\r\n    domAtPos(pos) {\r\n        return pos == 0 ? DOMPos.before(this.dom) : DOMPos.after(this.dom, pos == this.length);\r\n    }\r\n    domBoundsAround() { return null; }\r\n    coordsAt(pos, side) {\r\n        let rects = this.dom.getClientRects(), rect = null;\r\n        if (!rects.length)\r\n            return Rect0;\r\n        for (let i = pos > 0 ? rects.length - 1 : 0;; i += (pos > 0 ? -1 : 1)) {\r\n            rect = rects[i];\r\n            if (pos > 0 ? i == 0 : i == rects.length - 1 || rect.top < rect.bottom)\r\n                break;\r\n        }\r\n        return this.length ? rect : flattenRect(rect, this.side > 0);\r\n    }\r\n    get isEditable() { return false; }\r\n    destroy() {\r\n        super.destroy();\r\n        if (this.dom)\r\n            this.widget.destroy(this.dom);\r\n    }\r\n}\r\nclass CompositionView extends WidgetView {\r\n    domAtPos(pos) {\r\n        let { topView, text } = this.widget;\r\n        if (!topView)\r\n            return new DOMPos(text, Math.min(pos, text.nodeValue.length));\r\n        return scanCompositionTree(pos, 0, topView, text, (v, p) => v.domAtPos(p), p => new DOMPos(text, Math.min(p, text.nodeValue.length)));\r\n    }\r\n    sync() { this.setDOM(this.widget.toDOM()); }\r\n    localPosFromDOM(node, offset) {\r\n        let { topView, text } = this.widget;\r\n        if (!topView)\r\n            return Math.min(offset, this.length);\r\n        return posFromDOMInCompositionTree(node, offset, topView, text);\r\n    }\r\n    ignoreMutation() { return false; }\r\n    get overrideDOMText() { return null; }\r\n    coordsAt(pos, side) {\r\n        let { topView, text } = this.widget;\r\n        if (!topView)\r\n            return textCoords(text, pos, side);\r\n        return scanCompositionTree(pos, side, topView, text, (v, pos, side) => v.coordsAt(pos, side), (pos, side) => textCoords(text, pos, side));\r\n    }\r\n    destroy() {\r\n        var _a;\r\n        super.destroy();\r\n        (_a = this.widget.topView) === null || _a === void 0 ? void 0 : _a.destroy();\r\n    }\r\n    get isEditable() { return true; }\r\n    canReuseDOM() { return true; }\r\n}\r\n// Uses the old structure of a chunk of content view frozen for\r\n// composition to try and find a reasonable DOM location for the given\r\n// offset.\r\nfunction scanCompositionTree(pos, side, view, text, enterView, fromText) {\r\n    if (view instanceof MarkView) {\r\n        for (let child = view.dom.firstChild; child; child = child.nextSibling) {\r\n            let desc = ContentView.get(child);\r\n            if (!desc)\r\n                return fromText(pos, side);\r\n            let hasComp = contains(child, text);\r\n            let len = desc.length + (hasComp ? text.nodeValue.length : 0);\r\n            if (pos < len || pos == len && desc.getSide() <= 0)\r\n                return hasComp ? scanCompositionTree(pos, side, desc, text, enterView, fromText) : enterView(desc, pos, side);\r\n            pos -= len;\r\n        }\r\n        return enterView(view, view.length, -1);\r\n    }\r\n    else if (view.dom == text) {\r\n        return fromText(pos, side);\r\n    }\r\n    else {\r\n        return enterView(view, pos, side);\r\n    }\r\n}\r\nfunction posFromDOMInCompositionTree(node, offset, view, text) {\r\n    if (view instanceof MarkView) {\r\n        for (let child of view.children) {\r\n            let pos = 0, hasComp = contains(child.dom, text);\r\n            if (contains(child.dom, node))\r\n                return pos + (hasComp ? posFromDOMInCompositionTree(node, offset, child, text) : child.localPosFromDOM(node, offset));\r\n            pos += hasComp ? text.nodeValue.length : child.length;\r\n        }\r\n    }\r\n    else if (view.dom == text) {\r\n        return Math.min(offset, text.nodeValue.length);\r\n    }\r\n    return view.localPosFromDOM(node, offset);\r\n}\r\n// These are drawn around uneditable widgets to avoid a number of\r\n// browser bugs that show up when the cursor is directly next to\r\n// uneditable inline content.\r\nclass WidgetBufferView extends ContentView {\r\n    constructor(side) {\r\n        super();\r\n        this.side = side;\r\n    }\r\n    get length() { return 0; }\r\n    merge() { return false; }\r\n    become(other) {\r\n        return other instanceof WidgetBufferView && other.side == this.side;\r\n    }\r\n    split() { return new WidgetBufferView(this.side); }\r\n    sync() {\r\n        if (!this.dom) {\r\n            let dom = document.createElement(\"img\");\r\n            dom.className = \"cm-widgetBuffer\";\r\n            dom.setAttribute(\"aria-hidden\", \"true\");\r\n            this.setDOM(dom);\r\n        }\r\n    }\r\n    getSide() { return this.side; }\r\n    domAtPos(pos) { return DOMPos.before(this.dom); }\r\n    localPosFromDOM() { return 0; }\r\n    domBoundsAround() { return null; }\r\n    coordsAt(pos) {\r\n        let imgRect = this.dom.getBoundingClientRect();\r\n        // Since the <img> height doesn't correspond to text height, try\r\n        // to borrow the height from some sibling node.\r\n        let siblingRect = inlineSiblingRect(this, this.side > 0 ? -1 : 1);\r\n        return siblingRect && siblingRect.top < imgRect.bottom && siblingRect.bottom > imgRect.top\r\n            ? { left: imgRect.left, right: imgRect.right, top: siblingRect.top, bottom: siblingRect.bottom } : imgRect;\r\n    }\r\n    get overrideDOMText() {\r\n        return _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Text.empty;\r\n    }\r\n}\r\nTextView.prototype.children = WidgetView.prototype.children = WidgetBufferView.prototype.children = noChildren;\r\nfunction inlineSiblingRect(view, side) {\r\n    let parent = view.parent, index = parent ? parent.children.indexOf(view) : -1;\r\n    while (parent && index >= 0) {\r\n        if (side < 0 ? index > 0 : index < parent.children.length) {\r\n            let next = parent.children[index + side];\r\n            if (next instanceof TextView) {\r\n                let nextRect = next.coordsAt(side < 0 ? next.length : 0, side);\r\n                if (nextRect)\r\n                    return nextRect;\r\n            }\r\n            index += side;\r\n        }\r\n        else if (parent instanceof MarkView && parent.parent) {\r\n            index = parent.parent.children.indexOf(parent) + (side < 0 ? 0 : 1);\r\n            parent = parent.parent;\r\n        }\r\n        else {\r\n            let last = parent.dom.lastChild;\r\n            if (last && last.nodeName == \"BR\")\r\n                return last.getClientRects()[0];\r\n            break;\r\n        }\r\n    }\r\n    return undefined;\r\n}\r\nfunction inlineDOMAtPos(parent, pos) {\r\n    let dom = parent.dom, { children } = parent, i = 0;\r\n    for (let off = 0; i < children.length; i++) {\r\n        let child = children[i], end = off + child.length;\r\n        if (end == off && child.getSide() <= 0)\r\n            continue;\r\n        if (pos > off && pos < end && child.dom.parentNode == dom)\r\n            return child.domAtPos(pos - off);\r\n        if (pos <= off)\r\n            break;\r\n        off = end;\r\n    }\r\n    for (let j = i; j > 0; j--) {\r\n        let prev = children[j - 1];\r\n        if (prev.dom.parentNode == dom)\r\n            return prev.domAtPos(prev.length);\r\n    }\r\n    for (let j = i; j < children.length; j++) {\r\n        let next = children[j];\r\n        if (next.dom.parentNode == dom)\r\n            return next.domAtPos(0);\r\n    }\r\n    return new DOMPos(dom, 0);\r\n}\r\n// Assumes `view`, if a mark view, has precisely 1 child.\r\nfunction joinInlineInto(parent, view, open) {\r\n    let last, { children } = parent;\r\n    if (open > 0 && view instanceof MarkView && children.length &&\r\n        (last = children[children.length - 1]) instanceof MarkView && last.mark.eq(view.mark)) {\r\n        joinInlineInto(last, view.children[0], open - 1);\r\n    }\r\n    else {\r\n        children.push(view);\r\n        view.setParent(parent);\r\n    }\r\n    parent.length += view.length;\r\n}\r\nfunction coordsInChildren(view, pos, side) {\r\n    let before = null, beforePos = -1, after = null, afterPos = -1;\r\n    function scan(view, pos) {\r\n        for (let i = 0, off = 0; i < view.children.length && off <= pos; i++) {\r\n            let child = view.children[i], end = off + child.length;\r\n            if (end >= pos) {\r\n                if (child.children.length) {\r\n                    scan(child, pos - off);\r\n                }\r\n                else if (!after && (end > pos || off == end && child.getSide() > 0)) {\r\n                    after = child;\r\n                    afterPos = pos - off;\r\n                }\r\n                else if (off < pos || (off == end && child.getSide() < 0)) {\r\n                    before = child;\r\n                    beforePos = pos - off;\r\n                }\r\n            }\r\n            off = end;\r\n        }\r\n    }\r\n    scan(view, pos);\r\n    let target = (side < 0 ? before : after) || before || after;\r\n    if (target)\r\n        return target.coordsAt(Math.max(0, target == before ? beforePos : afterPos), side);\r\n    return fallbackRect(view);\r\n}\r\nfunction fallbackRect(view) {\r\n    let last = view.dom.lastChild;\r\n    if (!last)\r\n        return view.dom.getBoundingClientRect();\r\n    let rects = clientRectsFor(last);\r\n    return rects[rects.length - 1] || null;\r\n}\r\n\r\nfunction combineAttrs(source, target) {\r\n    for (let name in source) {\r\n        if (name == \"class\" && target.class)\r\n            target.class += \" \" + source.class;\r\n        else if (name == \"style\" && target.style)\r\n            target.style += \";\" + source.style;\r\n        else\r\n            target[name] = source[name];\r\n    }\r\n    return target;\r\n}\r\nfunction attrsEq(a, b) {\r\n    if (a == b)\r\n        return true;\r\n    if (!a || !b)\r\n        return false;\r\n    let keysA = Object.keys(a), keysB = Object.keys(b);\r\n    if (keysA.length != keysB.length)\r\n        return false;\r\n    for (let key of keysA) {\r\n        if (keysB.indexOf(key) == -1 || a[key] !== b[key])\r\n            return false;\r\n    }\r\n    return true;\r\n}\r\nfunction updateAttrs(dom, prev, attrs) {\r\n    let changed = null;\r\n    if (prev)\r\n        for (let name in prev)\r\n            if (!(attrs && name in attrs))\r\n                dom.removeAttribute(changed = name);\r\n    if (attrs)\r\n        for (let name in attrs)\r\n            if (!(prev && prev[name] == attrs[name]))\r\n                dom.setAttribute(changed = name, attrs[name]);\r\n    return !!changed;\r\n}\r\n\r\n/**\r\nWidgets added to the content are described by subclasses of this\r\nclass. Using a description object like that makes it possible to\r\ndelay creating of the DOM structure for a widget until it is\r\nneeded, and to avoid redrawing widgets even if the decorations\r\nthat define them are recreated.\r\n*/\r\nclass WidgetType {\r\n    /**\r\n    Compare this instance to another instance of the same type.\r\n    (TypeScript can't express this, but only instances of the same\r\n    specific class will be passed to this method.) This is used to\r\n    avoid redrawing widgets when they are replaced by a new\r\n    decoration of the same type. The default implementation just\r\n    returns `false`, which will cause new instances of the widget to\r\n    always be redrawn.\r\n    */\r\n    eq(widget) { return false; }\r\n    /**\r\n    Update a DOM element created by a widget of the same type (but\r\n    different, non-`eq` content) to reflect this widget. May return\r\n    true to indicate that it could update, false to indicate it\r\n    couldn't (in which case the widget will be redrawn). The default\r\n    implementation just returns false.\r\n    */\r\n    updateDOM(dom) { return false; }\r\n    /**\r\n    @internal\r\n    */\r\n    compare(other) {\r\n        return this == other || this.constructor == other.constructor && this.eq(other);\r\n    }\r\n    /**\r\n    The estimated height this widget will have, to be used when\r\n    estimating the height of content that hasn't been drawn. May\r\n    return -1 to indicate you don't know. The default implementation\r\n    returns -1.\r\n    */\r\n    get estimatedHeight() { return -1; }\r\n    /**\r\n    Can be used to configure which kinds of events inside the widget\r\n    should be ignored by the editor. The default is to ignore all\r\n    events.\r\n    */\r\n    ignoreEvent(event) { return true; }\r\n    /**\r\n    @internal\r\n    */\r\n    get customView() { return null; }\r\n    /**\r\n    This is called when the an instance of the widget is removed\r\n    from the editor view.\r\n    */\r\n    destroy(dom) { }\r\n}\r\n/**\r\nThe different types of blocks that can occur in an editor view.\r\n*/\r\nvar BlockType = /*@__PURE__*/(function (BlockType) {\r\n    /**\r\n    A line of text.\r\n    */\r\n    BlockType[BlockType[\"Text\"] = 0] = \"Text\";\r\n    /**\r\n    A block widget associated with the position after it.\r\n    */\r\n    BlockType[BlockType[\"WidgetBefore\"] = 1] = \"WidgetBefore\";\r\n    /**\r\n    A block widget associated with the position before it.\r\n    */\r\n    BlockType[BlockType[\"WidgetAfter\"] = 2] = \"WidgetAfter\";\r\n    /**\r\n    A block widget [replacing](https://codemirror.net/6/docs/ref/#view.Decoration^replace) a range of content.\r\n    */\r\n    BlockType[BlockType[\"WidgetRange\"] = 3] = \"WidgetRange\";\r\nreturn BlockType})(BlockType || (BlockType = {}));\r\n/**\r\nA decoration provides information on how to draw or style a piece\r\nof content. You'll usually use it wrapped in a\r\n[`Range`](https://codemirror.net/6/docs/ref/#state.Range), which adds a start and end position.\r\n@nonabstract\r\n*/\r\nclass Decoration extends _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.RangeValue {\r\n    constructor(\r\n    /**\r\n    @internal\r\n    */\r\n    startSide, \r\n    /**\r\n    @internal\r\n    */\r\n    endSide, \r\n    /**\r\n    @internal\r\n    */\r\n    widget, \r\n    /**\r\n    The config object used to create this decoration. You can\r\n    include additional properties in there to store metadata about\r\n    your decoration.\r\n    */\r\n    spec) {\r\n        super();\r\n        this.startSide = startSide;\r\n        this.endSide = endSide;\r\n        this.widget = widget;\r\n        this.spec = spec;\r\n    }\r\n    /**\r\n    @internal\r\n    */\r\n    get heightRelevant() { return false; }\r\n    /**\r\n    Create a mark decoration, which influences the styling of the\r\n    content in its range. Nested mark decorations will cause nested\r\n    DOM elements to be created. Nesting order is determined by\r\n    precedence of the [facet](https://codemirror.net/6/docs/ref/#view.EditorView^decorations), with\r\n    the higher-precedence decorations creating the inner DOM nodes.\r\n    Such elements are split on line boundaries and on the boundaries\r\n    of lower-precedence decorations.\r\n    */\r\n    static mark(spec) {\r\n        return new MarkDecoration(spec);\r\n    }\r\n    /**\r\n    Create a widget decoration, which displays a DOM element at the\r\n    given position.\r\n    */\r\n    static widget(spec) {\r\n        let side = spec.side || 0, block = !!spec.block;\r\n        side += block ? (side > 0 ? 300000000 /* Side.BlockAfter */ : -400000000 /* Side.BlockBefore */) : (side > 0 ? 100000000 /* Side.InlineAfter */ : -100000000 /* Side.InlineBefore */);\r\n        return new PointDecoration(spec, side, side, block, spec.widget || null, false);\r\n    }\r\n    /**\r\n    Create a replace decoration which replaces the given range with\r\n    a widget, or simply hides it.\r\n    */\r\n    static replace(spec) {\r\n        let block = !!spec.block, startSide, endSide;\r\n        if (spec.isBlockGap) {\r\n            startSide = -500000000 /* Side.GapStart */;\r\n            endSide = 400000000 /* Side.GapEnd */;\r\n        }\r\n        else {\r\n            let { start, end } = getInclusive(spec, block);\r\n            startSide = (start ? (block ? -300000000 /* Side.BlockIncStart */ : -1 /* Side.InlineIncStart */) : 500000000 /* Side.NonIncStart */) - 1;\r\n            endSide = (end ? (block ? 200000000 /* Side.BlockIncEnd */ : 1 /* Side.InlineIncEnd */) : -600000000 /* Side.NonIncEnd */) + 1;\r\n        }\r\n        return new PointDecoration(spec, startSide, endSide, block, spec.widget || null, true);\r\n    }\r\n    /**\r\n    Create a line decoration, which can add DOM attributes to the\r\n    line starting at the given position.\r\n    */\r\n    static line(spec) {\r\n        return new LineDecoration(spec);\r\n    }\r\n    /**\r\n    Build a [`DecorationSet`](https://codemirror.net/6/docs/ref/#view.DecorationSet) from the given\r\n    decorated range or ranges. If the ranges aren't already sorted,\r\n    pass `true` for `sort` to make the library sort them for you.\r\n    */\r\n    static set(of, sort = false) {\r\n        return _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.RangeSet.of(of, sort);\r\n    }\r\n    /**\r\n    @internal\r\n    */\r\n    hasHeight() { return this.widget ? this.widget.estimatedHeight > -1 : false; }\r\n}\r\n/**\r\nThe empty set of decorations.\r\n*/\r\nDecoration.none = _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.RangeSet.empty;\r\nclass MarkDecoration extends Decoration {\r\n    constructor(spec) {\r\n        let { start, end } = getInclusive(spec);\r\n        super(start ? -1 /* Side.InlineIncStart */ : 500000000 /* Side.NonIncStart */, end ? 1 /* Side.InlineIncEnd */ : -600000000 /* Side.NonIncEnd */, null, spec);\r\n        this.tagName = spec.tagName || \"span\";\r\n        this.class = spec.class || \"\";\r\n        this.attrs = spec.attributes || null;\r\n    }\r\n    eq(other) {\r\n        return this == other ||\r\n            other instanceof MarkDecoration &&\r\n                this.tagName == other.tagName &&\r\n                this.class == other.class &&\r\n                attrsEq(this.attrs, other.attrs);\r\n    }\r\n    range(from, to = from) {\r\n        if (from >= to)\r\n            throw new RangeError(\"Mark decorations may not be empty\");\r\n        return super.range(from, to);\r\n    }\r\n}\r\nMarkDecoration.prototype.point = false;\r\nclass LineDecoration extends Decoration {\r\n    constructor(spec) {\r\n        super(-200000000 /* Side.Line */, -200000000 /* Side.Line */, null, spec);\r\n    }\r\n    eq(other) {\r\n        return other instanceof LineDecoration &&\r\n            this.spec.class == other.spec.class &&\r\n            attrsEq(this.spec.attributes, other.spec.attributes);\r\n    }\r\n    range(from, to = from) {\r\n        if (to != from)\r\n            throw new RangeError(\"Line decoration ranges must be zero-length\");\r\n        return super.range(from, to);\r\n    }\r\n}\r\nLineDecoration.prototype.mapMode = _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.MapMode.TrackBefore;\r\nLineDecoration.prototype.point = true;\r\nclass PointDecoration extends Decoration {\r\n    constructor(spec, startSide, endSide, block, widget, isReplace) {\r\n        super(startSide, endSide, widget, spec);\r\n        this.block = block;\r\n        this.isReplace = isReplace;\r\n        this.mapMode = !block ? _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.MapMode.TrackDel : startSide <= 0 ? _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.MapMode.TrackBefore : _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.MapMode.TrackAfter;\r\n    }\r\n    // Only relevant when this.block == true\r\n    get type() {\r\n        return this.startSide < this.endSide ? BlockType.WidgetRange\r\n            : this.startSide <= 0 ? BlockType.WidgetBefore : BlockType.WidgetAfter;\r\n    }\r\n    get heightRelevant() { return this.block || !!this.widget && this.widget.estimatedHeight >= 5; }\r\n    eq(other) {\r\n        return other instanceof PointDecoration &&\r\n            widgetsEq(this.widget, other.widget) &&\r\n            this.block == other.block &&\r\n            this.startSide == other.startSide && this.endSide == other.endSide;\r\n    }\r\n    range(from, to = from) {\r\n        if (this.isReplace && (from > to || (from == to && this.startSide > 0 && this.endSide <= 0)))\r\n            throw new RangeError(\"Invalid range for replacement decoration\");\r\n        if (!this.isReplace && to != from)\r\n            throw new RangeError(\"Widget decorations can only have zero-length ranges\");\r\n        return super.range(from, to);\r\n    }\r\n}\r\nPointDecoration.prototype.point = true;\r\nfunction getInclusive(spec, block = false) {\r\n    let { inclusiveStart: start, inclusiveEnd: end } = spec;\r\n    if (start == null)\r\n        start = spec.inclusive;\r\n    if (end == null)\r\n        end = spec.inclusive;\r\n    return { start: start !== null && start !== void 0 ? start : block, end: end !== null && end !== void 0 ? end : block };\r\n}\r\nfunction widgetsEq(a, b) {\r\n    return a == b || !!(a && b && a.compare(b));\r\n}\r\nfunction addRange(from, to, ranges, margin = 0) {\r\n    let last = ranges.length - 1;\r\n    if (last >= 0 && ranges[last] + margin >= from)\r\n        ranges[last] = Math.max(ranges[last], to);\r\n    else\r\n        ranges.push(from, to);\r\n}\r\n\r\nclass LineView extends ContentView {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.children = [];\r\n        this.length = 0;\r\n        this.prevAttrs = undefined;\r\n        this.attrs = null;\r\n        this.breakAfter = 0;\r\n    }\r\n    // Consumes source\r\n    merge(from, to, source, hasStart, openStart, openEnd) {\r\n        if (source) {\r\n            if (!(source instanceof LineView))\r\n                return false;\r\n            if (!this.dom)\r\n                source.transferDOM(this); // Reuse source.dom when appropriate\r\n        }\r\n        if (hasStart)\r\n            this.setDeco(source ? source.attrs : null);\r\n        mergeChildrenInto(this, from, to, source ? source.children : [], openStart, openEnd);\r\n        return true;\r\n    }\r\n    split(at) {\r\n        let end = new LineView;\r\n        end.breakAfter = this.breakAfter;\r\n        if (this.length == 0)\r\n            return end;\r\n        let { i, off } = this.childPos(at);\r\n        if (off) {\r\n            end.append(this.children[i].split(off), 0);\r\n            this.children[i].merge(off, this.children[i].length, null, false, 0, 0);\r\n            i++;\r\n        }\r\n        for (let j = i; j < this.children.length; j++)\r\n            end.append(this.children[j], 0);\r\n        while (i > 0 && this.children[i - 1].length == 0)\r\n            this.children[--i].destroy();\r\n        this.children.length = i;\r\n        this.markDirty();\r\n        this.length = at;\r\n        return end;\r\n    }\r\n    transferDOM(other) {\r\n        if (!this.dom)\r\n            return;\r\n        this.markDirty();\r\n        other.setDOM(this.dom);\r\n        other.prevAttrs = this.prevAttrs === undefined ? this.attrs : this.prevAttrs;\r\n        this.prevAttrs = undefined;\r\n        this.dom = null;\r\n    }\r\n    setDeco(attrs) {\r\n        if (!attrsEq(this.attrs, attrs)) {\r\n            if (this.dom) {\r\n                this.prevAttrs = this.attrs;\r\n                this.markDirty();\r\n            }\r\n            this.attrs = attrs;\r\n        }\r\n    }\r\n    append(child, openStart) {\r\n        joinInlineInto(this, child, openStart);\r\n    }\r\n    // Only called when building a line view in ContentBuilder\r\n    addLineDeco(deco) {\r\n        let attrs = deco.spec.attributes, cls = deco.spec.class;\r\n        if (attrs)\r\n            this.attrs = combineAttrs(attrs, this.attrs || {});\r\n        if (cls)\r\n            this.attrs = combineAttrs({ class: cls }, this.attrs || {});\r\n    }\r\n    domAtPos(pos) {\r\n        return inlineDOMAtPos(this, pos);\r\n    }\r\n    reuseDOM(node) {\r\n        if (node.nodeName == \"DIV\") {\r\n            this.setDOM(node);\r\n            this.dirty |= 4 /* Dirty.Attrs */ | 2 /* Dirty.Node */;\r\n        }\r\n    }\r\n    sync(track) {\r\n        var _a;\r\n        if (!this.dom) {\r\n            this.setDOM(document.createElement(\"div\"));\r\n            this.dom.className = \"cm-line\";\r\n            this.prevAttrs = this.attrs ? null : undefined;\r\n        }\r\n        else if (this.dirty & 4 /* Dirty.Attrs */) {\r\n            clearAttributes(this.dom);\r\n            this.dom.className = \"cm-line\";\r\n            this.prevAttrs = this.attrs ? null : undefined;\r\n        }\r\n        if (this.prevAttrs !== undefined) {\r\n            updateAttrs(this.dom, this.prevAttrs, this.attrs);\r\n            this.dom.classList.add(\"cm-line\");\r\n            this.prevAttrs = undefined;\r\n        }\r\n        super.sync(track);\r\n        let last = this.dom.lastChild;\r\n        while (last && ContentView.get(last) instanceof MarkView)\r\n            last = last.lastChild;\r\n        if (!last || !this.length ||\r\n            last.nodeName != \"BR\" && ((_a = ContentView.get(last)) === null || _a === void 0 ? void 0 : _a.isEditable) == false &&\r\n                (!browser.ios || !this.children.some(ch => ch instanceof TextView))) {\r\n            let hack = document.createElement(\"BR\");\r\n            hack.cmIgnore = true;\r\n            this.dom.appendChild(hack);\r\n        }\r\n    }\r\n    measureTextSize() {\r\n        if (this.children.length == 0 || this.length > 20)\r\n            return null;\r\n        let totalWidth = 0;\r\n        for (let child of this.children) {\r\n            if (!(child instanceof TextView) || /[^ -~]/.test(child.text))\r\n                return null;\r\n            let rects = clientRectsFor(child.dom);\r\n            if (rects.length != 1)\r\n                return null;\r\n            totalWidth += rects[0].width;\r\n        }\r\n        return !totalWidth ? null : {\r\n            lineHeight: this.dom.getBoundingClientRect().height,\r\n            charWidth: totalWidth / this.length\r\n        };\r\n    }\r\n    coordsAt(pos, side) {\r\n        return coordsInChildren(this, pos, side);\r\n    }\r\n    become(_other) { return false; }\r\n    get type() { return BlockType.Text; }\r\n    static find(docView, pos) {\r\n        for (let i = 0, off = 0; i < docView.children.length; i++) {\r\n            let block = docView.children[i], end = off + block.length;\r\n            if (end >= pos) {\r\n                if (block instanceof LineView)\r\n                    return block;\r\n                if (end > pos)\r\n                    break;\r\n            }\r\n            off = end + block.breakAfter;\r\n        }\r\n        return null;\r\n    }\r\n}\r\nclass BlockWidgetView extends ContentView {\r\n    constructor(widget, length, type) {\r\n        super();\r\n        this.widget = widget;\r\n        this.length = length;\r\n        this.type = type;\r\n        this.breakAfter = 0;\r\n        this.prevWidget = null;\r\n    }\r\n    merge(from, to, source, _takeDeco, openStart, openEnd) {\r\n        if (source && (!(source instanceof BlockWidgetView) || !this.widget.compare(source.widget) ||\r\n            from > 0 && openStart <= 0 || to < this.length && openEnd <= 0))\r\n            return false;\r\n        this.length = from + (source ? source.length : 0) + (this.length - to);\r\n        return true;\r\n    }\r\n    domAtPos(pos) {\r\n        return pos == 0 ? DOMPos.before(this.dom) : DOMPos.after(this.dom, pos == this.length);\r\n    }\r\n    split(at) {\r\n        let len = this.length - at;\r\n        this.length = at;\r\n        let end = new BlockWidgetView(this.widget, len, this.type);\r\n        end.breakAfter = this.breakAfter;\r\n        return end;\r\n    }\r\n    get children() { return noChildren; }\r\n    sync() {\r\n        if (!this.dom || !this.widget.updateDOM(this.dom)) {\r\n            if (this.dom && this.prevWidget)\r\n                this.prevWidget.destroy(this.dom);\r\n            this.prevWidget = null;\r\n            this.setDOM(this.widget.toDOM(this.editorView));\r\n            this.dom.contentEditable = \"false\";\r\n        }\r\n    }\r\n    get overrideDOMText() {\r\n        return this.parent ? this.parent.view.state.doc.slice(this.posAtStart, this.posAtEnd) : _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Text.empty;\r\n    }\r\n    domBoundsAround() { return null; }\r\n    become(other) {\r\n        if (other instanceof BlockWidgetView && other.type == this.type &&\r\n            other.widget.constructor == this.widget.constructor) {\r\n            if (!other.widget.eq(this.widget))\r\n                this.markDirty(true);\r\n            if (this.dom && !this.prevWidget)\r\n                this.prevWidget = this.widget;\r\n            this.widget = other.widget;\r\n            this.length = other.length;\r\n            this.breakAfter = other.breakAfter;\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    ignoreMutation() { return true; }\r\n    ignoreEvent(event) { return this.widget.ignoreEvent(event); }\r\n    destroy() {\r\n        super.destroy();\r\n        if (this.dom)\r\n            this.widget.destroy(this.dom);\r\n    }\r\n}\r\n\r\nclass ContentBuilder {\r\n    constructor(doc, pos, end, disallowBlockEffectsFor) {\r\n        this.doc = doc;\r\n        this.pos = pos;\r\n        this.end = end;\r\n        this.disallowBlockEffectsFor = disallowBlockEffectsFor;\r\n        this.content = [];\r\n        this.curLine = null;\r\n        this.breakAtStart = 0;\r\n        this.pendingBuffer = 0 /* Buf.No */;\r\n        this.bufferMarks = [];\r\n        // Set to false directly after a widget that covers the position after it\r\n        this.atCursorPos = true;\r\n        this.openStart = -1;\r\n        this.openEnd = -1;\r\n        this.text = \"\";\r\n        this.textOff = 0;\r\n        this.cursor = doc.iter();\r\n        this.skip = pos;\r\n    }\r\n    posCovered() {\r\n        if (this.content.length == 0)\r\n            return !this.breakAtStart && this.doc.lineAt(this.pos).from != this.pos;\r\n        let last = this.content[this.content.length - 1];\r\n        return !last.breakAfter && !(last instanceof BlockWidgetView && last.type == BlockType.WidgetBefore);\r\n    }\r\n    getLine() {\r\n        if (!this.curLine) {\r\n            this.content.push(this.curLine = new LineView);\r\n            this.atCursorPos = true;\r\n        }\r\n        return this.curLine;\r\n    }\r\n    flushBuffer(active = this.bufferMarks) {\r\n        if (this.pendingBuffer) {\r\n            this.curLine.append(wrapMarks(new WidgetBufferView(-1), active), active.length);\r\n            this.pendingBuffer = 0 /* Buf.No */;\r\n        }\r\n    }\r\n    addBlockWidget(view) {\r\n        this.flushBuffer();\r\n        this.curLine = null;\r\n        this.content.push(view);\r\n    }\r\n    finish(openEnd) {\r\n        if (this.pendingBuffer && openEnd <= this.bufferMarks.length)\r\n            this.flushBuffer();\r\n        else\r\n            this.pendingBuffer = 0 /* Buf.No */;\r\n        if (!this.posCovered())\r\n            this.getLine();\r\n    }\r\n    buildText(length, active, openStart) {\r\n        while (length > 0) {\r\n            if (this.textOff == this.text.length) {\r\n                let { value, lineBreak, done } = this.cursor.next(this.skip);\r\n                this.skip = 0;\r\n                if (done)\r\n                    throw new Error(\"Ran out of text content when drawing inline views\");\r\n                if (lineBreak) {\r\n                    if (!this.posCovered())\r\n                        this.getLine();\r\n                    if (this.content.length)\r\n                        this.content[this.content.length - 1].breakAfter = 1;\r\n                    else\r\n                        this.breakAtStart = 1;\r\n                    this.flushBuffer();\r\n                    this.curLine = null;\r\n                    this.atCursorPos = true;\r\n                    length--;\r\n                    continue;\r\n                }\r\n                else {\r\n                    this.text = value;\r\n                    this.textOff = 0;\r\n                }\r\n            }\r\n            let take = Math.min(this.text.length - this.textOff, length, 512 /* T.Chunk */);\r\n            this.flushBuffer(active.slice(active.length - openStart));\r\n            this.getLine().append(wrapMarks(new TextView(this.text.slice(this.textOff, this.textOff + take)), active), openStart);\r\n            this.atCursorPos = true;\r\n            this.textOff += take;\r\n            length -= take;\r\n            openStart = 0;\r\n        }\r\n    }\r\n    span(from, to, active, openStart) {\r\n        this.buildText(to - from, active, openStart);\r\n        this.pos = to;\r\n        if (this.openStart < 0)\r\n            this.openStart = openStart;\r\n    }\r\n    point(from, to, deco, active, openStart, index) {\r\n        if (this.disallowBlockEffectsFor[index] && deco instanceof PointDecoration) {\r\n            if (deco.block)\r\n                throw new RangeError(\"Block decorations may not be specified via plugins\");\r\n            if (to > this.doc.lineAt(this.pos).to)\r\n                throw new RangeError(\"Decorations that replace line breaks may not be specified via plugins\");\r\n        }\r\n        let len = to - from;\r\n        if (deco instanceof PointDecoration) {\r\n            if (deco.block) {\r\n                let { type } = deco;\r\n                if (type == BlockType.WidgetAfter && !this.posCovered())\r\n                    this.getLine();\r\n                this.addBlockWidget(new BlockWidgetView(deco.widget || new NullWidget(\"div\"), len, type));\r\n            }\r\n            else {\r\n                let view = WidgetView.create(deco.widget || new NullWidget(\"span\"), len, len ? 0 : deco.startSide);\r\n                let cursorBefore = this.atCursorPos && !view.isEditable && openStart <= active.length && (from < to || deco.startSide > 0);\r\n                let cursorAfter = !view.isEditable && (from < to || openStart > active.length || deco.startSide <= 0);\r\n                let line = this.getLine();\r\n                if (this.pendingBuffer == 2 /* Buf.IfCursor */ && !cursorBefore)\r\n                    this.pendingBuffer = 0 /* Buf.No */;\r\n                this.flushBuffer(active);\r\n                if (cursorBefore) {\r\n                    line.append(wrapMarks(new WidgetBufferView(1), active), openStart);\r\n                    openStart = active.length + Math.max(0, openStart - active.length);\r\n                }\r\n                line.append(wrapMarks(view, active), openStart);\r\n                this.atCursorPos = cursorAfter;\r\n                this.pendingBuffer = !cursorAfter ? 0 /* Buf.No */ : from < to || openStart > active.length ? 1 /* Buf.Yes */ : 2 /* Buf.IfCursor */;\r\n                if (this.pendingBuffer)\r\n                    this.bufferMarks = active.slice();\r\n            }\r\n        }\r\n        else if (this.doc.lineAt(this.pos).from == this.pos) { // Line decoration\r\n            this.getLine().addLineDeco(deco);\r\n        }\r\n        if (len) {\r\n            // Advance the iterator past the replaced content\r\n            if (this.textOff + len <= this.text.length) {\r\n                this.textOff += len;\r\n            }\r\n            else {\r\n                this.skip += len - (this.text.length - this.textOff);\r\n                this.text = \"\";\r\n                this.textOff = 0;\r\n            }\r\n            this.pos = to;\r\n        }\r\n        if (this.openStart < 0)\r\n            this.openStart = openStart;\r\n    }\r\n    static build(text, from, to, decorations, dynamicDecorationMap) {\r\n        let builder = new ContentBuilder(text, from, to, dynamicDecorationMap);\r\n        builder.openEnd = _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.RangeSet.spans(decorations, from, to, builder);\r\n        if (builder.openStart < 0)\r\n            builder.openStart = builder.openEnd;\r\n        builder.finish(builder.openEnd);\r\n        return builder;\r\n    }\r\n}\r\nfunction wrapMarks(view, active) {\r\n    for (let mark of active)\r\n        view = new MarkView(mark, [view], view.length);\r\n    return view;\r\n}\r\nclass NullWidget extends WidgetType {\r\n    constructor(tag) {\r\n        super();\r\n        this.tag = tag;\r\n    }\r\n    eq(other) { return other.tag == this.tag; }\r\n    toDOM() { return document.createElement(this.tag); }\r\n    updateDOM(elt) { return elt.nodeName.toLowerCase() == this.tag; }\r\n}\r\n\r\nconst clickAddsSelectionRange = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define();\r\nconst dragMovesSelection$1 = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define();\r\nconst mouseSelectionStyle = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define();\r\nconst exceptionSink = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define();\r\nconst updateListener = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define();\r\nconst inputHandler = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define();\r\nconst perLineTextDirection = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define({\r\n    combine: values => values.some(x => x)\r\n});\r\nconst nativeSelectionHidden = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define({\r\n    combine: values => values.some(x => x)\r\n});\r\nclass ScrollTarget {\r\n    constructor(range, y = \"nearest\", x = \"nearest\", yMargin = 5, xMargin = 5) {\r\n        this.range = range;\r\n        this.y = y;\r\n        this.x = x;\r\n        this.yMargin = yMargin;\r\n        this.xMargin = xMargin;\r\n    }\r\n    map(changes) {\r\n        return changes.empty ? this : new ScrollTarget(this.range.map(changes), this.y, this.x, this.yMargin, this.xMargin);\r\n    }\r\n}\r\nconst scrollIntoView = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.StateEffect.define({ map: (t, ch) => t.map(ch) });\r\n/**\r\nLog or report an unhandled exception in client code. Should\r\nprobably only be used by extension code that allows client code to\r\nprovide functions, and calls those functions in a context where an\r\nexception can't be propagated to calling code in a reasonable way\r\n(for example when in an event handler).\r\n\r\nEither calls a handler registered with\r\n[`EditorView.exceptionSink`](https://codemirror.net/6/docs/ref/#view.EditorView^exceptionSink),\r\n`window.onerror`, if defined, or `console.error` (in which case\r\nit'll pass `context`, when given, as first argument).\r\n*/\r\nfunction logException(state, exception, context) {\r\n    let handler = state.facet(exceptionSink);\r\n    if (handler.length)\r\n        handler[0](exception);\r\n    else if (window.onerror)\r\n        window.onerror(String(exception), context, undefined, undefined, exception);\r\n    else if (context)\r\n        console.error(context + \":\", exception);\r\n    else\r\n        console.error(exception);\r\n}\r\nconst editable = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define({ combine: values => values.length ? values[0] : true });\r\nlet nextPluginID = 0;\r\nconst viewPlugin = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define();\r\n/**\r\nView plugins associate stateful values with a view. They can\r\ninfluence the way the content is drawn, and are notified of things\r\nthat happen in the view.\r\n*/\r\nclass ViewPlugin {\r\n    constructor(\r\n    /**\r\n    @internal\r\n    */\r\n    id, \r\n    /**\r\n    @internal\r\n    */\r\n    create, \r\n    /**\r\n    @internal\r\n    */\r\n    domEventHandlers, buildExtensions) {\r\n        this.id = id;\r\n        this.create = create;\r\n        this.domEventHandlers = domEventHandlers;\r\n        this.extension = buildExtensions(this);\r\n    }\r\n    /**\r\n    Define a plugin from a constructor function that creates the\r\n    plugin's value, given an editor view.\r\n    */\r\n    static define(create, spec) {\r\n        const { eventHandlers, provide, decorations: deco } = spec || {};\r\n        return new ViewPlugin(nextPluginID++, create, eventHandlers, plugin => {\r\n            let ext = [viewPlugin.of(plugin)];\r\n            if (deco)\r\n                ext.push(decorations.of(view => {\r\n                    let pluginInst = view.plugin(plugin);\r\n                    return pluginInst ? deco(pluginInst) : Decoration.none;\r\n                }));\r\n            if (provide)\r\n                ext.push(provide(plugin));\r\n            return ext;\r\n        });\r\n    }\r\n    /**\r\n    Create a plugin for a class whose constructor takes a single\r\n    editor view as argument.\r\n    */\r\n    static fromClass(cls, spec) {\r\n        return ViewPlugin.define(view => new cls(view), spec);\r\n    }\r\n}\r\nclass PluginInstance {\r\n    constructor(spec) {\r\n        this.spec = spec;\r\n        // When starting an update, all plugins have this field set to the\r\n        // update object, indicating they need to be updated. When finished\r\n        // updating, it is set to `false`. Retrieving a plugin that needs to\r\n        // be updated with `view.plugin` forces an eager update.\r\n        this.mustUpdate = null;\r\n        // This is null when the plugin is initially created, but\r\n        // initialized on the first update.\r\n        this.value = null;\r\n    }\r\n    update(view) {\r\n        if (!this.value) {\r\n            if (this.spec) {\r\n                try {\r\n                    this.value = this.spec.create(view);\r\n                }\r\n                catch (e) {\r\n                    logException(view.state, e, \"CodeMirror plugin crashed\");\r\n                    this.deactivate();\r\n                }\r\n            }\r\n        }\r\n        else if (this.mustUpdate) {\r\n            let update = this.mustUpdate;\r\n            this.mustUpdate = null;\r\n            if (this.value.update) {\r\n                try {\r\n                    this.value.update(update);\r\n                }\r\n                catch (e) {\r\n                    logException(update.state, e, \"CodeMirror plugin crashed\");\r\n                    if (this.value.destroy)\r\n                        try {\r\n                            this.value.destroy();\r\n                        }\r\n                        catch (_) { }\r\n                    this.deactivate();\r\n                }\r\n            }\r\n        }\r\n        return this;\r\n    }\r\n    destroy(view) {\r\n        var _a;\r\n        if ((_a = this.value) === null || _a === void 0 ? void 0 : _a.destroy) {\r\n            try {\r\n                this.value.destroy();\r\n            }\r\n            catch (e) {\r\n                logException(view.state, e, \"CodeMirror plugin crashed\");\r\n            }\r\n        }\r\n    }\r\n    deactivate() {\r\n        this.spec = this.value = null;\r\n    }\r\n}\r\nconst editorAttributes = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define();\r\nconst contentAttributes = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define();\r\n// Provide decorations\r\nconst decorations = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define();\r\nconst atomicRanges = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define();\r\nconst scrollMargins = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define();\r\nconst styleModule = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define();\r\nclass ChangedRange {\r\n    constructor(fromA, toA, fromB, toB) {\r\n        this.fromA = fromA;\r\n        this.toA = toA;\r\n        this.fromB = fromB;\r\n        this.toB = toB;\r\n    }\r\n    join(other) {\r\n        return new ChangedRange(Math.min(this.fromA, other.fromA), Math.max(this.toA, other.toA), Math.min(this.fromB, other.fromB), Math.max(this.toB, other.toB));\r\n    }\r\n    addToSet(set) {\r\n        let i = set.length, me = this;\r\n        for (; i > 0; i--) {\r\n            let range = set[i - 1];\r\n            if (range.fromA > me.toA)\r\n                continue;\r\n            if (range.toA < me.fromA)\r\n                break;\r\n            me = me.join(range);\r\n            set.splice(i - 1, 1);\r\n        }\r\n        set.splice(i, 0, me);\r\n        return set;\r\n    }\r\n    static extendWithRanges(diff, ranges) {\r\n        if (ranges.length == 0)\r\n            return diff;\r\n        let result = [];\r\n        for (let dI = 0, rI = 0, posA = 0, posB = 0;; dI++) {\r\n            let next = dI == diff.length ? null : diff[dI], off = posA - posB;\r\n            let end = next ? next.fromB : 1e9;\r\n            while (rI < ranges.length && ranges[rI] < end) {\r\n                let from = ranges[rI], to = ranges[rI + 1];\r\n                let fromB = Math.max(posB, from), toB = Math.min(end, to);\r\n                if (fromB <= toB)\r\n                    new ChangedRange(fromB + off, toB + off, fromB, toB).addToSet(result);\r\n                if (to > end)\r\n                    break;\r\n                else\r\n                    rI += 2;\r\n            }\r\n            if (!next)\r\n                return result;\r\n            new ChangedRange(next.fromA, next.toA, next.fromB, next.toB).addToSet(result);\r\n            posA = next.toA;\r\n            posB = next.toB;\r\n        }\r\n    }\r\n}\r\n/**\r\nView [plugins](https://codemirror.net/6/docs/ref/#view.ViewPlugin) are given instances of this\r\nclass, which describe what happened, whenever the view is updated.\r\n*/\r\nclass ViewUpdate {\r\n    constructor(\r\n    /**\r\n    The editor view that the update is associated with.\r\n    */\r\n    view, \r\n    /**\r\n    The new editor state.\r\n    */\r\n    state, \r\n    /**\r\n    The transactions involved in the update. May be empty.\r\n    */\r\n    transactions) {\r\n        this.view = view;\r\n        this.state = state;\r\n        this.transactions = transactions;\r\n        /**\r\n        @internal\r\n        */\r\n        this.flags = 0;\r\n        this.startState = view.state;\r\n        this.changes = _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.ChangeSet.empty(this.startState.doc.length);\r\n        for (let tr of transactions)\r\n            this.changes = this.changes.compose(tr.changes);\r\n        let changedRanges = [];\r\n        this.changes.iterChangedRanges((fromA, toA, fromB, toB) => changedRanges.push(new ChangedRange(fromA, toA, fromB, toB)));\r\n        this.changedRanges = changedRanges;\r\n        let focus = view.hasFocus;\r\n        if (focus != view.inputState.notifiedFocused) {\r\n            view.inputState.notifiedFocused = focus;\r\n            this.flags |= 1 /* UpdateFlag.Focus */;\r\n        }\r\n    }\r\n    /**\r\n    @internal\r\n    */\r\n    static create(view, state, transactions) {\r\n        return new ViewUpdate(view, state, transactions);\r\n    }\r\n    /**\r\n    Tells you whether the [viewport](https://codemirror.net/6/docs/ref/#view.EditorView.viewport) or\r\n    [visible ranges](https://codemirror.net/6/docs/ref/#view.EditorView.visibleRanges) changed in this\r\n    update.\r\n    */\r\n    get viewportChanged() {\r\n        return (this.flags & 4 /* UpdateFlag.Viewport */) > 0;\r\n    }\r\n    /**\r\n    Indicates whether the height of a block element in the editor\r\n    changed in this update.\r\n    */\r\n    get heightChanged() {\r\n        return (this.flags & 2 /* UpdateFlag.Height */) > 0;\r\n    }\r\n    /**\r\n    Returns true when the document was modified or the size of the\r\n    editor, or elements within the editor, changed.\r\n    */\r\n    get geometryChanged() {\r\n        return this.docChanged || (this.flags & (8 /* UpdateFlag.Geometry */ | 2 /* UpdateFlag.Height */)) > 0;\r\n    }\r\n    /**\r\n    True when this update indicates a focus change.\r\n    */\r\n    get focusChanged() {\r\n        return (this.flags & 1 /* UpdateFlag.Focus */) > 0;\r\n    }\r\n    /**\r\n    Whether the document changed in this update.\r\n    */\r\n    get docChanged() {\r\n        return !this.changes.empty;\r\n    }\r\n    /**\r\n    Whether the selection was explicitly set in this update.\r\n    */\r\n    get selectionSet() {\r\n        return this.transactions.some(tr => tr.selection);\r\n    }\r\n    /**\r\n    @internal\r\n    */\r\n    get empty() { return this.flags == 0 && this.transactions.length == 0; }\r\n}\r\n\r\n/**\r\nUsed to indicate [text direction](https://codemirror.net/6/docs/ref/#view.EditorView.textDirection).\r\n*/\r\nvar Direction = /*@__PURE__*/(function (Direction) {\r\n    // (These are chosen to match the base levels, in bidi algorithm\r\n    // terms, of spans in that direction.)\r\n    /**\r\n    Left-to-right.\r\n    */\r\n    Direction[Direction[\"LTR\"] = 0] = \"LTR\";\r\n    /**\r\n    Right-to-left.\r\n    */\r\n    Direction[Direction[\"RTL\"] = 1] = \"RTL\";\r\nreturn Direction})(Direction || (Direction = {}));\r\nconst LTR = Direction.LTR, RTL = Direction.RTL;\r\n// Decode a string with each type encoded as log2(type)\r\nfunction dec(str) {\r\n    let result = [];\r\n    for (let i = 0; i < str.length; i++)\r\n        result.push(1 << +str[i]);\r\n    return result;\r\n}\r\n// Character types for codepoints 0 to 0xf8\r\nconst LowTypes = /*@__PURE__*/dec(\"88888888888888888888888888888888888666888888787833333333337888888000000000000000000000000008888880000000000000000000000000088888888888888888888888888888888888887866668888088888663380888308888800000000000000000000000800000000000000000000000000000008\");\r\n// Character types for codepoints 0x600 to 0x6f9\r\nconst ArabicTypes = /*@__PURE__*/dec(\"4444448826627288999999999992222222222222222222222222222222222222222222222229999999999999999999994444444444644222822222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222999999949999999229989999223333333333\");\r\nconst Brackets = /*@__PURE__*/Object.create(null), BracketStack = [];\r\n// There's a lot more in\r\n// https://www.unicode.org/Public/UCD/latest/ucd/BidiBrackets.txt,\r\n// which are left out to keep code size down.\r\nfor (let p of [\"()\", \"[]\", \"{}\"]) {\r\n    let l = /*@__PURE__*/p.charCodeAt(0), r = /*@__PURE__*/p.charCodeAt(1);\r\n    Brackets[l] = r;\r\n    Brackets[r] = -l;\r\n}\r\nfunction charType(ch) {\r\n    return ch <= 0xf7 ? LowTypes[ch] :\r\n        0x590 <= ch && ch <= 0x5f4 ? 2 /* T.R */ :\r\n            0x600 <= ch && ch <= 0x6f9 ? ArabicTypes[ch - 0x600] :\r\n                0x6ee <= ch && ch <= 0x8ac ? 4 /* T.AL */ :\r\n                    0x2000 <= ch && ch <= 0x200b ? 256 /* T.NI */ :\r\n                        0xfb50 <= ch && ch <= 0xfdff ? 4 /* T.AL */ :\r\n                            ch == 0x200c ? 256 /* T.NI */ : 1 /* T.L */;\r\n}\r\nconst BidiRE = /[\\u0590-\\u05f4\\u0600-\\u06ff\\u0700-\\u08ac\\ufb50-\\ufdff]/;\r\n/**\r\nRepresents a contiguous range of text that has a single direction\r\n(as in left-to-right or right-to-left).\r\n*/\r\nclass BidiSpan {\r\n    /**\r\n    @internal\r\n    */\r\n    constructor(\r\n    /**\r\n    The start of the span (relative to the start of the line).\r\n    */\r\n    from, \r\n    /**\r\n    The end of the span.\r\n    */\r\n    to, \r\n    /**\r\n    The [\"bidi\r\n    level\"](https://unicode.org/reports/tr9/#Basic_Display_Algorithm)\r\n    of the span (in this context, 0 means\r\n    left-to-right, 1 means right-to-left, 2 means left-to-right\r\n    number inside right-to-left text).\r\n    */\r\n    level) {\r\n        this.from = from;\r\n        this.to = to;\r\n        this.level = level;\r\n    }\r\n    /**\r\n    The direction of this span.\r\n    */\r\n    get dir() { return this.level % 2 ? RTL : LTR; }\r\n    /**\r\n    @internal\r\n    */\r\n    side(end, dir) { return (this.dir == dir) == end ? this.to : this.from; }\r\n    /**\r\n    @internal\r\n    */\r\n    static find(order, index, level, assoc) {\r\n        let maybe = -1;\r\n        for (let i = 0; i < order.length; i++) {\r\n            let span = order[i];\r\n            if (span.from <= index && span.to >= index) {\r\n                if (span.level == level)\r\n                    return i;\r\n                // When multiple spans match, if assoc != 0, take the one that\r\n                // covers that side, otherwise take the one with the minimum\r\n                // level.\r\n                if (maybe < 0 || (assoc != 0 ? (assoc < 0 ? span.from < index : span.to > index) : order[maybe].level > span.level))\r\n                    maybe = i;\r\n            }\r\n        }\r\n        if (maybe < 0)\r\n            throw new RangeError(\"Index out of range\");\r\n        return maybe;\r\n    }\r\n}\r\n// Reused array of character types\r\nconst types = [];\r\nfunction computeOrder(line, direction) {\r\n    let len = line.length, outerType = direction == LTR ? 1 /* T.L */ : 2 /* T.R */, oppositeType = direction == LTR ? 2 /* T.R */ : 1 /* T.L */;\r\n    if (!line || outerType == 1 /* T.L */ && !BidiRE.test(line))\r\n        return trivialOrder(len);\r\n    // W1. Examine each non-spacing mark (NSM) in the level run, and\r\n    // change the type of the NSM to the type of the previous\r\n    // character. If the NSM is at the start of the level run, it will\r\n    // get the type of sor.\r\n    // W2. Search backwards from each instance of a European number\r\n    // until the first strong type (R, L, AL, or sor) is found. If an\r\n    // AL is found, change the type of the European number to Arabic\r\n    // number.\r\n    // W3. Change all ALs to R.\r\n    // (Left after this: L, R, EN, AN, ET, CS, NI)\r\n    for (let i = 0, prev = outerType, prevStrong = outerType; i < len; i++) {\r\n        let type = charType(line.charCodeAt(i));\r\n        if (type == 512 /* T.NSM */)\r\n            type = prev;\r\n        else if (type == 8 /* T.EN */ && prevStrong == 4 /* T.AL */)\r\n            type = 16 /* T.AN */;\r\n        types[i] = type == 4 /* T.AL */ ? 2 /* T.R */ : type;\r\n        if (type & 7 /* T.Strong */)\r\n            prevStrong = type;\r\n        prev = type;\r\n    }\r\n    // W5. A sequence of European terminators adjacent to European\r\n    // numbers changes to all European numbers.\r\n    // W6. Otherwise, separators and terminators change to Other\r\n    // Neutral.\r\n    // W7. Search backwards from each instance of a European number\r\n    // until the first strong type (R, L, or sor) is found. If an L is\r\n    // found, then change the type of the European number to L.\r\n    // (Left after this: L, R, EN+AN, NI)\r\n    for (let i = 0, prev = outerType, prevStrong = outerType; i < len; i++) {\r\n        let type = types[i];\r\n        if (type == 128 /* T.CS */) {\r\n            if (i < len - 1 && prev == types[i + 1] && (prev & 24 /* T.Num */))\r\n                type = types[i] = prev;\r\n            else\r\n                types[i] = 256 /* T.NI */;\r\n        }\r\n        else if (type == 64 /* T.ET */) {\r\n            let end = i + 1;\r\n            while (end < len && types[end] == 64 /* T.ET */)\r\n                end++;\r\n            let replace = (i && prev == 8 /* T.EN */) || (end < len && types[end] == 8 /* T.EN */) ? (prevStrong == 1 /* T.L */ ? 1 /* T.L */ : 8 /* T.EN */) : 256 /* T.NI */;\r\n            for (let j = i; j < end; j++)\r\n                types[j] = replace;\r\n            i = end - 1;\r\n        }\r\n        else if (type == 8 /* T.EN */ && prevStrong == 1 /* T.L */) {\r\n            types[i] = 1 /* T.L */;\r\n        }\r\n        prev = type;\r\n        if (type & 7 /* T.Strong */)\r\n            prevStrong = type;\r\n    }\r\n    // N0. Process bracket pairs in an isolating run sequence\r\n    // sequentially in the logical order of the text positions of the\r\n    // opening paired brackets using the logic given below. Within this\r\n    // scope, bidirectional types EN and AN are treated as R.\r\n    for (let i = 0, sI = 0, context = 0, ch, br, type; i < len; i++) {\r\n        // Keeps [startIndex, type, strongSeen] triples for each open\r\n        // bracket on BracketStack.\r\n        if (br = Brackets[ch = line.charCodeAt(i)]) {\r\n            if (br < 0) { // Closing bracket\r\n                for (let sJ = sI - 3; sJ >= 0; sJ -= 3) {\r\n                    if (BracketStack[sJ + 1] == -br) {\r\n                        let flags = BracketStack[sJ + 2];\r\n                        let type = (flags & 2 /* Bracketed.EmbedInside */) ? outerType :\r\n                            !(flags & 4 /* Bracketed.OppositeInside */) ? 0 :\r\n                                (flags & 1 /* Bracketed.OppositeBefore */) ? oppositeType : outerType;\r\n                        if (type)\r\n                            types[i] = types[BracketStack[sJ]] = type;\r\n                        sI = sJ;\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n            else if (BracketStack.length == 189 /* Bracketed.MaxDepth */) {\r\n                break;\r\n            }\r\n            else {\r\n                BracketStack[sI++] = i;\r\n                BracketStack[sI++] = ch;\r\n                BracketStack[sI++] = context;\r\n            }\r\n        }\r\n        else if ((type = types[i]) == 2 /* T.R */ || type == 1 /* T.L */) {\r\n            let embed = type == outerType;\r\n            context = embed ? 0 : 1 /* Bracketed.OppositeBefore */;\r\n            for (let sJ = sI - 3; sJ >= 0; sJ -= 3) {\r\n                let cur = BracketStack[sJ + 2];\r\n                if (cur & 2 /* Bracketed.EmbedInside */)\r\n                    break;\r\n                if (embed) {\r\n                    BracketStack[sJ + 2] |= 2 /* Bracketed.EmbedInside */;\r\n                }\r\n                else {\r\n                    if (cur & 4 /* Bracketed.OppositeInside */)\r\n                        break;\r\n                    BracketStack[sJ + 2] |= 4 /* Bracketed.OppositeInside */;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    // N1. A sequence of neutrals takes the direction of the\r\n    // surrounding strong text if the text on both sides has the same\r\n    // direction. European and Arabic numbers act as if they were R in\r\n    // terms of their influence on neutrals. Start-of-level-run (sor)\r\n    // and end-of-level-run (eor) are used at level run boundaries.\r\n    // N2. Any remaining neutrals take the embedding direction.\r\n    // (Left after this: L, R, EN+AN)\r\n    for (let i = 0; i < len; i++) {\r\n        if (types[i] == 256 /* T.NI */) {\r\n            let end = i + 1;\r\n            while (end < len && types[end] == 256 /* T.NI */)\r\n                end++;\r\n            let beforeL = (i ? types[i - 1] : outerType) == 1 /* T.L */;\r\n            let afterL = (end < len ? types[end] : outerType) == 1 /* T.L */;\r\n            let replace = beforeL == afterL ? (beforeL ? 1 /* T.L */ : 2 /* T.R */) : outerType;\r\n            for (let j = i; j < end; j++)\r\n                types[j] = replace;\r\n            i = end - 1;\r\n        }\r\n    }\r\n    // Here we depart from the documented algorithm, in order to avoid\r\n    // building up an actual levels array. Since there are only three\r\n    // levels (0, 1, 2) in an implementation that doesn't take\r\n    // explicit embedding into account, we can build up the order on\r\n    // the fly, without following the level-based algorithm.\r\n    let order = [];\r\n    if (outerType == 1 /* T.L */) {\r\n        for (let i = 0; i < len;) {\r\n            let start = i, rtl = types[i++] != 1 /* T.L */;\r\n            while (i < len && rtl == (types[i] != 1 /* T.L */))\r\n                i++;\r\n            if (rtl) {\r\n                for (let j = i; j > start;) {\r\n                    let end = j, l = types[--j] != 2 /* T.R */;\r\n                    while (j > start && l == (types[j - 1] != 2 /* T.R */))\r\n                        j--;\r\n                    order.push(new BidiSpan(j, end, l ? 2 : 1));\r\n                }\r\n            }\r\n            else {\r\n                order.push(new BidiSpan(start, i, 0));\r\n            }\r\n        }\r\n    }\r\n    else {\r\n        for (let i = 0; i < len;) {\r\n            let start = i, rtl = types[i++] == 2 /* T.R */;\r\n            while (i < len && rtl == (types[i] == 2 /* T.R */))\r\n                i++;\r\n            order.push(new BidiSpan(start, i, rtl ? 1 : 2));\r\n        }\r\n    }\r\n    return order;\r\n}\r\nfunction trivialOrder(length) {\r\n    return [new BidiSpan(0, length, 0)];\r\n}\r\nlet movedOver = \"\";\r\nfunction moveVisually(line, order, dir, start, forward) {\r\n    var _a;\r\n    let startIndex = start.head - line.from, spanI = -1;\r\n    if (startIndex == 0) {\r\n        if (!forward || !line.length)\r\n            return null;\r\n        if (order[0].level != dir) {\r\n            startIndex = order[0].side(false, dir);\r\n            spanI = 0;\r\n        }\r\n    }\r\n    else if (startIndex == line.length) {\r\n        if (forward)\r\n            return null;\r\n        let last = order[order.length - 1];\r\n        if (last.level != dir) {\r\n            startIndex = last.side(true, dir);\r\n            spanI = order.length - 1;\r\n        }\r\n    }\r\n    if (spanI < 0)\r\n        spanI = BidiSpan.find(order, startIndex, (_a = start.bidiLevel) !== null && _a !== void 0 ? _a : -1, start.assoc);\r\n    let span = order[spanI];\r\n    // End of span. (But not end of line--that was checked for above.)\r\n    if (startIndex == span.side(forward, dir)) {\r\n        span = order[spanI += forward ? 1 : -1];\r\n        startIndex = span.side(!forward, dir);\r\n    }\r\n    let indexForward = forward == (span.dir == dir);\r\n    let nextIndex = (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.findClusterBreak)(line.text, startIndex, indexForward);\r\n    movedOver = line.text.slice(Math.min(startIndex, nextIndex), Math.max(startIndex, nextIndex));\r\n    if (nextIndex != span.side(forward, dir))\r\n        return _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.cursor(nextIndex + line.from, indexForward ? -1 : 1, span.level);\r\n    let nextSpan = spanI == (forward ? order.length - 1 : 0) ? null : order[spanI + (forward ? 1 : -1)];\r\n    if (!nextSpan && span.level != dir)\r\n        return _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.cursor(forward ? line.to : line.from, forward ? -1 : 1, dir);\r\n    if (nextSpan && nextSpan.level < span.level)\r\n        return _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.cursor(nextSpan.side(!forward, dir) + line.from, forward ? 1 : -1, nextSpan.level);\r\n    return _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.cursor(nextIndex + line.from, forward ? -1 : 1, span.level);\r\n}\r\n\r\nconst LineBreakPlaceholder = \"\\uffff\";\r\nclass DOMReader {\r\n    constructor(points, state) {\r\n        this.points = points;\r\n        this.text = \"\";\r\n        this.lineSeparator = state.facet(_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorState.lineSeparator);\r\n    }\r\n    append(text) {\r\n        this.text += text;\r\n    }\r\n    lineBreak() {\r\n        this.text += LineBreakPlaceholder;\r\n    }\r\n    readRange(start, end) {\r\n        if (!start)\r\n            return this;\r\n        let parent = start.parentNode;\r\n        for (let cur = start;;) {\r\n            this.findPointBefore(parent, cur);\r\n            this.readNode(cur);\r\n            let next = cur.nextSibling;\r\n            if (next == end)\r\n                break;\r\n            let view = ContentView.get(cur), nextView = ContentView.get(next);\r\n            if (view && nextView ? view.breakAfter :\r\n                (view ? view.breakAfter : isBlockElement(cur)) ||\r\n                    (isBlockElement(next) && (cur.nodeName != \"BR\" || cur.cmIgnore)))\r\n                this.lineBreak();\r\n            cur = next;\r\n        }\r\n        this.findPointBefore(parent, end);\r\n        return this;\r\n    }\r\n    readTextNode(node) {\r\n        let text = node.nodeValue;\r\n        for (let point of this.points)\r\n            if (point.node == node)\r\n                point.pos = this.text.length + Math.min(point.offset, text.length);\r\n        for (let off = 0, re = this.lineSeparator ? null : /\\r\\n?|\\n/g;;) {\r\n            let nextBreak = -1, breakSize = 1, m;\r\n            if (this.lineSeparator) {\r\n                nextBreak = text.indexOf(this.lineSeparator, off);\r\n                breakSize = this.lineSeparator.length;\r\n            }\r\n            else if (m = re.exec(text)) {\r\n                nextBreak = m.index;\r\n                breakSize = m[0].length;\r\n            }\r\n            this.append(text.slice(off, nextBreak < 0 ? text.length : nextBreak));\r\n            if (nextBreak < 0)\r\n                break;\r\n            this.lineBreak();\r\n            if (breakSize > 1)\r\n                for (let point of this.points)\r\n                    if (point.node == node && point.pos > this.text.length)\r\n                        point.pos -= breakSize - 1;\r\n            off = nextBreak + breakSize;\r\n        }\r\n    }\r\n    readNode(node) {\r\n        if (node.cmIgnore)\r\n            return;\r\n        let view = ContentView.get(node);\r\n        let fromView = view && view.overrideDOMText;\r\n        if (fromView != null) {\r\n            this.findPointInside(node, fromView.length);\r\n            for (let i = fromView.iter(); !i.next().done;) {\r\n                if (i.lineBreak)\r\n                    this.lineBreak();\r\n                else\r\n                    this.append(i.value);\r\n            }\r\n        }\r\n        else if (node.nodeType == 3) {\r\n            this.readTextNode(node);\r\n        }\r\n        else if (node.nodeName == \"BR\") {\r\n            if (node.nextSibling)\r\n                this.lineBreak();\r\n        }\r\n        else if (node.nodeType == 1) {\r\n            this.readRange(node.firstChild, null);\r\n        }\r\n    }\r\n    findPointBefore(node, next) {\r\n        for (let point of this.points)\r\n            if (point.node == node && node.childNodes[point.offset] == next)\r\n                point.pos = this.text.length;\r\n    }\r\n    findPointInside(node, maxLen) {\r\n        for (let point of this.points)\r\n            if (node.nodeType == 3 ? point.node == node : node.contains(point.node))\r\n                point.pos = this.text.length + Math.min(maxLen, point.offset);\r\n    }\r\n}\r\nfunction isBlockElement(node) {\r\n    return node.nodeType == 1 && /^(DIV|P|LI|UL|OL|BLOCKQUOTE|DD|DT|H\\d|SECTION|PRE)$/.test(node.nodeName);\r\n}\r\nclass DOMPoint {\r\n    constructor(node, offset) {\r\n        this.node = node;\r\n        this.offset = offset;\r\n        this.pos = -1;\r\n    }\r\n}\r\n\r\nclass DocView extends ContentView {\r\n    constructor(view) {\r\n        super();\r\n        this.view = view;\r\n        this.compositionDeco = Decoration.none;\r\n        this.decorations = [];\r\n        this.dynamicDecorationMap = [];\r\n        // Track a minimum width for the editor. When measuring sizes in\r\n        // measureVisibleLineHeights, this is updated to point at the width\r\n        // of a given element and its extent in the document. When a change\r\n        // happens in that range, these are reset. That way, once we've seen\r\n        // a line/element of a given length, we keep the editor wide enough\r\n        // to fit at least that element, until it is changed, at which point\r\n        // we forget it again.\r\n        this.minWidth = 0;\r\n        this.minWidthFrom = 0;\r\n        this.minWidthTo = 0;\r\n        // Track whether the DOM selection was set in a lossy way, so that\r\n        // we don't mess it up when reading it back it\r\n        this.impreciseAnchor = null;\r\n        this.impreciseHead = null;\r\n        this.forceSelection = false;\r\n        // Used by the resize observer to ignore resizes that we caused\r\n        // ourselves\r\n        this.lastUpdate = Date.now();\r\n        this.setDOM(view.contentDOM);\r\n        this.children = [new LineView];\r\n        this.children[0].setParent(this);\r\n        this.updateDeco();\r\n        this.updateInner([new ChangedRange(0, 0, 0, view.state.doc.length)], 0);\r\n    }\r\n    get editorView() { return this.view; }\r\n    get length() { return this.view.state.doc.length; }\r\n    // Update the document view to a given state. scrollIntoView can be\r\n    // used as a hint to compute a new viewport that includes that\r\n    // position, if we know the editor is going to scroll that position\r\n    // into view.\r\n    update(update) {\r\n        let changedRanges = update.changedRanges;\r\n        if (this.minWidth > 0 && changedRanges.length) {\r\n            if (!changedRanges.every(({ fromA, toA }) => toA < this.minWidthFrom || fromA > this.minWidthTo)) {\r\n                this.minWidth = this.minWidthFrom = this.minWidthTo = 0;\r\n            }\r\n            else {\r\n                this.minWidthFrom = update.changes.mapPos(this.minWidthFrom, 1);\r\n                this.minWidthTo = update.changes.mapPos(this.minWidthTo, 1);\r\n            }\r\n        }\r\n        if (this.view.inputState.composing < 0)\r\n            this.compositionDeco = Decoration.none;\r\n        else if (update.transactions.length || this.dirty)\r\n            this.compositionDeco = computeCompositionDeco(this.view, update.changes);\r\n        // When the DOM nodes around the selection are moved to another\r\n        // parent, Chrome sometimes reports a different selection through\r\n        // getSelection than the one that it actually shows to the user.\r\n        // This forces a selection update when lines are joined to work\r\n        // around that. Issue #54\r\n        if ((browser.ie || browser.chrome) && !this.compositionDeco.size && update &&\r\n            update.state.doc.lines != update.startState.doc.lines)\r\n            this.forceSelection = true;\r\n        let prevDeco = this.decorations, deco = this.updateDeco();\r\n        let decoDiff = findChangedDeco(prevDeco, deco, update.changes);\r\n        changedRanges = ChangedRange.extendWithRanges(changedRanges, decoDiff);\r\n        if (this.dirty == 0 /* Dirty.Not */ && changedRanges.length == 0) {\r\n            return false;\r\n        }\r\n        else {\r\n            this.updateInner(changedRanges, update.startState.doc.length);\r\n            if (update.transactions.length)\r\n                this.lastUpdate = Date.now();\r\n            return true;\r\n        }\r\n    }\r\n    // Used by update and the constructor do perform the actual DOM\r\n    // update\r\n    updateInner(changes, oldLength) {\r\n        this.view.viewState.mustMeasureContent = true;\r\n        this.updateChildren(changes, oldLength);\r\n        let { observer } = this.view;\r\n        observer.ignore(() => {\r\n            // Lock the height during redrawing, since Chrome sometimes\r\n            // messes with the scroll position during DOM mutation (though\r\n            // no relayout is triggered and I cannot imagine how it can\r\n            // recompute the scroll position without a layout)\r\n            this.dom.style.height = this.view.viewState.contentHeight + \"px\";\r\n            this.dom.style.flexBasis = this.minWidth ? this.minWidth + \"px\" : \"\";\r\n            // Chrome will sometimes, when DOM mutations occur directly\r\n            // around the selection, get confused and report a different\r\n            // selection from the one it displays (issue #218). This tries\r\n            // to detect that situation.\r\n            let track = browser.chrome || browser.ios ? { node: observer.selectionRange.focusNode, written: false } : undefined;\r\n            this.sync(track);\r\n            this.dirty = 0 /* Dirty.Not */;\r\n            if (track && (track.written || observer.selectionRange.focusNode != track.node))\r\n                this.forceSelection = true;\r\n            this.dom.style.height = \"\";\r\n        });\r\n        let gaps = [];\r\n        if (this.view.viewport.from || this.view.viewport.to < this.view.state.doc.length)\r\n            for (let child of this.children)\r\n                if (child instanceof BlockWidgetView && child.widget instanceof BlockGapWidget)\r\n                    gaps.push(child.dom);\r\n        observer.updateGaps(gaps);\r\n    }\r\n    updateChildren(changes, oldLength) {\r\n        let cursor = this.childCursor(oldLength);\r\n        for (let i = changes.length - 1;; i--) {\r\n            let next = i >= 0 ? changes[i] : null;\r\n            if (!next)\r\n                break;\r\n            let { fromA, toA, fromB, toB } = next;\r\n            let { content, breakAtStart, openStart, openEnd } = ContentBuilder.build(this.view.state.doc, fromB, toB, this.decorations, this.dynamicDecorationMap);\r\n            let { i: toI, off: toOff } = cursor.findPos(toA, 1);\r\n            let { i: fromI, off: fromOff } = cursor.findPos(fromA, -1);\r\n            replaceRange(this, fromI, fromOff, toI, toOff, content, breakAtStart, openStart, openEnd);\r\n        }\r\n    }\r\n    // Sync the DOM selection to this.state.selection\r\n    updateSelection(mustRead = false, fromPointer = false) {\r\n        if (mustRead || !this.view.observer.selectionRange.focusNode)\r\n            this.view.observer.readSelectionRange();\r\n        if (!(fromPointer || this.mayControlSelection()))\r\n            return;\r\n        let force = this.forceSelection;\r\n        this.forceSelection = false;\r\n        let main = this.view.state.selection.main;\r\n        // FIXME need to handle the case where the selection falls inside a block range\r\n        let anchor = this.domAtPos(main.anchor);\r\n        let head = main.empty ? anchor : this.domAtPos(main.head);\r\n        // Always reset on Firefox when next to an uneditable node to\r\n        // avoid invisible cursor bugs (#111)\r\n        if (browser.gecko && main.empty && betweenUneditable(anchor)) {\r\n            let dummy = document.createTextNode(\"\");\r\n            this.view.observer.ignore(() => anchor.node.insertBefore(dummy, anchor.node.childNodes[anchor.offset] || null));\r\n            anchor = head = new DOMPos(dummy, 0);\r\n            force = true;\r\n        }\r\n        let domSel = this.view.observer.selectionRange;\r\n        // If the selection is already here, or in an equivalent position, don't touch it\r\n        if (force || !domSel.focusNode ||\r\n            !isEquivalentPosition(anchor.node, anchor.offset, domSel.anchorNode, domSel.anchorOffset) ||\r\n            !isEquivalentPosition(head.node, head.offset, domSel.focusNode, domSel.focusOffset)) {\r\n            this.view.observer.ignore(() => {\r\n                // Chrome Android will hide the virtual keyboard when tapping\r\n                // inside an uneditable node, and not bring it back when we\r\n                // move the cursor to its proper position. This tries to\r\n                // restore the keyboard by cycling focus.\r\n                if (browser.android && browser.chrome && this.dom.contains(domSel.focusNode) &&\r\n                    inUneditable(domSel.focusNode, this.dom)) {\r\n                    this.dom.blur();\r\n                    this.dom.focus({ preventScroll: true });\r\n                }\r\n                let rawSel = getSelection(this.view.root);\r\n                if (!rawSel) ;\r\n                else if (main.empty) {\r\n                    // Work around https://bugzilla.mozilla.org/show_bug.cgi?id=1612076\r\n                    if (browser.gecko) {\r\n                        let nextTo = nextToUneditable(anchor.node, anchor.offset);\r\n                        if (nextTo && nextTo != (1 /* NextTo.Before */ | 2 /* NextTo.After */)) {\r\n                            let text = nearbyTextNode(anchor.node, anchor.offset, nextTo == 1 /* NextTo.Before */ ? 1 : -1);\r\n                            if (text)\r\n                                anchor = new DOMPos(text, nextTo == 1 /* NextTo.Before */ ? 0 : text.nodeValue.length);\r\n                        }\r\n                    }\r\n                    rawSel.collapse(anchor.node, anchor.offset);\r\n                    if (main.bidiLevel != null && domSel.cursorBidiLevel != null)\r\n                        domSel.cursorBidiLevel = main.bidiLevel;\r\n                }\r\n                else if (rawSel.extend) {\r\n                    // Selection.extend can be used to create an 'inverted' selection\r\n                    // (one where the focus is before the anchor), but not all\r\n                    // browsers support it yet.\r\n                    rawSel.collapse(anchor.node, anchor.offset);\r\n                    // Safari will ignore the call above when the editor is\r\n                    // hidden, and then raise an error on the call to extend\r\n                    // (#940).\r\n                    try {\r\n                        rawSel.extend(head.node, head.offset);\r\n                    }\r\n                    catch (_) { }\r\n                }\r\n                else {\r\n                    // Primitive (IE) way\r\n                    let range = document.createRange();\r\n                    if (main.anchor > main.head)\r\n                        [anchor, head] = [head, anchor];\r\n                    range.setEnd(head.node, head.offset);\r\n                    range.setStart(anchor.node, anchor.offset);\r\n                    rawSel.removeAllRanges();\r\n                    rawSel.addRange(range);\r\n                }\r\n            });\r\n            this.view.observer.setSelectionRange(anchor, head);\r\n        }\r\n        this.impreciseAnchor = anchor.precise ? null : new DOMPos(domSel.anchorNode, domSel.anchorOffset);\r\n        this.impreciseHead = head.precise ? null : new DOMPos(domSel.focusNode, domSel.focusOffset);\r\n    }\r\n    enforceCursorAssoc() {\r\n        if (this.compositionDeco.size)\r\n            return;\r\n        let { view } = this, cursor = view.state.selection.main;\r\n        let sel = getSelection(view.root);\r\n        let { anchorNode, anchorOffset } = view.observer.selectionRange;\r\n        if (!sel || !cursor.empty || !cursor.assoc || !sel.modify)\r\n            return;\r\n        let line = LineView.find(this, cursor.head);\r\n        if (!line)\r\n            return;\r\n        let lineStart = line.posAtStart;\r\n        if (cursor.head == lineStart || cursor.head == lineStart + line.length)\r\n            return;\r\n        let before = this.coordsAt(cursor.head, -1), after = this.coordsAt(cursor.head, 1);\r\n        if (!before || !after || before.bottom > after.top)\r\n            return;\r\n        let dom = this.domAtPos(cursor.head + cursor.assoc);\r\n        sel.collapse(dom.node, dom.offset);\r\n        sel.modify(\"move\", cursor.assoc < 0 ? \"forward\" : \"backward\", \"lineboundary\");\r\n        // This can go wrong in corner cases like single-character lines,\r\n        // so check and reset if necessary.\r\n        view.observer.readSelectionRange();\r\n        let newRange = view.observer.selectionRange;\r\n        if (view.docView.posFromDOM(newRange.anchorNode, newRange.anchorOffset) != cursor.from)\r\n            sel.collapse(anchorNode, anchorOffset);\r\n    }\r\n    mayControlSelection() {\r\n        let active = this.view.root.activeElement;\r\n        return active == this.dom ||\r\n            hasSelection(this.dom, this.view.observer.selectionRange) && !(active && this.dom.contains(active));\r\n    }\r\n    nearest(dom) {\r\n        for (let cur = dom; cur;) {\r\n            let domView = ContentView.get(cur);\r\n            if (domView && domView.rootView == this)\r\n                return domView;\r\n            cur = cur.parentNode;\r\n        }\r\n        return null;\r\n    }\r\n    posFromDOM(node, offset) {\r\n        let view = this.nearest(node);\r\n        if (!view)\r\n            throw new RangeError(\"Trying to find position for a DOM position outside of the document\");\r\n        return view.localPosFromDOM(node, offset) + view.posAtStart;\r\n    }\r\n    domAtPos(pos) {\r\n        let { i, off } = this.childCursor().findPos(pos, -1);\r\n        for (; i < this.children.length - 1;) {\r\n            let child = this.children[i];\r\n            if (off < child.length || child instanceof LineView)\r\n                break;\r\n            i++;\r\n            off = 0;\r\n        }\r\n        return this.children[i].domAtPos(off);\r\n    }\r\n    coordsAt(pos, side) {\r\n        for (let off = this.length, i = this.children.length - 1;; i--) {\r\n            let child = this.children[i], start = off - child.breakAfter - child.length;\r\n            if (pos > start ||\r\n                (pos == start && child.type != BlockType.WidgetBefore && child.type != BlockType.WidgetAfter &&\r\n                    (!i || side == 2 || this.children[i - 1].breakAfter ||\r\n                        (this.children[i - 1].type == BlockType.WidgetBefore && side > -2))))\r\n                return child.coordsAt(pos - start, side);\r\n            off = start;\r\n        }\r\n    }\r\n    measureVisibleLineHeights(viewport) {\r\n        let result = [], { from, to } = viewport;\r\n        let contentWidth = this.view.contentDOM.clientWidth;\r\n        let isWider = contentWidth > Math.max(this.view.scrollDOM.clientWidth, this.minWidth) + 1;\r\n        let widest = -1, ltr = this.view.textDirection == Direction.LTR;\r\n        for (let pos = 0, i = 0; i < this.children.length; i++) {\r\n            let child = this.children[i], end = pos + child.length;\r\n            if (end > to)\r\n                break;\r\n            if (pos >= from) {\r\n                let childRect = child.dom.getBoundingClientRect();\r\n                result.push(childRect.height);\r\n                if (isWider) {\r\n                    let last = child.dom.lastChild;\r\n                    let rects = last ? clientRectsFor(last) : [];\r\n                    if (rects.length) {\r\n                        let rect = rects[rects.length - 1];\r\n                        let width = ltr ? rect.right - childRect.left : childRect.right - rect.left;\r\n                        if (width > widest) {\r\n                            widest = width;\r\n                            this.minWidth = contentWidth;\r\n                            this.minWidthFrom = pos;\r\n                            this.minWidthTo = end;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            pos = end + child.breakAfter;\r\n        }\r\n        return result;\r\n    }\r\n    textDirectionAt(pos) {\r\n        let { i } = this.childPos(pos, 1);\r\n        return getComputedStyle(this.children[i].dom).direction == \"rtl\" ? Direction.RTL : Direction.LTR;\r\n    }\r\n    measureTextSize() {\r\n        for (let child of this.children) {\r\n            if (child instanceof LineView) {\r\n                let measure = child.measureTextSize();\r\n                if (measure)\r\n                    return measure;\r\n            }\r\n        }\r\n        // If no workable line exists, force a layout of a measurable element\r\n        let dummy = document.createElement(\"div\"), lineHeight, charWidth;\r\n        dummy.className = \"cm-line\";\r\n        dummy.style.width = \"99999px\";\r\n        dummy.textContent = \"abc def ghi jkl mno pqr stu\";\r\n        this.view.observer.ignore(() => {\r\n            this.dom.appendChild(dummy);\r\n            let rect = clientRectsFor(dummy.firstChild)[0];\r\n            lineHeight = dummy.getBoundingClientRect().height;\r\n            charWidth = rect ? rect.width / 27 : 7;\r\n            dummy.remove();\r\n        });\r\n        return { lineHeight, charWidth };\r\n    }\r\n    childCursor(pos = this.length) {\r\n        // Move back to start of last element when possible, so that\r\n        // `ChildCursor.findPos` doesn't have to deal with the edge case\r\n        // of being after the last element.\r\n        let i = this.children.length;\r\n        if (i)\r\n            pos -= this.children[--i].length;\r\n        return new ChildCursor(this.children, pos, i);\r\n    }\r\n    computeBlockGapDeco() {\r\n        let deco = [], vs = this.view.viewState;\r\n        for (let pos = 0, i = 0;; i++) {\r\n            let next = i == vs.viewports.length ? null : vs.viewports[i];\r\n            let end = next ? next.from - 1 : this.length;\r\n            if (end > pos) {\r\n                let height = vs.lineBlockAt(end).bottom - vs.lineBlockAt(pos).top;\r\n                deco.push(Decoration.replace({\r\n                    widget: new BlockGapWidget(height),\r\n                    block: true,\r\n                    inclusive: true,\r\n                    isBlockGap: true,\r\n                }).range(pos, end));\r\n            }\r\n            if (!next)\r\n                break;\r\n            pos = next.to + 1;\r\n        }\r\n        return Decoration.set(deco);\r\n    }\r\n    updateDeco() {\r\n        let allDeco = this.view.state.facet(decorations).map((d, i) => {\r\n            let dynamic = this.dynamicDecorationMap[i] = typeof d == \"function\";\r\n            return dynamic ? d(this.view) : d;\r\n        });\r\n        for (let i = allDeco.length; i < allDeco.length + 3; i++)\r\n            this.dynamicDecorationMap[i] = false;\r\n        return this.decorations = [\r\n            ...allDeco,\r\n            this.compositionDeco,\r\n            this.computeBlockGapDeco(),\r\n            this.view.viewState.lineGapDeco\r\n        ];\r\n    }\r\n    scrollIntoView(target) {\r\n        let { range } = target;\r\n        let rect = this.coordsAt(range.head, range.empty ? range.assoc : range.head > range.anchor ? -1 : 1), other;\r\n        if (!rect)\r\n            return;\r\n        if (!range.empty && (other = this.coordsAt(range.anchor, range.anchor > range.head ? -1 : 1)))\r\n            rect = { left: Math.min(rect.left, other.left), top: Math.min(rect.top, other.top),\r\n                right: Math.max(rect.right, other.right), bottom: Math.max(rect.bottom, other.bottom) };\r\n        let mLeft = 0, mRight = 0, mTop = 0, mBottom = 0;\r\n        for (let margins of this.view.state.facet(scrollMargins).map(f => f(this.view)))\r\n            if (margins) {\r\n                let { left, right, top, bottom } = margins;\r\n                if (left != null)\r\n                    mLeft = Math.max(mLeft, left);\r\n                if (right != null)\r\n                    mRight = Math.max(mRight, right);\r\n                if (top != null)\r\n                    mTop = Math.max(mTop, top);\r\n                if (bottom != null)\r\n                    mBottom = Math.max(mBottom, bottom);\r\n            }\r\n        let targetRect = {\r\n            left: rect.left - mLeft, top: rect.top - mTop,\r\n            right: rect.right + mRight, bottom: rect.bottom + mBottom\r\n        };\r\n        scrollRectIntoView(this.view.scrollDOM, targetRect, range.head < range.anchor ? -1 : 1, target.x, target.y, target.xMargin, target.yMargin, this.view.textDirection == Direction.LTR);\r\n    }\r\n}\r\nfunction betweenUneditable(pos) {\r\n    return pos.node.nodeType == 1 && pos.node.firstChild &&\r\n        (pos.offset == 0 || pos.node.childNodes[pos.offset - 1].contentEditable == \"false\") &&\r\n        (pos.offset == pos.node.childNodes.length || pos.node.childNodes[pos.offset].contentEditable == \"false\");\r\n}\r\nclass BlockGapWidget extends WidgetType {\r\n    constructor(height) {\r\n        super();\r\n        this.height = height;\r\n    }\r\n    toDOM() {\r\n        let elt = document.createElement(\"div\");\r\n        this.updateDOM(elt);\r\n        return elt;\r\n    }\r\n    eq(other) { return other.height == this.height; }\r\n    updateDOM(elt) {\r\n        elt.style.height = this.height + \"px\";\r\n        return true;\r\n    }\r\n    get estimatedHeight() { return this.height; }\r\n}\r\nfunction compositionSurroundingNode(view) {\r\n    let sel = view.observer.selectionRange;\r\n    let textNode = sel.focusNode && nearbyTextNode(sel.focusNode, sel.focusOffset, 0);\r\n    if (!textNode)\r\n        return null;\r\n    let cView = view.docView.nearest(textNode);\r\n    if (!cView)\r\n        return null;\r\n    if (cView instanceof LineView) {\r\n        let topNode = textNode;\r\n        while (topNode.parentNode != cView.dom)\r\n            topNode = topNode.parentNode;\r\n        let prev = topNode.previousSibling;\r\n        while (prev && !ContentView.get(prev))\r\n            prev = prev.previousSibling;\r\n        let pos = prev ? ContentView.get(prev).posAtEnd : cView.posAtStart;\r\n        return { from: pos, to: pos, node: topNode, text: textNode };\r\n    }\r\n    else {\r\n        for (;;) {\r\n            let { parent } = cView;\r\n            if (!parent)\r\n                return null;\r\n            if (parent instanceof LineView)\r\n                break;\r\n            cView = parent;\r\n        }\r\n        let from = cView.posAtStart;\r\n        return { from, to: from + cView.length, node: cView.dom, text: textNode };\r\n    }\r\n}\r\nfunction computeCompositionDeco(view, changes) {\r\n    let surrounding = compositionSurroundingNode(view);\r\n    if (!surrounding)\r\n        return Decoration.none;\r\n    let { from, to, node, text: textNode } = surrounding;\r\n    let newFrom = changes.mapPos(from, 1), newTo = Math.max(newFrom, changes.mapPos(to, -1));\r\n    let { state } = view, text = node.nodeType == 3 ? node.nodeValue :\r\n        new DOMReader([], state).readRange(node.firstChild, null).text;\r\n    if (newTo - newFrom < text.length) {\r\n        if (state.doc.sliceString(newFrom, Math.min(state.doc.length, newFrom + text.length), LineBreakPlaceholder) == text)\r\n            newTo = newFrom + text.length;\r\n        else if (state.doc.sliceString(Math.max(0, newTo - text.length), newTo, LineBreakPlaceholder) == text)\r\n            newFrom = newTo - text.length;\r\n        else\r\n            return Decoration.none;\r\n    }\r\n    else if (state.doc.sliceString(newFrom, newTo, LineBreakPlaceholder) != text) {\r\n        return Decoration.none;\r\n    }\r\n    let topView = ContentView.get(node);\r\n    if (topView instanceof CompositionView)\r\n        topView = topView.widget.topView;\r\n    else if (topView)\r\n        topView.parent = null;\r\n    return Decoration.set(Decoration.replace({ widget: new CompositionWidget(node, textNode, topView), inclusive: true })\r\n        .range(newFrom, newTo));\r\n}\r\nclass CompositionWidget extends WidgetType {\r\n    constructor(top, text, topView) {\r\n        super();\r\n        this.top = top;\r\n        this.text = text;\r\n        this.topView = topView;\r\n    }\r\n    eq(other) { return this.top == other.top && this.text == other.text; }\r\n    toDOM() { return this.top; }\r\n    ignoreEvent() { return false; }\r\n    get customView() { return CompositionView; }\r\n}\r\nfunction nearbyTextNode(node, offset, side) {\r\n    for (;;) {\r\n        if (node.nodeType == 3)\r\n            return node;\r\n        if (node.nodeType == 1 && offset > 0 && side <= 0) {\r\n            node = node.childNodes[offset - 1];\r\n            offset = maxOffset(node);\r\n        }\r\n        else if (node.nodeType == 1 && offset < node.childNodes.length && side >= 0) {\r\n            node = node.childNodes[offset];\r\n            offset = 0;\r\n        }\r\n        else {\r\n            return null;\r\n        }\r\n    }\r\n}\r\nfunction nextToUneditable(node, offset) {\r\n    if (node.nodeType != 1)\r\n        return 0;\r\n    return (offset && node.childNodes[offset - 1].contentEditable == \"false\" ? 1 /* NextTo.Before */ : 0) |\r\n        (offset < node.childNodes.length && node.childNodes[offset].contentEditable == \"false\" ? 2 /* NextTo.After */ : 0);\r\n}\r\nclass DecorationComparator$1 {\r\n    constructor() {\r\n        this.changes = [];\r\n    }\r\n    compareRange(from, to) { addRange(from, to, this.changes); }\r\n    comparePoint(from, to) { addRange(from, to, this.changes); }\r\n}\r\nfunction findChangedDeco(a, b, diff) {\r\n    let comp = new DecorationComparator$1;\r\n    _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.RangeSet.compare(a, b, diff, comp);\r\n    return comp.changes;\r\n}\r\nfunction inUneditable(node, inside) {\r\n    for (let cur = node; cur && cur != inside; cur = cur.assignedSlot || cur.parentNode) {\r\n        if (cur.nodeType == 1 && cur.contentEditable == 'false') {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}\r\n\r\nfunction groupAt(state, pos, bias = 1) {\r\n    let categorize = state.charCategorizer(pos);\r\n    let line = state.doc.lineAt(pos), linePos = pos - line.from;\r\n    if (line.length == 0)\r\n        return _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.cursor(pos);\r\n    if (linePos == 0)\r\n        bias = 1;\r\n    else if (linePos == line.length)\r\n        bias = -1;\r\n    let from = linePos, to = linePos;\r\n    if (bias < 0)\r\n        from = (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.findClusterBreak)(line.text, linePos, false);\r\n    else\r\n        to = (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.findClusterBreak)(line.text, linePos);\r\n    let cat = categorize(line.text.slice(from, to));\r\n    while (from > 0) {\r\n        let prev = (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.findClusterBreak)(line.text, from, false);\r\n        if (categorize(line.text.slice(prev, from)) != cat)\r\n            break;\r\n        from = prev;\r\n    }\r\n    while (to < line.length) {\r\n        let next = (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.findClusterBreak)(line.text, to);\r\n        if (categorize(line.text.slice(to, next)) != cat)\r\n            break;\r\n        to = next;\r\n    }\r\n    return _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.range(from + line.from, to + line.from);\r\n}\r\n// Search the DOM for the {node, offset} position closest to the given\r\n// coordinates. Very inefficient and crude, but can usually be avoided\r\n// by calling caret(Position|Range)FromPoint instead.\r\nfunction getdx(x, rect) {\r\n    return rect.left > x ? rect.left - x : Math.max(0, x - rect.right);\r\n}\r\nfunction getdy(y, rect) {\r\n    return rect.top > y ? rect.top - y : Math.max(0, y - rect.bottom);\r\n}\r\nfunction yOverlap(a, b) {\r\n    return a.top < b.bottom - 1 && a.bottom > b.top + 1;\r\n}\r\nfunction upTop(rect, top) {\r\n    return top < rect.top ? { top, left: rect.left, right: rect.right, bottom: rect.bottom } : rect;\r\n}\r\nfunction upBot(rect, bottom) {\r\n    return bottom > rect.bottom ? { top: rect.top, left: rect.left, right: rect.right, bottom } : rect;\r\n}\r\nfunction domPosAtCoords(parent, x, y) {\r\n    let closest, closestRect, closestX, closestY, closestOverlap = false;\r\n    let above, below, aboveRect, belowRect;\r\n    for (let child = parent.firstChild; child; child = child.nextSibling) {\r\n        let rects = clientRectsFor(child);\r\n        for (let i = 0; i < rects.length; i++) {\r\n            let rect = rects[i];\r\n            if (closestRect && yOverlap(closestRect, rect))\r\n                rect = upTop(upBot(rect, closestRect.bottom), closestRect.top);\r\n            let dx = getdx(x, rect), dy = getdy(y, rect);\r\n            if (dx == 0 && dy == 0)\r\n                return child.nodeType == 3 ? domPosInText(child, x, y) : domPosAtCoords(child, x, y);\r\n            if (!closest || closestY > dy || closestY == dy && closestX > dx) {\r\n                closest = child;\r\n                closestRect = rect;\r\n                closestX = dx;\r\n                closestY = dy;\r\n                closestOverlap = !dx || (dx > 0 ? i < rects.length - 1 : i > 0);\r\n            }\r\n            if (dx == 0) {\r\n                if (y > rect.bottom && (!aboveRect || aboveRect.bottom < rect.bottom)) {\r\n                    above = child;\r\n                    aboveRect = rect;\r\n                }\r\n                else if (y < rect.top && (!belowRect || belowRect.top > rect.top)) {\r\n                    below = child;\r\n                    belowRect = rect;\r\n                }\r\n            }\r\n            else if (aboveRect && yOverlap(aboveRect, rect)) {\r\n                aboveRect = upBot(aboveRect, rect.bottom);\r\n            }\r\n            else if (belowRect && yOverlap(belowRect, rect)) {\r\n                belowRect = upTop(belowRect, rect.top);\r\n            }\r\n        }\r\n    }\r\n    if (aboveRect && aboveRect.bottom >= y) {\r\n        closest = above;\r\n        closestRect = aboveRect;\r\n    }\r\n    else if (belowRect && belowRect.top <= y) {\r\n        closest = below;\r\n        closestRect = belowRect;\r\n    }\r\n    if (!closest)\r\n        return { node: parent, offset: 0 };\r\n    let clipX = Math.max(closestRect.left, Math.min(closestRect.right, x));\r\n    if (closest.nodeType == 3)\r\n        return domPosInText(closest, clipX, y);\r\n    if (closestOverlap && closest.contentEditable != \"false\")\r\n        return domPosAtCoords(closest, clipX, y);\r\n    let offset = Array.prototype.indexOf.call(parent.childNodes, closest) +\r\n        (x >= (closestRect.left + closestRect.right) / 2 ? 1 : 0);\r\n    return { node: parent, offset };\r\n}\r\nfunction domPosInText(node, x, y) {\r\n    let len = node.nodeValue.length;\r\n    let closestOffset = -1, closestDY = 1e9, generalSide = 0;\r\n    for (let i = 0; i < len; i++) {\r\n        let rects = textRange(node, i, i + 1).getClientRects();\r\n        for (let j = 0; j < rects.length; j++) {\r\n            let rect = rects[j];\r\n            if (rect.top == rect.bottom)\r\n                continue;\r\n            if (!generalSide)\r\n                generalSide = x - rect.left;\r\n            let dy = (rect.top > y ? rect.top - y : y - rect.bottom) - 1;\r\n            if (rect.left - 1 <= x && rect.right + 1 >= x && dy < closestDY) {\r\n                let right = x >= (rect.left + rect.right) / 2, after = right;\r\n                if (browser.chrome || browser.gecko) {\r\n                    // Check for RTL on browsers that support getting client\r\n                    // rects for empty ranges.\r\n                    let rectBefore = textRange(node, i).getBoundingClientRect();\r\n                    if (rectBefore.left == rect.right)\r\n                        after = !right;\r\n                }\r\n                if (dy <= 0)\r\n                    return { node, offset: i + (after ? 1 : 0) };\r\n                closestOffset = i + (after ? 1 : 0);\r\n                closestDY = dy;\r\n            }\r\n        }\r\n    }\r\n    return { node, offset: closestOffset > -1 ? closestOffset : generalSide > 0 ? node.nodeValue.length : 0 };\r\n}\r\nfunction posAtCoords(view, { x, y }, precise, bias = -1) {\r\n    var _a;\r\n    let content = view.contentDOM.getBoundingClientRect(), docTop = content.top + view.viewState.paddingTop;\r\n    let block, { docHeight } = view.viewState;\r\n    let yOffset = y - docTop;\r\n    if (yOffset < 0)\r\n        return 0;\r\n    if (yOffset > docHeight)\r\n        return view.state.doc.length;\r\n    // Scan for a text block near the queried y position\r\n    for (let halfLine = view.defaultLineHeight / 2, bounced = false;;) {\r\n        block = view.elementAtHeight(yOffset);\r\n        if (block.type == BlockType.Text)\r\n            break;\r\n        for (;;) {\r\n            // Move the y position out of this block\r\n            yOffset = bias > 0 ? block.bottom + halfLine : block.top - halfLine;\r\n            if (yOffset >= 0 && yOffset <= docHeight)\r\n                break;\r\n            // If the document consists entirely of replaced widgets, we\r\n            // won't find a text block, so return 0\r\n            if (bounced)\r\n                return precise ? null : 0;\r\n            bounced = true;\r\n            bias = -bias;\r\n        }\r\n    }\r\n    y = docTop + yOffset;\r\n    let lineStart = block.from;\r\n    // If this is outside of the rendered viewport, we can't determine a position\r\n    if (lineStart < view.viewport.from)\r\n        return view.viewport.from == 0 ? 0 : precise ? null : posAtCoordsImprecise(view, content, block, x, y);\r\n    if (lineStart > view.viewport.to)\r\n        return view.viewport.to == view.state.doc.length ? view.state.doc.length :\r\n            precise ? null : posAtCoordsImprecise(view, content, block, x, y);\r\n    // Prefer ShadowRootOrDocument.elementFromPoint if present, fall back to document if not\r\n    let doc = view.dom.ownerDocument;\r\n    let root = view.root.elementFromPoint ? view.root : doc;\r\n    let element = root.elementFromPoint(x, y);\r\n    if (element && !view.contentDOM.contains(element))\r\n        element = null;\r\n    // If the element is unexpected, clip x at the sides of the content area and try again\r\n    if (!element) {\r\n        x = Math.max(content.left + 1, Math.min(content.right - 1, x));\r\n        element = root.elementFromPoint(x, y);\r\n        if (element && !view.contentDOM.contains(element))\r\n            element = null;\r\n    }\r\n    // There's visible editor content under the point, so we can try\r\n    // using caret(Position|Range)FromPoint as a shortcut\r\n    let node, offset = -1;\r\n    if (element && ((_a = view.docView.nearest(element)) === null || _a === void 0 ? void 0 : _a.isEditable) != false) {\r\n        if (doc.caretPositionFromPoint) {\r\n            let pos = doc.caretPositionFromPoint(x, y);\r\n            if (pos)\r\n                ({ offsetNode: node, offset } = pos);\r\n        }\r\n        else if (doc.caretRangeFromPoint) {\r\n            let range = doc.caretRangeFromPoint(x, y);\r\n            if (range) {\r\n                ({ startContainer: node, startOffset: offset } = range);\r\n                if (!view.contentDOM.contains(node) ||\r\n                    browser.safari && isSuspiciousSafariCaretResult(node, offset, x) ||\r\n                    browser.chrome && isSuspiciousChromeCaretResult(node, offset, x))\r\n                    node = undefined;\r\n            }\r\n        }\r\n    }\r\n    // No luck, do our own (potentially expensive) search\r\n    if (!node || !view.docView.dom.contains(node)) {\r\n        let line = LineView.find(view.docView, lineStart);\r\n        if (!line)\r\n            return yOffset > block.top + block.height / 2 ? block.to : block.from;\r\n        ({ node, offset } = domPosAtCoords(line.dom, x, y));\r\n    }\r\n    return view.docView.posFromDOM(node, offset);\r\n}\r\nfunction posAtCoordsImprecise(view, contentRect, block, x, y) {\r\n    let into = Math.round((x - contentRect.left) * view.defaultCharacterWidth);\r\n    if (view.lineWrapping && block.height > view.defaultLineHeight * 1.5) {\r\n        let line = Math.floor((y - block.top) / view.defaultLineHeight);\r\n        into += line * view.viewState.heightOracle.lineLength;\r\n    }\r\n    let content = view.state.sliceDoc(block.from, block.to);\r\n    return block.from + (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.findColumn)(content, into, view.state.tabSize);\r\n}\r\n// In case of a high line height, Safari's caretRangeFromPoint treats\r\n// the space between lines as belonging to the last character of the\r\n// line before. This is used to detect such a result so that it can be\r\n// ignored (issue #401).\r\nfunction isSuspiciousSafariCaretResult(node, offset, x) {\r\n    let len;\r\n    if (node.nodeType != 3 || offset != (len = node.nodeValue.length))\r\n        return false;\r\n    for (let next = node.nextSibling; next; next = next.nextSibling)\r\n        if (next.nodeType != 1 || next.nodeName != \"BR\")\r\n            return false;\r\n    return textRange(node, len - 1, len).getBoundingClientRect().left > x;\r\n}\r\n// Chrome will move positions between lines to the start of the next line\r\nfunction isSuspiciousChromeCaretResult(node, offset, x) {\r\n    if (offset != 0)\r\n        return false;\r\n    for (let cur = node;;) {\r\n        let parent = cur.parentNode;\r\n        if (!parent || parent.nodeType != 1 || parent.firstChild != cur)\r\n            return false;\r\n        if (parent.classList.contains(\"cm-line\"))\r\n            break;\r\n        cur = parent;\r\n    }\r\n    let rect = node.nodeType == 1 ? node.getBoundingClientRect()\r\n        : textRange(node, 0, Math.max(node.nodeValue.length, 1)).getBoundingClientRect();\r\n    return x - rect.left > 5;\r\n}\r\nfunction moveToLineBoundary(view, start, forward, includeWrap) {\r\n    let line = view.state.doc.lineAt(start.head);\r\n    let coords = !includeWrap || !view.lineWrapping ? null\r\n        : view.coordsAtPos(start.assoc < 0 && start.head > line.from ? start.head - 1 : start.head);\r\n    if (coords) {\r\n        let editorRect = view.dom.getBoundingClientRect();\r\n        let direction = view.textDirectionAt(line.from);\r\n        let pos = view.posAtCoords({ x: forward == (direction == Direction.LTR) ? editorRect.right - 1 : editorRect.left + 1,\r\n            y: (coords.top + coords.bottom) / 2 });\r\n        if (pos != null)\r\n            return _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.cursor(pos, forward ? -1 : 1);\r\n    }\r\n    let lineView = LineView.find(view.docView, start.head);\r\n    let end = lineView ? (forward ? lineView.posAtEnd : lineView.posAtStart) : (forward ? line.to : line.from);\r\n    return _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.cursor(end, forward ? -1 : 1);\r\n}\r\nfunction moveByChar(view, start, forward, by) {\r\n    let line = view.state.doc.lineAt(start.head), spans = view.bidiSpans(line);\r\n    let direction = view.textDirectionAt(line.from);\r\n    for (let cur = start, check = null;;) {\r\n        let next = moveVisually(line, spans, direction, cur, forward), char = movedOver;\r\n        if (!next) {\r\n            if (line.number == (forward ? view.state.doc.lines : 1))\r\n                return cur;\r\n            char = \"\\n\";\r\n            line = view.state.doc.line(line.number + (forward ? 1 : -1));\r\n            spans = view.bidiSpans(line);\r\n            next = _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.cursor(forward ? line.from : line.to);\r\n        }\r\n        if (!check) {\r\n            if (!by)\r\n                return next;\r\n            check = by(char);\r\n        }\r\n        else if (!check(char)) {\r\n            return cur;\r\n        }\r\n        cur = next;\r\n    }\r\n}\r\nfunction byGroup(view, pos, start) {\r\n    let categorize = view.state.charCategorizer(pos);\r\n    let cat = categorize(start);\r\n    return (next) => {\r\n        let nextCat = categorize(next);\r\n        if (cat == _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.CharCategory.Space)\r\n            cat = nextCat;\r\n        return cat == nextCat;\r\n    };\r\n}\r\nfunction moveVertically(view, start, forward, distance) {\r\n    let startPos = start.head, dir = forward ? 1 : -1;\r\n    if (startPos == (forward ? view.state.doc.length : 0))\r\n        return _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.cursor(startPos, start.assoc);\r\n    let goal = start.goalColumn, startY;\r\n    let rect = view.contentDOM.getBoundingClientRect();\r\n    let startCoords = view.coordsAtPos(startPos), docTop = view.documentTop;\r\n    if (startCoords) {\r\n        if (goal == null)\r\n            goal = startCoords.left - rect.left;\r\n        startY = dir < 0 ? startCoords.top : startCoords.bottom;\r\n    }\r\n    else {\r\n        let line = view.viewState.lineBlockAt(startPos);\r\n        if (goal == null)\r\n            goal = Math.min(rect.right - rect.left, view.defaultCharacterWidth * (startPos - line.from));\r\n        startY = (dir < 0 ? line.top : line.bottom) + docTop;\r\n    }\r\n    let resolvedGoal = rect.left + goal;\r\n    let dist = distance !== null && distance !== void 0 ? distance : (view.defaultLineHeight >> 1);\r\n    for (let extra = 0;; extra += 10) {\r\n        let curY = startY + (dist + extra) * dir;\r\n        let pos = posAtCoords(view, { x: resolvedGoal, y: curY }, false, dir);\r\n        if (curY < rect.top || curY > rect.bottom || (dir < 0 ? pos < startPos : pos > startPos))\r\n            return _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.cursor(pos, start.assoc, undefined, goal);\r\n    }\r\n}\r\nfunction skipAtoms(view, oldPos, pos) {\r\n    let atoms = view.state.facet(atomicRanges).map(f => f(view));\r\n    for (;;) {\r\n        let moved = false;\r\n        for (let set of atoms) {\r\n            set.between(pos.from - 1, pos.from + 1, (from, to, value) => {\r\n                if (pos.from > from && pos.from < to) {\r\n                    pos = oldPos.head > pos.from ? _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.cursor(from, 1) : _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.cursor(to, -1);\r\n                    moved = true;\r\n                }\r\n            });\r\n        }\r\n        if (!moved)\r\n            return pos;\r\n    }\r\n}\r\n\r\n// This will also be where dragging info and such goes\r\nclass InputState {\r\n    constructor(view) {\r\n        this.lastKeyCode = 0;\r\n        this.lastKeyTime = 0;\r\n        this.lastTouchTime = 0;\r\n        this.lastFocusTime = 0;\r\n        this.lastScrollTop = 0;\r\n        this.lastScrollLeft = 0;\r\n        this.chromeScrollHack = -1;\r\n        // On iOS, some keys need to have their default behavior happen\r\n        // (after which we retroactively handle them and reset the DOM) to\r\n        // avoid messing up the virtual keyboard state.\r\n        this.pendingIOSKey = undefined;\r\n        this.lastSelectionOrigin = null;\r\n        this.lastSelectionTime = 0;\r\n        this.lastEscPress = 0;\r\n        this.lastContextMenu = 0;\r\n        this.scrollHandlers = [];\r\n        this.registeredEvents = [];\r\n        this.customHandlers = [];\r\n        // -1 means not in a composition. Otherwise, this counts the number\r\n        // of changes made during the composition. The count is used to\r\n        // avoid treating the start state of the composition, before any\r\n        // changes have been made, as part of the composition.\r\n        this.composing = -1;\r\n        // Tracks whether the next change should be marked as starting the\r\n        // composition (null means no composition, true means next is the\r\n        // first, false means first has already been marked for this\r\n        // composition)\r\n        this.compositionFirstChange = null;\r\n        this.compositionEndedAt = 0;\r\n        this.mouseSelection = null;\r\n        let handleEvent = (handler, event) => {\r\n            if (this.ignoreDuringComposition(event))\r\n                return;\r\n            if (event.type == \"keydown\" && this.keydown(view, event))\r\n                return;\r\n            if (this.mustFlushObserver(event))\r\n                view.observer.forceFlush();\r\n            if (this.runCustomHandlers(event.type, view, event))\r\n                event.preventDefault();\r\n            else\r\n                handler(view, event);\r\n        };\r\n        for (let type in handlers) {\r\n            let handler = handlers[type];\r\n            view.contentDOM.addEventListener(type, event => {\r\n                if (eventBelongsToEditor(view, event))\r\n                    handleEvent(handler, event);\r\n            }, handlerOptions[type]);\r\n            this.registeredEvents.push(type);\r\n        }\r\n        view.scrollDOM.addEventListener(\"mousedown\", (event) => {\r\n            if (event.target == view.scrollDOM)\r\n                handleEvent(handlers.mousedown, event);\r\n        });\r\n        if (browser.chrome && browser.chrome_version == 102) { // FIXME remove at some point\r\n            // On Chrome 102, viewport updates somehow stop wheel-based\r\n            // scrolling. Turning off pointer events during the scroll seems\r\n            // to avoid the issue.\r\n            view.scrollDOM.addEventListener(\"wheel\", () => {\r\n                if (this.chromeScrollHack < 0)\r\n                    view.contentDOM.style.pointerEvents = \"none\";\r\n                else\r\n                    window.clearTimeout(this.chromeScrollHack);\r\n                this.chromeScrollHack = setTimeout(() => {\r\n                    this.chromeScrollHack = -1;\r\n                    view.contentDOM.style.pointerEvents = \"\";\r\n                }, 100);\r\n            }, { passive: true });\r\n        }\r\n        this.notifiedFocused = view.hasFocus;\r\n        // On Safari adding an input event handler somehow prevents an\r\n        // issue where the composition vanishes when you press enter.\r\n        if (browser.safari)\r\n            view.contentDOM.addEventListener(\"input\", () => null);\r\n    }\r\n    setSelectionOrigin(origin) {\r\n        this.lastSelectionOrigin = origin;\r\n        this.lastSelectionTime = Date.now();\r\n    }\r\n    ensureHandlers(view, plugins) {\r\n        var _a;\r\n        let handlers;\r\n        this.customHandlers = [];\r\n        for (let plugin of plugins)\r\n            if (handlers = (_a = plugin.update(view).spec) === null || _a === void 0 ? void 0 : _a.domEventHandlers) {\r\n                this.customHandlers.push({ plugin: plugin.value, handlers });\r\n                for (let type in handlers)\r\n                    if (this.registeredEvents.indexOf(type) < 0 && type != \"scroll\") {\r\n                        this.registeredEvents.push(type);\r\n                        view.contentDOM.addEventListener(type, (event) => {\r\n                            if (!eventBelongsToEditor(view, event))\r\n                                return;\r\n                            if (this.runCustomHandlers(type, view, event))\r\n                                event.preventDefault();\r\n                        });\r\n                    }\r\n            }\r\n    }\r\n    runCustomHandlers(type, view, event) {\r\n        for (let set of this.customHandlers) {\r\n            let handler = set.handlers[type];\r\n            if (handler) {\r\n                try {\r\n                    if (handler.call(set.plugin, event, view) || event.defaultPrevented)\r\n                        return true;\r\n                }\r\n                catch (e) {\r\n                    logException(view.state, e);\r\n                }\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n    runScrollHandlers(view, event) {\r\n        this.lastScrollTop = view.scrollDOM.scrollTop;\r\n        this.lastScrollLeft = view.scrollDOM.scrollLeft;\r\n        for (let set of this.customHandlers) {\r\n            let handler = set.handlers.scroll;\r\n            if (handler) {\r\n                try {\r\n                    handler.call(set.plugin, event, view);\r\n                }\r\n                catch (e) {\r\n                    logException(view.state, e);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    keydown(view, event) {\r\n        // Must always run, even if a custom handler handled the event\r\n        this.lastKeyCode = event.keyCode;\r\n        this.lastKeyTime = Date.now();\r\n        if (event.keyCode == 9 && Date.now() < this.lastEscPress + 2000)\r\n            return true;\r\n        // Chrome for Android usually doesn't fire proper key events, but\r\n        // occasionally does, usually surrounded by a bunch of complicated\r\n        // composition changes. When an enter or backspace key event is\r\n        // seen, hold off on handling DOM events for a bit, and then\r\n        // dispatch it.\r\n        if (browser.android && browser.chrome && !event.synthetic &&\r\n            (event.keyCode == 13 || event.keyCode == 8)) {\r\n            view.observer.delayAndroidKey(event.key, event.keyCode);\r\n            return true;\r\n        }\r\n        // Prevent the default behavior of Enter on iOS makes the\r\n        // virtual keyboard get stuck in the wrong (lowercase)\r\n        // state. So we let it go through, and then, in\r\n        // applyDOMChange, notify key handlers of it and reset to\r\n        // the state they produce.\r\n        let pending;\r\n        if (browser.ios && !event.synthetic && !event.altKey && !event.metaKey &&\r\n            ((pending = PendingKeys.find(key => key.keyCode == event.keyCode)) && !event.ctrlKey ||\r\n                EmacsyPendingKeys.indexOf(event.key) > -1 && event.ctrlKey && !event.shiftKey)) {\r\n            this.pendingIOSKey = pending || event;\r\n            setTimeout(() => this.flushIOSKey(view), 250);\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    flushIOSKey(view) {\r\n        let key = this.pendingIOSKey;\r\n        if (!key)\r\n            return false;\r\n        this.pendingIOSKey = undefined;\r\n        return dispatchKey(view.contentDOM, key.key, key.keyCode);\r\n    }\r\n    ignoreDuringComposition(event) {\r\n        if (!/^key/.test(event.type))\r\n            return false;\r\n        if (this.composing > 0)\r\n            return true;\r\n        // See https://www.stum.de/2016/06/24/handling-ime-events-in-javascript/.\r\n        // On some input method editors (IMEs), the Enter key is used to\r\n        // confirm character selection. On Safari, when Enter is pressed,\r\n        // compositionend and keydown events are sometimes emitted in the\r\n        // wrong order. The key event should still be ignored, even when\r\n        // it happens after the compositionend event.\r\n        if (browser.safari && !browser.ios && Date.now() - this.compositionEndedAt < 100) {\r\n            this.compositionEndedAt = 0;\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    mustFlushObserver(event) {\r\n        return event.type == \"keydown\" && event.keyCode != 229;\r\n    }\r\n    startMouseSelection(mouseSelection) {\r\n        if (this.mouseSelection)\r\n            this.mouseSelection.destroy();\r\n        this.mouseSelection = mouseSelection;\r\n    }\r\n    update(update) {\r\n        if (this.mouseSelection)\r\n            this.mouseSelection.update(update);\r\n        if (update.transactions.length)\r\n            this.lastKeyCode = this.lastSelectionTime = 0;\r\n    }\r\n    destroy() {\r\n        if (this.mouseSelection)\r\n            this.mouseSelection.destroy();\r\n    }\r\n}\r\nconst PendingKeys = [\r\n    { key: \"Backspace\", keyCode: 8, inputType: \"deleteContentBackward\" },\r\n    { key: \"Enter\", keyCode: 13, inputType: \"insertParagraph\" },\r\n    { key: \"Delete\", keyCode: 46, inputType: \"deleteContentForward\" }\r\n];\r\nconst EmacsyPendingKeys = \"dthko\";\r\n// Key codes for modifier keys\r\nconst modifierCodes = [16, 17, 18, 20, 91, 92, 224, 225];\r\nfunction dragScrollSpeed(dist) {\r\n    return dist * 0.7 + 8;\r\n}\r\nclass MouseSelection {\r\n    constructor(view, startEvent, style, mustSelect) {\r\n        this.view = view;\r\n        this.style = style;\r\n        this.mustSelect = mustSelect;\r\n        this.scrollSpeed = { x: 0, y: 0 };\r\n        this.scrolling = -1;\r\n        this.lastEvent = startEvent;\r\n        this.scrollParent = scrollableParent(view.contentDOM);\r\n        let doc = view.contentDOM.ownerDocument;\r\n        doc.addEventListener(\"mousemove\", this.move = this.move.bind(this));\r\n        doc.addEventListener(\"mouseup\", this.up = this.up.bind(this));\r\n        this.extend = startEvent.shiftKey;\r\n        this.multiple = view.state.facet(_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorState.allowMultipleSelections) && addsSelectionRange(view, startEvent);\r\n        this.dragMove = dragMovesSelection(view, startEvent);\r\n        this.dragging = isInPrimarySelection(view, startEvent) && getClickType(startEvent) == 1 ? null : false;\r\n        // When clicking outside of the selection, immediately apply the\r\n        // effect of starting the selection\r\n        if (this.dragging === false) {\r\n            startEvent.preventDefault();\r\n            this.select(startEvent);\r\n        }\r\n    }\r\n    move(event) {\r\n        var _a;\r\n        if (event.buttons == 0)\r\n            return this.destroy();\r\n        if (this.dragging !== false)\r\n            return;\r\n        this.select(this.lastEvent = event);\r\n        let sx = 0, sy = 0;\r\n        let rect = ((_a = this.scrollParent) === null || _a === void 0 ? void 0 : _a.getBoundingClientRect())\r\n            || { left: 0, top: 0, right: this.view.win.innerWidth, bottom: this.view.win.innerHeight };\r\n        if (event.clientX <= rect.left)\r\n            sx = -dragScrollSpeed(rect.left - event.clientX);\r\n        else if (event.clientX >= rect.right)\r\n            sx = dragScrollSpeed(event.clientX - rect.right);\r\n        if (event.clientY <= rect.top)\r\n            sy = -dragScrollSpeed(rect.top - event.clientY);\r\n        else if (event.clientY >= rect.bottom)\r\n            sy = dragScrollSpeed(event.clientY - rect.bottom);\r\n        this.setScrollSpeed(sx, sy);\r\n    }\r\n    up(event) {\r\n        if (this.dragging == null)\r\n            this.select(this.lastEvent);\r\n        if (!this.dragging)\r\n            event.preventDefault();\r\n        this.destroy();\r\n    }\r\n    destroy() {\r\n        this.setScrollSpeed(0, 0);\r\n        let doc = this.view.contentDOM.ownerDocument;\r\n        doc.removeEventListener(\"mousemove\", this.move);\r\n        doc.removeEventListener(\"mouseup\", this.up);\r\n        this.view.inputState.mouseSelection = null;\r\n    }\r\n    setScrollSpeed(sx, sy) {\r\n        this.scrollSpeed = { x: sx, y: sy };\r\n        if (sx || sy) {\r\n            if (this.scrolling < 0)\r\n                this.scrolling = setInterval(() => this.scroll(), 50);\r\n        }\r\n        else if (this.scrolling > -1) {\r\n            clearInterval(this.scrolling);\r\n            this.scrolling = -1;\r\n        }\r\n    }\r\n    scroll() {\r\n        if (this.scrollParent) {\r\n            this.scrollParent.scrollLeft += this.scrollSpeed.x;\r\n            this.scrollParent.scrollTop += this.scrollSpeed.y;\r\n        }\r\n        else {\r\n            this.view.win.scrollBy(this.scrollSpeed.x, this.scrollSpeed.y);\r\n        }\r\n        if (this.dragging === false)\r\n            this.select(this.lastEvent);\r\n    }\r\n    select(event) {\r\n        let selection = this.style.get(event, this.extend, this.multiple);\r\n        if (this.mustSelect || !selection.eq(this.view.state.selection) ||\r\n            selection.main.assoc != this.view.state.selection.main.assoc)\r\n            this.view.dispatch({\r\n                selection,\r\n                userEvent: \"select.pointer\"\r\n            });\r\n        this.mustSelect = false;\r\n    }\r\n    update(update) {\r\n        if (update.docChanged && this.dragging)\r\n            this.dragging = this.dragging.map(update.changes);\r\n        if (this.style.update(update))\r\n            setTimeout(() => this.select(this.lastEvent), 20);\r\n    }\r\n}\r\nfunction addsSelectionRange(view, event) {\r\n    let facet = view.state.facet(clickAddsSelectionRange);\r\n    return facet.length ? facet[0](event) : browser.mac ? event.metaKey : event.ctrlKey;\r\n}\r\nfunction dragMovesSelection(view, event) {\r\n    let facet = view.state.facet(dragMovesSelection$1);\r\n    return facet.length ? facet[0](event) : browser.mac ? !event.altKey : !event.ctrlKey;\r\n}\r\nfunction isInPrimarySelection(view, event) {\r\n    let { main } = view.state.selection;\r\n    if (main.empty)\r\n        return false;\r\n    // On boundary clicks, check whether the coordinates are inside the\r\n    // selection's client rectangles\r\n    let sel = getSelection(view.root);\r\n    if (!sel || sel.rangeCount == 0)\r\n        return true;\r\n    let rects = sel.getRangeAt(0).getClientRects();\r\n    for (let i = 0; i < rects.length; i++) {\r\n        let rect = rects[i];\r\n        if (rect.left <= event.clientX && rect.right >= event.clientX &&\r\n            rect.top <= event.clientY && rect.bottom >= event.clientY)\r\n            return true;\r\n    }\r\n    return false;\r\n}\r\nfunction eventBelongsToEditor(view, event) {\r\n    if (!event.bubbles)\r\n        return true;\r\n    if (event.defaultPrevented)\r\n        return false;\r\n    for (let node = event.target, cView; node != view.contentDOM; node = node.parentNode)\r\n        if (!node || node.nodeType == 11 || ((cView = ContentView.get(node)) && cView.ignoreEvent(event)))\r\n            return false;\r\n    return true;\r\n}\r\nconst handlers = /*@__PURE__*/Object.create(null);\r\nconst handlerOptions = /*@__PURE__*/Object.create(null);\r\n// This is very crude, but unfortunately both these browsers _pretend_\r\n// that they have a clipboard API—all the objects and methods are\r\n// there, they just don't work, and they are hard to test.\r\nconst brokenClipboardAPI = (browser.ie && browser.ie_version < 15) ||\r\n    (browser.ios && browser.webkit_version < 604);\r\nfunction capturePaste(view) {\r\n    let parent = view.dom.parentNode;\r\n    if (!parent)\r\n        return;\r\n    let target = parent.appendChild(document.createElement(\"textarea\"));\r\n    target.style.cssText = \"position: fixed; left: -10000px; top: 10px\";\r\n    target.focus();\r\n    setTimeout(() => {\r\n        view.focus();\r\n        target.remove();\r\n        doPaste(view, target.value);\r\n    }, 50);\r\n}\r\nfunction doPaste(view, input) {\r\n    let { state } = view, changes, i = 1, text = state.toText(input);\r\n    let byLine = text.lines == state.selection.ranges.length;\r\n    let linewise = lastLinewiseCopy != null && state.selection.ranges.every(r => r.empty) && lastLinewiseCopy == text.toString();\r\n    if (linewise) {\r\n        let lastLine = -1;\r\n        changes = state.changeByRange(range => {\r\n            let line = state.doc.lineAt(range.from);\r\n            if (line.from == lastLine)\r\n                return { range };\r\n            lastLine = line.from;\r\n            let insert = state.toText((byLine ? text.line(i++).text : input) + state.lineBreak);\r\n            return { changes: { from: line.from, insert },\r\n                range: _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.cursor(range.from + insert.length) };\r\n        });\r\n    }\r\n    else if (byLine) {\r\n        changes = state.changeByRange(range => {\r\n            let line = text.line(i++);\r\n            return { changes: { from: range.from, to: range.to, insert: line.text },\r\n                range: _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.cursor(range.from + line.length) };\r\n        });\r\n    }\r\n    else {\r\n        changes = state.replaceSelection(text);\r\n    }\r\n    view.dispatch(changes, {\r\n        userEvent: \"input.paste\",\r\n        scrollIntoView: true\r\n    });\r\n}\r\nhandlers.keydown = (view, event) => {\r\n    view.inputState.setSelectionOrigin(\"select\");\r\n    if (event.keyCode == 27)\r\n        view.inputState.lastEscPress = Date.now();\r\n    else if (modifierCodes.indexOf(event.keyCode) < 0)\r\n        view.inputState.lastEscPress = 0;\r\n};\r\nhandlers.touchstart = (view, e) => {\r\n    view.inputState.lastTouchTime = Date.now();\r\n    view.inputState.setSelectionOrigin(\"select.pointer\");\r\n};\r\nhandlers.touchmove = view => {\r\n    view.inputState.setSelectionOrigin(\"select.pointer\");\r\n};\r\nhandlerOptions.touchstart = handlerOptions.touchmove = { passive: true };\r\nhandlers.mousedown = (view, event) => {\r\n    view.observer.flush();\r\n    if (view.inputState.lastTouchTime > Date.now() - 2000)\r\n        return; // Ignore touch interaction\r\n    let style = null;\r\n    for (let makeStyle of view.state.facet(mouseSelectionStyle)) {\r\n        style = makeStyle(view, event);\r\n        if (style)\r\n            break;\r\n    }\r\n    if (!style && event.button == 0)\r\n        style = basicMouseSelection(view, event);\r\n    if (style) {\r\n        let mustFocus = view.root.activeElement != view.contentDOM;\r\n        if (mustFocus)\r\n            view.observer.ignore(() => focusPreventScroll(view.contentDOM));\r\n        view.inputState.startMouseSelection(new MouseSelection(view, event, style, mustFocus));\r\n    }\r\n};\r\nfunction rangeForClick(view, pos, bias, type) {\r\n    if (type == 1) { // Single click\r\n        return _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.cursor(pos, bias);\r\n    }\r\n    else if (type == 2) { // Double click\r\n        return groupAt(view.state, pos, bias);\r\n    }\r\n    else { // Triple click\r\n        let visual = LineView.find(view.docView, pos), line = view.state.doc.lineAt(visual ? visual.posAtEnd : pos);\r\n        let from = visual ? visual.posAtStart : line.from, to = visual ? visual.posAtEnd : line.to;\r\n        if (to < view.state.doc.length && to == line.to)\r\n            to++;\r\n        return _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.range(from, to);\r\n    }\r\n}\r\nlet insideY = (y, rect) => y >= rect.top && y <= rect.bottom;\r\nlet inside = (x, y, rect) => insideY(y, rect) && x >= rect.left && x <= rect.right;\r\n// Try to determine, for the given coordinates, associated with the\r\n// given position, whether they are related to the element before or\r\n// the element after the position.\r\nfunction findPositionSide(view, pos, x, y) {\r\n    let line = LineView.find(view.docView, pos);\r\n    if (!line)\r\n        return 1;\r\n    let off = pos - line.posAtStart;\r\n    // Line boundaries point into the line\r\n    if (off == 0)\r\n        return 1;\r\n    if (off == line.length)\r\n        return -1;\r\n    // Positions on top of an element point at that element\r\n    let before = line.coordsAt(off, -1);\r\n    if (before && inside(x, y, before))\r\n        return -1;\r\n    let after = line.coordsAt(off, 1);\r\n    if (after && inside(x, y, after))\r\n        return 1;\r\n    // This is probably a line wrap point. Pick before if the point is\r\n    // beside it.\r\n    return before && insideY(y, before) ? -1 : 1;\r\n}\r\nfunction queryPos(view, event) {\r\n    let pos = view.posAtCoords({ x: event.clientX, y: event.clientY }, false);\r\n    return { pos, bias: findPositionSide(view, pos, event.clientX, event.clientY) };\r\n}\r\nconst BadMouseDetail = browser.ie && browser.ie_version <= 11;\r\nlet lastMouseDown = null, lastMouseDownCount = 0, lastMouseDownTime = 0;\r\nfunction getClickType(event) {\r\n    if (!BadMouseDetail)\r\n        return event.detail;\r\n    let last = lastMouseDown, lastTime = lastMouseDownTime;\r\n    lastMouseDown = event;\r\n    lastMouseDownTime = Date.now();\r\n    return lastMouseDownCount = !last || (lastTime > Date.now() - 400 && Math.abs(last.clientX - event.clientX) < 2 &&\r\n        Math.abs(last.clientY - event.clientY) < 2) ? (lastMouseDownCount + 1) % 3 : 1;\r\n}\r\nfunction basicMouseSelection(view, event) {\r\n    let start = queryPos(view, event), type = getClickType(event);\r\n    let startSel = view.state.selection;\r\n    return {\r\n        update(update) {\r\n            if (update.docChanged) {\r\n                start.pos = update.changes.mapPos(start.pos);\r\n                startSel = startSel.map(update.changes);\r\n            }\r\n        },\r\n        get(event, extend, multiple) {\r\n            let cur = queryPos(view, event);\r\n            let range = rangeForClick(view, cur.pos, cur.bias, type);\r\n            if (start.pos != cur.pos && !extend) {\r\n                let startRange = rangeForClick(view, start.pos, start.bias, type);\r\n                let from = Math.min(startRange.from, range.from), to = Math.max(startRange.to, range.to);\r\n                range = from < range.from ? _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.range(from, to) : _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.range(to, from);\r\n            }\r\n            if (extend)\r\n                return startSel.replaceRange(startSel.main.extend(range.from, range.to));\r\n            else if (multiple && startSel.ranges.length > 1 && startSel.ranges.some(r => r.eq(range)))\r\n                return removeRange(startSel, range);\r\n            else if (multiple)\r\n                return startSel.addRange(range);\r\n            else\r\n                return _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.create([range]);\r\n        }\r\n    };\r\n}\r\nfunction removeRange(sel, range) {\r\n    for (let i = 0;; i++) {\r\n        if (sel.ranges[i].eq(range))\r\n            return _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.create(sel.ranges.slice(0, i).concat(sel.ranges.slice(i + 1)), sel.mainIndex == i ? 0 : sel.mainIndex - (sel.mainIndex > i ? 1 : 0));\r\n    }\r\n}\r\nhandlers.dragstart = (view, event) => {\r\n    let { selection: { main } } = view.state;\r\n    let { mouseSelection } = view.inputState;\r\n    if (mouseSelection)\r\n        mouseSelection.dragging = main;\r\n    if (event.dataTransfer) {\r\n        event.dataTransfer.setData(\"Text\", view.state.sliceDoc(main.from, main.to));\r\n        event.dataTransfer.effectAllowed = \"copyMove\";\r\n    }\r\n};\r\nfunction dropText(view, event, text, direct) {\r\n    if (!text)\r\n        return;\r\n    let dropPos = view.posAtCoords({ x: event.clientX, y: event.clientY }, false);\r\n    event.preventDefault();\r\n    let { mouseSelection } = view.inputState;\r\n    let del = direct && mouseSelection && mouseSelection.dragging && mouseSelection.dragMove ?\r\n        { from: mouseSelection.dragging.from, to: mouseSelection.dragging.to } : null;\r\n    let ins = { from: dropPos, insert: text };\r\n    let changes = view.state.changes(del ? [del, ins] : ins);\r\n    view.focus();\r\n    view.dispatch({\r\n        changes,\r\n        selection: { anchor: changes.mapPos(dropPos, -1), head: changes.mapPos(dropPos, 1) },\r\n        userEvent: del ? \"move.drop\" : \"input.drop\"\r\n    });\r\n}\r\nhandlers.drop = (view, event) => {\r\n    if (!event.dataTransfer)\r\n        return;\r\n    if (view.state.readOnly)\r\n        return event.preventDefault();\r\n    let files = event.dataTransfer.files;\r\n    if (files && files.length) { // For a file drop, read the file's text.\r\n        event.preventDefault();\r\n        let text = Array(files.length), read = 0;\r\n        let finishFile = () => {\r\n            if (++read == files.length)\r\n                dropText(view, event, text.filter(s => s != null).join(view.state.lineBreak), false);\r\n        };\r\n        for (let i = 0; i < files.length; i++) {\r\n            let reader = new FileReader;\r\n            reader.onerror = finishFile;\r\n            reader.onload = () => {\r\n                if (!/[\\x00-\\x08\\x0e-\\x1f]{2}/.test(reader.result))\r\n                    text[i] = reader.result;\r\n                finishFile();\r\n            };\r\n            reader.readAsText(files[i]);\r\n        }\r\n    }\r\n    else {\r\n        dropText(view, event, event.dataTransfer.getData(\"Text\"), true);\r\n    }\r\n};\r\nhandlers.paste = (view, event) => {\r\n    if (view.state.readOnly)\r\n        return event.preventDefault();\r\n    view.observer.flush();\r\n    let data = brokenClipboardAPI ? null : event.clipboardData;\r\n    if (data) {\r\n        doPaste(view, data.getData(\"text/plain\"));\r\n        event.preventDefault();\r\n    }\r\n    else {\r\n        capturePaste(view);\r\n    }\r\n};\r\nfunction captureCopy(view, text) {\r\n    // The extra wrapper is somehow necessary on IE/Edge to prevent the\r\n    // content from being mangled when it is put onto the clipboard\r\n    let parent = view.dom.parentNode;\r\n    if (!parent)\r\n        return;\r\n    let target = parent.appendChild(document.createElement(\"textarea\"));\r\n    target.style.cssText = \"position: fixed; left: -10000px; top: 10px\";\r\n    target.value = text;\r\n    target.focus();\r\n    target.selectionEnd = text.length;\r\n    target.selectionStart = 0;\r\n    setTimeout(() => {\r\n        target.remove();\r\n        view.focus();\r\n    }, 50);\r\n}\r\nfunction copiedRange(state) {\r\n    let content = [], ranges = [], linewise = false;\r\n    for (let range of state.selection.ranges)\r\n        if (!range.empty) {\r\n            content.push(state.sliceDoc(range.from, range.to));\r\n            ranges.push(range);\r\n        }\r\n    if (!content.length) {\r\n        // Nothing selected, do a line-wise copy\r\n        let upto = -1;\r\n        for (let { from } of state.selection.ranges) {\r\n            let line = state.doc.lineAt(from);\r\n            if (line.number > upto) {\r\n                content.push(line.text);\r\n                ranges.push({ from: line.from, to: Math.min(state.doc.length, line.to + 1) });\r\n            }\r\n            upto = line.number;\r\n        }\r\n        linewise = true;\r\n    }\r\n    return { text: content.join(state.lineBreak), ranges, linewise };\r\n}\r\nlet lastLinewiseCopy = null;\r\nhandlers.copy = handlers.cut = (view, event) => {\r\n    let { text, ranges, linewise } = copiedRange(view.state);\r\n    if (!text && !linewise)\r\n        return;\r\n    lastLinewiseCopy = linewise ? text : null;\r\n    let data = brokenClipboardAPI ? null : event.clipboardData;\r\n    if (data) {\r\n        event.preventDefault();\r\n        data.clearData();\r\n        data.setData(\"text/plain\", text);\r\n    }\r\n    else {\r\n        captureCopy(view, text);\r\n    }\r\n    if (event.type == \"cut\" && !view.state.readOnly)\r\n        view.dispatch({\r\n            changes: ranges,\r\n            scrollIntoView: true,\r\n            userEvent: \"delete.cut\"\r\n        });\r\n};\r\nfunction updateForFocusChange(view) {\r\n    setTimeout(() => {\r\n        if (view.hasFocus != view.inputState.notifiedFocused)\r\n            view.update([]);\r\n    }, 10);\r\n}\r\nhandlers.focus = view => {\r\n    view.inputState.lastFocusTime = Date.now();\r\n    // When focusing reset the scroll position, move it back to where it was\r\n    if (!view.scrollDOM.scrollTop && (view.inputState.lastScrollTop || view.inputState.lastScrollLeft)) {\r\n        view.scrollDOM.scrollTop = view.inputState.lastScrollTop;\r\n        view.scrollDOM.scrollLeft = view.inputState.lastScrollLeft;\r\n    }\r\n    updateForFocusChange(view);\r\n};\r\nhandlers.blur = view => {\r\n    view.observer.clearSelectionRange();\r\n    updateForFocusChange(view);\r\n};\r\nhandlers.compositionstart = handlers.compositionupdate = view => {\r\n    if (view.inputState.compositionFirstChange == null)\r\n        view.inputState.compositionFirstChange = true;\r\n    if (view.inputState.composing < 0) {\r\n        // FIXME possibly set a timeout to clear it again on Android\r\n        view.inputState.composing = 0;\r\n    }\r\n};\r\nhandlers.compositionend = view => {\r\n    view.inputState.composing = -1;\r\n    view.inputState.compositionEndedAt = Date.now();\r\n    view.inputState.compositionFirstChange = null;\r\n    if (browser.chrome && browser.android)\r\n        view.observer.flushSoon();\r\n    setTimeout(() => {\r\n        // Force the composition state to be cleared if it hasn't already been\r\n        if (view.inputState.composing < 0 && view.docView.compositionDeco.size)\r\n            view.update([]);\r\n    }, 50);\r\n};\r\nhandlers.contextmenu = view => {\r\n    view.inputState.lastContextMenu = Date.now();\r\n};\r\nhandlers.beforeinput = (view, event) => {\r\n    var _a;\r\n    // Because Chrome Android doesn't fire useful key events, use\r\n    // beforeinput to detect backspace (and possibly enter and delete,\r\n    // but those usually don't even seem to fire beforeinput events at\r\n    // the moment) and fake a key event for it.\r\n    //\r\n    // (preventDefault on beforeinput, though supported in the spec,\r\n    // seems to do nothing at all on Chrome).\r\n    let pending;\r\n    if (browser.chrome && browser.android && (pending = PendingKeys.find(key => key.inputType == event.inputType))) {\r\n        view.observer.delayAndroidKey(pending.key, pending.keyCode);\r\n        if (pending.key == \"Backspace\" || pending.key == \"Delete\") {\r\n            let startViewHeight = ((_a = window.visualViewport) === null || _a === void 0 ? void 0 : _a.height) || 0;\r\n            setTimeout(() => {\r\n                var _a;\r\n                // Backspacing near uneditable nodes on Chrome Android sometimes\r\n                // closes the virtual keyboard. This tries to crudely detect\r\n                // that and refocus to get it back.\r\n                if ((((_a = window.visualViewport) === null || _a === void 0 ? void 0 : _a.height) || 0) > startViewHeight + 10 && view.hasFocus) {\r\n                    view.contentDOM.blur();\r\n                    view.focus();\r\n                }\r\n            }, 100);\r\n        }\r\n    }\r\n};\r\n\r\nconst wrappingWhiteSpace = [\"pre-wrap\", \"normal\", \"pre-line\", \"break-spaces\"];\r\nclass HeightOracle {\r\n    constructor(lineWrapping) {\r\n        this.lineWrapping = lineWrapping;\r\n        this.doc = _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Text.empty;\r\n        this.heightSamples = {};\r\n        this.lineHeight = 14;\r\n        this.charWidth = 7;\r\n        this.lineLength = 30;\r\n        // Used to track, during updateHeight, if any actual heights changed\r\n        this.heightChanged = false;\r\n    }\r\n    heightForGap(from, to) {\r\n        let lines = this.doc.lineAt(to).number - this.doc.lineAt(from).number + 1;\r\n        if (this.lineWrapping)\r\n            lines += Math.ceil(((to - from) - (lines * this.lineLength * 0.5)) / this.lineLength);\r\n        return this.lineHeight * lines;\r\n    }\r\n    heightForLine(length) {\r\n        if (!this.lineWrapping)\r\n            return this.lineHeight;\r\n        let lines = 1 + Math.max(0, Math.ceil((length - this.lineLength) / (this.lineLength - 5)));\r\n        return lines * this.lineHeight;\r\n    }\r\n    setDoc(doc) { this.doc = doc; return this; }\r\n    mustRefreshForWrapping(whiteSpace) {\r\n        return (wrappingWhiteSpace.indexOf(whiteSpace) > -1) != this.lineWrapping;\r\n    }\r\n    mustRefreshForHeights(lineHeights) {\r\n        let newHeight = false;\r\n        for (let i = 0; i < lineHeights.length; i++) {\r\n            let h = lineHeights[i];\r\n            if (h < 0) {\r\n                i++;\r\n            }\r\n            else if (!this.heightSamples[Math.floor(h * 10)]) { // Round to .1 pixels\r\n                newHeight = true;\r\n                this.heightSamples[Math.floor(h * 10)] = true;\r\n            }\r\n        }\r\n        return newHeight;\r\n    }\r\n    refresh(whiteSpace, lineHeight, charWidth, lineLength, knownHeights) {\r\n        let lineWrapping = wrappingWhiteSpace.indexOf(whiteSpace) > -1;\r\n        let changed = Math.round(lineHeight) != Math.round(this.lineHeight) || this.lineWrapping != lineWrapping;\r\n        this.lineWrapping = lineWrapping;\r\n        this.lineHeight = lineHeight;\r\n        this.charWidth = charWidth;\r\n        this.lineLength = lineLength;\r\n        if (changed) {\r\n            this.heightSamples = {};\r\n            for (let i = 0; i < knownHeights.length; i++) {\r\n                let h = knownHeights[i];\r\n                if (h < 0)\r\n                    i++;\r\n                else\r\n                    this.heightSamples[Math.floor(h * 10)] = true;\r\n            }\r\n        }\r\n        return changed;\r\n    }\r\n}\r\n// This object is used by `updateHeight` to make DOM measurements\r\n// arrive at the right nides. The `heights` array is a sequence of\r\n// block heights, starting from position `from`.\r\nclass MeasuredHeights {\r\n    constructor(from, heights) {\r\n        this.from = from;\r\n        this.heights = heights;\r\n        this.index = 0;\r\n    }\r\n    get more() { return this.index < this.heights.length; }\r\n}\r\n/**\r\nRecord used to represent information about a block-level element\r\nin the editor view.\r\n*/\r\nclass BlockInfo {\r\n    /**\r\n    @internal\r\n    */\r\n    constructor(\r\n    /**\r\n    The start of the element in the document.\r\n    */\r\n    from, \r\n    /**\r\n    The length of the element.\r\n    */\r\n    length, \r\n    /**\r\n    The top position of the element (relative to the top of the\r\n    document).\r\n    */\r\n    top, \r\n    /**\r\n    Its height.\r\n    */\r\n    height, \r\n    /**\r\n    The type of element this is. When querying lines, this may be\r\n    an array of all the blocks that make up the line.\r\n    */\r\n    type) {\r\n        this.from = from;\r\n        this.length = length;\r\n        this.top = top;\r\n        this.height = height;\r\n        this.type = type;\r\n    }\r\n    /**\r\n    The end of the element as a document position.\r\n    */\r\n    get to() { return this.from + this.length; }\r\n    /**\r\n    The bottom position of the element.\r\n    */\r\n    get bottom() { return this.top + this.height; }\r\n    /**\r\n    @internal\r\n    */\r\n    join(other) {\r\n        let detail = (Array.isArray(this.type) ? this.type : [this])\r\n            .concat(Array.isArray(other.type) ? other.type : [other]);\r\n        return new BlockInfo(this.from, this.length + other.length, this.top, this.height + other.height, detail);\r\n    }\r\n}\r\nvar QueryType = /*@__PURE__*/(function (QueryType) {\r\n    QueryType[QueryType[\"ByPos\"] = 0] = \"ByPos\";\r\n    QueryType[QueryType[\"ByHeight\"] = 1] = \"ByHeight\";\r\n    QueryType[QueryType[\"ByPosNoHeight\"] = 2] = \"ByPosNoHeight\";\r\nreturn QueryType})(QueryType || (QueryType = {}));\r\nconst Epsilon = 1e-3;\r\nclass HeightMap {\r\n    constructor(length, // The number of characters covered\r\n    height, // Height of this part of the document\r\n    flags = 2 /* Flag.Outdated */) {\r\n        this.length = length;\r\n        this.height = height;\r\n        this.flags = flags;\r\n    }\r\n    get outdated() { return (this.flags & 2 /* Flag.Outdated */) > 0; }\r\n    set outdated(value) { this.flags = (value ? 2 /* Flag.Outdated */ : 0) | (this.flags & ~2 /* Flag.Outdated */); }\r\n    setHeight(oracle, height) {\r\n        if (this.height != height) {\r\n            if (Math.abs(this.height - height) > Epsilon)\r\n                oracle.heightChanged = true;\r\n            this.height = height;\r\n        }\r\n    }\r\n    // Base case is to replace a leaf node, which simply builds a tree\r\n    // from the new nodes and returns that (HeightMapBranch and\r\n    // HeightMapGap override this to actually use from/to)\r\n    replace(_from, _to, nodes) {\r\n        return HeightMap.of(nodes);\r\n    }\r\n    // Again, these are base cases, and are overridden for branch and gap nodes.\r\n    decomposeLeft(_to, result) { result.push(this); }\r\n    decomposeRight(_from, result) { result.push(this); }\r\n    applyChanges(decorations, oldDoc, oracle, changes) {\r\n        let me = this;\r\n        for (let i = changes.length - 1; i >= 0; i--) {\r\n            let { fromA, toA, fromB, toB } = changes[i];\r\n            let start = me.lineAt(fromA, QueryType.ByPosNoHeight, oldDoc, 0, 0);\r\n            let end = start.to >= toA ? start : me.lineAt(toA, QueryType.ByPosNoHeight, oldDoc, 0, 0);\r\n            toB += end.to - toA;\r\n            toA = end.to;\r\n            while (i > 0 && start.from <= changes[i - 1].toA) {\r\n                fromA = changes[i - 1].fromA;\r\n                fromB = changes[i - 1].fromB;\r\n                i--;\r\n                if (fromA < start.from)\r\n                    start = me.lineAt(fromA, QueryType.ByPosNoHeight, oldDoc, 0, 0);\r\n            }\r\n            fromB += start.from - fromA;\r\n            fromA = start.from;\r\n            let nodes = NodeBuilder.build(oracle, decorations, fromB, toB);\r\n            me = me.replace(fromA, toA, nodes);\r\n        }\r\n        return me.updateHeight(oracle, 0);\r\n    }\r\n    static empty() { return new HeightMapText(0, 0); }\r\n    // nodes uses null values to indicate the position of line breaks.\r\n    // There are never line breaks at the start or end of the array, or\r\n    // two line breaks next to each other, and the array isn't allowed\r\n    // to be empty (same restrictions as return value from the builder).\r\n    static of(nodes) {\r\n        if (nodes.length == 1)\r\n            return nodes[0];\r\n        let i = 0, j = nodes.length, before = 0, after = 0;\r\n        for (;;) {\r\n            if (i == j) {\r\n                if (before > after * 2) {\r\n                    let split = nodes[i - 1];\r\n                    if (split.break)\r\n                        nodes.splice(--i, 1, split.left, null, split.right);\r\n                    else\r\n                        nodes.splice(--i, 1, split.left, split.right);\r\n                    j += 1 + split.break;\r\n                    before -= split.size;\r\n                }\r\n                else if (after > before * 2) {\r\n                    let split = nodes[j];\r\n                    if (split.break)\r\n                        nodes.splice(j, 1, split.left, null, split.right);\r\n                    else\r\n                        nodes.splice(j, 1, split.left, split.right);\r\n                    j += 2 + split.break;\r\n                    after -= split.size;\r\n                }\r\n                else {\r\n                    break;\r\n                }\r\n            }\r\n            else if (before < after) {\r\n                let next = nodes[i++];\r\n                if (next)\r\n                    before += next.size;\r\n            }\r\n            else {\r\n                let next = nodes[--j];\r\n                if (next)\r\n                    after += next.size;\r\n            }\r\n        }\r\n        let brk = 0;\r\n        if (nodes[i - 1] == null) {\r\n            brk = 1;\r\n            i--;\r\n        }\r\n        else if (nodes[i] == null) {\r\n            brk = 1;\r\n            j++;\r\n        }\r\n        return new HeightMapBranch(HeightMap.of(nodes.slice(0, i)), brk, HeightMap.of(nodes.slice(j)));\r\n    }\r\n}\r\nHeightMap.prototype.size = 1;\r\nclass HeightMapBlock extends HeightMap {\r\n    constructor(length, height, type) {\r\n        super(length, height);\r\n        this.type = type;\r\n    }\r\n    blockAt(_height, _doc, top, offset) {\r\n        return new BlockInfo(offset, this.length, top, this.height, this.type);\r\n    }\r\n    lineAt(_value, _type, doc, top, offset) {\r\n        return this.blockAt(0, doc, top, offset);\r\n    }\r\n    forEachLine(from, to, doc, top, offset, f) {\r\n        if (from <= offset + this.length && to >= offset)\r\n            f(this.blockAt(0, doc, top, offset));\r\n    }\r\n    updateHeight(oracle, offset = 0, _force = false, measured) {\r\n        if (measured && measured.from <= offset && measured.more)\r\n            this.setHeight(oracle, measured.heights[measured.index++]);\r\n        this.outdated = false;\r\n        return this;\r\n    }\r\n    toString() { return `block(${this.length})`; }\r\n}\r\nclass HeightMapText extends HeightMapBlock {\r\n    constructor(length, height) {\r\n        super(length, height, BlockType.Text);\r\n        this.collapsed = 0; // Amount of collapsed content in the line\r\n        this.widgetHeight = 0; // Maximum inline widget height\r\n    }\r\n    replace(_from, _to, nodes) {\r\n        let node = nodes[0];\r\n        if (nodes.length == 1 && (node instanceof HeightMapText || node instanceof HeightMapGap && (node.flags & 4 /* Flag.SingleLine */)) &&\r\n            Math.abs(this.length - node.length) < 10) {\r\n            if (node instanceof HeightMapGap)\r\n                node = new HeightMapText(node.length, this.height);\r\n            else\r\n                node.height = this.height;\r\n            if (!this.outdated)\r\n                node.outdated = false;\r\n            return node;\r\n        }\r\n        else {\r\n            return HeightMap.of(nodes);\r\n        }\r\n    }\r\n    updateHeight(oracle, offset = 0, force = false, measured) {\r\n        if (measured && measured.from <= offset && measured.more)\r\n            this.setHeight(oracle, measured.heights[measured.index++]);\r\n        else if (force || this.outdated)\r\n            this.setHeight(oracle, Math.max(this.widgetHeight, oracle.heightForLine(this.length - this.collapsed)));\r\n        this.outdated = false;\r\n        return this;\r\n    }\r\n    toString() {\r\n        return `line(${this.length}${this.collapsed ? -this.collapsed : \"\"}${this.widgetHeight ? \":\" + this.widgetHeight : \"\"})`;\r\n    }\r\n}\r\nclass HeightMapGap extends HeightMap {\r\n    constructor(length) { super(length, 0); }\r\n    lines(doc, offset) {\r\n        let firstLine = doc.lineAt(offset).number, lastLine = doc.lineAt(offset + this.length).number;\r\n        return { firstLine, lastLine, lineHeight: this.height / (lastLine - firstLine + 1) };\r\n    }\r\n    blockAt(height, doc, top, offset) {\r\n        let { firstLine, lastLine, lineHeight } = this.lines(doc, offset);\r\n        let line = Math.max(0, Math.min(lastLine - firstLine, Math.floor((height - top) / lineHeight)));\r\n        let { from, length } = doc.line(firstLine + line);\r\n        return new BlockInfo(from, length, top + lineHeight * line, lineHeight, BlockType.Text);\r\n    }\r\n    lineAt(value, type, doc, top, offset) {\r\n        if (type == QueryType.ByHeight)\r\n            return this.blockAt(value, doc, top, offset);\r\n        if (type == QueryType.ByPosNoHeight) {\r\n            let { from, to } = doc.lineAt(value);\r\n            return new BlockInfo(from, to - from, 0, 0, BlockType.Text);\r\n        }\r\n        let { firstLine, lineHeight } = this.lines(doc, offset);\r\n        let { from, length, number } = doc.lineAt(value);\r\n        return new BlockInfo(from, length, top + lineHeight * (number - firstLine), lineHeight, BlockType.Text);\r\n    }\r\n    forEachLine(from, to, doc, top, offset, f) {\r\n        let { firstLine, lineHeight } = this.lines(doc, offset);\r\n        for (let pos = Math.max(from, offset), end = Math.min(offset + this.length, to); pos <= end;) {\r\n            let line = doc.lineAt(pos);\r\n            if (pos == from)\r\n                top += lineHeight * (line.number - firstLine);\r\n            f(new BlockInfo(line.from, line.length, top, lineHeight, BlockType.Text));\r\n            top += lineHeight;\r\n            pos = line.to + 1;\r\n        }\r\n    }\r\n    replace(from, to, nodes) {\r\n        let after = this.length - to;\r\n        if (after > 0) {\r\n            let last = nodes[nodes.length - 1];\r\n            if (last instanceof HeightMapGap)\r\n                nodes[nodes.length - 1] = new HeightMapGap(last.length + after);\r\n            else\r\n                nodes.push(null, new HeightMapGap(after - 1));\r\n        }\r\n        if (from > 0) {\r\n            let first = nodes[0];\r\n            if (first instanceof HeightMapGap)\r\n                nodes[0] = new HeightMapGap(from + first.length);\r\n            else\r\n                nodes.unshift(new HeightMapGap(from - 1), null);\r\n        }\r\n        return HeightMap.of(nodes);\r\n    }\r\n    decomposeLeft(to, result) {\r\n        result.push(new HeightMapGap(to - 1), null);\r\n    }\r\n    decomposeRight(from, result) {\r\n        result.push(null, new HeightMapGap(this.length - from - 1));\r\n    }\r\n    updateHeight(oracle, offset = 0, force = false, measured) {\r\n        let end = offset + this.length;\r\n        if (measured && measured.from <= offset + this.length && measured.more) {\r\n            // Fill in part of this gap with measured lines. We know there\r\n            // can't be widgets or collapsed ranges in those lines, because\r\n            // they would already have been added to the heightmap (gaps\r\n            // only contain plain text).\r\n            let nodes = [], pos = Math.max(offset, measured.from), singleHeight = -1;\r\n            let wasChanged = oracle.heightChanged;\r\n            if (measured.from > offset)\r\n                nodes.push(new HeightMapGap(measured.from - offset - 1).updateHeight(oracle, offset));\r\n            while (pos <= end && measured.more) {\r\n                let len = oracle.doc.lineAt(pos).length;\r\n                if (nodes.length)\r\n                    nodes.push(null);\r\n                let height = measured.heights[measured.index++];\r\n                if (singleHeight == -1)\r\n                    singleHeight = height;\r\n                else if (Math.abs(height - singleHeight) >= Epsilon)\r\n                    singleHeight = -2;\r\n                let line = new HeightMapText(len, height);\r\n                line.outdated = false;\r\n                nodes.push(line);\r\n                pos += len + 1;\r\n            }\r\n            if (pos <= end)\r\n                nodes.push(null, new HeightMapGap(end - pos).updateHeight(oracle, pos));\r\n            let result = HeightMap.of(nodes);\r\n            oracle.heightChanged = wasChanged || singleHeight < 0 || Math.abs(result.height - this.height) >= Epsilon ||\r\n                Math.abs(singleHeight - this.lines(oracle.doc, offset).lineHeight) >= Epsilon;\r\n            return result;\r\n        }\r\n        else if (force || this.outdated) {\r\n            this.setHeight(oracle, oracle.heightForGap(offset, offset + this.length));\r\n            this.outdated = false;\r\n        }\r\n        return this;\r\n    }\r\n    toString() { return `gap(${this.length})`; }\r\n}\r\nclass HeightMapBranch extends HeightMap {\r\n    constructor(left, brk, right) {\r\n        super(left.length + brk + right.length, left.height + right.height, brk | (left.outdated || right.outdated ? 2 /* Flag.Outdated */ : 0));\r\n        this.left = left;\r\n        this.right = right;\r\n        this.size = left.size + right.size;\r\n    }\r\n    get break() { return this.flags & 1 /* Flag.Break */; }\r\n    blockAt(height, doc, top, offset) {\r\n        let mid = top + this.left.height;\r\n        return height < mid ? this.left.blockAt(height, doc, top, offset)\r\n            : this.right.blockAt(height, doc, mid, offset + this.left.length + this.break);\r\n    }\r\n    lineAt(value, type, doc, top, offset) {\r\n        let rightTop = top + this.left.height, rightOffset = offset + this.left.length + this.break;\r\n        let left = type == QueryType.ByHeight ? value < rightTop : value < rightOffset;\r\n        let base = left ? this.left.lineAt(value, type, doc, top, offset)\r\n            : this.right.lineAt(value, type, doc, rightTop, rightOffset);\r\n        if (this.break || (left ? base.to < rightOffset : base.from > rightOffset))\r\n            return base;\r\n        let subQuery = type == QueryType.ByPosNoHeight ? QueryType.ByPosNoHeight : QueryType.ByPos;\r\n        if (left)\r\n            return base.join(this.right.lineAt(rightOffset, subQuery, doc, rightTop, rightOffset));\r\n        else\r\n            return this.left.lineAt(rightOffset, subQuery, doc, top, offset).join(base);\r\n    }\r\n    forEachLine(from, to, doc, top, offset, f) {\r\n        let rightTop = top + this.left.height, rightOffset = offset + this.left.length + this.break;\r\n        if (this.break) {\r\n            if (from < rightOffset)\r\n                this.left.forEachLine(from, to, doc, top, offset, f);\r\n            if (to >= rightOffset)\r\n                this.right.forEachLine(from, to, doc, rightTop, rightOffset, f);\r\n        }\r\n        else {\r\n            let mid = this.lineAt(rightOffset, QueryType.ByPos, doc, top, offset);\r\n            if (from < mid.from)\r\n                this.left.forEachLine(from, mid.from - 1, doc, top, offset, f);\r\n            if (mid.to >= from && mid.from <= to)\r\n                f(mid);\r\n            if (to > mid.to)\r\n                this.right.forEachLine(mid.to + 1, to, doc, rightTop, rightOffset, f);\r\n        }\r\n    }\r\n    replace(from, to, nodes) {\r\n        let rightStart = this.left.length + this.break;\r\n        if (to < rightStart)\r\n            return this.balanced(this.left.replace(from, to, nodes), this.right);\r\n        if (from > this.left.length)\r\n            return this.balanced(this.left, this.right.replace(from - rightStart, to - rightStart, nodes));\r\n        let result = [];\r\n        if (from > 0)\r\n            this.decomposeLeft(from, result);\r\n        let left = result.length;\r\n        for (let node of nodes)\r\n            result.push(node);\r\n        if (from > 0)\r\n            mergeGaps(result, left - 1);\r\n        if (to < this.length) {\r\n            let right = result.length;\r\n            this.decomposeRight(to, result);\r\n            mergeGaps(result, right);\r\n        }\r\n        return HeightMap.of(result);\r\n    }\r\n    decomposeLeft(to, result) {\r\n        let left = this.left.length;\r\n        if (to <= left)\r\n            return this.left.decomposeLeft(to, result);\r\n        result.push(this.left);\r\n        if (this.break) {\r\n            left++;\r\n            if (to >= left)\r\n                result.push(null);\r\n        }\r\n        if (to > left)\r\n            this.right.decomposeLeft(to - left, result);\r\n    }\r\n    decomposeRight(from, result) {\r\n        let left = this.left.length, right = left + this.break;\r\n        if (from >= right)\r\n            return this.right.decomposeRight(from - right, result);\r\n        if (from < left)\r\n            this.left.decomposeRight(from, result);\r\n        if (this.break && from < right)\r\n            result.push(null);\r\n        result.push(this.right);\r\n    }\r\n    balanced(left, right) {\r\n        if (left.size > 2 * right.size || right.size > 2 * left.size)\r\n            return HeightMap.of(this.break ? [left, null, right] : [left, right]);\r\n        this.left = left;\r\n        this.right = right;\r\n        this.height = left.height + right.height;\r\n        this.outdated = left.outdated || right.outdated;\r\n        this.size = left.size + right.size;\r\n        this.length = left.length + this.break + right.length;\r\n        return this;\r\n    }\r\n    updateHeight(oracle, offset = 0, force = false, measured) {\r\n        let { left, right } = this, rightStart = offset + left.length + this.break, rebalance = null;\r\n        if (measured && measured.from <= offset + left.length && measured.more)\r\n            rebalance = left = left.updateHeight(oracle, offset, force, measured);\r\n        else\r\n            left.updateHeight(oracle, offset, force);\r\n        if (measured && measured.from <= rightStart + right.length && measured.more)\r\n            rebalance = right = right.updateHeight(oracle, rightStart, force, measured);\r\n        else\r\n            right.updateHeight(oracle, rightStart, force);\r\n        if (rebalance)\r\n            return this.balanced(left, right);\r\n        this.height = this.left.height + this.right.height;\r\n        this.outdated = false;\r\n        return this;\r\n    }\r\n    toString() { return this.left + (this.break ? \" \" : \"-\") + this.right; }\r\n}\r\nfunction mergeGaps(nodes, around) {\r\n    let before, after;\r\n    if (nodes[around] == null &&\r\n        (before = nodes[around - 1]) instanceof HeightMapGap &&\r\n        (after = nodes[around + 1]) instanceof HeightMapGap)\r\n        nodes.splice(around - 1, 3, new HeightMapGap(before.length + 1 + after.length));\r\n}\r\nconst relevantWidgetHeight = 5;\r\nclass NodeBuilder {\r\n    constructor(pos, oracle) {\r\n        this.pos = pos;\r\n        this.oracle = oracle;\r\n        this.nodes = [];\r\n        this.lineStart = -1;\r\n        this.lineEnd = -1;\r\n        this.covering = null;\r\n        this.writtenTo = pos;\r\n    }\r\n    get isCovered() {\r\n        return this.covering && this.nodes[this.nodes.length - 1] == this.covering;\r\n    }\r\n    span(_from, to) {\r\n        if (this.lineStart > -1) {\r\n            let end = Math.min(to, this.lineEnd), last = this.nodes[this.nodes.length - 1];\r\n            if (last instanceof HeightMapText)\r\n                last.length += end - this.pos;\r\n            else if (end > this.pos || !this.isCovered)\r\n                this.nodes.push(new HeightMapText(end - this.pos, -1));\r\n            this.writtenTo = end;\r\n            if (to > end) {\r\n                this.nodes.push(null);\r\n                this.writtenTo++;\r\n                this.lineStart = -1;\r\n            }\r\n        }\r\n        this.pos = to;\r\n    }\r\n    point(from, to, deco) {\r\n        if (from < to || deco.heightRelevant) {\r\n            let height = deco.widget ? deco.widget.estimatedHeight : 0;\r\n            if (height < 0)\r\n                height = this.oracle.lineHeight;\r\n            let len = to - from;\r\n            if (deco.block) {\r\n                this.addBlock(new HeightMapBlock(len, height, deco.type));\r\n            }\r\n            else if (len || height >= relevantWidgetHeight) {\r\n                this.addLineDeco(height, len);\r\n            }\r\n        }\r\n        else if (to > from) {\r\n            this.span(from, to);\r\n        }\r\n        if (this.lineEnd > -1 && this.lineEnd < this.pos)\r\n            this.lineEnd = this.oracle.doc.lineAt(this.pos).to;\r\n    }\r\n    enterLine() {\r\n        if (this.lineStart > -1)\r\n            return;\r\n        let { from, to } = this.oracle.doc.lineAt(this.pos);\r\n        this.lineStart = from;\r\n        this.lineEnd = to;\r\n        if (this.writtenTo < from) {\r\n            if (this.writtenTo < from - 1 || this.nodes[this.nodes.length - 1] == null)\r\n                this.nodes.push(this.blankContent(this.writtenTo, from - 1));\r\n            this.nodes.push(null);\r\n        }\r\n        if (this.pos > from)\r\n            this.nodes.push(new HeightMapText(this.pos - from, -1));\r\n        this.writtenTo = this.pos;\r\n    }\r\n    blankContent(from, to) {\r\n        let gap = new HeightMapGap(to - from);\r\n        if (this.oracle.doc.lineAt(from).to == to)\r\n            gap.flags |= 4 /* Flag.SingleLine */;\r\n        return gap;\r\n    }\r\n    ensureLine() {\r\n        this.enterLine();\r\n        let last = this.nodes.length ? this.nodes[this.nodes.length - 1] : null;\r\n        if (last instanceof HeightMapText)\r\n            return last;\r\n        let line = new HeightMapText(0, -1);\r\n        this.nodes.push(line);\r\n        return line;\r\n    }\r\n    addBlock(block) {\r\n        this.enterLine();\r\n        if (block.type == BlockType.WidgetAfter && !this.isCovered)\r\n            this.ensureLine();\r\n        this.nodes.push(block);\r\n        this.writtenTo = this.pos = this.pos + block.length;\r\n        if (block.type != BlockType.WidgetBefore)\r\n            this.covering = block;\r\n    }\r\n    addLineDeco(height, length) {\r\n        let line = this.ensureLine();\r\n        line.length += length;\r\n        line.collapsed += length;\r\n        line.widgetHeight = Math.max(line.widgetHeight, height);\r\n        this.writtenTo = this.pos = this.pos + length;\r\n    }\r\n    finish(from) {\r\n        let last = this.nodes.length == 0 ? null : this.nodes[this.nodes.length - 1];\r\n        if (this.lineStart > -1 && !(last instanceof HeightMapText) && !this.isCovered)\r\n            this.nodes.push(new HeightMapText(0, -1));\r\n        else if (this.writtenTo < this.pos || last == null)\r\n            this.nodes.push(this.blankContent(this.writtenTo, this.pos));\r\n        let pos = from;\r\n        for (let node of this.nodes) {\r\n            if (node instanceof HeightMapText)\r\n                node.updateHeight(this.oracle, pos);\r\n            pos += node ? node.length : 1;\r\n        }\r\n        return this.nodes;\r\n    }\r\n    // Always called with a region that on both sides either stretches\r\n    // to a line break or the end of the document.\r\n    // The returned array uses null to indicate line breaks, but never\r\n    // starts or ends in a line break, or has multiple line breaks next\r\n    // to each other.\r\n    static build(oracle, decorations, from, to) {\r\n        let builder = new NodeBuilder(from, oracle);\r\n        _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.RangeSet.spans(decorations, from, to, builder, 0);\r\n        return builder.finish(from);\r\n    }\r\n}\r\nfunction heightRelevantDecoChanges(a, b, diff) {\r\n    let comp = new DecorationComparator;\r\n    _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.RangeSet.compare(a, b, diff, comp, 0);\r\n    return comp.changes;\r\n}\r\nclass DecorationComparator {\r\n    constructor() {\r\n        this.changes = [];\r\n    }\r\n    compareRange() { }\r\n    comparePoint(from, to, a, b) {\r\n        if (from < to || a && a.heightRelevant || b && b.heightRelevant)\r\n            addRange(from, to, this.changes, 5);\r\n    }\r\n}\r\n\r\nfunction visiblePixelRange(dom, paddingTop) {\r\n    let rect = dom.getBoundingClientRect();\r\n    let doc = dom.ownerDocument, win = doc.defaultView || window;\r\n    let left = Math.max(0, rect.left), right = Math.min(win.innerWidth, rect.right);\r\n    let top = Math.max(0, rect.top), bottom = Math.min(win.innerHeight, rect.bottom);\r\n    for (let parent = dom.parentNode; parent && parent != doc.body;) {\r\n        if (parent.nodeType == 1) {\r\n            let elt = parent;\r\n            let style = window.getComputedStyle(elt);\r\n            if ((elt.scrollHeight > elt.clientHeight || elt.scrollWidth > elt.clientWidth) &&\r\n                style.overflow != \"visible\") {\r\n                let parentRect = elt.getBoundingClientRect();\r\n                left = Math.max(left, parentRect.left);\r\n                right = Math.min(right, parentRect.right);\r\n                top = Math.max(top, parentRect.top);\r\n                bottom = parent == dom.parentNode ? parentRect.bottom : Math.min(bottom, parentRect.bottom);\r\n            }\r\n            parent = style.position == \"absolute\" || style.position == \"fixed\" ? elt.offsetParent : elt.parentNode;\r\n        }\r\n        else if (parent.nodeType == 11) { // Shadow root\r\n            parent = parent.host;\r\n        }\r\n        else {\r\n            break;\r\n        }\r\n    }\r\n    return { left: left - rect.left, right: Math.max(left, right) - rect.left,\r\n        top: top - (rect.top + paddingTop), bottom: Math.max(top, bottom) - (rect.top + paddingTop) };\r\n}\r\nfunction fullPixelRange(dom, paddingTop) {\r\n    let rect = dom.getBoundingClientRect();\r\n    return { left: 0, right: rect.right - rect.left,\r\n        top: paddingTop, bottom: rect.bottom - (rect.top + paddingTop) };\r\n}\r\n// Line gaps are placeholder widgets used to hide pieces of overlong\r\n// lines within the viewport, as a kludge to keep the editor\r\n// responsive when a ridiculously long line is loaded into it.\r\nclass LineGap {\r\n    constructor(from, to, size) {\r\n        this.from = from;\r\n        this.to = to;\r\n        this.size = size;\r\n    }\r\n    static same(a, b) {\r\n        if (a.length != b.length)\r\n            return false;\r\n        for (let i = 0; i < a.length; i++) {\r\n            let gA = a[i], gB = b[i];\r\n            if (gA.from != gB.from || gA.to != gB.to || gA.size != gB.size)\r\n                return false;\r\n        }\r\n        return true;\r\n    }\r\n    draw(wrapping) {\r\n        return Decoration.replace({ widget: new LineGapWidget(this.size, wrapping) }).range(this.from, this.to);\r\n    }\r\n}\r\nclass LineGapWidget extends WidgetType {\r\n    constructor(size, vertical) {\r\n        super();\r\n        this.size = size;\r\n        this.vertical = vertical;\r\n    }\r\n    eq(other) { return other.size == this.size && other.vertical == this.vertical; }\r\n    toDOM() {\r\n        let elt = document.createElement(\"div\");\r\n        if (this.vertical) {\r\n            elt.style.height = this.size + \"px\";\r\n        }\r\n        else {\r\n            elt.style.width = this.size + \"px\";\r\n            elt.style.height = \"2px\";\r\n            elt.style.display = \"inline-block\";\r\n        }\r\n        return elt;\r\n    }\r\n    get estimatedHeight() { return this.vertical ? this.size : -1; }\r\n}\r\nclass ViewState {\r\n    constructor(state) {\r\n        this.state = state;\r\n        // These are contentDOM-local coordinates\r\n        this.pixelViewport = { left: 0, right: window.innerWidth, top: 0, bottom: 0 };\r\n        this.inView = true;\r\n        this.paddingTop = 0;\r\n        this.paddingBottom = 0;\r\n        this.contentDOMWidth = 0;\r\n        this.contentDOMHeight = 0;\r\n        this.editorHeight = 0;\r\n        this.editorWidth = 0;\r\n        // See VP.MaxDOMHeight\r\n        this.scaler = IdScaler;\r\n        this.scrollTarget = null;\r\n        // Briefly set to true when printing, to disable viewport limiting\r\n        this.printing = false;\r\n        // Flag set when editor content was redrawn, so that the next\r\n        // measure stage knows it must read DOM layout\r\n        this.mustMeasureContent = true;\r\n        this.defaultTextDirection = Direction.LTR;\r\n        this.visibleRanges = [];\r\n        // Cursor 'assoc' is only significant when the cursor is on a line\r\n        // wrap point, where it must stick to the character that it is\r\n        // associated with. Since browsers don't provide a reasonable\r\n        // interface to set or query this, when a selection is set that\r\n        // might cause this to be significant, this flag is set. The next\r\n        // measure phase will check whether the cursor is on a line-wrapping\r\n        // boundary and, if so, reset it to make sure it is positioned in\r\n        // the right place.\r\n        this.mustEnforceCursorAssoc = false;\r\n        let guessWrapping = state.facet(contentAttributes).some(v => typeof v != \"function\" && v.class == \"cm-lineWrapping\");\r\n        this.heightOracle = new HeightOracle(guessWrapping);\r\n        this.stateDeco = state.facet(decorations).filter(d => typeof d != \"function\");\r\n        this.heightMap = HeightMap.empty().applyChanges(this.stateDeco, _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Text.empty, this.heightOracle.setDoc(state.doc), [new ChangedRange(0, 0, 0, state.doc.length)]);\r\n        this.viewport = this.getViewport(0, null);\r\n        this.updateViewportLines();\r\n        this.updateForViewport();\r\n        this.lineGaps = this.ensureLineGaps([]);\r\n        this.lineGapDeco = Decoration.set(this.lineGaps.map(gap => gap.draw(false)));\r\n        this.computeVisibleRanges();\r\n    }\r\n    updateForViewport() {\r\n        let viewports = [this.viewport], { main } = this.state.selection;\r\n        for (let i = 0; i <= 1; i++) {\r\n            let pos = i ? main.head : main.anchor;\r\n            if (!viewports.some(({ from, to }) => pos >= from && pos <= to)) {\r\n                let { from, to } = this.lineBlockAt(pos);\r\n                viewports.push(new Viewport(from, to));\r\n            }\r\n        }\r\n        this.viewports = viewports.sort((a, b) => a.from - b.from);\r\n        this.scaler = this.heightMap.height <= 7000000 /* VP.MaxDOMHeight */ ? IdScaler :\r\n            new BigScaler(this.heightOracle.doc, this.heightMap, this.viewports);\r\n    }\r\n    updateViewportLines() {\r\n        this.viewportLines = [];\r\n        this.heightMap.forEachLine(this.viewport.from, this.viewport.to, this.state.doc, 0, 0, block => {\r\n            this.viewportLines.push(this.scaler.scale == 1 ? block : scaleBlock(block, this.scaler));\r\n        });\r\n    }\r\n    update(update, scrollTarget = null) {\r\n        this.state = update.state;\r\n        let prevDeco = this.stateDeco;\r\n        this.stateDeco = this.state.facet(decorations).filter(d => typeof d != \"function\");\r\n        let contentChanges = update.changedRanges;\r\n        let heightChanges = ChangedRange.extendWithRanges(contentChanges, heightRelevantDecoChanges(prevDeco, this.stateDeco, update ? update.changes : _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.ChangeSet.empty(this.state.doc.length)));\r\n        let prevHeight = this.heightMap.height;\r\n        this.heightMap = this.heightMap.applyChanges(this.stateDeco, update.startState.doc, this.heightOracle.setDoc(this.state.doc), heightChanges);\r\n        if (this.heightMap.height != prevHeight)\r\n            update.flags |= 2 /* UpdateFlag.Height */;\r\n        let viewport = heightChanges.length ? this.mapViewport(this.viewport, update.changes) : this.viewport;\r\n        if (scrollTarget && (scrollTarget.range.head < viewport.from || scrollTarget.range.head > viewport.to) ||\r\n            !this.viewportIsAppropriate(viewport))\r\n            viewport = this.getViewport(0, scrollTarget);\r\n        let updateLines = !update.changes.empty || (update.flags & 2 /* UpdateFlag.Height */) ||\r\n            viewport.from != this.viewport.from || viewport.to != this.viewport.to;\r\n        this.viewport = viewport;\r\n        this.updateForViewport();\r\n        if (updateLines)\r\n            this.updateViewportLines();\r\n        if (this.lineGaps.length || this.viewport.to - this.viewport.from > (2000 /* LG.Margin */ << 1))\r\n            this.updateLineGaps(this.ensureLineGaps(this.mapLineGaps(this.lineGaps, update.changes)));\r\n        update.flags |= this.computeVisibleRanges();\r\n        if (scrollTarget)\r\n            this.scrollTarget = scrollTarget;\r\n        if (!this.mustEnforceCursorAssoc && update.selectionSet && update.view.lineWrapping &&\r\n            update.state.selection.main.empty && update.state.selection.main.assoc &&\r\n            !update.state.facet(nativeSelectionHidden))\r\n            this.mustEnforceCursorAssoc = true;\r\n    }\r\n    measure(view) {\r\n        let dom = view.contentDOM, style = window.getComputedStyle(dom);\r\n        let oracle = this.heightOracle;\r\n        let whiteSpace = style.whiteSpace;\r\n        this.defaultTextDirection = style.direction == \"rtl\" ? Direction.RTL : Direction.LTR;\r\n        let refresh = this.heightOracle.mustRefreshForWrapping(whiteSpace);\r\n        let measureContent = refresh || this.mustMeasureContent || this.contentDOMHeight != dom.clientHeight;\r\n        this.contentDOMHeight = dom.clientHeight;\r\n        this.mustMeasureContent = false;\r\n        let result = 0, bias = 0;\r\n        // Vertical padding\r\n        let paddingTop = parseInt(style.paddingTop) || 0, paddingBottom = parseInt(style.paddingBottom) || 0;\r\n        if (this.paddingTop != paddingTop || this.paddingBottom != paddingBottom) {\r\n            this.paddingTop = paddingTop;\r\n            this.paddingBottom = paddingBottom;\r\n            result |= 8 /* UpdateFlag.Geometry */ | 2 /* UpdateFlag.Height */;\r\n        }\r\n        if (this.editorWidth != view.scrollDOM.clientWidth) {\r\n            if (oracle.lineWrapping)\r\n                measureContent = true;\r\n            this.editorWidth = view.scrollDOM.clientWidth;\r\n            result |= 8 /* UpdateFlag.Geometry */;\r\n        }\r\n        // Pixel viewport\r\n        let pixelViewport = (this.printing ? fullPixelRange : visiblePixelRange)(dom, this.paddingTop);\r\n        let dTop = pixelViewport.top - this.pixelViewport.top, dBottom = pixelViewport.bottom - this.pixelViewport.bottom;\r\n        this.pixelViewport = pixelViewport;\r\n        let inView = this.pixelViewport.bottom > this.pixelViewport.top && this.pixelViewport.right > this.pixelViewport.left;\r\n        if (inView != this.inView) {\r\n            this.inView = inView;\r\n            if (inView)\r\n                measureContent = true;\r\n        }\r\n        if (!this.inView && !this.scrollTarget)\r\n            return 0;\r\n        let contentWidth = dom.clientWidth;\r\n        if (this.contentDOMWidth != contentWidth || this.editorHeight != view.scrollDOM.clientHeight) {\r\n            this.contentDOMWidth = contentWidth;\r\n            this.editorHeight = view.scrollDOM.clientHeight;\r\n            result |= 8 /* UpdateFlag.Geometry */;\r\n        }\r\n        if (measureContent) {\r\n            let lineHeights = view.docView.measureVisibleLineHeights(this.viewport);\r\n            if (oracle.mustRefreshForHeights(lineHeights))\r\n                refresh = true;\r\n            if (refresh || oracle.lineWrapping && Math.abs(contentWidth - this.contentDOMWidth) > oracle.charWidth) {\r\n                let { lineHeight, charWidth } = view.docView.measureTextSize();\r\n                refresh = lineHeight > 0 && oracle.refresh(whiteSpace, lineHeight, charWidth, contentWidth / charWidth, lineHeights);\r\n                if (refresh) {\r\n                    view.docView.minWidth = 0;\r\n                    result |= 8 /* UpdateFlag.Geometry */;\r\n                }\r\n            }\r\n            if (dTop > 0 && dBottom > 0)\r\n                bias = Math.max(dTop, dBottom);\r\n            else if (dTop < 0 && dBottom < 0)\r\n                bias = Math.min(dTop, dBottom);\r\n            oracle.heightChanged = false;\r\n            for (let vp of this.viewports) {\r\n                let heights = vp.from == this.viewport.from ? lineHeights : view.docView.measureVisibleLineHeights(vp);\r\n                this.heightMap = (refresh ? HeightMap.empty().applyChanges(this.stateDeco, _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Text.empty, this.heightOracle, [new ChangedRange(0, 0, 0, view.state.doc.length)]) : this.heightMap).updateHeight(oracle, 0, refresh, new MeasuredHeights(vp.from, heights));\r\n            }\r\n            if (oracle.heightChanged)\r\n                result |= 2 /* UpdateFlag.Height */;\r\n        }\r\n        let viewportChange = !this.viewportIsAppropriate(this.viewport, bias) ||\r\n            this.scrollTarget && (this.scrollTarget.range.head < this.viewport.from || this.scrollTarget.range.head > this.viewport.to);\r\n        if (viewportChange)\r\n            this.viewport = this.getViewport(bias, this.scrollTarget);\r\n        this.updateForViewport();\r\n        if ((result & 2 /* UpdateFlag.Height */) || viewportChange)\r\n            this.updateViewportLines();\r\n        if (this.lineGaps.length || this.viewport.to - this.viewport.from > (2000 /* LG.Margin */ << 1))\r\n            this.updateLineGaps(this.ensureLineGaps(refresh ? [] : this.lineGaps, view));\r\n        result |= this.computeVisibleRanges();\r\n        if (this.mustEnforceCursorAssoc) {\r\n            this.mustEnforceCursorAssoc = false;\r\n            // This is done in the read stage, because moving the selection\r\n            // to a line end is going to trigger a layout anyway, so it\r\n            // can't be a pure write. It should be rare that it does any\r\n            // writing.\r\n            view.docView.enforceCursorAssoc();\r\n        }\r\n        return result;\r\n    }\r\n    get visibleTop() { return this.scaler.fromDOM(this.pixelViewport.top); }\r\n    get visibleBottom() { return this.scaler.fromDOM(this.pixelViewport.bottom); }\r\n    getViewport(bias, scrollTarget) {\r\n        // This will divide VP.Margin between the top and the\r\n        // bottom, depending on the bias (the change in viewport position\r\n        // since the last update). It'll hold a number between 0 and 1\r\n        let marginTop = 0.5 - Math.max(-0.5, Math.min(0.5, bias / 1000 /* VP.Margin */ / 2));\r\n        let map = this.heightMap, doc = this.state.doc, { visibleTop, visibleBottom } = this;\r\n        let viewport = new Viewport(map.lineAt(visibleTop - marginTop * 1000 /* VP.Margin */, QueryType.ByHeight, doc, 0, 0).from, map.lineAt(visibleBottom + (1 - marginTop) * 1000 /* VP.Margin */, QueryType.ByHeight, doc, 0, 0).to);\r\n        // If scrollTarget is given, make sure the viewport includes that position\r\n        if (scrollTarget) {\r\n            let { head } = scrollTarget.range;\r\n            if (head < viewport.from || head > viewport.to) {\r\n                let viewHeight = Math.min(this.editorHeight, this.pixelViewport.bottom - this.pixelViewport.top);\r\n                let block = map.lineAt(head, QueryType.ByPos, doc, 0, 0), topPos;\r\n                if (scrollTarget.y == \"center\")\r\n                    topPos = (block.top + block.bottom) / 2 - viewHeight / 2;\r\n                else if (scrollTarget.y == \"start\" || scrollTarget.y == \"nearest\" && head < viewport.from)\r\n                    topPos = block.top;\r\n                else\r\n                    topPos = block.bottom - viewHeight;\r\n                viewport = new Viewport(map.lineAt(topPos - 1000 /* VP.Margin */ / 2, QueryType.ByHeight, doc, 0, 0).from, map.lineAt(topPos + viewHeight + 1000 /* VP.Margin */ / 2, QueryType.ByHeight, doc, 0, 0).to);\r\n            }\r\n        }\r\n        return viewport;\r\n    }\r\n    mapViewport(viewport, changes) {\r\n        let from = changes.mapPos(viewport.from, -1), to = changes.mapPos(viewport.to, 1);\r\n        return new Viewport(this.heightMap.lineAt(from, QueryType.ByPos, this.state.doc, 0, 0).from, this.heightMap.lineAt(to, QueryType.ByPos, this.state.doc, 0, 0).to);\r\n    }\r\n    // Checks if a given viewport covers the visible part of the\r\n    // document and not too much beyond that.\r\n    viewportIsAppropriate({ from, to }, bias = 0) {\r\n        if (!this.inView)\r\n            return true;\r\n        let { top } = this.heightMap.lineAt(from, QueryType.ByPos, this.state.doc, 0, 0);\r\n        let { bottom } = this.heightMap.lineAt(to, QueryType.ByPos, this.state.doc, 0, 0);\r\n        let { visibleTop, visibleBottom } = this;\r\n        return (from == 0 || top <= visibleTop - Math.max(10 /* VP.MinCoverMargin */, Math.min(-bias, 250 /* VP.MaxCoverMargin */))) &&\r\n            (to == this.state.doc.length ||\r\n                bottom >= visibleBottom + Math.max(10 /* VP.MinCoverMargin */, Math.min(bias, 250 /* VP.MaxCoverMargin */))) &&\r\n            (top > visibleTop - 2 * 1000 /* VP.Margin */ && bottom < visibleBottom + 2 * 1000 /* VP.Margin */);\r\n    }\r\n    mapLineGaps(gaps, changes) {\r\n        if (!gaps.length || changes.empty)\r\n            return gaps;\r\n        let mapped = [];\r\n        for (let gap of gaps)\r\n            if (!changes.touchesRange(gap.from, gap.to))\r\n                mapped.push(new LineGap(changes.mapPos(gap.from), changes.mapPos(gap.to), gap.size));\r\n        return mapped;\r\n    }\r\n    // Computes positions in the viewport where the start or end of a\r\n    // line should be hidden, trying to reuse existing line gaps when\r\n    // appropriate to avoid unneccesary redraws.\r\n    // Uses crude character-counting for the positioning and sizing,\r\n    // since actual DOM coordinates aren't always available and\r\n    // predictable. Relies on generous margins (see LG.Margin) to hide\r\n    // the artifacts this might produce from the user.\r\n    ensureLineGaps(current, mayMeasure) {\r\n        let wrapping = this.heightOracle.lineWrapping;\r\n        let margin = wrapping ? 10000 /* LG.MarginWrap */ : 2000 /* LG.Margin */, halfMargin = margin >> 1, doubleMargin = margin << 1;\r\n        // The non-wrapping logic won't work at all in predominantly right-to-left text.\r\n        if (this.defaultTextDirection != Direction.LTR && !wrapping)\r\n            return [];\r\n        let gaps = [];\r\n        let addGap = (from, to, line, structure) => {\r\n            if (to - from < halfMargin)\r\n                return;\r\n            let sel = this.state.selection.main, avoid = [sel.from];\r\n            if (!sel.empty)\r\n                avoid.push(sel.to);\r\n            for (let pos of avoid) {\r\n                if (pos > from && pos < to) {\r\n                    addGap(from, pos - 10 /* LG.SelectionMargin */, line, structure);\r\n                    addGap(pos + 10 /* LG.SelectionMargin */, to, line, structure);\r\n                    return;\r\n                }\r\n            }\r\n            let gap = find(current, gap => gap.from >= line.from && gap.to <= line.to &&\r\n                Math.abs(gap.from - from) < halfMargin && Math.abs(gap.to - to) < halfMargin &&\r\n                !avoid.some(pos => gap.from < pos && gap.to > pos));\r\n            if (!gap) {\r\n                // When scrolling down, snap gap ends to line starts to avoid shifts in wrapping\r\n                if (to < line.to && mayMeasure && wrapping &&\r\n                    mayMeasure.visibleRanges.some(r => r.from <= to && r.to >= to)) {\r\n                    let lineStart = mayMeasure.moveToLineBoundary(_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.cursor(to), false, true).head;\r\n                    if (lineStart > from)\r\n                        to = lineStart;\r\n                }\r\n                gap = new LineGap(from, to, this.gapSize(line, from, to, structure));\r\n            }\r\n            gaps.push(gap);\r\n        };\r\n        for (let line of this.viewportLines) {\r\n            if (line.length < doubleMargin)\r\n                continue;\r\n            let structure = lineStructure(line.from, line.to, this.stateDeco);\r\n            if (structure.total < doubleMargin)\r\n                continue;\r\n            let target = this.scrollTarget ? this.scrollTarget.range.head : null;\r\n            let viewFrom, viewTo;\r\n            if (wrapping) {\r\n                let marginHeight = (margin / this.heightOracle.lineLength) * this.heightOracle.lineHeight;\r\n                let top, bot;\r\n                if (target != null) {\r\n                    let targetFrac = findFraction(structure, target);\r\n                    let spaceFrac = ((this.visibleBottom - this.visibleTop) / 2 + marginHeight) / line.height;\r\n                    top = targetFrac - spaceFrac;\r\n                    bot = targetFrac + spaceFrac;\r\n                }\r\n                else {\r\n                    top = (this.visibleTop - line.top - marginHeight) / line.height;\r\n                    bot = (this.visibleBottom - line.top + marginHeight) / line.height;\r\n                }\r\n                viewFrom = findPosition(structure, top);\r\n                viewTo = findPosition(structure, bot);\r\n            }\r\n            else {\r\n                let totalWidth = structure.total * this.heightOracle.charWidth;\r\n                let marginWidth = margin * this.heightOracle.charWidth;\r\n                let left, right;\r\n                if (target != null) {\r\n                    let targetFrac = findFraction(structure, target);\r\n                    let spaceFrac = ((this.pixelViewport.right - this.pixelViewport.left) / 2 + marginWidth) / totalWidth;\r\n                    left = targetFrac - spaceFrac;\r\n                    right = targetFrac + spaceFrac;\r\n                }\r\n                else {\r\n                    left = (this.pixelViewport.left - marginWidth) / totalWidth;\r\n                    right = (this.pixelViewport.right + marginWidth) / totalWidth;\r\n                }\r\n                viewFrom = findPosition(structure, left);\r\n                viewTo = findPosition(structure, right);\r\n            }\r\n            if (viewFrom > line.from)\r\n                addGap(line.from, viewFrom, line, structure);\r\n            if (viewTo < line.to)\r\n                addGap(viewTo, line.to, line, structure);\r\n        }\r\n        return gaps;\r\n    }\r\n    gapSize(line, from, to, structure) {\r\n        let fraction = findFraction(structure, to) - findFraction(structure, from);\r\n        if (this.heightOracle.lineWrapping) {\r\n            return line.height * fraction;\r\n        }\r\n        else {\r\n            return structure.total * this.heightOracle.charWidth * fraction;\r\n        }\r\n    }\r\n    updateLineGaps(gaps) {\r\n        if (!LineGap.same(gaps, this.lineGaps)) {\r\n            this.lineGaps = gaps;\r\n            this.lineGapDeco = Decoration.set(gaps.map(gap => gap.draw(this.heightOracle.lineWrapping)));\r\n        }\r\n    }\r\n    computeVisibleRanges() {\r\n        let deco = this.stateDeco;\r\n        if (this.lineGaps.length)\r\n            deco = deco.concat(this.lineGapDeco);\r\n        let ranges = [];\r\n        _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.RangeSet.spans(deco, this.viewport.from, this.viewport.to, {\r\n            span(from, to) { ranges.push({ from, to }); },\r\n            point() { }\r\n        }, 20);\r\n        let changed = ranges.length != this.visibleRanges.length ||\r\n            this.visibleRanges.some((r, i) => r.from != ranges[i].from || r.to != ranges[i].to);\r\n        this.visibleRanges = ranges;\r\n        return changed ? 4 /* UpdateFlag.Viewport */ : 0;\r\n    }\r\n    lineBlockAt(pos) {\r\n        return (pos >= this.viewport.from && pos <= this.viewport.to && this.viewportLines.find(b => b.from <= pos && b.to >= pos)) ||\r\n            scaleBlock(this.heightMap.lineAt(pos, QueryType.ByPos, this.state.doc, 0, 0), this.scaler);\r\n    }\r\n    lineBlockAtHeight(height) {\r\n        return scaleBlock(this.heightMap.lineAt(this.scaler.fromDOM(height), QueryType.ByHeight, this.state.doc, 0, 0), this.scaler);\r\n    }\r\n    elementAtHeight(height) {\r\n        return scaleBlock(this.heightMap.blockAt(this.scaler.fromDOM(height), this.state.doc, 0, 0), this.scaler);\r\n    }\r\n    get docHeight() {\r\n        return this.scaler.toDOM(this.heightMap.height);\r\n    }\r\n    get contentHeight() {\r\n        return this.docHeight + this.paddingTop + this.paddingBottom;\r\n    }\r\n}\r\nclass Viewport {\r\n    constructor(from, to) {\r\n        this.from = from;\r\n        this.to = to;\r\n    }\r\n}\r\nfunction lineStructure(from, to, stateDeco) {\r\n    let ranges = [], pos = from, total = 0;\r\n    _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.RangeSet.spans(stateDeco, from, to, {\r\n        span() { },\r\n        point(from, to) {\r\n            if (from > pos) {\r\n                ranges.push({ from: pos, to: from });\r\n                total += from - pos;\r\n            }\r\n            pos = to;\r\n        }\r\n    }, 20); // We're only interested in collapsed ranges of a significant size\r\n    if (pos < to) {\r\n        ranges.push({ from: pos, to });\r\n        total += to - pos;\r\n    }\r\n    return { total, ranges };\r\n}\r\nfunction findPosition({ total, ranges }, ratio) {\r\n    if (ratio <= 0)\r\n        return ranges[0].from;\r\n    if (ratio >= 1)\r\n        return ranges[ranges.length - 1].to;\r\n    let dist = Math.floor(total * ratio);\r\n    for (let i = 0;; i++) {\r\n        let { from, to } = ranges[i], size = to - from;\r\n        if (dist <= size)\r\n            return from + dist;\r\n        dist -= size;\r\n    }\r\n}\r\nfunction findFraction(structure, pos) {\r\n    let counted = 0;\r\n    for (let { from, to } of structure.ranges) {\r\n        if (pos <= to) {\r\n            counted += pos - from;\r\n            break;\r\n        }\r\n        counted += to - from;\r\n    }\r\n    return counted / structure.total;\r\n}\r\nfunction find(array, f) {\r\n    for (let val of array)\r\n        if (f(val))\r\n            return val;\r\n    return undefined;\r\n}\r\n// Don't scale when the document height is within the range of what\r\n// the DOM can handle.\r\nconst IdScaler = {\r\n    toDOM(n) { return n; },\r\n    fromDOM(n) { return n; },\r\n    scale: 1\r\n};\r\n// When the height is too big (> VP.MaxDOMHeight), scale down the\r\n// regions outside the viewports so that the total height is\r\n// VP.MaxDOMHeight.\r\nclass BigScaler {\r\n    constructor(doc, heightMap, viewports) {\r\n        let vpHeight = 0, base = 0, domBase = 0;\r\n        this.viewports = viewports.map(({ from, to }) => {\r\n            let top = heightMap.lineAt(from, QueryType.ByPos, doc, 0, 0).top;\r\n            let bottom = heightMap.lineAt(to, QueryType.ByPos, doc, 0, 0).bottom;\r\n            vpHeight += bottom - top;\r\n            return { from, to, top, bottom, domTop: 0, domBottom: 0 };\r\n        });\r\n        this.scale = (7000000 /* VP.MaxDOMHeight */ - vpHeight) / (heightMap.height - vpHeight);\r\n        for (let obj of this.viewports) {\r\n            obj.domTop = domBase + (obj.top - base) * this.scale;\r\n            domBase = obj.domBottom = obj.domTop + (obj.bottom - obj.top);\r\n            base = obj.bottom;\r\n        }\r\n    }\r\n    toDOM(n) {\r\n        for (let i = 0, base = 0, domBase = 0;; i++) {\r\n            let vp = i < this.viewports.length ? this.viewports[i] : null;\r\n            if (!vp || n < vp.top)\r\n                return domBase + (n - base) * this.scale;\r\n            if (n <= vp.bottom)\r\n                return vp.domTop + (n - vp.top);\r\n            base = vp.bottom;\r\n            domBase = vp.domBottom;\r\n        }\r\n    }\r\n    fromDOM(n) {\r\n        for (let i = 0, base = 0, domBase = 0;; i++) {\r\n            let vp = i < this.viewports.length ? this.viewports[i] : null;\r\n            if (!vp || n < vp.domTop)\r\n                return base + (n - domBase) / this.scale;\r\n            if (n <= vp.domBottom)\r\n                return vp.top + (n - vp.domTop);\r\n            base = vp.bottom;\r\n            domBase = vp.domBottom;\r\n        }\r\n    }\r\n}\r\nfunction scaleBlock(block, scaler) {\r\n    if (scaler.scale == 1)\r\n        return block;\r\n    let bTop = scaler.toDOM(block.top), bBottom = scaler.toDOM(block.bottom);\r\n    return new BlockInfo(block.from, block.length, bTop, bBottom - bTop, Array.isArray(block.type) ? block.type.map(b => scaleBlock(b, scaler)) : block.type);\r\n}\r\n\r\nconst theme = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define({ combine: strs => strs.join(\" \") });\r\nconst darkTheme = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define({ combine: values => values.indexOf(true) > -1 });\r\nconst baseThemeID = /*@__PURE__*/style_mod__WEBPACK_IMPORTED_MODULE_0__.StyleModule.newName(), baseLightID = /*@__PURE__*/style_mod__WEBPACK_IMPORTED_MODULE_0__.StyleModule.newName(), baseDarkID = /*@__PURE__*/style_mod__WEBPACK_IMPORTED_MODULE_0__.StyleModule.newName();\r\nconst lightDarkIDs = { \"&light\": \".\" + baseLightID, \"&dark\": \".\" + baseDarkID };\r\nfunction buildTheme(main, spec, scopes) {\r\n    return new style_mod__WEBPACK_IMPORTED_MODULE_0__.StyleModule(spec, {\r\n        finish(sel) {\r\n            return /&/.test(sel) ? sel.replace(/&\\w*/, m => {\r\n                if (m == \"&\")\r\n                    return main;\r\n                if (!scopes || !scopes[m])\r\n                    throw new RangeError(`Unsupported selector: ${m}`);\r\n                return scopes[m];\r\n            }) : main + \" \" + sel;\r\n        }\r\n    });\r\n}\r\nconst baseTheme$1 = /*@__PURE__*/buildTheme(\".\" + baseThemeID, {\r\n    \"&\": {\r\n        position: \"relative !important\",\r\n        boxSizing: \"border-box\",\r\n        \"&.cm-focused\": {\r\n            // Provide a simple default outline to make sure a focused\r\n            // editor is visually distinct. Can't leave the default behavior\r\n            // because that will apply to the content element, which is\r\n            // inside the scrollable container and doesn't include the\r\n            // gutters. We also can't use an 'auto' outline, since those\r\n            // are, for some reason, drawn behind the element content, which\r\n            // will cause things like the active line background to cover\r\n            // the outline (#297).\r\n            outline: \"1px dotted #212121\"\r\n        },\r\n        display: \"flex !important\",\r\n        flexDirection: \"column\"\r\n    },\r\n    \".cm-scroller\": {\r\n        display: \"flex !important\",\r\n        alignItems: \"flex-start !important\",\r\n        fontFamily: \"monospace\",\r\n        lineHeight: 1.4,\r\n        height: \"100%\",\r\n        overflowX: \"auto\",\r\n        position: \"relative\",\r\n        zIndex: 0\r\n    },\r\n    \".cm-content\": {\r\n        margin: 0,\r\n        flexGrow: 2,\r\n        flexShrink: 0,\r\n        display: \"block\",\r\n        whiteSpace: \"pre\",\r\n        wordWrap: \"normal\",\r\n        boxSizing: \"border-box\",\r\n        padding: \"4px 0\",\r\n        outline: \"none\",\r\n        \"&[contenteditable=true]\": {\r\n            WebkitUserModify: \"read-write-plaintext-only\",\r\n        }\r\n    },\r\n    \".cm-lineWrapping\": {\r\n        whiteSpace_fallback: \"pre-wrap\",\r\n        whiteSpace: \"break-spaces\",\r\n        wordBreak: \"break-word\",\r\n        overflowWrap: \"anywhere\",\r\n        flexShrink: 1\r\n    },\r\n    \"&light .cm-content\": { caretColor: \"black\" },\r\n    \"&dark .cm-content\": { caretColor: \"white\" },\r\n    \".cm-line\": {\r\n        display: \"block\",\r\n        padding: \"0 2px 0 6px\"\r\n    },\r\n    \".cm-layer\": {\r\n        contain: \"size style\",\r\n        \"& > *\": {\r\n            position: \"absolute\"\r\n        }\r\n    },\r\n    \"&light .cm-selectionBackground\": {\r\n        background: \"#d9d9d9\"\r\n    },\r\n    \"&dark .cm-selectionBackground\": {\r\n        background: \"#222\"\r\n    },\r\n    \"&light.cm-focused .cm-selectionBackground\": {\r\n        background: \"#d7d4f0\"\r\n    },\r\n    \"&dark.cm-focused .cm-selectionBackground\": {\r\n        background: \"#233\"\r\n    },\r\n    \".cm-cursorLayer\": {\r\n        pointerEvents: \"none\"\r\n    },\r\n    \"&.cm-focused .cm-cursorLayer\": {\r\n        animation: \"steps(1) cm-blink 1.2s infinite\"\r\n    },\r\n    // Two animations defined so that we can switch between them to\r\n    // restart the animation without forcing another style\r\n    // recomputation.\r\n    \"@keyframes cm-blink\": { \"0%\": {}, \"50%\": { opacity: 0 }, \"100%\": {} },\r\n    \"@keyframes cm-blink2\": { \"0%\": {}, \"50%\": { opacity: 0 }, \"100%\": {} },\r\n    \".cm-cursor, .cm-dropCursor\": {\r\n        borderLeft: \"1.2px solid black\",\r\n        marginLeft: \"-0.6px\",\r\n        pointerEvents: \"none\",\r\n    },\r\n    \".cm-cursor\": {\r\n        display: \"none\"\r\n    },\r\n    \"&dark .cm-cursor\": {\r\n        borderLeftColor: \"#444\"\r\n    },\r\n    \"&.cm-focused .cm-cursor\": {\r\n        display: \"block\"\r\n    },\r\n    \"&light .cm-activeLine\": { backgroundColor: \"#cceeff44\" },\r\n    \"&dark .cm-activeLine\": { backgroundColor: \"#99eeff33\" },\r\n    \"&light .cm-specialChar\": { color: \"red\" },\r\n    \"&dark .cm-specialChar\": { color: \"#f78\" },\r\n    \".cm-gutters\": {\r\n        flexShrink: 0,\r\n        display: \"flex\",\r\n        height: \"100%\",\r\n        boxSizing: \"border-box\",\r\n        left: 0,\r\n        zIndex: 200\r\n    },\r\n    \"&light .cm-gutters\": {\r\n        backgroundColor: \"#f5f5f5\",\r\n        color: \"#6c6c6c\",\r\n        borderRight: \"1px solid #ddd\"\r\n    },\r\n    \"&dark .cm-gutters\": {\r\n        backgroundColor: \"#333338\",\r\n        color: \"#ccc\"\r\n    },\r\n    \".cm-gutter\": {\r\n        display: \"flex !important\",\r\n        flexDirection: \"column\",\r\n        flexShrink: 0,\r\n        boxSizing: \"border-box\",\r\n        minHeight: \"100%\",\r\n        overflow: \"hidden\"\r\n    },\r\n    \".cm-gutterElement\": {\r\n        boxSizing: \"border-box\"\r\n    },\r\n    \".cm-lineNumbers .cm-gutterElement\": {\r\n        padding: \"0 3px 0 5px\",\r\n        minWidth: \"20px\",\r\n        textAlign: \"right\",\r\n        whiteSpace: \"nowrap\"\r\n    },\r\n    \"&light .cm-activeLineGutter\": {\r\n        backgroundColor: \"#e2f2ff\"\r\n    },\r\n    \"&dark .cm-activeLineGutter\": {\r\n        backgroundColor: \"#222227\"\r\n    },\r\n    \".cm-panels\": {\r\n        boxSizing: \"border-box\",\r\n        position: \"sticky\",\r\n        left: 0,\r\n        right: 0\r\n    },\r\n    \"&light .cm-panels\": {\r\n        backgroundColor: \"#f5f5f5\",\r\n        color: \"black\"\r\n    },\r\n    \"&light .cm-panels-top\": {\r\n        borderBottom: \"1px solid #ddd\"\r\n    },\r\n    \"&light .cm-panels-bottom\": {\r\n        borderTop: \"1px solid #ddd\"\r\n    },\r\n    \"&dark .cm-panels\": {\r\n        backgroundColor: \"#333338\",\r\n        color: \"white\"\r\n    },\r\n    \".cm-tab\": {\r\n        display: \"inline-block\",\r\n        overflow: \"hidden\",\r\n        verticalAlign: \"bottom\"\r\n    },\r\n    \".cm-widgetBuffer\": {\r\n        verticalAlign: \"text-top\",\r\n        height: \"1em\",\r\n        width: 0,\r\n        display: \"inline\"\r\n    },\r\n    \".cm-placeholder\": {\r\n        color: \"#888\",\r\n        display: \"inline-block\",\r\n        verticalAlign: \"top\",\r\n    },\r\n    \".cm-highlightSpace:before\": {\r\n        content: \"attr(data-display)\",\r\n        position: \"absolute\",\r\n        pointerEvents: \"none\",\r\n        color: \"#888\"\r\n    },\r\n    \".cm-highlightTab\": {\r\n        backgroundImage: `url('data:image/svg+xml,<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"200\" height=\"20\"><path stroke=\"%23888\" stroke-width=\"1\" fill=\"none\" d=\"M1 10H196L190 5M190 15L196 10M197 4L197 16\"/></svg>')`,\r\n        backgroundSize: \"auto 100%\",\r\n        backgroundPosition: \"right 90%\",\r\n        backgroundRepeat: \"no-repeat\"\r\n    },\r\n    \".cm-trailingSpace\": {\r\n        backgroundColor: \"#ff332255\"\r\n    },\r\n    \".cm-button\": {\r\n        verticalAlign: \"middle\",\r\n        color: \"inherit\",\r\n        fontSize: \"70%\",\r\n        padding: \".2em 1em\",\r\n        borderRadius: \"1px\"\r\n    },\r\n    \"&light .cm-button\": {\r\n        backgroundImage: \"linear-gradient(#eff1f5, #d9d9df)\",\r\n        border: \"1px solid #888\",\r\n        \"&:active\": {\r\n            backgroundImage: \"linear-gradient(#b4b4b4, #d0d3d6)\"\r\n        }\r\n    },\r\n    \"&dark .cm-button\": {\r\n        backgroundImage: \"linear-gradient(#393939, #111)\",\r\n        border: \"1px solid #888\",\r\n        \"&:active\": {\r\n            backgroundImage: \"linear-gradient(#111, #333)\"\r\n        }\r\n    },\r\n    \".cm-textfield\": {\r\n        verticalAlign: \"middle\",\r\n        color: \"inherit\",\r\n        fontSize: \"70%\",\r\n        border: \"1px solid silver\",\r\n        padding: \".2em .5em\"\r\n    },\r\n    \"&light .cm-textfield\": {\r\n        backgroundColor: \"white\"\r\n    },\r\n    \"&dark .cm-textfield\": {\r\n        border: \"1px solid #555\",\r\n        backgroundColor: \"inherit\"\r\n    }\r\n}, lightDarkIDs);\r\n\r\nclass DOMChange {\r\n    constructor(view, start, end, typeOver) {\r\n        this.typeOver = typeOver;\r\n        this.bounds = null;\r\n        this.text = \"\";\r\n        let { impreciseHead: iHead, impreciseAnchor: iAnchor } = view.docView;\r\n        if (view.state.readOnly && start > -1) {\r\n            // Ignore changes when the editor is read-only\r\n            this.newSel = null;\r\n        }\r\n        else if (start > -1 && (this.bounds = view.docView.domBoundsAround(start, end, 0))) {\r\n            let selPoints = iHead || iAnchor ? [] : selectionPoints(view);\r\n            let reader = new DOMReader(selPoints, view.state);\r\n            reader.readRange(this.bounds.startDOM, this.bounds.endDOM);\r\n            this.text = reader.text;\r\n            this.newSel = selectionFromPoints(selPoints, this.bounds.from);\r\n        }\r\n        else {\r\n            let domSel = view.observer.selectionRange;\r\n            let head = iHead && iHead.node == domSel.focusNode && iHead.offset == domSel.focusOffset ||\r\n                !contains(view.contentDOM, domSel.focusNode)\r\n                ? view.state.selection.main.head\r\n                : view.docView.posFromDOM(domSel.focusNode, domSel.focusOffset);\r\n            let anchor = iAnchor && iAnchor.node == domSel.anchorNode && iAnchor.offset == domSel.anchorOffset ||\r\n                !contains(view.contentDOM, domSel.anchorNode)\r\n                ? view.state.selection.main.anchor\r\n                : view.docView.posFromDOM(domSel.anchorNode, domSel.anchorOffset);\r\n            this.newSel = _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.single(anchor, head);\r\n        }\r\n    }\r\n}\r\nfunction applyDOMChange(view, domChange) {\r\n    let change;\r\n    let { newSel } = domChange, sel = view.state.selection.main;\r\n    if (domChange.bounds) {\r\n        let { from, to } = domChange.bounds;\r\n        let preferredPos = sel.from, preferredSide = null;\r\n        // Prefer anchoring to end when Backspace is pressed (or, on\r\n        // Android, when something was deleted)\r\n        if (view.inputState.lastKeyCode === 8 && view.inputState.lastKeyTime > Date.now() - 100 ||\r\n            browser.android && domChange.text.length < to - from) {\r\n            preferredPos = sel.to;\r\n            preferredSide = \"end\";\r\n        }\r\n        let diff = findDiff(view.state.doc.sliceString(from, to, LineBreakPlaceholder), domChange.text, preferredPos - from, preferredSide);\r\n        if (diff) {\r\n            // Chrome inserts two newlines when pressing shift-enter at the\r\n            // end of a line. DomChange drops one of those.\r\n            if (browser.chrome && view.inputState.lastKeyCode == 13 &&\r\n                diff.toB == diff.from + 2 && domChange.text.slice(diff.from, diff.toB) == LineBreakPlaceholder + LineBreakPlaceholder)\r\n                diff.toB--;\r\n            change = { from: from + diff.from, to: from + diff.toA,\r\n                insert: _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Text.of(domChange.text.slice(diff.from, diff.toB).split(LineBreakPlaceholder)) };\r\n        }\r\n    }\r\n    else if (newSel && (!view.hasFocus && view.state.facet(editable) || newSel.main.eq(sel))) {\r\n        newSel = null;\r\n    }\r\n    if (!change && !newSel)\r\n        return false;\r\n    if (!change && domChange.typeOver && !sel.empty && newSel && newSel.main.empty) {\r\n        // Heuristic to notice typing over a selected character\r\n        change = { from: sel.from, to: sel.to, insert: view.state.doc.slice(sel.from, sel.to) };\r\n    }\r\n    else if (change && change.from >= sel.from && change.to <= sel.to &&\r\n        (change.from != sel.from || change.to != sel.to) &&\r\n        (sel.to - sel.from) - (change.to - change.from) <= 4) {\r\n        // If the change is inside the selection and covers most of it,\r\n        // assume it is a selection replace (with identical characters at\r\n        // the start/end not included in the diff)\r\n        change = {\r\n            from: sel.from, to: sel.to,\r\n            insert: view.state.doc.slice(sel.from, change.from).append(change.insert).append(view.state.doc.slice(change.to, sel.to))\r\n        };\r\n    }\r\n    else if ((browser.mac || browser.android) && change && change.from == change.to && change.from == sel.head - 1 &&\r\n        /^\\. ?$/.test(change.insert.toString())) {\r\n        // Detect insert-period-on-double-space Mac and Android behavior,\r\n        // and transform it into a regular space insert.\r\n        if (newSel && change.insert.length == 2)\r\n            newSel = _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.single(newSel.main.anchor - 1, newSel.main.head - 1);\r\n        change = { from: sel.from, to: sel.to, insert: _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Text.of([\" \"]) };\r\n    }\r\n    else if (browser.chrome && change && change.from == change.to && change.from == sel.head &&\r\n        change.insert.toString() == \"\\n \" && view.lineWrapping) {\r\n        // In Chrome, if you insert a space at the start of a wrapped\r\n        // line, it will actually insert a newline and a space, causing a\r\n        // bogus new line to be created in CodeMirror (#968)\r\n        if (newSel)\r\n            newSel = _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.single(newSel.main.anchor - 1, newSel.main.head - 1);\r\n        change = { from: sel.from, to: sel.to, insert: _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Text.of([\" \"]) };\r\n    }\r\n    if (change) {\r\n        let startState = view.state;\r\n        if (browser.ios && view.inputState.flushIOSKey(view))\r\n            return true;\r\n        // Android browsers don't fire reasonable key events for enter,\r\n        // backspace, or delete. So this detects changes that look like\r\n        // they're caused by those keys, and reinterprets them as key\r\n        // events. (Some of these keys are also handled by beforeinput\r\n        // events and the pendingAndroidKey mechanism, but that's not\r\n        // reliable in all situations.)\r\n        if (browser.android &&\r\n            ((change.from == sel.from && change.to == sel.to &&\r\n                change.insert.length == 1 && change.insert.lines == 2 &&\r\n                dispatchKey(view.contentDOM, \"Enter\", 13)) ||\r\n                (change.from == sel.from - 1 && change.to == sel.to && change.insert.length == 0 &&\r\n                    dispatchKey(view.contentDOM, \"Backspace\", 8)) ||\r\n                (change.from == sel.from && change.to == sel.to + 1 && change.insert.length == 0 &&\r\n                    dispatchKey(view.contentDOM, \"Delete\", 46))))\r\n            return true;\r\n        let text = change.insert.toString();\r\n        if (view.state.facet(inputHandler).some(h => h(view, change.from, change.to, text)))\r\n            return true;\r\n        if (view.inputState.composing >= 0)\r\n            view.inputState.composing++;\r\n        let tr;\r\n        if (change.from >= sel.from && change.to <= sel.to && change.to - change.from >= (sel.to - sel.from) / 3 &&\r\n            (!newSel || newSel.main.empty && newSel.main.from == change.from + change.insert.length) &&\r\n            view.inputState.composing < 0) {\r\n            let before = sel.from < change.from ? startState.sliceDoc(sel.from, change.from) : \"\";\r\n            let after = sel.to > change.to ? startState.sliceDoc(change.to, sel.to) : \"\";\r\n            tr = startState.replaceSelection(view.state.toText(before + change.insert.sliceString(0, undefined, view.state.lineBreak) + after));\r\n        }\r\n        else {\r\n            let changes = startState.changes(change);\r\n            let mainSel = newSel && !startState.selection.main.eq(newSel.main) && newSel.main.to <= changes.newLength\r\n                ? newSel.main : undefined;\r\n            // Try to apply a composition change to all cursors\r\n            if (startState.selection.ranges.length > 1 && view.inputState.composing >= 0 &&\r\n                change.to <= sel.to && change.to >= sel.to - 10) {\r\n                let replaced = view.state.sliceDoc(change.from, change.to);\r\n                let compositionRange = compositionSurroundingNode(view) || view.state.doc.lineAt(sel.head);\r\n                let offset = sel.to - change.to, size = sel.to - sel.from;\r\n                tr = startState.changeByRange(range => {\r\n                    if (range.from == sel.from && range.to == sel.to)\r\n                        return { changes, range: mainSel || range.map(changes) };\r\n                    let to = range.to - offset, from = to - replaced.length;\r\n                    if (range.to - range.from != size || view.state.sliceDoc(from, to) != replaced ||\r\n                        // Unfortunately, there's no way to make multiple\r\n                        // changes in the same node work without aborting\r\n                        // composition, so cursors in the composition range are\r\n                        // ignored.\r\n                        compositionRange && range.to >= compositionRange.from && range.from <= compositionRange.to)\r\n                        return { range };\r\n                    let rangeChanges = startState.changes({ from, to, insert: change.insert }), selOff = range.to - sel.to;\r\n                    return {\r\n                        changes: rangeChanges,\r\n                        range: !mainSel ? range.map(rangeChanges) :\r\n                            _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.range(Math.max(0, mainSel.anchor + selOff), Math.max(0, mainSel.head + selOff))\r\n                    };\r\n                });\r\n            }\r\n            else {\r\n                tr = {\r\n                    changes,\r\n                    selection: mainSel && startState.selection.replaceRange(mainSel)\r\n                };\r\n            }\r\n        }\r\n        let userEvent = \"input.type\";\r\n        if (view.composing) {\r\n            userEvent += \".compose\";\r\n            if (view.inputState.compositionFirstChange) {\r\n                userEvent += \".start\";\r\n                view.inputState.compositionFirstChange = false;\r\n            }\r\n        }\r\n        view.dispatch(tr, { scrollIntoView: true, userEvent });\r\n        return true;\r\n    }\r\n    else if (newSel && !newSel.main.eq(sel)) {\r\n        let scrollIntoView = false, userEvent = \"select\";\r\n        if (view.inputState.lastSelectionTime > Date.now() - 50) {\r\n            if (view.inputState.lastSelectionOrigin == \"select\")\r\n                scrollIntoView = true;\r\n            userEvent = view.inputState.lastSelectionOrigin;\r\n        }\r\n        view.dispatch({ selection: newSel, scrollIntoView, userEvent });\r\n        return true;\r\n    }\r\n    else {\r\n        return false;\r\n    }\r\n}\r\nfunction findDiff(a, b, preferredPos, preferredSide) {\r\n    let minLen = Math.min(a.length, b.length);\r\n    let from = 0;\r\n    while (from < minLen && a.charCodeAt(from) == b.charCodeAt(from))\r\n        from++;\r\n    if (from == minLen && a.length == b.length)\r\n        return null;\r\n    let toA = a.length, toB = b.length;\r\n    while (toA > 0 && toB > 0 && a.charCodeAt(toA - 1) == b.charCodeAt(toB - 1)) {\r\n        toA--;\r\n        toB--;\r\n    }\r\n    if (preferredSide == \"end\") {\r\n        let adjust = Math.max(0, from - Math.min(toA, toB));\r\n        preferredPos -= toA + adjust - from;\r\n    }\r\n    if (toA < from && a.length < b.length) {\r\n        let move = preferredPos <= from && preferredPos >= toA ? from - preferredPos : 0;\r\n        from -= move;\r\n        toB = from + (toB - toA);\r\n        toA = from;\r\n    }\r\n    else if (toB < from) {\r\n        let move = preferredPos <= from && preferredPos >= toB ? from - preferredPos : 0;\r\n        from -= move;\r\n        toA = from + (toA - toB);\r\n        toB = from;\r\n    }\r\n    return { from, toA, toB };\r\n}\r\nfunction selectionPoints(view) {\r\n    let result = [];\r\n    if (view.root.activeElement != view.contentDOM)\r\n        return result;\r\n    let { anchorNode, anchorOffset, focusNode, focusOffset } = view.observer.selectionRange;\r\n    if (anchorNode) {\r\n        result.push(new DOMPoint(anchorNode, anchorOffset));\r\n        if (focusNode != anchorNode || focusOffset != anchorOffset)\r\n            result.push(new DOMPoint(focusNode, focusOffset));\r\n    }\r\n    return result;\r\n}\r\nfunction selectionFromPoints(points, base) {\r\n    if (points.length == 0)\r\n        return null;\r\n    let anchor = points[0].pos, head = points.length == 2 ? points[1].pos : anchor;\r\n    return anchor > -1 && head > -1 ? _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.single(anchor + base, head + base) : null;\r\n}\r\n\r\nconst observeOptions = {\r\n    childList: true,\r\n    characterData: true,\r\n    subtree: true,\r\n    attributes: true,\r\n    characterDataOldValue: true\r\n};\r\n// IE11 has very broken mutation observers, so we also listen to\r\n// DOMCharacterDataModified there\r\nconst useCharData = browser.ie && browser.ie_version <= 11;\r\nclass DOMObserver {\r\n    constructor(view) {\r\n        this.view = view;\r\n        this.active = false;\r\n        // The known selection. Kept in our own object, as opposed to just\r\n        // directly accessing the selection because:\r\n        //  - Safari doesn't report the right selection in shadow DOM\r\n        //  - Reading from the selection forces a DOM layout\r\n        //  - This way, we can ignore selectionchange events if we have\r\n        //    already seen the 'new' selection\r\n        this.selectionRange = new DOMSelectionState;\r\n        // Set when a selection change is detected, cleared on flush\r\n        this.selectionChanged = false;\r\n        this.delayedFlush = -1;\r\n        this.resizeTimeout = -1;\r\n        this.queue = [];\r\n        this.delayedAndroidKey = null;\r\n        this.flushingAndroidKey = -1;\r\n        this.lastChange = 0;\r\n        this.scrollTargets = [];\r\n        this.intersection = null;\r\n        this.resizeScroll = null;\r\n        this.resizeContent = null;\r\n        this.intersecting = false;\r\n        this.gapIntersection = null;\r\n        this.gaps = [];\r\n        // Timeout for scheduling check of the parents that need scroll handlers\r\n        this.parentCheck = -1;\r\n        this.dom = view.contentDOM;\r\n        this.observer = new MutationObserver(mutations => {\r\n            for (let mut of mutations)\r\n                this.queue.push(mut);\r\n            // IE11 will sometimes (on typing over a selection or\r\n            // backspacing out a single character text node) call the\r\n            // observer callback before actually updating the DOM.\r\n            //\r\n            // Unrelatedly, iOS Safari will, when ending a composition,\r\n            // sometimes first clear it, deliver the mutations, and then\r\n            // reinsert the finished text. CodeMirror's handling of the\r\n            // deletion will prevent the reinsertion from happening,\r\n            // breaking composition.\r\n            if ((browser.ie && browser.ie_version <= 11 || browser.ios && view.composing) &&\r\n                mutations.some(m => m.type == \"childList\" && m.removedNodes.length ||\r\n                    m.type == \"characterData\" && m.oldValue.length > m.target.nodeValue.length))\r\n                this.flushSoon();\r\n            else\r\n                this.flush();\r\n        });\r\n        if (useCharData)\r\n            this.onCharData = (event) => {\r\n                this.queue.push({ target: event.target,\r\n                    type: \"characterData\",\r\n                    oldValue: event.prevValue });\r\n                this.flushSoon();\r\n            };\r\n        this.onSelectionChange = this.onSelectionChange.bind(this);\r\n        this.onResize = this.onResize.bind(this);\r\n        this.onPrint = this.onPrint.bind(this);\r\n        this.onScroll = this.onScroll.bind(this);\r\n        if (typeof ResizeObserver == \"function\") {\r\n            this.resizeScroll = new ResizeObserver(() => {\r\n                var _a;\r\n                if (((_a = this.view.docView) === null || _a === void 0 ? void 0 : _a.lastUpdate) < Date.now() - 75)\r\n                    this.onResize();\r\n            });\r\n            this.resizeScroll.observe(view.scrollDOM);\r\n            this.resizeContent = new ResizeObserver(() => this.view.requestMeasure());\r\n            this.resizeContent.observe(view.contentDOM);\r\n        }\r\n        this.addWindowListeners(this.win = view.win);\r\n        this.start();\r\n        if (typeof IntersectionObserver == \"function\") {\r\n            this.intersection = new IntersectionObserver(entries => {\r\n                if (this.parentCheck < 0)\r\n                    this.parentCheck = setTimeout(this.listenForScroll.bind(this), 1000);\r\n                if (entries.length > 0 && (entries[entries.length - 1].intersectionRatio > 0) != this.intersecting) {\r\n                    this.intersecting = !this.intersecting;\r\n                    if (this.intersecting != this.view.inView)\r\n                        this.onScrollChanged(document.createEvent(\"Event\"));\r\n                }\r\n            }, {});\r\n            this.intersection.observe(this.dom);\r\n            this.gapIntersection = new IntersectionObserver(entries => {\r\n                if (entries.length > 0 && entries[entries.length - 1].intersectionRatio > 0)\r\n                    this.onScrollChanged(document.createEvent(\"Event\"));\r\n            }, {});\r\n        }\r\n        this.listenForScroll();\r\n        this.readSelectionRange();\r\n    }\r\n    onScrollChanged(e) {\r\n        this.view.inputState.runScrollHandlers(this.view, e);\r\n        if (this.intersecting)\r\n            this.view.measure();\r\n    }\r\n    onScroll(e) {\r\n        if (this.intersecting)\r\n            this.flush(false);\r\n        this.onScrollChanged(e);\r\n    }\r\n    onResize() {\r\n        if (this.resizeTimeout < 0)\r\n            this.resizeTimeout = setTimeout(() => {\r\n                this.resizeTimeout = -1;\r\n                this.view.requestMeasure();\r\n            }, 50);\r\n    }\r\n    onPrint() {\r\n        this.view.viewState.printing = true;\r\n        this.view.measure();\r\n        setTimeout(() => {\r\n            this.view.viewState.printing = false;\r\n            this.view.requestMeasure();\r\n        }, 500);\r\n    }\r\n    updateGaps(gaps) {\r\n        if (this.gapIntersection && (gaps.length != this.gaps.length || this.gaps.some((g, i) => g != gaps[i]))) {\r\n            this.gapIntersection.disconnect();\r\n            for (let gap of gaps)\r\n                this.gapIntersection.observe(gap);\r\n            this.gaps = gaps;\r\n        }\r\n    }\r\n    onSelectionChange(event) {\r\n        let wasChanged = this.selectionChanged;\r\n        if (!this.readSelectionRange() || this.delayedAndroidKey)\r\n            return;\r\n        let { view } = this, sel = this.selectionRange;\r\n        if (view.state.facet(editable) ? view.root.activeElement != this.dom : !hasSelection(view.dom, sel))\r\n            return;\r\n        let context = sel.anchorNode && view.docView.nearest(sel.anchorNode);\r\n        if (context && context.ignoreEvent(event)) {\r\n            if (!wasChanged)\r\n                this.selectionChanged = false;\r\n            return;\r\n        }\r\n        // Deletions on IE11 fire their events in the wrong order, giving\r\n        // us a selection change event before the DOM changes are\r\n        // reported.\r\n        // Chrome Android has a similar issue when backspacing out a\r\n        // selection (#645).\r\n        if ((browser.ie && browser.ie_version <= 11 || browser.android && browser.chrome) && !view.state.selection.main.empty &&\r\n            // (Selection.isCollapsed isn't reliable on IE)\r\n            sel.focusNode && isEquivalentPosition(sel.focusNode, sel.focusOffset, sel.anchorNode, sel.anchorOffset))\r\n            this.flushSoon();\r\n        else\r\n            this.flush(false);\r\n    }\r\n    readSelectionRange() {\r\n        let { view } = this;\r\n        // The Selection object is broken in shadow roots in Safari. See\r\n        // https://github.com/codemirror/dev/issues/414\r\n        let range = browser.safari && view.root.nodeType == 11 &&\r\n            deepActiveElement(this.dom.ownerDocument) == this.dom &&\r\n            safariSelectionRangeHack(this.view) || getSelection(view.root);\r\n        if (!range || this.selectionRange.eq(range))\r\n            return false;\r\n        let local = hasSelection(this.dom, range);\r\n        // Detect the situation where the browser has, on focus, moved the\r\n        // selection to the start of the content element. Reset it to the\r\n        // position from the editor state.\r\n        if (local && !this.selectionChanged &&\r\n            view.inputState.lastFocusTime > Date.now() - 200 &&\r\n            view.inputState.lastTouchTime < Date.now() - 300 &&\r\n            atElementStart(this.dom, range)) {\r\n            this.view.inputState.lastFocusTime = 0;\r\n            view.docView.updateSelection();\r\n            return false;\r\n        }\r\n        this.selectionRange.setRange(range);\r\n        if (local)\r\n            this.selectionChanged = true;\r\n        return true;\r\n    }\r\n    setSelectionRange(anchor, head) {\r\n        this.selectionRange.set(anchor.node, anchor.offset, head.node, head.offset);\r\n        this.selectionChanged = false;\r\n    }\r\n    clearSelectionRange() {\r\n        this.selectionRange.set(null, 0, null, 0);\r\n    }\r\n    listenForScroll() {\r\n        this.parentCheck = -1;\r\n        let i = 0, changed = null;\r\n        for (let dom = this.dom; dom;) {\r\n            if (dom.nodeType == 1) {\r\n                if (!changed && i < this.scrollTargets.length && this.scrollTargets[i] == dom)\r\n                    i++;\r\n                else if (!changed)\r\n                    changed = this.scrollTargets.slice(0, i);\r\n                if (changed)\r\n                    changed.push(dom);\r\n                dom = dom.assignedSlot || dom.parentNode;\r\n            }\r\n            else if (dom.nodeType == 11) { // Shadow root\r\n                dom = dom.host;\r\n            }\r\n            else {\r\n                break;\r\n            }\r\n        }\r\n        if (i < this.scrollTargets.length && !changed)\r\n            changed = this.scrollTargets.slice(0, i);\r\n        if (changed) {\r\n            for (let dom of this.scrollTargets)\r\n                dom.removeEventListener(\"scroll\", this.onScroll);\r\n            for (let dom of this.scrollTargets = changed)\r\n                dom.addEventListener(\"scroll\", this.onScroll);\r\n        }\r\n    }\r\n    ignore(f) {\r\n        if (!this.active)\r\n            return f();\r\n        try {\r\n            this.stop();\r\n            return f();\r\n        }\r\n        finally {\r\n            this.start();\r\n            this.clear();\r\n        }\r\n    }\r\n    start() {\r\n        if (this.active)\r\n            return;\r\n        this.observer.observe(this.dom, observeOptions);\r\n        if (useCharData)\r\n            this.dom.addEventListener(\"DOMCharacterDataModified\", this.onCharData);\r\n        this.active = true;\r\n    }\r\n    stop() {\r\n        if (!this.active)\r\n            return;\r\n        this.active = false;\r\n        this.observer.disconnect();\r\n        if (useCharData)\r\n            this.dom.removeEventListener(\"DOMCharacterDataModified\", this.onCharData);\r\n    }\r\n    // Throw away any pending changes\r\n    clear() {\r\n        this.processRecords();\r\n        this.queue.length = 0;\r\n        this.selectionChanged = false;\r\n    }\r\n    // Chrome Android, especially in combination with GBoard, not only\r\n    // doesn't reliably fire regular key events, but also often\r\n    // surrounds the effect of enter or backspace with a bunch of\r\n    // composition events that, when interrupted, cause text duplication\r\n    // or other kinds of corruption. This hack makes the editor back off\r\n    // from handling DOM changes for a moment when such a key is\r\n    // detected (via beforeinput or keydown), and then tries to flush\r\n    // them or, if that has no effect, dispatches the given key.\r\n    delayAndroidKey(key, keyCode) {\r\n        var _a;\r\n        if (!this.delayedAndroidKey) {\r\n            let flush = () => {\r\n                let key = this.delayedAndroidKey;\r\n                if (key) {\r\n                    this.clearDelayedAndroidKey();\r\n                    if (!this.flush() && key.force)\r\n                        dispatchKey(this.dom, key.key, key.keyCode);\r\n                }\r\n            };\r\n            this.flushingAndroidKey = this.view.win.requestAnimationFrame(flush);\r\n        }\r\n        // Since backspace beforeinput is sometimes signalled spuriously,\r\n        // Enter always takes precedence.\r\n        if (!this.delayedAndroidKey || key == \"Enter\")\r\n            this.delayedAndroidKey = {\r\n                key, keyCode,\r\n                // Only run the key handler when no changes are detected if\r\n                // this isn't coming right after another change, in which case\r\n                // it is probably part of a weird chain of updates, and should\r\n                // be ignored if it returns the DOM to its previous state.\r\n                force: this.lastChange < Date.now() - 50 || !!((_a = this.delayedAndroidKey) === null || _a === void 0 ? void 0 : _a.force)\r\n            };\r\n    }\r\n    clearDelayedAndroidKey() {\r\n        this.win.cancelAnimationFrame(this.flushingAndroidKey);\r\n        this.delayedAndroidKey = null;\r\n        this.flushingAndroidKey = -1;\r\n    }\r\n    flushSoon() {\r\n        if (this.delayedFlush < 0)\r\n            this.delayedFlush = this.view.win.requestAnimationFrame(() => { this.delayedFlush = -1; this.flush(); });\r\n    }\r\n    forceFlush() {\r\n        if (this.delayedFlush >= 0) {\r\n            this.view.win.cancelAnimationFrame(this.delayedFlush);\r\n            this.delayedFlush = -1;\r\n        }\r\n        this.flush();\r\n    }\r\n    processRecords() {\r\n        let records = this.queue;\r\n        for (let mut of this.observer.takeRecords())\r\n            records.push(mut);\r\n        if (records.length)\r\n            this.queue = [];\r\n        let from = -1, to = -1, typeOver = false;\r\n        for (let record of records) {\r\n            let range = this.readMutation(record);\r\n            if (!range)\r\n                continue;\r\n            if (range.typeOver)\r\n                typeOver = true;\r\n            if (from == -1) {\r\n                ({ from, to } = range);\r\n            }\r\n            else {\r\n                from = Math.min(range.from, from);\r\n                to = Math.max(range.to, to);\r\n            }\r\n        }\r\n        return { from, to, typeOver };\r\n    }\r\n    readChange() {\r\n        let { from, to, typeOver } = this.processRecords();\r\n        let newSel = this.selectionChanged && hasSelection(this.dom, this.selectionRange);\r\n        if (from < 0 && !newSel)\r\n            return null;\r\n        if (from > -1)\r\n            this.lastChange = Date.now();\r\n        this.view.inputState.lastFocusTime = 0;\r\n        this.selectionChanged = false;\r\n        return new DOMChange(this.view, from, to, typeOver);\r\n    }\r\n    // Apply pending changes, if any\r\n    flush(readSelection = true) {\r\n        // Completely hold off flushing when pending keys are set—the code\r\n        // managing those will make sure processRecords is called and the\r\n        // view is resynchronized after\r\n        if (this.delayedFlush >= 0 || this.delayedAndroidKey)\r\n            return false;\r\n        if (readSelection)\r\n            this.readSelectionRange();\r\n        let domChange = this.readChange();\r\n        if (!domChange)\r\n            return false;\r\n        let startState = this.view.state;\r\n        let handled = applyDOMChange(this.view, domChange);\r\n        // The view wasn't updated\r\n        if (this.view.state == startState)\r\n            this.view.update([]);\r\n        return handled;\r\n    }\r\n    readMutation(rec) {\r\n        let cView = this.view.docView.nearest(rec.target);\r\n        if (!cView || cView.ignoreMutation(rec))\r\n            return null;\r\n        cView.markDirty(rec.type == \"attributes\");\r\n        if (rec.type == \"attributes\")\r\n            cView.dirty |= 4 /* Dirty.Attrs */;\r\n        if (rec.type == \"childList\") {\r\n            let childBefore = findChild(cView, rec.previousSibling || rec.target.previousSibling, -1);\r\n            let childAfter = findChild(cView, rec.nextSibling || rec.target.nextSibling, 1);\r\n            return { from: childBefore ? cView.posAfter(childBefore) : cView.posAtStart,\r\n                to: childAfter ? cView.posBefore(childAfter) : cView.posAtEnd, typeOver: false };\r\n        }\r\n        else if (rec.type == \"characterData\") {\r\n            return { from: cView.posAtStart, to: cView.posAtEnd, typeOver: rec.target.nodeValue == rec.oldValue };\r\n        }\r\n        else {\r\n            return null;\r\n        }\r\n    }\r\n    setWindow(win) {\r\n        if (win != this.win) {\r\n            this.removeWindowListeners(this.win);\r\n            this.win = win;\r\n            this.addWindowListeners(this.win);\r\n        }\r\n    }\r\n    addWindowListeners(win) {\r\n        win.addEventListener(\"resize\", this.onResize);\r\n        win.addEventListener(\"beforeprint\", this.onPrint);\r\n        win.addEventListener(\"scroll\", this.onScroll);\r\n        win.document.addEventListener(\"selectionchange\", this.onSelectionChange);\r\n    }\r\n    removeWindowListeners(win) {\r\n        win.removeEventListener(\"scroll\", this.onScroll);\r\n        win.removeEventListener(\"resize\", this.onResize);\r\n        win.removeEventListener(\"beforeprint\", this.onPrint);\r\n        win.document.removeEventListener(\"selectionchange\", this.onSelectionChange);\r\n    }\r\n    destroy() {\r\n        var _a, _b, _c, _d;\r\n        this.stop();\r\n        (_a = this.intersection) === null || _a === void 0 ? void 0 : _a.disconnect();\r\n        (_b = this.gapIntersection) === null || _b === void 0 ? void 0 : _b.disconnect();\r\n        (_c = this.resizeScroll) === null || _c === void 0 ? void 0 : _c.disconnect();\r\n        (_d = this.resizeContent) === null || _d === void 0 ? void 0 : _d.disconnect();\r\n        for (let dom of this.scrollTargets)\r\n            dom.removeEventListener(\"scroll\", this.onScroll);\r\n        this.removeWindowListeners(this.win);\r\n        clearTimeout(this.parentCheck);\r\n        clearTimeout(this.resizeTimeout);\r\n        this.win.cancelAnimationFrame(this.delayedFlush);\r\n        this.win.cancelAnimationFrame(this.flushingAndroidKey);\r\n    }\r\n}\r\nfunction findChild(cView, dom, dir) {\r\n    while (dom) {\r\n        let curView = ContentView.get(dom);\r\n        if (curView && curView.parent == cView)\r\n            return curView;\r\n        let parent = dom.parentNode;\r\n        dom = parent != cView.dom ? parent : dir > 0 ? dom.nextSibling : dom.previousSibling;\r\n    }\r\n    return null;\r\n}\r\n// Used to work around a Safari Selection/shadow DOM bug (#414)\r\nfunction safariSelectionRangeHack(view) {\r\n    let found = null;\r\n    // Because Safari (at least in 2018-2021) doesn't provide regular\r\n    // access to the selection inside a shadowroot, we have to perform a\r\n    // ridiculous hack to get at it—using `execCommand` to trigger a\r\n    // `beforeInput` event so that we can read the target range from the\r\n    // event.\r\n    function read(event) {\r\n        event.preventDefault();\r\n        event.stopImmediatePropagation();\r\n        found = event.getTargetRanges()[0];\r\n    }\r\n    view.contentDOM.addEventListener(\"beforeinput\", read, true);\r\n    view.dom.ownerDocument.execCommand(\"indent\");\r\n    view.contentDOM.removeEventListener(\"beforeinput\", read, true);\r\n    if (!found)\r\n        return null;\r\n    let anchorNode = found.startContainer, anchorOffset = found.startOffset;\r\n    let focusNode = found.endContainer, focusOffset = found.endOffset;\r\n    let curAnchor = view.docView.domAtPos(view.state.selection.main.anchor);\r\n    // Since such a range doesn't distinguish between anchor and head,\r\n    // use a heuristic that flips it around if its end matches the\r\n    // current anchor.\r\n    if (isEquivalentPosition(curAnchor.node, curAnchor.offset, focusNode, focusOffset))\r\n        [anchorNode, anchorOffset, focusNode, focusOffset] = [focusNode, focusOffset, anchorNode, anchorOffset];\r\n    return { anchorNode, anchorOffset, focusNode, focusOffset };\r\n}\r\n\r\n// The editor's update state machine looks something like this:\r\n//\r\n//     Idle → Updating ⇆ Idle (unchecked) → Measuring → Idle\r\n//                                         ↑      ↓\r\n//                                         Updating (measure)\r\n//\r\n// The difference between 'Idle' and 'Idle (unchecked)' lies in\r\n// whether a layout check has been scheduled. A regular update through\r\n// the `update` method updates the DOM in a write-only fashion, and\r\n// relies on a check (scheduled with `requestAnimationFrame`) to make\r\n// sure everything is where it should be and the viewport covers the\r\n// visible code. That check continues to measure and then optionally\r\n// update until it reaches a coherent state.\r\n/**\r\nAn editor view represents the editor's user interface. It holds\r\nthe editable DOM surface, and possibly other elements such as the\r\nline number gutter. It handles events and dispatches state\r\ntransactions for editing actions.\r\n*/\r\nclass EditorView {\r\n    /**\r\n    Construct a new view. You'll want to either provide a `parent`\r\n    option, or put `view.dom` into your document after creating a\r\n    view, so that the user can see the editor.\r\n    */\r\n    constructor(config = {}) {\r\n        this.plugins = [];\r\n        this.pluginMap = new Map;\r\n        this.editorAttrs = {};\r\n        this.contentAttrs = {};\r\n        this.bidiCache = [];\r\n        this.destroyed = false;\r\n        /**\r\n        @internal\r\n        */\r\n        this.updateState = 2 /* UpdateState.Updating */;\r\n        /**\r\n        @internal\r\n        */\r\n        this.measureScheduled = -1;\r\n        /**\r\n        @internal\r\n        */\r\n        this.measureRequests = [];\r\n        this.contentDOM = document.createElement(\"div\");\r\n        this.scrollDOM = document.createElement(\"div\");\r\n        this.scrollDOM.tabIndex = -1;\r\n        this.scrollDOM.className = \"cm-scroller\";\r\n        this.scrollDOM.appendChild(this.contentDOM);\r\n        this.announceDOM = document.createElement(\"div\");\r\n        this.announceDOM.style.cssText = \"position: fixed; top: -10000px\";\r\n        this.announceDOM.setAttribute(\"aria-live\", \"polite\");\r\n        this.dom = document.createElement(\"div\");\r\n        this.dom.appendChild(this.announceDOM);\r\n        this.dom.appendChild(this.scrollDOM);\r\n        this._dispatch = config.dispatch || ((tr) => this.update([tr]));\r\n        this.dispatch = this.dispatch.bind(this);\r\n        this._root = (config.root || getRoot(config.parent) || document);\r\n        this.viewState = new ViewState(config.state || _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorState.create(config));\r\n        this.plugins = this.state.facet(viewPlugin).map(spec => new PluginInstance(spec));\r\n        for (let plugin of this.plugins)\r\n            plugin.update(this);\r\n        this.observer = new DOMObserver(this);\r\n        this.inputState = new InputState(this);\r\n        this.inputState.ensureHandlers(this, this.plugins);\r\n        this.docView = new DocView(this);\r\n        this.mountStyles();\r\n        this.updateAttrs();\r\n        this.updateState = 0 /* UpdateState.Idle */;\r\n        this.requestMeasure();\r\n        if (config.parent)\r\n            config.parent.appendChild(this.dom);\r\n    }\r\n    /**\r\n    The current editor state.\r\n    */\r\n    get state() { return this.viewState.state; }\r\n    /**\r\n    To be able to display large documents without consuming too much\r\n    memory or overloading the browser, CodeMirror only draws the\r\n    code that is visible (plus a margin around it) to the DOM. This\r\n    property tells you the extent of the current drawn viewport, in\r\n    document positions.\r\n    */\r\n    get viewport() { return this.viewState.viewport; }\r\n    /**\r\n    When there are, for example, large collapsed ranges in the\r\n    viewport, its size can be a lot bigger than the actual visible\r\n    content. Thus, if you are doing something like styling the\r\n    content in the viewport, it is preferable to only do so for\r\n    these ranges, which are the subset of the viewport that is\r\n    actually drawn.\r\n    */\r\n    get visibleRanges() { return this.viewState.visibleRanges; }\r\n    /**\r\n    Returns false when the editor is entirely scrolled out of view\r\n    or otherwise hidden.\r\n    */\r\n    get inView() { return this.viewState.inView; }\r\n    /**\r\n    Indicates whether the user is currently composing text via\r\n    [IME](https://en.wikipedia.org/wiki/Input_method), and at least\r\n    one change has been made in the current composition.\r\n    */\r\n    get composing() { return this.inputState.composing > 0; }\r\n    /**\r\n    Indicates whether the user is currently in composing state. Note\r\n    that on some platforms, like Android, this will be the case a\r\n    lot, since just putting the cursor on a word starts a\r\n    composition there.\r\n    */\r\n    get compositionStarted() { return this.inputState.composing >= 0; }\r\n    /**\r\n    The document or shadow root that the view lives in.\r\n    */\r\n    get root() { return this._root; }\r\n    /**\r\n    @internal\r\n    */\r\n    get win() { return this.dom.ownerDocument.defaultView || window; }\r\n    dispatch(...input) {\r\n        this._dispatch(input.length == 1 && input[0] instanceof _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Transaction ? input[0]\r\n            : this.state.update(...input));\r\n    }\r\n    /**\r\n    Update the view for the given array of transactions. This will\r\n    update the visible document and selection to match the state\r\n    produced by the transactions, and notify view plugins of the\r\n    change. You should usually call\r\n    [`dispatch`](https://codemirror.net/6/docs/ref/#view.EditorView.dispatch) instead, which uses this\r\n    as a primitive.\r\n    */\r\n    update(transactions) {\r\n        if (this.updateState != 0 /* UpdateState.Idle */)\r\n            throw new Error(\"Calls to EditorView.update are not allowed while an update is in progress\");\r\n        let redrawn = false, attrsChanged = false, update;\r\n        let state = this.state;\r\n        for (let tr of transactions) {\r\n            if (tr.startState != state)\r\n                throw new RangeError(\"Trying to update state with a transaction that doesn't start from the previous state.\");\r\n            state = tr.state;\r\n        }\r\n        if (this.destroyed) {\r\n            this.viewState.state = state;\r\n            return;\r\n        }\r\n        // If there was a pending DOM change, eagerly read it and try to\r\n        // apply it after the given transactions.\r\n        let pendingKey = this.observer.delayedAndroidKey, domChange = null;\r\n        if (pendingKey) {\r\n            this.observer.clearDelayedAndroidKey();\r\n            domChange = this.observer.readChange();\r\n            // Only try to apply DOM changes if the transactions didn't\r\n            // change the doc or selection.\r\n            if (domChange && !this.state.doc.eq(state.doc) || !this.state.selection.eq(state.selection))\r\n                domChange = null;\r\n        }\r\n        else {\r\n            this.observer.clear();\r\n        }\r\n        // When the phrases change, redraw the editor\r\n        if (state.facet(_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorState.phrases) != this.state.facet(_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorState.phrases))\r\n            return this.setState(state);\r\n        update = ViewUpdate.create(this, state, transactions);\r\n        let scrollTarget = this.viewState.scrollTarget;\r\n        try {\r\n            this.updateState = 2 /* UpdateState.Updating */;\r\n            for (let tr of transactions) {\r\n                if (scrollTarget)\r\n                    scrollTarget = scrollTarget.map(tr.changes);\r\n                if (tr.scrollIntoView) {\r\n                    let { main } = tr.state.selection;\r\n                    scrollTarget = new ScrollTarget(main.empty ? main : _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.cursor(main.head, main.head > main.anchor ? -1 : 1));\r\n                }\r\n                for (let e of tr.effects)\r\n                    if (e.is(scrollIntoView))\r\n                        scrollTarget = e.value;\r\n            }\r\n            this.viewState.update(update, scrollTarget);\r\n            this.bidiCache = CachedOrder.update(this.bidiCache, update.changes);\r\n            if (!update.empty) {\r\n                this.updatePlugins(update);\r\n                this.inputState.update(update);\r\n            }\r\n            redrawn = this.docView.update(update);\r\n            if (this.state.facet(styleModule) != this.styleModules)\r\n                this.mountStyles();\r\n            attrsChanged = this.updateAttrs();\r\n            this.showAnnouncements(transactions);\r\n            this.docView.updateSelection(redrawn, transactions.some(tr => tr.isUserEvent(\"select.pointer\")));\r\n        }\r\n        finally {\r\n            this.updateState = 0 /* UpdateState.Idle */;\r\n        }\r\n        if (update.startState.facet(theme) != update.state.facet(theme))\r\n            this.viewState.mustMeasureContent = true;\r\n        if (redrawn || attrsChanged || scrollTarget || this.viewState.mustEnforceCursorAssoc || this.viewState.mustMeasureContent)\r\n            this.requestMeasure();\r\n        if (!update.empty)\r\n            for (let listener of this.state.facet(updateListener))\r\n                listener(update);\r\n        if (domChange) {\r\n            if (!applyDOMChange(this, domChange) && pendingKey.force)\r\n                dispatchKey(this.contentDOM, pendingKey.key, pendingKey.keyCode);\r\n        }\r\n    }\r\n    /**\r\n    Reset the view to the given state. (This will cause the entire\r\n    document to be redrawn and all view plugins to be reinitialized,\r\n    so you should probably only use it when the new state isn't\r\n    derived from the old state. Otherwise, use\r\n    [`dispatch`](https://codemirror.net/6/docs/ref/#view.EditorView.dispatch) instead.)\r\n    */\r\n    setState(newState) {\r\n        if (this.updateState != 0 /* UpdateState.Idle */)\r\n            throw new Error(\"Calls to EditorView.setState are not allowed while an update is in progress\");\r\n        if (this.destroyed) {\r\n            this.viewState.state = newState;\r\n            return;\r\n        }\r\n        this.updateState = 2 /* UpdateState.Updating */;\r\n        let hadFocus = this.hasFocus;\r\n        try {\r\n            for (let plugin of this.plugins)\r\n                plugin.destroy(this);\r\n            this.viewState = new ViewState(newState);\r\n            this.plugins = newState.facet(viewPlugin).map(spec => new PluginInstance(spec));\r\n            this.pluginMap.clear();\r\n            for (let plugin of this.plugins)\r\n                plugin.update(this);\r\n            this.docView = new DocView(this);\r\n            this.inputState.ensureHandlers(this, this.plugins);\r\n            this.mountStyles();\r\n            this.updateAttrs();\r\n            this.bidiCache = [];\r\n        }\r\n        finally {\r\n            this.updateState = 0 /* UpdateState.Idle */;\r\n        }\r\n        if (hadFocus)\r\n            this.focus();\r\n        this.requestMeasure();\r\n    }\r\n    updatePlugins(update) {\r\n        let prevSpecs = update.startState.facet(viewPlugin), specs = update.state.facet(viewPlugin);\r\n        if (prevSpecs != specs) {\r\n            let newPlugins = [];\r\n            for (let spec of specs) {\r\n                let found = prevSpecs.indexOf(spec);\r\n                if (found < 0) {\r\n                    newPlugins.push(new PluginInstance(spec));\r\n                }\r\n                else {\r\n                    let plugin = this.plugins[found];\r\n                    plugin.mustUpdate = update;\r\n                    newPlugins.push(plugin);\r\n                }\r\n            }\r\n            for (let plugin of this.plugins)\r\n                if (plugin.mustUpdate != update)\r\n                    plugin.destroy(this);\r\n            this.plugins = newPlugins;\r\n            this.pluginMap.clear();\r\n            this.inputState.ensureHandlers(this, this.plugins);\r\n        }\r\n        else {\r\n            for (let p of this.plugins)\r\n                p.mustUpdate = update;\r\n        }\r\n        for (let i = 0; i < this.plugins.length; i++)\r\n            this.plugins[i].update(this);\r\n    }\r\n    /**\r\n    @internal\r\n    */\r\n    measure(flush = true) {\r\n        if (this.destroyed)\r\n            return;\r\n        if (this.measureScheduled > -1)\r\n            cancelAnimationFrame(this.measureScheduled);\r\n        this.measureScheduled = 0; // Prevent requestMeasure calls from scheduling another animation frame\r\n        if (flush)\r\n            this.observer.forceFlush();\r\n        let updated = null;\r\n        let { scrollHeight, scrollTop, clientHeight } = this.scrollDOM;\r\n        let refHeight = scrollTop > scrollHeight - clientHeight - 4 ? scrollHeight : scrollTop;\r\n        try {\r\n            for (let i = 0;; i++) {\r\n                this.updateState = 1 /* UpdateState.Measuring */;\r\n                let oldViewport = this.viewport;\r\n                let refBlock = this.viewState.lineBlockAtHeight(refHeight);\r\n                let changed = this.viewState.measure(this);\r\n                if (!changed && !this.measureRequests.length && this.viewState.scrollTarget == null)\r\n                    break;\r\n                if (i > 5) {\r\n                    console.warn(this.measureRequests.length\r\n                        ? \"Measure loop restarted more than 5 times\"\r\n                        : \"Viewport failed to stabilize\");\r\n                    break;\r\n                }\r\n                let measuring = [];\r\n                // Only run measure requests in this cycle when the viewport didn't change\r\n                if (!(changed & 4 /* UpdateFlag.Viewport */))\r\n                    [this.measureRequests, measuring] = [measuring, this.measureRequests];\r\n                let measured = measuring.map(m => {\r\n                    try {\r\n                        return m.read(this);\r\n                    }\r\n                    catch (e) {\r\n                        logException(this.state, e);\r\n                        return BadMeasure;\r\n                    }\r\n                });\r\n                let update = ViewUpdate.create(this, this.state, []), redrawn = false, scrolled = false;\r\n                update.flags |= changed;\r\n                if (!updated)\r\n                    updated = update;\r\n                else\r\n                    updated.flags |= changed;\r\n                this.updateState = 2 /* UpdateState.Updating */;\r\n                if (!update.empty) {\r\n                    this.updatePlugins(update);\r\n                    this.inputState.update(update);\r\n                    this.updateAttrs();\r\n                    redrawn = this.docView.update(update);\r\n                }\r\n                for (let i = 0; i < measuring.length; i++)\r\n                    if (measured[i] != BadMeasure) {\r\n                        try {\r\n                            let m = measuring[i];\r\n                            if (m.write)\r\n                                m.write(measured[i], this);\r\n                        }\r\n                        catch (e) {\r\n                            logException(this.state, e);\r\n                        }\r\n                    }\r\n                if (this.viewState.editorHeight) {\r\n                    if (this.viewState.scrollTarget) {\r\n                        this.docView.scrollIntoView(this.viewState.scrollTarget);\r\n                        this.viewState.scrollTarget = null;\r\n                        scrolled = true;\r\n                    }\r\n                    else {\r\n                        let diff = this.viewState.lineBlockAt(refBlock.from).top - refBlock.top;\r\n                        if (diff > 1 || diff < -1) {\r\n                            this.scrollDOM.scrollTop += diff;\r\n                            scrolled = true;\r\n                        }\r\n                    }\r\n                }\r\n                if (redrawn)\r\n                    this.docView.updateSelection(true);\r\n                if (this.viewport.from == oldViewport.from && this.viewport.to == oldViewport.to &&\r\n                    !scrolled && this.measureRequests.length == 0)\r\n                    break;\r\n            }\r\n        }\r\n        finally {\r\n            this.updateState = 0 /* UpdateState.Idle */;\r\n            this.measureScheduled = -1;\r\n        }\r\n        if (updated && !updated.empty)\r\n            for (let listener of this.state.facet(updateListener))\r\n                listener(updated);\r\n    }\r\n    /**\r\n    Get the CSS classes for the currently active editor themes.\r\n    */\r\n    get themeClasses() {\r\n        return baseThemeID + \" \" +\r\n            (this.state.facet(darkTheme) ? baseDarkID : baseLightID) + \" \" +\r\n            this.state.facet(theme);\r\n    }\r\n    updateAttrs() {\r\n        let editorAttrs = attrsFromFacet(this, editorAttributes, {\r\n            class: \"cm-editor\" + (this.hasFocus ? \" cm-focused \" : \" \") + this.themeClasses\r\n        });\r\n        let contentAttrs = {\r\n            spellcheck: \"false\",\r\n            autocorrect: \"off\",\r\n            autocapitalize: \"off\",\r\n            translate: \"no\",\r\n            contenteditable: !this.state.facet(editable) ? \"false\" : \"true\",\r\n            class: \"cm-content\",\r\n            style: `${browser.tabSize}: ${this.state.tabSize}`,\r\n            role: \"textbox\",\r\n            \"aria-multiline\": \"true\"\r\n        };\r\n        if (this.state.readOnly)\r\n            contentAttrs[\"aria-readonly\"] = \"true\";\r\n        attrsFromFacet(this, contentAttributes, contentAttrs);\r\n        let changed = this.observer.ignore(() => {\r\n            let changedContent = updateAttrs(this.contentDOM, this.contentAttrs, contentAttrs);\r\n            let changedEditor = updateAttrs(this.dom, this.editorAttrs, editorAttrs);\r\n            return changedContent || changedEditor;\r\n        });\r\n        this.editorAttrs = editorAttrs;\r\n        this.contentAttrs = contentAttrs;\r\n        return changed;\r\n    }\r\n    showAnnouncements(trs) {\r\n        let first = true;\r\n        for (let tr of trs)\r\n            for (let effect of tr.effects)\r\n                if (effect.is(EditorView.announce)) {\r\n                    if (first)\r\n                        this.announceDOM.textContent = \"\";\r\n                    first = false;\r\n                    let div = this.announceDOM.appendChild(document.createElement(\"div\"));\r\n                    div.textContent = effect.value;\r\n                }\r\n    }\r\n    mountStyles() {\r\n        this.styleModules = this.state.facet(styleModule);\r\n        style_mod__WEBPACK_IMPORTED_MODULE_0__.StyleModule.mount(this.root, this.styleModules.concat(baseTheme$1).reverse());\r\n    }\r\n    readMeasured() {\r\n        if (this.updateState == 2 /* UpdateState.Updating */)\r\n            throw new Error(\"Reading the editor layout isn't allowed during an update\");\r\n        if (this.updateState == 0 /* UpdateState.Idle */ && this.measureScheduled > -1)\r\n            this.measure(false);\r\n    }\r\n    /**\r\n    Schedule a layout measurement, optionally providing callbacks to\r\n    do custom DOM measuring followed by a DOM write phase. Using\r\n    this is preferable reading DOM layout directly from, for\r\n    example, an event handler, because it'll make sure measuring and\r\n    drawing done by other components is synchronized, avoiding\r\n    unnecessary DOM layout computations.\r\n    */\r\n    requestMeasure(request) {\r\n        if (this.measureScheduled < 0)\r\n            this.measureScheduled = this.win.requestAnimationFrame(() => this.measure());\r\n        if (request) {\r\n            if (this.measureRequests.indexOf(request) > -1)\r\n                return;\r\n            if (request.key != null)\r\n                for (let i = 0; i < this.measureRequests.length; i++) {\r\n                    if (this.measureRequests[i].key === request.key) {\r\n                        this.measureRequests[i] = request;\r\n                        return;\r\n                    }\r\n                }\r\n            this.measureRequests.push(request);\r\n        }\r\n    }\r\n    /**\r\n    Get the value of a specific plugin, if present. Note that\r\n    plugins that crash can be dropped from a view, so even when you\r\n    know you registered a given plugin, it is recommended to check\r\n    the return value of this method.\r\n    */\r\n    plugin(plugin) {\r\n        let known = this.pluginMap.get(plugin);\r\n        if (known === undefined || known && known.spec != plugin)\r\n            this.pluginMap.set(plugin, known = this.plugins.find(p => p.spec == plugin) || null);\r\n        return known && known.update(this).value;\r\n    }\r\n    /**\r\n    The top position of the document, in screen coordinates. This\r\n    may be negative when the editor is scrolled down. Points\r\n    directly to the top of the first line, not above the padding.\r\n    */\r\n    get documentTop() {\r\n        return this.contentDOM.getBoundingClientRect().top + this.viewState.paddingTop;\r\n    }\r\n    /**\r\n    Reports the padding above and below the document.\r\n    */\r\n    get documentPadding() {\r\n        return { top: this.viewState.paddingTop, bottom: this.viewState.paddingBottom };\r\n    }\r\n    /**\r\n    Find the text line or block widget at the given vertical\r\n    position (which is interpreted as relative to the [top of the\r\n    document](https://codemirror.net/6/docs/ref/#view.EditorView.documentTop)).\r\n    */\r\n    elementAtHeight(height) {\r\n        this.readMeasured();\r\n        return this.viewState.elementAtHeight(height);\r\n    }\r\n    /**\r\n    Find the line block (see\r\n    [`lineBlockAt`](https://codemirror.net/6/docs/ref/#view.EditorView.lineBlockAt) at the given\r\n    height, again interpreted relative to the [top of the\r\n    document](https://codemirror.net/6/docs/ref/#view.EditorView.documentTop).\r\n    */\r\n    lineBlockAtHeight(height) {\r\n        this.readMeasured();\r\n        return this.viewState.lineBlockAtHeight(height);\r\n    }\r\n    /**\r\n    Get the extent and vertical position of all [line\r\n    blocks](https://codemirror.net/6/docs/ref/#view.EditorView.lineBlockAt) in the viewport. Positions\r\n    are relative to the [top of the\r\n    document](https://codemirror.net/6/docs/ref/#view.EditorView.documentTop);\r\n    */\r\n    get viewportLineBlocks() {\r\n        return this.viewState.viewportLines;\r\n    }\r\n    /**\r\n    Find the line block around the given document position. A line\r\n    block is a range delimited on both sides by either a\r\n    non-[hidden](https://codemirror.net/6/docs/ref/#view.Decoration^replace) line breaks, or the\r\n    start/end of the document. It will usually just hold a line of\r\n    text, but may be broken into multiple textblocks by block\r\n    widgets.\r\n    */\r\n    lineBlockAt(pos) {\r\n        return this.viewState.lineBlockAt(pos);\r\n    }\r\n    /**\r\n    The editor's total content height.\r\n    */\r\n    get contentHeight() {\r\n        return this.viewState.contentHeight;\r\n    }\r\n    /**\r\n    Move a cursor position by [grapheme\r\n    cluster](https://codemirror.net/6/docs/ref/#state.findClusterBreak). `forward` determines whether\r\n    the motion is away from the line start, or towards it. In\r\n    bidirectional text, the line is traversed in visual order, using\r\n    the editor's [text direction](https://codemirror.net/6/docs/ref/#view.EditorView.textDirection).\r\n    When the start position was the last one on the line, the\r\n    returned position will be across the line break. If there is no\r\n    further line, the original position is returned.\r\n    \r\n    By default, this method moves over a single cluster. The\r\n    optional `by` argument can be used to move across more. It will\r\n    be called with the first cluster as argument, and should return\r\n    a predicate that determines, for each subsequent cluster,\r\n    whether it should also be moved over.\r\n    */\r\n    moveByChar(start, forward, by) {\r\n        return skipAtoms(this, start, moveByChar(this, start, forward, by));\r\n    }\r\n    /**\r\n    Move a cursor position across the next group of either\r\n    [letters](https://codemirror.net/6/docs/ref/#state.EditorState.charCategorizer) or non-letter\r\n    non-whitespace characters.\r\n    */\r\n    moveByGroup(start, forward) {\r\n        return skipAtoms(this, start, moveByChar(this, start, forward, initial => byGroup(this, start.head, initial)));\r\n    }\r\n    /**\r\n    Move to the next line boundary in the given direction. If\r\n    `includeWrap` is true, line wrapping is on, and there is a\r\n    further wrap point on the current line, the wrap point will be\r\n    returned. Otherwise this function will return the start or end\r\n    of the line.\r\n    */\r\n    moveToLineBoundary(start, forward, includeWrap = true) {\r\n        return moveToLineBoundary(this, start, forward, includeWrap);\r\n    }\r\n    /**\r\n    Move a cursor position vertically. When `distance` isn't given,\r\n    it defaults to moving to the next line (including wrapped\r\n    lines). Otherwise, `distance` should provide a positive distance\r\n    in pixels.\r\n    \r\n    When `start` has a\r\n    [`goalColumn`](https://codemirror.net/6/docs/ref/#state.SelectionRange.goalColumn), the vertical\r\n    motion will use that as a target horizontal position. Otherwise,\r\n    the cursor's own horizontal position is used. The returned\r\n    cursor will have its goal column set to whichever column was\r\n    used.\r\n    */\r\n    moveVertically(start, forward, distance) {\r\n        return skipAtoms(this, start, moveVertically(this, start, forward, distance));\r\n    }\r\n    /**\r\n    Find the DOM parent node and offset (child offset if `node` is\r\n    an element, character offset when it is a text node) at the\r\n    given document position.\r\n    \r\n    Note that for positions that aren't currently in\r\n    `visibleRanges`, the resulting DOM position isn't necessarily\r\n    meaningful (it may just point before or after a placeholder\r\n    element).\r\n    */\r\n    domAtPos(pos) {\r\n        return this.docView.domAtPos(pos);\r\n    }\r\n    /**\r\n    Find the document position at the given DOM node. Can be useful\r\n    for associating positions with DOM events. Will raise an error\r\n    when `node` isn't part of the editor content.\r\n    */\r\n    posAtDOM(node, offset = 0) {\r\n        return this.docView.posFromDOM(node, offset);\r\n    }\r\n    posAtCoords(coords, precise = true) {\r\n        this.readMeasured();\r\n        return posAtCoords(this, coords, precise);\r\n    }\r\n    /**\r\n    Get the screen coordinates at the given document position.\r\n    `side` determines whether the coordinates are based on the\r\n    element before (-1) or after (1) the position (if no element is\r\n    available on the given side, the method will transparently use\r\n    another strategy to get reasonable coordinates).\r\n    */\r\n    coordsAtPos(pos, side = 1) {\r\n        this.readMeasured();\r\n        let rect = this.docView.coordsAt(pos, side);\r\n        if (!rect || rect.left == rect.right)\r\n            return rect;\r\n        let line = this.state.doc.lineAt(pos), order = this.bidiSpans(line);\r\n        let span = order[BidiSpan.find(order, pos - line.from, -1, side)];\r\n        return flattenRect(rect, (span.dir == Direction.LTR) == (side > 0));\r\n    }\r\n    /**\r\n    The default width of a character in the editor. May not\r\n    accurately reflect the width of all characters (given variable\r\n    width fonts or styling of invididual ranges).\r\n    */\r\n    get defaultCharacterWidth() { return this.viewState.heightOracle.charWidth; }\r\n    /**\r\n    The default height of a line in the editor. May not be accurate\r\n    for all lines.\r\n    */\r\n    get defaultLineHeight() { return this.viewState.heightOracle.lineHeight; }\r\n    /**\r\n    The text direction\r\n    ([`direction`](https://developer.mozilla.org/en-US/docs/Web/CSS/direction)\r\n    CSS property) of the editor's content element.\r\n    */\r\n    get textDirection() { return this.viewState.defaultTextDirection; }\r\n    /**\r\n    Find the text direction of the block at the given position, as\r\n    assigned by CSS. If\r\n    [`perLineTextDirection`](https://codemirror.net/6/docs/ref/#view.EditorView^perLineTextDirection)\r\n    isn't enabled, or the given position is outside of the viewport,\r\n    this will always return the same as\r\n    [`textDirection`](https://codemirror.net/6/docs/ref/#view.EditorView.textDirection). Note that\r\n    this may trigger a DOM layout.\r\n    */\r\n    textDirectionAt(pos) {\r\n        let perLine = this.state.facet(perLineTextDirection);\r\n        if (!perLine || pos < this.viewport.from || pos > this.viewport.to)\r\n            return this.textDirection;\r\n        this.readMeasured();\r\n        return this.docView.textDirectionAt(pos);\r\n    }\r\n    /**\r\n    Whether this editor [wraps lines](https://codemirror.net/6/docs/ref/#view.EditorView.lineWrapping)\r\n    (as determined by the\r\n    [`white-space`](https://developer.mozilla.org/en-US/docs/Web/CSS/white-space)\r\n    CSS property of its content element).\r\n    */\r\n    get lineWrapping() { return this.viewState.heightOracle.lineWrapping; }\r\n    /**\r\n    Returns the bidirectional text structure of the given line\r\n    (which should be in the current document) as an array of span\r\n    objects. The order of these spans matches the [text\r\n    direction](https://codemirror.net/6/docs/ref/#view.EditorView.textDirection)—if that is\r\n    left-to-right, the leftmost spans come first, otherwise the\r\n    rightmost spans come first.\r\n    */\r\n    bidiSpans(line) {\r\n        if (line.length > MaxBidiLine)\r\n            return trivialOrder(line.length);\r\n        let dir = this.textDirectionAt(line.from);\r\n        for (let entry of this.bidiCache)\r\n            if (entry.from == line.from && entry.dir == dir)\r\n                return entry.order;\r\n        let order = computeOrder(line.text, dir);\r\n        this.bidiCache.push(new CachedOrder(line.from, line.to, dir, order));\r\n        return order;\r\n    }\r\n    /**\r\n    Check whether the editor has focus.\r\n    */\r\n    get hasFocus() {\r\n        var _a;\r\n        // Safari return false for hasFocus when the context menu is open\r\n        // or closing, which leads us to ignore selection changes from the\r\n        // context menu because it looks like the editor isn't focused.\r\n        // This kludges around that.\r\n        return (this.dom.ownerDocument.hasFocus() || browser.safari && ((_a = this.inputState) === null || _a === void 0 ? void 0 : _a.lastContextMenu) > Date.now() - 3e4) &&\r\n            this.root.activeElement == this.contentDOM;\r\n    }\r\n    /**\r\n    Put focus on the editor.\r\n    */\r\n    focus() {\r\n        this.observer.ignore(() => {\r\n            focusPreventScroll(this.contentDOM);\r\n            this.docView.updateSelection();\r\n        });\r\n    }\r\n    /**\r\n    Update the [root](https://codemirror.net/6/docs/ref/##view.EditorViewConfig.root) in which the editor lives. This is only\r\n    necessary when moving the editor's existing DOM to a new window or shadow root.\r\n    */\r\n    setRoot(root) {\r\n        if (this._root != root) {\r\n            this._root = root;\r\n            this.observer.setWindow((root.nodeType == 9 ? root : root.ownerDocument).defaultView || window);\r\n            this.mountStyles();\r\n        }\r\n    }\r\n    /**\r\n    Clean up this editor view, removing its element from the\r\n    document, unregistering event handlers, and notifying\r\n    plugins. The view instance can no longer be used after\r\n    calling this.\r\n    */\r\n    destroy() {\r\n        for (let plugin of this.plugins)\r\n            plugin.destroy(this);\r\n        this.plugins = [];\r\n        this.inputState.destroy();\r\n        this.dom.remove();\r\n        this.observer.destroy();\r\n        if (this.measureScheduled > -1)\r\n            cancelAnimationFrame(this.measureScheduled);\r\n        this.destroyed = true;\r\n    }\r\n    /**\r\n    Returns an effect that can be\r\n    [added](https://codemirror.net/6/docs/ref/#state.TransactionSpec.effects) to a transaction to\r\n    cause it to scroll the given position or range into view.\r\n    */\r\n    static scrollIntoView(pos, options = {}) {\r\n        return scrollIntoView.of(new ScrollTarget(typeof pos == \"number\" ? _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.cursor(pos) : pos, options.y, options.x, options.yMargin, options.xMargin));\r\n    }\r\n    /**\r\n    Returns an extension that can be used to add DOM event handlers.\r\n    The value should be an object mapping event names to handler\r\n    functions. For any given event, such functions are ordered by\r\n    extension precedence, and the first handler to return true will\r\n    be assumed to have handled that event, and no other handlers or\r\n    built-in behavior will be activated for it. These are registered\r\n    on the [content element](https://codemirror.net/6/docs/ref/#view.EditorView.contentDOM), except\r\n    for `scroll` handlers, which will be called any time the\r\n    editor's [scroll element](https://codemirror.net/6/docs/ref/#view.EditorView.scrollDOM) or one of\r\n    its parent nodes is scrolled.\r\n    */\r\n    static domEventHandlers(handlers) {\r\n        return ViewPlugin.define(() => ({}), { eventHandlers: handlers });\r\n    }\r\n    /**\r\n    Create a theme extension. The first argument can be a\r\n    [`style-mod`](https://github.com/marijnh/style-mod#documentation)\r\n    style spec providing the styles for the theme. These will be\r\n    prefixed with a generated class for the style.\r\n    \r\n    Because the selectors will be prefixed with a scope class, rule\r\n    that directly match the editor's [wrapper\r\n    element](https://codemirror.net/6/docs/ref/#view.EditorView.dom)—to which the scope class will be\r\n    added—need to be explicitly differentiated by adding an `&` to\r\n    the selector for that element—for example\r\n    `&.cm-focused`.\r\n    \r\n    When `dark` is set to true, the theme will be marked as dark,\r\n    which will cause the `&dark` rules from [base\r\n    themes](https://codemirror.net/6/docs/ref/#view.EditorView^baseTheme) to be used (as opposed to\r\n    `&light` when a light theme is active).\r\n    */\r\n    static theme(spec, options) {\r\n        let prefix = style_mod__WEBPACK_IMPORTED_MODULE_0__.StyleModule.newName();\r\n        let result = [theme.of(prefix), styleModule.of(buildTheme(`.${prefix}`, spec))];\r\n        if (options && options.dark)\r\n            result.push(darkTheme.of(true));\r\n        return result;\r\n    }\r\n    /**\r\n    Create an extension that adds styles to the base theme. Like\r\n    with [`theme`](https://codemirror.net/6/docs/ref/#view.EditorView^theme), use `&` to indicate the\r\n    place of the editor wrapper element when directly targeting\r\n    that. You can also use `&dark` or `&light` instead to only\r\n    target editors with a dark or light theme.\r\n    */\r\n    static baseTheme(spec) {\r\n        return _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Prec.lowest(styleModule.of(buildTheme(\".\" + baseThemeID, spec, lightDarkIDs)));\r\n    }\r\n    /**\r\n    Retrieve an editor view instance from the view's DOM\r\n    representation.\r\n    */\r\n    static findFromDOM(dom) {\r\n        var _a;\r\n        let content = dom.querySelector(\".cm-content\");\r\n        let cView = content && ContentView.get(content) || ContentView.get(dom);\r\n        return ((_a = cView === null || cView === void 0 ? void 0 : cView.rootView) === null || _a === void 0 ? void 0 : _a.view) || null;\r\n    }\r\n}\r\n/**\r\nFacet to add a [style\r\nmodule](https://github.com/marijnh/style-mod#documentation) to\r\nan editor view. The view will ensure that the module is\r\nmounted in its [document\r\nroot](https://codemirror.net/6/docs/ref/#view.EditorView.constructor^config.root).\r\n*/\r\nEditorView.styleModule = styleModule;\r\n/**\r\nAn input handler can override the way changes to the editable\r\nDOM content are handled. Handlers are passed the document\r\npositions between which the change was found, and the new\r\ncontent. When one returns true, no further input handlers are\r\ncalled and the default behavior is prevented.\r\n*/\r\nEditorView.inputHandler = inputHandler;\r\n/**\r\nBy default, the editor assumes all its content has the same\r\n[text direction](https://codemirror.net/6/docs/ref/#view.Direction). Configure this with a `true`\r\nvalue to make it read the text direction of every (rendered)\r\nline separately.\r\n*/\r\nEditorView.perLineTextDirection = perLineTextDirection;\r\n/**\r\nAllows you to provide a function that should be called when the\r\nlibrary catches an exception from an extension (mostly from view\r\nplugins, but may be used by other extensions to route exceptions\r\nfrom user-code-provided callbacks). This is mostly useful for\r\ndebugging and logging. See [`logException`](https://codemirror.net/6/docs/ref/#view.logException).\r\n*/\r\nEditorView.exceptionSink = exceptionSink;\r\n/**\r\nA facet that can be used to register a function to be called\r\nevery time the view updates.\r\n*/\r\nEditorView.updateListener = updateListener;\r\n/**\r\nFacet that controls whether the editor content DOM is editable.\r\nWhen its highest-precedence value is `false`, the element will\r\nnot have its `contenteditable` attribute set. (Note that this\r\ndoesn't affect API calls that change the editor content, even\r\nwhen those are bound to keys or buttons. See the\r\n[`readOnly`](https://codemirror.net/6/docs/ref/#state.EditorState.readOnly) facet for that.)\r\n*/\r\nEditorView.editable = editable;\r\n/**\r\nAllows you to influence the way mouse selection happens. The\r\nfunctions in this facet will be called for a `mousedown` event\r\non the editor, and can return an object that overrides the way a\r\nselection is computed from that mouse click or drag.\r\n*/\r\nEditorView.mouseSelectionStyle = mouseSelectionStyle;\r\n/**\r\nFacet used to configure whether a given selection drag event\r\nshould move or copy the selection. The given predicate will be\r\ncalled with the `mousedown` event, and can return `true` when\r\nthe drag should move the content.\r\n*/\r\nEditorView.dragMovesSelection = dragMovesSelection$1;\r\n/**\r\nFacet used to configure whether a given selecting click adds a\r\nnew range to the existing selection or replaces it entirely. The\r\ndefault behavior is to check `event.metaKey` on macOS, and\r\n`event.ctrlKey` elsewhere.\r\n*/\r\nEditorView.clickAddsSelectionRange = clickAddsSelectionRange;\r\n/**\r\nA facet that determines which [decorations](https://codemirror.net/6/docs/ref/#view.Decoration)\r\nare shown in the view. Decorations can be provided in two\r\nways—directly, or via a function that takes an editor view.\r\n\r\nOnly decoration sets provided directly are allowed to influence\r\nthe editor's vertical layout structure. The ones provided as\r\nfunctions are called _after_ the new viewport has been computed,\r\nand thus **must not** introduce block widgets or replacing\r\ndecorations that cover line breaks.\r\n\r\nIf you want decorated ranges to behave like atomic units for\r\ncursor motion and deletion purposes, also provide the range set\r\ncontaining the decorations to\r\n[`EditorView.atomicRanges`](https://codemirror.net/6/docs/ref/#view.EditorView^atomicRanges).\r\n*/\r\nEditorView.decorations = decorations;\r\n/**\r\nUsed to provide ranges that should be treated as atoms as far as\r\ncursor motion is concerned. This causes methods like\r\n[`moveByChar`](https://codemirror.net/6/docs/ref/#view.EditorView.moveByChar) and\r\n[`moveVertically`](https://codemirror.net/6/docs/ref/#view.EditorView.moveVertically) (and the\r\ncommands built on top of them) to skip across such regions when\r\na selection endpoint would enter them. This does _not_ prevent\r\ndirect programmatic [selection\r\nupdates](https://codemirror.net/6/docs/ref/#state.TransactionSpec.selection) from moving into such\r\nregions.\r\n*/\r\nEditorView.atomicRanges = atomicRanges;\r\n/**\r\nFacet that allows extensions to provide additional scroll\r\nmargins (space around the sides of the scrolling element that\r\nshould be considered invisible). This can be useful when the\r\nplugin introduces elements that cover part of that element (for\r\nexample a horizontally fixed gutter).\r\n*/\r\nEditorView.scrollMargins = scrollMargins;\r\n/**\r\nThis facet records whether a dark theme is active. The extension\r\nreturned by [`theme`](https://codemirror.net/6/docs/ref/#view.EditorView^theme) automatically\r\nincludes an instance of this when the `dark` option is set to\r\ntrue.\r\n*/\r\nEditorView.darkTheme = darkTheme;\r\n/**\r\nFacet that provides additional DOM attributes for the editor's\r\neditable DOM element.\r\n*/\r\nEditorView.contentAttributes = contentAttributes;\r\n/**\r\nFacet that provides DOM attributes for the editor's outer\r\nelement.\r\n*/\r\nEditorView.editorAttributes = editorAttributes;\r\n/**\r\nAn extension that enables line wrapping in the editor (by\r\nsetting CSS `white-space` to `pre-wrap` in the content).\r\n*/\r\nEditorView.lineWrapping = /*@__PURE__*/EditorView.contentAttributes.of({ \"class\": \"cm-lineWrapping\" });\r\n/**\r\nState effect used to include screen reader announcements in a\r\ntransaction. These will be added to the DOM in a visually hidden\r\nelement with `aria-live=\"polite\"` set, and should be used to\r\ndescribe effects that are visually obvious but may not be\r\nnoticed by screen reader users (such as moving to the next\r\nsearch match).\r\n*/\r\nEditorView.announce = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.StateEffect.define();\r\n// Maximum line length for which we compute accurate bidi info\r\nconst MaxBidiLine = 4096;\r\nconst BadMeasure = {};\r\nclass CachedOrder {\r\n    constructor(from, to, dir, order) {\r\n        this.from = from;\r\n        this.to = to;\r\n        this.dir = dir;\r\n        this.order = order;\r\n    }\r\n    static update(cache, changes) {\r\n        if (changes.empty)\r\n            return cache;\r\n        let result = [], lastDir = cache.length ? cache[cache.length - 1].dir : Direction.LTR;\r\n        for (let i = Math.max(0, cache.length - 10); i < cache.length; i++) {\r\n            let entry = cache[i];\r\n            if (entry.dir == lastDir && !changes.touchesRange(entry.from, entry.to))\r\n                result.push(new CachedOrder(changes.mapPos(entry.from, 1), changes.mapPos(entry.to, -1), entry.dir, entry.order));\r\n        }\r\n        return result;\r\n    }\r\n}\r\nfunction attrsFromFacet(view, facet, base) {\r\n    for (let sources = view.state.facet(facet), i = sources.length - 1; i >= 0; i--) {\r\n        let source = sources[i], value = typeof source == \"function\" ? source(view) : source;\r\n        if (value)\r\n            combineAttrs(value, base);\r\n    }\r\n    return base;\r\n}\r\n\r\nconst currentPlatform = browser.mac ? \"mac\" : browser.windows ? \"win\" : browser.linux ? \"linux\" : \"key\";\r\nfunction normalizeKeyName(name, platform) {\r\n    const parts = name.split(/-(?!$)/);\r\n    let result = parts[parts.length - 1];\r\n    if (result == \"Space\")\r\n        result = \" \";\r\n    let alt, ctrl, shift, meta;\r\n    for (let i = 0; i < parts.length - 1; ++i) {\r\n        const mod = parts[i];\r\n        if (/^(cmd|meta|m)$/i.test(mod))\r\n            meta = true;\r\n        else if (/^a(lt)?$/i.test(mod))\r\n            alt = true;\r\n        else if (/^(c|ctrl|control)$/i.test(mod))\r\n            ctrl = true;\r\n        else if (/^s(hift)?$/i.test(mod))\r\n            shift = true;\r\n        else if (/^mod$/i.test(mod)) {\r\n            if (platform == \"mac\")\r\n                meta = true;\r\n            else\r\n                ctrl = true;\r\n        }\r\n        else\r\n            throw new Error(\"Unrecognized modifier name: \" + mod);\r\n    }\r\n    if (alt)\r\n        result = \"Alt-\" + result;\r\n    if (ctrl)\r\n        result = \"Ctrl-\" + result;\r\n    if (meta)\r\n        result = \"Meta-\" + result;\r\n    if (shift)\r\n        result = \"Shift-\" + result;\r\n    return result;\r\n}\r\nfunction modifiers(name, event, shift) {\r\n    if (event.altKey)\r\n        name = \"Alt-\" + name;\r\n    if (event.ctrlKey)\r\n        name = \"Ctrl-\" + name;\r\n    if (event.metaKey)\r\n        name = \"Meta-\" + name;\r\n    if (shift !== false && event.shiftKey)\r\n        name = \"Shift-\" + name;\r\n    return name;\r\n}\r\nconst handleKeyEvents = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Prec[\"default\"](/*@__PURE__*/EditorView.domEventHandlers({\r\n    keydown(event, view) {\r\n        return runHandlers(getKeymap(view.state), event, view, \"editor\");\r\n    }\r\n}));\r\n/**\r\nFacet used for registering keymaps.\r\n\r\nYou can add multiple keymaps to an editor. Their priorities\r\ndetermine their precedence (the ones specified early or with high\r\npriority get checked first). When a handler has returned `true`\r\nfor a given key, no further handlers are called.\r\n*/\r\nconst keymap = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define({ enables: handleKeyEvents });\r\nconst Keymaps = /*@__PURE__*/new WeakMap();\r\n// This is hidden behind an indirection, rather than directly computed\r\n// by the facet, to keep internal types out of the facet's type.\r\nfunction getKeymap(state) {\r\n    let bindings = state.facet(keymap);\r\n    let map = Keymaps.get(bindings);\r\n    if (!map)\r\n        Keymaps.set(bindings, map = buildKeymap(bindings.reduce((a, b) => a.concat(b), [])));\r\n    return map;\r\n}\r\n/**\r\nRun the key handlers registered for a given scope. The event\r\nobject should be a `\"keydown\"` event. Returns true if any of the\r\nhandlers handled it.\r\n*/\r\nfunction runScopeHandlers(view, event, scope) {\r\n    return runHandlers(getKeymap(view.state), event, view, scope);\r\n}\r\nlet storedPrefix = null;\r\nconst PrefixTimeout = 4000;\r\nfunction buildKeymap(bindings, platform = currentPlatform) {\r\n    let bound = Object.create(null);\r\n    let isPrefix = Object.create(null);\r\n    let checkPrefix = (name, is) => {\r\n        let current = isPrefix[name];\r\n        if (current == null)\r\n            isPrefix[name] = is;\r\n        else if (current != is)\r\n            throw new Error(\"Key binding \" + name + \" is used both as a regular binding and as a multi-stroke prefix\");\r\n    };\r\n    let add = (scope, key, command, preventDefault) => {\r\n        var _a, _b;\r\n        let scopeObj = bound[scope] || (bound[scope] = Object.create(null));\r\n        let parts = key.split(/ (?!$)/).map(k => normalizeKeyName(k, platform));\r\n        for (let i = 1; i < parts.length; i++) {\r\n            let prefix = parts.slice(0, i).join(\" \");\r\n            checkPrefix(prefix, true);\r\n            if (!scopeObj[prefix])\r\n                scopeObj[prefix] = {\r\n                    preventDefault: true,\r\n                    run: [(view) => {\r\n                            let ourObj = storedPrefix = { view, prefix, scope };\r\n                            setTimeout(() => { if (storedPrefix == ourObj)\r\n                                storedPrefix = null; }, PrefixTimeout);\r\n                            return true;\r\n                        }]\r\n                };\r\n        }\r\n        let full = parts.join(\" \");\r\n        checkPrefix(full, false);\r\n        let binding = scopeObj[full] || (scopeObj[full] = { preventDefault: false, run: ((_b = (_a = scopeObj._any) === null || _a === void 0 ? void 0 : _a.run) === null || _b === void 0 ? void 0 : _b.slice()) || [] });\r\n        if (command)\r\n            binding.run.push(command);\r\n        if (preventDefault)\r\n            binding.preventDefault = true;\r\n    };\r\n    for (let b of bindings) {\r\n        let scopes = b.scope ? b.scope.split(\" \") : [\"editor\"];\r\n        if (b.any)\r\n            for (let scope of scopes) {\r\n                let scopeObj = bound[scope] || (bound[scope] = Object.create(null));\r\n                if (!scopeObj._any)\r\n                    scopeObj._any = { preventDefault: false, run: [] };\r\n                for (let key in scopeObj)\r\n                    scopeObj[key].run.push(b.any);\r\n            }\r\n        let name = b[platform] || b.key;\r\n        if (!name)\r\n            continue;\r\n        for (let scope of scopes) {\r\n            add(scope, name, b.run, b.preventDefault);\r\n            if (b.shift)\r\n                add(scope, \"Shift-\" + name, b.shift, b.preventDefault);\r\n        }\r\n    }\r\n    return bound;\r\n}\r\nfunction runHandlers(map, event, view, scope) {\r\n    let name = (0,w3c_keyname__WEBPACK_IMPORTED_MODULE_1__.keyName)(event);\r\n    let charCode = (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.codePointAt)(name, 0), isChar = (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.codePointSize)(charCode) == name.length && name != \" \";\r\n    let prefix = \"\", fallthrough = false;\r\n    if (storedPrefix && storedPrefix.view == view && storedPrefix.scope == scope) {\r\n        prefix = storedPrefix.prefix + \" \";\r\n        if (fallthrough = modifierCodes.indexOf(event.keyCode) < 0)\r\n            storedPrefix = null;\r\n    }\r\n    let ran = new Set;\r\n    let runFor = (binding) => {\r\n        if (binding) {\r\n            for (let cmd of binding.run)\r\n                if (!ran.has(cmd)) {\r\n                    ran.add(cmd);\r\n                    if (cmd(view, event))\r\n                        return true;\r\n                }\r\n            if (binding.preventDefault)\r\n                fallthrough = true;\r\n        }\r\n        return false;\r\n    };\r\n    let scopeObj = map[scope], baseName, shiftName;\r\n    if (scopeObj) {\r\n        if (runFor(scopeObj[prefix + modifiers(name, event, !isChar)]))\r\n            return true;\r\n        if (isChar && (event.altKey || event.metaKey || event.ctrlKey) &&\r\n            // Ctrl-Alt may be used for AltGr on Windows\r\n            !(browser.windows && event.ctrlKey && event.altKey) &&\r\n            (baseName = w3c_keyname__WEBPACK_IMPORTED_MODULE_1__.base[event.keyCode]) && baseName != name) {\r\n            if (runFor(scopeObj[prefix + modifiers(baseName, event, true)]))\r\n                return true;\r\n            else if (event.shiftKey && (shiftName = w3c_keyname__WEBPACK_IMPORTED_MODULE_1__.shift[event.keyCode]) != name && shiftName != baseName &&\r\n                runFor(scopeObj[prefix + modifiers(shiftName, event, false)]))\r\n                return true;\r\n        }\r\n        else if (isChar && event.shiftKey) {\r\n            if (runFor(scopeObj[prefix + modifiers(name, event, true)]))\r\n                return true;\r\n        }\r\n        if (runFor(scopeObj._any))\r\n            return true;\r\n    }\r\n    return fallthrough;\r\n}\r\n\r\n/**\r\nImplementation of [`LayerMarker`](https://codemirror.net/6/docs/ref/#view.LayerMarker) that creates\r\na rectangle at a given set of coordinates.\r\n*/\r\nclass RectangleMarker {\r\n    /**\r\n    Create a marker with the given class and dimensions. If `width`\r\n    is null, the DOM element will get no width style.\r\n    */\r\n    constructor(className, left, top, width, height) {\r\n        this.className = className;\r\n        this.left = left;\r\n        this.top = top;\r\n        this.width = width;\r\n        this.height = height;\r\n    }\r\n    draw() {\r\n        let elt = document.createElement(\"div\");\r\n        elt.className = this.className;\r\n        this.adjust(elt);\r\n        return elt;\r\n    }\r\n    update(elt, prev) {\r\n        if (prev.className != this.className)\r\n            return false;\r\n        this.adjust(elt);\r\n        return true;\r\n    }\r\n    adjust(elt) {\r\n        elt.style.left = this.left + \"px\";\r\n        elt.style.top = this.top + \"px\";\r\n        if (this.width != null)\r\n            elt.style.width = this.width + \"px\";\r\n        elt.style.height = this.height + \"px\";\r\n    }\r\n    eq(p) {\r\n        return this.left == p.left && this.top == p.top && this.width == p.width && this.height == p.height &&\r\n            this.className == p.className;\r\n    }\r\n    /**\r\n    Create a set of rectangles for the given selection range,\r\n    assigning them theclass`className`. Will create a single\r\n    rectangle for empty ranges, and a set of selection-style\r\n    rectangles covering the range's content (in a bidi-aware\r\n    way) for non-empty ones.\r\n    */\r\n    static forRange(view, className, range) {\r\n        if (range.empty) {\r\n            let pos = view.coordsAtPos(range.head, range.assoc || 1);\r\n            if (!pos)\r\n                return [];\r\n            let base = getBase(view);\r\n            return [new RectangleMarker(className, pos.left - base.left, pos.top - base.top, null, pos.bottom - pos.top)];\r\n        }\r\n        else {\r\n            return rectanglesForRange(view, className, range);\r\n        }\r\n    }\r\n}\r\nfunction getBase(view) {\r\n    let rect = view.scrollDOM.getBoundingClientRect();\r\n    let left = view.textDirection == Direction.LTR ? rect.left : rect.right - view.scrollDOM.clientWidth;\r\n    return { left: left - view.scrollDOM.scrollLeft, top: rect.top - view.scrollDOM.scrollTop };\r\n}\r\nfunction wrappedLine(view, pos, inside) {\r\n    let range = _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.cursor(pos);\r\n    return { from: Math.max(inside.from, view.moveToLineBoundary(range, false, true).from),\r\n        to: Math.min(inside.to, view.moveToLineBoundary(range, true, true).from),\r\n        type: BlockType.Text };\r\n}\r\nfunction blockAt(view, pos) {\r\n    let line = view.lineBlockAt(pos);\r\n    if (Array.isArray(line.type))\r\n        for (let l of line.type) {\r\n            if (l.to > pos || l.to == pos && (l.to == line.to || l.type == BlockType.Text))\r\n                return l;\r\n        }\r\n    return line;\r\n}\r\nfunction rectanglesForRange(view, className, range) {\r\n    if (range.to <= view.viewport.from || range.from >= view.viewport.to)\r\n        return [];\r\n    let from = Math.max(range.from, view.viewport.from), to = Math.min(range.to, view.viewport.to);\r\n    let ltr = view.textDirection == Direction.LTR;\r\n    let content = view.contentDOM, contentRect = content.getBoundingClientRect(), base = getBase(view);\r\n    let lineStyle = window.getComputedStyle(content.firstChild);\r\n    let leftSide = contentRect.left + parseInt(lineStyle.paddingLeft) + Math.min(0, parseInt(lineStyle.textIndent));\r\n    let rightSide = contentRect.right - parseInt(lineStyle.paddingRight);\r\n    let startBlock = blockAt(view, from), endBlock = blockAt(view, to);\r\n    let visualStart = startBlock.type == BlockType.Text ? startBlock : null;\r\n    let visualEnd = endBlock.type == BlockType.Text ? endBlock : null;\r\n    if (view.lineWrapping) {\r\n        if (visualStart)\r\n            visualStart = wrappedLine(view, from, visualStart);\r\n        if (visualEnd)\r\n            visualEnd = wrappedLine(view, to, visualEnd);\r\n    }\r\n    if (visualStart && visualEnd && visualStart.from == visualEnd.from) {\r\n        return pieces(drawForLine(range.from, range.to, visualStart));\r\n    }\r\n    else {\r\n        let top = visualStart ? drawForLine(range.from, null, visualStart) : drawForWidget(startBlock, false);\r\n        let bottom = visualEnd ? drawForLine(null, range.to, visualEnd) : drawForWidget(endBlock, true);\r\n        let between = [];\r\n        if ((visualStart || startBlock).to < (visualEnd || endBlock).from - 1)\r\n            between.push(piece(leftSide, top.bottom, rightSide, bottom.top));\r\n        else if (top.bottom < bottom.top && view.elementAtHeight((top.bottom + bottom.top) / 2).type == BlockType.Text)\r\n            top.bottom = bottom.top = (top.bottom + bottom.top) / 2;\r\n        return pieces(top).concat(between).concat(pieces(bottom));\r\n    }\r\n    function piece(left, top, right, bottom) {\r\n        return new RectangleMarker(className, left - base.left, top - base.top - 0.01 /* C.Epsilon */, right - left, bottom - top + 0.01 /* C.Epsilon */);\r\n    }\r\n    function pieces({ top, bottom, horizontal }) {\r\n        let pieces = [];\r\n        for (let i = 0; i < horizontal.length; i += 2)\r\n            pieces.push(piece(horizontal[i], top, horizontal[i + 1], bottom));\r\n        return pieces;\r\n    }\r\n    // Gets passed from/to in line-local positions\r\n    function drawForLine(from, to, line) {\r\n        let top = 1e9, bottom = -1e9, horizontal = [];\r\n        function addSpan(from, fromOpen, to, toOpen, dir) {\r\n            // Passing 2/-2 is a kludge to force the view to return\r\n            // coordinates on the proper side of block widgets, since\r\n            // normalizing the side there, though appropriate for most\r\n            // coordsAtPos queries, would break selection drawing.\r\n            let fromCoords = view.coordsAtPos(from, (from == line.to ? -2 : 2));\r\n            let toCoords = view.coordsAtPos(to, (to == line.from ? 2 : -2));\r\n            top = Math.min(fromCoords.top, toCoords.top, top);\r\n            bottom = Math.max(fromCoords.bottom, toCoords.bottom, bottom);\r\n            if (dir == Direction.LTR)\r\n                horizontal.push(ltr && fromOpen ? leftSide : fromCoords.left, ltr && toOpen ? rightSide : toCoords.right);\r\n            else\r\n                horizontal.push(!ltr && toOpen ? leftSide : toCoords.left, !ltr && fromOpen ? rightSide : fromCoords.right);\r\n        }\r\n        let start = from !== null && from !== void 0 ? from : line.from, end = to !== null && to !== void 0 ? to : line.to;\r\n        // Split the range by visible range and document line\r\n        for (let r of view.visibleRanges)\r\n            if (r.to > start && r.from < end) {\r\n                for (let pos = Math.max(r.from, start), endPos = Math.min(r.to, end);;) {\r\n                    let docLine = view.state.doc.lineAt(pos);\r\n                    for (let span of view.bidiSpans(docLine)) {\r\n                        let spanFrom = span.from + docLine.from, spanTo = span.to + docLine.from;\r\n                        if (spanFrom >= endPos)\r\n                            break;\r\n                        if (spanTo > pos)\r\n                            addSpan(Math.max(spanFrom, pos), from == null && spanFrom <= start, Math.min(spanTo, endPos), to == null && spanTo >= end, span.dir);\r\n                    }\r\n                    pos = docLine.to + 1;\r\n                    if (pos >= endPos)\r\n                        break;\r\n                }\r\n            }\r\n        if (horizontal.length == 0)\r\n            addSpan(start, from == null, end, to == null, view.textDirection);\r\n        return { top, bottom, horizontal };\r\n    }\r\n    function drawForWidget(block, top) {\r\n        let y = contentRect.top + (top ? block.top : block.bottom);\r\n        return { top: y, bottom: y, horizontal: [] };\r\n    }\r\n}\r\nfunction sameMarker(a, b) {\r\n    return a.constructor == b.constructor && a.eq(b);\r\n}\r\nclass LayerView {\r\n    constructor(view, layer) {\r\n        this.view = view;\r\n        this.layer = layer;\r\n        this.drawn = [];\r\n        this.measureReq = { read: this.measure.bind(this), write: this.draw.bind(this) };\r\n        this.dom = view.scrollDOM.appendChild(document.createElement(\"div\"));\r\n        this.dom.classList.add(\"cm-layer\");\r\n        if (layer.above)\r\n            this.dom.classList.add(\"cm-layer-above\");\r\n        if (layer.class)\r\n            this.dom.classList.add(layer.class);\r\n        this.dom.setAttribute(\"aria-hidden\", \"true\");\r\n        this.setOrder(view.state);\r\n        view.requestMeasure(this.measureReq);\r\n        if (layer.mount)\r\n            layer.mount(this.dom, view);\r\n    }\r\n    update(update) {\r\n        if (update.startState.facet(layerOrder) != update.state.facet(layerOrder))\r\n            this.setOrder(update.state);\r\n        if (this.layer.update(update, this.dom) || update.geometryChanged)\r\n            update.view.requestMeasure(this.measureReq);\r\n    }\r\n    setOrder(state) {\r\n        let pos = 0, order = state.facet(layerOrder);\r\n        while (pos < order.length && order[pos] != this.layer)\r\n            pos++;\r\n        this.dom.style.zIndex = String((this.layer.above ? 150 : -1) - pos);\r\n    }\r\n    measure() {\r\n        return this.layer.markers(this.view);\r\n    }\r\n    draw(markers) {\r\n        if (markers.length != this.drawn.length || markers.some((p, i) => !sameMarker(p, this.drawn[i]))) {\r\n            let old = this.dom.firstChild, oldI = 0;\r\n            for (let marker of markers) {\r\n                if (marker.update && old && marker.constructor && this.drawn[oldI].constructor &&\r\n                    marker.update(old, this.drawn[oldI])) {\r\n                    old = old.nextSibling;\r\n                    oldI++;\r\n                }\r\n                else {\r\n                    this.dom.insertBefore(marker.draw(), old);\r\n                }\r\n            }\r\n            while (old) {\r\n                let next = old.nextSibling;\r\n                old.remove();\r\n                old = next;\r\n            }\r\n            this.drawn = markers;\r\n        }\r\n    }\r\n    destroy() {\r\n        if (this.layer.destroy)\r\n            this.layer.destroy(this.dom, this.view);\r\n        this.dom.remove();\r\n    }\r\n}\r\nconst layerOrder = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define();\r\n/**\r\nDefine a layer.\r\n*/\r\nfunction layer(config) {\r\n    return [\r\n        ViewPlugin.define(v => new LayerView(v, config)),\r\n        layerOrder.of(config)\r\n    ];\r\n}\r\n\r\nconst CanHidePrimary = !browser.ios; // FIXME test IE\r\nconst selectionConfig = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define({\r\n    combine(configs) {\r\n        return (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.combineConfig)(configs, {\r\n            cursorBlinkRate: 1200,\r\n            drawRangeCursor: true\r\n        }, {\r\n            cursorBlinkRate: (a, b) => Math.min(a, b),\r\n            drawRangeCursor: (a, b) => a || b\r\n        });\r\n    }\r\n});\r\n/**\r\nReturns an extension that hides the browser's native selection and\r\ncursor, replacing the selection with a background behind the text\r\n(with the `cm-selectionBackground` class), and the\r\ncursors with elements overlaid over the code (using\r\n`cm-cursor-primary` and `cm-cursor-secondary`).\r\n\r\nThis allows the editor to display secondary selection ranges, and\r\ntends to produce a type of selection more in line with that users\r\nexpect in a text editor (the native selection styling will often\r\nleave gaps between lines and won't fill the horizontal space after\r\na line when the selection continues past it).\r\n\r\nIt does have a performance cost, in that it requires an extra DOM\r\nlayout cycle for many updates (the selection is drawn based on DOM\r\nlayout information that's only available after laying out the\r\ncontent).\r\n*/\r\nfunction drawSelection(config = {}) {\r\n    return [\r\n        selectionConfig.of(config),\r\n        cursorLayer,\r\n        selectionLayer,\r\n        hideNativeSelection,\r\n        nativeSelectionHidden.of(true)\r\n    ];\r\n}\r\nfunction configChanged(update) {\r\n    return update.startState.facet(selectionConfig) != update.state.facet(selectionConfig);\r\n}\r\nconst cursorLayer = /*@__PURE__*/layer({\r\n    above: true,\r\n    markers(view) {\r\n        let { state } = view, conf = state.facet(selectionConfig);\r\n        let cursors = [];\r\n        for (let r of state.selection.ranges) {\r\n            let prim = r == state.selection.main;\r\n            if (r.empty ? !prim || CanHidePrimary : conf.drawRangeCursor) {\r\n                let className = prim ? \"cm-cursor cm-cursor-primary\" : \"cm-cursor cm-cursor-secondary\";\r\n                let cursor = r.empty ? r : _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.cursor(r.head, r.head > r.anchor ? -1 : 1);\r\n                for (let piece of RectangleMarker.forRange(view, className, cursor))\r\n                    cursors.push(piece);\r\n            }\r\n        }\r\n        return cursors;\r\n    },\r\n    update(update, dom) {\r\n        if (update.transactions.some(tr => tr.selection))\r\n            dom.style.animationName = dom.style.animationName == \"cm-blink\" ? \"cm-blink2\" : \"cm-blink\";\r\n        let confChange = configChanged(update);\r\n        if (confChange)\r\n            setBlinkRate(update.state, dom);\r\n        return update.docChanged || update.selectionSet || confChange;\r\n    },\r\n    mount(dom, view) {\r\n        setBlinkRate(view.state, dom);\r\n    },\r\n    class: \"cm-cursorLayer\"\r\n});\r\nfunction setBlinkRate(state, dom) {\r\n    dom.style.animationDuration = state.facet(selectionConfig).cursorBlinkRate + \"ms\";\r\n}\r\nconst selectionLayer = /*@__PURE__*/layer({\r\n    above: false,\r\n    markers(view) {\r\n        return view.state.selection.ranges.map(r => r.empty ? [] : RectangleMarker.forRange(view, \"cm-selectionBackground\", r))\r\n            .reduce((a, b) => a.concat(b));\r\n    },\r\n    update(update, dom) {\r\n        return update.docChanged || update.selectionSet || update.viewportChanged || configChanged(update);\r\n    },\r\n    class: \"cm-selectionLayer\"\r\n});\r\nconst themeSpec = {\r\n    \".cm-line\": {\r\n        \"& ::selection\": { backgroundColor: \"transparent !important\" },\r\n        \"&::selection\": { backgroundColor: \"transparent !important\" }\r\n    }\r\n};\r\nif (CanHidePrimary)\r\n    themeSpec[\".cm-line\"].caretColor = \"transparent !important\";\r\nconst hideNativeSelection = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Prec.highest(/*@__PURE__*/EditorView.theme(themeSpec));\r\n\r\nconst setDropCursorPos = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.StateEffect.define({\r\n    map(pos, mapping) { return pos == null ? null : mapping.mapPos(pos); }\r\n});\r\nconst dropCursorPos = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.StateField.define({\r\n    create() { return null; },\r\n    update(pos, tr) {\r\n        if (pos != null)\r\n            pos = tr.changes.mapPos(pos);\r\n        return tr.effects.reduce((pos, e) => e.is(setDropCursorPos) ? e.value : pos, pos);\r\n    }\r\n});\r\nconst drawDropCursor = /*@__PURE__*/ViewPlugin.fromClass(class {\r\n    constructor(view) {\r\n        this.view = view;\r\n        this.cursor = null;\r\n        this.measureReq = { read: this.readPos.bind(this), write: this.drawCursor.bind(this) };\r\n    }\r\n    update(update) {\r\n        var _a;\r\n        let cursorPos = update.state.field(dropCursorPos);\r\n        if (cursorPos == null) {\r\n            if (this.cursor != null) {\r\n                (_a = this.cursor) === null || _a === void 0 ? void 0 : _a.remove();\r\n                this.cursor = null;\r\n            }\r\n        }\r\n        else {\r\n            if (!this.cursor) {\r\n                this.cursor = this.view.scrollDOM.appendChild(document.createElement(\"div\"));\r\n                this.cursor.className = \"cm-dropCursor\";\r\n            }\r\n            if (update.startState.field(dropCursorPos) != cursorPos || update.docChanged || update.geometryChanged)\r\n                this.view.requestMeasure(this.measureReq);\r\n        }\r\n    }\r\n    readPos() {\r\n        let pos = this.view.state.field(dropCursorPos);\r\n        let rect = pos != null && this.view.coordsAtPos(pos);\r\n        if (!rect)\r\n            return null;\r\n        let outer = this.view.scrollDOM.getBoundingClientRect();\r\n        return {\r\n            left: rect.left - outer.left + this.view.scrollDOM.scrollLeft,\r\n            top: rect.top - outer.top + this.view.scrollDOM.scrollTop,\r\n            height: rect.bottom - rect.top\r\n        };\r\n    }\r\n    drawCursor(pos) {\r\n        if (this.cursor) {\r\n            if (pos) {\r\n                this.cursor.style.left = pos.left + \"px\";\r\n                this.cursor.style.top = pos.top + \"px\";\r\n                this.cursor.style.height = pos.height + \"px\";\r\n            }\r\n            else {\r\n                this.cursor.style.left = \"-100000px\";\r\n            }\r\n        }\r\n    }\r\n    destroy() {\r\n        if (this.cursor)\r\n            this.cursor.remove();\r\n    }\r\n    setDropPos(pos) {\r\n        if (this.view.state.field(dropCursorPos) != pos)\r\n            this.view.dispatch({ effects: setDropCursorPos.of(pos) });\r\n    }\r\n}, {\r\n    eventHandlers: {\r\n        dragover(event) {\r\n            this.setDropPos(this.view.posAtCoords({ x: event.clientX, y: event.clientY }));\r\n        },\r\n        dragleave(event) {\r\n            if (event.target == this.view.contentDOM || !this.view.contentDOM.contains(event.relatedTarget))\r\n                this.setDropPos(null);\r\n        },\r\n        dragend() {\r\n            this.setDropPos(null);\r\n        },\r\n        drop() {\r\n            this.setDropPos(null);\r\n        }\r\n    }\r\n});\r\n/**\r\nDraws a cursor at the current drop position when something is\r\ndragged over the editor.\r\n*/\r\nfunction dropCursor() {\r\n    return [dropCursorPos, drawDropCursor];\r\n}\r\n\r\nfunction iterMatches(doc, re, from, to, f) {\r\n    re.lastIndex = 0;\r\n    for (let cursor = doc.iterRange(from, to), pos = from, m; !cursor.next().done; pos += cursor.value.length) {\r\n        if (!cursor.lineBreak)\r\n            while (m = re.exec(cursor.value))\r\n                f(pos + m.index, m);\r\n    }\r\n}\r\nfunction matchRanges(view, maxLength) {\r\n    let visible = view.visibleRanges;\r\n    if (visible.length == 1 && visible[0].from == view.viewport.from &&\r\n        visible[0].to == view.viewport.to)\r\n        return visible;\r\n    let result = [];\r\n    for (let { from, to } of visible) {\r\n        from = Math.max(view.state.doc.lineAt(from).from, from - maxLength);\r\n        to = Math.min(view.state.doc.lineAt(to).to, to + maxLength);\r\n        if (result.length && result[result.length - 1].to >= from)\r\n            result[result.length - 1].to = to;\r\n        else\r\n            result.push({ from, to });\r\n    }\r\n    return result;\r\n}\r\n/**\r\nHelper class used to make it easier to maintain decorations on\r\nvisible code that matches a given regular expression. To be used\r\nin a [view plugin](https://codemirror.net/6/docs/ref/#view.ViewPlugin). Instances of this object\r\nrepresent a matching configuration.\r\n*/\r\nclass MatchDecorator {\r\n    /**\r\n    Create a decorator.\r\n    */\r\n    constructor(config) {\r\n        const { regexp, decoration, decorate, boundary, maxLength = 1000 } = config;\r\n        if (!regexp.global)\r\n            throw new RangeError(\"The regular expression given to MatchDecorator should have its 'g' flag set\");\r\n        this.regexp = regexp;\r\n        if (decorate) {\r\n            this.addMatch = (match, view, from, add) => decorate(add, from, from + match[0].length, match, view);\r\n        }\r\n        else if (typeof decoration == \"function\") {\r\n            this.addMatch = (match, view, from, add) => {\r\n                let deco = decoration(match, view, from);\r\n                if (deco)\r\n                    add(from, from + match[0].length, deco);\r\n            };\r\n        }\r\n        else if (decoration) {\r\n            this.addMatch = (match, _view, from, add) => add(from, from + match[0].length, decoration);\r\n        }\r\n        else {\r\n            throw new RangeError(\"Either 'decorate' or 'decoration' should be provided to MatchDecorator\");\r\n        }\r\n        this.boundary = boundary;\r\n        this.maxLength = maxLength;\r\n    }\r\n    /**\r\n    Compute the full set of decorations for matches in the given\r\n    view's viewport. You'll want to call this when initializing your\r\n    plugin.\r\n    */\r\n    createDeco(view) {\r\n        let build = new _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.RangeSetBuilder(), add = build.add.bind(build);\r\n        for (let { from, to } of matchRanges(view, this.maxLength))\r\n            iterMatches(view.state.doc, this.regexp, from, to, (from, m) => this.addMatch(m, view, from, add));\r\n        return build.finish();\r\n    }\r\n    /**\r\n    Update a set of decorations for a view update. `deco` _must_ be\r\n    the set of decorations produced by _this_ `MatchDecorator` for\r\n    the view state before the update.\r\n    */\r\n    updateDeco(update, deco) {\r\n        let changeFrom = 1e9, changeTo = -1;\r\n        if (update.docChanged)\r\n            update.changes.iterChanges((_f, _t, from, to) => {\r\n                if (to > update.view.viewport.from && from < update.view.viewport.to) {\r\n                    changeFrom = Math.min(from, changeFrom);\r\n                    changeTo = Math.max(to, changeTo);\r\n                }\r\n            });\r\n        if (update.viewportChanged || changeTo - changeFrom > 1000)\r\n            return this.createDeco(update.view);\r\n        if (changeTo > -1)\r\n            return this.updateRange(update.view, deco.map(update.changes), changeFrom, changeTo);\r\n        return deco;\r\n    }\r\n    updateRange(view, deco, updateFrom, updateTo) {\r\n        for (let r of view.visibleRanges) {\r\n            let from = Math.max(r.from, updateFrom), to = Math.min(r.to, updateTo);\r\n            if (to > from) {\r\n                let fromLine = view.state.doc.lineAt(from), toLine = fromLine.to < to ? view.state.doc.lineAt(to) : fromLine;\r\n                let start = Math.max(r.from, fromLine.from), end = Math.min(r.to, toLine.to);\r\n                if (this.boundary) {\r\n                    for (; from > fromLine.from; from--)\r\n                        if (this.boundary.test(fromLine.text[from - 1 - fromLine.from])) {\r\n                            start = from;\r\n                            break;\r\n                        }\r\n                    for (; to < toLine.to; to++)\r\n                        if (this.boundary.test(toLine.text[to - toLine.from])) {\r\n                            end = to;\r\n                            break;\r\n                        }\r\n                }\r\n                let ranges = [], m;\r\n                let add = (from, to, deco) => ranges.push(deco.range(from, to));\r\n                if (fromLine == toLine) {\r\n                    this.regexp.lastIndex = start - fromLine.from;\r\n                    while ((m = this.regexp.exec(fromLine.text)) && m.index < end - fromLine.from)\r\n                        this.addMatch(m, view, m.index + fromLine.from, add);\r\n                }\r\n                else {\r\n                    iterMatches(view.state.doc, this.regexp, start, end, (from, m) => this.addMatch(m, view, from, add));\r\n                }\r\n                deco = deco.update({ filterFrom: start, filterTo: end, filter: (from, to) => from < start || to > end, add: ranges });\r\n            }\r\n        }\r\n        return deco;\r\n    }\r\n}\r\n\r\nconst UnicodeRegexpSupport = /x/.unicode != null ? \"gu\" : \"g\";\r\nconst Specials = /*@__PURE__*/new RegExp(\"[\\u0000-\\u0008\\u000a-\\u001f\\u007f-\\u009f\\u00ad\\u061c\\u200b\\u200e\\u200f\\u2028\\u2029\\u202d\\u202e\\u2066\\u2067\\u2069\\ufeff\\ufff9-\\ufffc]\", UnicodeRegexpSupport);\r\nconst Names = {\r\n    0: \"null\",\r\n    7: \"bell\",\r\n    8: \"backspace\",\r\n    10: \"newline\",\r\n    11: \"vertical tab\",\r\n    13: \"carriage return\",\r\n    27: \"escape\",\r\n    8203: \"zero width space\",\r\n    8204: \"zero width non-joiner\",\r\n    8205: \"zero width joiner\",\r\n    8206: \"left-to-right mark\",\r\n    8207: \"right-to-left mark\",\r\n    8232: \"line separator\",\r\n    8237: \"left-to-right override\",\r\n    8238: \"right-to-left override\",\r\n    8294: \"left-to-right isolate\",\r\n    8295: \"right-to-left isolate\",\r\n    8297: \"pop directional isolate\",\r\n    8233: \"paragraph separator\",\r\n    65279: \"zero width no-break space\",\r\n    65532: \"object replacement\"\r\n};\r\nlet _supportsTabSize = null;\r\nfunction supportsTabSize() {\r\n    var _a;\r\n    if (_supportsTabSize == null && typeof document != \"undefined\" && document.body) {\r\n        let styles = document.body.style;\r\n        _supportsTabSize = ((_a = styles.tabSize) !== null && _a !== void 0 ? _a : styles.MozTabSize) != null;\r\n    }\r\n    return _supportsTabSize || false;\r\n}\r\nconst specialCharConfig = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define({\r\n    combine(configs) {\r\n        let config = (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.combineConfig)(configs, {\r\n            render: null,\r\n            specialChars: Specials,\r\n            addSpecialChars: null\r\n        });\r\n        if (config.replaceTabs = !supportsTabSize())\r\n            config.specialChars = new RegExp(\"\\t|\" + config.specialChars.source, UnicodeRegexpSupport);\r\n        if (config.addSpecialChars)\r\n            config.specialChars = new RegExp(config.specialChars.source + \"|\" + config.addSpecialChars.source, UnicodeRegexpSupport);\r\n        return config;\r\n    }\r\n});\r\n/**\r\nReturns an extension that installs highlighting of special\r\ncharacters.\r\n*/\r\nfunction highlightSpecialChars(\r\n/**\r\nConfiguration options.\r\n*/\r\nconfig = {}) {\r\n    return [specialCharConfig.of(config), specialCharPlugin()];\r\n}\r\nlet _plugin = null;\r\nfunction specialCharPlugin() {\r\n    return _plugin || (_plugin = ViewPlugin.fromClass(class {\r\n        constructor(view) {\r\n            this.view = view;\r\n            this.decorations = Decoration.none;\r\n            this.decorationCache = Object.create(null);\r\n            this.decorator = this.makeDecorator(view.state.facet(specialCharConfig));\r\n            this.decorations = this.decorator.createDeco(view);\r\n        }\r\n        makeDecorator(conf) {\r\n            return new MatchDecorator({\r\n                regexp: conf.specialChars,\r\n                decoration: (m, view, pos) => {\r\n                    let { doc } = view.state;\r\n                    let code = (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.codePointAt)(m[0], 0);\r\n                    if (code == 9) {\r\n                        let line = doc.lineAt(pos);\r\n                        let size = view.state.tabSize, col = (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.countColumn)(line.text, size, pos - line.from);\r\n                        return Decoration.replace({ widget: new TabWidget((size - (col % size)) * this.view.defaultCharacterWidth) });\r\n                    }\r\n                    return this.decorationCache[code] ||\r\n                        (this.decorationCache[code] = Decoration.replace({ widget: new SpecialCharWidget(conf, code) }));\r\n                },\r\n                boundary: conf.replaceTabs ? undefined : /[^]/\r\n            });\r\n        }\r\n        update(update) {\r\n            let conf = update.state.facet(specialCharConfig);\r\n            if (update.startState.facet(specialCharConfig) != conf) {\r\n                this.decorator = this.makeDecorator(conf);\r\n                this.decorations = this.decorator.createDeco(update.view);\r\n            }\r\n            else {\r\n                this.decorations = this.decorator.updateDeco(update, this.decorations);\r\n            }\r\n        }\r\n    }, {\r\n        decorations: v => v.decorations\r\n    }));\r\n}\r\nconst DefaultPlaceholder = \"\\u2022\";\r\n// Assigns placeholder characters from the Control Pictures block to\r\n// ASCII control characters\r\nfunction placeholder$1(code) {\r\n    if (code >= 32)\r\n        return DefaultPlaceholder;\r\n    if (code == 10)\r\n        return \"\\u2424\";\r\n    return String.fromCharCode(9216 + code);\r\n}\r\nclass SpecialCharWidget extends WidgetType {\r\n    constructor(options, code) {\r\n        super();\r\n        this.options = options;\r\n        this.code = code;\r\n    }\r\n    eq(other) { return other.code == this.code; }\r\n    toDOM(view) {\r\n        let ph = placeholder$1(this.code);\r\n        let desc = view.state.phrase(\"Control character\") + \" \" + (Names[this.code] || \"0x\" + this.code.toString(16));\r\n        let custom = this.options.render && this.options.render(this.code, desc, ph);\r\n        if (custom)\r\n            return custom;\r\n        let span = document.createElement(\"span\");\r\n        span.textContent = ph;\r\n        span.title = desc;\r\n        span.setAttribute(\"aria-label\", desc);\r\n        span.className = \"cm-specialChar\";\r\n        return span;\r\n    }\r\n    ignoreEvent() { return false; }\r\n}\r\nclass TabWidget extends WidgetType {\r\n    constructor(width) {\r\n        super();\r\n        this.width = width;\r\n    }\r\n    eq(other) { return other.width == this.width; }\r\n    toDOM() {\r\n        let span = document.createElement(\"span\");\r\n        span.textContent = \"\\t\";\r\n        span.className = \"cm-tab\";\r\n        span.style.width = this.width + \"px\";\r\n        return span;\r\n    }\r\n    ignoreEvent() { return false; }\r\n}\r\n\r\nconst plugin = /*@__PURE__*/ViewPlugin.fromClass(class {\r\n    constructor() {\r\n        this.height = 1000;\r\n        this.attrs = { style: \"padding-bottom: 1000px\" };\r\n    }\r\n    update(update) {\r\n        let { view } = update;\r\n        let height = view.viewState.editorHeight - view.defaultLineHeight - view.documentPadding.top - 0.5;\r\n        if (height != this.height) {\r\n            this.height = height;\r\n            this.attrs = { style: `padding-bottom: ${height}px` };\r\n        }\r\n    }\r\n});\r\n/**\r\nReturns an extension that makes sure the content has a bottom\r\nmargin equivalent to the height of the editor, minus one line\r\nheight, so that every line in the document can be scrolled to the\r\ntop of the editor.\r\n\r\nThis is only meaningful when the editor is scrollable, and should\r\nnot be enabled in editors that take the size of their content.\r\n*/\r\nfunction scrollPastEnd() {\r\n    return [plugin, contentAttributes.of(view => { var _a; return ((_a = view.plugin(plugin)) === null || _a === void 0 ? void 0 : _a.attrs) || null; })];\r\n}\r\n\r\n/**\r\nMark lines that have a cursor on them with the `\"cm-activeLine\"`\r\nDOM class.\r\n*/\r\nfunction highlightActiveLine() {\r\n    return activeLineHighlighter;\r\n}\r\nconst lineDeco = /*@__PURE__*/Decoration.line({ class: \"cm-activeLine\" });\r\nconst activeLineHighlighter = /*@__PURE__*/ViewPlugin.fromClass(class {\r\n    constructor(view) {\r\n        this.decorations = this.getDeco(view);\r\n    }\r\n    update(update) {\r\n        if (update.docChanged || update.selectionSet)\r\n            this.decorations = this.getDeco(update.view);\r\n    }\r\n    getDeco(view) {\r\n        let lastLineStart = -1, deco = [];\r\n        for (let r of view.state.selection.ranges) {\r\n            let line = view.lineBlockAt(r.head);\r\n            if (line.from > lastLineStart) {\r\n                deco.push(lineDeco.range(line.from));\r\n                lastLineStart = line.from;\r\n            }\r\n        }\r\n        return Decoration.set(deco);\r\n    }\r\n}, {\r\n    decorations: v => v.decorations\r\n});\r\n\r\nclass Placeholder extends WidgetType {\r\n    constructor(content) {\r\n        super();\r\n        this.content = content;\r\n    }\r\n    toDOM() {\r\n        let wrap = document.createElement(\"span\");\r\n        wrap.className = \"cm-placeholder\";\r\n        wrap.style.pointerEvents = \"none\";\r\n        wrap.appendChild(typeof this.content == \"string\" ? document.createTextNode(this.content) : this.content);\r\n        if (typeof this.content == \"string\")\r\n            wrap.setAttribute(\"aria-label\", \"placeholder \" + this.content);\r\n        else\r\n            wrap.setAttribute(\"aria-hidden\", \"true\");\r\n        return wrap;\r\n    }\r\n    ignoreEvent() { return false; }\r\n}\r\n/**\r\nExtension that enables a placeholder—a piece of example content\r\nto show when the editor is empty.\r\n*/\r\nfunction placeholder(content) {\r\n    return ViewPlugin.fromClass(class {\r\n        constructor(view) {\r\n            this.view = view;\r\n            this.placeholder = Decoration.set([Decoration.widget({ widget: new Placeholder(content), side: 1 }).range(0)]);\r\n        }\r\n        get decorations() { return this.view.state.doc.length ? Decoration.none : this.placeholder; }\r\n    }, { decorations: v => v.decorations });\r\n}\r\n\r\n// Don't compute precise column positions for line offsets above this\r\n// (since it could get expensive). Assume offset==column for them.\r\nconst MaxOff = 2000;\r\nfunction rectangleFor(state, a, b) {\r\n    let startLine = Math.min(a.line, b.line), endLine = Math.max(a.line, b.line);\r\n    let ranges = [];\r\n    if (a.off > MaxOff || b.off > MaxOff || a.col < 0 || b.col < 0) {\r\n        let startOff = Math.min(a.off, b.off), endOff = Math.max(a.off, b.off);\r\n        for (let i = startLine; i <= endLine; i++) {\r\n            let line = state.doc.line(i);\r\n            if (line.length <= endOff)\r\n                ranges.push(_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.range(line.from + startOff, line.to + endOff));\r\n        }\r\n    }\r\n    else {\r\n        let startCol = Math.min(a.col, b.col), endCol = Math.max(a.col, b.col);\r\n        for (let i = startLine; i <= endLine; i++) {\r\n            let line = state.doc.line(i);\r\n            let start = (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.findColumn)(line.text, startCol, state.tabSize, true);\r\n            if (start < 0) {\r\n                ranges.push(_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.cursor(line.to));\r\n            }\r\n            else {\r\n                let end = (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.findColumn)(line.text, endCol, state.tabSize);\r\n                ranges.push(_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.range(line.from + start, line.from + end));\r\n            }\r\n        }\r\n    }\r\n    return ranges;\r\n}\r\nfunction absoluteColumn(view, x) {\r\n    let ref = view.coordsAtPos(view.viewport.from);\r\n    return ref ? Math.round(Math.abs((ref.left - x) / view.defaultCharacterWidth)) : -1;\r\n}\r\nfunction getPos(view, event) {\r\n    let offset = view.posAtCoords({ x: event.clientX, y: event.clientY }, false);\r\n    let line = view.state.doc.lineAt(offset), off = offset - line.from;\r\n    let col = off > MaxOff ? -1\r\n        : off == line.length ? absoluteColumn(view, event.clientX)\r\n            : (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.countColumn)(line.text, view.state.tabSize, offset - line.from);\r\n    return { line: line.number, col, off };\r\n}\r\nfunction rectangleSelectionStyle(view, event) {\r\n    let start = getPos(view, event), startSel = view.state.selection;\r\n    if (!start)\r\n        return null;\r\n    return {\r\n        update(update) {\r\n            if (update.docChanged) {\r\n                let newStart = update.changes.mapPos(update.startState.doc.line(start.line).from);\r\n                let newLine = update.state.doc.lineAt(newStart);\r\n                start = { line: newLine.number, col: start.col, off: Math.min(start.off, newLine.length) };\r\n                startSel = startSel.map(update.changes);\r\n            }\r\n        },\r\n        get(event, _extend, multiple) {\r\n            let cur = getPos(view, event);\r\n            if (!cur)\r\n                return startSel;\r\n            let ranges = rectangleFor(view.state, start, cur);\r\n            if (!ranges.length)\r\n                return startSel;\r\n            if (multiple)\r\n                return _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.create(ranges.concat(startSel.ranges));\r\n            else\r\n                return _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.create(ranges);\r\n        }\r\n    };\r\n}\r\n/**\r\nCreate an extension that enables rectangular selections. By\r\ndefault, it will react to left mouse drag with the Alt key held\r\ndown. When such a selection occurs, the text within the rectangle\r\nthat was dragged over will be selected, as one selection\r\n[range](https://codemirror.net/6/docs/ref/#state.SelectionRange) per line.\r\n*/\r\nfunction rectangularSelection(options) {\r\n    let filter = (options === null || options === void 0 ? void 0 : options.eventFilter) || (e => e.altKey && e.button == 0);\r\n    return EditorView.mouseSelectionStyle.of((view, event) => filter(event) ? rectangleSelectionStyle(view, event) : null);\r\n}\r\nconst keys = {\r\n    Alt: [18, e => e.altKey],\r\n    Control: [17, e => e.ctrlKey],\r\n    Shift: [16, e => e.shiftKey],\r\n    Meta: [91, e => e.metaKey]\r\n};\r\nconst showCrosshair = { style: \"cursor: crosshair\" };\r\n/**\r\nReturns an extension that turns the pointer cursor into a\r\ncrosshair when a given modifier key, defaulting to Alt, is held\r\ndown. Can serve as a visual hint that rectangular selection is\r\ngoing to happen when paired with\r\n[`rectangularSelection`](https://codemirror.net/6/docs/ref/#view.rectangularSelection).\r\n*/\r\nfunction crosshairCursor(options = {}) {\r\n    let [code, getter] = keys[options.key || \"Alt\"];\r\n    let plugin = ViewPlugin.fromClass(class {\r\n        constructor(view) {\r\n            this.view = view;\r\n            this.isDown = false;\r\n        }\r\n        set(isDown) {\r\n            if (this.isDown != isDown) {\r\n                this.isDown = isDown;\r\n                this.view.update([]);\r\n            }\r\n        }\r\n    }, {\r\n        eventHandlers: {\r\n            keydown(e) {\r\n                this.set(e.keyCode == code || getter(e));\r\n            },\r\n            keyup(e) {\r\n                if (e.keyCode == code || !getter(e))\r\n                    this.set(false);\r\n            },\r\n            mousemove(e) {\r\n                this.set(getter(e));\r\n            }\r\n        }\r\n    });\r\n    return [\r\n        plugin,\r\n        EditorView.contentAttributes.of(view => { var _a; return ((_a = view.plugin(plugin)) === null || _a === void 0 ? void 0 : _a.isDown) ? showCrosshair : null; })\r\n    ];\r\n}\r\n\r\nconst Outside = \"-10000px\";\r\nclass TooltipViewManager {\r\n    constructor(view, facet, createTooltipView) {\r\n        this.facet = facet;\r\n        this.createTooltipView = createTooltipView;\r\n        this.input = view.state.facet(facet);\r\n        this.tooltips = this.input.filter(t => t);\r\n        this.tooltipViews = this.tooltips.map(createTooltipView);\r\n    }\r\n    update(update) {\r\n        var _a;\r\n        let input = update.state.facet(this.facet);\r\n        let tooltips = input.filter(x => x);\r\n        if (input === this.input) {\r\n            for (let t of this.tooltipViews)\r\n                if (t.update)\r\n                    t.update(update);\r\n            return false;\r\n        }\r\n        let tooltipViews = [];\r\n        for (let i = 0; i < tooltips.length; i++) {\r\n            let tip = tooltips[i], known = -1;\r\n            if (!tip)\r\n                continue;\r\n            for (let i = 0; i < this.tooltips.length; i++) {\r\n                let other = this.tooltips[i];\r\n                if (other && other.create == tip.create)\r\n                    known = i;\r\n            }\r\n            if (known < 0) {\r\n                tooltipViews[i] = this.createTooltipView(tip);\r\n            }\r\n            else {\r\n                let tooltipView = tooltipViews[i] = this.tooltipViews[known];\r\n                if (tooltipView.update)\r\n                    tooltipView.update(update);\r\n            }\r\n        }\r\n        for (let t of this.tooltipViews)\r\n            if (tooltipViews.indexOf(t) < 0) {\r\n                t.dom.remove();\r\n                (_a = t.destroy) === null || _a === void 0 ? void 0 : _a.call(t);\r\n            }\r\n        this.input = input;\r\n        this.tooltips = tooltips;\r\n        this.tooltipViews = tooltipViews;\r\n        return true;\r\n    }\r\n}\r\n/**\r\nCreates an extension that configures tooltip behavior.\r\n*/\r\nfunction tooltips(config = {}) {\r\n    return tooltipConfig.of(config);\r\n}\r\nfunction windowSpace(view) {\r\n    let { win } = view;\r\n    return { top: 0, left: 0, bottom: win.innerHeight, right: win.innerWidth };\r\n}\r\nconst tooltipConfig = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define({\r\n    combine: values => {\r\n        var _a, _b, _c;\r\n        return ({\r\n            position: browser.ios ? \"absolute\" : ((_a = values.find(conf => conf.position)) === null || _a === void 0 ? void 0 : _a.position) || \"fixed\",\r\n            parent: ((_b = values.find(conf => conf.parent)) === null || _b === void 0 ? void 0 : _b.parent) || null,\r\n            tooltipSpace: ((_c = values.find(conf => conf.tooltipSpace)) === null || _c === void 0 ? void 0 : _c.tooltipSpace) || windowSpace,\r\n        });\r\n    }\r\n});\r\nconst tooltipPlugin = /*@__PURE__*/ViewPlugin.fromClass(class {\r\n    constructor(view) {\r\n        this.view = view;\r\n        this.inView = true;\r\n        this.lastTransaction = 0;\r\n        this.measureTimeout = -1;\r\n        let config = view.state.facet(tooltipConfig);\r\n        this.position = config.position;\r\n        this.parent = config.parent;\r\n        this.classes = view.themeClasses;\r\n        this.createContainer();\r\n        this.measureReq = { read: this.readMeasure.bind(this), write: this.writeMeasure.bind(this), key: this };\r\n        this.manager = new TooltipViewManager(view, showTooltip, t => this.createTooltip(t));\r\n        this.intersectionObserver = typeof IntersectionObserver == \"function\" ? new IntersectionObserver(entries => {\r\n            if (Date.now() > this.lastTransaction - 50 &&\r\n                entries.length > 0 && entries[entries.length - 1].intersectionRatio < 1)\r\n                this.measureSoon();\r\n        }, { threshold: [1] }) : null;\r\n        this.observeIntersection();\r\n        view.win.addEventListener(\"resize\", this.measureSoon = this.measureSoon.bind(this));\r\n        this.maybeMeasure();\r\n    }\r\n    createContainer() {\r\n        if (this.parent) {\r\n            this.container = document.createElement(\"div\");\r\n            this.container.style.position = \"relative\";\r\n            this.container.className = this.view.themeClasses;\r\n            this.parent.appendChild(this.container);\r\n        }\r\n        else {\r\n            this.container = this.view.dom;\r\n        }\r\n    }\r\n    observeIntersection() {\r\n        if (this.intersectionObserver) {\r\n            this.intersectionObserver.disconnect();\r\n            for (let tooltip of this.manager.tooltipViews)\r\n                this.intersectionObserver.observe(tooltip.dom);\r\n        }\r\n    }\r\n    measureSoon() {\r\n        if (this.measureTimeout < 0)\r\n            this.measureTimeout = setTimeout(() => {\r\n                this.measureTimeout = -1;\r\n                this.maybeMeasure();\r\n            }, 50);\r\n    }\r\n    update(update) {\r\n        if (update.transactions.length)\r\n            this.lastTransaction = Date.now();\r\n        let updated = this.manager.update(update);\r\n        if (updated)\r\n            this.observeIntersection();\r\n        let shouldMeasure = updated || update.geometryChanged;\r\n        let newConfig = update.state.facet(tooltipConfig);\r\n        if (newConfig.position != this.position) {\r\n            this.position = newConfig.position;\r\n            for (let t of this.manager.tooltipViews)\r\n                t.dom.style.position = this.position;\r\n            shouldMeasure = true;\r\n        }\r\n        if (newConfig.parent != this.parent) {\r\n            if (this.parent)\r\n                this.container.remove();\r\n            this.parent = newConfig.parent;\r\n            this.createContainer();\r\n            for (let t of this.manager.tooltipViews)\r\n                this.container.appendChild(t.dom);\r\n            shouldMeasure = true;\r\n        }\r\n        else if (this.parent && this.view.themeClasses != this.classes) {\r\n            this.classes = this.container.className = this.view.themeClasses;\r\n        }\r\n        if (shouldMeasure)\r\n            this.maybeMeasure();\r\n    }\r\n    createTooltip(tooltip) {\r\n        let tooltipView = tooltip.create(this.view);\r\n        tooltipView.dom.classList.add(\"cm-tooltip\");\r\n        if (tooltip.arrow && !tooltipView.dom.querySelector(\".cm-tooltip > .cm-tooltip-arrow\")) {\r\n            let arrow = document.createElement(\"div\");\r\n            arrow.className = \"cm-tooltip-arrow\";\r\n            tooltipView.dom.appendChild(arrow);\r\n        }\r\n        tooltipView.dom.style.position = this.position;\r\n        tooltipView.dom.style.top = Outside;\r\n        this.container.appendChild(tooltipView.dom);\r\n        if (tooltipView.mount)\r\n            tooltipView.mount(this.view);\r\n        return tooltipView;\r\n    }\r\n    destroy() {\r\n        var _a, _b;\r\n        this.view.win.removeEventListener(\"resize\", this.measureSoon);\r\n        for (let tooltipView of this.manager.tooltipViews) {\r\n            tooltipView.dom.remove();\r\n            (_a = tooltipView.destroy) === null || _a === void 0 ? void 0 : _a.call(tooltipView);\r\n        }\r\n        (_b = this.intersectionObserver) === null || _b === void 0 ? void 0 : _b.disconnect();\r\n        clearTimeout(this.measureTimeout);\r\n    }\r\n    readMeasure() {\r\n        let editor = this.view.dom.getBoundingClientRect();\r\n        return {\r\n            editor,\r\n            parent: this.parent ? this.container.getBoundingClientRect() : editor,\r\n            pos: this.manager.tooltips.map((t, i) => {\r\n                let tv = this.manager.tooltipViews[i];\r\n                return tv.getCoords ? tv.getCoords(t.pos) : this.view.coordsAtPos(t.pos);\r\n            }),\r\n            size: this.manager.tooltipViews.map(({ dom }) => dom.getBoundingClientRect()),\r\n            space: this.view.state.facet(tooltipConfig).tooltipSpace(this.view),\r\n        };\r\n    }\r\n    writeMeasure(measured) {\r\n        let { editor, space } = measured;\r\n        let others = [];\r\n        for (let i = 0; i < this.manager.tooltips.length; i++) {\r\n            let tooltip = this.manager.tooltips[i], tView = this.manager.tooltipViews[i], { dom } = tView;\r\n            let pos = measured.pos[i], size = measured.size[i];\r\n            // Hide tooltips that are outside of the editor.\r\n            if (!pos || pos.bottom <= Math.max(editor.top, space.top) ||\r\n                pos.top >= Math.min(editor.bottom, space.bottom) ||\r\n                pos.right < Math.max(editor.left, space.left) - .1 ||\r\n                pos.left > Math.min(editor.right, space.right) + .1) {\r\n                dom.style.top = Outside;\r\n                continue;\r\n            }\r\n            let arrow = tooltip.arrow ? tView.dom.querySelector(\".cm-tooltip-arrow\") : null;\r\n            let arrowHeight = arrow ? 7 /* Arrow.Size */ : 0;\r\n            let width = size.right - size.left, height = size.bottom - size.top;\r\n            let offset = tView.offset || noOffset, ltr = this.view.textDirection == Direction.LTR;\r\n            let left = size.width > space.right - space.left ? (ltr ? space.left : space.right - size.width)\r\n                : ltr ? Math.min(pos.left - (arrow ? 14 /* Arrow.Offset */ : 0) + offset.x, space.right - width)\r\n                    : Math.max(space.left, pos.left - width + (arrow ? 14 /* Arrow.Offset */ : 0) - offset.x);\r\n            let above = !!tooltip.above;\r\n            if (!tooltip.strictSide && (above\r\n                ? pos.top - (size.bottom - size.top) - offset.y < space.top\r\n                : pos.bottom + (size.bottom - size.top) + offset.y > space.bottom) &&\r\n                above == (space.bottom - pos.bottom > pos.top - space.top))\r\n                above = !above;\r\n            let spaceVert = (above ? pos.top - space.top : space.bottom - pos.bottom) - arrowHeight;\r\n            if (spaceVert < height && tView.resize !== false) {\r\n                if (spaceVert < this.view.defaultLineHeight) {\r\n                    dom.style.top = Outside;\r\n                    continue;\r\n                }\r\n                dom.style.height = (height = spaceVert) + \"px\";\r\n            }\r\n            else if (dom.style.height) {\r\n                dom.style.height = \"\";\r\n            }\r\n            let top = above ? pos.top - height - arrowHeight - offset.y : pos.bottom + arrowHeight + offset.y;\r\n            let right = left + width;\r\n            if (tView.overlap !== true)\r\n                for (let r of others)\r\n                    if (r.left < right && r.right > left && r.top < top + height && r.bottom > top)\r\n                        top = above ? r.top - height - 2 - arrowHeight : r.bottom + arrowHeight + 2;\r\n            if (this.position == \"absolute\") {\r\n                dom.style.top = (top - measured.parent.top) + \"px\";\r\n                dom.style.left = (left - measured.parent.left) + \"px\";\r\n            }\r\n            else {\r\n                dom.style.top = top + \"px\";\r\n                dom.style.left = left + \"px\";\r\n            }\r\n            if (arrow)\r\n                arrow.style.left = `${pos.left + (ltr ? offset.x : -offset.x) - (left + 14 /* Arrow.Offset */ - 7 /* Arrow.Size */)}px`;\r\n            if (tView.overlap !== true)\r\n                others.push({ left, top, right, bottom: top + height });\r\n            dom.classList.toggle(\"cm-tooltip-above\", above);\r\n            dom.classList.toggle(\"cm-tooltip-below\", !above);\r\n            if (tView.positioned)\r\n                tView.positioned(measured.space);\r\n        }\r\n    }\r\n    maybeMeasure() {\r\n        if (this.manager.tooltips.length) {\r\n            if (this.view.inView)\r\n                this.view.requestMeasure(this.measureReq);\r\n            if (this.inView != this.view.inView) {\r\n                this.inView = this.view.inView;\r\n                if (!this.inView)\r\n                    for (let tv of this.manager.tooltipViews)\r\n                        tv.dom.style.top = Outside;\r\n            }\r\n        }\r\n    }\r\n}, {\r\n    eventHandlers: {\r\n        scroll() { this.maybeMeasure(); }\r\n    }\r\n});\r\nconst baseTheme = /*@__PURE__*/EditorView.baseTheme({\r\n    \".cm-tooltip\": {\r\n        zIndex: 100,\r\n        boxSizing: \"border-box\"\r\n    },\r\n    \"&light .cm-tooltip\": {\r\n        border: \"1px solid #bbb\",\r\n        backgroundColor: \"#f5f5f5\"\r\n    },\r\n    \"&light .cm-tooltip-section:not(:first-child)\": {\r\n        borderTop: \"1px solid #bbb\",\r\n    },\r\n    \"&dark .cm-tooltip\": {\r\n        backgroundColor: \"#333338\",\r\n        color: \"white\"\r\n    },\r\n    \".cm-tooltip-arrow\": {\r\n        height: `${7 /* Arrow.Size */}px`,\r\n        width: `${7 /* Arrow.Size */ * 2}px`,\r\n        position: \"absolute\",\r\n        zIndex: -1,\r\n        overflow: \"hidden\",\r\n        \"&:before, &:after\": {\r\n            content: \"''\",\r\n            position: \"absolute\",\r\n            width: 0,\r\n            height: 0,\r\n            borderLeft: `${7 /* Arrow.Size */}px solid transparent`,\r\n            borderRight: `${7 /* Arrow.Size */}px solid transparent`,\r\n        },\r\n        \".cm-tooltip-above &\": {\r\n            bottom: `-${7 /* Arrow.Size */}px`,\r\n            \"&:before\": {\r\n                borderTop: `${7 /* Arrow.Size */}px solid #bbb`,\r\n            },\r\n            \"&:after\": {\r\n                borderTop: `${7 /* Arrow.Size */}px solid #f5f5f5`,\r\n                bottom: \"1px\"\r\n            }\r\n        },\r\n        \".cm-tooltip-below &\": {\r\n            top: `-${7 /* Arrow.Size */}px`,\r\n            \"&:before\": {\r\n                borderBottom: `${7 /* Arrow.Size */}px solid #bbb`,\r\n            },\r\n            \"&:after\": {\r\n                borderBottom: `${7 /* Arrow.Size */}px solid #f5f5f5`,\r\n                top: \"1px\"\r\n            }\r\n        },\r\n    },\r\n    \"&dark .cm-tooltip .cm-tooltip-arrow\": {\r\n        \"&:before\": {\r\n            borderTopColor: \"#333338\",\r\n            borderBottomColor: \"#333338\"\r\n        },\r\n        \"&:after\": {\r\n            borderTopColor: \"transparent\",\r\n            borderBottomColor: \"transparent\"\r\n        }\r\n    }\r\n});\r\nconst noOffset = { x: 0, y: 0 };\r\n/**\r\nFacet to which an extension can add a value to show a tooltip.\r\n*/\r\nconst showTooltip = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define({\r\n    enables: [tooltipPlugin, baseTheme]\r\n});\r\nconst showHoverTooltip = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define();\r\nclass HoverTooltipHost {\r\n    constructor(view) {\r\n        this.view = view;\r\n        this.mounted = false;\r\n        this.dom = document.createElement(\"div\");\r\n        this.dom.classList.add(\"cm-tooltip-hover\");\r\n        this.manager = new TooltipViewManager(view, showHoverTooltip, t => this.createHostedView(t));\r\n    }\r\n    // Needs to be static so that host tooltip instances always match\r\n    static create(view) {\r\n        return new HoverTooltipHost(view);\r\n    }\r\n    createHostedView(tooltip) {\r\n        let hostedView = tooltip.create(this.view);\r\n        hostedView.dom.classList.add(\"cm-tooltip-section\");\r\n        this.dom.appendChild(hostedView.dom);\r\n        if (this.mounted && hostedView.mount)\r\n            hostedView.mount(this.view);\r\n        return hostedView;\r\n    }\r\n    mount(view) {\r\n        for (let hostedView of this.manager.tooltipViews) {\r\n            if (hostedView.mount)\r\n                hostedView.mount(view);\r\n        }\r\n        this.mounted = true;\r\n    }\r\n    positioned(space) {\r\n        for (let hostedView of this.manager.tooltipViews) {\r\n            if (hostedView.positioned)\r\n                hostedView.positioned(space);\r\n        }\r\n    }\r\n    update(update) {\r\n        this.manager.update(update);\r\n    }\r\n}\r\nconst showHoverTooltipHost = /*@__PURE__*/showTooltip.compute([showHoverTooltip], state => {\r\n    let tooltips = state.facet(showHoverTooltip).filter(t => t);\r\n    if (tooltips.length === 0)\r\n        return null;\r\n    return {\r\n        pos: Math.min(...tooltips.map(t => t.pos)),\r\n        end: Math.max(...tooltips.filter(t => t.end != null).map(t => t.end)),\r\n        create: HoverTooltipHost.create,\r\n        above: tooltips[0].above,\r\n        arrow: tooltips.some(t => t.arrow),\r\n    };\r\n});\r\nclass HoverPlugin {\r\n    constructor(view, source, field, setHover, hoverTime) {\r\n        this.view = view;\r\n        this.source = source;\r\n        this.field = field;\r\n        this.setHover = setHover;\r\n        this.hoverTime = hoverTime;\r\n        this.hoverTimeout = -1;\r\n        this.restartTimeout = -1;\r\n        this.pending = null;\r\n        this.lastMove = { x: 0, y: 0, target: view.dom, time: 0 };\r\n        this.checkHover = this.checkHover.bind(this);\r\n        view.dom.addEventListener(\"mouseleave\", this.mouseleave = this.mouseleave.bind(this));\r\n        view.dom.addEventListener(\"mousemove\", this.mousemove = this.mousemove.bind(this));\r\n    }\r\n    update() {\r\n        if (this.pending) {\r\n            this.pending = null;\r\n            clearTimeout(this.restartTimeout);\r\n            this.restartTimeout = setTimeout(() => this.startHover(), 20);\r\n        }\r\n    }\r\n    get active() {\r\n        return this.view.state.field(this.field);\r\n    }\r\n    checkHover() {\r\n        this.hoverTimeout = -1;\r\n        if (this.active)\r\n            return;\r\n        let hovered = Date.now() - this.lastMove.time;\r\n        if (hovered < this.hoverTime)\r\n            this.hoverTimeout = setTimeout(this.checkHover, this.hoverTime - hovered);\r\n        else\r\n            this.startHover();\r\n    }\r\n    startHover() {\r\n        clearTimeout(this.restartTimeout);\r\n        let { lastMove } = this;\r\n        let pos = this.view.contentDOM.contains(lastMove.target) ? this.view.posAtCoords(lastMove) : null;\r\n        if (pos == null)\r\n            return;\r\n        let posCoords = this.view.coordsAtPos(pos);\r\n        if (posCoords == null || lastMove.y < posCoords.top || lastMove.y > posCoords.bottom ||\r\n            lastMove.x < posCoords.left - this.view.defaultCharacterWidth ||\r\n            lastMove.x > posCoords.right + this.view.defaultCharacterWidth)\r\n            return;\r\n        let bidi = this.view.bidiSpans(this.view.state.doc.lineAt(pos)).find(s => s.from <= pos && s.to >= pos);\r\n        let rtl = bidi && bidi.dir == Direction.RTL ? -1 : 1;\r\n        let open = this.source(this.view, pos, (lastMove.x < posCoords.left ? -rtl : rtl));\r\n        if (open === null || open === void 0 ? void 0 : open.then) {\r\n            let pending = this.pending = { pos };\r\n            open.then(result => {\r\n                if (this.pending == pending) {\r\n                    this.pending = null;\r\n                    if (result)\r\n                        this.view.dispatch({ effects: this.setHover.of(result) });\r\n                }\r\n            }, e => logException(this.view.state, e, \"hover tooltip\"));\r\n        }\r\n        else if (open) {\r\n            this.view.dispatch({ effects: this.setHover.of(open) });\r\n        }\r\n    }\r\n    mousemove(event) {\r\n        var _a;\r\n        this.lastMove = { x: event.clientX, y: event.clientY, target: event.target, time: Date.now() };\r\n        if (this.hoverTimeout < 0)\r\n            this.hoverTimeout = setTimeout(this.checkHover, this.hoverTime);\r\n        let tooltip = this.active;\r\n        if (tooltip && !isInTooltip(this.lastMove.target) || this.pending) {\r\n            let { pos } = tooltip || this.pending, end = (_a = tooltip === null || tooltip === void 0 ? void 0 : tooltip.end) !== null && _a !== void 0 ? _a : pos;\r\n            if ((pos == end ? this.view.posAtCoords(this.lastMove) != pos\r\n                : !isOverRange(this.view, pos, end, event.clientX, event.clientY, 6 /* Hover.MaxDist */))) {\r\n                this.view.dispatch({ effects: this.setHover.of(null) });\r\n                this.pending = null;\r\n            }\r\n        }\r\n    }\r\n    mouseleave(e) {\r\n        clearTimeout(this.hoverTimeout);\r\n        this.hoverTimeout = -1;\r\n        if (this.active && !isInTooltip(e.relatedTarget))\r\n            this.view.dispatch({ effects: this.setHover.of(null) });\r\n    }\r\n    destroy() {\r\n        clearTimeout(this.hoverTimeout);\r\n        this.view.dom.removeEventListener(\"mouseleave\", this.mouseleave);\r\n        this.view.dom.removeEventListener(\"mousemove\", this.mousemove);\r\n    }\r\n}\r\nfunction isInTooltip(elt) {\r\n    for (let cur = elt; cur; cur = cur.parentNode)\r\n        if (cur.nodeType == 1 && cur.classList.contains(\"cm-tooltip\"))\r\n            return true;\r\n    return false;\r\n}\r\nfunction isOverRange(view, from, to, x, y, margin) {\r\n    let range = document.createRange();\r\n    let fromDOM = view.domAtPos(from), toDOM = view.domAtPos(to);\r\n    range.setEnd(toDOM.node, toDOM.offset);\r\n    range.setStart(fromDOM.node, fromDOM.offset);\r\n    let rects = range.getClientRects();\r\n    range.detach();\r\n    for (let i = 0; i < rects.length; i++) {\r\n        let rect = rects[i];\r\n        let dist = Math.max(rect.top - y, y - rect.bottom, rect.left - x, x - rect.right);\r\n        if (dist <= margin)\r\n            return true;\r\n    }\r\n    return false;\r\n}\r\n/**\r\nSet up a hover tooltip, which shows up when the pointer hovers\r\nover ranges of text. The callback is called when the mouse hovers\r\nover the document text. It should, if there is a tooltip\r\nassociated with position `pos`, return the tooltip description\r\n(either directly or in a promise). The `side` argument indicates\r\non which side of the position the pointer is—it will be -1 if the\r\npointer is before the position, 1 if after the position.\r\n\r\nNote that all hover tooltips are hosted within a single tooltip\r\ncontainer element. This allows multiple tooltips over the same\r\nrange to be \"merged\" together without overlapping.\r\n*/\r\nfunction hoverTooltip(source, options = {}) {\r\n    let setHover = _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.StateEffect.define();\r\n    let hoverState = _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.StateField.define({\r\n        create() { return null; },\r\n        update(value, tr) {\r\n            if (value && (options.hideOnChange && (tr.docChanged || tr.selection) ||\r\n                options.hideOn && options.hideOn(tr, value)))\r\n                return null;\r\n            if (value && tr.docChanged) {\r\n                let newPos = tr.changes.mapPos(value.pos, -1, _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.MapMode.TrackDel);\r\n                if (newPos == null)\r\n                    return null;\r\n                let copy = Object.assign(Object.create(null), value);\r\n                copy.pos = newPos;\r\n                if (value.end != null)\r\n                    copy.end = tr.changes.mapPos(value.end);\r\n                value = copy;\r\n            }\r\n            for (let effect of tr.effects) {\r\n                if (effect.is(setHover))\r\n                    value = effect.value;\r\n                if (effect.is(closeHoverTooltipEffect))\r\n                    value = null;\r\n            }\r\n            return value;\r\n        },\r\n        provide: f => showHoverTooltip.from(f)\r\n    });\r\n    return [\r\n        hoverState,\r\n        ViewPlugin.define(view => new HoverPlugin(view, source, hoverState, setHover, options.hoverTime || 300 /* Hover.Time */)),\r\n        showHoverTooltipHost\r\n    ];\r\n}\r\n/**\r\nGet the active tooltip view for a given tooltip, if available.\r\n*/\r\nfunction getTooltip(view, tooltip) {\r\n    let plugin = view.plugin(tooltipPlugin);\r\n    if (!plugin)\r\n        return null;\r\n    let found = plugin.manager.tooltips.indexOf(tooltip);\r\n    return found < 0 ? null : plugin.manager.tooltipViews[found];\r\n}\r\n/**\r\nReturns true if any hover tooltips are currently active.\r\n*/\r\nfunction hasHoverTooltips(state) {\r\n    return state.facet(showHoverTooltip).some(x => x);\r\n}\r\nconst closeHoverTooltipEffect = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.StateEffect.define();\r\n/**\r\nTransaction effect that closes all hover tooltips.\r\n*/\r\nconst closeHoverTooltips = /*@__PURE__*/closeHoverTooltipEffect.of(null);\r\n/**\r\nTell the tooltip extension to recompute the position of the active\r\ntooltips. This can be useful when something happens (such as a\r\nre-positioning or CSS change affecting the editor) that could\r\ninvalidate the existing tooltip positions.\r\n*/\r\nfunction repositionTooltips(view) {\r\n    var _a;\r\n    (_a = view.plugin(tooltipPlugin)) === null || _a === void 0 ? void 0 : _a.maybeMeasure();\r\n}\r\n\r\nconst panelConfig = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define({\r\n    combine(configs) {\r\n        let topContainer, bottomContainer;\r\n        for (let c of configs) {\r\n            topContainer = topContainer || c.topContainer;\r\n            bottomContainer = bottomContainer || c.bottomContainer;\r\n        }\r\n        return { topContainer, bottomContainer };\r\n    }\r\n});\r\n/**\r\nConfigures the panel-managing extension.\r\n*/\r\nfunction panels(config) {\r\n    return config ? [panelConfig.of(config)] : [];\r\n}\r\n/**\r\nGet the active panel created by the given constructor, if any.\r\nThis can be useful when you need access to your panels' DOM\r\nstructure.\r\n*/\r\nfunction getPanel(view, panel) {\r\n    let plugin = view.plugin(panelPlugin);\r\n    let index = plugin ? plugin.specs.indexOf(panel) : -1;\r\n    return index > -1 ? plugin.panels[index] : null;\r\n}\r\nconst panelPlugin = /*@__PURE__*/ViewPlugin.fromClass(class {\r\n    constructor(view) {\r\n        this.input = view.state.facet(showPanel);\r\n        this.specs = this.input.filter(s => s);\r\n        this.panels = this.specs.map(spec => spec(view));\r\n        let conf = view.state.facet(panelConfig);\r\n        this.top = new PanelGroup(view, true, conf.topContainer);\r\n        this.bottom = new PanelGroup(view, false, conf.bottomContainer);\r\n        this.top.sync(this.panels.filter(p => p.top));\r\n        this.bottom.sync(this.panels.filter(p => !p.top));\r\n        for (let p of this.panels) {\r\n            p.dom.classList.add(\"cm-panel\");\r\n            if (p.mount)\r\n                p.mount();\r\n        }\r\n    }\r\n    update(update) {\r\n        let conf = update.state.facet(panelConfig);\r\n        if (this.top.container != conf.topContainer) {\r\n            this.top.sync([]);\r\n            this.top = new PanelGroup(update.view, true, conf.topContainer);\r\n        }\r\n        if (this.bottom.container != conf.bottomContainer) {\r\n            this.bottom.sync([]);\r\n            this.bottom = new PanelGroup(update.view, false, conf.bottomContainer);\r\n        }\r\n        this.top.syncClasses();\r\n        this.bottom.syncClasses();\r\n        let input = update.state.facet(showPanel);\r\n        if (input != this.input) {\r\n            let specs = input.filter(x => x);\r\n            let panels = [], top = [], bottom = [], mount = [];\r\n            for (let spec of specs) {\r\n                let known = this.specs.indexOf(spec), panel;\r\n                if (known < 0) {\r\n                    panel = spec(update.view);\r\n                    mount.push(panel);\r\n                }\r\n                else {\r\n                    panel = this.panels[known];\r\n                    if (panel.update)\r\n                        panel.update(update);\r\n                }\r\n                panels.push(panel);\r\n                (panel.top ? top : bottom).push(panel);\r\n            }\r\n            this.specs = specs;\r\n            this.panels = panels;\r\n            this.top.sync(top);\r\n            this.bottom.sync(bottom);\r\n            for (let p of mount) {\r\n                p.dom.classList.add(\"cm-panel\");\r\n                if (p.mount)\r\n                    p.mount();\r\n            }\r\n        }\r\n        else {\r\n            for (let p of this.panels)\r\n                if (p.update)\r\n                    p.update(update);\r\n        }\r\n    }\r\n    destroy() {\r\n        this.top.sync([]);\r\n        this.bottom.sync([]);\r\n    }\r\n}, {\r\n    provide: plugin => EditorView.scrollMargins.of(view => {\r\n        let value = view.plugin(plugin);\r\n        return value && { top: value.top.scrollMargin(), bottom: value.bottom.scrollMargin() };\r\n    })\r\n});\r\nclass PanelGroup {\r\n    constructor(view, top, container) {\r\n        this.view = view;\r\n        this.top = top;\r\n        this.container = container;\r\n        this.dom = undefined;\r\n        this.classes = \"\";\r\n        this.panels = [];\r\n        this.syncClasses();\r\n    }\r\n    sync(panels) {\r\n        for (let p of this.panels)\r\n            if (p.destroy && panels.indexOf(p) < 0)\r\n                p.destroy();\r\n        this.panels = panels;\r\n        this.syncDOM();\r\n    }\r\n    syncDOM() {\r\n        if (this.panels.length == 0) {\r\n            if (this.dom) {\r\n                this.dom.remove();\r\n                this.dom = undefined;\r\n            }\r\n            return;\r\n        }\r\n        if (!this.dom) {\r\n            this.dom = document.createElement(\"div\");\r\n            this.dom.className = this.top ? \"cm-panels cm-panels-top\" : \"cm-panels cm-panels-bottom\";\r\n            this.dom.style[this.top ? \"top\" : \"bottom\"] = \"0\";\r\n            let parent = this.container || this.view.dom;\r\n            parent.insertBefore(this.dom, this.top ? parent.firstChild : null);\r\n        }\r\n        let curDOM = this.dom.firstChild;\r\n        for (let panel of this.panels) {\r\n            if (panel.dom.parentNode == this.dom) {\r\n                while (curDOM != panel.dom)\r\n                    curDOM = rm(curDOM);\r\n                curDOM = curDOM.nextSibling;\r\n            }\r\n            else {\r\n                this.dom.insertBefore(panel.dom, curDOM);\r\n            }\r\n        }\r\n        while (curDOM)\r\n            curDOM = rm(curDOM);\r\n    }\r\n    scrollMargin() {\r\n        return !this.dom || this.container ? 0\r\n            : Math.max(0, this.top ?\r\n                this.dom.getBoundingClientRect().bottom - Math.max(0, this.view.scrollDOM.getBoundingClientRect().top) :\r\n                Math.min(innerHeight, this.view.scrollDOM.getBoundingClientRect().bottom) - this.dom.getBoundingClientRect().top);\r\n    }\r\n    syncClasses() {\r\n        if (!this.container || this.classes == this.view.themeClasses)\r\n            return;\r\n        for (let cls of this.classes.split(\" \"))\r\n            if (cls)\r\n                this.container.classList.remove(cls);\r\n        for (let cls of (this.classes = this.view.themeClasses).split(\" \"))\r\n            if (cls)\r\n                this.container.classList.add(cls);\r\n    }\r\n}\r\nfunction rm(node) {\r\n    let next = node.nextSibling;\r\n    node.remove();\r\n    return next;\r\n}\r\n/**\r\nOpening a panel is done by providing a constructor function for\r\nthe panel through this facet. (The panel is closed again when its\r\nconstructor is no longer provided.) Values of `null` are ignored.\r\n*/\r\nconst showPanel = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define({\r\n    enables: panelPlugin\r\n});\r\n\r\n/**\r\nA gutter marker represents a bit of information attached to a line\r\nin a specific gutter. Your own custom markers have to extend this\r\nclass.\r\n*/\r\nclass GutterMarker extends _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.RangeValue {\r\n    /**\r\n    @internal\r\n    */\r\n    compare(other) {\r\n        return this == other || this.constructor == other.constructor && this.eq(other);\r\n    }\r\n    /**\r\n    Compare this marker to another marker of the same type.\r\n    */\r\n    eq(other) { return false; }\r\n    /**\r\n    Called if the marker has a `toDOM` method and its representation\r\n    was removed from a gutter.\r\n    */\r\n    destroy(dom) { }\r\n}\r\nGutterMarker.prototype.elementClass = \"\";\r\nGutterMarker.prototype.toDOM = undefined;\r\nGutterMarker.prototype.mapMode = _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.MapMode.TrackBefore;\r\nGutterMarker.prototype.startSide = GutterMarker.prototype.endSide = -1;\r\nGutterMarker.prototype.point = true;\r\n/**\r\nFacet used to add a class to all gutter elements for a given line.\r\nMarkers given to this facet should _only_ define an\r\n[`elementclass`](https://codemirror.net/6/docs/ref/#view.GutterMarker.elementClass), not a\r\n[`toDOM`](https://codemirror.net/6/docs/ref/#view.GutterMarker.toDOM) (or the marker will appear\r\nin all gutters for the line).\r\n*/\r\nconst gutterLineClass = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define();\r\nconst defaults = {\r\n    class: \"\",\r\n    renderEmptyElements: false,\r\n    elementStyle: \"\",\r\n    markers: () => _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.RangeSet.empty,\r\n    lineMarker: () => null,\r\n    lineMarkerChange: null,\r\n    initialSpacer: null,\r\n    updateSpacer: null,\r\n    domEventHandlers: {}\r\n};\r\nconst activeGutters = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define();\r\n/**\r\nDefine an editor gutter. The order in which the gutters appear is\r\ndetermined by their extension priority.\r\n*/\r\nfunction gutter(config) {\r\n    return [gutters(), activeGutters.of(Object.assign(Object.assign({}, defaults), config))];\r\n}\r\nconst unfixGutters = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define({\r\n    combine: values => values.some(x => x)\r\n});\r\n/**\r\nThe gutter-drawing plugin is automatically enabled when you add a\r\ngutter, but you can use this function to explicitly configure it.\r\n\r\nUnless `fixed` is explicitly set to `false`, the gutters are\r\nfixed, meaning they don't scroll along with the content\r\nhorizontally (except on Internet Explorer, which doesn't support\r\nCSS [`position:\r\nsticky`](https://developer.mozilla.org/en-US/docs/Web/CSS/position#sticky)).\r\n*/\r\nfunction gutters(config) {\r\n    let result = [\r\n        gutterView,\r\n    ];\r\n    if (config && config.fixed === false)\r\n        result.push(unfixGutters.of(true));\r\n    return result;\r\n}\r\nconst gutterView = /*@__PURE__*/ViewPlugin.fromClass(class {\r\n    constructor(view) {\r\n        this.view = view;\r\n        this.prevViewport = view.viewport;\r\n        this.dom = document.createElement(\"div\");\r\n        this.dom.className = \"cm-gutters\";\r\n        this.dom.setAttribute(\"aria-hidden\", \"true\");\r\n        this.dom.style.minHeight = this.view.contentHeight + \"px\";\r\n        this.gutters = view.state.facet(activeGutters).map(conf => new SingleGutterView(view, conf));\r\n        for (let gutter of this.gutters)\r\n            this.dom.appendChild(gutter.dom);\r\n        this.fixed = !view.state.facet(unfixGutters);\r\n        if (this.fixed) {\r\n            // FIXME IE11 fallback, which doesn't support position: sticky,\r\n            // by using position: relative + event handlers that realign the\r\n            // gutter (or just force fixed=false on IE11?)\r\n            this.dom.style.position = \"sticky\";\r\n        }\r\n        this.syncGutters(false);\r\n        view.scrollDOM.insertBefore(this.dom, view.contentDOM);\r\n    }\r\n    update(update) {\r\n        if (this.updateGutters(update)) {\r\n            // Detach during sync when the viewport changed significantly\r\n            // (such as during scrolling), since for large updates that is\r\n            // faster.\r\n            let vpA = this.prevViewport, vpB = update.view.viewport;\r\n            let vpOverlap = Math.min(vpA.to, vpB.to) - Math.max(vpA.from, vpB.from);\r\n            this.syncGutters(vpOverlap < (vpB.to - vpB.from) * 0.8);\r\n        }\r\n        if (update.geometryChanged)\r\n            this.dom.style.minHeight = this.view.contentHeight + \"px\";\r\n        if (this.view.state.facet(unfixGutters) != !this.fixed) {\r\n            this.fixed = !this.fixed;\r\n            this.dom.style.position = this.fixed ? \"sticky\" : \"\";\r\n        }\r\n        this.prevViewport = update.view.viewport;\r\n    }\r\n    syncGutters(detach) {\r\n        let after = this.dom.nextSibling;\r\n        if (detach)\r\n            this.dom.remove();\r\n        let lineClasses = _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.RangeSet.iter(this.view.state.facet(gutterLineClass), this.view.viewport.from);\r\n        let classSet = [];\r\n        let contexts = this.gutters.map(gutter => new UpdateContext(gutter, this.view.viewport, -this.view.documentPadding.top));\r\n        for (let line of this.view.viewportLineBlocks) {\r\n            let text;\r\n            if (Array.isArray(line.type)) {\r\n                for (let b of line.type)\r\n                    if (b.type == BlockType.Text) {\r\n                        text = b;\r\n                        break;\r\n                    }\r\n            }\r\n            else {\r\n                text = line.type == BlockType.Text ? line : undefined;\r\n            }\r\n            if (!text)\r\n                continue;\r\n            if (classSet.length)\r\n                classSet = [];\r\n            advanceCursor(lineClasses, classSet, line.from);\r\n            for (let cx of contexts)\r\n                cx.line(this.view, text, classSet);\r\n        }\r\n        for (let cx of contexts)\r\n            cx.finish();\r\n        if (detach)\r\n            this.view.scrollDOM.insertBefore(this.dom, after);\r\n    }\r\n    updateGutters(update) {\r\n        let prev = update.startState.facet(activeGutters), cur = update.state.facet(activeGutters);\r\n        let change = update.docChanged || update.heightChanged || update.viewportChanged ||\r\n            !_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.RangeSet.eq(update.startState.facet(gutterLineClass), update.state.facet(gutterLineClass), update.view.viewport.from, update.view.viewport.to);\r\n        if (prev == cur) {\r\n            for (let gutter of this.gutters)\r\n                if (gutter.update(update))\r\n                    change = true;\r\n        }\r\n        else {\r\n            change = true;\r\n            let gutters = [];\r\n            for (let conf of cur) {\r\n                let known = prev.indexOf(conf);\r\n                if (known < 0) {\r\n                    gutters.push(new SingleGutterView(this.view, conf));\r\n                }\r\n                else {\r\n                    this.gutters[known].update(update);\r\n                    gutters.push(this.gutters[known]);\r\n                }\r\n            }\r\n            for (let g of this.gutters) {\r\n                g.dom.remove();\r\n                if (gutters.indexOf(g) < 0)\r\n                    g.destroy();\r\n            }\r\n            for (let g of gutters)\r\n                this.dom.appendChild(g.dom);\r\n            this.gutters = gutters;\r\n        }\r\n        return change;\r\n    }\r\n    destroy() {\r\n        for (let view of this.gutters)\r\n            view.destroy();\r\n        this.dom.remove();\r\n    }\r\n}, {\r\n    provide: plugin => EditorView.scrollMargins.of(view => {\r\n        let value = view.plugin(plugin);\r\n        if (!value || value.gutters.length == 0 || !value.fixed)\r\n            return null;\r\n        return view.textDirection == Direction.LTR ? { left: value.dom.offsetWidth } : { right: value.dom.offsetWidth };\r\n    })\r\n});\r\nfunction asArray(val) { return (Array.isArray(val) ? val : [val]); }\r\nfunction advanceCursor(cursor, collect, pos) {\r\n    while (cursor.value && cursor.from <= pos) {\r\n        if (cursor.from == pos)\r\n            collect.push(cursor.value);\r\n        cursor.next();\r\n    }\r\n}\r\nclass UpdateContext {\r\n    constructor(gutter, viewport, height) {\r\n        this.gutter = gutter;\r\n        this.height = height;\r\n        this.i = 0;\r\n        this.cursor = _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.RangeSet.iter(gutter.markers, viewport.from);\r\n    }\r\n    line(view, line, extraMarkers) {\r\n        let localMarkers = [];\r\n        advanceCursor(this.cursor, localMarkers, line.from);\r\n        if (extraMarkers.length)\r\n            localMarkers = localMarkers.concat(extraMarkers);\r\n        let forLine = this.gutter.config.lineMarker(view, line, localMarkers);\r\n        if (forLine)\r\n            localMarkers.unshift(forLine);\r\n        let gutter = this.gutter;\r\n        if (localMarkers.length == 0 && !gutter.config.renderEmptyElements)\r\n            return;\r\n        let above = line.top - this.height;\r\n        if (this.i == gutter.elements.length) {\r\n            let newElt = new GutterElement(view, line.height, above, localMarkers);\r\n            gutter.elements.push(newElt);\r\n            gutter.dom.appendChild(newElt.dom);\r\n        }\r\n        else {\r\n            gutter.elements[this.i].update(view, line.height, above, localMarkers);\r\n        }\r\n        this.height = line.bottom;\r\n        this.i++;\r\n    }\r\n    finish() {\r\n        let gutter = this.gutter;\r\n        while (gutter.elements.length > this.i) {\r\n            let last = gutter.elements.pop();\r\n            gutter.dom.removeChild(last.dom);\r\n            last.destroy();\r\n        }\r\n    }\r\n}\r\nclass SingleGutterView {\r\n    constructor(view, config) {\r\n        this.view = view;\r\n        this.config = config;\r\n        this.elements = [];\r\n        this.spacer = null;\r\n        this.dom = document.createElement(\"div\");\r\n        this.dom.className = \"cm-gutter\" + (this.config.class ? \" \" + this.config.class : \"\");\r\n        for (let prop in config.domEventHandlers) {\r\n            this.dom.addEventListener(prop, (event) => {\r\n                let target = event.target, y;\r\n                if (target != this.dom && this.dom.contains(target)) {\r\n                    while (target.parentNode != this.dom)\r\n                        target = target.parentNode;\r\n                    let rect = target.getBoundingClientRect();\r\n                    y = (rect.top + rect.bottom) / 2;\r\n                }\r\n                else {\r\n                    y = event.clientY;\r\n                }\r\n                let line = view.lineBlockAtHeight(y - view.documentTop);\r\n                if (config.domEventHandlers[prop](view, line, event))\r\n                    event.preventDefault();\r\n            });\r\n        }\r\n        this.markers = asArray(config.markers(view));\r\n        if (config.initialSpacer) {\r\n            this.spacer = new GutterElement(view, 0, 0, [config.initialSpacer(view)]);\r\n            this.dom.appendChild(this.spacer.dom);\r\n            this.spacer.dom.style.cssText += \"visibility: hidden; pointer-events: none\";\r\n        }\r\n    }\r\n    update(update) {\r\n        let prevMarkers = this.markers;\r\n        this.markers = asArray(this.config.markers(update.view));\r\n        if (this.spacer && this.config.updateSpacer) {\r\n            let updated = this.config.updateSpacer(this.spacer.markers[0], update);\r\n            if (updated != this.spacer.markers[0])\r\n                this.spacer.update(update.view, 0, 0, [updated]);\r\n        }\r\n        let vp = update.view.viewport;\r\n        return !_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.RangeSet.eq(this.markers, prevMarkers, vp.from, vp.to) ||\r\n            (this.config.lineMarkerChange ? this.config.lineMarkerChange(update) : false);\r\n    }\r\n    destroy() {\r\n        for (let elt of this.elements)\r\n            elt.destroy();\r\n    }\r\n}\r\nclass GutterElement {\r\n    constructor(view, height, above, markers) {\r\n        this.height = -1;\r\n        this.above = 0;\r\n        this.markers = [];\r\n        this.dom = document.createElement(\"div\");\r\n        this.dom.className = \"cm-gutterElement\";\r\n        this.update(view, height, above, markers);\r\n    }\r\n    update(view, height, above, markers) {\r\n        if (this.height != height)\r\n            this.dom.style.height = (this.height = height) + \"px\";\r\n        if (this.above != above)\r\n            this.dom.style.marginTop = (this.above = above) ? above + \"px\" : \"\";\r\n        if (!sameMarkers(this.markers, markers))\r\n            this.setMarkers(view, markers);\r\n    }\r\n    setMarkers(view, markers) {\r\n        let cls = \"cm-gutterElement\", domPos = this.dom.firstChild;\r\n        for (let iNew = 0, iOld = 0;;) {\r\n            let skipTo = iOld, marker = iNew < markers.length ? markers[iNew++] : null, matched = false;\r\n            if (marker) {\r\n                let c = marker.elementClass;\r\n                if (c)\r\n                    cls += \" \" + c;\r\n                for (let i = iOld; i < this.markers.length; i++)\r\n                    if (this.markers[i].compare(marker)) {\r\n                        skipTo = i;\r\n                        matched = true;\r\n                        break;\r\n                    }\r\n            }\r\n            else {\r\n                skipTo = this.markers.length;\r\n            }\r\n            while (iOld < skipTo) {\r\n                let next = this.markers[iOld++];\r\n                if (next.toDOM) {\r\n                    next.destroy(domPos);\r\n                    let after = domPos.nextSibling;\r\n                    domPos.remove();\r\n                    domPos = after;\r\n                }\r\n            }\r\n            if (!marker)\r\n                break;\r\n            if (marker.toDOM) {\r\n                if (matched)\r\n                    domPos = domPos.nextSibling;\r\n                else\r\n                    this.dom.insertBefore(marker.toDOM(view), domPos);\r\n            }\r\n            if (matched)\r\n                iOld++;\r\n        }\r\n        this.dom.className = cls;\r\n        this.markers = markers;\r\n    }\r\n    destroy() {\r\n        this.setMarkers(null, []); // First argument not used unless creating markers\r\n    }\r\n}\r\nfunction sameMarkers(a, b) {\r\n    if (a.length != b.length)\r\n        return false;\r\n    for (let i = 0; i < a.length; i++)\r\n        if (!a[i].compare(b[i]))\r\n            return false;\r\n    return true;\r\n}\r\n/**\r\nFacet used to provide markers to the line number gutter.\r\n*/\r\nconst lineNumberMarkers = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define();\r\nconst lineNumberConfig = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define({\r\n    combine(values) {\r\n        return (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.combineConfig)(values, { formatNumber: String, domEventHandlers: {} }, {\r\n            domEventHandlers(a, b) {\r\n                let result = Object.assign({}, a);\r\n                for (let event in b) {\r\n                    let exists = result[event], add = b[event];\r\n                    result[event] = exists ? (view, line, event) => exists(view, line, event) || add(view, line, event) : add;\r\n                }\r\n                return result;\r\n            }\r\n        });\r\n    }\r\n});\r\nclass NumberMarker extends GutterMarker {\r\n    constructor(number) {\r\n        super();\r\n        this.number = number;\r\n    }\r\n    eq(other) { return this.number == other.number; }\r\n    toDOM() { return document.createTextNode(this.number); }\r\n}\r\nfunction formatNumber(view, number) {\r\n    return view.state.facet(lineNumberConfig).formatNumber(number, view.state);\r\n}\r\nconst lineNumberGutter = /*@__PURE__*/activeGutters.compute([lineNumberConfig], state => ({\r\n    class: \"cm-lineNumbers\",\r\n    renderEmptyElements: false,\r\n    markers(view) { return view.state.facet(lineNumberMarkers); },\r\n    lineMarker(view, line, others) {\r\n        if (others.some(m => m.toDOM))\r\n            return null;\r\n        return new NumberMarker(formatNumber(view, view.state.doc.lineAt(line.from).number));\r\n    },\r\n    lineMarkerChange: update => update.startState.facet(lineNumberConfig) != update.state.facet(lineNumberConfig),\r\n    initialSpacer(view) {\r\n        return new NumberMarker(formatNumber(view, maxLineNumber(view.state.doc.lines)));\r\n    },\r\n    updateSpacer(spacer, update) {\r\n        let max = formatNumber(update.view, maxLineNumber(update.view.state.doc.lines));\r\n        return max == spacer.number ? spacer : new NumberMarker(max);\r\n    },\r\n    domEventHandlers: state.facet(lineNumberConfig).domEventHandlers\r\n}));\r\n/**\r\nCreate a line number gutter extension.\r\n*/\r\nfunction lineNumbers(config = {}) {\r\n    return [\r\n        lineNumberConfig.of(config),\r\n        gutters(),\r\n        lineNumberGutter\r\n    ];\r\n}\r\nfunction maxLineNumber(lines) {\r\n    let last = 9;\r\n    while (last < lines)\r\n        last = last * 10 + 9;\r\n    return last;\r\n}\r\nconst activeLineGutterMarker = /*@__PURE__*/new class extends GutterMarker {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.elementClass = \"cm-activeLineGutter\";\r\n    }\r\n};\r\nconst activeLineGutterHighlighter = /*@__PURE__*/gutterLineClass.compute([\"selection\"], state => {\r\n    let marks = [], last = -1;\r\n    for (let range of state.selection.ranges) {\r\n        let linePos = state.doc.lineAt(range.head).from;\r\n        if (linePos > last) {\r\n            last = linePos;\r\n            marks.push(activeLineGutterMarker.range(linePos));\r\n        }\r\n    }\r\n    return _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.RangeSet.of(marks);\r\n});\r\n/**\r\nReturns an extension that adds a `cm-activeLineGutter` class to\r\nall gutter elements on the [active\r\nline](https://codemirror.net/6/docs/ref/#view.highlightActiveLine).\r\n*/\r\nfunction highlightActiveLineGutter() {\r\n    return activeLineGutterHighlighter;\r\n}\r\n\r\nconst WhitespaceDeco = /*@__PURE__*/new Map();\r\nfunction getWhitespaceDeco(space) {\r\n    let deco = WhitespaceDeco.get(space);\r\n    if (!deco)\r\n        WhitespaceDeco.set(space, deco = Decoration.mark({\r\n            attributes: space === \"\\t\" ? {\r\n                class: \"cm-highlightTab\",\r\n            } : {\r\n                class: \"cm-highlightSpace\",\r\n                \"data-display\": space.replace(/ /g, \"·\")\r\n            }\r\n        }));\r\n    return deco;\r\n}\r\nfunction matcher(decorator) {\r\n    return ViewPlugin.define(view => ({\r\n        decorations: decorator.createDeco(view),\r\n        update(u) {\r\n            this.decorations = decorator.updateDeco(u, this.decorations);\r\n        },\r\n    }), {\r\n        decorations: v => v.decorations\r\n    });\r\n}\r\nconst whitespaceHighlighter = /*@__PURE__*/matcher(/*@__PURE__*/new MatchDecorator({\r\n    regexp: /\\t| +/g,\r\n    decoration: match => getWhitespaceDeco(match[0]),\r\n    boundary: /\\S/,\r\n}));\r\n/**\r\nReturns an extension that highlights whitespace, adding a\r\n`cm-highlightSpace` class to stretches of spaces, and a\r\n`cm-highlightTab` class to individual tab characters. By default,\r\nthe former are shown as faint dots, and the latter as arrows.\r\n*/\r\nfunction highlightWhitespace() {\r\n    return whitespaceHighlighter;\r\n}\r\nconst trailingHighlighter = /*@__PURE__*/matcher(/*@__PURE__*/new MatchDecorator({\r\n    regexp: /\\s+$/g,\r\n    decoration: /*@__PURE__*/Decoration.mark({ class: \"cm-trailingSpace\" }),\r\n    boundary: /\\S/,\r\n}));\r\n/**\r\nReturns an extension that adds a `cm-trailingSpace` class to all\r\ntrailing whitespace.\r\n*/\r\nfunction highlightTrailingWhitespace() {\r\n    return trailingHighlighter;\r\n}\r\n\r\n/**\r\n@internal\r\n*/\r\nconst __test = { HeightMap, HeightOracle, MeasuredHeights, QueryType, ChangedRange, computeOrder, moveVisually };\r\n\r\n\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGNvZGVtaXJyb3Ivdmlldy9kaXN0L2luZGV4LmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBeVI7QUFDalA7QUFDVztBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsSUFBSTtBQUM1QixpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLElBQUk7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLG9CQUFvQjtBQUMzRDtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLEtBQUs7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLHdCQUF3QixpQkFBaUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQyxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdELDBCQUEwQjtBQUNsRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxRQUFRO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsUUFBUTtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHFCQUFxQjtBQUM3QztBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkIsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQix5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLFdBQVc7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxxQkFBcUI7QUFDL0IsVUFBVSx5QkFBeUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQ7QUFDMUQsd0RBQXdELG1CQUFtQjtBQUMzRTtBQUNBO0FBQ0EsbURBQW1ELEdBQUc7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0Q7QUFDbEQ7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkIseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQSxtQkFBbUIseURBQVU7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrREFBK0QseURBQVU7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0Q7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLGdCQUFnQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLGNBQWMsZ0JBQWdCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCLDRCQUE0QjtBQUM1QjtBQUNBLGNBQWMsZ0JBQWdCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QixvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLE9BQU87QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkIsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCLG9CQUFvQjtBQUNwQix3QkFBd0I7QUFDeEIsd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiw2RkFBNkY7QUFDN0c7QUFDQTtBQUNBLGVBQWUseURBQVU7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixXQUFXO0FBQ3ZDLHNCQUFzQixxQkFBcUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IscUJBQXFCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsV0FBVztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyx3Q0FBd0M7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLDhCQUE4QjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIseURBQVU7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixhQUFhO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsMERBQVc7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsNkRBQWM7QUFDaEM7QUFDQTtBQUNBLGNBQWMsYUFBYTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxrRUFBbUI7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLCtEQUFnQixvQkFBb0Isa0VBQW1CLEdBQUcsaUVBQWtCO0FBQzVHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsMkNBQTJDO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxTQUFTO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsMEJBQTBCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RDtBQUM3RDtBQUNBLHdDQUF3QyxZQUFZLGtCQUFrQjtBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLGlCQUFpQjtBQUNqQjtBQUNBLGlDQUFpQyw2QkFBNkI7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdHQUFnRyx5REFBVTtBQUMxRztBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHlCQUF5QjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixPQUFPO0FBQzdCO0FB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxrRUFBa0U7QUFDeEUsTUFBTSx5REFBeUQ7QUFDL0QsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxrRkFBbUM7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsZ0JBQWdCO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsT0FBTztBQUMxQjtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsOERBQThEO0FBQzVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsVUFBVSx5QkFBeUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIseURBQVU7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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Y0FBYyx1QkFBdUI7QUFDckM7QUFDQTtBQUNBO0FBQ0EsY0FBYyx3QkFBd0I7QUFDdEMseUZBQXlGLFdBQVc7QUFDcEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsY0FBYyxZQUFZO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsY0FBYztBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsV0FBVztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLDZEQUFjO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLCtEQUFnQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0VBQWtFLHFFQUFzQjtBQUN4RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLDZEQUFjO0FBQ3RCLDZCQUE2QixjQUFjLFVBQVUsSUFBSTtBQUN6RDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLDZEQUFjO0FBQ2xCLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0EsOEJBQThCLHFCQUFxQjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssT0FBTztBQUNa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QUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsbURBQW1EO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MscUVBQXNCO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBLCtDQUErQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsSUFBSTtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsSUFBSTtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsT0FBTztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLE9BQU87QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsSUFBSTtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRFQUE0RSx3QkFBd0IsZUFBZTtBQUNuSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixXQUFXO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsY0FBYyxxQkFBcUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRDtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RCxpRUFBa0I7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQSxnRUFBZ0UsMERBQVc7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGtFQUFtQixzQkFBc0Isa0VBQW1CO0FBQ3BGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixPQUFPO0FBQ2pDLHdFQUF3RSxxRUFBc0I7QUFDOUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHlCQUF5QjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQSxjQUFjLHdDQUF3QztBQUN0RDtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxzQkFBc0I7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixnQkFBZ0IsSUFBSSxtQkFBbUI7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSx3REFBaUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsaUNBQWlDO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDLDJFQUEyRSxxRUFBc0I7QUFDakc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxLQUFLLHlCQUF5QjtBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLDBEQUFtQjtBQUN4QyxzRUFBc0UsT0FBTztBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLDBEQUFXO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsaUVBQWtCO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQywyREFBWTtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQixLQUFLO0FBQ0wsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLDJEQUFZO0FBQzNDO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQix5REFBVTtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxrRUFBbUI7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLDJEQUFZO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLDZEQUFjO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQywyREFBWTtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0VBQXNFO0FBQ3RFO0FBQ0Esa0NBQWtDLDJEQUFZO0FBQzlDO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQiw0REFBYTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLDBEQUFXO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVELDhCQUE4QixJQUFJO0FBQ3pGLEtBQUs7QUFDTCxDQUFDO0FBQ0Qsd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQiw0REFBYTtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrRUFBa0U7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiwwREFBVztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMseUJBQXlCO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGNBQWM7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsMkRBQVk7QUFDbkQsc0NBQXNDLDJEQUFZO0FBQ2xEO0FBQ0EsZUFBZSxnRUFBYSxXQUFXLDRDQUE0QztBQUNuRjtBQUNBLDZDQUE2QztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsNkNBQTZDO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsMERBQVc7QUFDdEIsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLDJCQUEyQjtBQUMxRTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ3duQiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGNvZGVtaXJyb3Ivdmlldy9kaXN0L2luZGV4LmpzPzM2MWIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgVGV4dCwgUmFuZ2VTZXQsIE1hcE1vZGUsIFJhbmdlVmFsdWUsIEZhY2V0LCBTdGF0ZUVmZmVjdCwgQ2hhbmdlU2V0LCBmaW5kQ2x1c3RlckJyZWFrLCBFZGl0b3JTZWxlY3Rpb24sIEVkaXRvclN0YXRlLCBmaW5kQ29sdW1uLCBDaGFyQ2F0ZWdvcnksIFRyYW5zYWN0aW9uLCBQcmVjLCBjb2RlUG9pbnRBdCwgY29kZVBvaW50U2l6ZSwgY29tYmluZUNvbmZpZywgU3RhdGVGaWVsZCwgUmFuZ2VTZXRCdWlsZGVyLCBjb3VudENvbHVtbiB9IGZyb20gJ0Bjb2RlbWlycm9yL3N0YXRlJztcclxuaW1wb3J0IHsgU3R5bGVNb2R1bGUgfSBmcm9tICdzdHlsZS1tb2QnO1xyXG5pbXBvcnQgeyBrZXlOYW1lLCBiYXNlLCBzaGlmdCB9IGZyb20gJ3czYy1rZXluYW1lJztcclxuXHJcbmZ1bmN0aW9uIGdldFNlbGVjdGlvbihyb290KSB7XHJcbiAgICBsZXQgdGFyZ2V0O1xyXG4gICAgLy8gQnJvd3NlcnMgZGlmZmVyIG9uIHdoZXRoZXIgc2hhZG93IHJvb3RzIGhhdmUgYSBnZXRTZWxlY3Rpb25cclxuICAgIC8vIG1ldGhvZC4gSWYgaXQgZXhpc3RzLCB1c2UgdGhhdCwgb3RoZXJ3aXNlLCBjYWxsIGl0IG9uIHRoZVxyXG4gICAgLy8gZG9jdW1lbnQuXHJcbiAgICBpZiAocm9vdC5ub2RlVHlwZSA9PSAxMSkgeyAvLyBTaGFkb3cgcm9vdFxyXG4gICAgICAgIHRhcmdldCA9IHJvb3QuZ2V0U2VsZWN0aW9uID8gcm9vdCA6IHJvb3Qub3duZXJEb2N1bWVudDtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHRhcmdldCA9IHJvb3Q7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdGFyZ2V0LmdldFNlbGVjdGlvbigpO1xyXG59XHJcbmZ1bmN0aW9uIGNvbnRhaW5zKGRvbSwgbm9kZSkge1xyXG4gICAgcmV0dXJuIG5vZGUgPyBkb20gPT0gbm9kZSB8fCBkb20uY29udGFpbnMobm9kZS5ub2RlVHlwZSAhPSAxID8gbm9kZS5wYXJlbnROb2RlIDogbm9kZSkgOiBmYWxzZTtcclxufVxyXG5mdW5jdGlvbiBkZWVwQWN0aXZlRWxlbWVudChkb2MpIHtcclxuICAgIGxldCBlbHQgPSBkb2MuYWN0aXZlRWxlbWVudDtcclxuICAgIHdoaWxlIChlbHQgJiYgZWx0LnNoYWRvd1Jvb3QpXHJcbiAgICAgICAgZWx0ID0gZWx0LnNoYWRvd1Jvb3QuYWN0aXZlRWxlbWVudDtcclxuICAgIHJldHVybiBlbHQ7XHJcbn1cclxuZnVuY3Rpb24gaGFzU2VsZWN0aW9uKGRvbSwgc2VsZWN0aW9uKSB7XHJcbiAgICBpZiAoIXNlbGVjdGlvbi5hbmNob3JOb2RlKVxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgLy8gRmlyZWZveCB3aWxsIHJhaXNlICdwZXJtaXNzaW9uIGRlbmllZCcgZXJyb3JzIHdoZW4gYWNjZXNzaW5nXHJcbiAgICAgICAgLy8gcHJvcGVydGllcyBvZiBgc2VsLmFuY2hvck5vZGVgIHdoZW4gaXQncyBpbiBhIGdlbmVyYXRlZCBDU1NcclxuICAgICAgICAvLyBlbGVtZW50LlxyXG4gICAgICAgIHJldHVybiBjb250YWlucyhkb20sIHNlbGVjdGlvbi5hbmNob3JOb2RlKTtcclxuICAgIH1cclxuICAgIGNhdGNoIChfKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGNsaWVudFJlY3RzRm9yKGRvbSkge1xyXG4gICAgaWYgKGRvbS5ub2RlVHlwZSA9PSAzKVxyXG4gICAgICAgIHJldHVybiB0ZXh0UmFuZ2UoZG9tLCAwLCBkb20ubm9kZVZhbHVlLmxlbmd0aCkuZ2V0Q2xpZW50UmVjdHMoKTtcclxuICAgIGVsc2UgaWYgKGRvbS5ub2RlVHlwZSA9PSAxKVxyXG4gICAgICAgIHJldHVybiBkb20uZ2V0Q2xpZW50UmVjdHMoKTtcclxuICAgIGVsc2VcclxuICAgICAgICByZXR1cm4gW107XHJcbn1cclxuLy8gU2NhbnMgZm9yd2FyZCBhbmQgYmFja3dhcmQgdGhyb3VnaCBET00gcG9zaXRpb25zIGVxdWl2YWxlbnQgdG8gdGhlXHJcbi8vIGdpdmVuIG9uZSB0byBzZWUgaWYgdGhlIHR3byBhcmUgaW4gdGhlIHNhbWUgcGxhY2UgKGkuZS4gYWZ0ZXIgYVxyXG4vLyB0ZXh0IG5vZGUgdnMgYXQgdGhlIGVuZCBvZiB0aGF0IHRleHQgbm9kZSlcclxuZnVuY3Rpb24gaXNFcXVpdmFsZW50UG9zaXRpb24obm9kZSwgb2ZmLCB0YXJnZXROb2RlLCB0YXJnZXRPZmYpIHtcclxuICAgIHJldHVybiB0YXJnZXROb2RlID8gKHNjYW5Gb3Iobm9kZSwgb2ZmLCB0YXJnZXROb2RlLCB0YXJnZXRPZmYsIC0xKSB8fFxyXG4gICAgICAgIHNjYW5Gb3Iobm9kZSwgb2ZmLCB0YXJnZXROb2RlLCB0YXJnZXRPZmYsIDEpKSA6IGZhbHNlO1xyXG59XHJcbmZ1bmN0aW9uIGRvbUluZGV4KG5vZGUpIHtcclxuICAgIGZvciAodmFyIGluZGV4ID0gMDs7IGluZGV4KyspIHtcclxuICAgICAgICBub2RlID0gbm9kZS5wcmV2aW91c1NpYmxpbmc7XHJcbiAgICAgICAgaWYgKCFub2RlKVxyXG4gICAgICAgICAgICByZXR1cm4gaW5kZXg7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gc2NhbkZvcihub2RlLCBvZmYsIHRhcmdldE5vZGUsIHRhcmdldE9mZiwgZGlyKSB7XHJcbiAgICBmb3IgKDs7KSB7XHJcbiAgICAgICAgaWYgKG5vZGUgPT0gdGFyZ2V0Tm9kZSAmJiBvZmYgPT0gdGFyZ2V0T2ZmKVxyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICBpZiAob2ZmID09IChkaXIgPCAwID8gMCA6IG1heE9mZnNldChub2RlKSkpIHtcclxuICAgICAgICAgICAgaWYgKG5vZGUubm9kZU5hbWUgPT0gXCJESVZcIilcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgbGV0IHBhcmVudCA9IG5vZGUucGFyZW50Tm9kZTtcclxuICAgICAgICAgICAgaWYgKCFwYXJlbnQgfHwgcGFyZW50Lm5vZGVUeXBlICE9IDEpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIG9mZiA9IGRvbUluZGV4KG5vZGUpICsgKGRpciA8IDAgPyAwIDogMSk7XHJcbiAgICAgICAgICAgIG5vZGUgPSBwYXJlbnQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKG5vZGUubm9kZVR5cGUgPT0gMSkge1xyXG4gICAgICAgICAgICBub2RlID0gbm9kZS5jaGlsZE5vZGVzW29mZiArIChkaXIgPCAwID8gLTEgOiAwKV07XHJcbiAgICAgICAgICAgIGlmIChub2RlLm5vZGVUeXBlID09IDEgJiYgbm9kZS5jb250ZW50RWRpdGFibGUgPT0gXCJmYWxzZVwiKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICBvZmYgPSBkaXIgPCAwID8gbWF4T2Zmc2V0KG5vZGUpIDogMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gbWF4T2Zmc2V0KG5vZGUpIHtcclxuICAgIHJldHVybiBub2RlLm5vZGVUeXBlID09IDMgPyBub2RlLm5vZGVWYWx1ZS5sZW5ndGggOiBub2RlLmNoaWxkTm9kZXMubGVuZ3RoO1xyXG59XHJcbmNvbnN0IFJlY3QwID0geyBsZWZ0OiAwLCByaWdodDogMCwgdG9wOiAwLCBib3R0b206IDAgfTtcclxuZnVuY3Rpb24gZmxhdHRlblJlY3QocmVjdCwgbGVmdCkge1xyXG4gICAgbGV0IHggPSBsZWZ0ID8gcmVjdC5sZWZ0IDogcmVjdC5yaWdodDtcclxuICAgIHJldHVybiB7IGxlZnQ6IHgsIHJpZ2h0OiB4LCB0b3A6IHJlY3QudG9wLCBib3R0b206IHJlY3QuYm90dG9tIH07XHJcbn1cclxuZnVuY3Rpb24gd2luZG93UmVjdCh3aW4pIHtcclxuICAgIHJldHVybiB7IGxlZnQ6IDAsIHJpZ2h0OiB3aW4uaW5uZXJXaWR0aCxcclxuICAgICAgICB0b3A6IDAsIGJvdHRvbTogd2luLmlubmVySGVpZ2h0IH07XHJcbn1cclxuZnVuY3Rpb24gc2Nyb2xsUmVjdEludG9WaWV3KGRvbSwgcmVjdCwgc2lkZSwgeCwgeSwgeE1hcmdpbiwgeU1hcmdpbiwgbHRyKSB7XHJcbiAgICBsZXQgZG9jID0gZG9tLm93bmVyRG9jdW1lbnQsIHdpbiA9IGRvYy5kZWZhdWx0VmlldyB8fCB3aW5kb3c7XHJcbiAgICBmb3IgKGxldCBjdXIgPSBkb207IGN1cjspIHtcclxuICAgICAgICBpZiAoY3VyLm5vZGVUeXBlID09IDEpIHsgLy8gRWxlbWVudFxyXG4gICAgICAgICAgICBsZXQgYm91bmRpbmcsIHRvcCA9IGN1ciA9PSBkb2MuYm9keTtcclxuICAgICAgICAgICAgaWYgKHRvcCkge1xyXG4gICAgICAgICAgICAgICAgYm91bmRpbmcgPSB3aW5kb3dSZWN0KHdpbik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoY3VyLnNjcm9sbEhlaWdodCA8PSBjdXIuY2xpZW50SGVpZ2h0ICYmIGN1ci5zY3JvbGxXaWR0aCA8PSBjdXIuY2xpZW50V2lkdGgpIHtcclxuICAgICAgICAgICAgICAgICAgICBjdXIgPSBjdXIuYXNzaWduZWRTbG90IHx8IGN1ci5wYXJlbnROb2RlO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgbGV0IHJlY3QgPSBjdXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XHJcbiAgICAgICAgICAgICAgICAvLyBNYWtlIHN1cmUgc2Nyb2xsYmFyIHdpZHRoIGlzbid0IGluY2x1ZGVkIGluIHRoZSByZWN0YW5nbGVcclxuICAgICAgICAgICAgICAgIGJvdW5kaW5nID0geyBsZWZ0OiByZWN0LmxlZnQsIHJpZ2h0OiByZWN0LmxlZnQgKyBjdXIuY2xpZW50V2lkdGgsXHJcbiAgICAgICAgICAgICAgICAgICAgdG9wOiByZWN0LnRvcCwgYm90dG9tOiByZWN0LnRvcCArIGN1ci5jbGllbnRIZWlnaHQgfTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBsZXQgbW92ZVggPSAwLCBtb3ZlWSA9IDA7XHJcbiAgICAgICAgICAgIGlmICh5ID09IFwibmVhcmVzdFwiKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAocmVjdC50b3AgPCBib3VuZGluZy50b3ApIHtcclxuICAgICAgICAgICAgICAgICAgICBtb3ZlWSA9IC0oYm91bmRpbmcudG9wIC0gcmVjdC50b3AgKyB5TWFyZ2luKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoc2lkZSA+IDAgJiYgcmVjdC5ib3R0b20gPiBib3VuZGluZy5ib3R0b20gKyBtb3ZlWSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgbW92ZVkgPSByZWN0LmJvdHRvbSAtIGJvdW5kaW5nLmJvdHRvbSArIG1vdmVZICsgeU1hcmdpbjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHJlY3QuYm90dG9tID4gYm91bmRpbmcuYm90dG9tKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbW92ZVkgPSByZWN0LmJvdHRvbSAtIGJvdW5kaW5nLmJvdHRvbSArIHlNYXJnaW47XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNpZGUgPCAwICYmIChyZWN0LnRvcCAtIG1vdmVZKSA8IGJvdW5kaW5nLnRvcClcclxuICAgICAgICAgICAgICAgICAgICAgICAgbW92ZVkgPSAtKGJvdW5kaW5nLnRvcCArIG1vdmVZIC0gcmVjdC50b3AgKyB5TWFyZ2luKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGxldCByZWN0SGVpZ2h0ID0gcmVjdC5ib3R0b20gLSByZWN0LnRvcCwgYm91bmRpbmdIZWlnaHQgPSBib3VuZGluZy5ib3R0b20gLSBib3VuZGluZy50b3A7XHJcbiAgICAgICAgICAgICAgICBsZXQgdGFyZ2V0VG9wID0geSA9PSBcImNlbnRlclwiICYmIHJlY3RIZWlnaHQgPD0gYm91bmRpbmdIZWlnaHQgPyByZWN0LnRvcCArIHJlY3RIZWlnaHQgLyAyIC0gYm91bmRpbmdIZWlnaHQgLyAyIDpcclxuICAgICAgICAgICAgICAgICAgICB5ID09IFwic3RhcnRcIiB8fCB5ID09IFwiY2VudGVyXCIgJiYgc2lkZSA8IDAgPyByZWN0LnRvcCAtIHlNYXJnaW4gOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZWN0LmJvdHRvbSAtIGJvdW5kaW5nSGVpZ2h0ICsgeU1hcmdpbjtcclxuICAgICAgICAgICAgICAgIG1vdmVZID0gdGFyZ2V0VG9wIC0gYm91bmRpbmcudG9wO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh4ID09IFwibmVhcmVzdFwiKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAocmVjdC5sZWZ0IDwgYm91bmRpbmcubGVmdCkge1xyXG4gICAgICAgICAgICAgICAgICAgIG1vdmVYID0gLShib3VuZGluZy5sZWZ0IC0gcmVjdC5sZWZ0ICsgeE1hcmdpbik7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNpZGUgPiAwICYmIHJlY3QucmlnaHQgPiBib3VuZGluZy5yaWdodCArIG1vdmVYKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBtb3ZlWCA9IHJlY3QucmlnaHQgLSBib3VuZGluZy5yaWdodCArIG1vdmVYICsgeE1hcmdpbjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHJlY3QucmlnaHQgPiBib3VuZGluZy5yaWdodCkge1xyXG4gICAgICAgICAgICAgICAgICAgIG1vdmVYID0gcmVjdC5yaWdodCAtIGJvdW5kaW5nLnJpZ2h0ICsgeE1hcmdpbjtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoc2lkZSA8IDAgJiYgcmVjdC5sZWZ0IDwgYm91bmRpbmcubGVmdCArIG1vdmVYKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBtb3ZlWCA9IC0oYm91bmRpbmcubGVmdCArIG1vdmVYIC0gcmVjdC5sZWZ0ICsgeE1hcmdpbik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgdGFyZ2V0TGVmdCA9IHggPT0gXCJjZW50ZXJcIiA/IHJlY3QubGVmdCArIChyZWN0LnJpZ2h0IC0gcmVjdC5sZWZ0KSAvIDIgLSAoYm91bmRpbmcucmlnaHQgLSBib3VuZGluZy5sZWZ0KSAvIDIgOlxyXG4gICAgICAgICAgICAgICAgICAgICh4ID09IFwic3RhcnRcIikgPT0gbHRyID8gcmVjdC5sZWZ0IC0geE1hcmdpbiA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlY3QucmlnaHQgLSAoYm91bmRpbmcucmlnaHQgLSBib3VuZGluZy5sZWZ0KSArIHhNYXJnaW47XHJcbiAgICAgICAgICAgICAgICBtb3ZlWCA9IHRhcmdldExlZnQgLSBib3VuZGluZy5sZWZ0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChtb3ZlWCB8fCBtb3ZlWSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRvcCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHdpbi5zY3JvbGxCeShtb3ZlWCwgbW92ZVkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IG1vdmVkWCA9IDAsIG1vdmVkWSA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1vdmVZKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBzdGFydCA9IGN1ci5zY3JvbGxUb3A7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1ci5zY3JvbGxUb3AgKz0gbW92ZVk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vdmVkWSA9IGN1ci5zY3JvbGxUb3AgLSBzdGFydDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1vdmVYKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBzdGFydCA9IGN1ci5zY3JvbGxMZWZ0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjdXIuc2Nyb2xsTGVmdCArPSBtb3ZlWDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbW92ZWRYID0gY3VyLnNjcm9sbExlZnQgLSBzdGFydDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmVjdCA9IHsgbGVmdDogcmVjdC5sZWZ0IC0gbW92ZWRYLCB0b3A6IHJlY3QudG9wIC0gbW92ZWRZLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICByaWdodDogcmVjdC5yaWdodCAtIG1vdmVkWCwgYm90dG9tOiByZWN0LmJvdHRvbSAtIG1vdmVkWSB9O1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChtb3ZlZFggJiYgTWF0aC5hYnMobW92ZWRYIC0gbW92ZVgpIDwgMSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgeCA9IFwibmVhcmVzdFwiO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChtb3ZlZFkgJiYgTWF0aC5hYnMobW92ZWRZIC0gbW92ZVkpIDwgMSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgeSA9IFwibmVhcmVzdFwiO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh0b3ApXHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY3VyID0gY3VyLmFzc2lnbmVkU2xvdCB8fCBjdXIucGFyZW50Tm9kZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoY3VyLm5vZGVUeXBlID09IDExKSB7IC8vIEEgc2hhZG93IHJvb3RcclxuICAgICAgICAgICAgY3VyID0gY3VyLmhvc3Q7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gc2Nyb2xsYWJsZVBhcmVudChkb20pIHtcclxuICAgIGxldCBkb2MgPSBkb20ub3duZXJEb2N1bWVudDtcclxuICAgIGZvciAobGV0IGN1ciA9IGRvbS5wYXJlbnROb2RlOyBjdXI7KSB7XHJcbiAgICAgICAgaWYgKGN1ciA9PSBkb2MuYm9keSkge1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoY3VyLm5vZGVUeXBlID09IDEpIHtcclxuICAgICAgICAgICAgaWYgKGN1ci5zY3JvbGxIZWlnaHQgPiBjdXIuY2xpZW50SGVpZ2h0IHx8IGN1ci5zY3JvbGxXaWR0aCA+IGN1ci5jbGllbnRXaWR0aClcclxuICAgICAgICAgICAgICAgIHJldHVybiBjdXI7XHJcbiAgICAgICAgICAgIGN1ciA9IGN1ci5hc3NpZ25lZFNsb3QgfHwgY3VyLnBhcmVudE5vZGU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGN1ci5ub2RlVHlwZSA9PSAxMSkge1xyXG4gICAgICAgICAgICBjdXIgPSBjdXIuaG9zdDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBudWxsO1xyXG59XHJcbmNsYXNzIERPTVNlbGVjdGlvblN0YXRlIHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHRoaXMuYW5jaG9yTm9kZSA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5hbmNob3JPZmZzZXQgPSAwO1xyXG4gICAgICAgIHRoaXMuZm9jdXNOb2RlID0gbnVsbDtcclxuICAgICAgICB0aGlzLmZvY3VzT2Zmc2V0ID0gMDtcclxuICAgIH1cclxuICAgIGVxKGRvbVNlbCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmFuY2hvck5vZGUgPT0gZG9tU2VsLmFuY2hvck5vZGUgJiYgdGhpcy5hbmNob3JPZmZzZXQgPT0gZG9tU2VsLmFuY2hvck9mZnNldCAmJlxyXG4gICAgICAgICAgICB0aGlzLmZvY3VzTm9kZSA9PSBkb21TZWwuZm9jdXNOb2RlICYmIHRoaXMuZm9jdXNPZmZzZXQgPT0gZG9tU2VsLmZvY3VzT2Zmc2V0O1xyXG4gICAgfVxyXG4gICAgc2V0UmFuZ2UocmFuZ2UpIHtcclxuICAgICAgICB0aGlzLnNldChyYW5nZS5hbmNob3JOb2RlLCByYW5nZS5hbmNob3JPZmZzZXQsIHJhbmdlLmZvY3VzTm9kZSwgcmFuZ2UuZm9jdXNPZmZzZXQpO1xyXG4gICAgfVxyXG4gICAgc2V0KGFuY2hvck5vZGUsIGFuY2hvck9mZnNldCwgZm9jdXNOb2RlLCBmb2N1c09mZnNldCkge1xyXG4gICAgICAgIHRoaXMuYW5jaG9yTm9kZSA9IGFuY2hvck5vZGU7XHJcbiAgICAgICAgdGhpcy5hbmNob3JPZmZzZXQgPSBhbmNob3JPZmZzZXQ7XHJcbiAgICAgICAgdGhpcy5mb2N1c05vZGUgPSBmb2N1c05vZGU7XHJcbiAgICAgICAgdGhpcy5mb2N1c09mZnNldCA9IGZvY3VzT2Zmc2V0O1xyXG4gICAgfVxyXG59XHJcbmxldCBwcmV2ZW50U2Nyb2xsU3VwcG9ydGVkID0gbnVsbDtcclxuLy8gRmVhdHVyZS1kZXRlY3RzIHN1cHBvcnQgZm9yIC5mb2N1cyh7cHJldmVudFNjcm9sbDogdHJ1ZX0pLCBhbmQgdXNlc1xyXG4vLyBhIGZhbGxiYWNrIGtsdWRnZSB3aGVuIG5vdCBzdXBwb3J0ZWQuXHJcbmZ1bmN0aW9uIGZvY3VzUHJldmVudFNjcm9sbChkb20pIHtcclxuICAgIGlmIChkb20uc2V0QWN0aXZlKVxyXG4gICAgICAgIHJldHVybiBkb20uc2V0QWN0aXZlKCk7IC8vIGluIElFXHJcbiAgICBpZiAocHJldmVudFNjcm9sbFN1cHBvcnRlZClcclxuICAgICAgICByZXR1cm4gZG9tLmZvY3VzKHByZXZlbnRTY3JvbGxTdXBwb3J0ZWQpO1xyXG4gICAgbGV0IHN0YWNrID0gW107XHJcbiAgICBmb3IgKGxldCBjdXIgPSBkb207IGN1cjsgY3VyID0gY3VyLnBhcmVudE5vZGUpIHtcclxuICAgICAgICBzdGFjay5wdXNoKGN1ciwgY3VyLnNjcm9sbFRvcCwgY3VyLnNjcm9sbExlZnQpO1xyXG4gICAgICAgIGlmIChjdXIgPT0gY3VyLm93bmVyRG9jdW1lbnQpXHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgfVxyXG4gICAgZG9tLmZvY3VzKHByZXZlbnRTY3JvbGxTdXBwb3J0ZWQgPT0gbnVsbCA/IHtcclxuICAgICAgICBnZXQgcHJldmVudFNjcm9sbCgpIHtcclxuICAgICAgICAgICAgcHJldmVudFNjcm9sbFN1cHBvcnRlZCA9IHsgcHJldmVudFNjcm9sbDogdHJ1ZSB9O1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICB9IDogdW5kZWZpbmVkKTtcclxuICAgIGlmICghcHJldmVudFNjcm9sbFN1cHBvcnRlZCkge1xyXG4gICAgICAgIHByZXZlbnRTY3JvbGxTdXBwb3J0ZWQgPSBmYWxzZTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0YWNrLmxlbmd0aDspIHtcclxuICAgICAgICAgICAgbGV0IGVsdCA9IHN0YWNrW2krK10sIHRvcCA9IHN0YWNrW2krK10sIGxlZnQgPSBzdGFja1tpKytdO1xyXG4gICAgICAgICAgICBpZiAoZWx0LnNjcm9sbFRvcCAhPSB0b3ApXHJcbiAgICAgICAgICAgICAgICBlbHQuc2Nyb2xsVG9wID0gdG9wO1xyXG4gICAgICAgICAgICBpZiAoZWx0LnNjcm9sbExlZnQgIT0gbGVmdClcclxuICAgICAgICAgICAgICAgIGVsdC5zY3JvbGxMZWZ0ID0gbGVmdDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxubGV0IHNjcmF0Y2hSYW5nZTtcclxuZnVuY3Rpb24gdGV4dFJhbmdlKG5vZGUsIGZyb20sIHRvID0gZnJvbSkge1xyXG4gICAgbGV0IHJhbmdlID0gc2NyYXRjaFJhbmdlIHx8IChzY3JhdGNoUmFuZ2UgPSBkb2N1bWVudC5jcmVhdGVSYW5nZSgpKTtcclxuICAgIHJhbmdlLnNldEVuZChub2RlLCB0byk7XHJcbiAgICByYW5nZS5zZXRTdGFydChub2RlLCBmcm9tKTtcclxuICAgIHJldHVybiByYW5nZTtcclxufVxyXG5mdW5jdGlvbiBkaXNwYXRjaEtleShlbHQsIG5hbWUsIGNvZGUpIHtcclxuICAgIGxldCBvcHRpb25zID0geyBrZXk6IG5hbWUsIGNvZGU6IG5hbWUsIGtleUNvZGU6IGNvZGUsIHdoaWNoOiBjb2RlLCBjYW5jZWxhYmxlOiB0cnVlIH07XHJcbiAgICBsZXQgZG93biA9IG5ldyBLZXlib2FyZEV2ZW50KFwia2V5ZG93blwiLCBvcHRpb25zKTtcclxuICAgIGRvd24uc3ludGhldGljID0gdHJ1ZTtcclxuICAgIGVsdC5kaXNwYXRjaEV2ZW50KGRvd24pO1xyXG4gICAgbGV0IHVwID0gbmV3IEtleWJvYXJkRXZlbnQoXCJrZXl1cFwiLCBvcHRpb25zKTtcclxuICAgIHVwLnN5bnRoZXRpYyA9IHRydWU7XHJcbiAgICBlbHQuZGlzcGF0Y2hFdmVudCh1cCk7XHJcbiAgICByZXR1cm4gZG93bi5kZWZhdWx0UHJldmVudGVkIHx8IHVwLmRlZmF1bHRQcmV2ZW50ZWQ7XHJcbn1cclxuZnVuY3Rpb24gZ2V0Um9vdChub2RlKSB7XHJcbiAgICB3aGlsZSAobm9kZSkge1xyXG4gICAgICAgIGlmIChub2RlICYmIChub2RlLm5vZGVUeXBlID09IDkgfHwgbm9kZS5ub2RlVHlwZSA9PSAxMSAmJiBub2RlLmhvc3QpKVxyXG4gICAgICAgICAgICByZXR1cm4gbm9kZTtcclxuICAgICAgICBub2RlID0gbm9kZS5hc3NpZ25lZFNsb3QgfHwgbm9kZS5wYXJlbnROb2RlO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG51bGw7XHJcbn1cclxuZnVuY3Rpb24gY2xlYXJBdHRyaWJ1dGVzKG5vZGUpIHtcclxuICAgIHdoaWxlIChub2RlLmF0dHJpYnV0ZXMubGVuZ3RoKVxyXG4gICAgICAgIG5vZGUucmVtb3ZlQXR0cmlidXRlTm9kZShub2RlLmF0dHJpYnV0ZXNbMF0pO1xyXG59XHJcbmZ1bmN0aW9uIGF0RWxlbWVudFN0YXJ0KGRvYywgc2VsZWN0aW9uKSB7XHJcbiAgICBsZXQgbm9kZSA9IHNlbGVjdGlvbi5mb2N1c05vZGUsIG9mZnNldCA9IHNlbGVjdGlvbi5mb2N1c09mZnNldDtcclxuICAgIGlmICghbm9kZSB8fCBzZWxlY3Rpb24uYW5jaG9yTm9kZSAhPSBub2RlIHx8IHNlbGVjdGlvbi5hbmNob3JPZmZzZXQgIT0gb2Zmc2V0KVxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIGZvciAoOzspIHtcclxuICAgICAgICBpZiAob2Zmc2V0KSB7XHJcbiAgICAgICAgICAgIGlmIChub2RlLm5vZGVUeXBlICE9IDEpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIGxldCBwcmV2ID0gbm9kZS5jaGlsZE5vZGVzW29mZnNldCAtIDFdO1xyXG4gICAgICAgICAgICBpZiAocHJldi5jb250ZW50RWRpdGFibGUgPT0gXCJmYWxzZVwiKVxyXG4gICAgICAgICAgICAgICAgb2Zmc2V0LS07XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgbm9kZSA9IHByZXY7XHJcbiAgICAgICAgICAgICAgICBvZmZzZXQgPSBtYXhPZmZzZXQobm9kZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAobm9kZSA9PSBkb2MpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBvZmZzZXQgPSBkb21JbmRleChub2RlKTtcclxuICAgICAgICAgICAgbm9kZSA9IG5vZGUucGFyZW50Tm9kZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuXHJcbmNsYXNzIERPTVBvcyB7XHJcbiAgICBjb25zdHJ1Y3Rvcihub2RlLCBvZmZzZXQsIHByZWNpc2UgPSB0cnVlKSB7XHJcbiAgICAgICAgdGhpcy5ub2RlID0gbm9kZTtcclxuICAgICAgICB0aGlzLm9mZnNldCA9IG9mZnNldDtcclxuICAgICAgICB0aGlzLnByZWNpc2UgPSBwcmVjaXNlO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGJlZm9yZShkb20sIHByZWNpc2UpIHsgcmV0dXJuIG5ldyBET01Qb3MoZG9tLnBhcmVudE5vZGUsIGRvbUluZGV4KGRvbSksIHByZWNpc2UpOyB9XHJcbiAgICBzdGF0aWMgYWZ0ZXIoZG9tLCBwcmVjaXNlKSB7IHJldHVybiBuZXcgRE9NUG9zKGRvbS5wYXJlbnROb2RlLCBkb21JbmRleChkb20pICsgMSwgcHJlY2lzZSk7IH1cclxufVxyXG5jb25zdCBub0NoaWxkcmVuID0gW107XHJcbmNsYXNzIENvbnRlbnRWaWV3IHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHRoaXMucGFyZW50ID0gbnVsbDtcclxuICAgICAgICB0aGlzLmRvbSA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5kaXJ0eSA9IDIgLyogRGlydHkuTm9kZSAqLztcclxuICAgIH1cclxuICAgIGdldCBlZGl0b3JWaWV3KCkge1xyXG4gICAgICAgIGlmICghdGhpcy5wYXJlbnQpXHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkFjY2Vzc2luZyB2aWV3IGluIG9ycGhhbiBjb250ZW50IHZpZXdcIik7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyZW50LmVkaXRvclZpZXc7XHJcbiAgICB9XHJcbiAgICBnZXQgb3ZlcnJpZGVET01UZXh0KCkgeyByZXR1cm4gbnVsbDsgfVxyXG4gICAgZ2V0IHBvc0F0U3RhcnQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyZW50ID8gdGhpcy5wYXJlbnQucG9zQmVmb3JlKHRoaXMpIDogMDtcclxuICAgIH1cclxuICAgIGdldCBwb3NBdEVuZCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5wb3NBdFN0YXJ0ICsgdGhpcy5sZW5ndGg7XHJcbiAgICB9XHJcbiAgICBwb3NCZWZvcmUodmlldykge1xyXG4gICAgICAgIGxldCBwb3MgPSB0aGlzLnBvc0F0U3RhcnQ7XHJcbiAgICAgICAgZm9yIChsZXQgY2hpbGQgb2YgdGhpcy5jaGlsZHJlbikge1xyXG4gICAgICAgICAgICBpZiAoY2hpbGQgPT0gdmlldylcclxuICAgICAgICAgICAgICAgIHJldHVybiBwb3M7XHJcbiAgICAgICAgICAgIHBvcyArPSBjaGlsZC5sZW5ndGggKyBjaGlsZC5icmVha0FmdGVyO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgY2hpbGQgaW4gcG9zQmVmb3JlXCIpO1xyXG4gICAgfVxyXG4gICAgcG9zQWZ0ZXIodmlldykge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnBvc0JlZm9yZSh2aWV3KSArIHZpZXcubGVuZ3RoO1xyXG4gICAgfVxyXG4gICAgLy8gV2lsbCByZXR1cm4gYSByZWN0YW5nbGUgZGlyZWN0bHkgYmVmb3JlICh3aGVuIHNpZGUgPCAwKSwgYWZ0ZXJcclxuICAgIC8vIChzaWRlID4gMCkgb3IgZGlyZWN0bHkgb24gKHdoZW4gdGhlIGJyb3dzZXIgc3VwcG9ydHMgaXQpIHRoZVxyXG4gICAgLy8gZ2l2ZW4gcG9zaXRpb24uXHJcbiAgICBjb29yZHNBdChfcG9zLCBfc2lkZSkgeyByZXR1cm4gbnVsbDsgfVxyXG4gICAgc3luYyh0cmFjaykge1xyXG4gICAgICAgIGlmICh0aGlzLmRpcnR5ICYgMiAvKiBEaXJ0eS5Ob2RlICovKSB7XHJcbiAgICAgICAgICAgIGxldCBwYXJlbnQgPSB0aGlzLmRvbTtcclxuICAgICAgICAgICAgbGV0IHByZXYgPSBudWxsLCBuZXh0O1xyXG4gICAgICAgICAgICBmb3IgKGxldCBjaGlsZCBvZiB0aGlzLmNoaWxkcmVuKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoY2hpbGQuZGlydHkpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIWNoaWxkLmRvbSAmJiAobmV4dCA9IHByZXYgPyBwcmV2Lm5leHRTaWJsaW5nIDogcGFyZW50LmZpcnN0Q2hpbGQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBjb250ZW50VmlldyA9IENvbnRlbnRWaWV3LmdldChuZXh0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFjb250ZW50VmlldyB8fCAhY29udGVudFZpZXcucGFyZW50ICYmIGNvbnRlbnRWaWV3LmNhblJldXNlRE9NKGNoaWxkKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkLnJldXNlRE9NKG5leHQpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBjaGlsZC5zeW5jKHRyYWNrKTtcclxuICAgICAgICAgICAgICAgICAgICBjaGlsZC5kaXJ0eSA9IDAgLyogRGlydHkuTm90ICovO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgbmV4dCA9IHByZXYgPyBwcmV2Lm5leHRTaWJsaW5nIDogcGFyZW50LmZpcnN0Q2hpbGQ7XHJcbiAgICAgICAgICAgICAgICBpZiAodHJhY2sgJiYgIXRyYWNrLndyaXR0ZW4gJiYgdHJhY2subm9kZSA9PSBwYXJlbnQgJiYgbmV4dCAhPSBjaGlsZC5kb20pXHJcbiAgICAgICAgICAgICAgICAgICAgdHJhY2sud3JpdHRlbiA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICBpZiAoY2hpbGQuZG9tLnBhcmVudE5vZGUgPT0gcGFyZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKG5leHQgJiYgbmV4dCAhPSBjaGlsZC5kb20pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHQgPSBybSQxKG5leHQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50Lmluc2VydEJlZm9yZShjaGlsZC5kb20sIG5leHQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcHJldiA9IGNoaWxkLmRvbTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBuZXh0ID0gcHJldiA/IHByZXYubmV4dFNpYmxpbmcgOiBwYXJlbnQuZmlyc3RDaGlsZDtcclxuICAgICAgICAgICAgaWYgKG5leHQgJiYgdHJhY2sgJiYgdHJhY2subm9kZSA9PSBwYXJlbnQpXHJcbiAgICAgICAgICAgICAgICB0cmFjay53cml0dGVuID0gdHJ1ZTtcclxuICAgICAgICAgICAgd2hpbGUgKG5leHQpXHJcbiAgICAgICAgICAgICAgICBuZXh0ID0gcm0kMShuZXh0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodGhpcy5kaXJ0eSAmIDEgLyogRGlydHkuQ2hpbGQgKi8pIHtcclxuICAgICAgICAgICAgZm9yIChsZXQgY2hpbGQgb2YgdGhpcy5jaGlsZHJlbilcclxuICAgICAgICAgICAgICAgIGlmIChjaGlsZC5kaXJ0eSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNoaWxkLnN5bmModHJhY2spO1xyXG4gICAgICAgICAgICAgICAgICAgIGNoaWxkLmRpcnR5ID0gMCAvKiBEaXJ0eS5Ob3QgKi87XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV1c2VET00oX2RvbSkgeyB9XHJcbiAgICBsb2NhbFBvc0Zyb21ET00obm9kZSwgb2Zmc2V0KSB7XHJcbiAgICAgICAgbGV0IGFmdGVyO1xyXG4gICAgICAgIGlmIChub2RlID09IHRoaXMuZG9tKSB7XHJcbiAgICAgICAgICAgIGFmdGVyID0gdGhpcy5kb20uY2hpbGROb2Rlc1tvZmZzZXRdO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgbGV0IGJpYXMgPSBtYXhPZmZzZXQobm9kZSkgPT0gMCA/IDAgOiBvZmZzZXQgPT0gMCA/IC0xIDogMTtcclxuICAgICAgICAgICAgZm9yICg7Oykge1xyXG4gICAgICAgICAgICAgICAgbGV0IHBhcmVudCA9IG5vZGUucGFyZW50Tm9kZTtcclxuICAgICAgICAgICAgICAgIGlmIChwYXJlbnQgPT0gdGhpcy5kb20pXHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBpZiAoYmlhcyA9PSAwICYmIHBhcmVudC5maXJzdENoaWxkICE9IHBhcmVudC5sYXN0Q2hpbGQpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAobm9kZSA9PSBwYXJlbnQuZmlyc3RDaGlsZClcclxuICAgICAgICAgICAgICAgICAgICAgICAgYmlhcyA9IC0xO1xyXG4gICAgICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgYmlhcyA9IDE7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBub2RlID0gcGFyZW50O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChiaWFzIDwgMClcclxuICAgICAgICAgICAgICAgIGFmdGVyID0gbm9kZTtcclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgYWZ0ZXIgPSBub2RlLm5leHRTaWJsaW5nO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoYWZ0ZXIgPT0gdGhpcy5kb20uZmlyc3RDaGlsZClcclxuICAgICAgICAgICAgcmV0dXJuIDA7XHJcbiAgICAgICAgd2hpbGUgKGFmdGVyICYmICFDb250ZW50Vmlldy5nZXQoYWZ0ZXIpKVxyXG4gICAgICAgICAgICBhZnRlciA9IGFmdGVyLm5leHRTaWJsaW5nO1xyXG4gICAgICAgIGlmICghYWZ0ZXIpXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxlbmd0aDtcclxuICAgICAgICBmb3IgKGxldCBpID0gMCwgcG9zID0gMDs7IGkrKykge1xyXG4gICAgICAgICAgICBsZXQgY2hpbGQgPSB0aGlzLmNoaWxkcmVuW2ldO1xyXG4gICAgICAgICAgICBpZiAoY2hpbGQuZG9tID09IGFmdGVyKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHBvcztcclxuICAgICAgICAgICAgcG9zICs9IGNoaWxkLmxlbmd0aCArIGNoaWxkLmJyZWFrQWZ0ZXI7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZG9tQm91bmRzQXJvdW5kKGZyb20sIHRvLCBvZmZzZXQgPSAwKSB7XHJcbiAgICAgICAgbGV0IGZyb21JID0gLTEsIGZyb21TdGFydCA9IC0xLCB0b0kgPSAtMSwgdG9FbmQgPSAtMTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMCwgcG9zID0gb2Zmc2V0LCBwcmV2RW5kID0gb2Zmc2V0OyBpIDwgdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBsZXQgY2hpbGQgPSB0aGlzLmNoaWxkcmVuW2ldLCBlbmQgPSBwb3MgKyBjaGlsZC5sZW5ndGg7XHJcbiAgICAgICAgICAgIGlmIChwb3MgPCBmcm9tICYmIGVuZCA+IHRvKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNoaWxkLmRvbUJvdW5kc0Fyb3VuZChmcm9tLCB0bywgcG9zKTtcclxuICAgICAgICAgICAgaWYgKGVuZCA+PSBmcm9tICYmIGZyb21JID09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICBmcm9tSSA9IGk7XHJcbiAgICAgICAgICAgICAgICBmcm9tU3RhcnQgPSBwb3M7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHBvcyA+IHRvICYmIGNoaWxkLmRvbS5wYXJlbnROb2RlID09IHRoaXMuZG9tKSB7XHJcbiAgICAgICAgICAgICAgICB0b0kgPSBpO1xyXG4gICAgICAgICAgICAgICAgdG9FbmQgPSBwcmV2RW5kO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcHJldkVuZCA9IGVuZDtcclxuICAgICAgICAgICAgcG9zID0gZW5kICsgY2hpbGQuYnJlYWtBZnRlcjtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHsgZnJvbTogZnJvbVN0YXJ0LCB0bzogdG9FbmQgPCAwID8gb2Zmc2V0ICsgdGhpcy5sZW5ndGggOiB0b0VuZCxcclxuICAgICAgICAgICAgc3RhcnRET006IChmcm9tSSA/IHRoaXMuY2hpbGRyZW5bZnJvbUkgLSAxXS5kb20ubmV4dFNpYmxpbmcgOiBudWxsKSB8fCB0aGlzLmRvbS5maXJzdENoaWxkLFxyXG4gICAgICAgICAgICBlbmRET006IHRvSSA8IHRoaXMuY2hpbGRyZW4ubGVuZ3RoICYmIHRvSSA+PSAwID8gdGhpcy5jaGlsZHJlblt0b0ldLmRvbSA6IG51bGwgfTtcclxuICAgIH1cclxuICAgIG1hcmtEaXJ0eShhbmRQYXJlbnQgPSBmYWxzZSkge1xyXG4gICAgICAgIHRoaXMuZGlydHkgfD0gMiAvKiBEaXJ0eS5Ob2RlICovO1xyXG4gICAgICAgIHRoaXMubWFya1BhcmVudHNEaXJ0eShhbmRQYXJlbnQpO1xyXG4gICAgfVxyXG4gICAgbWFya1BhcmVudHNEaXJ0eShjaGlsZExpc3QpIHtcclxuICAgICAgICBmb3IgKGxldCBwYXJlbnQgPSB0aGlzLnBhcmVudDsgcGFyZW50OyBwYXJlbnQgPSBwYXJlbnQucGFyZW50KSB7XHJcbiAgICAgICAgICAgIGlmIChjaGlsZExpc3QpXHJcbiAgICAgICAgICAgICAgICBwYXJlbnQuZGlydHkgfD0gMiAvKiBEaXJ0eS5Ob2RlICovO1xyXG4gICAgICAgICAgICBpZiAocGFyZW50LmRpcnR5ICYgMSAvKiBEaXJ0eS5DaGlsZCAqLylcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgcGFyZW50LmRpcnR5IHw9IDEgLyogRGlydHkuQ2hpbGQgKi87XHJcbiAgICAgICAgICAgIGNoaWxkTGlzdCA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHNldFBhcmVudChwYXJlbnQpIHtcclxuICAgICAgICBpZiAodGhpcy5wYXJlbnQgIT0gcGFyZW50KSB7XHJcbiAgICAgICAgICAgIHRoaXMucGFyZW50ID0gcGFyZW50O1xyXG4gICAgICAgICAgICBpZiAodGhpcy5kaXJ0eSlcclxuICAgICAgICAgICAgICAgIHRoaXMubWFya1BhcmVudHNEaXJ0eSh0cnVlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBzZXRET00oZG9tKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuZG9tKVxyXG4gICAgICAgICAgICB0aGlzLmRvbS5jbVZpZXcgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuZG9tID0gZG9tO1xyXG4gICAgICAgIGRvbS5jbVZpZXcgPSB0aGlzO1xyXG4gICAgfVxyXG4gICAgZ2V0IHJvb3RWaWV3KCkge1xyXG4gICAgICAgIGZvciAobGV0IHYgPSB0aGlzOzspIHtcclxuICAgICAgICAgICAgbGV0IHBhcmVudCA9IHYucGFyZW50O1xyXG4gICAgICAgICAgICBpZiAoIXBhcmVudClcclxuICAgICAgICAgICAgICAgIHJldHVybiB2O1xyXG4gICAgICAgICAgICB2ID0gcGFyZW50O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJlcGxhY2VDaGlsZHJlbihmcm9tLCB0bywgY2hpbGRyZW4gPSBub0NoaWxkcmVuKSB7XHJcbiAgICAgICAgdGhpcy5tYXJrRGlydHkoKTtcclxuICAgICAgICBmb3IgKGxldCBpID0gZnJvbTsgaSA8IHRvOyBpKyspIHtcclxuICAgICAgICAgICAgbGV0IGNoaWxkID0gdGhpcy5jaGlsZHJlbltpXTtcclxuICAgICAgICAgICAgaWYgKGNoaWxkLnBhcmVudCA9PSB0aGlzKVxyXG4gICAgICAgICAgICAgICAgY2hpbGQuZGVzdHJveSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmNoaWxkcmVuLnNwbGljZShmcm9tLCB0byAtIGZyb20sIC4uLmNoaWxkcmVuKTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKVxyXG4gICAgICAgICAgICBjaGlsZHJlbltpXS5zZXRQYXJlbnQodGhpcyk7XHJcbiAgICB9XHJcbiAgICBpZ25vcmVNdXRhdGlvbihfcmVjKSB7IHJldHVybiBmYWxzZTsgfVxyXG4gICAgaWdub3JlRXZlbnQoX2V2ZW50KSB7IHJldHVybiBmYWxzZTsgfVxyXG4gICAgY2hpbGRDdXJzb3IocG9zID0gdGhpcy5sZW5ndGgpIHtcclxuICAgICAgICByZXR1cm4gbmV3IENoaWxkQ3Vyc29yKHRoaXMuY2hpbGRyZW4sIHBvcywgdGhpcy5jaGlsZHJlbi5sZW5ndGgpO1xyXG4gICAgfVxyXG4gICAgY2hpbGRQb3MocG9zLCBiaWFzID0gMSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNoaWxkQ3Vyc29yKCkuZmluZFBvcyhwb3MsIGJpYXMpO1xyXG4gICAgfVxyXG4gICAgdG9TdHJpbmcoKSB7XHJcbiAgICAgICAgbGV0IG5hbWUgPSB0aGlzLmNvbnN0cnVjdG9yLm5hbWUucmVwbGFjZShcIlZpZXdcIiwgXCJcIik7XHJcbiAgICAgICAgcmV0dXJuIG5hbWUgKyAodGhpcy5jaGlsZHJlbi5sZW5ndGggPyBcIihcIiArIHRoaXMuY2hpbGRyZW4uam9pbigpICsgXCIpXCIgOlxyXG4gICAgICAgICAgICB0aGlzLmxlbmd0aCA/IFwiW1wiICsgKG5hbWUgPT0gXCJUZXh0XCIgPyB0aGlzLnRleHQgOiB0aGlzLmxlbmd0aCkgKyBcIl1cIiA6IFwiXCIpICtcclxuICAgICAgICAgICAgKHRoaXMuYnJlYWtBZnRlciA/IFwiI1wiIDogXCJcIik7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgZ2V0KG5vZGUpIHsgcmV0dXJuIG5vZGUuY21WaWV3OyB9XHJcbiAgICBnZXQgaXNFZGl0YWJsZSgpIHsgcmV0dXJuIHRydWU7IH1cclxuICAgIG1lcmdlKGZyb20sIHRvLCBzb3VyY2UsIGhhc1N0YXJ0LCBvcGVuU3RhcnQsIG9wZW5FbmQpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBiZWNvbWUob3RoZXIpIHsgcmV0dXJuIGZhbHNlOyB9XHJcbiAgICBjYW5SZXVzZURPTShvdGhlcikgeyByZXR1cm4gb3RoZXIuY29uc3RydWN0b3IgPT0gdGhpcy5jb25zdHJ1Y3RvcjsgfVxyXG4gICAgLy8gV2hlbiB0aGlzIGlzIGEgemVyby1sZW5ndGggdmlldyB3aXRoIGEgc2lkZSwgdGhpcyBzaG91bGQgcmV0dXJuIGFcclxuICAgIC8vIG51bWJlciA8PSAwIHRvIGluZGljYXRlIGl0IGlzIGJlZm9yZSBpdHMgcG9zaXRpb24sIG9yIGFcclxuICAgIC8vIG51bWJlciA+IDAgd2hlbiBhZnRlciBpdHMgcG9zaXRpb24uXHJcbiAgICBnZXRTaWRlKCkgeyByZXR1cm4gMDsgfVxyXG4gICAgZGVzdHJveSgpIHtcclxuICAgICAgICB0aGlzLnBhcmVudCA9IG51bGw7XHJcbiAgICB9XHJcbn1cclxuQ29udGVudFZpZXcucHJvdG90eXBlLmJyZWFrQWZ0ZXIgPSAwO1xyXG4vLyBSZW1vdmUgYSBET00gbm9kZSBhbmQgcmV0dXJuIGl0cyBuZXh0IHNpYmxpbmcuXHJcbmZ1bmN0aW9uIHJtJDEoZG9tKSB7XHJcbiAgICBsZXQgbmV4dCA9IGRvbS5uZXh0U2libGluZztcclxuICAgIGRvbS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGRvbSk7XHJcbiAgICByZXR1cm4gbmV4dDtcclxufVxyXG5jbGFzcyBDaGlsZEN1cnNvciB7XHJcbiAgICBjb25zdHJ1Y3RvcihjaGlsZHJlbiwgcG9zLCBpKSB7XHJcbiAgICAgICAgdGhpcy5jaGlsZHJlbiA9IGNoaWxkcmVuO1xyXG4gICAgICAgIHRoaXMucG9zID0gcG9zO1xyXG4gICAgICAgIHRoaXMuaSA9IGk7XHJcbiAgICAgICAgdGhpcy5vZmYgPSAwO1xyXG4gICAgfVxyXG4gICAgZmluZFBvcyhwb3MsIGJpYXMgPSAxKSB7XHJcbiAgICAgICAgZm9yICg7Oykge1xyXG4gICAgICAgICAgICBpZiAocG9zID4gdGhpcy5wb3MgfHwgcG9zID09IHRoaXMucG9zICYmXHJcbiAgICAgICAgICAgICAgICAoYmlhcyA+IDAgfHwgdGhpcy5pID09IDAgfHwgdGhpcy5jaGlsZHJlblt0aGlzLmkgLSAxXS5icmVha0FmdGVyKSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5vZmYgPSBwb3MgLSB0aGlzLnBvcztcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGxldCBuZXh0ID0gdGhpcy5jaGlsZHJlblstLXRoaXMuaV07XHJcbiAgICAgICAgICAgIHRoaXMucG9zIC09IG5leHQubGVuZ3RoICsgbmV4dC5icmVha0FmdGVyO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiByZXBsYWNlUmFuZ2UocGFyZW50LCBmcm9tSSwgZnJvbU9mZiwgdG9JLCB0b09mZiwgaW5zZXJ0LCBicmVha0F0U3RhcnQsIG9wZW5TdGFydCwgb3BlbkVuZCkge1xyXG4gICAgbGV0IHsgY2hpbGRyZW4gfSA9IHBhcmVudDtcclxuICAgIGxldCBiZWZvcmUgPSBjaGlsZHJlbi5sZW5ndGggPyBjaGlsZHJlbltmcm9tSV0gOiBudWxsO1xyXG4gICAgbGV0IGxhc3QgPSBpbnNlcnQubGVuZ3RoID8gaW5zZXJ0W2luc2VydC5sZW5ndGggLSAxXSA6IG51bGw7XHJcbiAgICBsZXQgYnJlYWtBdEVuZCA9IGxhc3QgPyBsYXN0LmJyZWFrQWZ0ZXIgOiBicmVha0F0U3RhcnQ7XHJcbiAgICAvLyBDaGFuZ2Ugd2l0aGluIGEgc2luZ2xlIGNoaWxkXHJcbiAgICBpZiAoZnJvbUkgPT0gdG9JICYmIGJlZm9yZSAmJiAhYnJlYWtBdFN0YXJ0ICYmICFicmVha0F0RW5kICYmIGluc2VydC5sZW5ndGggPCAyICYmXHJcbiAgICAgICAgYmVmb3JlLm1lcmdlKGZyb21PZmYsIHRvT2ZmLCBpbnNlcnQubGVuZ3RoID8gbGFzdCA6IG51bGwsIGZyb21PZmYgPT0gMCwgb3BlblN0YXJ0LCBvcGVuRW5kKSlcclxuICAgICAgICByZXR1cm47XHJcbiAgICBpZiAodG9JIDwgY2hpbGRyZW4ubGVuZ3RoKSB7XHJcbiAgICAgICAgbGV0IGFmdGVyID0gY2hpbGRyZW5bdG9JXTtcclxuICAgICAgICAvLyBNYWtlIHN1cmUgdGhlIGVuZCBvZiB0aGUgY2hpbGQgYWZ0ZXIgdGhlIHVwZGF0ZSBpcyBwcmVzZXJ2ZWQgaW4gYGFmdGVyYFxyXG4gICAgICAgIGlmIChhZnRlciAmJiB0b09mZiA8IGFmdGVyLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAvLyBJZiB3ZSdyZSBzcGxpdHRpbmcgYSBjaGlsZCwgc2VwYXJhdGUgcGFydCBvZiBpdCB0byBhdm9pZCB0aGF0XHJcbiAgICAgICAgICAgIC8vIGJlaW5nIG1hbmdsZWQgd2hlbiB1cGRhdGluZyB0aGUgY2hpbGQgYmVmb3JlIHRoZSB1cGRhdGUuXHJcbiAgICAgICAgICAgIGlmIChmcm9tSSA9PSB0b0kpIHtcclxuICAgICAgICAgICAgICAgIGFmdGVyID0gYWZ0ZXIuc3BsaXQodG9PZmYpO1xyXG4gICAgICAgICAgICAgICAgdG9PZmYgPSAwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIElmIHRoZSBlbGVtZW50IGFmdGVyIHRoZSByZXBsYWNlbWVudCBzaG91bGQgYmUgbWVyZ2VkIHdpdGhcclxuICAgICAgICAgICAgLy8gdGhlIGxhc3QgcmVwbGFjaW5nIGVsZW1lbnQsIHVwZGF0ZSBgY29udGVudGBcclxuICAgICAgICAgICAgaWYgKCFicmVha0F0RW5kICYmIGxhc3QgJiYgYWZ0ZXIubWVyZ2UoMCwgdG9PZmYsIGxhc3QsIHRydWUsIDAsIG9wZW5FbmQpKSB7XHJcbiAgICAgICAgICAgICAgICBpbnNlcnRbaW5zZXJ0Lmxlbmd0aCAtIDFdID0gYWZ0ZXI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyBSZW1vdmUgdGhlIHN0YXJ0IG9mIHRoZSBhZnRlciBlbGVtZW50LCBpZiBuZWNlc3NhcnksIGFuZFxyXG4gICAgICAgICAgICAgICAgLy8gYWRkIGl0IHRvIGBjb250ZW50YC5cclxuICAgICAgICAgICAgICAgIGlmICh0b09mZilcclxuICAgICAgICAgICAgICAgICAgICBhZnRlci5tZXJnZSgwLCB0b09mZiwgbnVsbCwgZmFsc2UsIDAsIG9wZW5FbmQpO1xyXG4gICAgICAgICAgICAgICAgaW5zZXJ0LnB1c2goYWZ0ZXIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGFmdGVyID09PSBudWxsIHx8IGFmdGVyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBhZnRlci5icmVha0FmdGVyKSB7XHJcbiAgICAgICAgICAgIC8vIFRoZSBlbGVtZW50IGF0IGB0b0lgIGlzIGVudGlyZWx5IGNvdmVyZWQgYnkgdGhpcyByYW5nZS5cclxuICAgICAgICAgICAgLy8gUHJlc2VydmUgaXRzIGxpbmUgYnJlYWssIGlmIGFueS5cclxuICAgICAgICAgICAgaWYgKGxhc3QpXHJcbiAgICAgICAgICAgICAgICBsYXN0LmJyZWFrQWZ0ZXIgPSAxO1xyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICBicmVha0F0U3RhcnQgPSAxO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBTaW5jZSB3ZSd2ZSBoYW5kbGVkIHRoZSBuZXh0IGVsZW1lbnQgZnJvbSB0aGUgY3VycmVudCBlbGVtZW50c1xyXG4gICAgICAgIC8vIG5vdywgbWFrZSBzdXJlIGB0b0lgIHBvaW50cyBhZnRlciB0aGF0LlxyXG4gICAgICAgIHRvSSsrO1xyXG4gICAgfVxyXG4gICAgaWYgKGJlZm9yZSkge1xyXG4gICAgICAgIGJlZm9yZS5icmVha0FmdGVyID0gYnJlYWtBdFN0YXJ0O1xyXG4gICAgICAgIGlmIChmcm9tT2ZmID4gMCkge1xyXG4gICAgICAgICAgICBpZiAoIWJyZWFrQXRTdGFydCAmJiBpbnNlcnQubGVuZ3RoICYmIGJlZm9yZS5tZXJnZShmcm9tT2ZmLCBiZWZvcmUubGVuZ3RoLCBpbnNlcnRbMF0sIGZhbHNlLCBvcGVuU3RhcnQsIDApKSB7XHJcbiAgICAgICAgICAgICAgICBiZWZvcmUuYnJlYWtBZnRlciA9IGluc2VydC5zaGlmdCgpLmJyZWFrQWZ0ZXI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoZnJvbU9mZiA8IGJlZm9yZS5sZW5ndGggfHwgYmVmb3JlLmNoaWxkcmVuLmxlbmd0aCAmJiBiZWZvcmUuY2hpbGRyZW5bYmVmb3JlLmNoaWxkcmVuLmxlbmd0aCAtIDFdLmxlbmd0aCA9PSAwKSB7XHJcbiAgICAgICAgICAgICAgICBiZWZvcmUubWVyZ2UoZnJvbU9mZiwgYmVmb3JlLmxlbmd0aCwgbnVsbCwgZmFsc2UsIG9wZW5TdGFydCwgMCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZnJvbUkrKztcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvLyBUcnkgdG8gbWVyZ2Ugd2lkZ2V0cyBvbiB0aGUgYm91bmRhcmllcyBvZiB0aGUgcmVwbGFjZW1lbnRcclxuICAgIHdoaWxlIChmcm9tSSA8IHRvSSAmJiBpbnNlcnQubGVuZ3RoKSB7XHJcbiAgICAgICAgaWYgKGNoaWxkcmVuW3RvSSAtIDFdLmJlY29tZShpbnNlcnRbaW5zZXJ0Lmxlbmd0aCAtIDFdKSkge1xyXG4gICAgICAgICAgICB0b0ktLTtcclxuICAgICAgICAgICAgaW5zZXJ0LnBvcCgpO1xyXG4gICAgICAgICAgICBvcGVuRW5kID0gaW5zZXJ0Lmxlbmd0aCA/IDAgOiBvcGVuU3RhcnQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGNoaWxkcmVuW2Zyb21JXS5iZWNvbWUoaW5zZXJ0WzBdKSkge1xyXG4gICAgICAgICAgICBmcm9tSSsrO1xyXG4gICAgICAgICAgICBpbnNlcnQuc2hpZnQoKTtcclxuICAgICAgICAgICAgb3BlblN0YXJ0ID0gaW5zZXJ0Lmxlbmd0aCA/IDAgOiBvcGVuRW5kO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKCFpbnNlcnQubGVuZ3RoICYmIGZyb21JICYmIHRvSSA8IGNoaWxkcmVuLmxlbmd0aCAmJiAhY2hpbGRyZW5bZnJvbUkgLSAxXS5icmVha0FmdGVyICYmXHJcbiAgICAgICAgY2hpbGRyZW5bdG9JXS5tZXJnZSgwLCAwLCBjaGlsZHJlbltmcm9tSSAtIDFdLCBmYWxzZSwgb3BlblN0YXJ0LCBvcGVuRW5kKSlcclxuICAgICAgICBmcm9tSS0tO1xyXG4gICAgaWYgKGZyb21JIDwgdG9JIHx8IGluc2VydC5sZW5ndGgpXHJcbiAgICAgICAgcGFyZW50LnJlcGxhY2VDaGlsZHJlbihmcm9tSSwgdG9JLCBpbnNlcnQpO1xyXG59XHJcbmZ1bmN0aW9uIG1lcmdlQ2hpbGRyZW5JbnRvKHBhcmVudCwgZnJvbSwgdG8sIGluc2VydCwgb3BlblN0YXJ0LCBvcGVuRW5kKSB7XHJcbiAgICBsZXQgY3VyID0gcGFyZW50LmNoaWxkQ3Vyc29yKCk7XHJcbiAgICBsZXQgeyBpOiB0b0ksIG9mZjogdG9PZmYgfSA9IGN1ci5maW5kUG9zKHRvLCAxKTtcclxuICAgIGxldCB7IGk6IGZyb21JLCBvZmY6IGZyb21PZmYgfSA9IGN1ci5maW5kUG9zKGZyb20sIC0xKTtcclxuICAgIGxldCBkTGVuID0gZnJvbSAtIHRvO1xyXG4gICAgZm9yIChsZXQgdmlldyBvZiBpbnNlcnQpXHJcbiAgICAgICAgZExlbiArPSB2aWV3Lmxlbmd0aDtcclxuICAgIHBhcmVudC5sZW5ndGggKz0gZExlbjtcclxuICAgIHJlcGxhY2VSYW5nZShwYXJlbnQsIGZyb21JLCBmcm9tT2ZmLCB0b0ksIHRvT2ZmLCBpbnNlcnQsIDAsIG9wZW5TdGFydCwgb3BlbkVuZCk7XHJcbn1cclxuXHJcbmxldCBuYXYgPSB0eXBlb2YgbmF2aWdhdG9yICE9IFwidW5kZWZpbmVkXCIgPyBuYXZpZ2F0b3IgOiB7IHVzZXJBZ2VudDogXCJcIiwgdmVuZG9yOiBcIlwiLCBwbGF0Zm9ybTogXCJcIiB9O1xyXG5sZXQgZG9jID0gdHlwZW9mIGRvY3VtZW50ICE9IFwidW5kZWZpbmVkXCIgPyBkb2N1bWVudCA6IHsgZG9jdW1lbnRFbGVtZW50OiB7IHN0eWxlOiB7fSB9IH07XHJcbmNvbnN0IGllX2VkZ2UgPSAvKkBfX1BVUkVfXyovL0VkZ2VcXC8oXFxkKykvLmV4ZWMobmF2LnVzZXJBZ2VudCk7XHJcbmNvbnN0IGllX3VwdG8xMCA9IC8qQF9fUFVSRV9fKi8vTVNJRSBcXGQvLnRlc3QobmF2LnVzZXJBZ2VudCk7XHJcbmNvbnN0IGllXzExdXAgPSAvKkBfX1BVUkVfXyovL1RyaWRlbnRcXC8oPzpbNy05XXxcXGR7Mix9KVxcLi4qcnY6KFxcZCspLy5leGVjKG5hdi51c2VyQWdlbnQpO1xyXG5jb25zdCBpZSA9ICEhKGllX3VwdG8xMCB8fCBpZV8xMXVwIHx8IGllX2VkZ2UpO1xyXG5jb25zdCBnZWNrbyA9ICFpZSAmJiAvKkBfX1BVUkVfXyovL2dlY2tvXFwvKFxcZCspL2kudGVzdChuYXYudXNlckFnZW50KTtcclxuY29uc3QgY2hyb21lID0gIWllICYmIC8qQF9fUFVSRV9fKi8vQ2hyb21lXFwvKFxcZCspLy5leGVjKG5hdi51c2VyQWdlbnQpO1xyXG5jb25zdCB3ZWJraXQgPSBcIndlYmtpdEZvbnRTbW9vdGhpbmdcIiBpbiBkb2MuZG9jdW1lbnRFbGVtZW50LnN0eWxlO1xyXG5jb25zdCBzYWZhcmkgPSAhaWUgJiYgLypAX19QVVJFX18qLy9BcHBsZSBDb21wdXRlci8udGVzdChuYXYudmVuZG9yKTtcclxuY29uc3QgaW9zID0gc2FmYXJpICYmICgvKkBfX1BVUkVfXyovL01vYmlsZVxcL1xcdysvLnRlc3QobmF2LnVzZXJBZ2VudCkgfHwgbmF2Lm1heFRvdWNoUG9pbnRzID4gMik7XHJcbnZhciBicm93c2VyID0ge1xyXG4gICAgbWFjOiBpb3MgfHwgLypAX19QVVJFX18qLy9NYWMvLnRlc3QobmF2LnBsYXRmb3JtKSxcclxuICAgIHdpbmRvd3M6IC8qQF9fUFVSRV9fKi8vV2luLy50ZXN0KG5hdi5wbGF0Zm9ybSksXHJcbiAgICBsaW51eDogLypAX19QVVJFX18qLy9MaW51eHxYMTEvLnRlc3QobmF2LnBsYXRmb3JtKSxcclxuICAgIGllLFxyXG4gICAgaWVfdmVyc2lvbjogaWVfdXB0bzEwID8gZG9jLmRvY3VtZW50TW9kZSB8fCA2IDogaWVfMTF1cCA/ICtpZV8xMXVwWzFdIDogaWVfZWRnZSA/ICtpZV9lZGdlWzFdIDogMCxcclxuICAgIGdlY2tvLFxyXG4gICAgZ2Vja29fdmVyc2lvbjogZ2Vja28gPyArKC8qQF9fUFVSRV9fKi8vRmlyZWZveFxcLyhcXGQrKS8uZXhlYyhuYXYudXNlckFnZW50KSB8fCBbMCwgMF0pWzFdIDogMCxcclxuICAgIGNocm9tZTogISFjaHJvbWUsXHJcbiAgICBjaHJvbWVfdmVyc2lvbjogY2hyb21lID8gK2Nocm9tZVsxXSA6IDAsXHJcbiAgICBpb3MsXHJcbiAgICBhbmRyb2lkOiAvKkBfX1BVUkVfXyovL0FuZHJvaWRcXGIvLnRlc3QobmF2LnVzZXJBZ2VudCksXHJcbiAgICB3ZWJraXQsXHJcbiAgICBzYWZhcmksXHJcbiAgICB3ZWJraXRfdmVyc2lvbjogd2Via2l0ID8gKygvKkBfX1BVUkVfXyovL1xcYkFwcGxlV2ViS2l0XFwvKFxcZCspLy5leGVjKG5hdmlnYXRvci51c2VyQWdlbnQpIHx8IFswLCAwXSlbMV0gOiAwLFxyXG4gICAgdGFiU2l6ZTogZG9jLmRvY3VtZW50RWxlbWVudC5zdHlsZS50YWJTaXplICE9IG51bGwgPyBcInRhYi1zaXplXCIgOiBcIi1tb3otdGFiLXNpemVcIlxyXG59O1xyXG5cclxuY29uc3QgTWF4Sm9pbkxlbiA9IDI1NjtcclxuY2xhc3MgVGV4dFZpZXcgZXh0ZW5kcyBDb250ZW50VmlldyB7XHJcbiAgICBjb25zdHJ1Y3Rvcih0ZXh0KSB7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuICAgICAgICB0aGlzLnRleHQgPSB0ZXh0O1xyXG4gICAgfVxyXG4gICAgZ2V0IGxlbmd0aCgpIHsgcmV0dXJuIHRoaXMudGV4dC5sZW5ndGg7IH1cclxuICAgIGNyZWF0ZURPTSh0ZXh0RE9NKSB7XHJcbiAgICAgICAgdGhpcy5zZXRET00odGV4dERPTSB8fCBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSh0aGlzLnRleHQpKTtcclxuICAgIH1cclxuICAgIHN5bmModHJhY2spIHtcclxuICAgICAgICBpZiAoIXRoaXMuZG9tKVxyXG4gICAgICAgICAgICB0aGlzLmNyZWF0ZURPTSgpO1xyXG4gICAgICAgIGlmICh0aGlzLmRvbS5ub2RlVmFsdWUgIT0gdGhpcy50ZXh0KSB7XHJcbiAgICAgICAgICAgIGlmICh0cmFjayAmJiB0cmFjay5ub2RlID09IHRoaXMuZG9tKVxyXG4gICAgICAgICAgICAgICAgdHJhY2sud3JpdHRlbiA9IHRydWU7XHJcbiAgICAgICAgICAgIHRoaXMuZG9tLm5vZGVWYWx1ZSA9IHRoaXMudGV4dDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXVzZURPTShkb20pIHtcclxuICAgICAgICBpZiAoZG9tLm5vZGVUeXBlID09IDMpXHJcbiAgICAgICAgICAgIHRoaXMuY3JlYXRlRE9NKGRvbSk7XHJcbiAgICB9XHJcbiAgICBtZXJnZShmcm9tLCB0bywgc291cmNlKSB7XHJcbiAgICAgICAgaWYgKHNvdXJjZSAmJiAoIShzb3VyY2UgaW5zdGFuY2VvZiBUZXh0VmlldykgfHwgdGhpcy5sZW5ndGggLSAodG8gLSBmcm9tKSArIHNvdXJjZS5sZW5ndGggPiBNYXhKb2luTGVuKSlcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIHRoaXMudGV4dCA9IHRoaXMudGV4dC5zbGljZSgwLCBmcm9tKSArIChzb3VyY2UgPyBzb3VyY2UudGV4dCA6IFwiXCIpICsgdGhpcy50ZXh0LnNsaWNlKHRvKTtcclxuICAgICAgICB0aGlzLm1hcmtEaXJ0eSgpO1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gICAgc3BsaXQoZnJvbSkge1xyXG4gICAgICAgIGxldCByZXN1bHQgPSBuZXcgVGV4dFZpZXcodGhpcy50ZXh0LnNsaWNlKGZyb20pKTtcclxuICAgICAgICB0aGlzLnRleHQgPSB0aGlzLnRleHQuc2xpY2UoMCwgZnJvbSk7XHJcbiAgICAgICAgdGhpcy5tYXJrRGlydHkoKTtcclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG4gICAgbG9jYWxQb3NGcm9tRE9NKG5vZGUsIG9mZnNldCkge1xyXG4gICAgICAgIHJldHVybiBub2RlID09IHRoaXMuZG9tID8gb2Zmc2V0IDogb2Zmc2V0ID8gdGhpcy50ZXh0Lmxlbmd0aCA6IDA7XHJcbiAgICB9XHJcbiAgICBkb21BdFBvcyhwb3MpIHsgcmV0dXJuIG5ldyBET01Qb3ModGhpcy5kb20sIHBvcyk7IH1cclxuICAgIGRvbUJvdW5kc0Fyb3VuZChfZnJvbSwgX3RvLCBvZmZzZXQpIHtcclxuICAgICAgICByZXR1cm4geyBmcm9tOiBvZmZzZXQsIHRvOiBvZmZzZXQgKyB0aGlzLmxlbmd0aCwgc3RhcnRET006IHRoaXMuZG9tLCBlbmRET006IHRoaXMuZG9tLm5leHRTaWJsaW5nIH07XHJcbiAgICB9XHJcbiAgICBjb29yZHNBdChwb3MsIHNpZGUpIHtcclxuICAgICAgICByZXR1cm4gdGV4dENvb3Jkcyh0aGlzLmRvbSwgcG9zLCBzaWRlKTtcclxuICAgIH1cclxufVxyXG5jbGFzcyBNYXJrVmlldyBleHRlbmRzIENvbnRlbnRWaWV3IHtcclxuICAgIGNvbnN0cnVjdG9yKG1hcmssIGNoaWxkcmVuID0gW10sIGxlbmd0aCA9IDApIHtcclxuICAgICAgICBzdXBlcigpO1xyXG4gICAgICAgIHRoaXMubWFyayA9IG1hcms7XHJcbiAgICAgICAgdGhpcy5jaGlsZHJlbiA9IGNoaWxkcmVuO1xyXG4gICAgICAgIHRoaXMubGVuZ3RoID0gbGVuZ3RoO1xyXG4gICAgICAgIGZvciAobGV0IGNoIG9mIGNoaWxkcmVuKVxyXG4gICAgICAgICAgICBjaC5zZXRQYXJlbnQodGhpcyk7XHJcbiAgICB9XHJcbiAgICBzZXRBdHRycyhkb20pIHtcclxuICAgICAgICBjbGVhckF0dHJpYnV0ZXMoZG9tKTtcclxuICAgICAgICBpZiAodGhpcy5tYXJrLmNsYXNzKVxyXG4gICAgICAgICAgICBkb20uY2xhc3NOYW1lID0gdGhpcy5tYXJrLmNsYXNzO1xyXG4gICAgICAgIGlmICh0aGlzLm1hcmsuYXR0cnMpXHJcbiAgICAgICAgICAgIGZvciAobGV0IG5hbWUgaW4gdGhpcy5tYXJrLmF0dHJzKVxyXG4gICAgICAgICAgICAgICAgZG9tLnNldEF0dHJpYnV0ZShuYW1lLCB0aGlzLm1hcmsuYXR0cnNbbmFtZV0pO1xyXG4gICAgICAgIHJldHVybiBkb207XHJcbiAgICB9XHJcbiAgICByZXVzZURPTShub2RlKSB7XHJcbiAgICAgICAgaWYgKG5vZGUubm9kZU5hbWUgPT0gdGhpcy5tYXJrLnRhZ05hbWUudG9VcHBlckNhc2UoKSkge1xyXG4gICAgICAgICAgICB0aGlzLnNldERPTShub2RlKTtcclxuICAgICAgICAgICAgdGhpcy5kaXJ0eSB8PSA0IC8qIERpcnR5LkF0dHJzICovIHwgMiAvKiBEaXJ0eS5Ob2RlICovO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHN5bmModHJhY2spIHtcclxuICAgICAgICBpZiAoIXRoaXMuZG9tKVxyXG4gICAgICAgICAgICB0aGlzLnNldERPTSh0aGlzLnNldEF0dHJzKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGhpcy5tYXJrLnRhZ05hbWUpKSk7XHJcbiAgICAgICAgZWxzZSBpZiAodGhpcy5kaXJ0eSAmIDQgLyogRGlydHkuQXR0cnMgKi8pXHJcbiAgICAgICAgICAgIHRoaXMuc2V0QXR0cnModGhpcy5kb20pO1xyXG4gICAgICAgIHN1cGVyLnN5bmModHJhY2spO1xyXG4gICAgfVxyXG4gICAgbWVyZ2UoZnJvbSwgdG8sIHNvdXJjZSwgX2hhc1N0YXJ0LCBvcGVuU3RhcnQsIG9wZW5FbmQpIHtcclxuICAgICAgICBpZiAoc291cmNlICYmICghKHNvdXJjZSBpbnN0YW5jZW9mIE1hcmtWaWV3ICYmIHNvdXJjZS5tYXJrLmVxKHRoaXMubWFyaykpIHx8XHJcbiAgICAgICAgICAgIChmcm9tICYmIG9wZW5TdGFydCA8PSAwKSB8fCAodG8gPCB0aGlzLmxlbmd0aCAmJiBvcGVuRW5kIDw9IDApKSlcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIG1lcmdlQ2hpbGRyZW5JbnRvKHRoaXMsIGZyb20sIHRvLCBzb3VyY2UgPyBzb3VyY2UuY2hpbGRyZW4gOiBbXSwgb3BlblN0YXJ0IC0gMSwgb3BlbkVuZCAtIDEpO1xyXG4gICAgICAgIHRoaXMubWFya0RpcnR5KCk7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgICBzcGxpdChmcm9tKSB7XHJcbiAgICAgICAgbGV0IHJlc3VsdCA9IFtdLCBvZmYgPSAwLCBkZXRhY2hGcm9tID0gLTEsIGkgPSAwO1xyXG4gICAgICAgIGZvciAobGV0IGVsdCBvZiB0aGlzLmNoaWxkcmVuKSB7XHJcbiAgICAgICAgICAgIGxldCBlbmQgPSBvZmYgKyBlbHQubGVuZ3RoO1xyXG4gICAgICAgICAgICBpZiAoZW5kID4gZnJvbSlcclxuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKG9mZiA8IGZyb20gPyBlbHQuc3BsaXQoZnJvbSAtIG9mZikgOiBlbHQpO1xyXG4gICAgICAgICAgICBpZiAoZGV0YWNoRnJvbSA8IDAgJiYgb2ZmID49IGZyb20pXHJcbiAgICAgICAgICAgICAgICBkZXRhY2hGcm9tID0gaTtcclxuICAgICAgICAgICAgb2ZmID0gZW5kO1xyXG4gICAgICAgICAgICBpKys7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCBsZW5ndGggPSB0aGlzLmxlbmd0aCAtIGZyb207XHJcbiAgICAgICAgdGhpcy5sZW5ndGggPSBmcm9tO1xyXG4gICAgICAgIGlmIChkZXRhY2hGcm9tID4gLTEpIHtcclxuICAgICAgICAgICAgdGhpcy5jaGlsZHJlbi5sZW5ndGggPSBkZXRhY2hGcm9tO1xyXG4gICAgICAgICAgICB0aGlzLm1hcmtEaXJ0eSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbmV3IE1hcmtWaWV3KHRoaXMubWFyaywgcmVzdWx0LCBsZW5ndGgpO1xyXG4gICAgfVxyXG4gICAgZG9tQXRQb3MocG9zKSB7XHJcbiAgICAgICAgcmV0dXJuIGlubGluZURPTUF0UG9zKHRoaXMsIHBvcyk7XHJcbiAgICB9XHJcbiAgICBjb29yZHNBdChwb3MsIHNpZGUpIHtcclxuICAgICAgICByZXR1cm4gY29vcmRzSW5DaGlsZHJlbih0aGlzLCBwb3MsIHNpZGUpO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIHRleHRDb29yZHModGV4dCwgcG9zLCBzaWRlKSB7XHJcbiAgICBsZXQgbGVuZ3RoID0gdGV4dC5ub2RlVmFsdWUubGVuZ3RoO1xyXG4gICAgaWYgKHBvcyA+IGxlbmd0aClcclxuICAgICAgICBwb3MgPSBsZW5ndGg7XHJcbiAgICBsZXQgZnJvbSA9IHBvcywgdG8gPSBwb3MsIGZsYXR0ZW4gPSAwO1xyXG4gICAgaWYgKHBvcyA9PSAwICYmIHNpZGUgPCAwIHx8IHBvcyA9PSBsZW5ndGggJiYgc2lkZSA+PSAwKSB7XHJcbiAgICAgICAgaWYgKCEoYnJvd3Nlci5jaHJvbWUgfHwgYnJvd3Nlci5nZWNrbykpIHsgLy8gVGhlc2UgYnJvd3NlcnMgcmVsaWFibHkgcmV0dXJuIHZhbGlkIHJlY3RhbmdsZXMgZm9yIGVtcHR5IHJhbmdlc1xyXG4gICAgICAgICAgICBpZiAocG9zKSB7XHJcbiAgICAgICAgICAgICAgICBmcm9tLS07XHJcbiAgICAgICAgICAgICAgICBmbGF0dGVuID0gMTtcclxuICAgICAgICAgICAgfSAvLyBGSVhNRSB0aGlzIGlzIHdyb25nIGluIFJUTCB0ZXh0XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHRvIDwgbGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICB0bysrO1xyXG4gICAgICAgICAgICAgICAgZmxhdHRlbiA9IC0xO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgaWYgKHNpZGUgPCAwKVxyXG4gICAgICAgICAgICBmcm9tLS07XHJcbiAgICAgICAgZWxzZSBpZiAodG8gPCBsZW5ndGgpXHJcbiAgICAgICAgICAgIHRvKys7XHJcbiAgICB9XHJcbiAgICBsZXQgcmVjdHMgPSB0ZXh0UmFuZ2UodGV4dCwgZnJvbSwgdG8pLmdldENsaWVudFJlY3RzKCk7XHJcbiAgICBpZiAoIXJlY3RzLmxlbmd0aClcclxuICAgICAgICByZXR1cm4gUmVjdDA7XHJcbiAgICBsZXQgcmVjdCA9IHJlY3RzWyhmbGF0dGVuID8gZmxhdHRlbiA8IDAgOiBzaWRlID49IDApID8gMCA6IHJlY3RzLmxlbmd0aCAtIDFdO1xyXG4gICAgaWYgKGJyb3dzZXIuc2FmYXJpICYmICFmbGF0dGVuICYmIHJlY3Qud2lkdGggPT0gMClcclxuICAgICAgICByZWN0ID0gQXJyYXkucHJvdG90eXBlLmZpbmQuY2FsbChyZWN0cywgciA9PiByLndpZHRoKSB8fCByZWN0O1xyXG4gICAgcmV0dXJuIGZsYXR0ZW4gPyBmbGF0dGVuUmVjdChyZWN0LCBmbGF0dGVuIDwgMCkgOiByZWN0IHx8IG51bGw7XHJcbn1cclxuLy8gQWxzbyB1c2VkIGZvciBjb2xsYXBzZWQgcmFuZ2VzIHRoYXQgZG9uJ3QgaGF2ZSBhIHBsYWNlaG9sZGVyIHdpZGdldCFcclxuY2xhc3MgV2lkZ2V0VmlldyBleHRlbmRzIENvbnRlbnRWaWV3IHtcclxuICAgIGNvbnN0cnVjdG9yKHdpZGdldCwgbGVuZ3RoLCBzaWRlKSB7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuICAgICAgICB0aGlzLndpZGdldCA9IHdpZGdldDtcclxuICAgICAgICB0aGlzLmxlbmd0aCA9IGxlbmd0aDtcclxuICAgICAgICB0aGlzLnNpZGUgPSBzaWRlO1xyXG4gICAgICAgIHRoaXMucHJldldpZGdldCA9IG51bGw7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgY3JlYXRlKHdpZGdldCwgbGVuZ3RoLCBzaWRlKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyAod2lkZ2V0LmN1c3RvbVZpZXcgfHwgV2lkZ2V0Vmlldykod2lkZ2V0LCBsZW5ndGgsIHNpZGUpO1xyXG4gICAgfVxyXG4gICAgc3BsaXQoZnJvbSkge1xyXG4gICAgICAgIGxldCByZXN1bHQgPSBXaWRnZXRWaWV3LmNyZWF0ZSh0aGlzLndpZGdldCwgdGhpcy5sZW5ndGggLSBmcm9tLCB0aGlzLnNpZGUpO1xyXG4gICAgICAgIHRoaXMubGVuZ3RoIC09IGZyb207XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuICAgIHN5bmMoKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLmRvbSB8fCAhdGhpcy53aWRnZXQudXBkYXRlRE9NKHRoaXMuZG9tKSkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5kb20gJiYgdGhpcy5wcmV2V2lkZ2V0KVxyXG4gICAgICAgICAgICAgICAgdGhpcy5wcmV2V2lkZ2V0LmRlc3Ryb3kodGhpcy5kb20pO1xyXG4gICAgICAgICAgICB0aGlzLnByZXZXaWRnZXQgPSBudWxsO1xyXG4gICAgICAgICAgICB0aGlzLnNldERPTSh0aGlzLndpZGdldC50b0RPTSh0aGlzLmVkaXRvclZpZXcpKTtcclxuICAgICAgICAgICAgdGhpcy5kb20uY29udGVudEVkaXRhYmxlID0gXCJmYWxzZVwiO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGdldFNpZGUoKSB7IHJldHVybiB0aGlzLnNpZGU7IH1cclxuICAgIG1lcmdlKGZyb20sIHRvLCBzb3VyY2UsIGhhc1N0YXJ0LCBvcGVuU3RhcnQsIG9wZW5FbmQpIHtcclxuICAgICAgICBpZiAoc291cmNlICYmICghKHNvdXJjZSBpbnN0YW5jZW9mIFdpZGdldFZpZXcpIHx8ICF0aGlzLndpZGdldC5jb21wYXJlKHNvdXJjZS53aWRnZXQpIHx8XHJcbiAgICAgICAgICAgIGZyb20gPiAwICYmIG9wZW5TdGFydCA8PSAwIHx8IHRvIDwgdGhpcy5sZW5ndGggJiYgb3BlbkVuZCA8PSAwKSlcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIHRoaXMubGVuZ3RoID0gZnJvbSArIChzb3VyY2UgPyBzb3VyY2UubGVuZ3RoIDogMCkgKyAodGhpcy5sZW5ndGggLSB0byk7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgICBiZWNvbWUob3RoZXIpIHtcclxuICAgICAgICBpZiAob3RoZXIubGVuZ3RoID09IHRoaXMubGVuZ3RoICYmIG90aGVyIGluc3RhbmNlb2YgV2lkZ2V0VmlldyAmJiBvdGhlci5zaWRlID09IHRoaXMuc2lkZSkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy53aWRnZXQuY29uc3RydWN0b3IgPT0gb3RoZXIud2lkZ2V0LmNvbnN0cnVjdG9yKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMud2lkZ2V0LmVxKG90aGVyLndpZGdldCkpXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tYXJrRGlydHkodHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5kb20gJiYgIXRoaXMucHJldldpZGdldClcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnByZXZXaWRnZXQgPSB0aGlzLndpZGdldDtcclxuICAgICAgICAgICAgICAgIHRoaXMud2lkZ2V0ID0gb3RoZXIud2lkZ2V0O1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgaWdub3JlTXV0YXRpb24oKSB7IHJldHVybiB0cnVlOyB9XHJcbiAgICBpZ25vcmVFdmVudChldmVudCkgeyByZXR1cm4gdGhpcy53aWRnZXQuaWdub3JlRXZlbnQoZXZlbnQpOyB9XHJcbiAgICBnZXQgb3ZlcnJpZGVET01UZXh0KCkge1xyXG4gICAgICAgIGlmICh0aGlzLmxlbmd0aCA9PSAwKVxyXG4gICAgICAgICAgICByZXR1cm4gVGV4dC5lbXB0eTtcclxuICAgICAgICBsZXQgdG9wID0gdGhpcztcclxuICAgICAgICB3aGlsZSAodG9wLnBhcmVudClcclxuICAgICAgICAgICAgdG9wID0gdG9wLnBhcmVudDtcclxuICAgICAgICBsZXQgdmlldyA9IHRvcC5lZGl0b3JWaWV3LCB0ZXh0ID0gdmlldyAmJiB2aWV3LnN0YXRlLmRvYywgc3RhcnQgPSB0aGlzLnBvc0F0U3RhcnQ7XHJcbiAgICAgICAgcmV0dXJuIHRleHQgPyB0ZXh0LnNsaWNlKHN0YXJ0LCBzdGFydCArIHRoaXMubGVuZ3RoKSA6IFRleHQuZW1wdHk7XHJcbiAgICB9XHJcbiAgICBkb21BdFBvcyhwb3MpIHtcclxuICAgICAgICByZXR1cm4gcG9zID09IDAgPyBET01Qb3MuYmVmb3JlKHRoaXMuZG9tKSA6IERPTVBvcy5hZnRlcih0aGlzLmRvbSwgcG9zID09IHRoaXMubGVuZ3RoKTtcclxuICAgIH1cclxuICAgIGRvbUJvdW5kc0Fyb3VuZCgpIHsgcmV0dXJuIG51bGw7IH1cclxuICAgIGNvb3Jkc0F0KHBvcywgc2lkZSkge1xyXG4gICAgICAgIGxldCByZWN0cyA9IHRoaXMuZG9tLmdldENsaWVudFJlY3RzKCksIHJlY3QgPSBudWxsO1xyXG4gICAgICAgIGlmICghcmVjdHMubGVuZ3RoKVxyXG4gICAgICAgICAgICByZXR1cm4gUmVjdDA7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IHBvcyA+IDAgPyByZWN0cy5sZW5ndGggLSAxIDogMDs7IGkgKz0gKHBvcyA+IDAgPyAtMSA6IDEpKSB7XHJcbiAgICAgICAgICAgIHJlY3QgPSByZWN0c1tpXTtcclxuICAgICAgICAgICAgaWYgKHBvcyA+IDAgPyBpID09IDAgOiBpID09IHJlY3RzLmxlbmd0aCAtIDEgfHwgcmVjdC50b3AgPCByZWN0LmJvdHRvbSlcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5sZW5ndGggPyByZWN0IDogZmxhdHRlblJlY3QocmVjdCwgdGhpcy5zaWRlID4gMCk7XHJcbiAgICB9XHJcbiAgICBnZXQgaXNFZGl0YWJsZSgpIHsgcmV0dXJuIGZhbHNlOyB9XHJcbiAgICBkZXN0cm95KCkge1xyXG4gICAgICAgIHN1cGVyLmRlc3Ryb3koKTtcclxuICAgICAgICBpZiAodGhpcy5kb20pXHJcbiAgICAgICAgICAgIHRoaXMud2lkZ2V0LmRlc3Ryb3kodGhpcy5kb20pO1xyXG4gICAgfVxyXG59XHJcbmNsYXNzIENvbXBvc2l0aW9uVmlldyBleHRlbmRzIFdpZGdldFZpZXcge1xyXG4gICAgZG9tQXRQb3MocG9zKSB7XHJcbiAgICAgICAgbGV0IHsgdG9wVmlldywgdGV4dCB9ID0gdGhpcy53aWRnZXQ7XHJcbiAgICAgICAgaWYgKCF0b3BWaWV3KVxyXG4gICAgICAgICAgICByZXR1cm4gbmV3IERPTVBvcyh0ZXh0LCBNYXRoLm1pbihwb3MsIHRleHQubm9kZVZhbHVlLmxlbmd0aCkpO1xyXG4gICAgICAgIHJldHVybiBzY2FuQ29tcG9zaXRpb25UcmVlKHBvcywgMCwgdG9wVmlldywgdGV4dCwgKHYsIHApID0+IHYuZG9tQXRQb3MocCksIHAgPT4gbmV3IERPTVBvcyh0ZXh0LCBNYXRoLm1pbihwLCB0ZXh0Lm5vZGVWYWx1ZS5sZW5ndGgpKSk7XHJcbiAgICB9XHJcbiAgICBzeW5jKCkgeyB0aGlzLnNldERPTSh0aGlzLndpZGdldC50b0RPTSgpKTsgfVxyXG4gICAgbG9jYWxQb3NGcm9tRE9NKG5vZGUsIG9mZnNldCkge1xyXG4gICAgICAgIGxldCB7IHRvcFZpZXcsIHRleHQgfSA9IHRoaXMud2lkZ2V0O1xyXG4gICAgICAgIGlmICghdG9wVmlldylcclxuICAgICAgICAgICAgcmV0dXJuIE1hdGgubWluKG9mZnNldCwgdGhpcy5sZW5ndGgpO1xyXG4gICAgICAgIHJldHVybiBwb3NGcm9tRE9NSW5Db21wb3NpdGlvblRyZWUobm9kZSwgb2Zmc2V0LCB0b3BWaWV3LCB0ZXh0KTtcclxuICAgIH1cclxuICAgIGlnbm9yZU11dGF0aW9uKCkgeyByZXR1cm4gZmFsc2U7IH1cclxuICAgIGdldCBvdmVycmlkZURPTVRleHQoKSB7IHJldHVybiBudWxsOyB9XHJcbiAgICBjb29yZHNBdChwb3MsIHNpZGUpIHtcclxuICAgICAgICBsZXQgeyB0b3BWaWV3LCB0ZXh0IH0gPSB0aGlzLndpZGdldDtcclxuICAgICAgICBpZiAoIXRvcFZpZXcpXHJcbiAgICAgICAgICAgIHJldHVybiB0ZXh0Q29vcmRzKHRleHQsIHBvcywgc2lkZSk7XHJcbiAgICAgICAgcmV0dXJuIHNjYW5Db21wb3NpdGlvblRyZWUocG9zLCBzaWRlLCB0b3BWaWV3LCB0ZXh0LCAodiwgcG9zLCBzaWRlKSA9PiB2LmNvb3Jkc0F0KHBvcywgc2lkZSksIChwb3MsIHNpZGUpID0+IHRleHRDb29yZHModGV4dCwgcG9zLCBzaWRlKSk7XHJcbiAgICB9XHJcbiAgICBkZXN0cm95KCkge1xyXG4gICAgICAgIHZhciBfYTtcclxuICAgICAgICBzdXBlci5kZXN0cm95KCk7XHJcbiAgICAgICAgKF9hID0gdGhpcy53aWRnZXQudG9wVmlldykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmRlc3Ryb3koKTtcclxuICAgIH1cclxuICAgIGdldCBpc0VkaXRhYmxlKCkgeyByZXR1cm4gdHJ1ZTsgfVxyXG4gICAgY2FuUmV1c2VET00oKSB7IHJldHVybiB0cnVlOyB9XHJcbn1cclxuLy8gVXNlcyB0aGUgb2xkIHN0cnVjdHVyZSBvZiBhIGNodW5rIG9mIGNvbnRlbnQgdmlldyBmcm96ZW4gZm9yXHJcbi8vIGNvbXBvc2l0aW9uIHRvIHRyeSBhbmQgZmluZCBhIHJlYXNvbmFibGUgRE9NIGxvY2F0aW9uIGZvciB0aGUgZ2l2ZW5cclxuLy8gb2Zmc2V0LlxyXG5mdW5jdGlvbiBzY2FuQ29tcG9zaXRpb25UcmVlKHBvcywgc2lkZSwgdmlldywgdGV4dCwgZW50ZXJWaWV3LCBmcm9tVGV4dCkge1xyXG4gICAgaWYgKHZpZXcgaW5zdGFuY2VvZiBNYXJrVmlldykge1xyXG4gICAgICAgIGZvciAobGV0IGNoaWxkID0gdmlldy5kb20uZmlyc3RDaGlsZDsgY2hpbGQ7IGNoaWxkID0gY2hpbGQubmV4dFNpYmxpbmcpIHtcclxuICAgICAgICAgICAgbGV0IGRlc2MgPSBDb250ZW50Vmlldy5nZXQoY2hpbGQpO1xyXG4gICAgICAgICAgICBpZiAoIWRlc2MpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZnJvbVRleHQocG9zLCBzaWRlKTtcclxuICAgICAgICAgICAgbGV0IGhhc0NvbXAgPSBjb250YWlucyhjaGlsZCwgdGV4dCk7XHJcbiAgICAgICAgICAgIGxldCBsZW4gPSBkZXNjLmxlbmd0aCArIChoYXNDb21wID8gdGV4dC5ub2RlVmFsdWUubGVuZ3RoIDogMCk7XHJcbiAgICAgICAgICAgIGlmIChwb3MgPCBsZW4gfHwgcG9zID09IGxlbiAmJiBkZXNjLmdldFNpZGUoKSA8PSAwKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGhhc0NvbXAgPyBzY2FuQ29tcG9zaXRpb25UcmVlKHBvcywgc2lkZSwgZGVzYywgdGV4dCwgZW50ZXJWaWV3LCBmcm9tVGV4dCkgOiBlbnRlclZpZXcoZGVzYywgcG9zLCBzaWRlKTtcclxuICAgICAgICAgICAgcG9zIC09IGxlbjtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGVudGVyVmlldyh2aWV3LCB2aWV3Lmxlbmd0aCwgLTEpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAodmlldy5kb20gPT0gdGV4dCkge1xyXG4gICAgICAgIHJldHVybiBmcm9tVGV4dChwb3MsIHNpZGUpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIGVudGVyVmlldyh2aWV3LCBwb3MsIHNpZGUpO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIHBvc0Zyb21ET01JbkNvbXBvc2l0aW9uVHJlZShub2RlLCBvZmZzZXQsIHZpZXcsIHRleHQpIHtcclxuICAgIGlmICh2aWV3IGluc3RhbmNlb2YgTWFya1ZpZXcpIHtcclxuICAgICAgICBmb3IgKGxldCBjaGlsZCBvZiB2aWV3LmNoaWxkcmVuKSB7XHJcbiAgICAgICAgICAgIGxldCBwb3MgPSAwLCBoYXNDb21wID0gY29udGFpbnMoY2hpbGQuZG9tLCB0ZXh0KTtcclxuICAgICAgICAgICAgaWYgKGNvbnRhaW5zKGNoaWxkLmRvbSwgbm9kZSkpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcG9zICsgKGhhc0NvbXAgPyBwb3NGcm9tRE9NSW5Db21wb3NpdGlvblRyZWUobm9kZSwgb2Zmc2V0LCBjaGlsZCwgdGV4dCkgOiBjaGlsZC5sb2NhbFBvc0Zyb21ET00obm9kZSwgb2Zmc2V0KSk7XHJcbiAgICAgICAgICAgIHBvcyArPSBoYXNDb21wID8gdGV4dC5ub2RlVmFsdWUubGVuZ3RoIDogY2hpbGQubGVuZ3RoO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHZpZXcuZG9tID09IHRleHQpIHtcclxuICAgICAgICByZXR1cm4gTWF0aC5taW4ob2Zmc2V0LCB0ZXh0Lm5vZGVWYWx1ZS5sZW5ndGgpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHZpZXcubG9jYWxQb3NGcm9tRE9NKG5vZGUsIG9mZnNldCk7XHJcbn1cclxuLy8gVGhlc2UgYXJlIGRyYXduIGFyb3VuZCB1bmVkaXRhYmxlIHdpZGdldHMgdG8gYXZvaWQgYSBudW1iZXIgb2ZcclxuLy8gYnJvd3NlciBidWdzIHRoYXQgc2hvdyB1cCB3aGVuIHRoZSBjdXJzb3IgaXMgZGlyZWN0bHkgbmV4dCB0b1xyXG4vLyB1bmVkaXRhYmxlIGlubGluZSBjb250ZW50LlxyXG5jbGFzcyBXaWRnZXRCdWZmZXJWaWV3IGV4dGVuZHMgQ29udGVudFZpZXcge1xyXG4gICAgY29uc3RydWN0b3Ioc2lkZSkge1xyXG4gICAgICAgIHN1cGVyKCk7XHJcbiAgICAgICAgdGhpcy5zaWRlID0gc2lkZTtcclxuICAgIH1cclxuICAgIGdldCBsZW5ndGgoKSB7IHJldHVybiAwOyB9XHJcbiAgICBtZXJnZSgpIHsgcmV0dXJuIGZhbHNlOyB9XHJcbiAgICBiZWNvbWUob3RoZXIpIHtcclxuICAgICAgICByZXR1cm4gb3RoZXIgaW5zdGFuY2VvZiBXaWRnZXRCdWZmZXJWaWV3ICYmIG90aGVyLnNpZGUgPT0gdGhpcy5zaWRlO1xyXG4gICAgfVxyXG4gICAgc3BsaXQoKSB7IHJldHVybiBuZXcgV2lkZ2V0QnVmZmVyVmlldyh0aGlzLnNpZGUpOyB9XHJcbiAgICBzeW5jKCkge1xyXG4gICAgICAgIGlmICghdGhpcy5kb20pIHtcclxuICAgICAgICAgICAgbGV0IGRvbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpbWdcIik7XHJcbiAgICAgICAgICAgIGRvbS5jbGFzc05hbWUgPSBcImNtLXdpZGdldEJ1ZmZlclwiO1xyXG4gICAgICAgICAgICBkb20uc2V0QXR0cmlidXRlKFwiYXJpYS1oaWRkZW5cIiwgXCJ0cnVlXCIpO1xyXG4gICAgICAgICAgICB0aGlzLnNldERPTShkb20pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGdldFNpZGUoKSB7IHJldHVybiB0aGlzLnNpZGU7IH1cclxuICAgIGRvbUF0UG9zKHBvcykgeyByZXR1cm4gRE9NUG9zLmJlZm9yZSh0aGlzLmRvbSk7IH1cclxuICAgIGxvY2FsUG9zRnJvbURPTSgpIHsgcmV0dXJuIDA7IH1cclxuICAgIGRvbUJvdW5kc0Fyb3VuZCgpIHsgcmV0dXJuIG51bGw7IH1cclxuICAgIGNvb3Jkc0F0KHBvcykge1xyXG4gICAgICAgIGxldCBpbWdSZWN0ID0gdGhpcy5kb20uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XHJcbiAgICAgICAgLy8gU2luY2UgdGhlIDxpbWc+IGhlaWdodCBkb2Vzbid0IGNvcnJlc3BvbmQgdG8gdGV4dCBoZWlnaHQsIHRyeVxyXG4gICAgICAgIC8vIHRvIGJvcnJvdyB0aGUgaGVpZ2h0IGZyb20gc29tZSBzaWJsaW5nIG5vZGUuXHJcbiAgICAgICAgbGV0IHNpYmxpbmdSZWN0ID0gaW5saW5lU2libGluZ1JlY3QodGhpcywgdGhpcy5zaWRlID4gMCA/IC0xIDogMSk7XHJcbiAgICAgICAgcmV0dXJuIHNpYmxpbmdSZWN0ICYmIHNpYmxpbmdSZWN0LnRvcCA8IGltZ1JlY3QuYm90dG9tICYmIHNpYmxpbmdSZWN0LmJvdHRvbSA+IGltZ1JlY3QudG9wXHJcbiAgICAgICAgICAgID8geyBsZWZ0OiBpbWdSZWN0LmxlZnQsIHJpZ2h0OiBpbWdSZWN0LnJpZ2h0LCB0b3A6IHNpYmxpbmdSZWN0LnRvcCwgYm90dG9tOiBzaWJsaW5nUmVjdC5ib3R0b20gfSA6IGltZ1JlY3Q7XHJcbiAgICB9XHJcbiAgICBnZXQgb3ZlcnJpZGVET01UZXh0KCkge1xyXG4gICAgICAgIHJldHVybiBUZXh0LmVtcHR5O1xyXG4gICAgfVxyXG59XHJcblRleHRWaWV3LnByb3RvdHlwZS5jaGlsZHJlbiA9IFdpZGdldFZpZXcucHJvdG90eXBlLmNoaWxkcmVuID0gV2lkZ2V0QnVmZmVyVmlldy5wcm90b3R5cGUuY2hpbGRyZW4gPSBub0NoaWxkcmVuO1xyXG5mdW5jdGlvbiBpbmxpbmVTaWJsaW5nUmVjdCh2aWV3LCBzaWRlKSB7XHJcbiAgICBsZXQgcGFyZW50ID0gdmlldy5wYXJlbnQsIGluZGV4ID0gcGFyZW50ID8gcGFyZW50LmNoaWxkcmVuLmluZGV4T2YodmlldykgOiAtMTtcclxuICAgIHdoaWxlIChwYXJlbnQgJiYgaW5kZXggPj0gMCkge1xyXG4gICAgICAgIGlmIChzaWRlIDwgMCA/IGluZGV4ID4gMCA6IGluZGV4IDwgcGFyZW50LmNoaWxkcmVuLmxlbmd0aCkge1xyXG4gICAgICAgICAgICBsZXQgbmV4dCA9IHBhcmVudC5jaGlsZHJlbltpbmRleCArIHNpZGVdO1xyXG4gICAgICAgICAgICBpZiAobmV4dCBpbnN0YW5jZW9mIFRleHRWaWV3KSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgbmV4dFJlY3QgPSBuZXh0LmNvb3Jkc0F0KHNpZGUgPCAwID8gbmV4dC5sZW5ndGggOiAwLCBzaWRlKTtcclxuICAgICAgICAgICAgICAgIGlmIChuZXh0UmVjdClcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV4dFJlY3Q7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaW5kZXggKz0gc2lkZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAocGFyZW50IGluc3RhbmNlb2YgTWFya1ZpZXcgJiYgcGFyZW50LnBhcmVudCkge1xyXG4gICAgICAgICAgICBpbmRleCA9IHBhcmVudC5wYXJlbnQuY2hpbGRyZW4uaW5kZXhPZihwYXJlbnQpICsgKHNpZGUgPCAwID8gMCA6IDEpO1xyXG4gICAgICAgICAgICBwYXJlbnQgPSBwYXJlbnQucGFyZW50O1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgbGV0IGxhc3QgPSBwYXJlbnQuZG9tLmxhc3RDaGlsZDtcclxuICAgICAgICAgICAgaWYgKGxhc3QgJiYgbGFzdC5ub2RlTmFtZSA9PSBcIkJSXCIpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbGFzdC5nZXRDbGllbnRSZWN0cygpWzBdO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG59XHJcbmZ1bmN0aW9uIGlubGluZURPTUF0UG9zKHBhcmVudCwgcG9zKSB7XHJcbiAgICBsZXQgZG9tID0gcGFyZW50LmRvbSwgeyBjaGlsZHJlbiB9ID0gcGFyZW50LCBpID0gMDtcclxuICAgIGZvciAobGV0IG9mZiA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGxldCBjaGlsZCA9IGNoaWxkcmVuW2ldLCBlbmQgPSBvZmYgKyBjaGlsZC5sZW5ndGg7XHJcbiAgICAgICAgaWYgKGVuZCA9PSBvZmYgJiYgY2hpbGQuZ2V0U2lkZSgpIDw9IDApXHJcbiAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgIGlmIChwb3MgPiBvZmYgJiYgcG9zIDwgZW5kICYmIGNoaWxkLmRvbS5wYXJlbnROb2RlID09IGRvbSlcclxuICAgICAgICAgICAgcmV0dXJuIGNoaWxkLmRvbUF0UG9zKHBvcyAtIG9mZik7XHJcbiAgICAgICAgaWYgKHBvcyA8PSBvZmYpXHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIG9mZiA9IGVuZDtcclxuICAgIH1cclxuICAgIGZvciAobGV0IGogPSBpOyBqID4gMDsgai0tKSB7XHJcbiAgICAgICAgbGV0IHByZXYgPSBjaGlsZHJlbltqIC0gMV07XHJcbiAgICAgICAgaWYgKHByZXYuZG9tLnBhcmVudE5vZGUgPT0gZG9tKVxyXG4gICAgICAgICAgICByZXR1cm4gcHJldi5kb21BdFBvcyhwcmV2Lmxlbmd0aCk7XHJcbiAgICB9XHJcbiAgICBmb3IgKGxldCBqID0gaTsgaiA8IGNoaWxkcmVuLmxlbmd0aDsgaisrKSB7XHJcbiAgICAgICAgbGV0IG5leHQgPSBjaGlsZHJlbltqXTtcclxuICAgICAgICBpZiAobmV4dC5kb20ucGFyZW50Tm9kZSA9PSBkb20pXHJcbiAgICAgICAgICAgIHJldHVybiBuZXh0LmRvbUF0UG9zKDApO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG5ldyBET01Qb3MoZG9tLCAwKTtcclxufVxyXG4vLyBBc3N1bWVzIGB2aWV3YCwgaWYgYSBtYXJrIHZpZXcsIGhhcyBwcmVjaXNlbHkgMSBjaGlsZC5cclxuZnVuY3Rpb24gam9pbklubGluZUludG8ocGFyZW50LCB2aWV3LCBvcGVuKSB7XHJcbiAgICBsZXQgbGFzdCwgeyBjaGlsZHJlbiB9ID0gcGFyZW50O1xyXG4gICAgaWYgKG9wZW4gPiAwICYmIHZpZXcgaW5zdGFuY2VvZiBNYXJrVmlldyAmJiBjaGlsZHJlbi5sZW5ndGggJiZcclxuICAgICAgICAobGFzdCA9IGNoaWxkcmVuW2NoaWxkcmVuLmxlbmd0aCAtIDFdKSBpbnN0YW5jZW9mIE1hcmtWaWV3ICYmIGxhc3QubWFyay5lcSh2aWV3Lm1hcmspKSB7XHJcbiAgICAgICAgam9pbklubGluZUludG8obGFzdCwgdmlldy5jaGlsZHJlblswXSwgb3BlbiAtIDEpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgY2hpbGRyZW4ucHVzaCh2aWV3KTtcclxuICAgICAgICB2aWV3LnNldFBhcmVudChwYXJlbnQpO1xyXG4gICAgfVxyXG4gICAgcGFyZW50Lmxlbmd0aCArPSB2aWV3Lmxlbmd0aDtcclxufVxyXG5mdW5jdGlvbiBjb29yZHNJbkNoaWxkcmVuKHZpZXcsIHBvcywgc2lkZSkge1xyXG4gICAgbGV0IGJlZm9yZSA9IG51bGwsIGJlZm9yZVBvcyA9IC0xLCBhZnRlciA9IG51bGwsIGFmdGVyUG9zID0gLTE7XHJcbiAgICBmdW5jdGlvbiBzY2FuKHZpZXcsIHBvcykge1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBvZmYgPSAwOyBpIDwgdmlldy5jaGlsZHJlbi5sZW5ndGggJiYgb2ZmIDw9IHBvczsgaSsrKSB7XHJcbiAgICAgICAgICAgIGxldCBjaGlsZCA9IHZpZXcuY2hpbGRyZW5baV0sIGVuZCA9IG9mZiArIGNoaWxkLmxlbmd0aDtcclxuICAgICAgICAgICAgaWYgKGVuZCA+PSBwb3MpIHtcclxuICAgICAgICAgICAgICAgIGlmIChjaGlsZC5jaGlsZHJlbi5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgICAgICBzY2FuKGNoaWxkLCBwb3MgLSBvZmYpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoIWFmdGVyICYmIChlbmQgPiBwb3MgfHwgb2ZmID09IGVuZCAmJiBjaGlsZC5nZXRTaWRlKCkgPiAwKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGFmdGVyID0gY2hpbGQ7XHJcbiAgICAgICAgICAgICAgICAgICAgYWZ0ZXJQb3MgPSBwb3MgLSBvZmY7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChvZmYgPCBwb3MgfHwgKG9mZiA9PSBlbmQgJiYgY2hpbGQuZ2V0U2lkZSgpIDwgMCkpIHtcclxuICAgICAgICAgICAgICAgICAgICBiZWZvcmUgPSBjaGlsZDtcclxuICAgICAgICAgICAgICAgICAgICBiZWZvcmVQb3MgPSBwb3MgLSBvZmY7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgb2ZmID0gZW5kO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHNjYW4odmlldywgcG9zKTtcclxuICAgIGxldCB0YXJnZXQgPSAoc2lkZSA8IDAgPyBiZWZvcmUgOiBhZnRlcikgfHwgYmVmb3JlIHx8IGFmdGVyO1xyXG4gICAgaWYgKHRhcmdldClcclxuICAgICAgICByZXR1cm4gdGFyZ2V0LmNvb3Jkc0F0KE1hdGgubWF4KDAsIHRhcmdldCA9PSBiZWZvcmUgPyBiZWZvcmVQb3MgOiBhZnRlclBvcyksIHNpZGUpO1xyXG4gICAgcmV0dXJuIGZhbGxiYWNrUmVjdCh2aWV3KTtcclxufVxyXG5mdW5jdGlvbiBmYWxsYmFja1JlY3Qodmlldykge1xyXG4gICAgbGV0IGxhc3QgPSB2aWV3LmRvbS5sYXN0Q2hpbGQ7XHJcbiAgICBpZiAoIWxhc3QpXHJcbiAgICAgICAgcmV0dXJuIHZpZXcuZG9tLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xyXG4gICAgbGV0IHJlY3RzID0gY2xpZW50UmVjdHNGb3IobGFzdCk7XHJcbiAgICByZXR1cm4gcmVjdHNbcmVjdHMubGVuZ3RoIC0gMV0gfHwgbnVsbDtcclxufVxyXG5cclxuZnVuY3Rpb24gY29tYmluZUF0dHJzKHNvdXJjZSwgdGFyZ2V0KSB7XHJcbiAgICBmb3IgKGxldCBuYW1lIGluIHNvdXJjZSkge1xyXG4gICAgICAgIGlmIChuYW1lID09IFwiY2xhc3NcIiAmJiB0YXJnZXQuY2xhc3MpXHJcbiAgICAgICAgICAgIHRhcmdldC5jbGFzcyArPSBcIiBcIiArIHNvdXJjZS5jbGFzcztcclxuICAgICAgICBlbHNlIGlmIChuYW1lID09IFwic3R5bGVcIiAmJiB0YXJnZXQuc3R5bGUpXHJcbiAgICAgICAgICAgIHRhcmdldC5zdHlsZSArPSBcIjtcIiArIHNvdXJjZS5zdHlsZTtcclxuICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHRhcmdldFtuYW1lXSA9IHNvdXJjZVtuYW1lXTtcclxuICAgIH1cclxuICAgIHJldHVybiB0YXJnZXQ7XHJcbn1cclxuZnVuY3Rpb24gYXR0cnNFcShhLCBiKSB7XHJcbiAgICBpZiAoYSA9PSBiKVxyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgaWYgKCFhIHx8ICFiKVxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIGxldCBrZXlzQSA9IE9iamVjdC5rZXlzKGEpLCBrZXlzQiA9IE9iamVjdC5rZXlzKGIpO1xyXG4gICAgaWYgKGtleXNBLmxlbmd0aCAhPSBrZXlzQi5sZW5ndGgpXHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgZm9yIChsZXQga2V5IG9mIGtleXNBKSB7XHJcbiAgICAgICAgaWYgKGtleXNCLmluZGV4T2Yoa2V5KSA9PSAtMSB8fCBhW2tleV0gIT09IGJba2V5XSlcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRydWU7XHJcbn1cclxuZnVuY3Rpb24gdXBkYXRlQXR0cnMoZG9tLCBwcmV2LCBhdHRycykge1xyXG4gICAgbGV0IGNoYW5nZWQgPSBudWxsO1xyXG4gICAgaWYgKHByZXYpXHJcbiAgICAgICAgZm9yIChsZXQgbmFtZSBpbiBwcmV2KVxyXG4gICAgICAgICAgICBpZiAoIShhdHRycyAmJiBuYW1lIGluIGF0dHJzKSlcclxuICAgICAgICAgICAgICAgIGRvbS5yZW1vdmVBdHRyaWJ1dGUoY2hhbmdlZCA9IG5hbWUpO1xyXG4gICAgaWYgKGF0dHJzKVxyXG4gICAgICAgIGZvciAobGV0IG5hbWUgaW4gYXR0cnMpXHJcbiAgICAgICAgICAgIGlmICghKHByZXYgJiYgcHJldltuYW1lXSA9PSBhdHRyc1tuYW1lXSkpXHJcbiAgICAgICAgICAgICAgICBkb20uc2V0QXR0cmlidXRlKGNoYW5nZWQgPSBuYW1lLCBhdHRyc1tuYW1lXSk7XHJcbiAgICByZXR1cm4gISFjaGFuZ2VkO1xyXG59XHJcblxyXG4vKipcclxuV2lkZ2V0cyBhZGRlZCB0byB0aGUgY29udGVudCBhcmUgZGVzY3JpYmVkIGJ5IHN1YmNsYXNzZXMgb2YgdGhpc1xyXG5jbGFzcy4gVXNpbmcgYSBkZXNjcmlwdGlvbiBvYmplY3QgbGlrZSB0aGF0IG1ha2VzIGl0IHBvc3NpYmxlIHRvXHJcbmRlbGF5IGNyZWF0aW5nIG9mIHRoZSBET00gc3RydWN0dXJlIGZvciBhIHdpZGdldCB1bnRpbCBpdCBpc1xyXG5uZWVkZWQsIGFuZCB0byBhdm9pZCByZWRyYXdpbmcgd2lkZ2V0cyBldmVuIGlmIHRoZSBkZWNvcmF0aW9uc1xyXG50aGF0IGRlZmluZSB0aGVtIGFyZSByZWNyZWF0ZWQuXHJcbiovXHJcbmNsYXNzIFdpZGdldFR5cGUge1xyXG4gICAgLyoqXHJcbiAgICBDb21wYXJlIHRoaXMgaW5zdGFuY2UgdG8gYW5vdGhlciBpbnN0YW5jZSBvZiB0aGUgc2FtZSB0eXBlLlxyXG4gICAgKFR5cGVTY3JpcHQgY2FuJ3QgZXhwcmVzcyB0aGlzLCBidXQgb25seSBpbnN0YW5jZXMgb2YgdGhlIHNhbWVcclxuICAgIHNwZWNpZmljIGNsYXNzIHdpbGwgYmUgcGFzc2VkIHRvIHRoaXMgbWV0aG9kLikgVGhpcyBpcyB1c2VkIHRvXHJcbiAgICBhdm9pZCByZWRyYXdpbmcgd2lkZ2V0cyB3aGVuIHRoZXkgYXJlIHJlcGxhY2VkIGJ5IGEgbmV3XHJcbiAgICBkZWNvcmF0aW9uIG9mIHRoZSBzYW1lIHR5cGUuIFRoZSBkZWZhdWx0IGltcGxlbWVudGF0aW9uIGp1c3RcclxuICAgIHJldHVybnMgYGZhbHNlYCwgd2hpY2ggd2lsbCBjYXVzZSBuZXcgaW5zdGFuY2VzIG9mIHRoZSB3aWRnZXQgdG9cclxuICAgIGFsd2F5cyBiZSByZWRyYXduLlxyXG4gICAgKi9cclxuICAgIGVxKHdpZGdldCkgeyByZXR1cm4gZmFsc2U7IH1cclxuICAgIC8qKlxyXG4gICAgVXBkYXRlIGEgRE9NIGVsZW1lbnQgY3JlYXRlZCBieSBhIHdpZGdldCBvZiB0aGUgc2FtZSB0eXBlIChidXRcclxuICAgIGRpZmZlcmVudCwgbm9uLWBlcWAgY29udGVudCkgdG8gcmVmbGVjdCB0aGlzIHdpZGdldC4gTWF5IHJldHVyblxyXG4gICAgdHJ1ZSB0byBpbmRpY2F0ZSB0aGF0IGl0IGNvdWxkIHVwZGF0ZSwgZmFsc2UgdG8gaW5kaWNhdGUgaXRcclxuICAgIGNvdWxkbid0IChpbiB3aGljaCBjYXNlIHRoZSB3aWRnZXQgd2lsbCBiZSByZWRyYXduKS4gVGhlIGRlZmF1bHRcclxuICAgIGltcGxlbWVudGF0aW9uIGp1c3QgcmV0dXJucyBmYWxzZS5cclxuICAgICovXHJcbiAgICB1cGRhdGVET00oZG9tKSB7IHJldHVybiBmYWxzZTsgfVxyXG4gICAgLyoqXHJcbiAgICBAaW50ZXJuYWxcclxuICAgICovXHJcbiAgICBjb21wYXJlKG90aGVyKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMgPT0gb3RoZXIgfHwgdGhpcy5jb25zdHJ1Y3RvciA9PSBvdGhlci5jb25zdHJ1Y3RvciAmJiB0aGlzLmVxKG90aGVyKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgVGhlIGVzdGltYXRlZCBoZWlnaHQgdGhpcyB3aWRnZXQgd2lsbCBoYXZlLCB0byBiZSB1c2VkIHdoZW5cclxuICAgIGVzdGltYXRpbmcgdGhlIGhlaWdodCBvZiBjb250ZW50IHRoYXQgaGFzbid0IGJlZW4gZHJhd24uIE1heVxyXG4gICAgcmV0dXJuIC0xIHRvIGluZGljYXRlIHlvdSBkb24ndCBrbm93LiBUaGUgZGVmYXVsdCBpbXBsZW1lbnRhdGlvblxyXG4gICAgcmV0dXJucyAtMS5cclxuICAgICovXHJcbiAgICBnZXQgZXN0aW1hdGVkSGVpZ2h0KCkgeyByZXR1cm4gLTE7IH1cclxuICAgIC8qKlxyXG4gICAgQ2FuIGJlIHVzZWQgdG8gY29uZmlndXJlIHdoaWNoIGtpbmRzIG9mIGV2ZW50cyBpbnNpZGUgdGhlIHdpZGdldFxyXG4gICAgc2hvdWxkIGJlIGlnbm9yZWQgYnkgdGhlIGVkaXRvci4gVGhlIGRlZmF1bHQgaXMgdG8gaWdub3JlIGFsbFxyXG4gICAgZXZlbnRzLlxyXG4gICAgKi9cclxuICAgIGlnbm9yZUV2ZW50KGV2ZW50KSB7IHJldHVybiB0cnVlOyB9XHJcbiAgICAvKipcclxuICAgIEBpbnRlcm5hbFxyXG4gICAgKi9cclxuICAgIGdldCBjdXN0b21WaWV3KCkgeyByZXR1cm4gbnVsbDsgfVxyXG4gICAgLyoqXHJcbiAgICBUaGlzIGlzIGNhbGxlZCB3aGVuIHRoZSBhbiBpbnN0YW5jZSBvZiB0aGUgd2lkZ2V0IGlzIHJlbW92ZWRcclxuICAgIGZyb20gdGhlIGVkaXRvciB2aWV3LlxyXG4gICAgKi9cclxuICAgIGRlc3Ryb3koZG9tKSB7IH1cclxufVxyXG4vKipcclxuVGhlIGRpZmZlcmVudCB0eXBlcyBvZiBibG9ja3MgdGhhdCBjYW4gb2NjdXIgaW4gYW4gZWRpdG9yIHZpZXcuXHJcbiovXHJcbnZhciBCbG9ja1R5cGUgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uIChCbG9ja1R5cGUpIHtcclxuICAgIC8qKlxyXG4gICAgQSBsaW5lIG9mIHRleHQuXHJcbiAgICAqL1xyXG4gICAgQmxvY2tUeXBlW0Jsb2NrVHlwZVtcIlRleHRcIl0gPSAwXSA9IFwiVGV4dFwiO1xyXG4gICAgLyoqXHJcbiAgICBBIGJsb2NrIHdpZGdldCBhc3NvY2lhdGVkIHdpdGggdGhlIHBvc2l0aW9uIGFmdGVyIGl0LlxyXG4gICAgKi9cclxuICAgIEJsb2NrVHlwZVtCbG9ja1R5cGVbXCJXaWRnZXRCZWZvcmVcIl0gPSAxXSA9IFwiV2lkZ2V0QmVmb3JlXCI7XHJcbiAgICAvKipcclxuICAgIEEgYmxvY2sgd2lkZ2V0IGFzc29jaWF0ZWQgd2l0aCB0aGUgcG9zaXRpb24gYmVmb3JlIGl0LlxyXG4gICAgKi9cclxuICAgIEJsb2NrVHlwZVtCbG9ja1R5cGVbXCJXaWRnZXRBZnRlclwiXSA9IDJdID0gXCJXaWRnZXRBZnRlclwiO1xyXG4gICAgLyoqXHJcbiAgICBBIGJsb2NrIHdpZGdldCBbcmVwbGFjaW5nXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuRGVjb3JhdGlvbl5yZXBsYWNlKSBhIHJhbmdlIG9mIGNvbnRlbnQuXHJcbiAgICAqL1xyXG4gICAgQmxvY2tUeXBlW0Jsb2NrVHlwZVtcIldpZGdldFJhbmdlXCJdID0gM10gPSBcIldpZGdldFJhbmdlXCI7XHJcbnJldHVybiBCbG9ja1R5cGV9KShCbG9ja1R5cGUgfHwgKEJsb2NrVHlwZSA9IHt9KSk7XHJcbi8qKlxyXG5BIGRlY29yYXRpb24gcHJvdmlkZXMgaW5mb3JtYXRpb24gb24gaG93IHRvIGRyYXcgb3Igc3R5bGUgYSBwaWVjZVxyXG5vZiBjb250ZW50LiBZb3UnbGwgdXN1YWxseSB1c2UgaXQgd3JhcHBlZCBpbiBhXHJcbltgUmFuZ2VgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlJhbmdlKSwgd2hpY2ggYWRkcyBhIHN0YXJ0IGFuZCBlbmQgcG9zaXRpb24uXHJcbkBub25hYnN0cmFjdFxyXG4qL1xyXG5jbGFzcyBEZWNvcmF0aW9uIGV4dGVuZHMgUmFuZ2VWYWx1ZSB7XHJcbiAgICBjb25zdHJ1Y3RvcihcclxuICAgIC8qKlxyXG4gICAgQGludGVybmFsXHJcbiAgICAqL1xyXG4gICAgc3RhcnRTaWRlLCBcclxuICAgIC8qKlxyXG4gICAgQGludGVybmFsXHJcbiAgICAqL1xyXG4gICAgZW5kU2lkZSwgXHJcbiAgICAvKipcclxuICAgIEBpbnRlcm5hbFxyXG4gICAgKi9cclxuICAgIHdpZGdldCwgXHJcbiAgICAvKipcclxuICAgIFRoZSBjb25maWcgb2JqZWN0IHVzZWQgdG8gY3JlYXRlIHRoaXMgZGVjb3JhdGlvbi4gWW91IGNhblxyXG4gICAgaW5jbHVkZSBhZGRpdGlvbmFsIHByb3BlcnRpZXMgaW4gdGhlcmUgdG8gc3RvcmUgbWV0YWRhdGEgYWJvdXRcclxuICAgIHlvdXIgZGVjb3JhdGlvbi5cclxuICAgICovXHJcbiAgICBzcGVjKSB7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuICAgICAgICB0aGlzLnN0YXJ0U2lkZSA9IHN0YXJ0U2lkZTtcclxuICAgICAgICB0aGlzLmVuZFNpZGUgPSBlbmRTaWRlO1xyXG4gICAgICAgIHRoaXMud2lkZ2V0ID0gd2lkZ2V0O1xyXG4gICAgICAgIHRoaXMuc3BlYyA9IHNwZWM7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgIEBpbnRlcm5hbFxyXG4gICAgKi9cclxuICAgIGdldCBoZWlnaHRSZWxldmFudCgpIHsgcmV0dXJuIGZhbHNlOyB9XHJcbiAgICAvKipcclxuICAgIENyZWF0ZSBhIG1hcmsgZGVjb3JhdGlvbiwgd2hpY2ggaW5mbHVlbmNlcyB0aGUgc3R5bGluZyBvZiB0aGVcclxuICAgIGNvbnRlbnQgaW4gaXRzIHJhbmdlLiBOZXN0ZWQgbWFyayBkZWNvcmF0aW9ucyB3aWxsIGNhdXNlIG5lc3RlZFxyXG4gICAgRE9NIGVsZW1lbnRzIHRvIGJlIGNyZWF0ZWQuIE5lc3Rpbmcgb3JkZXIgaXMgZGV0ZXJtaW5lZCBieVxyXG4gICAgcHJlY2VkZW5jZSBvZiB0aGUgW2ZhY2V0XShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuRWRpdG9yVmlld15kZWNvcmF0aW9ucyksIHdpdGhcclxuICAgIHRoZSBoaWdoZXItcHJlY2VkZW5jZSBkZWNvcmF0aW9ucyBjcmVhdGluZyB0aGUgaW5uZXIgRE9NIG5vZGVzLlxyXG4gICAgU3VjaCBlbGVtZW50cyBhcmUgc3BsaXQgb24gbGluZSBib3VuZGFyaWVzIGFuZCBvbiB0aGUgYm91bmRhcmllc1xyXG4gICAgb2YgbG93ZXItcHJlY2VkZW5jZSBkZWNvcmF0aW9ucy5cclxuICAgICovXHJcbiAgICBzdGF0aWMgbWFyayhzcGVjKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBNYXJrRGVjb3JhdGlvbihzcGVjKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgQ3JlYXRlIGEgd2lkZ2V0IGRlY29yYXRpb24sIHdoaWNoIGRpc3BsYXlzIGEgRE9NIGVsZW1lbnQgYXQgdGhlXHJcbiAgICBnaXZlbiBwb3NpdGlvbi5cclxuICAgICovXHJcbiAgICBzdGF0aWMgd2lkZ2V0KHNwZWMpIHtcclxuICAgICAgICBsZXQgc2lkZSA9IHNwZWMuc2lkZSB8fCAwLCBibG9jayA9ICEhc3BlYy5ibG9jaztcclxuICAgICAgICBzaWRlICs9IGJsb2NrID8gKHNpZGUgPiAwID8gMzAwMDAwMDAwIC8qIFNpZGUuQmxvY2tBZnRlciAqLyA6IC00MDAwMDAwMDAgLyogU2lkZS5CbG9ja0JlZm9yZSAqLykgOiAoc2lkZSA+IDAgPyAxMDAwMDAwMDAgLyogU2lkZS5JbmxpbmVBZnRlciAqLyA6IC0xMDAwMDAwMDAgLyogU2lkZS5JbmxpbmVCZWZvcmUgKi8pO1xyXG4gICAgICAgIHJldHVybiBuZXcgUG9pbnREZWNvcmF0aW9uKHNwZWMsIHNpZGUsIHNpZGUsIGJsb2NrLCBzcGVjLndpZGdldCB8fCBudWxsLCBmYWxzZSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgIENyZWF0ZSBhIHJlcGxhY2UgZGVjb3JhdGlvbiB3aGljaCByZXBsYWNlcyB0aGUgZ2l2ZW4gcmFuZ2Ugd2l0aFxyXG4gICAgYSB3aWRnZXQsIG9yIHNpbXBseSBoaWRlcyBpdC5cclxuICAgICovXHJcbiAgICBzdGF0aWMgcmVwbGFjZShzcGVjKSB7XHJcbiAgICAgICAgbGV0IGJsb2NrID0gISFzcGVjLmJsb2NrLCBzdGFydFNpZGUsIGVuZFNpZGU7XHJcbiAgICAgICAgaWYgKHNwZWMuaXNCbG9ja0dhcCkge1xyXG4gICAgICAgICAgICBzdGFydFNpZGUgPSAtNTAwMDAwMDAwIC8qIFNpZGUuR2FwU3RhcnQgKi87XHJcbiAgICAgICAgICAgIGVuZFNpZGUgPSA0MDAwMDAwMDAgLyogU2lkZS5HYXBFbmQgKi87XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBsZXQgeyBzdGFydCwgZW5kIH0gPSBnZXRJbmNsdXNpdmUoc3BlYywgYmxvY2spO1xyXG4gICAgICAgICAgICBzdGFydFNpZGUgPSAoc3RhcnQgPyAoYmxvY2sgPyAtMzAwMDAwMDAwIC8qIFNpZGUuQmxvY2tJbmNTdGFydCAqLyA6IC0xIC8qIFNpZGUuSW5saW5lSW5jU3RhcnQgKi8pIDogNTAwMDAwMDAwIC8qIFNpZGUuTm9uSW5jU3RhcnQgKi8pIC0gMTtcclxuICAgICAgICAgICAgZW5kU2lkZSA9IChlbmQgPyAoYmxvY2sgPyAyMDAwMDAwMDAgLyogU2lkZS5CbG9ja0luY0VuZCAqLyA6IDEgLyogU2lkZS5JbmxpbmVJbmNFbmQgKi8pIDogLTYwMDAwMDAwMCAvKiBTaWRlLk5vbkluY0VuZCAqLykgKyAxO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbmV3IFBvaW50RGVjb3JhdGlvbihzcGVjLCBzdGFydFNpZGUsIGVuZFNpZGUsIGJsb2NrLCBzcGVjLndpZGdldCB8fCBudWxsLCB0cnVlKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgQ3JlYXRlIGEgbGluZSBkZWNvcmF0aW9uLCB3aGljaCBjYW4gYWRkIERPTSBhdHRyaWJ1dGVzIHRvIHRoZVxyXG4gICAgbGluZSBzdGFydGluZyBhdCB0aGUgZ2l2ZW4gcG9zaXRpb24uXHJcbiAgICAqL1xyXG4gICAgc3RhdGljIGxpbmUoc3BlYykge1xyXG4gICAgICAgIHJldHVybiBuZXcgTGluZURlY29yYXRpb24oc3BlYyk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgIEJ1aWxkIGEgW2BEZWNvcmF0aW9uU2V0YF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LkRlY29yYXRpb25TZXQpIGZyb20gdGhlIGdpdmVuXHJcbiAgICBkZWNvcmF0ZWQgcmFuZ2Ugb3IgcmFuZ2VzLiBJZiB0aGUgcmFuZ2VzIGFyZW4ndCBhbHJlYWR5IHNvcnRlZCxcclxuICAgIHBhc3MgYHRydWVgIGZvciBgc29ydGAgdG8gbWFrZSB0aGUgbGlicmFyeSBzb3J0IHRoZW0gZm9yIHlvdS5cclxuICAgICovXHJcbiAgICBzdGF0aWMgc2V0KG9mLCBzb3J0ID0gZmFsc2UpIHtcclxuICAgICAgICByZXR1cm4gUmFuZ2VTZXQub2Yob2YsIHNvcnQpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICBAaW50ZXJuYWxcclxuICAgICovXHJcbiAgICBoYXNIZWlnaHQoKSB7IHJldHVybiB0aGlzLndpZGdldCA/IHRoaXMud2lkZ2V0LmVzdGltYXRlZEhlaWdodCA+IC0xIDogZmFsc2U7IH1cclxufVxyXG4vKipcclxuVGhlIGVtcHR5IHNldCBvZiBkZWNvcmF0aW9ucy5cclxuKi9cclxuRGVjb3JhdGlvbi5ub25lID0gUmFuZ2VTZXQuZW1wdHk7XHJcbmNsYXNzIE1hcmtEZWNvcmF0aW9uIGV4dGVuZHMgRGVjb3JhdGlvbiB7XHJcbiAgICBjb25zdHJ1Y3RvcihzcGVjKSB7XHJcbiAgICAgICAgbGV0IHsgc3RhcnQsIGVuZCB9ID0gZ2V0SW5jbHVzaXZlKHNwZWMpO1xyXG4gICAgICAgIHN1cGVyKHN0YXJ0ID8gLTEgLyogU2lkZS5JbmxpbmVJbmNTdGFydCAqLyA6IDUwMDAwMDAwMCAvKiBTaWRlLk5vbkluY1N0YXJ0ICovLCBlbmQgPyAxIC8qIFNpZGUuSW5saW5lSW5jRW5kICovIDogLTYwMDAwMDAwMCAvKiBTaWRlLk5vbkluY0VuZCAqLywgbnVsbCwgc3BlYyk7XHJcbiAgICAgICAgdGhpcy50YWdOYW1lID0gc3BlYy50YWdOYW1lIHx8IFwic3BhblwiO1xyXG4gICAgICAgIHRoaXMuY2xhc3MgPSBzcGVjLmNsYXNzIHx8IFwiXCI7XHJcbiAgICAgICAgdGhpcy5hdHRycyA9IHNwZWMuYXR0cmlidXRlcyB8fCBudWxsO1xyXG4gICAgfVxyXG4gICAgZXEob3RoZXIpIHtcclxuICAgICAgICByZXR1cm4gdGhpcyA9PSBvdGhlciB8fFxyXG4gICAgICAgICAgICBvdGhlciBpbnN0YW5jZW9mIE1hcmtEZWNvcmF0aW9uICYmXHJcbiAgICAgICAgICAgICAgICB0aGlzLnRhZ05hbWUgPT0gb3RoZXIudGFnTmFtZSAmJlxyXG4gICAgICAgICAgICAgICAgdGhpcy5jbGFzcyA9PSBvdGhlci5jbGFzcyAmJlxyXG4gICAgICAgICAgICAgICAgYXR0cnNFcSh0aGlzLmF0dHJzLCBvdGhlci5hdHRycyk7XHJcbiAgICB9XHJcbiAgICByYW5nZShmcm9tLCB0byA9IGZyb20pIHtcclxuICAgICAgICBpZiAoZnJvbSA+PSB0bylcclxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJNYXJrIGRlY29yYXRpb25zIG1heSBub3QgYmUgZW1wdHlcIik7XHJcbiAgICAgICAgcmV0dXJuIHN1cGVyLnJhbmdlKGZyb20sIHRvKTtcclxuICAgIH1cclxufVxyXG5NYXJrRGVjb3JhdGlvbi5wcm90b3R5cGUucG9pbnQgPSBmYWxzZTtcclxuY2xhc3MgTGluZURlY29yYXRpb24gZXh0ZW5kcyBEZWNvcmF0aW9uIHtcclxuICAgIGNvbnN0cnVjdG9yKHNwZWMpIHtcclxuICAgICAgICBzdXBlcigtMjAwMDAwMDAwIC8qIFNpZGUuTGluZSAqLywgLTIwMDAwMDAwMCAvKiBTaWRlLkxpbmUgKi8sIG51bGwsIHNwZWMpO1xyXG4gICAgfVxyXG4gICAgZXEob3RoZXIpIHtcclxuICAgICAgICByZXR1cm4gb3RoZXIgaW5zdGFuY2VvZiBMaW5lRGVjb3JhdGlvbiAmJlxyXG4gICAgICAgICAgICB0aGlzLnNwZWMuY2xhc3MgPT0gb3RoZXIuc3BlYy5jbGFzcyAmJlxyXG4gICAgICAgICAgICBhdHRyc0VxKHRoaXMuc3BlYy5hdHRyaWJ1dGVzLCBvdGhlci5zcGVjLmF0dHJpYnV0ZXMpO1xyXG4gICAgfVxyXG4gICAgcmFuZ2UoZnJvbSwgdG8gPSBmcm9tKSB7XHJcbiAgICAgICAgaWYgKHRvICE9IGZyb20pXHJcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiTGluZSBkZWNvcmF0aW9uIHJhbmdlcyBtdXN0IGJlIHplcm8tbGVuZ3RoXCIpO1xyXG4gICAgICAgIHJldHVybiBzdXBlci5yYW5nZShmcm9tLCB0byk7XHJcbiAgICB9XHJcbn1cclxuTGluZURlY29yYXRpb24ucHJvdG90eXBlLm1hcE1vZGUgPSBNYXBNb2RlLlRyYWNrQmVmb3JlO1xyXG5MaW5lRGVjb3JhdGlvbi5wcm90b3R5cGUucG9pbnQgPSB0cnVlO1xyXG5jbGFzcyBQb2ludERlY29yYXRpb24gZXh0ZW5kcyBEZWNvcmF0aW9uIHtcclxuICAgIGNvbnN0cnVjdG9yKHNwZWMsIHN0YXJ0U2lkZSwgZW5kU2lkZSwgYmxvY2ssIHdpZGdldCwgaXNSZXBsYWNlKSB7XHJcbiAgICAgICAgc3VwZXIoc3RhcnRTaWRlLCBlbmRTaWRlLCB3aWRnZXQsIHNwZWMpO1xyXG4gICAgICAgIHRoaXMuYmxvY2sgPSBibG9jaztcclxuICAgICAgICB0aGlzLmlzUmVwbGFjZSA9IGlzUmVwbGFjZTtcclxuICAgICAgICB0aGlzLm1hcE1vZGUgPSAhYmxvY2sgPyBNYXBNb2RlLlRyYWNrRGVsIDogc3RhcnRTaWRlIDw9IDAgPyBNYXBNb2RlLlRyYWNrQmVmb3JlIDogTWFwTW9kZS5UcmFja0FmdGVyO1xyXG4gICAgfVxyXG4gICAgLy8gT25seSByZWxldmFudCB3aGVuIHRoaXMuYmxvY2sgPT0gdHJ1ZVxyXG4gICAgZ2V0IHR5cGUoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhcnRTaWRlIDwgdGhpcy5lbmRTaWRlID8gQmxvY2tUeXBlLldpZGdldFJhbmdlXHJcbiAgICAgICAgICAgIDogdGhpcy5zdGFydFNpZGUgPD0gMCA/IEJsb2NrVHlwZS5XaWRnZXRCZWZvcmUgOiBCbG9ja1R5cGUuV2lkZ2V0QWZ0ZXI7XHJcbiAgICB9XHJcbiAgICBnZXQgaGVpZ2h0UmVsZXZhbnQoKSB7IHJldHVybiB0aGlzLmJsb2NrIHx8ICEhdGhpcy53aWRnZXQgJiYgdGhpcy53aWRnZXQuZXN0aW1hdGVkSGVpZ2h0ID49IDU7IH1cclxuICAgIGVxKG90aGVyKSB7XHJcbiAgICAgICAgcmV0dXJuIG90aGVyIGluc3RhbmNlb2YgUG9pbnREZWNvcmF0aW9uICYmXHJcbiAgICAgICAgICAgIHdpZGdldHNFcSh0aGlzLndpZGdldCwgb3RoZXIud2lkZ2V0KSAmJlxyXG4gICAgICAgICAgICB0aGlzLmJsb2NrID09IG90aGVyLmJsb2NrICYmXHJcbiAgICAgICAgICAgIHRoaXMuc3RhcnRTaWRlID09IG90aGVyLnN0YXJ0U2lkZSAmJiB0aGlzLmVuZFNpZGUgPT0gb3RoZXIuZW5kU2lkZTtcclxuICAgIH1cclxuICAgIHJhbmdlKGZyb20sIHRvID0gZnJvbSkge1xyXG4gICAgICAgIGlmICh0aGlzLmlzUmVwbGFjZSAmJiAoZnJvbSA+IHRvIHx8IChmcm9tID09IHRvICYmIHRoaXMuc3RhcnRTaWRlID4gMCAmJiB0aGlzLmVuZFNpZGUgPD0gMCkpKVxyXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgcmFuZ2UgZm9yIHJlcGxhY2VtZW50IGRlY29yYXRpb25cIik7XHJcbiAgICAgICAgaWYgKCF0aGlzLmlzUmVwbGFjZSAmJiB0byAhPSBmcm9tKVxyXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIldpZGdldCBkZWNvcmF0aW9ucyBjYW4gb25seSBoYXZlIHplcm8tbGVuZ3RoIHJhbmdlc1wiKTtcclxuICAgICAgICByZXR1cm4gc3VwZXIucmFuZ2UoZnJvbSwgdG8pO1xyXG4gICAgfVxyXG59XHJcblBvaW50RGVjb3JhdGlvbi5wcm90b3R5cGUucG9pbnQgPSB0cnVlO1xyXG5mdW5jdGlvbiBnZXRJbmNsdXNpdmUoc3BlYywgYmxvY2sgPSBmYWxzZSkge1xyXG4gICAgbGV0IHsgaW5jbHVzaXZlU3RhcnQ6IHN0YXJ0LCBpbmNsdXNpdmVFbmQ6IGVuZCB9ID0gc3BlYztcclxuICAgIGlmIChzdGFydCA9PSBudWxsKVxyXG4gICAgICAgIHN0YXJ0ID0gc3BlYy5pbmNsdXNpdmU7XHJcbiAgICBpZiAoZW5kID09IG51bGwpXHJcbiAgICAgICAgZW5kID0gc3BlYy5pbmNsdXNpdmU7XHJcbiAgICByZXR1cm4geyBzdGFydDogc3RhcnQgIT09IG51bGwgJiYgc3RhcnQgIT09IHZvaWQgMCA/IHN0YXJ0IDogYmxvY2ssIGVuZDogZW5kICE9PSBudWxsICYmIGVuZCAhPT0gdm9pZCAwID8gZW5kIDogYmxvY2sgfTtcclxufVxyXG5mdW5jdGlvbiB3aWRnZXRzRXEoYSwgYikge1xyXG4gICAgcmV0dXJuIGEgPT0gYiB8fCAhIShhICYmIGIgJiYgYS5jb21wYXJlKGIpKTtcclxufVxyXG5mdW5jdGlvbiBhZGRSYW5nZShmcm9tLCB0bywgcmFuZ2VzLCBtYXJnaW4gPSAwKSB7XHJcbiAgICBsZXQgbGFzdCA9IHJhbmdlcy5sZW5ndGggLSAxO1xyXG4gICAgaWYgKGxhc3QgPj0gMCAmJiByYW5nZXNbbGFzdF0gKyBtYXJnaW4gPj0gZnJvbSlcclxuICAgICAgICByYW5nZXNbbGFzdF0gPSBNYXRoLm1heChyYW5nZXNbbGFzdF0sIHRvKTtcclxuICAgIGVsc2VcclxuICAgICAgICByYW5nZXMucHVzaChmcm9tLCB0byk7XHJcbn1cclxuXHJcbmNsYXNzIExpbmVWaWV3IGV4dGVuZHMgQ29udGVudFZpZXcge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcclxuICAgICAgICB0aGlzLmNoaWxkcmVuID0gW107XHJcbiAgICAgICAgdGhpcy5sZW5ndGggPSAwO1xyXG4gICAgICAgIHRoaXMucHJldkF0dHJzID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIHRoaXMuYXR0cnMgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuYnJlYWtBZnRlciA9IDA7XHJcbiAgICB9XHJcbiAgICAvLyBDb25zdW1lcyBzb3VyY2VcclxuICAgIG1lcmdlKGZyb20sIHRvLCBzb3VyY2UsIGhhc1N0YXJ0LCBvcGVuU3RhcnQsIG9wZW5FbmQpIHtcclxuICAgICAgICBpZiAoc291cmNlKSB7XHJcbiAgICAgICAgICAgIGlmICghKHNvdXJjZSBpbnN0YW5jZW9mIExpbmVWaWV3KSlcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLmRvbSlcclxuICAgICAgICAgICAgICAgIHNvdXJjZS50cmFuc2ZlckRPTSh0aGlzKTsgLy8gUmV1c2Ugc291cmNlLmRvbSB3aGVuIGFwcHJvcHJpYXRlXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChoYXNTdGFydClcclxuICAgICAgICAgICAgdGhpcy5zZXREZWNvKHNvdXJjZSA/IHNvdXJjZS5hdHRycyA6IG51bGwpO1xyXG4gICAgICAgIG1lcmdlQ2hpbGRyZW5JbnRvKHRoaXMsIGZyb20sIHRvLCBzb3VyY2UgPyBzb3VyY2UuY2hpbGRyZW4gOiBbXSwgb3BlblN0YXJ0LCBvcGVuRW5kKTtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICAgIHNwbGl0KGF0KSB7XHJcbiAgICAgICAgbGV0IGVuZCA9IG5ldyBMaW5lVmlldztcclxuICAgICAgICBlbmQuYnJlYWtBZnRlciA9IHRoaXMuYnJlYWtBZnRlcjtcclxuICAgICAgICBpZiAodGhpcy5sZW5ndGggPT0gMClcclxuICAgICAgICAgICAgcmV0dXJuIGVuZDtcclxuICAgICAgICBsZXQgeyBpLCBvZmYgfSA9IHRoaXMuY2hpbGRQb3MoYXQpO1xyXG4gICAgICAgIGlmIChvZmYpIHtcclxuICAgICAgICAgICAgZW5kLmFwcGVuZCh0aGlzLmNoaWxkcmVuW2ldLnNwbGl0KG9mZiksIDApO1xyXG4gICAgICAgICAgICB0aGlzLmNoaWxkcmVuW2ldLm1lcmdlKG9mZiwgdGhpcy5jaGlsZHJlbltpXS5sZW5ndGgsIG51bGwsIGZhbHNlLCAwLCAwKTtcclxuICAgICAgICAgICAgaSsrO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmb3IgKGxldCBqID0gaTsgaiA8IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBqKyspXHJcbiAgICAgICAgICAgIGVuZC5hcHBlbmQodGhpcy5jaGlsZHJlbltqXSwgMCk7XHJcbiAgICAgICAgd2hpbGUgKGkgPiAwICYmIHRoaXMuY2hpbGRyZW5baSAtIDFdLmxlbmd0aCA9PSAwKVxyXG4gICAgICAgICAgICB0aGlzLmNoaWxkcmVuWy0taV0uZGVzdHJveSgpO1xyXG4gICAgICAgIHRoaXMuY2hpbGRyZW4ubGVuZ3RoID0gaTtcclxuICAgICAgICB0aGlzLm1hcmtEaXJ0eSgpO1xyXG4gICAgICAgIHRoaXMubGVuZ3RoID0gYXQ7XHJcbiAgICAgICAgcmV0dXJuIGVuZDtcclxuICAgIH1cclxuICAgIHRyYW5zZmVyRE9NKG90aGVyKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLmRvbSlcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIHRoaXMubWFya0RpcnR5KCk7XHJcbiAgICAgICAgb3RoZXIuc2V0RE9NKHRoaXMuZG9tKTtcclxuICAgICAgICBvdGhlci5wcmV2QXR0cnMgPSB0aGlzLnByZXZBdHRycyA9PT0gdW5kZWZpbmVkID8gdGhpcy5hdHRycyA6IHRoaXMucHJldkF0dHJzO1xyXG4gICAgICAgIHRoaXMucHJldkF0dHJzID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIHRoaXMuZG9tID0gbnVsbDtcclxuICAgIH1cclxuICAgIHNldERlY28oYXR0cnMpIHtcclxuICAgICAgICBpZiAoIWF0dHJzRXEodGhpcy5hdHRycywgYXR0cnMpKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmRvbSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5wcmV2QXR0cnMgPSB0aGlzLmF0dHJzO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5tYXJrRGlydHkoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLmF0dHJzID0gYXR0cnM7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgYXBwZW5kKGNoaWxkLCBvcGVuU3RhcnQpIHtcclxuICAgICAgICBqb2luSW5saW5lSW50byh0aGlzLCBjaGlsZCwgb3BlblN0YXJ0KTtcclxuICAgIH1cclxuICAgIC8vIE9ubHkgY2FsbGVkIHdoZW4gYnVpbGRpbmcgYSBsaW5lIHZpZXcgaW4gQ29udGVudEJ1aWxkZXJcclxuICAgIGFkZExpbmVEZWNvKGRlY28pIHtcclxuICAgICAgICBsZXQgYXR0cnMgPSBkZWNvLnNwZWMuYXR0cmlidXRlcywgY2xzID0gZGVjby5zcGVjLmNsYXNzO1xyXG4gICAgICAgIGlmIChhdHRycylcclxuICAgICAgICAgICAgdGhpcy5hdHRycyA9IGNvbWJpbmVBdHRycyhhdHRycywgdGhpcy5hdHRycyB8fCB7fSk7XHJcbiAgICAgICAgaWYgKGNscylcclxuICAgICAgICAgICAgdGhpcy5hdHRycyA9IGNvbWJpbmVBdHRycyh7IGNsYXNzOiBjbHMgfSwgdGhpcy5hdHRycyB8fCB7fSk7XHJcbiAgICB9XHJcbiAgICBkb21BdFBvcyhwb3MpIHtcclxuICAgICAgICByZXR1cm4gaW5saW5lRE9NQXRQb3ModGhpcywgcG9zKTtcclxuICAgIH1cclxuICAgIHJldXNlRE9NKG5vZGUpIHtcclxuICAgICAgICBpZiAobm9kZS5ub2RlTmFtZSA9PSBcIkRJVlwiKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2V0RE9NKG5vZGUpO1xyXG4gICAgICAgICAgICB0aGlzLmRpcnR5IHw9IDQgLyogRGlydHkuQXR0cnMgKi8gfCAyIC8qIERpcnR5Lk5vZGUgKi87XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgc3luYyh0cmFjaykge1xyXG4gICAgICAgIHZhciBfYTtcclxuICAgICAgICBpZiAoIXRoaXMuZG9tKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2V0RE9NKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIikpO1xyXG4gICAgICAgICAgICB0aGlzLmRvbS5jbGFzc05hbWUgPSBcImNtLWxpbmVcIjtcclxuICAgICAgICAgICAgdGhpcy5wcmV2QXR0cnMgPSB0aGlzLmF0dHJzID8gbnVsbCA6IHVuZGVmaW5lZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodGhpcy5kaXJ0eSAmIDQgLyogRGlydHkuQXR0cnMgKi8pIHtcclxuICAgICAgICAgICAgY2xlYXJBdHRyaWJ1dGVzKHRoaXMuZG9tKTtcclxuICAgICAgICAgICAgdGhpcy5kb20uY2xhc3NOYW1lID0gXCJjbS1saW5lXCI7XHJcbiAgICAgICAgICAgIHRoaXMucHJldkF0dHJzID0gdGhpcy5hdHRycyA/IG51bGwgOiB1bmRlZmluZWQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLnByZXZBdHRycyAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHVwZGF0ZUF0dHJzKHRoaXMuZG9tLCB0aGlzLnByZXZBdHRycywgdGhpcy5hdHRycyk7XHJcbiAgICAgICAgICAgIHRoaXMuZG9tLmNsYXNzTGlzdC5hZGQoXCJjbS1saW5lXCIpO1xyXG4gICAgICAgICAgICB0aGlzLnByZXZBdHRycyA9IHVuZGVmaW5lZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgc3VwZXIuc3luYyh0cmFjayk7XHJcbiAgICAgICAgbGV0IGxhc3QgPSB0aGlzLmRvbS5sYXN0Q2hpbGQ7XHJcbiAgICAgICAgd2hpbGUgKGxhc3QgJiYgQ29udGVudFZpZXcuZ2V0KGxhc3QpIGluc3RhbmNlb2YgTWFya1ZpZXcpXHJcbiAgICAgICAgICAgIGxhc3QgPSBsYXN0Lmxhc3RDaGlsZDtcclxuICAgICAgICBpZiAoIWxhc3QgfHwgIXRoaXMubGVuZ3RoIHx8XHJcbiAgICAgICAgICAgIGxhc3Qubm9kZU5hbWUgIT0gXCJCUlwiICYmICgoX2EgPSBDb250ZW50Vmlldy5nZXQobGFzdCkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5pc0VkaXRhYmxlKSA9PSBmYWxzZSAmJlxyXG4gICAgICAgICAgICAgICAgKCFicm93c2VyLmlvcyB8fCAhdGhpcy5jaGlsZHJlbi5zb21lKGNoID0+IGNoIGluc3RhbmNlb2YgVGV4dFZpZXcpKSkge1xyXG4gICAgICAgICAgICBsZXQgaGFjayA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJCUlwiKTtcclxuICAgICAgICAgICAgaGFjay5jbUlnbm9yZSA9IHRydWU7XHJcbiAgICAgICAgICAgIHRoaXMuZG9tLmFwcGVuZENoaWxkKGhhY2spO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIG1lYXN1cmVUZXh0U2l6ZSgpIHtcclxuICAgICAgICBpZiAodGhpcy5jaGlsZHJlbi5sZW5ndGggPT0gMCB8fCB0aGlzLmxlbmd0aCA+IDIwKVxyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICBsZXQgdG90YWxXaWR0aCA9IDA7XHJcbiAgICAgICAgZm9yIChsZXQgY2hpbGQgb2YgdGhpcy5jaGlsZHJlbikge1xyXG4gICAgICAgICAgICBpZiAoIShjaGlsZCBpbnN0YW5jZW9mIFRleHRWaWV3KSB8fCAvW14gLX5dLy50ZXN0KGNoaWxkLnRleHQpKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgIGxldCByZWN0cyA9IGNsaWVudFJlY3RzRm9yKGNoaWxkLmRvbSk7XHJcbiAgICAgICAgICAgIGlmIChyZWN0cy5sZW5ndGggIT0gMSlcclxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICB0b3RhbFdpZHRoICs9IHJlY3RzWzBdLndpZHRoO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gIXRvdGFsV2lkdGggPyBudWxsIDoge1xyXG4gICAgICAgICAgICBsaW5lSGVpZ2h0OiB0aGlzLmRvbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5oZWlnaHQsXHJcbiAgICAgICAgICAgIGNoYXJXaWR0aDogdG90YWxXaWR0aCAvIHRoaXMubGVuZ3RoXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIGNvb3Jkc0F0KHBvcywgc2lkZSkge1xyXG4gICAgICAgIHJldHVybiBjb29yZHNJbkNoaWxkcmVuKHRoaXMsIHBvcywgc2lkZSk7XHJcbiAgICB9XHJcbiAgICBiZWNvbWUoX290aGVyKSB7IHJldHVybiBmYWxzZTsgfVxyXG4gICAgZ2V0IHR5cGUoKSB7IHJldHVybiBCbG9ja1R5cGUuVGV4dDsgfVxyXG4gICAgc3RhdGljIGZpbmQoZG9jVmlldywgcG9zKSB7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIG9mZiA9IDA7IGkgPCBkb2NWaWV3LmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGxldCBibG9jayA9IGRvY1ZpZXcuY2hpbGRyZW5baV0sIGVuZCA9IG9mZiArIGJsb2NrLmxlbmd0aDtcclxuICAgICAgICAgICAgaWYgKGVuZCA+PSBwb3MpIHtcclxuICAgICAgICAgICAgICAgIGlmIChibG9jayBpbnN0YW5jZW9mIExpbmVWaWV3KVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBibG9jaztcclxuICAgICAgICAgICAgICAgIGlmIChlbmQgPiBwb3MpXHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgb2ZmID0gZW5kICsgYmxvY2suYnJlYWtBZnRlcjtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbn1cclxuY2xhc3MgQmxvY2tXaWRnZXRWaWV3IGV4dGVuZHMgQ29udGVudFZpZXcge1xyXG4gICAgY29uc3RydWN0b3Iod2lkZ2V0LCBsZW5ndGgsIHR5cGUpIHtcclxuICAgICAgICBzdXBlcigpO1xyXG4gICAgICAgIHRoaXMud2lkZ2V0ID0gd2lkZ2V0O1xyXG4gICAgICAgIHRoaXMubGVuZ3RoID0gbGVuZ3RoO1xyXG4gICAgICAgIHRoaXMudHlwZSA9IHR5cGU7XHJcbiAgICAgICAgdGhpcy5icmVha0FmdGVyID0gMDtcclxuICAgICAgICB0aGlzLnByZXZXaWRnZXQgPSBudWxsO1xyXG4gICAgfVxyXG4gICAgbWVyZ2UoZnJvbSwgdG8sIHNvdXJjZSwgX3Rha2VEZWNvLCBvcGVuU3RhcnQsIG9wZW5FbmQpIHtcclxuICAgICAgICBpZiAoc291cmNlICYmICghKHNvdXJjZSBpbnN0YW5jZW9mIEJsb2NrV2lkZ2V0VmlldykgfHwgIXRoaXMud2lkZ2V0LmNvbXBhcmUoc291cmNlLndpZGdldCkgfHxcclxuICAgICAgICAgICAgZnJvbSA+IDAgJiYgb3BlblN0YXJ0IDw9IDAgfHwgdG8gPCB0aGlzLmxlbmd0aCAmJiBvcGVuRW5kIDw9IDApKVxyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5sZW5ndGggPSBmcm9tICsgKHNvdXJjZSA/IHNvdXJjZS5sZW5ndGggOiAwKSArICh0aGlzLmxlbmd0aCAtIHRvKTtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICAgIGRvbUF0UG9zKHBvcykge1xyXG4gICAgICAgIHJldHVybiBwb3MgPT0gMCA/IERPTVBvcy5iZWZvcmUodGhpcy5kb20pIDogRE9NUG9zLmFmdGVyKHRoaXMuZG9tLCBwb3MgPT0gdGhpcy5sZW5ndGgpO1xyXG4gICAgfVxyXG4gICAgc3BsaXQoYXQpIHtcclxuICAgICAgICBsZXQgbGVuID0gdGhpcy5sZW5ndGggLSBhdDtcclxuICAgICAgICB0aGlzLmxlbmd0aCA9IGF0O1xyXG4gICAgICAgIGxldCBlbmQgPSBuZXcgQmxvY2tXaWRnZXRWaWV3KHRoaXMud2lkZ2V0LCBsZW4sIHRoaXMudHlwZSk7XHJcbiAgICAgICAgZW5kLmJyZWFrQWZ0ZXIgPSB0aGlzLmJyZWFrQWZ0ZXI7XHJcbiAgICAgICAgcmV0dXJuIGVuZDtcclxuICAgIH1cclxuICAgIGdldCBjaGlsZHJlbigpIHsgcmV0dXJuIG5vQ2hpbGRyZW47IH1cclxuICAgIHN5bmMoKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLmRvbSB8fCAhdGhpcy53aWRnZXQudXBkYXRlRE9NKHRoaXMuZG9tKSkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5kb20gJiYgdGhpcy5wcmV2V2lkZ2V0KVxyXG4gICAgICAgICAgICAgICAgdGhpcy5wcmV2V2lkZ2V0LmRlc3Ryb3kodGhpcy5kb20pO1xyXG4gICAgICAgICAgICB0aGlzLnByZXZXaWRnZXQgPSBudWxsO1xyXG4gICAgICAgICAgICB0aGlzLnNldERPTSh0aGlzLndpZGdldC50b0RPTSh0aGlzLmVkaXRvclZpZXcpKTtcclxuICAgICAgICAgICAgdGhpcy5kb20uY29udGVudEVkaXRhYmxlID0gXCJmYWxzZVwiO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGdldCBvdmVycmlkZURPTVRleHQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyZW50ID8gdGhpcy5wYXJlbnQudmlldy5zdGF0ZS5kb2Muc2xpY2UodGhpcy5wb3NBdFN0YXJ0LCB0aGlzLnBvc0F0RW5kKSA6IFRleHQuZW1wdHk7XHJcbiAgICB9XHJcbiAgICBkb21Cb3VuZHNBcm91bmQoKSB7IHJldHVybiBudWxsOyB9XHJcbiAgICBiZWNvbWUob3RoZXIpIHtcclxuICAgICAgICBpZiAob3RoZXIgaW5zdGFuY2VvZiBCbG9ja1dpZGdldFZpZXcgJiYgb3RoZXIudHlwZSA9PSB0aGlzLnR5cGUgJiZcclxuICAgICAgICAgICAgb3RoZXIud2lkZ2V0LmNvbnN0cnVjdG9yID09IHRoaXMud2lkZ2V0LmNvbnN0cnVjdG9yKSB7XHJcbiAgICAgICAgICAgIGlmICghb3RoZXIud2lkZ2V0LmVxKHRoaXMud2lkZ2V0KSlcclxuICAgICAgICAgICAgICAgIHRoaXMubWFya0RpcnR5KHRydWUpO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5kb20gJiYgIXRoaXMucHJldldpZGdldClcclxuICAgICAgICAgICAgICAgIHRoaXMucHJldldpZGdldCA9IHRoaXMud2lkZ2V0O1xyXG4gICAgICAgICAgICB0aGlzLndpZGdldCA9IG90aGVyLndpZGdldDtcclxuICAgICAgICAgICAgdGhpcy5sZW5ndGggPSBvdGhlci5sZW5ndGg7XHJcbiAgICAgICAgICAgIHRoaXMuYnJlYWtBZnRlciA9IG90aGVyLmJyZWFrQWZ0ZXI7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBpZ25vcmVNdXRhdGlvbigpIHsgcmV0dXJuIHRydWU7IH1cclxuICAgIGlnbm9yZUV2ZW50KGV2ZW50KSB7IHJldHVybiB0aGlzLndpZGdldC5pZ25vcmVFdmVudChldmVudCk7IH1cclxuICAgIGRlc3Ryb3koKSB7XHJcbiAgICAgICAgc3VwZXIuZGVzdHJveSgpO1xyXG4gICAgICAgIGlmICh0aGlzLmRvbSlcclxuICAgICAgICAgICAgdGhpcy53aWRnZXQuZGVzdHJveSh0aGlzLmRvbSk7XHJcbiAgICB9XHJcbn1cclxuXHJcbmNsYXNzIENvbnRlbnRCdWlsZGVyIHtcclxuICAgIGNvbnN0cnVjdG9yKGRvYywgcG9zLCBlbmQsIGRpc2FsbG93QmxvY2tFZmZlY3RzRm9yKSB7XHJcbiAgICAgICAgdGhpcy5kb2MgPSBkb2M7XHJcbiAgICAgICAgdGhpcy5wb3MgPSBwb3M7XHJcbiAgICAgICAgdGhpcy5lbmQgPSBlbmQ7XHJcbiAgICAgICAgdGhpcy5kaXNhbGxvd0Jsb2NrRWZmZWN0c0ZvciA9IGRpc2FsbG93QmxvY2tFZmZlY3RzRm9yO1xyXG4gICAgICAgIHRoaXMuY29udGVudCA9IFtdO1xyXG4gICAgICAgIHRoaXMuY3VyTGluZSA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5icmVha0F0U3RhcnQgPSAwO1xyXG4gICAgICAgIHRoaXMucGVuZGluZ0J1ZmZlciA9IDAgLyogQnVmLk5vICovO1xyXG4gICAgICAgIHRoaXMuYnVmZmVyTWFya3MgPSBbXTtcclxuICAgICAgICAvLyBTZXQgdG8gZmFsc2UgZGlyZWN0bHkgYWZ0ZXIgYSB3aWRnZXQgdGhhdCBjb3ZlcnMgdGhlIHBvc2l0aW9uIGFmdGVyIGl0XHJcbiAgICAgICAgdGhpcy5hdEN1cnNvclBvcyA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5vcGVuU3RhcnQgPSAtMTtcclxuICAgICAgICB0aGlzLm9wZW5FbmQgPSAtMTtcclxuICAgICAgICB0aGlzLnRleHQgPSBcIlwiO1xyXG4gICAgICAgIHRoaXMudGV4dE9mZiA9IDA7XHJcbiAgICAgICAgdGhpcy5jdXJzb3IgPSBkb2MuaXRlcigpO1xyXG4gICAgICAgIHRoaXMuc2tpcCA9IHBvcztcclxuICAgIH1cclxuICAgIHBvc0NvdmVyZWQoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuY29udGVudC5sZW5ndGggPT0gMClcclxuICAgICAgICAgICAgcmV0dXJuICF0aGlzLmJyZWFrQXRTdGFydCAmJiB0aGlzLmRvYy5saW5lQXQodGhpcy5wb3MpLmZyb20gIT0gdGhpcy5wb3M7XHJcbiAgICAgICAgbGV0IGxhc3QgPSB0aGlzLmNvbnRlbnRbdGhpcy5jb250ZW50Lmxlbmd0aCAtIDFdO1xyXG4gICAgICAgIHJldHVybiAhbGFzdC5icmVha0FmdGVyICYmICEobGFzdCBpbnN0YW5jZW9mIEJsb2NrV2lkZ2V0VmlldyAmJiBsYXN0LnR5cGUgPT0gQmxvY2tUeXBlLldpZGdldEJlZm9yZSk7XHJcbiAgICB9XHJcbiAgICBnZXRMaW5lKCkge1xyXG4gICAgICAgIGlmICghdGhpcy5jdXJMaW5lKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY29udGVudC5wdXNoKHRoaXMuY3VyTGluZSA9IG5ldyBMaW5lVmlldyk7XHJcbiAgICAgICAgICAgIHRoaXMuYXRDdXJzb3JQb3MgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5jdXJMaW5lO1xyXG4gICAgfVxyXG4gICAgZmx1c2hCdWZmZXIoYWN0aXZlID0gdGhpcy5idWZmZXJNYXJrcykge1xyXG4gICAgICAgIGlmICh0aGlzLnBlbmRpbmdCdWZmZXIpIHtcclxuICAgICAgICAgICAgdGhpcy5jdXJMaW5lLmFwcGVuZCh3cmFwTWFya3MobmV3IFdpZGdldEJ1ZmZlclZpZXcoLTEpLCBhY3RpdmUpLCBhY3RpdmUubGVuZ3RoKTtcclxuICAgICAgICAgICAgdGhpcy5wZW5kaW5nQnVmZmVyID0gMCAvKiBCdWYuTm8gKi87XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgYWRkQmxvY2tXaWRnZXQodmlldykge1xyXG4gICAgICAgIHRoaXMuZmx1c2hCdWZmZXIoKTtcclxuICAgICAgICB0aGlzLmN1ckxpbmUgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuY29udGVudC5wdXNoKHZpZXcpO1xyXG4gICAgfVxyXG4gICAgZmluaXNoKG9wZW5FbmQpIHtcclxuICAgICAgICBpZiAodGhpcy5wZW5kaW5nQnVmZmVyICYmIG9wZW5FbmQgPD0gdGhpcy5idWZmZXJNYXJrcy5sZW5ndGgpXHJcbiAgICAgICAgICAgIHRoaXMuZmx1c2hCdWZmZXIoKTtcclxuICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHRoaXMucGVuZGluZ0J1ZmZlciA9IDAgLyogQnVmLk5vICovO1xyXG4gICAgICAgIGlmICghdGhpcy5wb3NDb3ZlcmVkKCkpXHJcbiAgICAgICAgICAgIHRoaXMuZ2V0TGluZSgpO1xyXG4gICAgfVxyXG4gICAgYnVpbGRUZXh0KGxlbmd0aCwgYWN0aXZlLCBvcGVuU3RhcnQpIHtcclxuICAgICAgICB3aGlsZSAobGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy50ZXh0T2ZmID09IHRoaXMudGV4dC5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIGxldCB7IHZhbHVlLCBsaW5lQnJlYWssIGRvbmUgfSA9IHRoaXMuY3Vyc29yLm5leHQodGhpcy5za2lwKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2tpcCA9IDA7XHJcbiAgICAgICAgICAgICAgICBpZiAoZG9uZSlcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJSYW4gb3V0IG9mIHRleHQgY29udGVudCB3aGVuIGRyYXdpbmcgaW5saW5lIHZpZXdzXCIpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGxpbmVCcmVhaykge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5wb3NDb3ZlcmVkKCkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZ2V0TGluZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmNvbnRlbnQubGVuZ3RoKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbnRlbnRbdGhpcy5jb250ZW50Lmxlbmd0aCAtIDFdLmJyZWFrQWZ0ZXIgPSAxO1xyXG4gICAgICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5icmVha0F0U3RhcnQgPSAxO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZmx1c2hCdWZmZXIoKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmN1ckxpbmUgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYXRDdXJzb3JQb3MgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIGxlbmd0aC0tO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50ZXh0ID0gdmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50ZXh0T2ZmID0gMDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBsZXQgdGFrZSA9IE1hdGgubWluKHRoaXMudGV4dC5sZW5ndGggLSB0aGlzLnRleHRPZmYsIGxlbmd0aCwgNTEyIC8qIFQuQ2h1bmsgKi8pO1xyXG4gICAgICAgICAgICB0aGlzLmZsdXNoQnVmZmVyKGFjdGl2ZS5zbGljZShhY3RpdmUubGVuZ3RoIC0gb3BlblN0YXJ0KSk7XHJcbiAgICAgICAgICAgIHRoaXMuZ2V0TGluZSgpLmFwcGVuZCh3cmFwTWFya3MobmV3IFRleHRWaWV3KHRoaXMudGV4dC5zbGljZSh0aGlzLnRleHRPZmYsIHRoaXMudGV4dE9mZiArIHRha2UpKSwgYWN0aXZlKSwgb3BlblN0YXJ0KTtcclxuICAgICAgICAgICAgdGhpcy5hdEN1cnNvclBvcyA9IHRydWU7XHJcbiAgICAgICAgICAgIHRoaXMudGV4dE9mZiArPSB0YWtlO1xyXG4gICAgICAgICAgICBsZW5ndGggLT0gdGFrZTtcclxuICAgICAgICAgICAgb3BlblN0YXJ0ID0gMDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBzcGFuKGZyb20sIHRvLCBhY3RpdmUsIG9wZW5TdGFydCkge1xyXG4gICAgICAgIHRoaXMuYnVpbGRUZXh0KHRvIC0gZnJvbSwgYWN0aXZlLCBvcGVuU3RhcnQpO1xyXG4gICAgICAgIHRoaXMucG9zID0gdG87XHJcbiAgICAgICAgaWYgKHRoaXMub3BlblN0YXJ0IDwgMClcclxuICAgICAgICAgICAgdGhpcy5vcGVuU3RhcnQgPSBvcGVuU3RhcnQ7XHJcbiAgICB9XHJcbiAgICBwb2ludChmcm9tLCB0bywgZGVjbywgYWN0aXZlLCBvcGVuU3RhcnQsIGluZGV4KSB7XHJcbiAgICAgICAgaWYgKHRoaXMuZGlzYWxsb3dCbG9ja0VmZmVjdHNGb3JbaW5kZXhdICYmIGRlY28gaW5zdGFuY2VvZiBQb2ludERlY29yYXRpb24pIHtcclxuICAgICAgICAgICAgaWYgKGRlY28uYmxvY2spXHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkJsb2NrIGRlY29yYXRpb25zIG1heSBub3QgYmUgc3BlY2lmaWVkIHZpYSBwbHVnaW5zXCIpO1xyXG4gICAgICAgICAgICBpZiAodG8gPiB0aGlzLmRvYy5saW5lQXQodGhpcy5wb3MpLnRvKVxyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJEZWNvcmF0aW9ucyB0aGF0IHJlcGxhY2UgbGluZSBicmVha3MgbWF5IG5vdCBiZSBzcGVjaWZpZWQgdmlhIHBsdWdpbnNcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCBsZW4gPSB0byAtIGZyb207XHJcbiAgICAgICAgaWYgKGRlY28gaW5zdGFuY2VvZiBQb2ludERlY29yYXRpb24pIHtcclxuICAgICAgICAgICAgaWYgKGRlY28uYmxvY2spIHtcclxuICAgICAgICAgICAgICAgIGxldCB7IHR5cGUgfSA9IGRlY287XHJcbiAgICAgICAgICAgICAgICBpZiAodHlwZSA9PSBCbG9ja1R5cGUuV2lkZ2V0QWZ0ZXIgJiYgIXRoaXMucG9zQ292ZXJlZCgpKVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZ2V0TGluZSgpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5hZGRCbG9ja1dpZGdldChuZXcgQmxvY2tXaWRnZXRWaWV3KGRlY28ud2lkZ2V0IHx8IG5ldyBOdWxsV2lkZ2V0KFwiZGl2XCIpLCBsZW4sIHR5cGUpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGxldCB2aWV3ID0gV2lkZ2V0Vmlldy5jcmVhdGUoZGVjby53aWRnZXQgfHwgbmV3IE51bGxXaWRnZXQoXCJzcGFuXCIpLCBsZW4sIGxlbiA/IDAgOiBkZWNvLnN0YXJ0U2lkZSk7XHJcbiAgICAgICAgICAgICAgICBsZXQgY3Vyc29yQmVmb3JlID0gdGhpcy5hdEN1cnNvclBvcyAmJiAhdmlldy5pc0VkaXRhYmxlICYmIG9wZW5TdGFydCA8PSBhY3RpdmUubGVuZ3RoICYmIChmcm9tIDwgdG8gfHwgZGVjby5zdGFydFNpZGUgPiAwKTtcclxuICAgICAgICAgICAgICAgIGxldCBjdXJzb3JBZnRlciA9ICF2aWV3LmlzRWRpdGFibGUgJiYgKGZyb20gPCB0byB8fCBvcGVuU3RhcnQgPiBhY3RpdmUubGVuZ3RoIHx8IGRlY28uc3RhcnRTaWRlIDw9IDApO1xyXG4gICAgICAgICAgICAgICAgbGV0IGxpbmUgPSB0aGlzLmdldExpbmUoKTtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnBlbmRpbmdCdWZmZXIgPT0gMiAvKiBCdWYuSWZDdXJzb3IgKi8gJiYgIWN1cnNvckJlZm9yZSlcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnBlbmRpbmdCdWZmZXIgPSAwIC8qIEJ1Zi5ObyAqLztcclxuICAgICAgICAgICAgICAgIHRoaXMuZmx1c2hCdWZmZXIoYWN0aXZlKTtcclxuICAgICAgICAgICAgICAgIGlmIChjdXJzb3JCZWZvcmUpIHtcclxuICAgICAgICAgICAgICAgICAgICBsaW5lLmFwcGVuZCh3cmFwTWFya3MobmV3IFdpZGdldEJ1ZmZlclZpZXcoMSksIGFjdGl2ZSksIG9wZW5TdGFydCk7XHJcbiAgICAgICAgICAgICAgICAgICAgb3BlblN0YXJ0ID0gYWN0aXZlLmxlbmd0aCArIE1hdGgubWF4KDAsIG9wZW5TdGFydCAtIGFjdGl2ZS5sZW5ndGgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgbGluZS5hcHBlbmQod3JhcE1hcmtzKHZpZXcsIGFjdGl2ZSksIG9wZW5TdGFydCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmF0Q3Vyc29yUG9zID0gY3Vyc29yQWZ0ZXI7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnBlbmRpbmdCdWZmZXIgPSAhY3Vyc29yQWZ0ZXIgPyAwIC8qIEJ1Zi5ObyAqLyA6IGZyb20gPCB0byB8fCBvcGVuU3RhcnQgPiBhY3RpdmUubGVuZ3RoID8gMSAvKiBCdWYuWWVzICovIDogMiAvKiBCdWYuSWZDdXJzb3IgKi87XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5wZW5kaW5nQnVmZmVyKVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYnVmZmVyTWFya3MgPSBhY3RpdmUuc2xpY2UoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0aGlzLmRvYy5saW5lQXQodGhpcy5wb3MpLmZyb20gPT0gdGhpcy5wb3MpIHsgLy8gTGluZSBkZWNvcmF0aW9uXHJcbiAgICAgICAgICAgIHRoaXMuZ2V0TGluZSgpLmFkZExpbmVEZWNvKGRlY28pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobGVuKSB7XHJcbiAgICAgICAgICAgIC8vIEFkdmFuY2UgdGhlIGl0ZXJhdG9yIHBhc3QgdGhlIHJlcGxhY2VkIGNvbnRlbnRcclxuICAgICAgICAgICAgaWYgKHRoaXMudGV4dE9mZiArIGxlbiA8PSB0aGlzLnRleHQubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnRleHRPZmYgKz0gbGVuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5za2lwICs9IGxlbiAtICh0aGlzLnRleHQubGVuZ3RoIC0gdGhpcy50ZXh0T2ZmKTtcclxuICAgICAgICAgICAgICAgIHRoaXMudGV4dCA9IFwiXCI7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnRleHRPZmYgPSAwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMucG9zID0gdG87XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLm9wZW5TdGFydCA8IDApXHJcbiAgICAgICAgICAgIHRoaXMub3BlblN0YXJ0ID0gb3BlblN0YXJ0O1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGJ1aWxkKHRleHQsIGZyb20sIHRvLCBkZWNvcmF0aW9ucywgZHluYW1pY0RlY29yYXRpb25NYXApIHtcclxuICAgICAgICBsZXQgYnVpbGRlciA9IG5ldyBDb250ZW50QnVpbGRlcih0ZXh0LCBmcm9tLCB0bywgZHluYW1pY0RlY29yYXRpb25NYXApO1xyXG4gICAgICAgIGJ1aWxkZXIub3BlbkVuZCA9IFJhbmdlU2V0LnNwYW5zKGRlY29yYXRpb25zLCBmcm9tLCB0bywgYnVpbGRlcik7XHJcbiAgICAgICAgaWYgKGJ1aWxkZXIub3BlblN0YXJ0IDwgMClcclxuICAgICAgICAgICAgYnVpbGRlci5vcGVuU3RhcnQgPSBidWlsZGVyLm9wZW5FbmQ7XHJcbiAgICAgICAgYnVpbGRlci5maW5pc2goYnVpbGRlci5vcGVuRW5kKTtcclxuICAgICAgICByZXR1cm4gYnVpbGRlcjtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiB3cmFwTWFya3ModmlldywgYWN0aXZlKSB7XHJcbiAgICBmb3IgKGxldCBtYXJrIG9mIGFjdGl2ZSlcclxuICAgICAgICB2aWV3ID0gbmV3IE1hcmtWaWV3KG1hcmssIFt2aWV3XSwgdmlldy5sZW5ndGgpO1xyXG4gICAgcmV0dXJuIHZpZXc7XHJcbn1cclxuY2xhc3MgTnVsbFdpZGdldCBleHRlbmRzIFdpZGdldFR5cGUge1xyXG4gICAgY29uc3RydWN0b3IodGFnKSB7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuICAgICAgICB0aGlzLnRhZyA9IHRhZztcclxuICAgIH1cclxuICAgIGVxKG90aGVyKSB7IHJldHVybiBvdGhlci50YWcgPT0gdGhpcy50YWc7IH1cclxuICAgIHRvRE9NKCkgeyByZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0aGlzLnRhZyk7IH1cclxuICAgIHVwZGF0ZURPTShlbHQpIHsgcmV0dXJuIGVsdC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09IHRoaXMudGFnOyB9XHJcbn1cclxuXHJcbmNvbnN0IGNsaWNrQWRkc1NlbGVjdGlvblJhbmdlID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSgpO1xyXG5jb25zdCBkcmFnTW92ZXNTZWxlY3Rpb24kMSA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoKTtcclxuY29uc3QgbW91c2VTZWxlY3Rpb25TdHlsZSA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoKTtcclxuY29uc3QgZXhjZXB0aW9uU2luayA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoKTtcclxuY29uc3QgdXBkYXRlTGlzdGVuZXIgPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKCk7XHJcbmNvbnN0IGlucHV0SGFuZGxlciA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoKTtcclxuY29uc3QgcGVyTGluZVRleHREaXJlY3Rpb24gPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKHtcclxuICAgIGNvbWJpbmU6IHZhbHVlcyA9PiB2YWx1ZXMuc29tZSh4ID0+IHgpXHJcbn0pO1xyXG5jb25zdCBuYXRpdmVTZWxlY3Rpb25IaWRkZW4gPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKHtcclxuICAgIGNvbWJpbmU6IHZhbHVlcyA9PiB2YWx1ZXMuc29tZSh4ID0+IHgpXHJcbn0pO1xyXG5jbGFzcyBTY3JvbGxUYXJnZXQge1xyXG4gICAgY29uc3RydWN0b3IocmFuZ2UsIHkgPSBcIm5lYXJlc3RcIiwgeCA9IFwibmVhcmVzdFwiLCB5TWFyZ2luID0gNSwgeE1hcmdpbiA9IDUpIHtcclxuICAgICAgICB0aGlzLnJhbmdlID0gcmFuZ2U7XHJcbiAgICAgICAgdGhpcy55ID0geTtcclxuICAgICAgICB0aGlzLnggPSB4O1xyXG4gICAgICAgIHRoaXMueU1hcmdpbiA9IHlNYXJnaW47XHJcbiAgICAgICAgdGhpcy54TWFyZ2luID0geE1hcmdpbjtcclxuICAgIH1cclxuICAgIG1hcChjaGFuZ2VzKSB7XHJcbiAgICAgICAgcmV0dXJuIGNoYW5nZXMuZW1wdHkgPyB0aGlzIDogbmV3IFNjcm9sbFRhcmdldCh0aGlzLnJhbmdlLm1hcChjaGFuZ2VzKSwgdGhpcy55LCB0aGlzLngsIHRoaXMueU1hcmdpbiwgdGhpcy54TWFyZ2luKTtcclxuICAgIH1cclxufVxyXG5jb25zdCBzY3JvbGxJbnRvVmlldyA9IC8qQF9fUFVSRV9fKi9TdGF0ZUVmZmVjdC5kZWZpbmUoeyBtYXA6ICh0LCBjaCkgPT4gdC5tYXAoY2gpIH0pO1xyXG4vKipcclxuTG9nIG9yIHJlcG9ydCBhbiB1bmhhbmRsZWQgZXhjZXB0aW9uIGluIGNsaWVudCBjb2RlLiBTaG91bGRcclxucHJvYmFibHkgb25seSBiZSB1c2VkIGJ5IGV4dGVuc2lvbiBjb2RlIHRoYXQgYWxsb3dzIGNsaWVudCBjb2RlIHRvXHJcbnByb3ZpZGUgZnVuY3Rpb25zLCBhbmQgY2FsbHMgdGhvc2UgZnVuY3Rpb25zIGluIGEgY29udGV4dCB3aGVyZSBhblxyXG5leGNlcHRpb24gY2FuJ3QgYmUgcHJvcGFnYXRlZCB0byBjYWxsaW5nIGNvZGUgaW4gYSByZWFzb25hYmxlIHdheVxyXG4oZm9yIGV4YW1wbGUgd2hlbiBpbiBhbiBldmVudCBoYW5kbGVyKS5cclxuXHJcbkVpdGhlciBjYWxscyBhIGhhbmRsZXIgcmVnaXN0ZXJlZCB3aXRoXHJcbltgRWRpdG9yVmlldy5leGNlcHRpb25TaW5rYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LkVkaXRvclZpZXdeZXhjZXB0aW9uU2luayksXHJcbmB3aW5kb3cub25lcnJvcmAsIGlmIGRlZmluZWQsIG9yIGBjb25zb2xlLmVycm9yYCAoaW4gd2hpY2ggY2FzZVxyXG5pdCdsbCBwYXNzIGBjb250ZXh0YCwgd2hlbiBnaXZlbiwgYXMgZmlyc3QgYXJndW1lbnQpLlxyXG4qL1xyXG5mdW5jdGlvbiBsb2dFeGNlcHRpb24oc3RhdGUsIGV4Y2VwdGlvbiwgY29udGV4dCkge1xyXG4gICAgbGV0IGhhbmRsZXIgPSBzdGF0ZS5mYWNldChleGNlcHRpb25TaW5rKTtcclxuICAgIGlmIChoYW5kbGVyLmxlbmd0aClcclxuICAgICAgICBoYW5kbGVyWzBdKGV4Y2VwdGlvbik7XHJcbiAgICBlbHNlIGlmICh3aW5kb3cub25lcnJvcilcclxuICAgICAgICB3aW5kb3cub25lcnJvcihTdHJpbmcoZXhjZXB0aW9uKSwgY29udGV4dCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGV4Y2VwdGlvbik7XHJcbiAgICBlbHNlIGlmIChjb250ZXh0KVxyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoY29udGV4dCArIFwiOlwiLCBleGNlcHRpb24pO1xyXG4gICAgZWxzZVxyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoZXhjZXB0aW9uKTtcclxufVxyXG5jb25zdCBlZGl0YWJsZSA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoeyBjb21iaW5lOiB2YWx1ZXMgPT4gdmFsdWVzLmxlbmd0aCA/IHZhbHVlc1swXSA6IHRydWUgfSk7XHJcbmxldCBuZXh0UGx1Z2luSUQgPSAwO1xyXG5jb25zdCB2aWV3UGx1Z2luID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSgpO1xyXG4vKipcclxuVmlldyBwbHVnaW5zIGFzc29jaWF0ZSBzdGF0ZWZ1bCB2YWx1ZXMgd2l0aCBhIHZpZXcuIFRoZXkgY2FuXHJcbmluZmx1ZW5jZSB0aGUgd2F5IHRoZSBjb250ZW50IGlzIGRyYXduLCBhbmQgYXJlIG5vdGlmaWVkIG9mIHRoaW5nc1xyXG50aGF0IGhhcHBlbiBpbiB0aGUgdmlldy5cclxuKi9cclxuY2xhc3MgVmlld1BsdWdpbiB7XHJcbiAgICBjb25zdHJ1Y3RvcihcclxuICAgIC8qKlxyXG4gICAgQGludGVybmFsXHJcbiAgICAqL1xyXG4gICAgaWQsIFxyXG4gICAgLyoqXHJcbiAgICBAaW50ZXJuYWxcclxuICAgICovXHJcbiAgICBjcmVhdGUsIFxyXG4gICAgLyoqXHJcbiAgICBAaW50ZXJuYWxcclxuICAgICovXHJcbiAgICBkb21FdmVudEhhbmRsZXJzLCBidWlsZEV4dGVuc2lvbnMpIHtcclxuICAgICAgICB0aGlzLmlkID0gaWQ7XHJcbiAgICAgICAgdGhpcy5jcmVhdGUgPSBjcmVhdGU7XHJcbiAgICAgICAgdGhpcy5kb21FdmVudEhhbmRsZXJzID0gZG9tRXZlbnRIYW5kbGVycztcclxuICAgICAgICB0aGlzLmV4dGVuc2lvbiA9IGJ1aWxkRXh0ZW5zaW9ucyh0aGlzKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgRGVmaW5lIGEgcGx1Z2luIGZyb20gYSBjb25zdHJ1Y3RvciBmdW5jdGlvbiB0aGF0IGNyZWF0ZXMgdGhlXHJcbiAgICBwbHVnaW4ncyB2YWx1ZSwgZ2l2ZW4gYW4gZWRpdG9yIHZpZXcuXHJcbiAgICAqL1xyXG4gICAgc3RhdGljIGRlZmluZShjcmVhdGUsIHNwZWMpIHtcclxuICAgICAgICBjb25zdCB7IGV2ZW50SGFuZGxlcnMsIHByb3ZpZGUsIGRlY29yYXRpb25zOiBkZWNvIH0gPSBzcGVjIHx8IHt9O1xyXG4gICAgICAgIHJldHVybiBuZXcgVmlld1BsdWdpbihuZXh0UGx1Z2luSUQrKywgY3JlYXRlLCBldmVudEhhbmRsZXJzLCBwbHVnaW4gPT4ge1xyXG4gICAgICAgICAgICBsZXQgZXh0ID0gW3ZpZXdQbHVnaW4ub2YocGx1Z2luKV07XHJcbiAgICAgICAgICAgIGlmIChkZWNvKVxyXG4gICAgICAgICAgICAgICAgZXh0LnB1c2goZGVjb3JhdGlvbnMub2YodmlldyA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IHBsdWdpbkluc3QgPSB2aWV3LnBsdWdpbihwbHVnaW4pO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwbHVnaW5JbnN0ID8gZGVjbyhwbHVnaW5JbnN0KSA6IERlY29yYXRpb24ubm9uZTtcclxuICAgICAgICAgICAgICAgIH0pKTtcclxuICAgICAgICAgICAgaWYgKHByb3ZpZGUpXHJcbiAgICAgICAgICAgICAgICBleHQucHVzaChwcm92aWRlKHBsdWdpbikpO1xyXG4gICAgICAgICAgICByZXR1cm4gZXh0O1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICBDcmVhdGUgYSBwbHVnaW4gZm9yIGEgY2xhc3Mgd2hvc2UgY29uc3RydWN0b3IgdGFrZXMgYSBzaW5nbGVcclxuICAgIGVkaXRvciB2aWV3IGFzIGFyZ3VtZW50LlxyXG4gICAgKi9cclxuICAgIHN0YXRpYyBmcm9tQ2xhc3MoY2xzLCBzcGVjKSB7XHJcbiAgICAgICAgcmV0dXJuIFZpZXdQbHVnaW4uZGVmaW5lKHZpZXcgPT4gbmV3IGNscyh2aWV3KSwgc3BlYyk7XHJcbiAgICB9XHJcbn1cclxuY2xhc3MgUGx1Z2luSW5zdGFuY2Uge1xyXG4gICAgY29uc3RydWN0b3Ioc3BlYykge1xyXG4gICAgICAgIHRoaXMuc3BlYyA9IHNwZWM7XHJcbiAgICAgICAgLy8gV2hlbiBzdGFydGluZyBhbiB1cGRhdGUsIGFsbCBwbHVnaW5zIGhhdmUgdGhpcyBmaWVsZCBzZXQgdG8gdGhlXHJcbiAgICAgICAgLy8gdXBkYXRlIG9iamVjdCwgaW5kaWNhdGluZyB0aGV5IG5lZWQgdG8gYmUgdXBkYXRlZC4gV2hlbiBmaW5pc2hlZFxyXG4gICAgICAgIC8vIHVwZGF0aW5nLCBpdCBpcyBzZXQgdG8gYGZhbHNlYC4gUmV0cmlldmluZyBhIHBsdWdpbiB0aGF0IG5lZWRzIHRvXHJcbiAgICAgICAgLy8gYmUgdXBkYXRlZCB3aXRoIGB2aWV3LnBsdWdpbmAgZm9yY2VzIGFuIGVhZ2VyIHVwZGF0ZS5cclxuICAgICAgICB0aGlzLm11c3RVcGRhdGUgPSBudWxsO1xyXG4gICAgICAgIC8vIFRoaXMgaXMgbnVsbCB3aGVuIHRoZSBwbHVnaW4gaXMgaW5pdGlhbGx5IGNyZWF0ZWQsIGJ1dFxyXG4gICAgICAgIC8vIGluaXRpYWxpemVkIG9uIHRoZSBmaXJzdCB1cGRhdGUuXHJcbiAgICAgICAgdGhpcy52YWx1ZSA9IG51bGw7XHJcbiAgICB9XHJcbiAgICB1cGRhdGUodmlldykge1xyXG4gICAgICAgIGlmICghdGhpcy52YWx1ZSkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5zcGVjKSB7XHJcbiAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudmFsdWUgPSB0aGlzLnNwZWMuY3JlYXRlKHZpZXcpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgICAgICBsb2dFeGNlcHRpb24odmlldy5zdGF0ZSwgZSwgXCJDb2RlTWlycm9yIHBsdWdpbiBjcmFzaGVkXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGVhY3RpdmF0ZSgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHRoaXMubXVzdFVwZGF0ZSkge1xyXG4gICAgICAgICAgICBsZXQgdXBkYXRlID0gdGhpcy5tdXN0VXBkYXRlO1xyXG4gICAgICAgICAgICB0aGlzLm11c3RVcGRhdGUgPSBudWxsO1xyXG4gICAgICAgICAgICBpZiAodGhpcy52YWx1ZS51cGRhdGUpIHtcclxuICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy52YWx1ZS51cGRhdGUodXBkYXRlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbG9nRXhjZXB0aW9uKHVwZGF0ZS5zdGF0ZSwgZSwgXCJDb2RlTWlycm9yIHBsdWdpbiBjcmFzaGVkXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnZhbHVlLmRlc3Ryb3kpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnZhbHVlLmRlc3Ryb3koKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXRjaCAoXykgeyB9XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kZWFjdGl2YXRlKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbiAgICBkZXN0cm95KHZpZXcpIHtcclxuICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgaWYgKChfYSA9IHRoaXMudmFsdWUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5kZXN0cm95KSB7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnZhbHVlLmRlc3Ryb3koKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAgICAgbG9nRXhjZXB0aW9uKHZpZXcuc3RhdGUsIGUsIFwiQ29kZU1pcnJvciBwbHVnaW4gY3Jhc2hlZFwiKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGRlYWN0aXZhdGUoKSB7XHJcbiAgICAgICAgdGhpcy5zcGVjID0gdGhpcy52YWx1ZSA9IG51bGw7XHJcbiAgICB9XHJcbn1cclxuY29uc3QgZWRpdG9yQXR0cmlidXRlcyA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoKTtcclxuY29uc3QgY29udGVudEF0dHJpYnV0ZXMgPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKCk7XHJcbi8vIFByb3ZpZGUgZGVjb3JhdGlvbnNcclxuY29uc3QgZGVjb3JhdGlvbnMgPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKCk7XHJcbmNvbnN0IGF0b21pY1JhbmdlcyA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoKTtcclxuY29uc3Qgc2Nyb2xsTWFyZ2lucyA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoKTtcclxuY29uc3Qgc3R5bGVNb2R1bGUgPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKCk7XHJcbmNsYXNzIENoYW5nZWRSYW5nZSB7XHJcbiAgICBjb25zdHJ1Y3Rvcihmcm9tQSwgdG9BLCBmcm9tQiwgdG9CKSB7XHJcbiAgICAgICAgdGhpcy5mcm9tQSA9IGZyb21BO1xyXG4gICAgICAgIHRoaXMudG9BID0gdG9BO1xyXG4gICAgICAgIHRoaXMuZnJvbUIgPSBmcm9tQjtcclxuICAgICAgICB0aGlzLnRvQiA9IHRvQjtcclxuICAgIH1cclxuICAgIGpvaW4ob3RoZXIpIHtcclxuICAgICAgICByZXR1cm4gbmV3IENoYW5nZWRSYW5nZShNYXRoLm1pbih0aGlzLmZyb21BLCBvdGhlci5mcm9tQSksIE1hdGgubWF4KHRoaXMudG9BLCBvdGhlci50b0EpLCBNYXRoLm1pbih0aGlzLmZyb21CLCBvdGhlci5mcm9tQiksIE1hdGgubWF4KHRoaXMudG9CLCBvdGhlci50b0IpKTtcclxuICAgIH1cclxuICAgIGFkZFRvU2V0KHNldCkge1xyXG4gICAgICAgIGxldCBpID0gc2V0Lmxlbmd0aCwgbWUgPSB0aGlzO1xyXG4gICAgICAgIGZvciAoOyBpID4gMDsgaS0tKSB7XHJcbiAgICAgICAgICAgIGxldCByYW5nZSA9IHNldFtpIC0gMV07XHJcbiAgICAgICAgICAgIGlmIChyYW5nZS5mcm9tQSA+IG1lLnRvQSlcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICBpZiAocmFuZ2UudG9BIDwgbWUuZnJvbUEpXHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgbWUgPSBtZS5qb2luKHJhbmdlKTtcclxuICAgICAgICAgICAgc2V0LnNwbGljZShpIC0gMSwgMSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHNldC5zcGxpY2UoaSwgMCwgbWUpO1xyXG4gICAgICAgIHJldHVybiBzZXQ7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgZXh0ZW5kV2l0aFJhbmdlcyhkaWZmLCByYW5nZXMpIHtcclxuICAgICAgICBpZiAocmFuZ2VzLmxlbmd0aCA9PSAwKVxyXG4gICAgICAgICAgICByZXR1cm4gZGlmZjtcclxuICAgICAgICBsZXQgcmVzdWx0ID0gW107XHJcbiAgICAgICAgZm9yIChsZXQgZEkgPSAwLCBySSA9IDAsIHBvc0EgPSAwLCBwb3NCID0gMDs7IGRJKyspIHtcclxuICAgICAgICAgICAgbGV0IG5leHQgPSBkSSA9PSBkaWZmLmxlbmd0aCA/IG51bGwgOiBkaWZmW2RJXSwgb2ZmID0gcG9zQSAtIHBvc0I7XHJcbiAgICAgICAgICAgIGxldCBlbmQgPSBuZXh0ID8gbmV4dC5mcm9tQiA6IDFlOTtcclxuICAgICAgICAgICAgd2hpbGUgKHJJIDwgcmFuZ2VzLmxlbmd0aCAmJiByYW5nZXNbckldIDwgZW5kKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgZnJvbSA9IHJhbmdlc1tySV0sIHRvID0gcmFuZ2VzW3JJICsgMV07XHJcbiAgICAgICAgICAgICAgICBsZXQgZnJvbUIgPSBNYXRoLm1heChwb3NCLCBmcm9tKSwgdG9CID0gTWF0aC5taW4oZW5kLCB0byk7XHJcbiAgICAgICAgICAgICAgICBpZiAoZnJvbUIgPD0gdG9CKVxyXG4gICAgICAgICAgICAgICAgICAgIG5ldyBDaGFuZ2VkUmFuZ2UoZnJvbUIgKyBvZmYsIHRvQiArIG9mZiwgZnJvbUIsIHRvQikuYWRkVG9TZXQocmVzdWx0KTtcclxuICAgICAgICAgICAgICAgIGlmICh0byA+IGVuZClcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICBySSArPSAyO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICghbmV4dClcclxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgICAgIG5ldyBDaGFuZ2VkUmFuZ2UobmV4dC5mcm9tQSwgbmV4dC50b0EsIG5leHQuZnJvbUIsIG5leHQudG9CKS5hZGRUb1NldChyZXN1bHQpO1xyXG4gICAgICAgICAgICBwb3NBID0gbmV4dC50b0E7XHJcbiAgICAgICAgICAgIHBvc0IgPSBuZXh0LnRvQjtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcblZpZXcgW3BsdWdpbnNdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5WaWV3UGx1Z2luKSBhcmUgZ2l2ZW4gaW5zdGFuY2VzIG9mIHRoaXNcclxuY2xhc3MsIHdoaWNoIGRlc2NyaWJlIHdoYXQgaGFwcGVuZWQsIHdoZW5ldmVyIHRoZSB2aWV3IGlzIHVwZGF0ZWQuXHJcbiovXHJcbmNsYXNzIFZpZXdVcGRhdGUge1xyXG4gICAgY29uc3RydWN0b3IoXHJcbiAgICAvKipcclxuICAgIFRoZSBlZGl0b3IgdmlldyB0aGF0IHRoZSB1cGRhdGUgaXMgYXNzb2NpYXRlZCB3aXRoLlxyXG4gICAgKi9cclxuICAgIHZpZXcsIFxyXG4gICAgLyoqXHJcbiAgICBUaGUgbmV3IGVkaXRvciBzdGF0ZS5cclxuICAgICovXHJcbiAgICBzdGF0ZSwgXHJcbiAgICAvKipcclxuICAgIFRoZSB0cmFuc2FjdGlvbnMgaW52b2x2ZWQgaW4gdGhlIHVwZGF0ZS4gTWF5IGJlIGVtcHR5LlxyXG4gICAgKi9cclxuICAgIHRyYW5zYWN0aW9ucykge1xyXG4gICAgICAgIHRoaXMudmlldyA9IHZpZXc7XHJcbiAgICAgICAgdGhpcy5zdGF0ZSA9IHN0YXRlO1xyXG4gICAgICAgIHRoaXMudHJhbnNhY3Rpb25zID0gdHJhbnNhY3Rpb25zO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgIEBpbnRlcm5hbFxyXG4gICAgICAgICovXHJcbiAgICAgICAgdGhpcy5mbGFncyA9IDA7XHJcbiAgICAgICAgdGhpcy5zdGFydFN0YXRlID0gdmlldy5zdGF0ZTtcclxuICAgICAgICB0aGlzLmNoYW5nZXMgPSBDaGFuZ2VTZXQuZW1wdHkodGhpcy5zdGFydFN0YXRlLmRvYy5sZW5ndGgpO1xyXG4gICAgICAgIGZvciAobGV0IHRyIG9mIHRyYW5zYWN0aW9ucylcclxuICAgICAgICAgICAgdGhpcy5jaGFuZ2VzID0gdGhpcy5jaGFuZ2VzLmNvbXBvc2UodHIuY2hhbmdlcyk7XHJcbiAgICAgICAgbGV0IGNoYW5nZWRSYW5nZXMgPSBbXTtcclxuICAgICAgICB0aGlzLmNoYW5nZXMuaXRlckNoYW5nZWRSYW5nZXMoKGZyb21BLCB0b0EsIGZyb21CLCB0b0IpID0+IGNoYW5nZWRSYW5nZXMucHVzaChuZXcgQ2hhbmdlZFJhbmdlKGZyb21BLCB0b0EsIGZyb21CLCB0b0IpKSk7XHJcbiAgICAgICAgdGhpcy5jaGFuZ2VkUmFuZ2VzID0gY2hhbmdlZFJhbmdlcztcclxuICAgICAgICBsZXQgZm9jdXMgPSB2aWV3Lmhhc0ZvY3VzO1xyXG4gICAgICAgIGlmIChmb2N1cyAhPSB2aWV3LmlucHV0U3RhdGUubm90aWZpZWRGb2N1c2VkKSB7XHJcbiAgICAgICAgICAgIHZpZXcuaW5wdXRTdGF0ZS5ub3RpZmllZEZvY3VzZWQgPSBmb2N1cztcclxuICAgICAgICAgICAgdGhpcy5mbGFncyB8PSAxIC8qIFVwZGF0ZUZsYWcuRm9jdXMgKi87XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICBAaW50ZXJuYWxcclxuICAgICovXHJcbiAgICBzdGF0aWMgY3JlYXRlKHZpZXcsIHN0YXRlLCB0cmFuc2FjdGlvbnMpIHtcclxuICAgICAgICByZXR1cm4gbmV3IFZpZXdVcGRhdGUodmlldywgc3RhdGUsIHRyYW5zYWN0aW9ucyk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgIFRlbGxzIHlvdSB3aGV0aGVyIHRoZSBbdmlld3BvcnRdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5FZGl0b3JWaWV3LnZpZXdwb3J0KSBvclxyXG4gICAgW3Zpc2libGUgcmFuZ2VzXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuRWRpdG9yVmlldy52aXNpYmxlUmFuZ2VzKSBjaGFuZ2VkIGluIHRoaXNcclxuICAgIHVwZGF0ZS5cclxuICAgICovXHJcbiAgICBnZXQgdmlld3BvcnRDaGFuZ2VkKCkge1xyXG4gICAgICAgIHJldHVybiAodGhpcy5mbGFncyAmIDQgLyogVXBkYXRlRmxhZy5WaWV3cG9ydCAqLykgPiAwO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICBJbmRpY2F0ZXMgd2hldGhlciB0aGUgaGVpZ2h0IG9mIGEgYmxvY2sgZWxlbWVudCBpbiB0aGUgZWRpdG9yXHJcbiAgICBjaGFuZ2VkIGluIHRoaXMgdXBkYXRlLlxyXG4gICAgKi9cclxuICAgIGdldCBoZWlnaHRDaGFuZ2VkKCkge1xyXG4gICAgICAgIHJldHVybiAodGhpcy5mbGFncyAmIDIgLyogVXBkYXRlRmxhZy5IZWlnaHQgKi8pID4gMDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgUmV0dXJucyB0cnVlIHdoZW4gdGhlIGRvY3VtZW50IHdhcyBtb2RpZmllZCBvciB0aGUgc2l6ZSBvZiB0aGVcclxuICAgIGVkaXRvciwgb3IgZWxlbWVudHMgd2l0aGluIHRoZSBlZGl0b3IsIGNoYW5nZWQuXHJcbiAgICAqL1xyXG4gICAgZ2V0IGdlb21ldHJ5Q2hhbmdlZCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5kb2NDaGFuZ2VkIHx8ICh0aGlzLmZsYWdzICYgKDggLyogVXBkYXRlRmxhZy5HZW9tZXRyeSAqLyB8IDIgLyogVXBkYXRlRmxhZy5IZWlnaHQgKi8pKSA+IDA7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgIFRydWUgd2hlbiB0aGlzIHVwZGF0ZSBpbmRpY2F0ZXMgYSBmb2N1cyBjaGFuZ2UuXHJcbiAgICAqL1xyXG4gICAgZ2V0IGZvY3VzQ2hhbmdlZCgpIHtcclxuICAgICAgICByZXR1cm4gKHRoaXMuZmxhZ3MgJiAxIC8qIFVwZGF0ZUZsYWcuRm9jdXMgKi8pID4gMDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgV2hldGhlciB0aGUgZG9jdW1lbnQgY2hhbmdlZCBpbiB0aGlzIHVwZGF0ZS5cclxuICAgICovXHJcbiAgICBnZXQgZG9jQ2hhbmdlZCgpIHtcclxuICAgICAgICByZXR1cm4gIXRoaXMuY2hhbmdlcy5lbXB0eTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgV2hldGhlciB0aGUgc2VsZWN0aW9uIHdhcyBleHBsaWNpdGx5IHNldCBpbiB0aGlzIHVwZGF0ZS5cclxuICAgICovXHJcbiAgICBnZXQgc2VsZWN0aW9uU2V0KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnRyYW5zYWN0aW9ucy5zb21lKHRyID0+IHRyLnNlbGVjdGlvbik7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgIEBpbnRlcm5hbFxyXG4gICAgKi9cclxuICAgIGdldCBlbXB0eSgpIHsgcmV0dXJuIHRoaXMuZmxhZ3MgPT0gMCAmJiB0aGlzLnRyYW5zYWN0aW9ucy5sZW5ndGggPT0gMDsgfVxyXG59XHJcblxyXG4vKipcclxuVXNlZCB0byBpbmRpY2F0ZSBbdGV4dCBkaXJlY3Rpb25dKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5FZGl0b3JWaWV3LnRleHREaXJlY3Rpb24pLlxyXG4qL1xyXG52YXIgRGlyZWN0aW9uID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoRGlyZWN0aW9uKSB7XHJcbiAgICAvLyAoVGhlc2UgYXJlIGNob3NlbiB0byBtYXRjaCB0aGUgYmFzZSBsZXZlbHMsIGluIGJpZGkgYWxnb3JpdGhtXHJcbiAgICAvLyB0ZXJtcywgb2Ygc3BhbnMgaW4gdGhhdCBkaXJlY3Rpb24uKVxyXG4gICAgLyoqXHJcbiAgICBMZWZ0LXRvLXJpZ2h0LlxyXG4gICAgKi9cclxuICAgIERpcmVjdGlvbltEaXJlY3Rpb25bXCJMVFJcIl0gPSAwXSA9IFwiTFRSXCI7XHJcbiAgICAvKipcclxuICAgIFJpZ2h0LXRvLWxlZnQuXHJcbiAgICAqL1xyXG4gICAgRGlyZWN0aW9uW0RpcmVjdGlvbltcIlJUTFwiXSA9IDFdID0gXCJSVExcIjtcclxucmV0dXJuIERpcmVjdGlvbn0pKERpcmVjdGlvbiB8fCAoRGlyZWN0aW9uID0ge30pKTtcclxuY29uc3QgTFRSID0gRGlyZWN0aW9uLkxUUiwgUlRMID0gRGlyZWN0aW9uLlJUTDtcclxuLy8gRGVjb2RlIGEgc3RyaW5nIHdpdGggZWFjaCB0eXBlIGVuY29kZWQgYXMgbG9nMih0eXBlKVxyXG5mdW5jdGlvbiBkZWMoc3RyKSB7XHJcbiAgICBsZXQgcmVzdWx0ID0gW107XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKylcclxuICAgICAgICByZXN1bHQucHVzaCgxIDw8ICtzdHJbaV0pO1xyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufVxyXG4vLyBDaGFyYWN0ZXIgdHlwZXMgZm9yIGNvZGVwb2ludHMgMCB0byAweGY4XHJcbmNvbnN0IExvd1R5cGVzID0gLypAX19QVVJFX18qL2RlYyhcIjg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4NjY2ODg4ODg4Nzg3ODMzMzMzMzMzMzM3ODg4ODg4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDA4ODg4ODgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg3ODY2NjY4ODg4MDg4ODg4NjYzMzgwODg4MzA4ODg4ODAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwODAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDA4XCIpO1xyXG4vLyBDaGFyYWN0ZXIgdHlwZXMgZm9yIGNvZGVwb2ludHMgMHg2MDAgdG8gMHg2ZjlcclxuY29uc3QgQXJhYmljVHlwZXMgPSAvKkBfX1BVUkVfXyovZGVjKFwiNDQ0NDQ0ODgyNjYyNzI4ODk5OTk5OTk5OTk5MjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyOTk5OTk5OTk5OTk5OTk5OTk5OTk5NDQ0NDQ0NDQ0NDY0NDIyMjgyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjk5OTk5OTk0OTk5OTk5OTIyOTk4OTk5OTIyMzMzMzMzMzMzM1wiKTtcclxuY29uc3QgQnJhY2tldHMgPSAvKkBfX1BVUkVfXyovT2JqZWN0LmNyZWF0ZShudWxsKSwgQnJhY2tldFN0YWNrID0gW107XHJcbi8vIFRoZXJlJ3MgYSBsb3QgbW9yZSBpblxyXG4vLyBodHRwczovL3d3dy51bmljb2RlLm9yZy9QdWJsaWMvVUNEL2xhdGVzdC91Y2QvQmlkaUJyYWNrZXRzLnR4dCxcclxuLy8gd2hpY2ggYXJlIGxlZnQgb3V0IHRvIGtlZXAgY29kZSBzaXplIGRvd24uXHJcbmZvciAobGV0IHAgb2YgW1wiKClcIiwgXCJbXVwiLCBcInt9XCJdKSB7XHJcbiAgICBsZXQgbCA9IC8qQF9fUFVSRV9fKi9wLmNoYXJDb2RlQXQoMCksIHIgPSAvKkBfX1BVUkVfXyovcC5jaGFyQ29kZUF0KDEpO1xyXG4gICAgQnJhY2tldHNbbF0gPSByO1xyXG4gICAgQnJhY2tldHNbcl0gPSAtbDtcclxufVxyXG5mdW5jdGlvbiBjaGFyVHlwZShjaCkge1xyXG4gICAgcmV0dXJuIGNoIDw9IDB4ZjcgPyBMb3dUeXBlc1tjaF0gOlxyXG4gICAgICAgIDB4NTkwIDw9IGNoICYmIGNoIDw9IDB4NWY0ID8gMiAvKiBULlIgKi8gOlxyXG4gICAgICAgICAgICAweDYwMCA8PSBjaCAmJiBjaCA8PSAweDZmOSA/IEFyYWJpY1R5cGVzW2NoIC0gMHg2MDBdIDpcclxuICAgICAgICAgICAgICAgIDB4NmVlIDw9IGNoICYmIGNoIDw9IDB4OGFjID8gNCAvKiBULkFMICovIDpcclxuICAgICAgICAgICAgICAgICAgICAweDIwMDAgPD0gY2ggJiYgY2ggPD0gMHgyMDBiID8gMjU2IC8qIFQuTkkgKi8gOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAweGZiNTAgPD0gY2ggJiYgY2ggPD0gMHhmZGZmID8gNCAvKiBULkFMICovIDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoID09IDB4MjAwYyA/IDI1NiAvKiBULk5JICovIDogMSAvKiBULkwgKi87XHJcbn1cclxuY29uc3QgQmlkaVJFID0gL1tcXHUwNTkwLVxcdTA1ZjRcXHUwNjAwLVxcdTA2ZmZcXHUwNzAwLVxcdTA4YWNcXHVmYjUwLVxcdWZkZmZdLztcclxuLyoqXHJcblJlcHJlc2VudHMgYSBjb250aWd1b3VzIHJhbmdlIG9mIHRleHQgdGhhdCBoYXMgYSBzaW5nbGUgZGlyZWN0aW9uXHJcbihhcyBpbiBsZWZ0LXRvLXJpZ2h0IG9yIHJpZ2h0LXRvLWxlZnQpLlxyXG4qL1xyXG5jbGFzcyBCaWRpU3BhbiB7XHJcbiAgICAvKipcclxuICAgIEBpbnRlcm5hbFxyXG4gICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKFxyXG4gICAgLyoqXHJcbiAgICBUaGUgc3RhcnQgb2YgdGhlIHNwYW4gKHJlbGF0aXZlIHRvIHRoZSBzdGFydCBvZiB0aGUgbGluZSkuXHJcbiAgICAqL1xyXG4gICAgZnJvbSwgXHJcbiAgICAvKipcclxuICAgIFRoZSBlbmQgb2YgdGhlIHNwYW4uXHJcbiAgICAqL1xyXG4gICAgdG8sIFxyXG4gICAgLyoqXHJcbiAgICBUaGUgW1wiYmlkaVxyXG4gICAgbGV2ZWxcIl0oaHR0cHM6Ly91bmljb2RlLm9yZy9yZXBvcnRzL3RyOS8jQmFzaWNfRGlzcGxheV9BbGdvcml0aG0pXHJcbiAgICBvZiB0aGUgc3BhbiAoaW4gdGhpcyBjb250ZXh0LCAwIG1lYW5zXHJcbiAgICBsZWZ0LXRvLXJpZ2h0LCAxIG1lYW5zIHJpZ2h0LXRvLWxlZnQsIDIgbWVhbnMgbGVmdC10by1yaWdodFxyXG4gICAgbnVtYmVyIGluc2lkZSByaWdodC10by1sZWZ0IHRleHQpLlxyXG4gICAgKi9cclxuICAgIGxldmVsKSB7XHJcbiAgICAgICAgdGhpcy5mcm9tID0gZnJvbTtcclxuICAgICAgICB0aGlzLnRvID0gdG87XHJcbiAgICAgICAgdGhpcy5sZXZlbCA9IGxldmVsO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICBUaGUgZGlyZWN0aW9uIG9mIHRoaXMgc3Bhbi5cclxuICAgICovXHJcbiAgICBnZXQgZGlyKCkgeyByZXR1cm4gdGhpcy5sZXZlbCAlIDIgPyBSVEwgOiBMVFI7IH1cclxuICAgIC8qKlxyXG4gICAgQGludGVybmFsXHJcbiAgICAqL1xyXG4gICAgc2lkZShlbmQsIGRpcikgeyByZXR1cm4gKHRoaXMuZGlyID09IGRpcikgPT0gZW5kID8gdGhpcy50byA6IHRoaXMuZnJvbTsgfVxyXG4gICAgLyoqXHJcbiAgICBAaW50ZXJuYWxcclxuICAgICovXHJcbiAgICBzdGF0aWMgZmluZChvcmRlciwgaW5kZXgsIGxldmVsLCBhc3NvYykge1xyXG4gICAgICAgIGxldCBtYXliZSA9IC0xO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb3JkZXIubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgbGV0IHNwYW4gPSBvcmRlcltpXTtcclxuICAgICAgICAgICAgaWYgKHNwYW4uZnJvbSA8PSBpbmRleCAmJiBzcGFuLnRvID49IGluZGV4KSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoc3Bhbi5sZXZlbCA9PSBsZXZlbClcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaTtcclxuICAgICAgICAgICAgICAgIC8vIFdoZW4gbXVsdGlwbGUgc3BhbnMgbWF0Y2gsIGlmIGFzc29jICE9IDAsIHRha2UgdGhlIG9uZSB0aGF0XHJcbiAgICAgICAgICAgICAgICAvLyBjb3ZlcnMgdGhhdCBzaWRlLCBvdGhlcndpc2UgdGFrZSB0aGUgb25lIHdpdGggdGhlIG1pbmltdW1cclxuICAgICAgICAgICAgICAgIC8vIGxldmVsLlxyXG4gICAgICAgICAgICAgICAgaWYgKG1heWJlIDwgMCB8fCAoYXNzb2MgIT0gMCA/IChhc3NvYyA8IDAgPyBzcGFuLmZyb20gPCBpbmRleCA6IHNwYW4udG8gPiBpbmRleCkgOiBvcmRlclttYXliZV0ubGV2ZWwgPiBzcGFuLmxldmVsKSlcclxuICAgICAgICAgICAgICAgICAgICBtYXliZSA9IGk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG1heWJlIDwgMClcclxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbmRleCBvdXQgb2YgcmFuZ2VcIik7XHJcbiAgICAgICAgcmV0dXJuIG1heWJlO1xyXG4gICAgfVxyXG59XHJcbi8vIFJldXNlZCBhcnJheSBvZiBjaGFyYWN0ZXIgdHlwZXNcclxuY29uc3QgdHlwZXMgPSBbXTtcclxuZnVuY3Rpb24gY29tcHV0ZU9yZGVyKGxpbmUsIGRpcmVjdGlvbikge1xyXG4gICAgbGV0IGxlbiA9IGxpbmUubGVuZ3RoLCBvdXRlclR5cGUgPSBkaXJlY3Rpb24gPT0gTFRSID8gMSAvKiBULkwgKi8gOiAyIC8qIFQuUiAqLywgb3Bwb3NpdGVUeXBlID0gZGlyZWN0aW9uID09IExUUiA/IDIgLyogVC5SICovIDogMSAvKiBULkwgKi87XHJcbiAgICBpZiAoIWxpbmUgfHwgb3V0ZXJUeXBlID09IDEgLyogVC5MICovICYmICFCaWRpUkUudGVzdChsaW5lKSlcclxuICAgICAgICByZXR1cm4gdHJpdmlhbE9yZGVyKGxlbik7XHJcbiAgICAvLyBXMS4gRXhhbWluZSBlYWNoIG5vbi1zcGFjaW5nIG1hcmsgKE5TTSkgaW4gdGhlIGxldmVsIHJ1biwgYW5kXHJcbiAgICAvLyBjaGFuZ2UgdGhlIHR5cGUgb2YgdGhlIE5TTSB0byB0aGUgdHlwZSBvZiB0aGUgcHJldmlvdXNcclxuICAgIC8vIGNoYXJhY3Rlci4gSWYgdGhlIE5TTSBpcyBhdCB0aGUgc3RhcnQgb2YgdGhlIGxldmVsIHJ1biwgaXQgd2lsbFxyXG4gICAgLy8gZ2V0IHRoZSB0eXBlIG9mIHNvci5cclxuICAgIC8vIFcyLiBTZWFyY2ggYmFja3dhcmRzIGZyb20gZWFjaCBpbnN0YW5jZSBvZiBhIEV1cm9wZWFuIG51bWJlclxyXG4gICAgLy8gdW50aWwgdGhlIGZpcnN0IHN0cm9uZyB0eXBlIChSLCBMLCBBTCwgb3Igc29yKSBpcyBmb3VuZC4gSWYgYW5cclxuICAgIC8vIEFMIGlzIGZvdW5kLCBjaGFuZ2UgdGhlIHR5cGUgb2YgdGhlIEV1cm9wZWFuIG51bWJlciB0byBBcmFiaWNcclxuICAgIC8vIG51bWJlci5cclxuICAgIC8vIFczLiBDaGFuZ2UgYWxsIEFMcyB0byBSLlxyXG4gICAgLy8gKExlZnQgYWZ0ZXIgdGhpczogTCwgUiwgRU4sIEFOLCBFVCwgQ1MsIE5JKVxyXG4gICAgZm9yIChsZXQgaSA9IDAsIHByZXYgPSBvdXRlclR5cGUsIHByZXZTdHJvbmcgPSBvdXRlclR5cGU7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgIGxldCB0eXBlID0gY2hhclR5cGUobGluZS5jaGFyQ29kZUF0KGkpKTtcclxuICAgICAgICBpZiAodHlwZSA9PSA1MTIgLyogVC5OU00gKi8pXHJcbiAgICAgICAgICAgIHR5cGUgPSBwcmV2O1xyXG4gICAgICAgIGVsc2UgaWYgKHR5cGUgPT0gOCAvKiBULkVOICovICYmIHByZXZTdHJvbmcgPT0gNCAvKiBULkFMICovKVxyXG4gICAgICAgICAgICB0eXBlID0gMTYgLyogVC5BTiAqLztcclxuICAgICAgICB0eXBlc1tpXSA9IHR5cGUgPT0gNCAvKiBULkFMICovID8gMiAvKiBULlIgKi8gOiB0eXBlO1xyXG4gICAgICAgIGlmICh0eXBlICYgNyAvKiBULlN0cm9uZyAqLylcclxuICAgICAgICAgICAgcHJldlN0cm9uZyA9IHR5cGU7XHJcbiAgICAgICAgcHJldiA9IHR5cGU7XHJcbiAgICB9XHJcbiAgICAvLyBXNS4gQSBzZXF1ZW5jZSBvZiBFdXJvcGVhbiB0ZXJtaW5hdG9ycyBhZGphY2VudCB0byBFdXJvcGVhblxyXG4gICAgLy8gbnVtYmVycyBjaGFuZ2VzIHRvIGFsbCBFdXJvcGVhbiBudW1iZXJzLlxyXG4gICAgLy8gVzYuIE90aGVyd2lzZSwgc2VwYXJhdG9ycyBhbmQgdGVybWluYXRvcnMgY2hhbmdlIHRvIE90aGVyXHJcbiAgICAvLyBOZXV0cmFsLlxyXG4gICAgLy8gVzcuIFNlYXJjaCBiYWNrd2FyZHMgZnJvbSBlYWNoIGluc3RhbmNlIG9mIGEgRXVyb3BlYW4gbnVtYmVyXHJcbiAgICAvLyB1bnRpbCB0aGUgZmlyc3Qgc3Ryb25nIHR5cGUgKFIsIEwsIG9yIHNvcikgaXMgZm91bmQuIElmIGFuIEwgaXNcclxuICAgIC8vIGZvdW5kLCB0aGVuIGNoYW5nZSB0aGUgdHlwZSBvZiB0aGUgRXVyb3BlYW4gbnVtYmVyIHRvIEwuXHJcbiAgICAvLyAoTGVmdCBhZnRlciB0aGlzOiBMLCBSLCBFTitBTiwgTkkpXHJcbiAgICBmb3IgKGxldCBpID0gMCwgcHJldiA9IG91dGVyVHlwZSwgcHJldlN0cm9uZyA9IG91dGVyVHlwZTsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgbGV0IHR5cGUgPSB0eXBlc1tpXTtcclxuICAgICAgICBpZiAodHlwZSA9PSAxMjggLyogVC5DUyAqLykge1xyXG4gICAgICAgICAgICBpZiAoaSA8IGxlbiAtIDEgJiYgcHJldiA9PSB0eXBlc1tpICsgMV0gJiYgKHByZXYgJiAyNCAvKiBULk51bSAqLykpXHJcbiAgICAgICAgICAgICAgICB0eXBlID0gdHlwZXNbaV0gPSBwcmV2O1xyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICB0eXBlc1tpXSA9IDI1NiAvKiBULk5JICovO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0eXBlID09IDY0IC8qIFQuRVQgKi8pIHtcclxuICAgICAgICAgICAgbGV0IGVuZCA9IGkgKyAxO1xyXG4gICAgICAgICAgICB3aGlsZSAoZW5kIDwgbGVuICYmIHR5cGVzW2VuZF0gPT0gNjQgLyogVC5FVCAqLylcclxuICAgICAgICAgICAgICAgIGVuZCsrO1xyXG4gICAgICAgICAgICBsZXQgcmVwbGFjZSA9IChpICYmIHByZXYgPT0gOCAvKiBULkVOICovKSB8fCAoZW5kIDwgbGVuICYmIHR5cGVzW2VuZF0gPT0gOCAvKiBULkVOICovKSA/IChwcmV2U3Ryb25nID09IDEgLyogVC5MICovID8gMSAvKiBULkwgKi8gOiA4IC8qIFQuRU4gKi8pIDogMjU2IC8qIFQuTkkgKi87XHJcbiAgICAgICAgICAgIGZvciAobGV0IGogPSBpOyBqIDwgZW5kOyBqKyspXHJcbiAgICAgICAgICAgICAgICB0eXBlc1tqXSA9IHJlcGxhY2U7XHJcbiAgICAgICAgICAgIGkgPSBlbmQgLSAxO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0eXBlID09IDggLyogVC5FTiAqLyAmJiBwcmV2U3Ryb25nID09IDEgLyogVC5MICovKSB7XHJcbiAgICAgICAgICAgIHR5cGVzW2ldID0gMSAvKiBULkwgKi87XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHByZXYgPSB0eXBlO1xyXG4gICAgICAgIGlmICh0eXBlICYgNyAvKiBULlN0cm9uZyAqLylcclxuICAgICAgICAgICAgcHJldlN0cm9uZyA9IHR5cGU7XHJcbiAgICB9XHJcbiAgICAvLyBOMC4gUHJvY2VzcyBicmFja2V0IHBhaXJzIGluIGFuIGlzb2xhdGluZyBydW4gc2VxdWVuY2VcclxuICAgIC8vIHNlcXVlbnRpYWxseSBpbiB0aGUgbG9naWNhbCBvcmRlciBvZiB0aGUgdGV4dCBwb3NpdGlvbnMgb2YgdGhlXHJcbiAgICAvLyBvcGVuaW5nIHBhaXJlZCBicmFja2V0cyB1c2luZyB0aGUgbG9naWMgZ2l2ZW4gYmVsb3cuIFdpdGhpbiB0aGlzXHJcbiAgICAvLyBzY29wZSwgYmlkaXJlY3Rpb25hbCB0eXBlcyBFTiBhbmQgQU4gYXJlIHRyZWF0ZWQgYXMgUi5cclxuICAgIGZvciAobGV0IGkgPSAwLCBzSSA9IDAsIGNvbnRleHQgPSAwLCBjaCwgYnIsIHR5cGU7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgIC8vIEtlZXBzIFtzdGFydEluZGV4LCB0eXBlLCBzdHJvbmdTZWVuXSB0cmlwbGVzIGZvciBlYWNoIG9wZW5cclxuICAgICAgICAvLyBicmFja2V0IG9uIEJyYWNrZXRTdGFjay5cclxuICAgICAgICBpZiAoYnIgPSBCcmFja2V0c1tjaCA9IGxpbmUuY2hhckNvZGVBdChpKV0pIHtcclxuICAgICAgICAgICAgaWYgKGJyIDwgMCkgeyAvLyBDbG9zaW5nIGJyYWNrZXRcclxuICAgICAgICAgICAgICAgIGZvciAobGV0IHNKID0gc0kgLSAzOyBzSiA+PSAwOyBzSiAtPSAzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKEJyYWNrZXRTdGFja1tzSiArIDFdID09IC1icikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgZmxhZ3MgPSBCcmFja2V0U3RhY2tbc0ogKyAyXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHR5cGUgPSAoZmxhZ3MgJiAyIC8qIEJyYWNrZXRlZC5FbWJlZEluc2lkZSAqLykgPyBvdXRlclR5cGUgOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIShmbGFncyAmIDQgLyogQnJhY2tldGVkLk9wcG9zaXRlSW5zaWRlICovKSA/IDAgOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChmbGFncyAmIDEgLyogQnJhY2tldGVkLk9wcG9zaXRlQmVmb3JlICovKSA/IG9wcG9zaXRlVHlwZSA6IG91dGVyVHlwZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGUpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlc1tpXSA9IHR5cGVzW0JyYWNrZXRTdGFja1tzSl1dID0gdHlwZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc0kgPSBzSjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKEJyYWNrZXRTdGFjay5sZW5ndGggPT0gMTg5IC8qIEJyYWNrZXRlZC5NYXhEZXB0aCAqLykge1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBCcmFja2V0U3RhY2tbc0krK10gPSBpO1xyXG4gICAgICAgICAgICAgICAgQnJhY2tldFN0YWNrW3NJKytdID0gY2g7XHJcbiAgICAgICAgICAgICAgICBCcmFja2V0U3RhY2tbc0krK10gPSBjb250ZXh0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKCh0eXBlID0gdHlwZXNbaV0pID09IDIgLyogVC5SICovIHx8IHR5cGUgPT0gMSAvKiBULkwgKi8pIHtcclxuICAgICAgICAgICAgbGV0IGVtYmVkID0gdHlwZSA9PSBvdXRlclR5cGU7XHJcbiAgICAgICAgICAgIGNvbnRleHQgPSBlbWJlZCA/IDAgOiAxIC8qIEJyYWNrZXRlZC5PcHBvc2l0ZUJlZm9yZSAqLztcclxuICAgICAgICAgICAgZm9yIChsZXQgc0ogPSBzSSAtIDM7IHNKID49IDA7IHNKIC09IDMpIHtcclxuICAgICAgICAgICAgICAgIGxldCBjdXIgPSBCcmFja2V0U3RhY2tbc0ogKyAyXTtcclxuICAgICAgICAgICAgICAgIGlmIChjdXIgJiAyIC8qIEJyYWNrZXRlZC5FbWJlZEluc2lkZSAqLylcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGlmIChlbWJlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIEJyYWNrZXRTdGFja1tzSiArIDJdIHw9IDIgLyogQnJhY2tldGVkLkVtYmVkSW5zaWRlICovO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGN1ciAmIDQgLyogQnJhY2tldGVkLk9wcG9zaXRlSW5zaWRlICovKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBCcmFja2V0U3RhY2tbc0ogKyAyXSB8PSA0IC8qIEJyYWNrZXRlZC5PcHBvc2l0ZUluc2lkZSAqLztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8vIE4xLiBBIHNlcXVlbmNlIG9mIG5ldXRyYWxzIHRha2VzIHRoZSBkaXJlY3Rpb24gb2YgdGhlXHJcbiAgICAvLyBzdXJyb3VuZGluZyBzdHJvbmcgdGV4dCBpZiB0aGUgdGV4dCBvbiBib3RoIHNpZGVzIGhhcyB0aGUgc2FtZVxyXG4gICAgLy8gZGlyZWN0aW9uLiBFdXJvcGVhbiBhbmQgQXJhYmljIG51bWJlcnMgYWN0IGFzIGlmIHRoZXkgd2VyZSBSIGluXHJcbiAgICAvLyB0ZXJtcyBvZiB0aGVpciBpbmZsdWVuY2Ugb24gbmV1dHJhbHMuIFN0YXJ0LW9mLWxldmVsLXJ1biAoc29yKVxyXG4gICAgLy8gYW5kIGVuZC1vZi1sZXZlbC1ydW4gKGVvcikgYXJlIHVzZWQgYXQgbGV2ZWwgcnVuIGJvdW5kYXJpZXMuXHJcbiAgICAvLyBOMi4gQW55IHJlbWFpbmluZyBuZXV0cmFscyB0YWtlIHRoZSBlbWJlZGRpbmcgZGlyZWN0aW9uLlxyXG4gICAgLy8gKExlZnQgYWZ0ZXIgdGhpczogTCwgUiwgRU4rQU4pXHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgaWYgKHR5cGVzW2ldID09IDI1NiAvKiBULk5JICovKSB7XHJcbiAgICAgICAgICAgIGxldCBlbmQgPSBpICsgMTtcclxuICAgICAgICAgICAgd2hpbGUgKGVuZCA8IGxlbiAmJiB0eXBlc1tlbmRdID09IDI1NiAvKiBULk5JICovKVxyXG4gICAgICAgICAgICAgICAgZW5kKys7XHJcbiAgICAgICAgICAgIGxldCBiZWZvcmVMID0gKGkgPyB0eXBlc1tpIC0gMV0gOiBvdXRlclR5cGUpID09IDEgLyogVC5MICovO1xyXG4gICAgICAgICAgICBsZXQgYWZ0ZXJMID0gKGVuZCA8IGxlbiA/IHR5cGVzW2VuZF0gOiBvdXRlclR5cGUpID09IDEgLyogVC5MICovO1xyXG4gICAgICAgICAgICBsZXQgcmVwbGFjZSA9IGJlZm9yZUwgPT0gYWZ0ZXJMID8gKGJlZm9yZUwgPyAxIC8qIFQuTCAqLyA6IDIgLyogVC5SICovKSA6IG91dGVyVHlwZTtcclxuICAgICAgICAgICAgZm9yIChsZXQgaiA9IGk7IGogPCBlbmQ7IGorKylcclxuICAgICAgICAgICAgICAgIHR5cGVzW2pdID0gcmVwbGFjZTtcclxuICAgICAgICAgICAgaSA9IGVuZCAtIDE7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLy8gSGVyZSB3ZSBkZXBhcnQgZnJvbSB0aGUgZG9jdW1lbnRlZCBhbGdvcml0aG0sIGluIG9yZGVyIHRvIGF2b2lkXHJcbiAgICAvLyBidWlsZGluZyB1cCBhbiBhY3R1YWwgbGV2ZWxzIGFycmF5LiBTaW5jZSB0aGVyZSBhcmUgb25seSB0aHJlZVxyXG4gICAgLy8gbGV2ZWxzICgwLCAxLCAyKSBpbiBhbiBpbXBsZW1lbnRhdGlvbiB0aGF0IGRvZXNuJ3QgdGFrZVxyXG4gICAgLy8gZXhwbGljaXQgZW1iZWRkaW5nIGludG8gYWNjb3VudCwgd2UgY2FuIGJ1aWxkIHVwIHRoZSBvcmRlciBvblxyXG4gICAgLy8gdGhlIGZseSwgd2l0aG91dCBmb2xsb3dpbmcgdGhlIGxldmVsLWJhc2VkIGFsZ29yaXRobS5cclxuICAgIGxldCBvcmRlciA9IFtdO1xyXG4gICAgaWYgKG91dGVyVHlwZSA9PSAxIC8qIFQuTCAqLykge1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOykge1xyXG4gICAgICAgICAgICBsZXQgc3RhcnQgPSBpLCBydGwgPSB0eXBlc1tpKytdICE9IDEgLyogVC5MICovO1xyXG4gICAgICAgICAgICB3aGlsZSAoaSA8IGxlbiAmJiBydGwgPT0gKHR5cGVzW2ldICE9IDEgLyogVC5MICovKSlcclxuICAgICAgICAgICAgICAgIGkrKztcclxuICAgICAgICAgICAgaWYgKHJ0bCkge1xyXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IGk7IGogPiBzdGFydDspIHtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgZW5kID0gaiwgbCA9IHR5cGVzWy0tal0gIT0gMiAvKiBULlIgKi87XHJcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGogPiBzdGFydCAmJiBsID09ICh0eXBlc1tqIC0gMV0gIT0gMiAvKiBULlIgKi8pKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBqLS07XHJcbiAgICAgICAgICAgICAgICAgICAgb3JkZXIucHVzaChuZXcgQmlkaVNwYW4oaiwgZW5kLCBsID8gMiA6IDEpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIG9yZGVyLnB1c2gobmV3IEJpZGlTcGFuKHN0YXJ0LCBpLCAwKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjspIHtcclxuICAgICAgICAgICAgbGV0IHN0YXJ0ID0gaSwgcnRsID0gdHlwZXNbaSsrXSA9PSAyIC8qIFQuUiAqLztcclxuICAgICAgICAgICAgd2hpbGUgKGkgPCBsZW4gJiYgcnRsID09ICh0eXBlc1tpXSA9PSAyIC8qIFQuUiAqLykpXHJcbiAgICAgICAgICAgICAgICBpKys7XHJcbiAgICAgICAgICAgIG9yZGVyLnB1c2gobmV3IEJpZGlTcGFuKHN0YXJ0LCBpLCBydGwgPyAxIDogMikpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBvcmRlcjtcclxufVxyXG5mdW5jdGlvbiB0cml2aWFsT3JkZXIobGVuZ3RoKSB7XHJcbiAgICByZXR1cm4gW25ldyBCaWRpU3BhbigwLCBsZW5ndGgsIDApXTtcclxufVxyXG5sZXQgbW92ZWRPdmVyID0gXCJcIjtcclxuZnVuY3Rpb24gbW92ZVZpc3VhbGx5KGxpbmUsIG9yZGVyLCBkaXIsIHN0YXJ0LCBmb3J3YXJkKSB7XHJcbiAgICB2YXIgX2E7XHJcbiAgICBsZXQgc3RhcnRJbmRleCA9IHN0YXJ0LmhlYWQgLSBsaW5lLmZyb20sIHNwYW5JID0gLTE7XHJcbiAgICBpZiAoc3RhcnRJbmRleCA9PSAwKSB7XHJcbiAgICAgICAgaWYgKCFmb3J3YXJkIHx8ICFsaW5lLmxlbmd0aClcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgaWYgKG9yZGVyWzBdLmxldmVsICE9IGRpcikge1xyXG4gICAgICAgICAgICBzdGFydEluZGV4ID0gb3JkZXJbMF0uc2lkZShmYWxzZSwgZGlyKTtcclxuICAgICAgICAgICAgc3BhbkkgPSAwO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHN0YXJ0SW5kZXggPT0gbGluZS5sZW5ndGgpIHtcclxuICAgICAgICBpZiAoZm9yd2FyZClcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgbGV0IGxhc3QgPSBvcmRlcltvcmRlci5sZW5ndGggLSAxXTtcclxuICAgICAgICBpZiAobGFzdC5sZXZlbCAhPSBkaXIpIHtcclxuICAgICAgICAgICAgc3RhcnRJbmRleCA9IGxhc3Quc2lkZSh0cnVlLCBkaXIpO1xyXG4gICAgICAgICAgICBzcGFuSSA9IG9yZGVyLmxlbmd0aCAtIDE7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKHNwYW5JIDwgMClcclxuICAgICAgICBzcGFuSSA9IEJpZGlTcGFuLmZpbmQob3JkZXIsIHN0YXJ0SW5kZXgsIChfYSA9IHN0YXJ0LmJpZGlMZXZlbCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogLTEsIHN0YXJ0LmFzc29jKTtcclxuICAgIGxldCBzcGFuID0gb3JkZXJbc3BhbkldO1xyXG4gICAgLy8gRW5kIG9mIHNwYW4uIChCdXQgbm90IGVuZCBvZiBsaW5lLS10aGF0IHdhcyBjaGVja2VkIGZvciBhYm92ZS4pXHJcbiAgICBpZiAoc3RhcnRJbmRleCA9PSBzcGFuLnNpZGUoZm9yd2FyZCwgZGlyKSkge1xyXG4gICAgICAgIHNwYW4gPSBvcmRlcltzcGFuSSArPSBmb3J3YXJkID8gMSA6IC0xXTtcclxuICAgICAgICBzdGFydEluZGV4ID0gc3Bhbi5zaWRlKCFmb3J3YXJkLCBkaXIpO1xyXG4gICAgfVxyXG4gICAgbGV0IGluZGV4Rm9yd2FyZCA9IGZvcndhcmQgPT0gKHNwYW4uZGlyID09IGRpcik7XHJcbiAgICBsZXQgbmV4dEluZGV4ID0gZmluZENsdXN0ZXJCcmVhayhsaW5lLnRleHQsIHN0YXJ0SW5kZXgsIGluZGV4Rm9yd2FyZCk7XHJcbiAgICBtb3ZlZE92ZXIgPSBsaW5lLnRleHQuc2xpY2UoTWF0aC5taW4oc3RhcnRJbmRleCwgbmV4dEluZGV4KSwgTWF0aC5tYXgoc3RhcnRJbmRleCwgbmV4dEluZGV4KSk7XHJcbiAgICBpZiAobmV4dEluZGV4ICE9IHNwYW4uc2lkZShmb3J3YXJkLCBkaXIpKVxyXG4gICAgICAgIHJldHVybiBFZGl0b3JTZWxlY3Rpb24uY3Vyc29yKG5leHRJbmRleCArIGxpbmUuZnJvbSwgaW5kZXhGb3J3YXJkID8gLTEgOiAxLCBzcGFuLmxldmVsKTtcclxuICAgIGxldCBuZXh0U3BhbiA9IHNwYW5JID09IChmb3J3YXJkID8gb3JkZXIubGVuZ3RoIC0gMSA6IDApID8gbnVsbCA6IG9yZGVyW3NwYW5JICsgKGZvcndhcmQgPyAxIDogLTEpXTtcclxuICAgIGlmICghbmV4dFNwYW4gJiYgc3Bhbi5sZXZlbCAhPSBkaXIpXHJcbiAgICAgICAgcmV0dXJuIEVkaXRvclNlbGVjdGlvbi5jdXJzb3IoZm9yd2FyZCA/IGxpbmUudG8gOiBsaW5lLmZyb20sIGZvcndhcmQgPyAtMSA6IDEsIGRpcik7XHJcbiAgICBpZiAobmV4dFNwYW4gJiYgbmV4dFNwYW4ubGV2ZWwgPCBzcGFuLmxldmVsKVxyXG4gICAgICAgIHJldHVybiBFZGl0b3JTZWxlY3Rpb24uY3Vyc29yKG5leHRTcGFuLnNpZGUoIWZvcndhcmQsIGRpcikgKyBsaW5lLmZyb20sIGZvcndhcmQgPyAxIDogLTEsIG5leHRTcGFuLmxldmVsKTtcclxuICAgIHJldHVybiBFZGl0b3JTZWxlY3Rpb24uY3Vyc29yKG5leHRJbmRleCArIGxpbmUuZnJvbSwgZm9yd2FyZCA/IC0xIDogMSwgc3Bhbi5sZXZlbCk7XHJcbn1cclxuXHJcbmNvbnN0IExpbmVCcmVha1BsYWNlaG9sZGVyID0gXCJcXHVmZmZmXCI7XHJcbmNsYXNzIERPTVJlYWRlciB7XHJcbiAgICBjb25zdHJ1Y3Rvcihwb2ludHMsIHN0YXRlKSB7XHJcbiAgICAgICAgdGhpcy5wb2ludHMgPSBwb2ludHM7XHJcbiAgICAgICAgdGhpcy50ZXh0ID0gXCJcIjtcclxuICAgICAgICB0aGlzLmxpbmVTZXBhcmF0b3IgPSBzdGF0ZS5mYWNldChFZGl0b3JTdGF0ZS5saW5lU2VwYXJhdG9yKTtcclxuICAgIH1cclxuICAgIGFwcGVuZCh0ZXh0KSB7XHJcbiAgICAgICAgdGhpcy50ZXh0ICs9IHRleHQ7XHJcbiAgICB9XHJcbiAgICBsaW5lQnJlYWsoKSB7XHJcbiAgICAgICAgdGhpcy50ZXh0ICs9IExpbmVCcmVha1BsYWNlaG9sZGVyO1xyXG4gICAgfVxyXG4gICAgcmVhZFJhbmdlKHN0YXJ0LCBlbmQpIHtcclxuICAgICAgICBpZiAoIXN0YXJ0KVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICBsZXQgcGFyZW50ID0gc3RhcnQucGFyZW50Tm9kZTtcclxuICAgICAgICBmb3IgKGxldCBjdXIgPSBzdGFydDs7KSB7XHJcbiAgICAgICAgICAgIHRoaXMuZmluZFBvaW50QmVmb3JlKHBhcmVudCwgY3VyKTtcclxuICAgICAgICAgICAgdGhpcy5yZWFkTm9kZShjdXIpO1xyXG4gICAgICAgICAgICBsZXQgbmV4dCA9IGN1ci5uZXh0U2libGluZztcclxuICAgICAgICAgICAgaWYgKG5leHQgPT0gZW5kKVxyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGxldCB2aWV3ID0gQ29udGVudFZpZXcuZ2V0KGN1ciksIG5leHRWaWV3ID0gQ29udGVudFZpZXcuZ2V0KG5leHQpO1xyXG4gICAgICAgICAgICBpZiAodmlldyAmJiBuZXh0VmlldyA/IHZpZXcuYnJlYWtBZnRlciA6XHJcbiAgICAgICAgICAgICAgICAodmlldyA/IHZpZXcuYnJlYWtBZnRlciA6IGlzQmxvY2tFbGVtZW50KGN1cikpIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgKGlzQmxvY2tFbGVtZW50KG5leHQpICYmIChjdXIubm9kZU5hbWUgIT0gXCJCUlwiIHx8IGN1ci5jbUlnbm9yZSkpKVxyXG4gICAgICAgICAgICAgICAgdGhpcy5saW5lQnJlYWsoKTtcclxuICAgICAgICAgICAgY3VyID0gbmV4dDtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5maW5kUG9pbnRCZWZvcmUocGFyZW50LCBlbmQpO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG4gICAgcmVhZFRleHROb2RlKG5vZGUpIHtcclxuICAgICAgICBsZXQgdGV4dCA9IG5vZGUubm9kZVZhbHVlO1xyXG4gICAgICAgIGZvciAobGV0IHBvaW50IG9mIHRoaXMucG9pbnRzKVxyXG4gICAgICAgICAgICBpZiAocG9pbnQubm9kZSA9PSBub2RlKVxyXG4gICAgICAgICAgICAgICAgcG9pbnQucG9zID0gdGhpcy50ZXh0Lmxlbmd0aCArIE1hdGgubWluKHBvaW50Lm9mZnNldCwgdGV4dC5sZW5ndGgpO1xyXG4gICAgICAgIGZvciAobGV0IG9mZiA9IDAsIHJlID0gdGhpcy5saW5lU2VwYXJhdG9yID8gbnVsbCA6IC9cXHJcXG4/fFxcbi9nOzspIHtcclxuICAgICAgICAgICAgbGV0IG5leHRCcmVhayA9IC0xLCBicmVha1NpemUgPSAxLCBtO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5saW5lU2VwYXJhdG9yKSB7XHJcbiAgICAgICAgICAgICAgICBuZXh0QnJlYWsgPSB0ZXh0LmluZGV4T2YodGhpcy5saW5lU2VwYXJhdG9yLCBvZmYpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWtTaXplID0gdGhpcy5saW5lU2VwYXJhdG9yLmxlbmd0aDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChtID0gcmUuZXhlYyh0ZXh0KSkge1xyXG4gICAgICAgICAgICAgICAgbmV4dEJyZWFrID0gbS5pbmRleDtcclxuICAgICAgICAgICAgICAgIGJyZWFrU2l6ZSA9IG1bMF0ubGVuZ3RoO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuYXBwZW5kKHRleHQuc2xpY2Uob2ZmLCBuZXh0QnJlYWsgPCAwID8gdGV4dC5sZW5ndGggOiBuZXh0QnJlYWspKTtcclxuICAgICAgICAgICAgaWYgKG5leHRCcmVhayA8IDApXHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgdGhpcy5saW5lQnJlYWsoKTtcclxuICAgICAgICAgICAgaWYgKGJyZWFrU2l6ZSA+IDEpXHJcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBwb2ludCBvZiB0aGlzLnBvaW50cylcclxuICAgICAgICAgICAgICAgICAgICBpZiAocG9pbnQubm9kZSA9PSBub2RlICYmIHBvaW50LnBvcyA+IHRoaXMudGV4dC5sZW5ndGgpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50LnBvcyAtPSBicmVha1NpemUgLSAxO1xyXG4gICAgICAgICAgICBvZmYgPSBuZXh0QnJlYWsgKyBicmVha1NpemU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmVhZE5vZGUobm9kZSkge1xyXG4gICAgICAgIGlmIChub2RlLmNtSWdub3JlKVxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgbGV0IHZpZXcgPSBDb250ZW50Vmlldy5nZXQobm9kZSk7XHJcbiAgICAgICAgbGV0IGZyb21WaWV3ID0gdmlldyAmJiB2aWV3Lm92ZXJyaWRlRE9NVGV4dDtcclxuICAgICAgICBpZiAoZnJvbVZpZXcgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICB0aGlzLmZpbmRQb2ludEluc2lkZShub2RlLCBmcm9tVmlldy5sZW5ndGgpO1xyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gZnJvbVZpZXcuaXRlcigpOyAhaS5uZXh0KCkuZG9uZTspIHtcclxuICAgICAgICAgICAgICAgIGlmIChpLmxpbmVCcmVhaylcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmxpbmVCcmVhaygpO1xyXG4gICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYXBwZW5kKGkudmFsdWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKG5vZGUubm9kZVR5cGUgPT0gMykge1xyXG4gICAgICAgICAgICB0aGlzLnJlYWRUZXh0Tm9kZShub2RlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAobm9kZS5ub2RlTmFtZSA9PSBcIkJSXCIpIHtcclxuICAgICAgICAgICAgaWYgKG5vZGUubmV4dFNpYmxpbmcpXHJcbiAgICAgICAgICAgICAgICB0aGlzLmxpbmVCcmVhaygpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChub2RlLm5vZGVUeXBlID09IDEpIHtcclxuICAgICAgICAgICAgdGhpcy5yZWFkUmFuZ2Uobm9kZS5maXJzdENoaWxkLCBudWxsKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBmaW5kUG9pbnRCZWZvcmUobm9kZSwgbmV4dCkge1xyXG4gICAgICAgIGZvciAobGV0IHBvaW50IG9mIHRoaXMucG9pbnRzKVxyXG4gICAgICAgICAgICBpZiAocG9pbnQubm9kZSA9PSBub2RlICYmIG5vZGUuY2hpbGROb2Rlc1twb2ludC5vZmZzZXRdID09IG5leHQpXHJcbiAgICAgICAgICAgICAgICBwb2ludC5wb3MgPSB0aGlzLnRleHQubGVuZ3RoO1xyXG4gICAgfVxyXG4gICAgZmluZFBvaW50SW5zaWRlKG5vZGUsIG1heExlbikge1xyXG4gICAgICAgIGZvciAobGV0IHBvaW50IG9mIHRoaXMucG9pbnRzKVxyXG4gICAgICAgICAgICBpZiAobm9kZS5ub2RlVHlwZSA9PSAzID8gcG9pbnQubm9kZSA9PSBub2RlIDogbm9kZS5jb250YWlucyhwb2ludC5ub2RlKSlcclxuICAgICAgICAgICAgICAgIHBvaW50LnBvcyA9IHRoaXMudGV4dC5sZW5ndGggKyBNYXRoLm1pbihtYXhMZW4sIHBvaW50Lm9mZnNldCk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gaXNCbG9ja0VsZW1lbnQobm9kZSkge1xyXG4gICAgcmV0dXJuIG5vZGUubm9kZVR5cGUgPT0gMSAmJiAvXihESVZ8UHxMSXxVTHxPTHxCTE9DS1FVT1RFfEREfERUfEhcXGR8U0VDVElPTnxQUkUpJC8udGVzdChub2RlLm5vZGVOYW1lKTtcclxufVxyXG5jbGFzcyBET01Qb2ludCB7XHJcbiAgICBjb25zdHJ1Y3Rvcihub2RlLCBvZmZzZXQpIHtcclxuICAgICAgICB0aGlzLm5vZGUgPSBub2RlO1xyXG4gICAgICAgIHRoaXMub2Zmc2V0ID0gb2Zmc2V0O1xyXG4gICAgICAgIHRoaXMucG9zID0gLTE7XHJcbiAgICB9XHJcbn1cclxuXHJcbmNsYXNzIERvY1ZpZXcgZXh0ZW5kcyBDb250ZW50VmlldyB7XHJcbiAgICBjb25zdHJ1Y3Rvcih2aWV3KSB7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuICAgICAgICB0aGlzLnZpZXcgPSB2aWV3O1xyXG4gICAgICAgIHRoaXMuY29tcG9zaXRpb25EZWNvID0gRGVjb3JhdGlvbi5ub25lO1xyXG4gICAgICAgIHRoaXMuZGVjb3JhdGlvbnMgPSBbXTtcclxuICAgICAgICB0aGlzLmR5bmFtaWNEZWNvcmF0aW9uTWFwID0gW107XHJcbiAgICAgICAgLy8gVHJhY2sgYSBtaW5pbXVtIHdpZHRoIGZvciB0aGUgZWRpdG9yLiBXaGVuIG1lYXN1cmluZyBzaXplcyBpblxyXG4gICAgICAgIC8vIG1lYXN1cmVWaXNpYmxlTGluZUhlaWdodHMsIHRoaXMgaXMgdXBkYXRlZCB0byBwb2ludCBhdCB0aGUgd2lkdGhcclxuICAgICAgICAvLyBvZiBhIGdpdmVuIGVsZW1lbnQgYW5kIGl0cyBleHRlbnQgaW4gdGhlIGRvY3VtZW50LiBXaGVuIGEgY2hhbmdlXHJcbiAgICAgICAgLy8gaGFwcGVucyBpbiB0aGF0IHJhbmdlLCB0aGVzZSBhcmUgcmVzZXQuIFRoYXQgd2F5LCBvbmNlIHdlJ3ZlIHNlZW5cclxuICAgICAgICAvLyBhIGxpbmUvZWxlbWVudCBvZiBhIGdpdmVuIGxlbmd0aCwgd2Uga2VlcCB0aGUgZWRpdG9yIHdpZGUgZW5vdWdoXHJcbiAgICAgICAgLy8gdG8gZml0IGF0IGxlYXN0IHRoYXQgZWxlbWVudCwgdW50aWwgaXQgaXMgY2hhbmdlZCwgYXQgd2hpY2ggcG9pbnRcclxuICAgICAgICAvLyB3ZSBmb3JnZXQgaXQgYWdhaW4uXHJcbiAgICAgICAgdGhpcy5taW5XaWR0aCA9IDA7XHJcbiAgICAgICAgdGhpcy5taW5XaWR0aEZyb20gPSAwO1xyXG4gICAgICAgIHRoaXMubWluV2lkdGhUbyA9IDA7XHJcbiAgICAgICAgLy8gVHJhY2sgd2hldGhlciB0aGUgRE9NIHNlbGVjdGlvbiB3YXMgc2V0IGluIGEgbG9zc3kgd2F5LCBzbyB0aGF0XHJcbiAgICAgICAgLy8gd2UgZG9uJ3QgbWVzcyBpdCB1cCB3aGVuIHJlYWRpbmcgaXQgYmFjayBpdFxyXG4gICAgICAgIHRoaXMuaW1wcmVjaXNlQW5jaG9yID0gbnVsbDtcclxuICAgICAgICB0aGlzLmltcHJlY2lzZUhlYWQgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuZm9yY2VTZWxlY3Rpb24gPSBmYWxzZTtcclxuICAgICAgICAvLyBVc2VkIGJ5IHRoZSByZXNpemUgb2JzZXJ2ZXIgdG8gaWdub3JlIHJlc2l6ZXMgdGhhdCB3ZSBjYXVzZWRcclxuICAgICAgICAvLyBvdXJzZWx2ZXNcclxuICAgICAgICB0aGlzLmxhc3RVcGRhdGUgPSBEYXRlLm5vdygpO1xyXG4gICAgICAgIHRoaXMuc2V0RE9NKHZpZXcuY29udGVudERPTSk7XHJcbiAgICAgICAgdGhpcy5jaGlsZHJlbiA9IFtuZXcgTGluZVZpZXddO1xyXG4gICAgICAgIHRoaXMuY2hpbGRyZW5bMF0uc2V0UGFyZW50KHRoaXMpO1xyXG4gICAgICAgIHRoaXMudXBkYXRlRGVjbygpO1xyXG4gICAgICAgIHRoaXMudXBkYXRlSW5uZXIoW25ldyBDaGFuZ2VkUmFuZ2UoMCwgMCwgMCwgdmlldy5zdGF0ZS5kb2MubGVuZ3RoKV0sIDApO1xyXG4gICAgfVxyXG4gICAgZ2V0IGVkaXRvclZpZXcoKSB7IHJldHVybiB0aGlzLnZpZXc7IH1cclxuICAgIGdldCBsZW5ndGgoKSB7IHJldHVybiB0aGlzLnZpZXcuc3RhdGUuZG9jLmxlbmd0aDsgfVxyXG4gICAgLy8gVXBkYXRlIHRoZSBkb2N1bWVudCB2aWV3IHRvIGEgZ2l2ZW4gc3RhdGUuIHNjcm9sbEludG9WaWV3IGNhbiBiZVxyXG4gICAgLy8gdXNlZCBhcyBhIGhpbnQgdG8gY29tcHV0ZSBhIG5ldyB2aWV3cG9ydCB0aGF0IGluY2x1ZGVzIHRoYXRcclxuICAgIC8vIHBvc2l0aW9uLCBpZiB3ZSBrbm93IHRoZSBlZGl0b3IgaXMgZ29pbmcgdG8gc2Nyb2xsIHRoYXQgcG9zaXRpb25cclxuICAgIC8vIGludG8gdmlldy5cclxuICAgIHVwZGF0ZSh1cGRhdGUpIHtcclxuICAgICAgICBsZXQgY2hhbmdlZFJhbmdlcyA9IHVwZGF0ZS5jaGFuZ2VkUmFuZ2VzO1xyXG4gICAgICAgIGlmICh0aGlzLm1pbldpZHRoID4gMCAmJiBjaGFuZ2VkUmFuZ2VzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICBpZiAoIWNoYW5nZWRSYW5nZXMuZXZlcnkoKHsgZnJvbUEsIHRvQSB9KSA9PiB0b0EgPCB0aGlzLm1pbldpZHRoRnJvbSB8fCBmcm9tQSA+IHRoaXMubWluV2lkdGhUbykpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMubWluV2lkdGggPSB0aGlzLm1pbldpZHRoRnJvbSA9IHRoaXMubWluV2lkdGhUbyA9IDA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm1pbldpZHRoRnJvbSA9IHVwZGF0ZS5jaGFuZ2VzLm1hcFBvcyh0aGlzLm1pbldpZHRoRnJvbSwgMSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm1pbldpZHRoVG8gPSB1cGRhdGUuY2hhbmdlcy5tYXBQb3ModGhpcy5taW5XaWR0aFRvLCAxKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy52aWV3LmlucHV0U3RhdGUuY29tcG9zaW5nIDwgMClcclxuICAgICAgICAgICAgdGhpcy5jb21wb3NpdGlvbkRlY28gPSBEZWNvcmF0aW9uLm5vbmU7XHJcbiAgICAgICAgZWxzZSBpZiAodXBkYXRlLnRyYW5zYWN0aW9ucy5sZW5ndGggfHwgdGhpcy5kaXJ0eSlcclxuICAgICAgICAgICAgdGhpcy5jb21wb3NpdGlvbkRlY28gPSBjb21wdXRlQ29tcG9zaXRpb25EZWNvKHRoaXMudmlldywgdXBkYXRlLmNoYW5nZXMpO1xyXG4gICAgICAgIC8vIFdoZW4gdGhlIERPTSBub2RlcyBhcm91bmQgdGhlIHNlbGVjdGlvbiBhcmUgbW92ZWQgdG8gYW5vdGhlclxyXG4gICAgICAgIC8vIHBhcmVudCwgQ2hyb21lIHNvbWV0aW1lcyByZXBvcnRzIGEgZGlmZmVyZW50IHNlbGVjdGlvbiB0aHJvdWdoXHJcbiAgICAgICAgLy8gZ2V0U2VsZWN0aW9uIHRoYW4gdGhlIG9uZSB0aGF0IGl0IGFjdHVhbGx5IHNob3dzIHRvIHRoZSB1c2VyLlxyXG4gICAgICAgIC8vIFRoaXMgZm9yY2VzIGEgc2VsZWN0aW9uIHVwZGF0ZSB3aGVuIGxpbmVzIGFyZSBqb2luZWQgdG8gd29ya1xyXG4gICAgICAgIC8vIGFyb3VuZCB0aGF0LiBJc3N1ZSAjNTRcclxuICAgICAgICBpZiAoKGJyb3dzZXIuaWUgfHwgYnJvd3Nlci5jaHJvbWUpICYmICF0aGlzLmNvbXBvc2l0aW9uRGVjby5zaXplICYmIHVwZGF0ZSAmJlxyXG4gICAgICAgICAgICB1cGRhdGUuc3RhdGUuZG9jLmxpbmVzICE9IHVwZGF0ZS5zdGFydFN0YXRlLmRvYy5saW5lcylcclxuICAgICAgICAgICAgdGhpcy5mb3JjZVNlbGVjdGlvbiA9IHRydWU7XHJcbiAgICAgICAgbGV0IHByZXZEZWNvID0gdGhpcy5kZWNvcmF0aW9ucywgZGVjbyA9IHRoaXMudXBkYXRlRGVjbygpO1xyXG4gICAgICAgIGxldCBkZWNvRGlmZiA9IGZpbmRDaGFuZ2VkRGVjbyhwcmV2RGVjbywgZGVjbywgdXBkYXRlLmNoYW5nZXMpO1xyXG4gICAgICAgIGNoYW5nZWRSYW5nZXMgPSBDaGFuZ2VkUmFuZ2UuZXh0ZW5kV2l0aFJhbmdlcyhjaGFuZ2VkUmFuZ2VzLCBkZWNvRGlmZik7XHJcbiAgICAgICAgaWYgKHRoaXMuZGlydHkgPT0gMCAvKiBEaXJ0eS5Ob3QgKi8gJiYgY2hhbmdlZFJhbmdlcy5sZW5ndGggPT0gMCkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUlubmVyKGNoYW5nZWRSYW5nZXMsIHVwZGF0ZS5zdGFydFN0YXRlLmRvYy5sZW5ndGgpO1xyXG4gICAgICAgICAgICBpZiAodXBkYXRlLnRyYW5zYWN0aW9ucy5sZW5ndGgpXHJcbiAgICAgICAgICAgICAgICB0aGlzLmxhc3RVcGRhdGUgPSBEYXRlLm5vdygpO1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvLyBVc2VkIGJ5IHVwZGF0ZSBhbmQgdGhlIGNvbnN0cnVjdG9yIGRvIHBlcmZvcm0gdGhlIGFjdHVhbCBET01cclxuICAgIC8vIHVwZGF0ZVxyXG4gICAgdXBkYXRlSW5uZXIoY2hhbmdlcywgb2xkTGVuZ3RoKSB7XHJcbiAgICAgICAgdGhpcy52aWV3LnZpZXdTdGF0ZS5tdXN0TWVhc3VyZUNvbnRlbnQgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMudXBkYXRlQ2hpbGRyZW4oY2hhbmdlcywgb2xkTGVuZ3RoKTtcclxuICAgICAgICBsZXQgeyBvYnNlcnZlciB9ID0gdGhpcy52aWV3O1xyXG4gICAgICAgIG9ic2VydmVyLmlnbm9yZSgoKSA9PiB7XHJcbiAgICAgICAgICAgIC8vIExvY2sgdGhlIGhlaWdodCBkdXJpbmcgcmVkcmF3aW5nLCBzaW5jZSBDaHJvbWUgc29tZXRpbWVzXHJcbiAgICAgICAgICAgIC8vIG1lc3NlcyB3aXRoIHRoZSBzY3JvbGwgcG9zaXRpb24gZHVyaW5nIERPTSBtdXRhdGlvbiAodGhvdWdoXHJcbiAgICAgICAgICAgIC8vIG5vIHJlbGF5b3V0IGlzIHRyaWdnZXJlZCBhbmQgSSBjYW5ub3QgaW1hZ2luZSBob3cgaXQgY2FuXHJcbiAgICAgICAgICAgIC8vIHJlY29tcHV0ZSB0aGUgc2Nyb2xsIHBvc2l0aW9uIHdpdGhvdXQgYSBsYXlvdXQpXHJcbiAgICAgICAgICAgIHRoaXMuZG9tLnN0eWxlLmhlaWdodCA9IHRoaXMudmlldy52aWV3U3RhdGUuY29udGVudEhlaWdodCArIFwicHhcIjtcclxuICAgICAgICAgICAgdGhpcy5kb20uc3R5bGUuZmxleEJhc2lzID0gdGhpcy5taW5XaWR0aCA/IHRoaXMubWluV2lkdGggKyBcInB4XCIgOiBcIlwiO1xyXG4gICAgICAgICAgICAvLyBDaHJvbWUgd2lsbCBzb21ldGltZXMsIHdoZW4gRE9NIG11dGF0aW9ucyBvY2N1ciBkaXJlY3RseVxyXG4gICAgICAgICAgICAvLyBhcm91bmQgdGhlIHNlbGVjdGlvbiwgZ2V0IGNvbmZ1c2VkIGFuZCByZXBvcnQgYSBkaWZmZXJlbnRcclxuICAgICAgICAgICAgLy8gc2VsZWN0aW9uIGZyb20gdGhlIG9uZSBpdCBkaXNwbGF5cyAoaXNzdWUgIzIxOCkuIFRoaXMgdHJpZXNcclxuICAgICAgICAgICAgLy8gdG8gZGV0ZWN0IHRoYXQgc2l0dWF0aW9uLlxyXG4gICAgICAgICAgICBsZXQgdHJhY2sgPSBicm93c2VyLmNocm9tZSB8fCBicm93c2VyLmlvcyA/IHsgbm9kZTogb2JzZXJ2ZXIuc2VsZWN0aW9uUmFuZ2UuZm9jdXNOb2RlLCB3cml0dGVuOiBmYWxzZSB9IDogdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICB0aGlzLnN5bmModHJhY2spO1xyXG4gICAgICAgICAgICB0aGlzLmRpcnR5ID0gMCAvKiBEaXJ0eS5Ob3QgKi87XHJcbiAgICAgICAgICAgIGlmICh0cmFjayAmJiAodHJhY2sud3JpdHRlbiB8fCBvYnNlcnZlci5zZWxlY3Rpb25SYW5nZS5mb2N1c05vZGUgIT0gdHJhY2subm9kZSkpXHJcbiAgICAgICAgICAgICAgICB0aGlzLmZvcmNlU2VsZWN0aW9uID0gdHJ1ZTtcclxuICAgICAgICAgICAgdGhpcy5kb20uc3R5bGUuaGVpZ2h0ID0gXCJcIjtcclxuICAgICAgICB9KTtcclxuICAgICAgICBsZXQgZ2FwcyA9IFtdO1xyXG4gICAgICAgIGlmICh0aGlzLnZpZXcudmlld3BvcnQuZnJvbSB8fCB0aGlzLnZpZXcudmlld3BvcnQudG8gPCB0aGlzLnZpZXcuc3RhdGUuZG9jLmxlbmd0aClcclxuICAgICAgICAgICAgZm9yIChsZXQgY2hpbGQgb2YgdGhpcy5jaGlsZHJlbilcclxuICAgICAgICAgICAgICAgIGlmIChjaGlsZCBpbnN0YW5jZW9mIEJsb2NrV2lkZ2V0VmlldyAmJiBjaGlsZC53aWRnZXQgaW5zdGFuY2VvZiBCbG9ja0dhcFdpZGdldClcclxuICAgICAgICAgICAgICAgICAgICBnYXBzLnB1c2goY2hpbGQuZG9tKTtcclxuICAgICAgICBvYnNlcnZlci51cGRhdGVHYXBzKGdhcHMpO1xyXG4gICAgfVxyXG4gICAgdXBkYXRlQ2hpbGRyZW4oY2hhbmdlcywgb2xkTGVuZ3RoKSB7XHJcbiAgICAgICAgbGV0IGN1cnNvciA9IHRoaXMuY2hpbGRDdXJzb3Iob2xkTGVuZ3RoKTtcclxuICAgICAgICBmb3IgKGxldCBpID0gY2hhbmdlcy5sZW5ndGggLSAxOzsgaS0tKSB7XHJcbiAgICAgICAgICAgIGxldCBuZXh0ID0gaSA+PSAwID8gY2hhbmdlc1tpXSA6IG51bGw7XHJcbiAgICAgICAgICAgIGlmICghbmV4dClcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBsZXQgeyBmcm9tQSwgdG9BLCBmcm9tQiwgdG9CIH0gPSBuZXh0O1xyXG4gICAgICAgICAgICBsZXQgeyBjb250ZW50LCBicmVha0F0U3RhcnQsIG9wZW5TdGFydCwgb3BlbkVuZCB9ID0gQ29udGVudEJ1aWxkZXIuYnVpbGQodGhpcy52aWV3LnN0YXRlLmRvYywgZnJvbUIsIHRvQiwgdGhpcy5kZWNvcmF0aW9ucywgdGhpcy5keW5hbWljRGVjb3JhdGlvbk1hcCk7XHJcbiAgICAgICAgICAgIGxldCB7IGk6IHRvSSwgb2ZmOiB0b09mZiB9ID0gY3Vyc29yLmZpbmRQb3ModG9BLCAxKTtcclxuICAgICAgICAgICAgbGV0IHsgaTogZnJvbUksIG9mZjogZnJvbU9mZiB9ID0gY3Vyc29yLmZpbmRQb3MoZnJvbUEsIC0xKTtcclxuICAgICAgICAgICAgcmVwbGFjZVJhbmdlKHRoaXMsIGZyb21JLCBmcm9tT2ZmLCB0b0ksIHRvT2ZmLCBjb250ZW50LCBicmVha0F0U3RhcnQsIG9wZW5TdGFydCwgb3BlbkVuZCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLy8gU3luYyB0aGUgRE9NIHNlbGVjdGlvbiB0byB0aGlzLnN0YXRlLnNlbGVjdGlvblxyXG4gICAgdXBkYXRlU2VsZWN0aW9uKG11c3RSZWFkID0gZmFsc2UsIGZyb21Qb2ludGVyID0gZmFsc2UpIHtcclxuICAgICAgICBpZiAobXVzdFJlYWQgfHwgIXRoaXMudmlldy5vYnNlcnZlci5zZWxlY3Rpb25SYW5nZS5mb2N1c05vZGUpXHJcbiAgICAgICAgICAgIHRoaXMudmlldy5vYnNlcnZlci5yZWFkU2VsZWN0aW9uUmFuZ2UoKTtcclxuICAgICAgICBpZiAoIShmcm9tUG9pbnRlciB8fCB0aGlzLm1heUNvbnRyb2xTZWxlY3Rpb24oKSkpXHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICBsZXQgZm9yY2UgPSB0aGlzLmZvcmNlU2VsZWN0aW9uO1xyXG4gICAgICAgIHRoaXMuZm9yY2VTZWxlY3Rpb24gPSBmYWxzZTtcclxuICAgICAgICBsZXQgbWFpbiA9IHRoaXMudmlldy5zdGF0ZS5zZWxlY3Rpb24ubWFpbjtcclxuICAgICAgICAvLyBGSVhNRSBuZWVkIHRvIGhhbmRsZSB0aGUgY2FzZSB3aGVyZSB0aGUgc2VsZWN0aW9uIGZhbGxzIGluc2lkZSBhIGJsb2NrIHJhbmdlXHJcbiAgICAgICAgbGV0IGFuY2hvciA9IHRoaXMuZG9tQXRQb3MobWFpbi5hbmNob3IpO1xyXG4gICAgICAgIGxldCBoZWFkID0gbWFpbi5lbXB0eSA/IGFuY2hvciA6IHRoaXMuZG9tQXRQb3MobWFpbi5oZWFkKTtcclxuICAgICAgICAvLyBBbHdheXMgcmVzZXQgb24gRmlyZWZveCB3aGVuIG5leHQgdG8gYW4gdW5lZGl0YWJsZSBub2RlIHRvXHJcbiAgICAgICAgLy8gYXZvaWQgaW52aXNpYmxlIGN1cnNvciBidWdzICgjMTExKVxyXG4gICAgICAgIGlmIChicm93c2VyLmdlY2tvICYmIG1haW4uZW1wdHkgJiYgYmV0d2VlblVuZWRpdGFibGUoYW5jaG9yKSkge1xyXG4gICAgICAgICAgICBsZXQgZHVtbXkgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShcIlwiKTtcclxuICAgICAgICAgICAgdGhpcy52aWV3Lm9ic2VydmVyLmlnbm9yZSgoKSA9PiBhbmNob3Iubm9kZS5pbnNlcnRCZWZvcmUoZHVtbXksIGFuY2hvci5ub2RlLmNoaWxkTm9kZXNbYW5jaG9yLm9mZnNldF0gfHwgbnVsbCkpO1xyXG4gICAgICAgICAgICBhbmNob3IgPSBoZWFkID0gbmV3IERPTVBvcyhkdW1teSwgMCk7XHJcbiAgICAgICAgICAgIGZvcmNlID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IGRvbVNlbCA9IHRoaXMudmlldy5vYnNlcnZlci5zZWxlY3Rpb25SYW5nZTtcclxuICAgICAgICAvLyBJZiB0aGUgc2VsZWN0aW9uIGlzIGFscmVhZHkgaGVyZSwgb3IgaW4gYW4gZXF1aXZhbGVudCBwb3NpdGlvbiwgZG9uJ3QgdG91Y2ggaXRcclxuICAgICAgICBpZiAoZm9yY2UgfHwgIWRvbVNlbC5mb2N1c05vZGUgfHxcclxuICAgICAgICAgICAgIWlzRXF1aXZhbGVudFBvc2l0aW9uKGFuY2hvci5ub2RlLCBhbmNob3Iub2Zmc2V0LCBkb21TZWwuYW5jaG9yTm9kZSwgZG9tU2VsLmFuY2hvck9mZnNldCkgfHxcclxuICAgICAgICAgICAgIWlzRXF1aXZhbGVudFBvc2l0aW9uKGhlYWQubm9kZSwgaGVhZC5vZmZzZXQsIGRvbVNlbC5mb2N1c05vZGUsIGRvbVNlbC5mb2N1c09mZnNldCkpIHtcclxuICAgICAgICAgICAgdGhpcy52aWV3Lm9ic2VydmVyLmlnbm9yZSgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAvLyBDaHJvbWUgQW5kcm9pZCB3aWxsIGhpZGUgdGhlIHZpcnR1YWwga2V5Ym9hcmQgd2hlbiB0YXBwaW5nXHJcbiAgICAgICAgICAgICAgICAvLyBpbnNpZGUgYW4gdW5lZGl0YWJsZSBub2RlLCBhbmQgbm90IGJyaW5nIGl0IGJhY2sgd2hlbiB3ZVxyXG4gICAgICAgICAgICAgICAgLy8gbW92ZSB0aGUgY3Vyc29yIHRvIGl0cyBwcm9wZXIgcG9zaXRpb24uIFRoaXMgdHJpZXMgdG9cclxuICAgICAgICAgICAgICAgIC8vIHJlc3RvcmUgdGhlIGtleWJvYXJkIGJ5IGN5Y2xpbmcgZm9jdXMuXHJcbiAgICAgICAgICAgICAgICBpZiAoYnJvd3Nlci5hbmRyb2lkICYmIGJyb3dzZXIuY2hyb21lICYmIHRoaXMuZG9tLmNvbnRhaW5zKGRvbVNlbC5mb2N1c05vZGUpICYmXHJcbiAgICAgICAgICAgICAgICAgICAgaW5VbmVkaXRhYmxlKGRvbVNlbC5mb2N1c05vZGUsIHRoaXMuZG9tKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZG9tLmJsdXIoKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRvbS5mb2N1cyh7IHByZXZlbnRTY3JvbGw6IHRydWUgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBsZXQgcmF3U2VsID0gZ2V0U2VsZWN0aW9uKHRoaXMudmlldy5yb290KTtcclxuICAgICAgICAgICAgICAgIGlmICghcmF3U2VsKSA7XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChtYWluLmVtcHR5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gV29yayBhcm91bmQgaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTYxMjA3NlxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChicm93c2VyLmdlY2tvKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBuZXh0VG8gPSBuZXh0VG9VbmVkaXRhYmxlKGFuY2hvci5ub2RlLCBhbmNob3Iub2Zmc2V0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5leHRUbyAmJiBuZXh0VG8gIT0gKDEgLyogTmV4dFRvLkJlZm9yZSAqLyB8IDIgLyogTmV4dFRvLkFmdGVyICovKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHRleHQgPSBuZWFyYnlUZXh0Tm9kZShhbmNob3Iubm9kZSwgYW5jaG9yLm9mZnNldCwgbmV4dFRvID09IDEgLyogTmV4dFRvLkJlZm9yZSAqLyA/IDEgOiAtMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGV4dClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbmNob3IgPSBuZXcgRE9NUG9zKHRleHQsIG5leHRUbyA9PSAxIC8qIE5leHRUby5CZWZvcmUgKi8gPyAwIDogdGV4dC5ub2RlVmFsdWUubGVuZ3RoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByYXdTZWwuY29sbGFwc2UoYW5jaG9yLm5vZGUsIGFuY2hvci5vZmZzZXQpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChtYWluLmJpZGlMZXZlbCAhPSBudWxsICYmIGRvbVNlbC5jdXJzb3JCaWRpTGV2ZWwgIT0gbnVsbClcclxuICAgICAgICAgICAgICAgICAgICAgICAgZG9tU2VsLmN1cnNvckJpZGlMZXZlbCA9IG1haW4uYmlkaUxldmVsO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAocmF3U2VsLmV4dGVuZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFNlbGVjdGlvbi5leHRlbmQgY2FuIGJlIHVzZWQgdG8gY3JlYXRlIGFuICdpbnZlcnRlZCcgc2VsZWN0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gKG9uZSB3aGVyZSB0aGUgZm9jdXMgaXMgYmVmb3JlIHRoZSBhbmNob3IpLCBidXQgbm90IGFsbFxyXG4gICAgICAgICAgICAgICAgICAgIC8vIGJyb3dzZXJzIHN1cHBvcnQgaXQgeWV0LlxyXG4gICAgICAgICAgICAgICAgICAgIHJhd1NlbC5jb2xsYXBzZShhbmNob3Iubm9kZSwgYW5jaG9yLm9mZnNldCk7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gU2FmYXJpIHdpbGwgaWdub3JlIHRoZSBjYWxsIGFib3ZlIHdoZW4gdGhlIGVkaXRvciBpc1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGhpZGRlbiwgYW5kIHRoZW4gcmFpc2UgYW4gZXJyb3Igb24gdGhlIGNhbGwgdG8gZXh0ZW5kXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gKCM5NDApLlxyXG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJhd1NlbC5leHRlbmQoaGVhZC5ub2RlLCBoZWFkLm9mZnNldCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGNhdGNoIChfKSB7IH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFByaW1pdGl2ZSAoSUUpIHdheVxyXG4gICAgICAgICAgICAgICAgICAgIGxldCByYW5nZSA9IGRvY3VtZW50LmNyZWF0ZVJhbmdlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1haW4uYW5jaG9yID4gbWFpbi5oZWFkKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBbYW5jaG9yLCBoZWFkXSA9IFtoZWFkLCBhbmNob3JdO1xyXG4gICAgICAgICAgICAgICAgICAgIHJhbmdlLnNldEVuZChoZWFkLm5vZGUsIGhlYWQub2Zmc2V0KTtcclxuICAgICAgICAgICAgICAgICAgICByYW5nZS5zZXRTdGFydChhbmNob3Iubm9kZSwgYW5jaG9yLm9mZnNldCk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmF3U2VsLnJlbW92ZUFsbFJhbmdlcygpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJhd1NlbC5hZGRSYW5nZShyYW5nZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB0aGlzLnZpZXcub2JzZXJ2ZXIuc2V0U2VsZWN0aW9uUmFuZ2UoYW5jaG9yLCBoZWFkKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5pbXByZWNpc2VBbmNob3IgPSBhbmNob3IucHJlY2lzZSA/IG51bGwgOiBuZXcgRE9NUG9zKGRvbVNlbC5hbmNob3JOb2RlLCBkb21TZWwuYW5jaG9yT2Zmc2V0KTtcclxuICAgICAgICB0aGlzLmltcHJlY2lzZUhlYWQgPSBoZWFkLnByZWNpc2UgPyBudWxsIDogbmV3IERPTVBvcyhkb21TZWwuZm9jdXNOb2RlLCBkb21TZWwuZm9jdXNPZmZzZXQpO1xyXG4gICAgfVxyXG4gICAgZW5mb3JjZUN1cnNvckFzc29jKCkge1xyXG4gICAgICAgIGlmICh0aGlzLmNvbXBvc2l0aW9uRGVjby5zaXplKVxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgbGV0IHsgdmlldyB9ID0gdGhpcywgY3Vyc29yID0gdmlldy5zdGF0ZS5zZWxlY3Rpb24ubWFpbjtcclxuICAgICAgICBsZXQgc2VsID0gZ2V0U2VsZWN0aW9uKHZpZXcucm9vdCk7XHJcbiAgICAgICAgbGV0IHsgYW5jaG9yTm9kZSwgYW5jaG9yT2Zmc2V0IH0gPSB2aWV3Lm9ic2VydmVyLnNlbGVjdGlvblJhbmdlO1xyXG4gICAgICAgIGlmICghc2VsIHx8ICFjdXJzb3IuZW1wdHkgfHwgIWN1cnNvci5hc3NvYyB8fCAhc2VsLm1vZGlmeSlcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIGxldCBsaW5lID0gTGluZVZpZXcuZmluZCh0aGlzLCBjdXJzb3IuaGVhZCk7XHJcbiAgICAgICAgaWYgKCFsaW5lKVxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgbGV0IGxpbmVTdGFydCA9IGxpbmUucG9zQXRTdGFydDtcclxuICAgICAgICBpZiAoY3Vyc29yLmhlYWQgPT0gbGluZVN0YXJ0IHx8IGN1cnNvci5oZWFkID09IGxpbmVTdGFydCArIGxpbmUubGVuZ3RoKVxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgbGV0IGJlZm9yZSA9IHRoaXMuY29vcmRzQXQoY3Vyc29yLmhlYWQsIC0xKSwgYWZ0ZXIgPSB0aGlzLmNvb3Jkc0F0KGN1cnNvci5oZWFkLCAxKTtcclxuICAgICAgICBpZiAoIWJlZm9yZSB8fCAhYWZ0ZXIgfHwgYmVmb3JlLmJvdHRvbSA+IGFmdGVyLnRvcClcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIGxldCBkb20gPSB0aGlzLmRvbUF0UG9zKGN1cnNvci5oZWFkICsgY3Vyc29yLmFzc29jKTtcclxuICAgICAgICBzZWwuY29sbGFwc2UoZG9tLm5vZGUsIGRvbS5vZmZzZXQpO1xyXG4gICAgICAgIHNlbC5tb2RpZnkoXCJtb3ZlXCIsIGN1cnNvci5hc3NvYyA8IDAgPyBcImZvcndhcmRcIiA6IFwiYmFja3dhcmRcIiwgXCJsaW5lYm91bmRhcnlcIik7XHJcbiAgICAgICAgLy8gVGhpcyBjYW4gZ28gd3JvbmcgaW4gY29ybmVyIGNhc2VzIGxpa2Ugc2luZ2xlLWNoYXJhY3RlciBsaW5lcyxcclxuICAgICAgICAvLyBzbyBjaGVjayBhbmQgcmVzZXQgaWYgbmVjZXNzYXJ5LlxyXG4gICAgICAgIHZpZXcub2JzZXJ2ZXIucmVhZFNlbGVjdGlvblJhbmdlKCk7XHJcbiAgICAgICAgbGV0IG5ld1JhbmdlID0gdmlldy5vYnNlcnZlci5zZWxlY3Rpb25SYW5nZTtcclxuICAgICAgICBpZiAodmlldy5kb2NWaWV3LnBvc0Zyb21ET00obmV3UmFuZ2UuYW5jaG9yTm9kZSwgbmV3UmFuZ2UuYW5jaG9yT2Zmc2V0KSAhPSBjdXJzb3IuZnJvbSlcclxuICAgICAgICAgICAgc2VsLmNvbGxhcHNlKGFuY2hvck5vZGUsIGFuY2hvck9mZnNldCk7XHJcbiAgICB9XHJcbiAgICBtYXlDb250cm9sU2VsZWN0aW9uKCkge1xyXG4gICAgICAgIGxldCBhY3RpdmUgPSB0aGlzLnZpZXcucm9vdC5hY3RpdmVFbGVtZW50O1xyXG4gICAgICAgIHJldHVybiBhY3RpdmUgPT0gdGhpcy5kb20gfHxcclxuICAgICAgICAgICAgaGFzU2VsZWN0aW9uKHRoaXMuZG9tLCB0aGlzLnZpZXcub2JzZXJ2ZXIuc2VsZWN0aW9uUmFuZ2UpICYmICEoYWN0aXZlICYmIHRoaXMuZG9tLmNvbnRhaW5zKGFjdGl2ZSkpO1xyXG4gICAgfVxyXG4gICAgbmVhcmVzdChkb20pIHtcclxuICAgICAgICBmb3IgKGxldCBjdXIgPSBkb207IGN1cjspIHtcclxuICAgICAgICAgICAgbGV0IGRvbVZpZXcgPSBDb250ZW50Vmlldy5nZXQoY3VyKTtcclxuICAgICAgICAgICAgaWYgKGRvbVZpZXcgJiYgZG9tVmlldy5yb290VmlldyA9PSB0aGlzKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGRvbVZpZXc7XHJcbiAgICAgICAgICAgIGN1ciA9IGN1ci5wYXJlbnROb2RlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuICAgIHBvc0Zyb21ET00obm9kZSwgb2Zmc2V0KSB7XHJcbiAgICAgICAgbGV0IHZpZXcgPSB0aGlzLm5lYXJlc3Qobm9kZSk7XHJcbiAgICAgICAgaWYgKCF2aWV3KVxyXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIlRyeWluZyB0byBmaW5kIHBvc2l0aW9uIGZvciBhIERPTSBwb3NpdGlvbiBvdXRzaWRlIG9mIHRoZSBkb2N1bWVudFwiKTtcclxuICAgICAgICByZXR1cm4gdmlldy5sb2NhbFBvc0Zyb21ET00obm9kZSwgb2Zmc2V0KSArIHZpZXcucG9zQXRTdGFydDtcclxuICAgIH1cclxuICAgIGRvbUF0UG9zKHBvcykge1xyXG4gICAgICAgIGxldCB7IGksIG9mZiB9ID0gdGhpcy5jaGlsZEN1cnNvcigpLmZpbmRQb3MocG9zLCAtMSk7XHJcbiAgICAgICAgZm9yICg7IGkgPCB0aGlzLmNoaWxkcmVuLmxlbmd0aCAtIDE7KSB7XHJcbiAgICAgICAgICAgIGxldCBjaGlsZCA9IHRoaXMuY2hpbGRyZW5baV07XHJcbiAgICAgICAgICAgIGlmIChvZmYgPCBjaGlsZC5sZW5ndGggfHwgY2hpbGQgaW5zdGFuY2VvZiBMaW5lVmlldylcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBpKys7XHJcbiAgICAgICAgICAgIG9mZiA9IDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLmNoaWxkcmVuW2ldLmRvbUF0UG9zKG9mZik7XHJcbiAgICB9XHJcbiAgICBjb29yZHNBdChwb3MsIHNpZGUpIHtcclxuICAgICAgICBmb3IgKGxldCBvZmYgPSB0aGlzLmxlbmd0aCwgaSA9IHRoaXMuY2hpbGRyZW4ubGVuZ3RoIC0gMTs7IGktLSkge1xyXG4gICAgICAgICAgICBsZXQgY2hpbGQgPSB0aGlzLmNoaWxkcmVuW2ldLCBzdGFydCA9IG9mZiAtIGNoaWxkLmJyZWFrQWZ0ZXIgLSBjaGlsZC5sZW5ndGg7XHJcbiAgICAgICAgICAgIGlmIChwb3MgPiBzdGFydCB8fFxyXG4gICAgICAgICAgICAgICAgKHBvcyA9PSBzdGFydCAmJiBjaGlsZC50eXBlICE9IEJsb2NrVHlwZS5XaWRnZXRCZWZvcmUgJiYgY2hpbGQudHlwZSAhPSBCbG9ja1R5cGUuV2lkZ2V0QWZ0ZXIgJiZcclxuICAgICAgICAgICAgICAgICAgICAoIWkgfHwgc2lkZSA9PSAyIHx8IHRoaXMuY2hpbGRyZW5baSAtIDFdLmJyZWFrQWZ0ZXIgfHxcclxuICAgICAgICAgICAgICAgICAgICAgICAgKHRoaXMuY2hpbGRyZW5baSAtIDFdLnR5cGUgPT0gQmxvY2tUeXBlLldpZGdldEJlZm9yZSAmJiBzaWRlID4gLTIpKSkpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY2hpbGQuY29vcmRzQXQocG9zIC0gc3RhcnQsIHNpZGUpO1xyXG4gICAgICAgICAgICBvZmYgPSBzdGFydDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBtZWFzdXJlVmlzaWJsZUxpbmVIZWlnaHRzKHZpZXdwb3J0KSB7XHJcbiAgICAgICAgbGV0IHJlc3VsdCA9IFtdLCB7IGZyb20sIHRvIH0gPSB2aWV3cG9ydDtcclxuICAgICAgICBsZXQgY29udGVudFdpZHRoID0gdGhpcy52aWV3LmNvbnRlbnRET00uY2xpZW50V2lkdGg7XHJcbiAgICAgICAgbGV0IGlzV2lkZXIgPSBjb250ZW50V2lkdGggPiBNYXRoLm1heCh0aGlzLnZpZXcuc2Nyb2xsRE9NLmNsaWVudFdpZHRoLCB0aGlzLm1pbldpZHRoKSArIDE7XHJcbiAgICAgICAgbGV0IHdpZGVzdCA9IC0xLCBsdHIgPSB0aGlzLnZpZXcudGV4dERpcmVjdGlvbiA9PSBEaXJlY3Rpb24uTFRSO1xyXG4gICAgICAgIGZvciAobGV0IHBvcyA9IDAsIGkgPSAwOyBpIDwgdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBsZXQgY2hpbGQgPSB0aGlzLmNoaWxkcmVuW2ldLCBlbmQgPSBwb3MgKyBjaGlsZC5sZW5ndGg7XHJcbiAgICAgICAgICAgIGlmIChlbmQgPiB0bylcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBpZiAocG9zID49IGZyb20pIHtcclxuICAgICAgICAgICAgICAgIGxldCBjaGlsZFJlY3QgPSBjaGlsZC5kb20uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChjaGlsZFJlY3QuaGVpZ2h0KTtcclxuICAgICAgICAgICAgICAgIGlmIChpc1dpZGVyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IGxhc3QgPSBjaGlsZC5kb20ubGFzdENoaWxkO1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCByZWN0cyA9IGxhc3QgPyBjbGllbnRSZWN0c0ZvcihsYXN0KSA6IFtdO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChyZWN0cy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHJlY3QgPSByZWN0c1tyZWN0cy5sZW5ndGggLSAxXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHdpZHRoID0gbHRyID8gcmVjdC5yaWdodCAtIGNoaWxkUmVjdC5sZWZ0IDogY2hpbGRSZWN0LnJpZ2h0IC0gcmVjdC5sZWZ0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAod2lkdGggPiB3aWRlc3QpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpZGVzdCA9IHdpZHRoO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5taW5XaWR0aCA9IGNvbnRlbnRXaWR0aDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubWluV2lkdGhGcm9tID0gcG9zO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5taW5XaWR0aFRvID0gZW5kO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHBvcyA9IGVuZCArIGNoaWxkLmJyZWFrQWZ0ZXI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcbiAgICB0ZXh0RGlyZWN0aW9uQXQocG9zKSB7XHJcbiAgICAgICAgbGV0IHsgaSB9ID0gdGhpcy5jaGlsZFBvcyhwb3MsIDEpO1xyXG4gICAgICAgIHJldHVybiBnZXRDb21wdXRlZFN0eWxlKHRoaXMuY2hpbGRyZW5baV0uZG9tKS5kaXJlY3Rpb24gPT0gXCJydGxcIiA/IERpcmVjdGlvbi5SVEwgOiBEaXJlY3Rpb24uTFRSO1xyXG4gICAgfVxyXG4gICAgbWVhc3VyZVRleHRTaXplKCkge1xyXG4gICAgICAgIGZvciAobGV0IGNoaWxkIG9mIHRoaXMuY2hpbGRyZW4pIHtcclxuICAgICAgICAgICAgaWYgKGNoaWxkIGluc3RhbmNlb2YgTGluZVZpZXcpIHtcclxuICAgICAgICAgICAgICAgIGxldCBtZWFzdXJlID0gY2hpbGQubWVhc3VyZVRleHRTaXplKCk7XHJcbiAgICAgICAgICAgICAgICBpZiAobWVhc3VyZSlcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbWVhc3VyZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBJZiBubyB3b3JrYWJsZSBsaW5lIGV4aXN0cywgZm9yY2UgYSBsYXlvdXQgb2YgYSBtZWFzdXJhYmxlIGVsZW1lbnRcclxuICAgICAgICBsZXQgZHVtbXkgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpLCBsaW5lSGVpZ2h0LCBjaGFyV2lkdGg7XHJcbiAgICAgICAgZHVtbXkuY2xhc3NOYW1lID0gXCJjbS1saW5lXCI7XHJcbiAgICAgICAgZHVtbXkuc3R5bGUud2lkdGggPSBcIjk5OTk5cHhcIjtcclxuICAgICAgICBkdW1teS50ZXh0Q29udGVudCA9IFwiYWJjIGRlZiBnaGkgamtsIG1ubyBwcXIgc3R1XCI7XHJcbiAgICAgICAgdGhpcy52aWV3Lm9ic2VydmVyLmlnbm9yZSgoKSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMuZG9tLmFwcGVuZENoaWxkKGR1bW15KTtcclxuICAgICAgICAgICAgbGV0IHJlY3QgPSBjbGllbnRSZWN0c0ZvcihkdW1teS5maXJzdENoaWxkKVswXTtcclxuICAgICAgICAgICAgbGluZUhlaWdodCA9IGR1bW15LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmhlaWdodDtcclxuICAgICAgICAgICAgY2hhcldpZHRoID0gcmVjdCA/IHJlY3Qud2lkdGggLyAyNyA6IDc7XHJcbiAgICAgICAgICAgIGR1bW15LnJlbW92ZSgpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiB7IGxpbmVIZWlnaHQsIGNoYXJXaWR0aCB9O1xyXG4gICAgfVxyXG4gICAgY2hpbGRDdXJzb3IocG9zID0gdGhpcy5sZW5ndGgpIHtcclxuICAgICAgICAvLyBNb3ZlIGJhY2sgdG8gc3RhcnQgb2YgbGFzdCBlbGVtZW50IHdoZW4gcG9zc2libGUsIHNvIHRoYXRcclxuICAgICAgICAvLyBgQ2hpbGRDdXJzb3IuZmluZFBvc2AgZG9lc24ndCBoYXZlIHRvIGRlYWwgd2l0aCB0aGUgZWRnZSBjYXNlXHJcbiAgICAgICAgLy8gb2YgYmVpbmcgYWZ0ZXIgdGhlIGxhc3QgZWxlbWVudC5cclxuICAgICAgICBsZXQgaSA9IHRoaXMuY2hpbGRyZW4ubGVuZ3RoO1xyXG4gICAgICAgIGlmIChpKVxyXG4gICAgICAgICAgICBwb3MgLT0gdGhpcy5jaGlsZHJlblstLWldLmxlbmd0aDtcclxuICAgICAgICByZXR1cm4gbmV3IENoaWxkQ3Vyc29yKHRoaXMuY2hpbGRyZW4sIHBvcywgaSk7XHJcbiAgICB9XHJcbiAgICBjb21wdXRlQmxvY2tHYXBEZWNvKCkge1xyXG4gICAgICAgIGxldCBkZWNvID0gW10sIHZzID0gdGhpcy52aWV3LnZpZXdTdGF0ZTtcclxuICAgICAgICBmb3IgKGxldCBwb3MgPSAwLCBpID0gMDs7IGkrKykge1xyXG4gICAgICAgICAgICBsZXQgbmV4dCA9IGkgPT0gdnMudmlld3BvcnRzLmxlbmd0aCA/IG51bGwgOiB2cy52aWV3cG9ydHNbaV07XHJcbiAgICAgICAgICAgIGxldCBlbmQgPSBuZXh0ID8gbmV4dC5mcm9tIC0gMSA6IHRoaXMubGVuZ3RoO1xyXG4gICAgICAgICAgICBpZiAoZW5kID4gcG9zKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgaGVpZ2h0ID0gdnMubGluZUJsb2NrQXQoZW5kKS5ib3R0b20gLSB2cy5saW5lQmxvY2tBdChwb3MpLnRvcDtcclxuICAgICAgICAgICAgICAgIGRlY28ucHVzaChEZWNvcmF0aW9uLnJlcGxhY2Uoe1xyXG4gICAgICAgICAgICAgICAgICAgIHdpZGdldDogbmV3IEJsb2NrR2FwV2lkZ2V0KGhlaWdodCksXHJcbiAgICAgICAgICAgICAgICAgICAgYmxvY2s6IHRydWUsXHJcbiAgICAgICAgICAgICAgICAgICAgaW5jbHVzaXZlOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgICAgIGlzQmxvY2tHYXA6IHRydWUsXHJcbiAgICAgICAgICAgICAgICB9KS5yYW5nZShwb3MsIGVuZCkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICghbmV4dClcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBwb3MgPSBuZXh0LnRvICsgMTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIERlY29yYXRpb24uc2V0KGRlY28pO1xyXG4gICAgfVxyXG4gICAgdXBkYXRlRGVjbygpIHtcclxuICAgICAgICBsZXQgYWxsRGVjbyA9IHRoaXMudmlldy5zdGF0ZS5mYWNldChkZWNvcmF0aW9ucykubWFwKChkLCBpKSA9PiB7XHJcbiAgICAgICAgICAgIGxldCBkeW5hbWljID0gdGhpcy5keW5hbWljRGVjb3JhdGlvbk1hcFtpXSA9IHR5cGVvZiBkID09IFwiZnVuY3Rpb25cIjtcclxuICAgICAgICAgICAgcmV0dXJuIGR5bmFtaWMgPyBkKHRoaXMudmlldykgOiBkO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSBhbGxEZWNvLmxlbmd0aDsgaSA8IGFsbERlY28ubGVuZ3RoICsgMzsgaSsrKVxyXG4gICAgICAgICAgICB0aGlzLmR5bmFtaWNEZWNvcmF0aW9uTWFwW2ldID0gZmFsc2U7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVjb3JhdGlvbnMgPSBbXHJcbiAgICAgICAgICAgIC4uLmFsbERlY28sXHJcbiAgICAgICAgICAgIHRoaXMuY29tcG9zaXRpb25EZWNvLFxyXG4gICAgICAgICAgICB0aGlzLmNvbXB1dGVCbG9ja0dhcERlY28oKSxcclxuICAgICAgICAgICAgdGhpcy52aWV3LnZpZXdTdGF0ZS5saW5lR2FwRGVjb1xyXG4gICAgICAgIF07XHJcbiAgICB9XHJcbiAgICBzY3JvbGxJbnRvVmlldyh0YXJnZXQpIHtcclxuICAgICAgICBsZXQgeyByYW5nZSB9ID0gdGFyZ2V0O1xyXG4gICAgICAgIGxldCByZWN0ID0gdGhpcy5jb29yZHNBdChyYW5nZS5oZWFkLCByYW5nZS5lbXB0eSA/IHJhbmdlLmFzc29jIDogcmFuZ2UuaGVhZCA+IHJhbmdlLmFuY2hvciA/IC0xIDogMSksIG90aGVyO1xyXG4gICAgICAgIGlmICghcmVjdClcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIGlmICghcmFuZ2UuZW1wdHkgJiYgKG90aGVyID0gdGhpcy5jb29yZHNBdChyYW5nZS5hbmNob3IsIHJhbmdlLmFuY2hvciA+IHJhbmdlLmhlYWQgPyAtMSA6IDEpKSlcclxuICAgICAgICAgICAgcmVjdCA9IHsgbGVmdDogTWF0aC5taW4ocmVjdC5sZWZ0LCBvdGhlci5sZWZ0KSwgdG9wOiBNYXRoLm1pbihyZWN0LnRvcCwgb3RoZXIudG9wKSxcclxuICAgICAgICAgICAgICAgIHJpZ2h0OiBNYXRoLm1heChyZWN0LnJpZ2h0LCBvdGhlci5yaWdodCksIGJvdHRvbTogTWF0aC5tYXgocmVjdC5ib3R0b20sIG90aGVyLmJvdHRvbSkgfTtcclxuICAgICAgICBsZXQgbUxlZnQgPSAwLCBtUmlnaHQgPSAwLCBtVG9wID0gMCwgbUJvdHRvbSA9IDA7XHJcbiAgICAgICAgZm9yIChsZXQgbWFyZ2lucyBvZiB0aGlzLnZpZXcuc3RhdGUuZmFjZXQoc2Nyb2xsTWFyZ2lucykubWFwKGYgPT4gZih0aGlzLnZpZXcpKSlcclxuICAgICAgICAgICAgaWYgKG1hcmdpbnMpIHtcclxuICAgICAgICAgICAgICAgIGxldCB7IGxlZnQsIHJpZ2h0LCB0b3AsIGJvdHRvbSB9ID0gbWFyZ2lucztcclxuICAgICAgICAgICAgICAgIGlmIChsZWZ0ICE9IG51bGwpXHJcbiAgICAgICAgICAgICAgICAgICAgbUxlZnQgPSBNYXRoLm1heChtTGVmdCwgbGVmdCk7XHJcbiAgICAgICAgICAgICAgICBpZiAocmlnaHQgIT0gbnVsbClcclxuICAgICAgICAgICAgICAgICAgICBtUmlnaHQgPSBNYXRoLm1heChtUmlnaHQsIHJpZ2h0KTtcclxuICAgICAgICAgICAgICAgIGlmICh0b3AgIT0gbnVsbClcclxuICAgICAgICAgICAgICAgICAgICBtVG9wID0gTWF0aC5tYXgobVRvcCwgdG9wKTtcclxuICAgICAgICAgICAgICAgIGlmIChib3R0b20gIT0gbnVsbClcclxuICAgICAgICAgICAgICAgICAgICBtQm90dG9tID0gTWF0aC5tYXgobUJvdHRvbSwgYm90dG9tKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIGxldCB0YXJnZXRSZWN0ID0ge1xyXG4gICAgICAgICAgICBsZWZ0OiByZWN0LmxlZnQgLSBtTGVmdCwgdG9wOiByZWN0LnRvcCAtIG1Ub3AsXHJcbiAgICAgICAgICAgIHJpZ2h0OiByZWN0LnJpZ2h0ICsgbVJpZ2h0LCBib3R0b206IHJlY3QuYm90dG9tICsgbUJvdHRvbVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgc2Nyb2xsUmVjdEludG9WaWV3KHRoaXMudmlldy5zY3JvbGxET00sIHRhcmdldFJlY3QsIHJhbmdlLmhlYWQgPCByYW5nZS5hbmNob3IgPyAtMSA6IDEsIHRhcmdldC54LCB0YXJnZXQueSwgdGFyZ2V0LnhNYXJnaW4sIHRhcmdldC55TWFyZ2luLCB0aGlzLnZpZXcudGV4dERpcmVjdGlvbiA9PSBEaXJlY3Rpb24uTFRSKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBiZXR3ZWVuVW5lZGl0YWJsZShwb3MpIHtcclxuICAgIHJldHVybiBwb3Mubm9kZS5ub2RlVHlwZSA9PSAxICYmIHBvcy5ub2RlLmZpcnN0Q2hpbGQgJiZcclxuICAgICAgICAocG9zLm9mZnNldCA9PSAwIHx8IHBvcy5ub2RlLmNoaWxkTm9kZXNbcG9zLm9mZnNldCAtIDFdLmNvbnRlbnRFZGl0YWJsZSA9PSBcImZhbHNlXCIpICYmXHJcbiAgICAgICAgKHBvcy5vZmZzZXQgPT0gcG9zLm5vZGUuY2hpbGROb2Rlcy5sZW5ndGggfHwgcG9zLm5vZGUuY2hpbGROb2Rlc1twb3Mub2Zmc2V0XS5jb250ZW50RWRpdGFibGUgPT0gXCJmYWxzZVwiKTtcclxufVxyXG5jbGFzcyBCbG9ja0dhcFdpZGdldCBleHRlbmRzIFdpZGdldFR5cGUge1xyXG4gICAgY29uc3RydWN0b3IoaGVpZ2h0KSB7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuICAgICAgICB0aGlzLmhlaWdodCA9IGhlaWdodDtcclxuICAgIH1cclxuICAgIHRvRE9NKCkge1xyXG4gICAgICAgIGxldCBlbHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xyXG4gICAgICAgIHRoaXMudXBkYXRlRE9NKGVsdCk7XHJcbiAgICAgICAgcmV0dXJuIGVsdDtcclxuICAgIH1cclxuICAgIGVxKG90aGVyKSB7IHJldHVybiBvdGhlci5oZWlnaHQgPT0gdGhpcy5oZWlnaHQ7IH1cclxuICAgIHVwZGF0ZURPTShlbHQpIHtcclxuICAgICAgICBlbHQuc3R5bGUuaGVpZ2h0ID0gdGhpcy5oZWlnaHQgKyBcInB4XCI7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgICBnZXQgZXN0aW1hdGVkSGVpZ2h0KCkgeyByZXR1cm4gdGhpcy5oZWlnaHQ7IH1cclxufVxyXG5mdW5jdGlvbiBjb21wb3NpdGlvblN1cnJvdW5kaW5nTm9kZSh2aWV3KSB7XHJcbiAgICBsZXQgc2VsID0gdmlldy5vYnNlcnZlci5zZWxlY3Rpb25SYW5nZTtcclxuICAgIGxldCB0ZXh0Tm9kZSA9IHNlbC5mb2N1c05vZGUgJiYgbmVhcmJ5VGV4dE5vZGUoc2VsLmZvY3VzTm9kZSwgc2VsLmZvY3VzT2Zmc2V0LCAwKTtcclxuICAgIGlmICghdGV4dE5vZGUpXHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICBsZXQgY1ZpZXcgPSB2aWV3LmRvY1ZpZXcubmVhcmVzdCh0ZXh0Tm9kZSk7XHJcbiAgICBpZiAoIWNWaWV3KVxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgaWYgKGNWaWV3IGluc3RhbmNlb2YgTGluZVZpZXcpIHtcclxuICAgICAgICBsZXQgdG9wTm9kZSA9IHRleHROb2RlO1xyXG4gICAgICAgIHdoaWxlICh0b3BOb2RlLnBhcmVudE5vZGUgIT0gY1ZpZXcuZG9tKVxyXG4gICAgICAgICAgICB0b3BOb2RlID0gdG9wTm9kZS5wYXJlbnROb2RlO1xyXG4gICAgICAgIGxldCBwcmV2ID0gdG9wTm9kZS5wcmV2aW91c1NpYmxpbmc7XHJcbiAgICAgICAgd2hpbGUgKHByZXYgJiYgIUNvbnRlbnRWaWV3LmdldChwcmV2KSlcclxuICAgICAgICAgICAgcHJldiA9IHByZXYucHJldmlvdXNTaWJsaW5nO1xyXG4gICAgICAgIGxldCBwb3MgPSBwcmV2ID8gQ29udGVudFZpZXcuZ2V0KHByZXYpLnBvc0F0RW5kIDogY1ZpZXcucG9zQXRTdGFydDtcclxuICAgICAgICByZXR1cm4geyBmcm9tOiBwb3MsIHRvOiBwb3MsIG5vZGU6IHRvcE5vZGUsIHRleHQ6IHRleHROb2RlIH07XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBmb3IgKDs7KSB7XHJcbiAgICAgICAgICAgIGxldCB7IHBhcmVudCB9ID0gY1ZpZXc7XHJcbiAgICAgICAgICAgIGlmICghcGFyZW50KVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgIGlmIChwYXJlbnQgaW5zdGFuY2VvZiBMaW5lVmlldylcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjVmlldyA9IHBhcmVudDtcclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IGZyb20gPSBjVmlldy5wb3NBdFN0YXJ0O1xyXG4gICAgICAgIHJldHVybiB7IGZyb20sIHRvOiBmcm9tICsgY1ZpZXcubGVuZ3RoLCBub2RlOiBjVmlldy5kb20sIHRleHQ6IHRleHROb2RlIH07XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gY29tcHV0ZUNvbXBvc2l0aW9uRGVjbyh2aWV3LCBjaGFuZ2VzKSB7XHJcbiAgICBsZXQgc3Vycm91bmRpbmcgPSBjb21wb3NpdGlvblN1cnJvdW5kaW5nTm9kZSh2aWV3KTtcclxuICAgIGlmICghc3Vycm91bmRpbmcpXHJcbiAgICAgICAgcmV0dXJuIERlY29yYXRpb24ubm9uZTtcclxuICAgIGxldCB7IGZyb20sIHRvLCBub2RlLCB0ZXh0OiB0ZXh0Tm9kZSB9ID0gc3Vycm91bmRpbmc7XHJcbiAgICBsZXQgbmV3RnJvbSA9IGNoYW5nZXMubWFwUG9zKGZyb20sIDEpLCBuZXdUbyA9IE1hdGgubWF4KG5ld0Zyb20sIGNoYW5nZXMubWFwUG9zKHRvLCAtMSkpO1xyXG4gICAgbGV0IHsgc3RhdGUgfSA9IHZpZXcsIHRleHQgPSBub2RlLm5vZGVUeXBlID09IDMgPyBub2RlLm5vZGVWYWx1ZSA6XHJcbiAgICAgICAgbmV3IERPTVJlYWRlcihbXSwgc3RhdGUpLnJlYWRSYW5nZShub2RlLmZpcnN0Q2hpbGQsIG51bGwpLnRleHQ7XHJcbiAgICBpZiAobmV3VG8gLSBuZXdGcm9tIDwgdGV4dC5sZW5ndGgpIHtcclxuICAgICAgICBpZiAoc3RhdGUuZG9jLnNsaWNlU3RyaW5nKG5ld0Zyb20sIE1hdGgubWluKHN0YXRlLmRvYy5sZW5ndGgsIG5ld0Zyb20gKyB0ZXh0Lmxlbmd0aCksIExpbmVCcmVha1BsYWNlaG9sZGVyKSA9PSB0ZXh0KVxyXG4gICAgICAgICAgICBuZXdUbyA9IG5ld0Zyb20gKyB0ZXh0Lmxlbmd0aDtcclxuICAgICAgICBlbHNlIGlmIChzdGF0ZS5kb2Muc2xpY2VTdHJpbmcoTWF0aC5tYXgoMCwgbmV3VG8gLSB0ZXh0Lmxlbmd0aCksIG5ld1RvLCBMaW5lQnJlYWtQbGFjZWhvbGRlcikgPT0gdGV4dClcclxuICAgICAgICAgICAgbmV3RnJvbSA9IG5ld1RvIC0gdGV4dC5sZW5ndGg7XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICByZXR1cm4gRGVjb3JhdGlvbi5ub25lO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoc3RhdGUuZG9jLnNsaWNlU3RyaW5nKG5ld0Zyb20sIG5ld1RvLCBMaW5lQnJlYWtQbGFjZWhvbGRlcikgIT0gdGV4dCkge1xyXG4gICAgICAgIHJldHVybiBEZWNvcmF0aW9uLm5vbmU7XHJcbiAgICB9XHJcbiAgICBsZXQgdG9wVmlldyA9IENvbnRlbnRWaWV3LmdldChub2RlKTtcclxuICAgIGlmICh0b3BWaWV3IGluc3RhbmNlb2YgQ29tcG9zaXRpb25WaWV3KVxyXG4gICAgICAgIHRvcFZpZXcgPSB0b3BWaWV3LndpZGdldC50b3BWaWV3O1xyXG4gICAgZWxzZSBpZiAodG9wVmlldylcclxuICAgICAgICB0b3BWaWV3LnBhcmVudCA9IG51bGw7XHJcbiAgICByZXR1cm4gRGVjb3JhdGlvbi5zZXQoRGVjb3JhdGlvbi5yZXBsYWNlKHsgd2lkZ2V0OiBuZXcgQ29tcG9zaXRpb25XaWRnZXQobm9kZSwgdGV4dE5vZGUsIHRvcFZpZXcpLCBpbmNsdXNpdmU6IHRydWUgfSlcclxuICAgICAgICAucmFuZ2UobmV3RnJvbSwgbmV3VG8pKTtcclxufVxyXG5jbGFzcyBDb21wb3NpdGlvbldpZGdldCBleHRlbmRzIFdpZGdldFR5cGUge1xyXG4gICAgY29uc3RydWN0b3IodG9wLCB0ZXh0LCB0b3BWaWV3KSB7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuICAgICAgICB0aGlzLnRvcCA9IHRvcDtcclxuICAgICAgICB0aGlzLnRleHQgPSB0ZXh0O1xyXG4gICAgICAgIHRoaXMudG9wVmlldyA9IHRvcFZpZXc7XHJcbiAgICB9XHJcbiAgICBlcShvdGhlcikgeyByZXR1cm4gdGhpcy50b3AgPT0gb3RoZXIudG9wICYmIHRoaXMudGV4dCA9PSBvdGhlci50ZXh0OyB9XHJcbiAgICB0b0RPTSgpIHsgcmV0dXJuIHRoaXMudG9wOyB9XHJcbiAgICBpZ25vcmVFdmVudCgpIHsgcmV0dXJuIGZhbHNlOyB9XHJcbiAgICBnZXQgY3VzdG9tVmlldygpIHsgcmV0dXJuIENvbXBvc2l0aW9uVmlldzsgfVxyXG59XHJcbmZ1bmN0aW9uIG5lYXJieVRleHROb2RlKG5vZGUsIG9mZnNldCwgc2lkZSkge1xyXG4gICAgZm9yICg7Oykge1xyXG4gICAgICAgIGlmIChub2RlLm5vZGVUeXBlID09IDMpXHJcbiAgICAgICAgICAgIHJldHVybiBub2RlO1xyXG4gICAgICAgIGlmIChub2RlLm5vZGVUeXBlID09IDEgJiYgb2Zmc2V0ID4gMCAmJiBzaWRlIDw9IDApIHtcclxuICAgICAgICAgICAgbm9kZSA9IG5vZGUuY2hpbGROb2Rlc1tvZmZzZXQgLSAxXTtcclxuICAgICAgICAgICAgb2Zmc2V0ID0gbWF4T2Zmc2V0KG5vZGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChub2RlLm5vZGVUeXBlID09IDEgJiYgb2Zmc2V0IDwgbm9kZS5jaGlsZE5vZGVzLmxlbmd0aCAmJiBzaWRlID49IDApIHtcclxuICAgICAgICAgICAgbm9kZSA9IG5vZGUuY2hpbGROb2Rlc1tvZmZzZXRdO1xyXG4gICAgICAgICAgICBvZmZzZXQgPSAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIG5leHRUb1VuZWRpdGFibGUobm9kZSwgb2Zmc2V0KSB7XHJcbiAgICBpZiAobm9kZS5ub2RlVHlwZSAhPSAxKVxyXG4gICAgICAgIHJldHVybiAwO1xyXG4gICAgcmV0dXJuIChvZmZzZXQgJiYgbm9kZS5jaGlsZE5vZGVzW29mZnNldCAtIDFdLmNvbnRlbnRFZGl0YWJsZSA9PSBcImZhbHNlXCIgPyAxIC8qIE5leHRUby5CZWZvcmUgKi8gOiAwKSB8XHJcbiAgICAgICAgKG9mZnNldCA8IG5vZGUuY2hpbGROb2Rlcy5sZW5ndGggJiYgbm9kZS5jaGlsZE5vZGVzW29mZnNldF0uY29udGVudEVkaXRhYmxlID09IFwiZmFsc2VcIiA/IDIgLyogTmV4dFRvLkFmdGVyICovIDogMCk7XHJcbn1cclxuY2xhc3MgRGVjb3JhdGlvbkNvbXBhcmF0b3IkMSB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICB0aGlzLmNoYW5nZXMgPSBbXTtcclxuICAgIH1cclxuICAgIGNvbXBhcmVSYW5nZShmcm9tLCB0bykgeyBhZGRSYW5nZShmcm9tLCB0bywgdGhpcy5jaGFuZ2VzKTsgfVxyXG4gICAgY29tcGFyZVBvaW50KGZyb20sIHRvKSB7IGFkZFJhbmdlKGZyb20sIHRvLCB0aGlzLmNoYW5nZXMpOyB9XHJcbn1cclxuZnVuY3Rpb24gZmluZENoYW5nZWREZWNvKGEsIGIsIGRpZmYpIHtcclxuICAgIGxldCBjb21wID0gbmV3IERlY29yYXRpb25Db21wYXJhdG9yJDE7XHJcbiAgICBSYW5nZVNldC5jb21wYXJlKGEsIGIsIGRpZmYsIGNvbXApO1xyXG4gICAgcmV0dXJuIGNvbXAuY2hhbmdlcztcclxufVxyXG5mdW5jdGlvbiBpblVuZWRpdGFibGUobm9kZSwgaW5zaWRlKSB7XHJcbiAgICBmb3IgKGxldCBjdXIgPSBub2RlOyBjdXIgJiYgY3VyICE9IGluc2lkZTsgY3VyID0gY3VyLmFzc2lnbmVkU2xvdCB8fCBjdXIucGFyZW50Tm9kZSkge1xyXG4gICAgICAgIGlmIChjdXIubm9kZVR5cGUgPT0gMSAmJiBjdXIuY29udGVudEVkaXRhYmxlID09ICdmYWxzZScpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG59XHJcblxyXG5mdW5jdGlvbiBncm91cEF0KHN0YXRlLCBwb3MsIGJpYXMgPSAxKSB7XHJcbiAgICBsZXQgY2F0ZWdvcml6ZSA9IHN0YXRlLmNoYXJDYXRlZ29yaXplcihwb3MpO1xyXG4gICAgbGV0IGxpbmUgPSBzdGF0ZS5kb2MubGluZUF0KHBvcyksIGxpbmVQb3MgPSBwb3MgLSBsaW5lLmZyb207XHJcbiAgICBpZiAobGluZS5sZW5ndGggPT0gMClcclxuICAgICAgICByZXR1cm4gRWRpdG9yU2VsZWN0aW9uLmN1cnNvcihwb3MpO1xyXG4gICAgaWYgKGxpbmVQb3MgPT0gMClcclxuICAgICAgICBiaWFzID0gMTtcclxuICAgIGVsc2UgaWYgKGxpbmVQb3MgPT0gbGluZS5sZW5ndGgpXHJcbiAgICAgICAgYmlhcyA9IC0xO1xyXG4gICAgbGV0IGZyb20gPSBsaW5lUG9zLCB0byA9IGxpbmVQb3M7XHJcbiAgICBpZiAoYmlhcyA8IDApXHJcbiAgICAgICAgZnJvbSA9IGZpbmRDbHVzdGVyQnJlYWsobGluZS50ZXh0LCBsaW5lUG9zLCBmYWxzZSk7XHJcbiAgICBlbHNlXHJcbiAgICAgICAgdG8gPSBmaW5kQ2x1c3RlckJyZWFrKGxpbmUudGV4dCwgbGluZVBvcyk7XHJcbiAgICBsZXQgY2F0ID0gY2F0ZWdvcml6ZShsaW5lLnRleHQuc2xpY2UoZnJvbSwgdG8pKTtcclxuICAgIHdoaWxlIChmcm9tID4gMCkge1xyXG4gICAgICAgIGxldCBwcmV2ID0gZmluZENsdXN0ZXJCcmVhayhsaW5lLnRleHQsIGZyb20sIGZhbHNlKTtcclxuICAgICAgICBpZiAoY2F0ZWdvcml6ZShsaW5lLnRleHQuc2xpY2UocHJldiwgZnJvbSkpICE9IGNhdClcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgZnJvbSA9IHByZXY7XHJcbiAgICB9XHJcbiAgICB3aGlsZSAodG8gPCBsaW5lLmxlbmd0aCkge1xyXG4gICAgICAgIGxldCBuZXh0ID0gZmluZENsdXN0ZXJCcmVhayhsaW5lLnRleHQsIHRvKTtcclxuICAgICAgICBpZiAoY2F0ZWdvcml6ZShsaW5lLnRleHQuc2xpY2UodG8sIG5leHQpKSAhPSBjYXQpXHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIHRvID0gbmV4dDtcclxuICAgIH1cclxuICAgIHJldHVybiBFZGl0b3JTZWxlY3Rpb24ucmFuZ2UoZnJvbSArIGxpbmUuZnJvbSwgdG8gKyBsaW5lLmZyb20pO1xyXG59XHJcbi8vIFNlYXJjaCB0aGUgRE9NIGZvciB0aGUge25vZGUsIG9mZnNldH0gcG9zaXRpb24gY2xvc2VzdCB0byB0aGUgZ2l2ZW5cclxuLy8gY29vcmRpbmF0ZXMuIFZlcnkgaW5lZmZpY2llbnQgYW5kIGNydWRlLCBidXQgY2FuIHVzdWFsbHkgYmUgYXZvaWRlZFxyXG4vLyBieSBjYWxsaW5nIGNhcmV0KFBvc2l0aW9ufFJhbmdlKUZyb21Qb2ludCBpbnN0ZWFkLlxyXG5mdW5jdGlvbiBnZXRkeCh4LCByZWN0KSB7XHJcbiAgICByZXR1cm4gcmVjdC5sZWZ0ID4geCA/IHJlY3QubGVmdCAtIHggOiBNYXRoLm1heCgwLCB4IC0gcmVjdC5yaWdodCk7XHJcbn1cclxuZnVuY3Rpb24gZ2V0ZHkoeSwgcmVjdCkge1xyXG4gICAgcmV0dXJuIHJlY3QudG9wID4geSA/IHJlY3QudG9wIC0geSA6IE1hdGgubWF4KDAsIHkgLSByZWN0LmJvdHRvbSk7XHJcbn1cclxuZnVuY3Rpb24geU92ZXJsYXAoYSwgYikge1xyXG4gICAgcmV0dXJuIGEudG9wIDwgYi5ib3R0b20gLSAxICYmIGEuYm90dG9tID4gYi50b3AgKyAxO1xyXG59XHJcbmZ1bmN0aW9uIHVwVG9wKHJlY3QsIHRvcCkge1xyXG4gICAgcmV0dXJuIHRvcCA8IHJlY3QudG9wID8geyB0b3AsIGxlZnQ6IHJlY3QubGVmdCwgcmlnaHQ6IHJlY3QucmlnaHQsIGJvdHRvbTogcmVjdC5ib3R0b20gfSA6IHJlY3Q7XHJcbn1cclxuZnVuY3Rpb24gdXBCb3QocmVjdCwgYm90dG9tKSB7XHJcbiAgICByZXR1cm4gYm90dG9tID4gcmVjdC5ib3R0b20gPyB7IHRvcDogcmVjdC50b3AsIGxlZnQ6IHJlY3QubGVmdCwgcmlnaHQ6IHJlY3QucmlnaHQsIGJvdHRvbSB9IDogcmVjdDtcclxufVxyXG5mdW5jdGlvbiBkb21Qb3NBdENvb3JkcyhwYXJlbnQsIHgsIHkpIHtcclxuICAgIGxldCBjbG9zZXN0LCBjbG9zZXN0UmVjdCwgY2xvc2VzdFgsIGNsb3Nlc3RZLCBjbG9zZXN0T3ZlcmxhcCA9IGZhbHNlO1xyXG4gICAgbGV0IGFib3ZlLCBiZWxvdywgYWJvdmVSZWN0LCBiZWxvd1JlY3Q7XHJcbiAgICBmb3IgKGxldCBjaGlsZCA9IHBhcmVudC5maXJzdENoaWxkOyBjaGlsZDsgY2hpbGQgPSBjaGlsZC5uZXh0U2libGluZykge1xyXG4gICAgICAgIGxldCByZWN0cyA9IGNsaWVudFJlY3RzRm9yKGNoaWxkKTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJlY3RzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGxldCByZWN0ID0gcmVjdHNbaV07XHJcbiAgICAgICAgICAgIGlmIChjbG9zZXN0UmVjdCAmJiB5T3ZlcmxhcChjbG9zZXN0UmVjdCwgcmVjdCkpXHJcbiAgICAgICAgICAgICAgICByZWN0ID0gdXBUb3AodXBCb3QocmVjdCwgY2xvc2VzdFJlY3QuYm90dG9tKSwgY2xvc2VzdFJlY3QudG9wKTtcclxuICAgICAgICAgICAgbGV0IGR4ID0gZ2V0ZHgoeCwgcmVjdCksIGR5ID0gZ2V0ZHkoeSwgcmVjdCk7XHJcbiAgICAgICAgICAgIGlmIChkeCA9PSAwICYmIGR5ID09IDApXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY2hpbGQubm9kZVR5cGUgPT0gMyA/IGRvbVBvc0luVGV4dChjaGlsZCwgeCwgeSkgOiBkb21Qb3NBdENvb3JkcyhjaGlsZCwgeCwgeSk7XHJcbiAgICAgICAgICAgIGlmICghY2xvc2VzdCB8fCBjbG9zZXN0WSA+IGR5IHx8IGNsb3Nlc3RZID09IGR5ICYmIGNsb3Nlc3RYID4gZHgpIHtcclxuICAgICAgICAgICAgICAgIGNsb3Nlc3QgPSBjaGlsZDtcclxuICAgICAgICAgICAgICAgIGNsb3Nlc3RSZWN0ID0gcmVjdDtcclxuICAgICAgICAgICAgICAgIGNsb3Nlc3RYID0gZHg7XHJcbiAgICAgICAgICAgICAgICBjbG9zZXN0WSA9IGR5O1xyXG4gICAgICAgICAgICAgICAgY2xvc2VzdE92ZXJsYXAgPSAhZHggfHwgKGR4ID4gMCA/IGkgPCByZWN0cy5sZW5ndGggLSAxIDogaSA+IDApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChkeCA9PSAwKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoeSA+IHJlY3QuYm90dG9tICYmICghYWJvdmVSZWN0IHx8IGFib3ZlUmVjdC5ib3R0b20gPCByZWN0LmJvdHRvbSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBhYm92ZSA9IGNoaWxkO1xyXG4gICAgICAgICAgICAgICAgICAgIGFib3ZlUmVjdCA9IHJlY3Q7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmICh5IDwgcmVjdC50b3AgJiYgKCFiZWxvd1JlY3QgfHwgYmVsb3dSZWN0LnRvcCA+IHJlY3QudG9wKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGJlbG93ID0gY2hpbGQ7XHJcbiAgICAgICAgICAgICAgICAgICAgYmVsb3dSZWN0ID0gcmVjdDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChhYm92ZVJlY3QgJiYgeU92ZXJsYXAoYWJvdmVSZWN0LCByZWN0KSkge1xyXG4gICAgICAgICAgICAgICAgYWJvdmVSZWN0ID0gdXBCb3QoYWJvdmVSZWN0LCByZWN0LmJvdHRvbSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoYmVsb3dSZWN0ICYmIHlPdmVybGFwKGJlbG93UmVjdCwgcmVjdCkpIHtcclxuICAgICAgICAgICAgICAgIGJlbG93UmVjdCA9IHVwVG9wKGJlbG93UmVjdCwgcmVjdC50b3ApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKGFib3ZlUmVjdCAmJiBhYm92ZVJlY3QuYm90dG9tID49IHkpIHtcclxuICAgICAgICBjbG9zZXN0ID0gYWJvdmU7XHJcbiAgICAgICAgY2xvc2VzdFJlY3QgPSBhYm92ZVJlY3Q7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChiZWxvd1JlY3QgJiYgYmVsb3dSZWN0LnRvcCA8PSB5KSB7XHJcbiAgICAgICAgY2xvc2VzdCA9IGJlbG93O1xyXG4gICAgICAgIGNsb3Nlc3RSZWN0ID0gYmVsb3dSZWN0O1xyXG4gICAgfVxyXG4gICAgaWYgKCFjbG9zZXN0KVxyXG4gICAgICAgIHJldHVybiB7IG5vZGU6IHBhcmVudCwgb2Zmc2V0OiAwIH07XHJcbiAgICBsZXQgY2xpcFggPSBNYXRoLm1heChjbG9zZXN0UmVjdC5sZWZ0LCBNYXRoLm1pbihjbG9zZXN0UmVjdC5yaWdodCwgeCkpO1xyXG4gICAgaWYgKGNsb3Nlc3Qubm9kZVR5cGUgPT0gMylcclxuICAgICAgICByZXR1cm4gZG9tUG9zSW5UZXh0KGNsb3Nlc3QsIGNsaXBYLCB5KTtcclxuICAgIGlmIChjbG9zZXN0T3ZlcmxhcCAmJiBjbG9zZXN0LmNvbnRlbnRFZGl0YWJsZSAhPSBcImZhbHNlXCIpXHJcbiAgICAgICAgcmV0dXJuIGRvbVBvc0F0Q29vcmRzKGNsb3Nlc3QsIGNsaXBYLCB5KTtcclxuICAgIGxldCBvZmZzZXQgPSBBcnJheS5wcm90b3R5cGUuaW5kZXhPZi5jYWxsKHBhcmVudC5jaGlsZE5vZGVzLCBjbG9zZXN0KSArXHJcbiAgICAgICAgKHggPj0gKGNsb3Nlc3RSZWN0LmxlZnQgKyBjbG9zZXN0UmVjdC5yaWdodCkgLyAyID8gMSA6IDApO1xyXG4gICAgcmV0dXJuIHsgbm9kZTogcGFyZW50LCBvZmZzZXQgfTtcclxufVxyXG5mdW5jdGlvbiBkb21Qb3NJblRleHQobm9kZSwgeCwgeSkge1xyXG4gICAgbGV0IGxlbiA9IG5vZGUubm9kZVZhbHVlLmxlbmd0aDtcclxuICAgIGxldCBjbG9zZXN0T2Zmc2V0ID0gLTEsIGNsb3Nlc3REWSA9IDFlOSwgZ2VuZXJhbFNpZGUgPSAwO1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgIGxldCByZWN0cyA9IHRleHRSYW5nZShub2RlLCBpLCBpICsgMSkuZ2V0Q2xpZW50UmVjdHMoKTtcclxuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHJlY3RzLmxlbmd0aDsgaisrKSB7XHJcbiAgICAgICAgICAgIGxldCByZWN0ID0gcmVjdHNbal07XHJcbiAgICAgICAgICAgIGlmIChyZWN0LnRvcCA9PSByZWN0LmJvdHRvbSlcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICBpZiAoIWdlbmVyYWxTaWRlKVxyXG4gICAgICAgICAgICAgICAgZ2VuZXJhbFNpZGUgPSB4IC0gcmVjdC5sZWZ0O1xyXG4gICAgICAgICAgICBsZXQgZHkgPSAocmVjdC50b3AgPiB5ID8gcmVjdC50b3AgLSB5IDogeSAtIHJlY3QuYm90dG9tKSAtIDE7XHJcbiAgICAgICAgICAgIGlmIChyZWN0LmxlZnQgLSAxIDw9IHggJiYgcmVjdC5yaWdodCArIDEgPj0geCAmJiBkeSA8IGNsb3Nlc3REWSkge1xyXG4gICAgICAgICAgICAgICAgbGV0IHJpZ2h0ID0geCA+PSAocmVjdC5sZWZ0ICsgcmVjdC5yaWdodCkgLyAyLCBhZnRlciA9IHJpZ2h0O1xyXG4gICAgICAgICAgICAgICAgaWYgKGJyb3dzZXIuY2hyb21lIHx8IGJyb3dzZXIuZ2Vja28pIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBDaGVjayBmb3IgUlRMIG9uIGJyb3dzZXJzIHRoYXQgc3VwcG9ydCBnZXR0aW5nIGNsaWVudFxyXG4gICAgICAgICAgICAgICAgICAgIC8vIHJlY3RzIGZvciBlbXB0eSByYW5nZXMuXHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IHJlY3RCZWZvcmUgPSB0ZXh0UmFuZ2Uobm9kZSwgaSkuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlY3RCZWZvcmUubGVmdCA9PSByZWN0LnJpZ2h0KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBhZnRlciA9ICFyaWdodDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChkeSA8PSAwKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IG5vZGUsIG9mZnNldDogaSArIChhZnRlciA/IDEgOiAwKSB9O1xyXG4gICAgICAgICAgICAgICAgY2xvc2VzdE9mZnNldCA9IGkgKyAoYWZ0ZXIgPyAxIDogMCk7XHJcbiAgICAgICAgICAgICAgICBjbG9zZXN0RFkgPSBkeTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiB7IG5vZGUsIG9mZnNldDogY2xvc2VzdE9mZnNldCA+IC0xID8gY2xvc2VzdE9mZnNldCA6IGdlbmVyYWxTaWRlID4gMCA/IG5vZGUubm9kZVZhbHVlLmxlbmd0aCA6IDAgfTtcclxufVxyXG5mdW5jdGlvbiBwb3NBdENvb3Jkcyh2aWV3LCB7IHgsIHkgfSwgcHJlY2lzZSwgYmlhcyA9IC0xKSB7XHJcbiAgICB2YXIgX2E7XHJcbiAgICBsZXQgY29udGVudCA9IHZpZXcuY29udGVudERPTS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSwgZG9jVG9wID0gY29udGVudC50b3AgKyB2aWV3LnZpZXdTdGF0ZS5wYWRkaW5nVG9wO1xyXG4gICAgbGV0IGJsb2NrLCB7IGRvY0hlaWdodCB9ID0gdmlldy52aWV3U3RhdGU7XHJcbiAgICBsZXQgeU9mZnNldCA9IHkgLSBkb2NUb3A7XHJcbiAgICBpZiAoeU9mZnNldCA8IDApXHJcbiAgICAgICAgcmV0dXJuIDA7XHJcbiAgICBpZiAoeU9mZnNldCA+IGRvY0hlaWdodClcclxuICAgICAgICByZXR1cm4gdmlldy5zdGF0ZS5kb2MubGVuZ3RoO1xyXG4gICAgLy8gU2NhbiBmb3IgYSB0ZXh0IGJsb2NrIG5lYXIgdGhlIHF1ZXJpZWQgeSBwb3NpdGlvblxyXG4gICAgZm9yIChsZXQgaGFsZkxpbmUgPSB2aWV3LmRlZmF1bHRMaW5lSGVpZ2h0IC8gMiwgYm91bmNlZCA9IGZhbHNlOzspIHtcclxuICAgICAgICBibG9jayA9IHZpZXcuZWxlbWVudEF0SGVpZ2h0KHlPZmZzZXQpO1xyXG4gICAgICAgIGlmIChibG9jay50eXBlID09IEJsb2NrVHlwZS5UZXh0KVxyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICBmb3IgKDs7KSB7XHJcbiAgICAgICAgICAgIC8vIE1vdmUgdGhlIHkgcG9zaXRpb24gb3V0IG9mIHRoaXMgYmxvY2tcclxuICAgICAgICAgICAgeU9mZnNldCA9IGJpYXMgPiAwID8gYmxvY2suYm90dG9tICsgaGFsZkxpbmUgOiBibG9jay50b3AgLSBoYWxmTGluZTtcclxuICAgICAgICAgICAgaWYgKHlPZmZzZXQgPj0gMCAmJiB5T2Zmc2V0IDw9IGRvY0hlaWdodClcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAvLyBJZiB0aGUgZG9jdW1lbnQgY29uc2lzdHMgZW50aXJlbHkgb2YgcmVwbGFjZWQgd2lkZ2V0cywgd2VcclxuICAgICAgICAgICAgLy8gd29uJ3QgZmluZCBhIHRleHQgYmxvY2ssIHNvIHJldHVybiAwXHJcbiAgICAgICAgICAgIGlmIChib3VuY2VkKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHByZWNpc2UgPyBudWxsIDogMDtcclxuICAgICAgICAgICAgYm91bmNlZCA9IHRydWU7XHJcbiAgICAgICAgICAgIGJpYXMgPSAtYmlhcztcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICB5ID0gZG9jVG9wICsgeU9mZnNldDtcclxuICAgIGxldCBsaW5lU3RhcnQgPSBibG9jay5mcm9tO1xyXG4gICAgLy8gSWYgdGhpcyBpcyBvdXRzaWRlIG9mIHRoZSByZW5kZXJlZCB2aWV3cG9ydCwgd2UgY2FuJ3QgZGV0ZXJtaW5lIGEgcG9zaXRpb25cclxuICAgIGlmIChsaW5lU3RhcnQgPCB2aWV3LnZpZXdwb3J0LmZyb20pXHJcbiAgICAgICAgcmV0dXJuIHZpZXcudmlld3BvcnQuZnJvbSA9PSAwID8gMCA6IHByZWNpc2UgPyBudWxsIDogcG9zQXRDb29yZHNJbXByZWNpc2UodmlldywgY29udGVudCwgYmxvY2ssIHgsIHkpO1xyXG4gICAgaWYgKGxpbmVTdGFydCA+IHZpZXcudmlld3BvcnQudG8pXHJcbiAgICAgICAgcmV0dXJuIHZpZXcudmlld3BvcnQudG8gPT0gdmlldy5zdGF0ZS5kb2MubGVuZ3RoID8gdmlldy5zdGF0ZS5kb2MubGVuZ3RoIDpcclxuICAgICAgICAgICAgcHJlY2lzZSA/IG51bGwgOiBwb3NBdENvb3Jkc0ltcHJlY2lzZSh2aWV3LCBjb250ZW50LCBibG9jaywgeCwgeSk7XHJcbiAgICAvLyBQcmVmZXIgU2hhZG93Um9vdE9yRG9jdW1lbnQuZWxlbWVudEZyb21Qb2ludCBpZiBwcmVzZW50LCBmYWxsIGJhY2sgdG8gZG9jdW1lbnQgaWYgbm90XHJcbiAgICBsZXQgZG9jID0gdmlldy5kb20ub3duZXJEb2N1bWVudDtcclxuICAgIGxldCByb290ID0gdmlldy5yb290LmVsZW1lbnRGcm9tUG9pbnQgPyB2aWV3LnJvb3QgOiBkb2M7XHJcbiAgICBsZXQgZWxlbWVudCA9IHJvb3QuZWxlbWVudEZyb21Qb2ludCh4LCB5KTtcclxuICAgIGlmIChlbGVtZW50ICYmICF2aWV3LmNvbnRlbnRET00uY29udGFpbnMoZWxlbWVudCkpXHJcbiAgICAgICAgZWxlbWVudCA9IG51bGw7XHJcbiAgICAvLyBJZiB0aGUgZWxlbWVudCBpcyB1bmV4cGVjdGVkLCBjbGlwIHggYXQgdGhlIHNpZGVzIG9mIHRoZSBjb250ZW50IGFyZWEgYW5kIHRyeSBhZ2FpblxyXG4gICAgaWYgKCFlbGVtZW50KSB7XHJcbiAgICAgICAgeCA9IE1hdGgubWF4KGNvbnRlbnQubGVmdCArIDEsIE1hdGgubWluKGNvbnRlbnQucmlnaHQgLSAxLCB4KSk7XHJcbiAgICAgICAgZWxlbWVudCA9IHJvb3QuZWxlbWVudEZyb21Qb2ludCh4LCB5KTtcclxuICAgICAgICBpZiAoZWxlbWVudCAmJiAhdmlldy5jb250ZW50RE9NLmNvbnRhaW5zKGVsZW1lbnQpKVxyXG4gICAgICAgICAgICBlbGVtZW50ID0gbnVsbDtcclxuICAgIH1cclxuICAgIC8vIFRoZXJlJ3MgdmlzaWJsZSBlZGl0b3IgY29udGVudCB1bmRlciB0aGUgcG9pbnQsIHNvIHdlIGNhbiB0cnlcclxuICAgIC8vIHVzaW5nIGNhcmV0KFBvc2l0aW9ufFJhbmdlKUZyb21Qb2ludCBhcyBhIHNob3J0Y3V0XHJcbiAgICBsZXQgbm9kZSwgb2Zmc2V0ID0gLTE7XHJcbiAgICBpZiAoZWxlbWVudCAmJiAoKF9hID0gdmlldy5kb2NWaWV3Lm5lYXJlc3QoZWxlbWVudCkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5pc0VkaXRhYmxlKSAhPSBmYWxzZSkge1xyXG4gICAgICAgIGlmIChkb2MuY2FyZXRQb3NpdGlvbkZyb21Qb2ludCkge1xyXG4gICAgICAgICAgICBsZXQgcG9zID0gZG9jLmNhcmV0UG9zaXRpb25Gcm9tUG9pbnQoeCwgeSk7XHJcbiAgICAgICAgICAgIGlmIChwb3MpXHJcbiAgICAgICAgICAgICAgICAoeyBvZmZzZXROb2RlOiBub2RlLCBvZmZzZXQgfSA9IHBvcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGRvYy5jYXJldFJhbmdlRnJvbVBvaW50KSB7XHJcbiAgICAgICAgICAgIGxldCByYW5nZSA9IGRvYy5jYXJldFJhbmdlRnJvbVBvaW50KHgsIHkpO1xyXG4gICAgICAgICAgICBpZiAocmFuZ2UpIHtcclxuICAgICAgICAgICAgICAgICh7IHN0YXJ0Q29udGFpbmVyOiBub2RlLCBzdGFydE9mZnNldDogb2Zmc2V0IH0gPSByYW5nZSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoIXZpZXcuY29udGVudERPTS5jb250YWlucyhub2RlKSB8fFxyXG4gICAgICAgICAgICAgICAgICAgIGJyb3dzZXIuc2FmYXJpICYmIGlzU3VzcGljaW91c1NhZmFyaUNhcmV0UmVzdWx0KG5vZGUsIG9mZnNldCwgeCkgfHxcclxuICAgICAgICAgICAgICAgICAgICBicm93c2VyLmNocm9tZSAmJiBpc1N1c3BpY2lvdXNDaHJvbWVDYXJldFJlc3VsdChub2RlLCBvZmZzZXQsIHgpKVxyXG4gICAgICAgICAgICAgICAgICAgIG5vZGUgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvLyBObyBsdWNrLCBkbyBvdXIgb3duIChwb3RlbnRpYWxseSBleHBlbnNpdmUpIHNlYXJjaFxyXG4gICAgaWYgKCFub2RlIHx8ICF2aWV3LmRvY1ZpZXcuZG9tLmNvbnRhaW5zKG5vZGUpKSB7XHJcbiAgICAgICAgbGV0IGxpbmUgPSBMaW5lVmlldy5maW5kKHZpZXcuZG9jVmlldywgbGluZVN0YXJ0KTtcclxuICAgICAgICBpZiAoIWxpbmUpXHJcbiAgICAgICAgICAgIHJldHVybiB5T2Zmc2V0ID4gYmxvY2sudG9wICsgYmxvY2suaGVpZ2h0IC8gMiA/IGJsb2NrLnRvIDogYmxvY2suZnJvbTtcclxuICAgICAgICAoeyBub2RlLCBvZmZzZXQgfSA9IGRvbVBvc0F0Q29vcmRzKGxpbmUuZG9tLCB4LCB5KSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdmlldy5kb2NWaWV3LnBvc0Zyb21ET00obm9kZSwgb2Zmc2V0KTtcclxufVxyXG5mdW5jdGlvbiBwb3NBdENvb3Jkc0ltcHJlY2lzZSh2aWV3LCBjb250ZW50UmVjdCwgYmxvY2ssIHgsIHkpIHtcclxuICAgIGxldCBpbnRvID0gTWF0aC5yb3VuZCgoeCAtIGNvbnRlbnRSZWN0LmxlZnQpICogdmlldy5kZWZhdWx0Q2hhcmFjdGVyV2lkdGgpO1xyXG4gICAgaWYgKHZpZXcubGluZVdyYXBwaW5nICYmIGJsb2NrLmhlaWdodCA+IHZpZXcuZGVmYXVsdExpbmVIZWlnaHQgKiAxLjUpIHtcclxuICAgICAgICBsZXQgbGluZSA9IE1hdGguZmxvb3IoKHkgLSBibG9jay50b3ApIC8gdmlldy5kZWZhdWx0TGluZUhlaWdodCk7XHJcbiAgICAgICAgaW50byArPSBsaW5lICogdmlldy52aWV3U3RhdGUuaGVpZ2h0T3JhY2xlLmxpbmVMZW5ndGg7XHJcbiAgICB9XHJcbiAgICBsZXQgY29udGVudCA9IHZpZXcuc3RhdGUuc2xpY2VEb2MoYmxvY2suZnJvbSwgYmxvY2sudG8pO1xyXG4gICAgcmV0dXJuIGJsb2NrLmZyb20gKyBmaW5kQ29sdW1uKGNvbnRlbnQsIGludG8sIHZpZXcuc3RhdGUudGFiU2l6ZSk7XHJcbn1cclxuLy8gSW4gY2FzZSBvZiBhIGhpZ2ggbGluZSBoZWlnaHQsIFNhZmFyaSdzIGNhcmV0UmFuZ2VGcm9tUG9pbnQgdHJlYXRzXHJcbi8vIHRoZSBzcGFjZSBiZXR3ZWVuIGxpbmVzIGFzIGJlbG9uZ2luZyB0byB0aGUgbGFzdCBjaGFyYWN0ZXIgb2YgdGhlXHJcbi8vIGxpbmUgYmVmb3JlLiBUaGlzIGlzIHVzZWQgdG8gZGV0ZWN0IHN1Y2ggYSByZXN1bHQgc28gdGhhdCBpdCBjYW4gYmVcclxuLy8gaWdub3JlZCAoaXNzdWUgIzQwMSkuXHJcbmZ1bmN0aW9uIGlzU3VzcGljaW91c1NhZmFyaUNhcmV0UmVzdWx0KG5vZGUsIG9mZnNldCwgeCkge1xyXG4gICAgbGV0IGxlbjtcclxuICAgIGlmIChub2RlLm5vZGVUeXBlICE9IDMgfHwgb2Zmc2V0ICE9IChsZW4gPSBub2RlLm5vZGVWYWx1ZS5sZW5ndGgpKVxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIGZvciAobGV0IG5leHQgPSBub2RlLm5leHRTaWJsaW5nOyBuZXh0OyBuZXh0ID0gbmV4dC5uZXh0U2libGluZylcclxuICAgICAgICBpZiAobmV4dC5ub2RlVHlwZSAhPSAxIHx8IG5leHQubm9kZU5hbWUgIT0gXCJCUlwiKVxyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICByZXR1cm4gdGV4dFJhbmdlKG5vZGUsIGxlbiAtIDEsIGxlbikuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkubGVmdCA+IHg7XHJcbn1cclxuLy8gQ2hyb21lIHdpbGwgbW92ZSBwb3NpdGlvbnMgYmV0d2VlbiBsaW5lcyB0byB0aGUgc3RhcnQgb2YgdGhlIG5leHQgbGluZVxyXG5mdW5jdGlvbiBpc1N1c3BpY2lvdXNDaHJvbWVDYXJldFJlc3VsdChub2RlLCBvZmZzZXQsIHgpIHtcclxuICAgIGlmIChvZmZzZXQgIT0gMClcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICBmb3IgKGxldCBjdXIgPSBub2RlOzspIHtcclxuICAgICAgICBsZXQgcGFyZW50ID0gY3VyLnBhcmVudE5vZGU7XHJcbiAgICAgICAgaWYgKCFwYXJlbnQgfHwgcGFyZW50Lm5vZGVUeXBlICE9IDEgfHwgcGFyZW50LmZpcnN0Q2hpbGQgIT0gY3VyKVxyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgaWYgKHBhcmVudC5jbGFzc0xpc3QuY29udGFpbnMoXCJjbS1saW5lXCIpKVxyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICBjdXIgPSBwYXJlbnQ7XHJcbiAgICB9XHJcbiAgICBsZXQgcmVjdCA9IG5vZGUubm9kZVR5cGUgPT0gMSA/IG5vZGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KClcclxuICAgICAgICA6IHRleHRSYW5nZShub2RlLCAwLCBNYXRoLm1heChub2RlLm5vZGVWYWx1ZS5sZW5ndGgsIDEpKS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcclxuICAgIHJldHVybiB4IC0gcmVjdC5sZWZ0ID4gNTtcclxufVxyXG5mdW5jdGlvbiBtb3ZlVG9MaW5lQm91bmRhcnkodmlldywgc3RhcnQsIGZvcndhcmQsIGluY2x1ZGVXcmFwKSB7XHJcbiAgICBsZXQgbGluZSA9IHZpZXcuc3RhdGUuZG9jLmxpbmVBdChzdGFydC5oZWFkKTtcclxuICAgIGxldCBjb29yZHMgPSAhaW5jbHVkZVdyYXAgfHwgIXZpZXcubGluZVdyYXBwaW5nID8gbnVsbFxyXG4gICAgICAgIDogdmlldy5jb29yZHNBdFBvcyhzdGFydC5hc3NvYyA8IDAgJiYgc3RhcnQuaGVhZCA+IGxpbmUuZnJvbSA/IHN0YXJ0LmhlYWQgLSAxIDogc3RhcnQuaGVhZCk7XHJcbiAgICBpZiAoY29vcmRzKSB7XHJcbiAgICAgICAgbGV0IGVkaXRvclJlY3QgPSB2aWV3LmRvbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcclxuICAgICAgICBsZXQgZGlyZWN0aW9uID0gdmlldy50ZXh0RGlyZWN0aW9uQXQobGluZS5mcm9tKTtcclxuICAgICAgICBsZXQgcG9zID0gdmlldy5wb3NBdENvb3Jkcyh7IHg6IGZvcndhcmQgPT0gKGRpcmVjdGlvbiA9PSBEaXJlY3Rpb24uTFRSKSA/IGVkaXRvclJlY3QucmlnaHQgLSAxIDogZWRpdG9yUmVjdC5sZWZ0ICsgMSxcclxuICAgICAgICAgICAgeTogKGNvb3Jkcy50b3AgKyBjb29yZHMuYm90dG9tKSAvIDIgfSk7XHJcbiAgICAgICAgaWYgKHBvcyAhPSBudWxsKVxyXG4gICAgICAgICAgICByZXR1cm4gRWRpdG9yU2VsZWN0aW9uLmN1cnNvcihwb3MsIGZvcndhcmQgPyAtMSA6IDEpO1xyXG4gICAgfVxyXG4gICAgbGV0IGxpbmVWaWV3ID0gTGluZVZpZXcuZmluZCh2aWV3LmRvY1ZpZXcsIHN0YXJ0LmhlYWQpO1xyXG4gICAgbGV0IGVuZCA9IGxpbmVWaWV3ID8gKGZvcndhcmQgPyBsaW5lVmlldy5wb3NBdEVuZCA6IGxpbmVWaWV3LnBvc0F0U3RhcnQpIDogKGZvcndhcmQgPyBsaW5lLnRvIDogbGluZS5mcm9tKTtcclxuICAgIHJldHVybiBFZGl0b3JTZWxlY3Rpb24uY3Vyc29yKGVuZCwgZm9yd2FyZCA/IC0xIDogMSk7XHJcbn1cclxuZnVuY3Rpb24gbW92ZUJ5Q2hhcih2aWV3LCBzdGFydCwgZm9yd2FyZCwgYnkpIHtcclxuICAgIGxldCBsaW5lID0gdmlldy5zdGF0ZS5kb2MubGluZUF0KHN0YXJ0LmhlYWQpLCBzcGFucyA9IHZpZXcuYmlkaVNwYW5zKGxpbmUpO1xyXG4gICAgbGV0IGRpcmVjdGlvbiA9IHZpZXcudGV4dERpcmVjdGlvbkF0KGxpbmUuZnJvbSk7XHJcbiAgICBmb3IgKGxldCBjdXIgPSBzdGFydCwgY2hlY2sgPSBudWxsOzspIHtcclxuICAgICAgICBsZXQgbmV4dCA9IG1vdmVWaXN1YWxseShsaW5lLCBzcGFucywgZGlyZWN0aW9uLCBjdXIsIGZvcndhcmQpLCBjaGFyID0gbW92ZWRPdmVyO1xyXG4gICAgICAgIGlmICghbmV4dCkge1xyXG4gICAgICAgICAgICBpZiAobGluZS5udW1iZXIgPT0gKGZvcndhcmQgPyB2aWV3LnN0YXRlLmRvYy5saW5lcyA6IDEpKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGN1cjtcclxuICAgICAgICAgICAgY2hhciA9IFwiXFxuXCI7XHJcbiAgICAgICAgICAgIGxpbmUgPSB2aWV3LnN0YXRlLmRvYy5saW5lKGxpbmUubnVtYmVyICsgKGZvcndhcmQgPyAxIDogLTEpKTtcclxuICAgICAgICAgICAgc3BhbnMgPSB2aWV3LmJpZGlTcGFucyhsaW5lKTtcclxuICAgICAgICAgICAgbmV4dCA9IEVkaXRvclNlbGVjdGlvbi5jdXJzb3IoZm9yd2FyZCA/IGxpbmUuZnJvbSA6IGxpbmUudG8pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIWNoZWNrKSB7XHJcbiAgICAgICAgICAgIGlmICghYnkpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV4dDtcclxuICAgICAgICAgICAgY2hlY2sgPSBieShjaGFyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoIWNoZWNrKGNoYXIpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBjdXI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGN1ciA9IG5leHQ7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gYnlHcm91cCh2aWV3LCBwb3MsIHN0YXJ0KSB7XHJcbiAgICBsZXQgY2F0ZWdvcml6ZSA9IHZpZXcuc3RhdGUuY2hhckNhdGVnb3JpemVyKHBvcyk7XHJcbiAgICBsZXQgY2F0ID0gY2F0ZWdvcml6ZShzdGFydCk7XHJcbiAgICByZXR1cm4gKG5leHQpID0+IHtcclxuICAgICAgICBsZXQgbmV4dENhdCA9IGNhdGVnb3JpemUobmV4dCk7XHJcbiAgICAgICAgaWYgKGNhdCA9PSBDaGFyQ2F0ZWdvcnkuU3BhY2UpXHJcbiAgICAgICAgICAgIGNhdCA9IG5leHRDYXQ7XHJcbiAgICAgICAgcmV0dXJuIGNhdCA9PSBuZXh0Q2F0O1xyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiBtb3ZlVmVydGljYWxseSh2aWV3LCBzdGFydCwgZm9yd2FyZCwgZGlzdGFuY2UpIHtcclxuICAgIGxldCBzdGFydFBvcyA9IHN0YXJ0LmhlYWQsIGRpciA9IGZvcndhcmQgPyAxIDogLTE7XHJcbiAgICBpZiAoc3RhcnRQb3MgPT0gKGZvcndhcmQgPyB2aWV3LnN0YXRlLmRvYy5sZW5ndGggOiAwKSlcclxuICAgICAgICByZXR1cm4gRWRpdG9yU2VsZWN0aW9uLmN1cnNvcihzdGFydFBvcywgc3RhcnQuYXNzb2MpO1xyXG4gICAgbGV0IGdvYWwgPSBzdGFydC5nb2FsQ29sdW1uLCBzdGFydFk7XHJcbiAgICBsZXQgcmVjdCA9IHZpZXcuY29udGVudERPTS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcclxuICAgIGxldCBzdGFydENvb3JkcyA9IHZpZXcuY29vcmRzQXRQb3Moc3RhcnRQb3MpLCBkb2NUb3AgPSB2aWV3LmRvY3VtZW50VG9wO1xyXG4gICAgaWYgKHN0YXJ0Q29vcmRzKSB7XHJcbiAgICAgICAgaWYgKGdvYWwgPT0gbnVsbClcclxuICAgICAgICAgICAgZ29hbCA9IHN0YXJ0Q29vcmRzLmxlZnQgLSByZWN0LmxlZnQ7XHJcbiAgICAgICAgc3RhcnRZID0gZGlyIDwgMCA/IHN0YXJ0Q29vcmRzLnRvcCA6IHN0YXJ0Q29vcmRzLmJvdHRvbTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGxldCBsaW5lID0gdmlldy52aWV3U3RhdGUubGluZUJsb2NrQXQoc3RhcnRQb3MpO1xyXG4gICAgICAgIGlmIChnb2FsID09IG51bGwpXHJcbiAgICAgICAgICAgIGdvYWwgPSBNYXRoLm1pbihyZWN0LnJpZ2h0IC0gcmVjdC5sZWZ0LCB2aWV3LmRlZmF1bHRDaGFyYWN0ZXJXaWR0aCAqIChzdGFydFBvcyAtIGxpbmUuZnJvbSkpO1xyXG4gICAgICAgIHN0YXJ0WSA9IChkaXIgPCAwID8gbGluZS50b3AgOiBsaW5lLmJvdHRvbSkgKyBkb2NUb3A7XHJcbiAgICB9XHJcbiAgICBsZXQgcmVzb2x2ZWRHb2FsID0gcmVjdC5sZWZ0ICsgZ29hbDtcclxuICAgIGxldCBkaXN0ID0gZGlzdGFuY2UgIT09IG51bGwgJiYgZGlzdGFuY2UgIT09IHZvaWQgMCA/IGRpc3RhbmNlIDogKHZpZXcuZGVmYXVsdExpbmVIZWlnaHQgPj4gMSk7XHJcbiAgICBmb3IgKGxldCBleHRyYSA9IDA7OyBleHRyYSArPSAxMCkge1xyXG4gICAgICAgIGxldCBjdXJZID0gc3RhcnRZICsgKGRpc3QgKyBleHRyYSkgKiBkaXI7XHJcbiAgICAgICAgbGV0IHBvcyA9IHBvc0F0Q29vcmRzKHZpZXcsIHsgeDogcmVzb2x2ZWRHb2FsLCB5OiBjdXJZIH0sIGZhbHNlLCBkaXIpO1xyXG4gICAgICAgIGlmIChjdXJZIDwgcmVjdC50b3AgfHwgY3VyWSA+IHJlY3QuYm90dG9tIHx8IChkaXIgPCAwID8gcG9zIDwgc3RhcnRQb3MgOiBwb3MgPiBzdGFydFBvcykpXHJcbiAgICAgICAgICAgIHJldHVybiBFZGl0b3JTZWxlY3Rpb24uY3Vyc29yKHBvcywgc3RhcnQuYXNzb2MsIHVuZGVmaW5lZCwgZ29hbCk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gc2tpcEF0b21zKHZpZXcsIG9sZFBvcywgcG9zKSB7XHJcbiAgICBsZXQgYXRvbXMgPSB2aWV3LnN0YXRlLmZhY2V0KGF0b21pY1JhbmdlcykubWFwKGYgPT4gZih2aWV3KSk7XHJcbiAgICBmb3IgKDs7KSB7XHJcbiAgICAgICAgbGV0IG1vdmVkID0gZmFsc2U7XHJcbiAgICAgICAgZm9yIChsZXQgc2V0IG9mIGF0b21zKSB7XHJcbiAgICAgICAgICAgIHNldC5iZXR3ZWVuKHBvcy5mcm9tIC0gMSwgcG9zLmZyb20gKyAxLCAoZnJvbSwgdG8sIHZhbHVlKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAocG9zLmZyb20gPiBmcm9tICYmIHBvcy5mcm9tIDwgdG8pIHtcclxuICAgICAgICAgICAgICAgICAgICBwb3MgPSBvbGRQb3MuaGVhZCA+IHBvcy5mcm9tID8gRWRpdG9yU2VsZWN0aW9uLmN1cnNvcihmcm9tLCAxKSA6IEVkaXRvclNlbGVjdGlvbi5jdXJzb3IodG8sIC0xKTtcclxuICAgICAgICAgICAgICAgICAgICBtb3ZlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIW1vdmVkKVxyXG4gICAgICAgICAgICByZXR1cm4gcG9zO1xyXG4gICAgfVxyXG59XHJcblxyXG4vLyBUaGlzIHdpbGwgYWxzbyBiZSB3aGVyZSBkcmFnZ2luZyBpbmZvIGFuZCBzdWNoIGdvZXNcclxuY2xhc3MgSW5wdXRTdGF0ZSB7XHJcbiAgICBjb25zdHJ1Y3Rvcih2aWV3KSB7XHJcbiAgICAgICAgdGhpcy5sYXN0S2V5Q29kZSA9IDA7XHJcbiAgICAgICAgdGhpcy5sYXN0S2V5VGltZSA9IDA7XHJcbiAgICAgICAgdGhpcy5sYXN0VG91Y2hUaW1lID0gMDtcclxuICAgICAgICB0aGlzLmxhc3RGb2N1c1RpbWUgPSAwO1xyXG4gICAgICAgIHRoaXMubGFzdFNjcm9sbFRvcCA9IDA7XHJcbiAgICAgICAgdGhpcy5sYXN0U2Nyb2xsTGVmdCA9IDA7XHJcbiAgICAgICAgdGhpcy5jaHJvbWVTY3JvbGxIYWNrID0gLTE7XHJcbiAgICAgICAgLy8gT24gaU9TLCBzb21lIGtleXMgbmVlZCB0byBoYXZlIHRoZWlyIGRlZmF1bHQgYmVoYXZpb3IgaGFwcGVuXHJcbiAgICAgICAgLy8gKGFmdGVyIHdoaWNoIHdlIHJldHJvYWN0aXZlbHkgaGFuZGxlIHRoZW0gYW5kIHJlc2V0IHRoZSBET00pIHRvXHJcbiAgICAgICAgLy8gYXZvaWQgbWVzc2luZyB1cCB0aGUgdmlydHVhbCBrZXlib2FyZCBzdGF0ZS5cclxuICAgICAgICB0aGlzLnBlbmRpbmdJT1NLZXkgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgdGhpcy5sYXN0U2VsZWN0aW9uT3JpZ2luID0gbnVsbDtcclxuICAgICAgICB0aGlzLmxhc3RTZWxlY3Rpb25UaW1lID0gMDtcclxuICAgICAgICB0aGlzLmxhc3RFc2NQcmVzcyA9IDA7XHJcbiAgICAgICAgdGhpcy5sYXN0Q29udGV4dE1lbnUgPSAwO1xyXG4gICAgICAgIHRoaXMuc2Nyb2xsSGFuZGxlcnMgPSBbXTtcclxuICAgICAgICB0aGlzLnJlZ2lzdGVyZWRFdmVudHMgPSBbXTtcclxuICAgICAgICB0aGlzLmN1c3RvbUhhbmRsZXJzID0gW107XHJcbiAgICAgICAgLy8gLTEgbWVhbnMgbm90IGluIGEgY29tcG9zaXRpb24uIE90aGVyd2lzZSwgdGhpcyBjb3VudHMgdGhlIG51bWJlclxyXG4gICAgICAgIC8vIG9mIGNoYW5nZXMgbWFkZSBkdXJpbmcgdGhlIGNvbXBvc2l0aW9uLiBUaGUgY291bnQgaXMgdXNlZCB0b1xyXG4gICAgICAgIC8vIGF2b2lkIHRyZWF0aW5nIHRoZSBzdGFydCBzdGF0ZSBvZiB0aGUgY29tcG9zaXRpb24sIGJlZm9yZSBhbnlcclxuICAgICAgICAvLyBjaGFuZ2VzIGhhdmUgYmVlbiBtYWRlLCBhcyBwYXJ0IG9mIHRoZSBjb21wb3NpdGlvbi5cclxuICAgICAgICB0aGlzLmNvbXBvc2luZyA9IC0xO1xyXG4gICAgICAgIC8vIFRyYWNrcyB3aGV0aGVyIHRoZSBuZXh0IGNoYW5nZSBzaG91bGQgYmUgbWFya2VkIGFzIHN0YXJ0aW5nIHRoZVxyXG4gICAgICAgIC8vIGNvbXBvc2l0aW9uIChudWxsIG1lYW5zIG5vIGNvbXBvc2l0aW9uLCB0cnVlIG1lYW5zIG5leHQgaXMgdGhlXHJcbiAgICAgICAgLy8gZmlyc3QsIGZhbHNlIG1lYW5zIGZpcnN0IGhhcyBhbHJlYWR5IGJlZW4gbWFya2VkIGZvciB0aGlzXHJcbiAgICAgICAgLy8gY29tcG9zaXRpb24pXHJcbiAgICAgICAgdGhpcy5jb21wb3NpdGlvbkZpcnN0Q2hhbmdlID0gbnVsbDtcclxuICAgICAgICB0aGlzLmNvbXBvc2l0aW9uRW5kZWRBdCA9IDA7XHJcbiAgICAgICAgdGhpcy5tb3VzZVNlbGVjdGlvbiA9IG51bGw7XHJcbiAgICAgICAgbGV0IGhhbmRsZUV2ZW50ID0gKGhhbmRsZXIsIGV2ZW50KSA9PiB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmlnbm9yZUR1cmluZ0NvbXBvc2l0aW9uKGV2ZW50KSlcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgaWYgKGV2ZW50LnR5cGUgPT0gXCJrZXlkb3duXCIgJiYgdGhpcy5rZXlkb3duKHZpZXcsIGV2ZW50KSlcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgaWYgKHRoaXMubXVzdEZsdXNoT2JzZXJ2ZXIoZXZlbnQpKVxyXG4gICAgICAgICAgICAgICAgdmlldy5vYnNlcnZlci5mb3JjZUZsdXNoKCk7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnJ1bkN1c3RvbUhhbmRsZXJzKGV2ZW50LnR5cGUsIHZpZXcsIGV2ZW50KSlcclxuICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgIGhhbmRsZXIodmlldywgZXZlbnQpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgZm9yIChsZXQgdHlwZSBpbiBoYW5kbGVycykge1xyXG4gICAgICAgICAgICBsZXQgaGFuZGxlciA9IGhhbmRsZXJzW3R5cGVdO1xyXG4gICAgICAgICAgICB2aWV3LmNvbnRlbnRET00uYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBldmVudCA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZXZlbnRCZWxvbmdzVG9FZGl0b3IodmlldywgZXZlbnQpKVxyXG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZUV2ZW50KGhhbmRsZXIsIGV2ZW50KTtcclxuICAgICAgICAgICAgfSwgaGFuZGxlck9wdGlvbnNbdHlwZV0pO1xyXG4gICAgICAgICAgICB0aGlzLnJlZ2lzdGVyZWRFdmVudHMucHVzaCh0eXBlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmlldy5zY3JvbGxET00uYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlZG93blwiLCAoZXZlbnQpID0+IHtcclxuICAgICAgICAgICAgaWYgKGV2ZW50LnRhcmdldCA9PSB2aWV3LnNjcm9sbERPTSlcclxuICAgICAgICAgICAgICAgIGhhbmRsZUV2ZW50KGhhbmRsZXJzLm1vdXNlZG93biwgZXZlbnQpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGlmIChicm93c2VyLmNocm9tZSAmJiBicm93c2VyLmNocm9tZV92ZXJzaW9uID09IDEwMikgeyAvLyBGSVhNRSByZW1vdmUgYXQgc29tZSBwb2ludFxyXG4gICAgICAgICAgICAvLyBPbiBDaHJvbWUgMTAyLCB2aWV3cG9ydCB1cGRhdGVzIHNvbWVob3cgc3RvcCB3aGVlbC1iYXNlZFxyXG4gICAgICAgICAgICAvLyBzY3JvbGxpbmcuIFR1cm5pbmcgb2ZmIHBvaW50ZXIgZXZlbnRzIGR1cmluZyB0aGUgc2Nyb2xsIHNlZW1zXHJcbiAgICAgICAgICAgIC8vIHRvIGF2b2lkIHRoZSBpc3N1ZS5cclxuICAgICAgICAgICAgdmlldy5zY3JvbGxET00uYWRkRXZlbnRMaXN0ZW5lcihcIndoZWVsXCIsICgpID0+IHtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmNocm9tZVNjcm9sbEhhY2sgPCAwKVxyXG4gICAgICAgICAgICAgICAgICAgIHZpZXcuY29udGVudERPTS5zdHlsZS5wb2ludGVyRXZlbnRzID0gXCJub25lXCI7XHJcbiAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgd2luZG93LmNsZWFyVGltZW91dCh0aGlzLmNocm9tZVNjcm9sbEhhY2spO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jaHJvbWVTY3JvbGxIYWNrID0gc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jaHJvbWVTY3JvbGxIYWNrID0gLTE7XHJcbiAgICAgICAgICAgICAgICAgICAgdmlldy5jb250ZW50RE9NLnN0eWxlLnBvaW50ZXJFdmVudHMgPSBcIlwiO1xyXG4gICAgICAgICAgICAgICAgfSwgMTAwKTtcclxuICAgICAgICAgICAgfSwgeyBwYXNzaXZlOiB0cnVlIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLm5vdGlmaWVkRm9jdXNlZCA9IHZpZXcuaGFzRm9jdXM7XHJcbiAgICAgICAgLy8gT24gU2FmYXJpIGFkZGluZyBhbiBpbnB1dCBldmVudCBoYW5kbGVyIHNvbWVob3cgcHJldmVudHMgYW5cclxuICAgICAgICAvLyBpc3N1ZSB3aGVyZSB0aGUgY29tcG9zaXRpb24gdmFuaXNoZXMgd2hlbiB5b3UgcHJlc3MgZW50ZXIuXHJcbiAgICAgICAgaWYgKGJyb3dzZXIuc2FmYXJpKVxyXG4gICAgICAgICAgICB2aWV3LmNvbnRlbnRET00uYWRkRXZlbnRMaXN0ZW5lcihcImlucHV0XCIsICgpID0+IG51bGwpO1xyXG4gICAgfVxyXG4gICAgc2V0U2VsZWN0aW9uT3JpZ2luKG9yaWdpbikge1xyXG4gICAgICAgIHRoaXMubGFzdFNlbGVjdGlvbk9yaWdpbiA9IG9yaWdpbjtcclxuICAgICAgICB0aGlzLmxhc3RTZWxlY3Rpb25UaW1lID0gRGF0ZS5ub3coKTtcclxuICAgIH1cclxuICAgIGVuc3VyZUhhbmRsZXJzKHZpZXcsIHBsdWdpbnMpIHtcclxuICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgbGV0IGhhbmRsZXJzO1xyXG4gICAgICAgIHRoaXMuY3VzdG9tSGFuZGxlcnMgPSBbXTtcclxuICAgICAgICBmb3IgKGxldCBwbHVnaW4gb2YgcGx1Z2lucylcclxuICAgICAgICAgICAgaWYgKGhhbmRsZXJzID0gKF9hID0gcGx1Z2luLnVwZGF0ZSh2aWV3KS5zcGVjKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZG9tRXZlbnRIYW5kbGVycykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jdXN0b21IYW5kbGVycy5wdXNoKHsgcGx1Z2luOiBwbHVnaW4udmFsdWUsIGhhbmRsZXJzIH0pO1xyXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgdHlwZSBpbiBoYW5kbGVycylcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5yZWdpc3RlcmVkRXZlbnRzLmluZGV4T2YodHlwZSkgPCAwICYmIHR5cGUgIT0gXCJzY3JvbGxcIikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlZ2lzdGVyZWRFdmVudHMucHVzaCh0eXBlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmlldy5jb250ZW50RE9NLmFkZEV2ZW50TGlzdGVuZXIodHlwZSwgKGV2ZW50KSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWV2ZW50QmVsb25nc1RvRWRpdG9yKHZpZXcsIGV2ZW50KSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5ydW5DdXN0b21IYW5kbGVycyh0eXBlLCB2aWV3LCBldmVudCkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBydW5DdXN0b21IYW5kbGVycyh0eXBlLCB2aWV3LCBldmVudCkge1xyXG4gICAgICAgIGZvciAobGV0IHNldCBvZiB0aGlzLmN1c3RvbUhhbmRsZXJzKSB7XHJcbiAgICAgICAgICAgIGxldCBoYW5kbGVyID0gc2V0LmhhbmRsZXJzW3R5cGVdO1xyXG4gICAgICAgICAgICBpZiAoaGFuZGxlcikge1xyXG4gICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaGFuZGxlci5jYWxsKHNldC5wbHVnaW4sIGV2ZW50LCB2aWV3KSB8fCBldmVudC5kZWZhdWx0UHJldmVudGVkKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbG9nRXhjZXB0aW9uKHZpZXcuc3RhdGUsIGUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIHJ1blNjcm9sbEhhbmRsZXJzKHZpZXcsIGV2ZW50KSB7XHJcbiAgICAgICAgdGhpcy5sYXN0U2Nyb2xsVG9wID0gdmlldy5zY3JvbGxET00uc2Nyb2xsVG9wO1xyXG4gICAgICAgIHRoaXMubGFzdFNjcm9sbExlZnQgPSB2aWV3LnNjcm9sbERPTS5zY3JvbGxMZWZ0O1xyXG4gICAgICAgIGZvciAobGV0IHNldCBvZiB0aGlzLmN1c3RvbUhhbmRsZXJzKSB7XHJcbiAgICAgICAgICAgIGxldCBoYW5kbGVyID0gc2V0LmhhbmRsZXJzLnNjcm9sbDtcclxuICAgICAgICAgICAgaWYgKGhhbmRsZXIpIHtcclxuICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlci5jYWxsKHNldC5wbHVnaW4sIGV2ZW50LCB2aWV3KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbG9nRXhjZXB0aW9uKHZpZXcuc3RhdGUsIGUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAga2V5ZG93bih2aWV3LCBldmVudCkge1xyXG4gICAgICAgIC8vIE11c3QgYWx3YXlzIHJ1biwgZXZlbiBpZiBhIGN1c3RvbSBoYW5kbGVyIGhhbmRsZWQgdGhlIGV2ZW50XHJcbiAgICAgICAgdGhpcy5sYXN0S2V5Q29kZSA9IGV2ZW50LmtleUNvZGU7XHJcbiAgICAgICAgdGhpcy5sYXN0S2V5VGltZSA9IERhdGUubm93KCk7XHJcbiAgICAgICAgaWYgKGV2ZW50LmtleUNvZGUgPT0gOSAmJiBEYXRlLm5vdygpIDwgdGhpcy5sYXN0RXNjUHJlc3MgKyAyMDAwKVxyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAvLyBDaHJvbWUgZm9yIEFuZHJvaWQgdXN1YWxseSBkb2Vzbid0IGZpcmUgcHJvcGVyIGtleSBldmVudHMsIGJ1dFxyXG4gICAgICAgIC8vIG9jY2FzaW9uYWxseSBkb2VzLCB1c3VhbGx5IHN1cnJvdW5kZWQgYnkgYSBidW5jaCBvZiBjb21wbGljYXRlZFxyXG4gICAgICAgIC8vIGNvbXBvc2l0aW9uIGNoYW5nZXMuIFdoZW4gYW4gZW50ZXIgb3IgYmFja3NwYWNlIGtleSBldmVudCBpc1xyXG4gICAgICAgIC8vIHNlZW4sIGhvbGQgb2ZmIG9uIGhhbmRsaW5nIERPTSBldmVudHMgZm9yIGEgYml0LCBhbmQgdGhlblxyXG4gICAgICAgIC8vIGRpc3BhdGNoIGl0LlxyXG4gICAgICAgIGlmIChicm93c2VyLmFuZHJvaWQgJiYgYnJvd3Nlci5jaHJvbWUgJiYgIWV2ZW50LnN5bnRoZXRpYyAmJlxyXG4gICAgICAgICAgICAoZXZlbnQua2V5Q29kZSA9PSAxMyB8fCBldmVudC5rZXlDb2RlID09IDgpKSB7XHJcbiAgICAgICAgICAgIHZpZXcub2JzZXJ2ZXIuZGVsYXlBbmRyb2lkS2V5KGV2ZW50LmtleSwgZXZlbnQua2V5Q29kZSk7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBQcmV2ZW50IHRoZSBkZWZhdWx0IGJlaGF2aW9yIG9mIEVudGVyIG9uIGlPUyBtYWtlcyB0aGVcclxuICAgICAgICAvLyB2aXJ0dWFsIGtleWJvYXJkIGdldCBzdHVjayBpbiB0aGUgd3JvbmcgKGxvd2VyY2FzZSlcclxuICAgICAgICAvLyBzdGF0ZS4gU28gd2UgbGV0IGl0IGdvIHRocm91Z2gsIGFuZCB0aGVuLCBpblxyXG4gICAgICAgIC8vIGFwcGx5RE9NQ2hhbmdlLCBub3RpZnkga2V5IGhhbmRsZXJzIG9mIGl0IGFuZCByZXNldCB0b1xyXG4gICAgICAgIC8vIHRoZSBzdGF0ZSB0aGV5IHByb2R1Y2UuXHJcbiAgICAgICAgbGV0IHBlbmRpbmc7XHJcbiAgICAgICAgaWYgKGJyb3dzZXIuaW9zICYmICFldmVudC5zeW50aGV0aWMgJiYgIWV2ZW50LmFsdEtleSAmJiAhZXZlbnQubWV0YUtleSAmJlxyXG4gICAgICAgICAgICAoKHBlbmRpbmcgPSBQZW5kaW5nS2V5cy5maW5kKGtleSA9PiBrZXkua2V5Q29kZSA9PSBldmVudC5rZXlDb2RlKSkgJiYgIWV2ZW50LmN0cmxLZXkgfHxcclxuICAgICAgICAgICAgICAgIEVtYWNzeVBlbmRpbmdLZXlzLmluZGV4T2YoZXZlbnQua2V5KSA+IC0xICYmIGV2ZW50LmN0cmxLZXkgJiYgIWV2ZW50LnNoaWZ0S2V5KSkge1xyXG4gICAgICAgICAgICB0aGlzLnBlbmRpbmdJT1NLZXkgPSBwZW5kaW5nIHx8IGV2ZW50O1xyXG4gICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHRoaXMuZmx1c2hJT1NLZXkodmlldyksIDI1MCk7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBmbHVzaElPU0tleSh2aWV3KSB7XHJcbiAgICAgICAgbGV0IGtleSA9IHRoaXMucGVuZGluZ0lPU0tleTtcclxuICAgICAgICBpZiAoIWtleSlcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIHRoaXMucGVuZGluZ0lPU0tleSA9IHVuZGVmaW5lZDtcclxuICAgICAgICByZXR1cm4gZGlzcGF0Y2hLZXkodmlldy5jb250ZW50RE9NLCBrZXkua2V5LCBrZXkua2V5Q29kZSk7XHJcbiAgICB9XHJcbiAgICBpZ25vcmVEdXJpbmdDb21wb3NpdGlvbihldmVudCkge1xyXG4gICAgICAgIGlmICghL15rZXkvLnRlc3QoZXZlbnQudHlwZSkpXHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICBpZiAodGhpcy5jb21wb3NpbmcgPiAwKVxyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAvLyBTZWUgaHR0cHM6Ly93d3cuc3R1bS5kZS8yMDE2LzA2LzI0L2hhbmRsaW5nLWltZS1ldmVudHMtaW4tamF2YXNjcmlwdC8uXHJcbiAgICAgICAgLy8gT24gc29tZSBpbnB1dCBtZXRob2QgZWRpdG9ycyAoSU1FcyksIHRoZSBFbnRlciBrZXkgaXMgdXNlZCB0b1xyXG4gICAgICAgIC8vIGNvbmZpcm0gY2hhcmFjdGVyIHNlbGVjdGlvbi4gT24gU2FmYXJpLCB3aGVuIEVudGVyIGlzIHByZXNzZWQsXHJcbiAgICAgICAgLy8gY29tcG9zaXRpb25lbmQgYW5kIGtleWRvd24gZXZlbnRzIGFyZSBzb21ldGltZXMgZW1pdHRlZCBpbiB0aGVcclxuICAgICAgICAvLyB3cm9uZyBvcmRlci4gVGhlIGtleSBldmVudCBzaG91bGQgc3RpbGwgYmUgaWdub3JlZCwgZXZlbiB3aGVuXHJcbiAgICAgICAgLy8gaXQgaGFwcGVucyBhZnRlciB0aGUgY29tcG9zaXRpb25lbmQgZXZlbnQuXHJcbiAgICAgICAgaWYgKGJyb3dzZXIuc2FmYXJpICYmICFicm93c2VyLmlvcyAmJiBEYXRlLm5vdygpIC0gdGhpcy5jb21wb3NpdGlvbkVuZGVkQXQgPCAxMDApIHtcclxuICAgICAgICAgICAgdGhpcy5jb21wb3NpdGlvbkVuZGVkQXQgPSAwO1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgbXVzdEZsdXNoT2JzZXJ2ZXIoZXZlbnQpIHtcclxuICAgICAgICByZXR1cm4gZXZlbnQudHlwZSA9PSBcImtleWRvd25cIiAmJiBldmVudC5rZXlDb2RlICE9IDIyOTtcclxuICAgIH1cclxuICAgIHN0YXJ0TW91c2VTZWxlY3Rpb24obW91c2VTZWxlY3Rpb24pIHtcclxuICAgICAgICBpZiAodGhpcy5tb3VzZVNlbGVjdGlvbilcclxuICAgICAgICAgICAgdGhpcy5tb3VzZVNlbGVjdGlvbi5kZXN0cm95KCk7XHJcbiAgICAgICAgdGhpcy5tb3VzZVNlbGVjdGlvbiA9IG1vdXNlU2VsZWN0aW9uO1xyXG4gICAgfVxyXG4gICAgdXBkYXRlKHVwZGF0ZSkge1xyXG4gICAgICAgIGlmICh0aGlzLm1vdXNlU2VsZWN0aW9uKVxyXG4gICAgICAgICAgICB0aGlzLm1vdXNlU2VsZWN0aW9uLnVwZGF0ZSh1cGRhdGUpO1xyXG4gICAgICAgIGlmICh1cGRhdGUudHJhbnNhY3Rpb25zLmxlbmd0aClcclxuICAgICAgICAgICAgdGhpcy5sYXN0S2V5Q29kZSA9IHRoaXMubGFzdFNlbGVjdGlvblRpbWUgPSAwO1xyXG4gICAgfVxyXG4gICAgZGVzdHJveSgpIHtcclxuICAgICAgICBpZiAodGhpcy5tb3VzZVNlbGVjdGlvbilcclxuICAgICAgICAgICAgdGhpcy5tb3VzZVNlbGVjdGlvbi5kZXN0cm95KCk7XHJcbiAgICB9XHJcbn1cclxuY29uc3QgUGVuZGluZ0tleXMgPSBbXHJcbiAgICB7IGtleTogXCJCYWNrc3BhY2VcIiwga2V5Q29kZTogOCwgaW5wdXRUeXBlOiBcImRlbGV0ZUNvbnRlbnRCYWNrd2FyZFwiIH0sXHJcbiAgICB7IGtleTogXCJFbnRlclwiLCBrZXlDb2RlOiAxMywgaW5wdXRUeXBlOiBcImluc2VydFBhcmFncmFwaFwiIH0sXHJcbiAgICB7IGtleTogXCJEZWxldGVcIiwga2V5Q29kZTogNDYsIGlucHV0VHlwZTogXCJkZWxldGVDb250ZW50Rm9yd2FyZFwiIH1cclxuXTtcclxuY29uc3QgRW1hY3N5UGVuZGluZ0tleXMgPSBcImR0aGtvXCI7XHJcbi8vIEtleSBjb2RlcyBmb3IgbW9kaWZpZXIga2V5c1xyXG5jb25zdCBtb2RpZmllckNvZGVzID0gWzE2LCAxNywgMTgsIDIwLCA5MSwgOTIsIDIyNCwgMjI1XTtcclxuZnVuY3Rpb24gZHJhZ1Njcm9sbFNwZWVkKGRpc3QpIHtcclxuICAgIHJldHVybiBkaXN0ICogMC43ICsgODtcclxufVxyXG5jbGFzcyBNb3VzZVNlbGVjdGlvbiB7XHJcbiAgICBjb25zdHJ1Y3Rvcih2aWV3LCBzdGFydEV2ZW50LCBzdHlsZSwgbXVzdFNlbGVjdCkge1xyXG4gICAgICAgIHRoaXMudmlldyA9IHZpZXc7XHJcbiAgICAgICAgdGhpcy5zdHlsZSA9IHN0eWxlO1xyXG4gICAgICAgIHRoaXMubXVzdFNlbGVjdCA9IG11c3RTZWxlY3Q7XHJcbiAgICAgICAgdGhpcy5zY3JvbGxTcGVlZCA9IHsgeDogMCwgeTogMCB9O1xyXG4gICAgICAgIHRoaXMuc2Nyb2xsaW5nID0gLTE7XHJcbiAgICAgICAgdGhpcy5sYXN0RXZlbnQgPSBzdGFydEV2ZW50O1xyXG4gICAgICAgIHRoaXMuc2Nyb2xsUGFyZW50ID0gc2Nyb2xsYWJsZVBhcmVudCh2aWV3LmNvbnRlbnRET00pO1xyXG4gICAgICAgIGxldCBkb2MgPSB2aWV3LmNvbnRlbnRET00ub3duZXJEb2N1bWVudDtcclxuICAgICAgICBkb2MuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlbW92ZVwiLCB0aGlzLm1vdmUgPSB0aGlzLm1vdmUuYmluZCh0aGlzKSk7XHJcbiAgICAgICAgZG9jLmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZXVwXCIsIHRoaXMudXAgPSB0aGlzLnVwLmJpbmQodGhpcykpO1xyXG4gICAgICAgIHRoaXMuZXh0ZW5kID0gc3RhcnRFdmVudC5zaGlmdEtleTtcclxuICAgICAgICB0aGlzLm11bHRpcGxlID0gdmlldy5zdGF0ZS5mYWNldChFZGl0b3JTdGF0ZS5hbGxvd011bHRpcGxlU2VsZWN0aW9ucykgJiYgYWRkc1NlbGVjdGlvblJhbmdlKHZpZXcsIHN0YXJ0RXZlbnQpO1xyXG4gICAgICAgIHRoaXMuZHJhZ01vdmUgPSBkcmFnTW92ZXNTZWxlY3Rpb24odmlldywgc3RhcnRFdmVudCk7XHJcbiAgICAgICAgdGhpcy5kcmFnZ2luZyA9IGlzSW5QcmltYXJ5U2VsZWN0aW9uKHZpZXcsIHN0YXJ0RXZlbnQpICYmIGdldENsaWNrVHlwZShzdGFydEV2ZW50KSA9PSAxID8gbnVsbCA6IGZhbHNlO1xyXG4gICAgICAgIC8vIFdoZW4gY2xpY2tpbmcgb3V0c2lkZSBvZiB0aGUgc2VsZWN0aW9uLCBpbW1lZGlhdGVseSBhcHBseSB0aGVcclxuICAgICAgICAvLyBlZmZlY3Qgb2Ygc3RhcnRpbmcgdGhlIHNlbGVjdGlvblxyXG4gICAgICAgIGlmICh0aGlzLmRyYWdnaW5nID09PSBmYWxzZSkge1xyXG4gICAgICAgICAgICBzdGFydEV2ZW50LnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0KHN0YXJ0RXZlbnQpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIG1vdmUoZXZlbnQpIHtcclxuICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgaWYgKGV2ZW50LmJ1dHRvbnMgPT0gMClcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGVzdHJveSgpO1xyXG4gICAgICAgIGlmICh0aGlzLmRyYWdnaW5nICE9PSBmYWxzZSlcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIHRoaXMuc2VsZWN0KHRoaXMubGFzdEV2ZW50ID0gZXZlbnQpO1xyXG4gICAgICAgIGxldCBzeCA9IDAsIHN5ID0gMDtcclxuICAgICAgICBsZXQgcmVjdCA9ICgoX2EgPSB0aGlzLnNjcm9sbFBhcmVudCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpKVxyXG4gICAgICAgICAgICB8fCB7IGxlZnQ6IDAsIHRvcDogMCwgcmlnaHQ6IHRoaXMudmlldy53aW4uaW5uZXJXaWR0aCwgYm90dG9tOiB0aGlzLnZpZXcud2luLmlubmVySGVpZ2h0IH07XHJcbiAgICAgICAgaWYgKGV2ZW50LmNsaWVudFggPD0gcmVjdC5sZWZ0KVxyXG4gICAgICAgICAgICBzeCA9IC1kcmFnU2Nyb2xsU3BlZWQocmVjdC5sZWZ0IC0gZXZlbnQuY2xpZW50WCk7XHJcbiAgICAgICAgZWxzZSBpZiAoZXZlbnQuY2xpZW50WCA+PSByZWN0LnJpZ2h0KVxyXG4gICAgICAgICAgICBzeCA9IGRyYWdTY3JvbGxTcGVlZChldmVudC5jbGllbnRYIC0gcmVjdC5yaWdodCk7XHJcbiAgICAgICAgaWYgKGV2ZW50LmNsaWVudFkgPD0gcmVjdC50b3ApXHJcbiAgICAgICAgICAgIHN5ID0gLWRyYWdTY3JvbGxTcGVlZChyZWN0LnRvcCAtIGV2ZW50LmNsaWVudFkpO1xyXG4gICAgICAgIGVsc2UgaWYgKGV2ZW50LmNsaWVudFkgPj0gcmVjdC5ib3R0b20pXHJcbiAgICAgICAgICAgIHN5ID0gZHJhZ1Njcm9sbFNwZWVkKGV2ZW50LmNsaWVudFkgLSByZWN0LmJvdHRvbSk7XHJcbiAgICAgICAgdGhpcy5zZXRTY3JvbGxTcGVlZChzeCwgc3kpO1xyXG4gICAgfVxyXG4gICAgdXAoZXZlbnQpIHtcclxuICAgICAgICBpZiAodGhpcy5kcmFnZ2luZyA9PSBudWxsKVxyXG4gICAgICAgICAgICB0aGlzLnNlbGVjdCh0aGlzLmxhc3RFdmVudCk7XHJcbiAgICAgICAgaWYgKCF0aGlzLmRyYWdnaW5nKVxyXG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgIHRoaXMuZGVzdHJveSgpO1xyXG4gICAgfVxyXG4gICAgZGVzdHJveSgpIHtcclxuICAgICAgICB0aGlzLnNldFNjcm9sbFNwZWVkKDAsIDApO1xyXG4gICAgICAgIGxldCBkb2MgPSB0aGlzLnZpZXcuY29udGVudERPTS5vd25lckRvY3VtZW50O1xyXG4gICAgICAgIGRvYy5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2Vtb3ZlXCIsIHRoaXMubW92ZSk7XHJcbiAgICAgICAgZG9jLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZXVwXCIsIHRoaXMudXApO1xyXG4gICAgICAgIHRoaXMudmlldy5pbnB1dFN0YXRlLm1vdXNlU2VsZWN0aW9uID0gbnVsbDtcclxuICAgIH1cclxuICAgIHNldFNjcm9sbFNwZWVkKHN4LCBzeSkge1xyXG4gICAgICAgIHRoaXMuc2Nyb2xsU3BlZWQgPSB7IHg6IHN4LCB5OiBzeSB9O1xyXG4gICAgICAgIGlmIChzeCB8fCBzeSkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5zY3JvbGxpbmcgPCAwKVxyXG4gICAgICAgICAgICAgICAgdGhpcy5zY3JvbGxpbmcgPSBzZXRJbnRlcnZhbCgoKSA9PiB0aGlzLnNjcm9sbCgpLCA1MCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHRoaXMuc2Nyb2xsaW5nID4gLTEpIHtcclxuICAgICAgICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLnNjcm9sbGluZyk7XHJcbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsaW5nID0gLTE7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgc2Nyb2xsKCkge1xyXG4gICAgICAgIGlmICh0aGlzLnNjcm9sbFBhcmVudCkge1xyXG4gICAgICAgICAgICB0aGlzLnNjcm9sbFBhcmVudC5zY3JvbGxMZWZ0ICs9IHRoaXMuc2Nyb2xsU3BlZWQueDtcclxuICAgICAgICAgICAgdGhpcy5zY3JvbGxQYXJlbnQuc2Nyb2xsVG9wICs9IHRoaXMuc2Nyb2xsU3BlZWQueTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMudmlldy53aW4uc2Nyb2xsQnkodGhpcy5zY3JvbGxTcGVlZC54LCB0aGlzLnNjcm9sbFNwZWVkLnkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5kcmFnZ2luZyA9PT0gZmFsc2UpXHJcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0KHRoaXMubGFzdEV2ZW50KTtcclxuICAgIH1cclxuICAgIHNlbGVjdChldmVudCkge1xyXG4gICAgICAgIGxldCBzZWxlY3Rpb24gPSB0aGlzLnN0eWxlLmdldChldmVudCwgdGhpcy5leHRlbmQsIHRoaXMubXVsdGlwbGUpO1xyXG4gICAgICAgIGlmICh0aGlzLm11c3RTZWxlY3QgfHwgIXNlbGVjdGlvbi5lcSh0aGlzLnZpZXcuc3RhdGUuc2VsZWN0aW9uKSB8fFxyXG4gICAgICAgICAgICBzZWxlY3Rpb24ubWFpbi5hc3NvYyAhPSB0aGlzLnZpZXcuc3RhdGUuc2VsZWN0aW9uLm1haW4uYXNzb2MpXHJcbiAgICAgICAgICAgIHRoaXMudmlldy5kaXNwYXRjaCh7XHJcbiAgICAgICAgICAgICAgICBzZWxlY3Rpb24sXHJcbiAgICAgICAgICAgICAgICB1c2VyRXZlbnQ6IFwic2VsZWN0LnBvaW50ZXJcIlxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLm11c3RTZWxlY3QgPSBmYWxzZTtcclxuICAgIH1cclxuICAgIHVwZGF0ZSh1cGRhdGUpIHtcclxuICAgICAgICBpZiAodXBkYXRlLmRvY0NoYW5nZWQgJiYgdGhpcy5kcmFnZ2luZylcclxuICAgICAgICAgICAgdGhpcy5kcmFnZ2luZyA9IHRoaXMuZHJhZ2dpbmcubWFwKHVwZGF0ZS5jaGFuZ2VzKTtcclxuICAgICAgICBpZiAodGhpcy5zdHlsZS51cGRhdGUodXBkYXRlKSlcclxuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB0aGlzLnNlbGVjdCh0aGlzLmxhc3RFdmVudCksIDIwKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBhZGRzU2VsZWN0aW9uUmFuZ2UodmlldywgZXZlbnQpIHtcclxuICAgIGxldCBmYWNldCA9IHZpZXcuc3RhdGUuZmFjZXQoY2xpY2tBZGRzU2VsZWN0aW9uUmFuZ2UpO1xyXG4gICAgcmV0dXJuIGZhY2V0Lmxlbmd0aCA/IGZhY2V0WzBdKGV2ZW50KSA6IGJyb3dzZXIubWFjID8gZXZlbnQubWV0YUtleSA6IGV2ZW50LmN0cmxLZXk7XHJcbn1cclxuZnVuY3Rpb24gZHJhZ01vdmVzU2VsZWN0aW9uKHZpZXcsIGV2ZW50KSB7XHJcbiAgICBsZXQgZmFjZXQgPSB2aWV3LnN0YXRlLmZhY2V0KGRyYWdNb3Zlc1NlbGVjdGlvbiQxKTtcclxuICAgIHJldHVybiBmYWNldC5sZW5ndGggPyBmYWNldFswXShldmVudCkgOiBicm93c2VyLm1hYyA/ICFldmVudC5hbHRLZXkgOiAhZXZlbnQuY3RybEtleTtcclxufVxyXG5mdW5jdGlvbiBpc0luUHJpbWFyeVNlbGVjdGlvbih2aWV3LCBldmVudCkge1xyXG4gICAgbGV0IHsgbWFpbiB9ID0gdmlldy5zdGF0ZS5zZWxlY3Rpb247XHJcbiAgICBpZiAobWFpbi5lbXB0eSlcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAvLyBPbiBib3VuZGFyeSBjbGlja3MsIGNoZWNrIHdoZXRoZXIgdGhlIGNvb3JkaW5hdGVzIGFyZSBpbnNpZGUgdGhlXHJcbiAgICAvLyBzZWxlY3Rpb24ncyBjbGllbnQgcmVjdGFuZ2xlc1xyXG4gICAgbGV0IHNlbCA9IGdldFNlbGVjdGlvbih2aWV3LnJvb3QpO1xyXG4gICAgaWYgKCFzZWwgfHwgc2VsLnJhbmdlQ291bnQgPT0gMClcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIGxldCByZWN0cyA9IHNlbC5nZXRSYW5nZUF0KDApLmdldENsaWVudFJlY3RzKCk7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJlY3RzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgbGV0IHJlY3QgPSByZWN0c1tpXTtcclxuICAgICAgICBpZiAocmVjdC5sZWZ0IDw9IGV2ZW50LmNsaWVudFggJiYgcmVjdC5yaWdodCA+PSBldmVudC5jbGllbnRYICYmXHJcbiAgICAgICAgICAgIHJlY3QudG9wIDw9IGV2ZW50LmNsaWVudFkgJiYgcmVjdC5ib3R0b20gPj0gZXZlbnQuY2xpZW50WSlcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbn1cclxuZnVuY3Rpb24gZXZlbnRCZWxvbmdzVG9FZGl0b3IodmlldywgZXZlbnQpIHtcclxuICAgIGlmICghZXZlbnQuYnViYmxlcylcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIGlmIChldmVudC5kZWZhdWx0UHJldmVudGVkKVxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIGZvciAobGV0IG5vZGUgPSBldmVudC50YXJnZXQsIGNWaWV3OyBub2RlICE9IHZpZXcuY29udGVudERPTTsgbm9kZSA9IG5vZGUucGFyZW50Tm9kZSlcclxuICAgICAgICBpZiAoIW5vZGUgfHwgbm9kZS5ub2RlVHlwZSA9PSAxMSB8fCAoKGNWaWV3ID0gQ29udGVudFZpZXcuZ2V0KG5vZGUpKSAmJiBjVmlldy5pZ25vcmVFdmVudChldmVudCkpKVxyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICByZXR1cm4gdHJ1ZTtcclxufVxyXG5jb25zdCBoYW5kbGVycyA9IC8qQF9fUFVSRV9fKi9PYmplY3QuY3JlYXRlKG51bGwpO1xyXG5jb25zdCBoYW5kbGVyT3B0aW9ucyA9IC8qQF9fUFVSRV9fKi9PYmplY3QuY3JlYXRlKG51bGwpO1xyXG4vLyBUaGlzIGlzIHZlcnkgY3J1ZGUsIGJ1dCB1bmZvcnR1bmF0ZWx5IGJvdGggdGhlc2UgYnJvd3NlcnMgX3ByZXRlbmRfXHJcbi8vIHRoYXQgdGhleSBoYXZlIGEgY2xpcGJvYXJkIEFQSeKAlGFsbCB0aGUgb2JqZWN0cyBhbmQgbWV0aG9kcyBhcmVcclxuLy8gdGhlcmUsIHRoZXkganVzdCBkb24ndCB3b3JrLCBhbmQgdGhleSBhcmUgaGFyZCB0byB0ZXN0LlxyXG5jb25zdCBicm9rZW5DbGlwYm9hcmRBUEkgPSAoYnJvd3Nlci5pZSAmJiBicm93c2VyLmllX3ZlcnNpb24gPCAxNSkgfHxcclxuICAgIChicm93c2VyLmlvcyAmJiBicm93c2VyLndlYmtpdF92ZXJzaW9uIDwgNjA0KTtcclxuZnVuY3Rpb24gY2FwdHVyZVBhc3RlKHZpZXcpIHtcclxuICAgIGxldCBwYXJlbnQgPSB2aWV3LmRvbS5wYXJlbnROb2RlO1xyXG4gICAgaWYgKCFwYXJlbnQpXHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgbGV0IHRhcmdldCA9IHBhcmVudC5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwidGV4dGFyZWFcIikpO1xyXG4gICAgdGFyZ2V0LnN0eWxlLmNzc1RleHQgPSBcInBvc2l0aW9uOiBmaXhlZDsgbGVmdDogLTEwMDAwcHg7IHRvcDogMTBweFwiO1xyXG4gICAgdGFyZ2V0LmZvY3VzKCk7XHJcbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgICB2aWV3LmZvY3VzKCk7XHJcbiAgICAgICAgdGFyZ2V0LnJlbW92ZSgpO1xyXG4gICAgICAgIGRvUGFzdGUodmlldywgdGFyZ2V0LnZhbHVlKTtcclxuICAgIH0sIDUwKTtcclxufVxyXG5mdW5jdGlvbiBkb1Bhc3RlKHZpZXcsIGlucHV0KSB7XHJcbiAgICBsZXQgeyBzdGF0ZSB9ID0gdmlldywgY2hhbmdlcywgaSA9IDEsIHRleHQgPSBzdGF0ZS50b1RleHQoaW5wdXQpO1xyXG4gICAgbGV0IGJ5TGluZSA9IHRleHQubGluZXMgPT0gc3RhdGUuc2VsZWN0aW9uLnJhbmdlcy5sZW5ndGg7XHJcbiAgICBsZXQgbGluZXdpc2UgPSBsYXN0TGluZXdpc2VDb3B5ICE9IG51bGwgJiYgc3RhdGUuc2VsZWN0aW9uLnJhbmdlcy5ldmVyeShyID0+IHIuZW1wdHkpICYmIGxhc3RMaW5ld2lzZUNvcHkgPT0gdGV4dC50b1N0cmluZygpO1xyXG4gICAgaWYgKGxpbmV3aXNlKSB7XHJcbiAgICAgICAgbGV0IGxhc3RMaW5lID0gLTE7XHJcbiAgICAgICAgY2hhbmdlcyA9IHN0YXRlLmNoYW5nZUJ5UmFuZ2UocmFuZ2UgPT4ge1xyXG4gICAgICAgICAgICBsZXQgbGluZSA9IHN0YXRlLmRvYy5saW5lQXQocmFuZ2UuZnJvbSk7XHJcbiAgICAgICAgICAgIGlmIChsaW5lLmZyb20gPT0gbGFzdExpbmUpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4geyByYW5nZSB9O1xyXG4gICAgICAgICAgICBsYXN0TGluZSA9IGxpbmUuZnJvbTtcclxuICAgICAgICAgICAgbGV0IGluc2VydCA9IHN0YXRlLnRvVGV4dCgoYnlMaW5lID8gdGV4dC5saW5lKGkrKykudGV4dCA6IGlucHV0KSArIHN0YXRlLmxpbmVCcmVhayk7XHJcbiAgICAgICAgICAgIHJldHVybiB7IGNoYW5nZXM6IHsgZnJvbTogbGluZS5mcm9tLCBpbnNlcnQgfSxcclxuICAgICAgICAgICAgICAgIHJhbmdlOiBFZGl0b3JTZWxlY3Rpb24uY3Vyc29yKHJhbmdlLmZyb20gKyBpbnNlcnQubGVuZ3RoKSB9O1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoYnlMaW5lKSB7XHJcbiAgICAgICAgY2hhbmdlcyA9IHN0YXRlLmNoYW5nZUJ5UmFuZ2UocmFuZ2UgPT4ge1xyXG4gICAgICAgICAgICBsZXQgbGluZSA9IHRleHQubGluZShpKyspO1xyXG4gICAgICAgICAgICByZXR1cm4geyBjaGFuZ2VzOiB7IGZyb206IHJhbmdlLmZyb20sIHRvOiByYW5nZS50bywgaW5zZXJ0OiBsaW5lLnRleHQgfSxcclxuICAgICAgICAgICAgICAgIHJhbmdlOiBFZGl0b3JTZWxlY3Rpb24uY3Vyc29yKHJhbmdlLmZyb20gKyBsaW5lLmxlbmd0aCkgfTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGNoYW5nZXMgPSBzdGF0ZS5yZXBsYWNlU2VsZWN0aW9uKHRleHQpO1xyXG4gICAgfVxyXG4gICAgdmlldy5kaXNwYXRjaChjaGFuZ2VzLCB7XHJcbiAgICAgICAgdXNlckV2ZW50OiBcImlucHV0LnBhc3RlXCIsXHJcbiAgICAgICAgc2Nyb2xsSW50b1ZpZXc6IHRydWVcclxuICAgIH0pO1xyXG59XHJcbmhhbmRsZXJzLmtleWRvd24gPSAodmlldywgZXZlbnQpID0+IHtcclxuICAgIHZpZXcuaW5wdXRTdGF0ZS5zZXRTZWxlY3Rpb25PcmlnaW4oXCJzZWxlY3RcIik7XHJcbiAgICBpZiAoZXZlbnQua2V5Q29kZSA9PSAyNylcclxuICAgICAgICB2aWV3LmlucHV0U3RhdGUubGFzdEVzY1ByZXNzID0gRGF0ZS5ub3coKTtcclxuICAgIGVsc2UgaWYgKG1vZGlmaWVyQ29kZXMuaW5kZXhPZihldmVudC5rZXlDb2RlKSA8IDApXHJcbiAgICAgICAgdmlldy5pbnB1dFN0YXRlLmxhc3RFc2NQcmVzcyA9IDA7XHJcbn07XHJcbmhhbmRsZXJzLnRvdWNoc3RhcnQgPSAodmlldywgZSkgPT4ge1xyXG4gICAgdmlldy5pbnB1dFN0YXRlLmxhc3RUb3VjaFRpbWUgPSBEYXRlLm5vdygpO1xyXG4gICAgdmlldy5pbnB1dFN0YXRlLnNldFNlbGVjdGlvbk9yaWdpbihcInNlbGVjdC5wb2ludGVyXCIpO1xyXG59O1xyXG5oYW5kbGVycy50b3VjaG1vdmUgPSB2aWV3ID0+IHtcclxuICAgIHZpZXcuaW5wdXRTdGF0ZS5zZXRTZWxlY3Rpb25PcmlnaW4oXCJzZWxlY3QucG9pbnRlclwiKTtcclxufTtcclxuaGFuZGxlck9wdGlvbnMudG91Y2hzdGFydCA9IGhhbmRsZXJPcHRpb25zLnRvdWNobW92ZSA9IHsgcGFzc2l2ZTogdHJ1ZSB9O1xyXG5oYW5kbGVycy5tb3VzZWRvd24gPSAodmlldywgZXZlbnQpID0+IHtcclxuICAgIHZpZXcub2JzZXJ2ZXIuZmx1c2goKTtcclxuICAgIGlmICh2aWV3LmlucHV0U3RhdGUubGFzdFRvdWNoVGltZSA+IERhdGUubm93KCkgLSAyMDAwKVxyXG4gICAgICAgIHJldHVybjsgLy8gSWdub3JlIHRvdWNoIGludGVyYWN0aW9uXHJcbiAgICBsZXQgc3R5bGUgPSBudWxsO1xyXG4gICAgZm9yIChsZXQgbWFrZVN0eWxlIG9mIHZpZXcuc3RhdGUuZmFjZXQobW91c2VTZWxlY3Rpb25TdHlsZSkpIHtcclxuICAgICAgICBzdHlsZSA9IG1ha2VTdHlsZSh2aWV3LCBldmVudCk7XHJcbiAgICAgICAgaWYgKHN0eWxlKVxyXG4gICAgICAgICAgICBicmVhaztcclxuICAgIH1cclxuICAgIGlmICghc3R5bGUgJiYgZXZlbnQuYnV0dG9uID09IDApXHJcbiAgICAgICAgc3R5bGUgPSBiYXNpY01vdXNlU2VsZWN0aW9uKHZpZXcsIGV2ZW50KTtcclxuICAgIGlmIChzdHlsZSkge1xyXG4gICAgICAgIGxldCBtdXN0Rm9jdXMgPSB2aWV3LnJvb3QuYWN0aXZlRWxlbWVudCAhPSB2aWV3LmNvbnRlbnRET007XHJcbiAgICAgICAgaWYgKG11c3RGb2N1cylcclxuICAgICAgICAgICAgdmlldy5vYnNlcnZlci5pZ25vcmUoKCkgPT4gZm9jdXNQcmV2ZW50U2Nyb2xsKHZpZXcuY29udGVudERPTSkpO1xyXG4gICAgICAgIHZpZXcuaW5wdXRTdGF0ZS5zdGFydE1vdXNlU2VsZWN0aW9uKG5ldyBNb3VzZVNlbGVjdGlvbih2aWV3LCBldmVudCwgc3R5bGUsIG11c3RGb2N1cykpO1xyXG4gICAgfVxyXG59O1xyXG5mdW5jdGlvbiByYW5nZUZvckNsaWNrKHZpZXcsIHBvcywgYmlhcywgdHlwZSkge1xyXG4gICAgaWYgKHR5cGUgPT0gMSkgeyAvLyBTaW5nbGUgY2xpY2tcclxuICAgICAgICByZXR1cm4gRWRpdG9yU2VsZWN0aW9uLmN1cnNvcihwb3MsIGJpYXMpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAodHlwZSA9PSAyKSB7IC8vIERvdWJsZSBjbGlja1xyXG4gICAgICAgIHJldHVybiBncm91cEF0KHZpZXcuc3RhdGUsIHBvcywgYmlhcyk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHsgLy8gVHJpcGxlIGNsaWNrXHJcbiAgICAgICAgbGV0IHZpc3VhbCA9IExpbmVWaWV3LmZpbmQodmlldy5kb2NWaWV3LCBwb3MpLCBsaW5lID0gdmlldy5zdGF0ZS5kb2MubGluZUF0KHZpc3VhbCA/IHZpc3VhbC5wb3NBdEVuZCA6IHBvcyk7XHJcbiAgICAgICAgbGV0IGZyb20gPSB2aXN1YWwgPyB2aXN1YWwucG9zQXRTdGFydCA6IGxpbmUuZnJvbSwgdG8gPSB2aXN1YWwgPyB2aXN1YWwucG9zQXRFbmQgOiBsaW5lLnRvO1xyXG4gICAgICAgIGlmICh0byA8IHZpZXcuc3RhdGUuZG9jLmxlbmd0aCAmJiB0byA9PSBsaW5lLnRvKVxyXG4gICAgICAgICAgICB0bysrO1xyXG4gICAgICAgIHJldHVybiBFZGl0b3JTZWxlY3Rpb24ucmFuZ2UoZnJvbSwgdG8pO1xyXG4gICAgfVxyXG59XHJcbmxldCBpbnNpZGVZID0gKHksIHJlY3QpID0+IHkgPj0gcmVjdC50b3AgJiYgeSA8PSByZWN0LmJvdHRvbTtcclxubGV0IGluc2lkZSA9ICh4LCB5LCByZWN0KSA9PiBpbnNpZGVZKHksIHJlY3QpICYmIHggPj0gcmVjdC5sZWZ0ICYmIHggPD0gcmVjdC5yaWdodDtcclxuLy8gVHJ5IHRvIGRldGVybWluZSwgZm9yIHRoZSBnaXZlbiBjb29yZGluYXRlcywgYXNzb2NpYXRlZCB3aXRoIHRoZVxyXG4vLyBnaXZlbiBwb3NpdGlvbiwgd2hldGhlciB0aGV5IGFyZSByZWxhdGVkIHRvIHRoZSBlbGVtZW50IGJlZm9yZSBvclxyXG4vLyB0aGUgZWxlbWVudCBhZnRlciB0aGUgcG9zaXRpb24uXHJcbmZ1bmN0aW9uIGZpbmRQb3NpdGlvblNpZGUodmlldywgcG9zLCB4LCB5KSB7XHJcbiAgICBsZXQgbGluZSA9IExpbmVWaWV3LmZpbmQodmlldy5kb2NWaWV3LCBwb3MpO1xyXG4gICAgaWYgKCFsaW5lKVxyXG4gICAgICAgIHJldHVybiAxO1xyXG4gICAgbGV0IG9mZiA9IHBvcyAtIGxpbmUucG9zQXRTdGFydDtcclxuICAgIC8vIExpbmUgYm91bmRhcmllcyBwb2ludCBpbnRvIHRoZSBsaW5lXHJcbiAgICBpZiAob2ZmID09IDApXHJcbiAgICAgICAgcmV0dXJuIDE7XHJcbiAgICBpZiAob2ZmID09IGxpbmUubGVuZ3RoKVxyXG4gICAgICAgIHJldHVybiAtMTtcclxuICAgIC8vIFBvc2l0aW9ucyBvbiB0b3Agb2YgYW4gZWxlbWVudCBwb2ludCBhdCB0aGF0IGVsZW1lbnRcclxuICAgIGxldCBiZWZvcmUgPSBsaW5lLmNvb3Jkc0F0KG9mZiwgLTEpO1xyXG4gICAgaWYgKGJlZm9yZSAmJiBpbnNpZGUoeCwgeSwgYmVmb3JlKSlcclxuICAgICAgICByZXR1cm4gLTE7XHJcbiAgICBsZXQgYWZ0ZXIgPSBsaW5lLmNvb3Jkc0F0KG9mZiwgMSk7XHJcbiAgICBpZiAoYWZ0ZXIgJiYgaW5zaWRlKHgsIHksIGFmdGVyKSlcclxuICAgICAgICByZXR1cm4gMTtcclxuICAgIC8vIFRoaXMgaXMgcHJvYmFibHkgYSBsaW5lIHdyYXAgcG9pbnQuIFBpY2sgYmVmb3JlIGlmIHRoZSBwb2ludCBpc1xyXG4gICAgLy8gYmVzaWRlIGl0LlxyXG4gICAgcmV0dXJuIGJlZm9yZSAmJiBpbnNpZGVZKHksIGJlZm9yZSkgPyAtMSA6IDE7XHJcbn1cclxuZnVuY3Rpb24gcXVlcnlQb3ModmlldywgZXZlbnQpIHtcclxuICAgIGxldCBwb3MgPSB2aWV3LnBvc0F0Q29vcmRzKHsgeDogZXZlbnQuY2xpZW50WCwgeTogZXZlbnQuY2xpZW50WSB9LCBmYWxzZSk7XHJcbiAgICByZXR1cm4geyBwb3MsIGJpYXM6IGZpbmRQb3NpdGlvblNpZGUodmlldywgcG9zLCBldmVudC5jbGllbnRYLCBldmVudC5jbGllbnRZKSB9O1xyXG59XHJcbmNvbnN0IEJhZE1vdXNlRGV0YWlsID0gYnJvd3Nlci5pZSAmJiBicm93c2VyLmllX3ZlcnNpb24gPD0gMTE7XHJcbmxldCBsYXN0TW91c2VEb3duID0gbnVsbCwgbGFzdE1vdXNlRG93bkNvdW50ID0gMCwgbGFzdE1vdXNlRG93blRpbWUgPSAwO1xyXG5mdW5jdGlvbiBnZXRDbGlja1R5cGUoZXZlbnQpIHtcclxuICAgIGlmICghQmFkTW91c2VEZXRhaWwpXHJcbiAgICAgICAgcmV0dXJuIGV2ZW50LmRldGFpbDtcclxuICAgIGxldCBsYXN0ID0gbGFzdE1vdXNlRG93biwgbGFzdFRpbWUgPSBsYXN0TW91c2VEb3duVGltZTtcclxuICAgIGxhc3RNb3VzZURvd24gPSBldmVudDtcclxuICAgIGxhc3RNb3VzZURvd25UaW1lID0gRGF0ZS5ub3coKTtcclxuICAgIHJldHVybiBsYXN0TW91c2VEb3duQ291bnQgPSAhbGFzdCB8fCAobGFzdFRpbWUgPiBEYXRlLm5vdygpIC0gNDAwICYmIE1hdGguYWJzKGxhc3QuY2xpZW50WCAtIGV2ZW50LmNsaWVudFgpIDwgMiAmJlxyXG4gICAgICAgIE1hdGguYWJzKGxhc3QuY2xpZW50WSAtIGV2ZW50LmNsaWVudFkpIDwgMikgPyAobGFzdE1vdXNlRG93bkNvdW50ICsgMSkgJSAzIDogMTtcclxufVxyXG5mdW5jdGlvbiBiYXNpY01vdXNlU2VsZWN0aW9uKHZpZXcsIGV2ZW50KSB7XHJcbiAgICBsZXQgc3RhcnQgPSBxdWVyeVBvcyh2aWV3LCBldmVudCksIHR5cGUgPSBnZXRDbGlja1R5cGUoZXZlbnQpO1xyXG4gICAgbGV0IHN0YXJ0U2VsID0gdmlldy5zdGF0ZS5zZWxlY3Rpb247XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHVwZGF0ZSh1cGRhdGUpIHtcclxuICAgICAgICAgICAgaWYgKHVwZGF0ZS5kb2NDaGFuZ2VkKSB7XHJcbiAgICAgICAgICAgICAgICBzdGFydC5wb3MgPSB1cGRhdGUuY2hhbmdlcy5tYXBQb3Moc3RhcnQucG9zKTtcclxuICAgICAgICAgICAgICAgIHN0YXJ0U2VsID0gc3RhcnRTZWwubWFwKHVwZGF0ZS5jaGFuZ2VzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZ2V0KGV2ZW50LCBleHRlbmQsIG11bHRpcGxlKSB7XHJcbiAgICAgICAgICAgIGxldCBjdXIgPSBxdWVyeVBvcyh2aWV3LCBldmVudCk7XHJcbiAgICAgICAgICAgIGxldCByYW5nZSA9IHJhbmdlRm9yQ2xpY2sodmlldywgY3VyLnBvcywgY3VyLmJpYXMsIHR5cGUpO1xyXG4gICAgICAgICAgICBpZiAoc3RhcnQucG9zICE9IGN1ci5wb3MgJiYgIWV4dGVuZCkge1xyXG4gICAgICAgICAgICAgICAgbGV0IHN0YXJ0UmFuZ2UgPSByYW5nZUZvckNsaWNrKHZpZXcsIHN0YXJ0LnBvcywgc3RhcnQuYmlhcywgdHlwZSk7XHJcbiAgICAgICAgICAgICAgICBsZXQgZnJvbSA9IE1hdGgubWluKHN0YXJ0UmFuZ2UuZnJvbSwgcmFuZ2UuZnJvbSksIHRvID0gTWF0aC5tYXgoc3RhcnRSYW5nZS50bywgcmFuZ2UudG8pO1xyXG4gICAgICAgICAgICAgICAgcmFuZ2UgPSBmcm9tIDwgcmFuZ2UuZnJvbSA/IEVkaXRvclNlbGVjdGlvbi5yYW5nZShmcm9tLCB0bykgOiBFZGl0b3JTZWxlY3Rpb24ucmFuZ2UodG8sIGZyb20pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChleHRlbmQpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RhcnRTZWwucmVwbGFjZVJhbmdlKHN0YXJ0U2VsLm1haW4uZXh0ZW5kKHJhbmdlLmZyb20sIHJhbmdlLnRvKSk7XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKG11bHRpcGxlICYmIHN0YXJ0U2VsLnJhbmdlcy5sZW5ndGggPiAxICYmIHN0YXJ0U2VsLnJhbmdlcy5zb21lKHIgPT4gci5lcShyYW5nZSkpKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlbW92ZVJhbmdlKHN0YXJ0U2VsLCByYW5nZSk7XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKG11bHRpcGxlKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0YXJ0U2VsLmFkZFJhbmdlKHJhbmdlKTtcclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIEVkaXRvclNlbGVjdGlvbi5jcmVhdGUoW3JhbmdlXSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiByZW1vdmVSYW5nZShzZWwsIHJhbmdlKSB7XHJcbiAgICBmb3IgKGxldCBpID0gMDs7IGkrKykge1xyXG4gICAgICAgIGlmIChzZWwucmFuZ2VzW2ldLmVxKHJhbmdlKSlcclxuICAgICAgICAgICAgcmV0dXJuIEVkaXRvclNlbGVjdGlvbi5jcmVhdGUoc2VsLnJhbmdlcy5zbGljZSgwLCBpKS5jb25jYXQoc2VsLnJhbmdlcy5zbGljZShpICsgMSkpLCBzZWwubWFpbkluZGV4ID09IGkgPyAwIDogc2VsLm1haW5JbmRleCAtIChzZWwubWFpbkluZGV4ID4gaSA/IDEgOiAwKSk7XHJcbiAgICB9XHJcbn1cclxuaGFuZGxlcnMuZHJhZ3N0YXJ0ID0gKHZpZXcsIGV2ZW50KSA9PiB7XHJcbiAgICBsZXQgeyBzZWxlY3Rpb246IHsgbWFpbiB9IH0gPSB2aWV3LnN0YXRlO1xyXG4gICAgbGV0IHsgbW91c2VTZWxlY3Rpb24gfSA9IHZpZXcuaW5wdXRTdGF0ZTtcclxuICAgIGlmIChtb3VzZVNlbGVjdGlvbilcclxuICAgICAgICBtb3VzZVNlbGVjdGlvbi5kcmFnZ2luZyA9IG1haW47XHJcbiAgICBpZiAoZXZlbnQuZGF0YVRyYW5zZmVyKSB7XHJcbiAgICAgICAgZXZlbnQuZGF0YVRyYW5zZmVyLnNldERhdGEoXCJUZXh0XCIsIHZpZXcuc3RhdGUuc2xpY2VEb2MobWFpbi5mcm9tLCBtYWluLnRvKSk7XHJcbiAgICAgICAgZXZlbnQuZGF0YVRyYW5zZmVyLmVmZmVjdEFsbG93ZWQgPSBcImNvcHlNb3ZlXCI7XHJcbiAgICB9XHJcbn07XHJcbmZ1bmN0aW9uIGRyb3BUZXh0KHZpZXcsIGV2ZW50LCB0ZXh0LCBkaXJlY3QpIHtcclxuICAgIGlmICghdGV4dClcclxuICAgICAgICByZXR1cm47XHJcbiAgICBsZXQgZHJvcFBvcyA9IHZpZXcucG9zQXRDb29yZHMoeyB4OiBldmVudC5jbGllbnRYLCB5OiBldmVudC5jbGllbnRZIH0sIGZhbHNlKTtcclxuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICBsZXQgeyBtb3VzZVNlbGVjdGlvbiB9ID0gdmlldy5pbnB1dFN0YXRlO1xyXG4gICAgbGV0IGRlbCA9IGRpcmVjdCAmJiBtb3VzZVNlbGVjdGlvbiAmJiBtb3VzZVNlbGVjdGlvbi5kcmFnZ2luZyAmJiBtb3VzZVNlbGVjdGlvbi5kcmFnTW92ZSA/XHJcbiAgICAgICAgeyBmcm9tOiBtb3VzZVNlbGVjdGlvbi5kcmFnZ2luZy5mcm9tLCB0bzogbW91c2VTZWxlY3Rpb24uZHJhZ2dpbmcudG8gfSA6IG51bGw7XHJcbiAgICBsZXQgaW5zID0geyBmcm9tOiBkcm9wUG9zLCBpbnNlcnQ6IHRleHQgfTtcclxuICAgIGxldCBjaGFuZ2VzID0gdmlldy5zdGF0ZS5jaGFuZ2VzKGRlbCA/IFtkZWwsIGluc10gOiBpbnMpO1xyXG4gICAgdmlldy5mb2N1cygpO1xyXG4gICAgdmlldy5kaXNwYXRjaCh7XHJcbiAgICAgICAgY2hhbmdlcyxcclxuICAgICAgICBzZWxlY3Rpb246IHsgYW5jaG9yOiBjaGFuZ2VzLm1hcFBvcyhkcm9wUG9zLCAtMSksIGhlYWQ6IGNoYW5nZXMubWFwUG9zKGRyb3BQb3MsIDEpIH0sXHJcbiAgICAgICAgdXNlckV2ZW50OiBkZWwgPyBcIm1vdmUuZHJvcFwiIDogXCJpbnB1dC5kcm9wXCJcclxuICAgIH0pO1xyXG59XHJcbmhhbmRsZXJzLmRyb3AgPSAodmlldywgZXZlbnQpID0+IHtcclxuICAgIGlmICghZXZlbnQuZGF0YVRyYW5zZmVyKVxyXG4gICAgICAgIHJldHVybjtcclxuICAgIGlmICh2aWV3LnN0YXRlLnJlYWRPbmx5KVxyXG4gICAgICAgIHJldHVybiBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgbGV0IGZpbGVzID0gZXZlbnQuZGF0YVRyYW5zZmVyLmZpbGVzO1xyXG4gICAgaWYgKGZpbGVzICYmIGZpbGVzLmxlbmd0aCkgeyAvLyBGb3IgYSBmaWxlIGRyb3AsIHJlYWQgdGhlIGZpbGUncyB0ZXh0LlxyXG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgbGV0IHRleHQgPSBBcnJheShmaWxlcy5sZW5ndGgpLCByZWFkID0gMDtcclxuICAgICAgICBsZXQgZmluaXNoRmlsZSA9ICgpID0+IHtcclxuICAgICAgICAgICAgaWYgKCsrcmVhZCA9PSBmaWxlcy5sZW5ndGgpXHJcbiAgICAgICAgICAgICAgICBkcm9wVGV4dCh2aWV3LCBldmVudCwgdGV4dC5maWx0ZXIocyA9PiBzICE9IG51bGwpLmpvaW4odmlldy5zdGF0ZS5saW5lQnJlYWspLCBmYWxzZSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGZpbGVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGxldCByZWFkZXIgPSBuZXcgRmlsZVJlYWRlcjtcclxuICAgICAgICAgICAgcmVhZGVyLm9uZXJyb3IgPSBmaW5pc2hGaWxlO1xyXG4gICAgICAgICAgICByZWFkZXIub25sb2FkID0gKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKCEvW1xceDAwLVxceDA4XFx4MGUtXFx4MWZdezJ9Ly50ZXN0KHJlYWRlci5yZXN1bHQpKVxyXG4gICAgICAgICAgICAgICAgICAgIHRleHRbaV0gPSByZWFkZXIucmVzdWx0O1xyXG4gICAgICAgICAgICAgICAgZmluaXNoRmlsZSgpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICByZWFkZXIucmVhZEFzVGV4dChmaWxlc1tpXSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgZHJvcFRleHQodmlldywgZXZlbnQsIGV2ZW50LmRhdGFUcmFuc2Zlci5nZXREYXRhKFwiVGV4dFwiKSwgdHJ1ZSk7XHJcbiAgICB9XHJcbn07XHJcbmhhbmRsZXJzLnBhc3RlID0gKHZpZXcsIGV2ZW50KSA9PiB7XHJcbiAgICBpZiAodmlldy5zdGF0ZS5yZWFkT25seSlcclxuICAgICAgICByZXR1cm4gZXZlbnQucHJldmVudERlZmF1bHQoKTtcclxuICAgIHZpZXcub2JzZXJ2ZXIuZmx1c2goKTtcclxuICAgIGxldCBkYXRhID0gYnJva2VuQ2xpcGJvYXJkQVBJID8gbnVsbCA6IGV2ZW50LmNsaXBib2FyZERhdGE7XHJcbiAgICBpZiAoZGF0YSkge1xyXG4gICAgICAgIGRvUGFzdGUodmlldywgZGF0YS5nZXREYXRhKFwidGV4dC9wbGFpblwiKSk7XHJcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGNhcHR1cmVQYXN0ZSh2aWV3KTtcclxuICAgIH1cclxufTtcclxuZnVuY3Rpb24gY2FwdHVyZUNvcHkodmlldywgdGV4dCkge1xyXG4gICAgLy8gVGhlIGV4dHJhIHdyYXBwZXIgaXMgc29tZWhvdyBuZWNlc3Nhcnkgb24gSUUvRWRnZSB0byBwcmV2ZW50IHRoZVxyXG4gICAgLy8gY29udGVudCBmcm9tIGJlaW5nIG1hbmdsZWQgd2hlbiBpdCBpcyBwdXQgb250byB0aGUgY2xpcGJvYXJkXHJcbiAgICBsZXQgcGFyZW50ID0gdmlldy5kb20ucGFyZW50Tm9kZTtcclxuICAgIGlmICghcGFyZW50KVxyXG4gICAgICAgIHJldHVybjtcclxuICAgIGxldCB0YXJnZXQgPSBwYXJlbnQuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInRleHRhcmVhXCIpKTtcclxuICAgIHRhcmdldC5zdHlsZS5jc3NUZXh0ID0gXCJwb3NpdGlvbjogZml4ZWQ7IGxlZnQ6IC0xMDAwMHB4OyB0b3A6IDEwcHhcIjtcclxuICAgIHRhcmdldC52YWx1ZSA9IHRleHQ7XHJcbiAgICB0YXJnZXQuZm9jdXMoKTtcclxuICAgIHRhcmdldC5zZWxlY3Rpb25FbmQgPSB0ZXh0Lmxlbmd0aDtcclxuICAgIHRhcmdldC5zZWxlY3Rpb25TdGFydCA9IDA7XHJcbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgICB0YXJnZXQucmVtb3ZlKCk7XHJcbiAgICAgICAgdmlldy5mb2N1cygpO1xyXG4gICAgfSwgNTApO1xyXG59XHJcbmZ1bmN0aW9uIGNvcGllZFJhbmdlKHN0YXRlKSB7XHJcbiAgICBsZXQgY29udGVudCA9IFtdLCByYW5nZXMgPSBbXSwgbGluZXdpc2UgPSBmYWxzZTtcclxuICAgIGZvciAobGV0IHJhbmdlIG9mIHN0YXRlLnNlbGVjdGlvbi5yYW5nZXMpXHJcbiAgICAgICAgaWYgKCFyYW5nZS5lbXB0eSkge1xyXG4gICAgICAgICAgICBjb250ZW50LnB1c2goc3RhdGUuc2xpY2VEb2MocmFuZ2UuZnJvbSwgcmFuZ2UudG8pKTtcclxuICAgICAgICAgICAgcmFuZ2VzLnB1c2gocmFuZ2UpO1xyXG4gICAgICAgIH1cclxuICAgIGlmICghY29udGVudC5sZW5ndGgpIHtcclxuICAgICAgICAvLyBOb3RoaW5nIHNlbGVjdGVkLCBkbyBhIGxpbmUtd2lzZSBjb3B5XHJcbiAgICAgICAgbGV0IHVwdG8gPSAtMTtcclxuICAgICAgICBmb3IgKGxldCB7IGZyb20gfSBvZiBzdGF0ZS5zZWxlY3Rpb24ucmFuZ2VzKSB7XHJcbiAgICAgICAgICAgIGxldCBsaW5lID0gc3RhdGUuZG9jLmxpbmVBdChmcm9tKTtcclxuICAgICAgICAgICAgaWYgKGxpbmUubnVtYmVyID4gdXB0bykge1xyXG4gICAgICAgICAgICAgICAgY29udGVudC5wdXNoKGxpbmUudGV4dCk7XHJcbiAgICAgICAgICAgICAgICByYW5nZXMucHVzaCh7IGZyb206IGxpbmUuZnJvbSwgdG86IE1hdGgubWluKHN0YXRlLmRvYy5sZW5ndGgsIGxpbmUudG8gKyAxKSB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB1cHRvID0gbGluZS5udW1iZXI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxpbmV3aXNlID0gdHJ1ZTtcclxuICAgIH1cclxuICAgIHJldHVybiB7IHRleHQ6IGNvbnRlbnQuam9pbihzdGF0ZS5saW5lQnJlYWspLCByYW5nZXMsIGxpbmV3aXNlIH07XHJcbn1cclxubGV0IGxhc3RMaW5ld2lzZUNvcHkgPSBudWxsO1xyXG5oYW5kbGVycy5jb3B5ID0gaGFuZGxlcnMuY3V0ID0gKHZpZXcsIGV2ZW50KSA9PiB7XHJcbiAgICBsZXQgeyB0ZXh0LCByYW5nZXMsIGxpbmV3aXNlIH0gPSBjb3BpZWRSYW5nZSh2aWV3LnN0YXRlKTtcclxuICAgIGlmICghdGV4dCAmJiAhbGluZXdpc2UpXHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgbGFzdExpbmV3aXNlQ29weSA9IGxpbmV3aXNlID8gdGV4dCA6IG51bGw7XHJcbiAgICBsZXQgZGF0YSA9IGJyb2tlbkNsaXBib2FyZEFQSSA/IG51bGwgOiBldmVudC5jbGlwYm9hcmREYXRhO1xyXG4gICAgaWYgKGRhdGEpIHtcclxuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgIGRhdGEuY2xlYXJEYXRhKCk7XHJcbiAgICAgICAgZGF0YS5zZXREYXRhKFwidGV4dC9wbGFpblwiLCB0ZXh0KTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGNhcHR1cmVDb3B5KHZpZXcsIHRleHQpO1xyXG4gICAgfVxyXG4gICAgaWYgKGV2ZW50LnR5cGUgPT0gXCJjdXRcIiAmJiAhdmlldy5zdGF0ZS5yZWFkT25seSlcclxuICAgICAgICB2aWV3LmRpc3BhdGNoKHtcclxuICAgICAgICAgICAgY2hhbmdlczogcmFuZ2VzLFxyXG4gICAgICAgICAgICBzY3JvbGxJbnRvVmlldzogdHJ1ZSxcclxuICAgICAgICAgICAgdXNlckV2ZW50OiBcImRlbGV0ZS5jdXRcIlxyXG4gICAgICAgIH0pO1xyXG59O1xyXG5mdW5jdGlvbiB1cGRhdGVGb3JGb2N1c0NoYW5nZSh2aWV3KSB7XHJcbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgICBpZiAodmlldy5oYXNGb2N1cyAhPSB2aWV3LmlucHV0U3RhdGUubm90aWZpZWRGb2N1c2VkKVxyXG4gICAgICAgICAgICB2aWV3LnVwZGF0ZShbXSk7XHJcbiAgICB9LCAxMCk7XHJcbn1cclxuaGFuZGxlcnMuZm9jdXMgPSB2aWV3ID0+IHtcclxuICAgIHZpZXcuaW5wdXRTdGF0ZS5sYXN0Rm9jdXNUaW1lID0gRGF0ZS5ub3coKTtcclxuICAgIC8vIFdoZW4gZm9jdXNpbmcgcmVzZXQgdGhlIHNjcm9sbCBwb3NpdGlvbiwgbW92ZSBpdCBiYWNrIHRvIHdoZXJlIGl0IHdhc1xyXG4gICAgaWYgKCF2aWV3LnNjcm9sbERPTS5zY3JvbGxUb3AgJiYgKHZpZXcuaW5wdXRTdGF0ZS5sYXN0U2Nyb2xsVG9wIHx8IHZpZXcuaW5wdXRTdGF0ZS5sYXN0U2Nyb2xsTGVmdCkpIHtcclxuICAgICAgICB2aWV3LnNjcm9sbERPTS5zY3JvbGxUb3AgPSB2aWV3LmlucHV0U3RhdGUubGFzdFNjcm9sbFRvcDtcclxuICAgICAgICB2aWV3LnNjcm9sbERPTS5zY3JvbGxMZWZ0ID0gdmlldy5pbnB1dFN0YXRlLmxhc3RTY3JvbGxMZWZ0O1xyXG4gICAgfVxyXG4gICAgdXBkYXRlRm9yRm9jdXNDaGFuZ2Uodmlldyk7XHJcbn07XHJcbmhhbmRsZXJzLmJsdXIgPSB2aWV3ID0+IHtcclxuICAgIHZpZXcub2JzZXJ2ZXIuY2xlYXJTZWxlY3Rpb25SYW5nZSgpO1xyXG4gICAgdXBkYXRlRm9yRm9jdXNDaGFuZ2Uodmlldyk7XHJcbn07XHJcbmhhbmRsZXJzLmNvbXBvc2l0aW9uc3RhcnQgPSBoYW5kbGVycy5jb21wb3NpdGlvbnVwZGF0ZSA9IHZpZXcgPT4ge1xyXG4gICAgaWYgKHZpZXcuaW5wdXRTdGF0ZS5jb21wb3NpdGlvbkZpcnN0Q2hhbmdlID09IG51bGwpXHJcbiAgICAgICAgdmlldy5pbnB1dFN0YXRlLmNvbXBvc2l0aW9uRmlyc3RDaGFuZ2UgPSB0cnVlO1xyXG4gICAgaWYgKHZpZXcuaW5wdXRTdGF0ZS5jb21wb3NpbmcgPCAwKSB7XHJcbiAgICAgICAgLy8gRklYTUUgcG9zc2libHkgc2V0IGEgdGltZW91dCB0byBjbGVhciBpdCBhZ2FpbiBvbiBBbmRyb2lkXHJcbiAgICAgICAgdmlldy5pbnB1dFN0YXRlLmNvbXBvc2luZyA9IDA7XHJcbiAgICB9XHJcbn07XHJcbmhhbmRsZXJzLmNvbXBvc2l0aW9uZW5kID0gdmlldyA9PiB7XHJcbiAgICB2aWV3LmlucHV0U3RhdGUuY29tcG9zaW5nID0gLTE7XHJcbiAgICB2aWV3LmlucHV0U3RhdGUuY29tcG9zaXRpb25FbmRlZEF0ID0gRGF0ZS5ub3coKTtcclxuICAgIHZpZXcuaW5wdXRTdGF0ZS5jb21wb3NpdGlvbkZpcnN0Q2hhbmdlID0gbnVsbDtcclxuICAgIGlmIChicm93c2VyLmNocm9tZSAmJiBicm93c2VyLmFuZHJvaWQpXHJcbiAgICAgICAgdmlldy5vYnNlcnZlci5mbHVzaFNvb24oKTtcclxuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICAgIC8vIEZvcmNlIHRoZSBjb21wb3NpdGlvbiBzdGF0ZSB0byBiZSBjbGVhcmVkIGlmIGl0IGhhc24ndCBhbHJlYWR5IGJlZW5cclxuICAgICAgICBpZiAodmlldy5pbnB1dFN0YXRlLmNvbXBvc2luZyA8IDAgJiYgdmlldy5kb2NWaWV3LmNvbXBvc2l0aW9uRGVjby5zaXplKVxyXG4gICAgICAgICAgICB2aWV3LnVwZGF0ZShbXSk7XHJcbiAgICB9LCA1MCk7XHJcbn07XHJcbmhhbmRsZXJzLmNvbnRleHRtZW51ID0gdmlldyA9PiB7XHJcbiAgICB2aWV3LmlucHV0U3RhdGUubGFzdENvbnRleHRNZW51ID0gRGF0ZS5ub3coKTtcclxufTtcclxuaGFuZGxlcnMuYmVmb3JlaW5wdXQgPSAodmlldywgZXZlbnQpID0+IHtcclxuICAgIHZhciBfYTtcclxuICAgIC8vIEJlY2F1c2UgQ2hyb21lIEFuZHJvaWQgZG9lc24ndCBmaXJlIHVzZWZ1bCBrZXkgZXZlbnRzLCB1c2VcclxuICAgIC8vIGJlZm9yZWlucHV0IHRvIGRldGVjdCBiYWNrc3BhY2UgKGFuZCBwb3NzaWJseSBlbnRlciBhbmQgZGVsZXRlLFxyXG4gICAgLy8gYnV0IHRob3NlIHVzdWFsbHkgZG9uJ3QgZXZlbiBzZWVtIHRvIGZpcmUgYmVmb3JlaW5wdXQgZXZlbnRzIGF0XHJcbiAgICAvLyB0aGUgbW9tZW50KSBhbmQgZmFrZSBhIGtleSBldmVudCBmb3IgaXQuXHJcbiAgICAvL1xyXG4gICAgLy8gKHByZXZlbnREZWZhdWx0IG9uIGJlZm9yZWlucHV0LCB0aG91Z2ggc3VwcG9ydGVkIGluIHRoZSBzcGVjLFxyXG4gICAgLy8gc2VlbXMgdG8gZG8gbm90aGluZyBhdCBhbGwgb24gQ2hyb21lKS5cclxuICAgIGxldCBwZW5kaW5nO1xyXG4gICAgaWYgKGJyb3dzZXIuY2hyb21lICYmIGJyb3dzZXIuYW5kcm9pZCAmJiAocGVuZGluZyA9IFBlbmRpbmdLZXlzLmZpbmQoa2V5ID0+IGtleS5pbnB1dFR5cGUgPT0gZXZlbnQuaW5wdXRUeXBlKSkpIHtcclxuICAgICAgICB2aWV3Lm9ic2VydmVyLmRlbGF5QW5kcm9pZEtleShwZW5kaW5nLmtleSwgcGVuZGluZy5rZXlDb2RlKTtcclxuICAgICAgICBpZiAocGVuZGluZy5rZXkgPT0gXCJCYWNrc3BhY2VcIiB8fCBwZW5kaW5nLmtleSA9PSBcIkRlbGV0ZVwiKSB7XHJcbiAgICAgICAgICAgIGxldCBzdGFydFZpZXdIZWlnaHQgPSAoKF9hID0gd2luZG93LnZpc3VhbFZpZXdwb3J0KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaGVpZ2h0KSB8fCAwO1xyXG4gICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgICAgICAgICAgIHZhciBfYTtcclxuICAgICAgICAgICAgICAgIC8vIEJhY2tzcGFjaW5nIG5lYXIgdW5lZGl0YWJsZSBub2RlcyBvbiBDaHJvbWUgQW5kcm9pZCBzb21ldGltZXNcclxuICAgICAgICAgICAgICAgIC8vIGNsb3NlcyB0aGUgdmlydHVhbCBrZXlib2FyZC4gVGhpcyB0cmllcyB0byBjcnVkZWx5IGRldGVjdFxyXG4gICAgICAgICAgICAgICAgLy8gdGhhdCBhbmQgcmVmb2N1cyB0byBnZXQgaXQgYmFjay5cclxuICAgICAgICAgICAgICAgIGlmICgoKChfYSA9IHdpbmRvdy52aXN1YWxWaWV3cG9ydCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmhlaWdodCkgfHwgMCkgPiBzdGFydFZpZXdIZWlnaHQgKyAxMCAmJiB2aWV3Lmhhc0ZvY3VzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmlldy5jb250ZW50RE9NLmJsdXIoKTtcclxuICAgICAgICAgICAgICAgICAgICB2aWV3LmZvY3VzKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sIDEwMCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59O1xyXG5cclxuY29uc3Qgd3JhcHBpbmdXaGl0ZVNwYWNlID0gW1wicHJlLXdyYXBcIiwgXCJub3JtYWxcIiwgXCJwcmUtbGluZVwiLCBcImJyZWFrLXNwYWNlc1wiXTtcclxuY2xhc3MgSGVpZ2h0T3JhY2xlIHtcclxuICAgIGNvbnN0cnVjdG9yKGxpbmVXcmFwcGluZykge1xyXG4gICAgICAgIHRoaXMubGluZVdyYXBwaW5nID0gbGluZVdyYXBwaW5nO1xyXG4gICAgICAgIHRoaXMuZG9jID0gVGV4dC5lbXB0eTtcclxuICAgICAgICB0aGlzLmhlaWdodFNhbXBsZXMgPSB7fTtcclxuICAgICAgICB0aGlzLmxpbmVIZWlnaHQgPSAxNDtcclxuICAgICAgICB0aGlzLmNoYXJXaWR0aCA9IDc7XHJcbiAgICAgICAgdGhpcy5saW5lTGVuZ3RoID0gMzA7XHJcbiAgICAgICAgLy8gVXNlZCB0byB0cmFjaywgZHVyaW5nIHVwZGF0ZUhlaWdodCwgaWYgYW55IGFjdHVhbCBoZWlnaHRzIGNoYW5nZWRcclxuICAgICAgICB0aGlzLmhlaWdodENoYW5nZWQgPSBmYWxzZTtcclxuICAgIH1cclxuICAgIGhlaWdodEZvckdhcChmcm9tLCB0bykge1xyXG4gICAgICAgIGxldCBsaW5lcyA9IHRoaXMuZG9jLmxpbmVBdCh0bykubnVtYmVyIC0gdGhpcy5kb2MubGluZUF0KGZyb20pLm51bWJlciArIDE7XHJcbiAgICAgICAgaWYgKHRoaXMubGluZVdyYXBwaW5nKVxyXG4gICAgICAgICAgICBsaW5lcyArPSBNYXRoLmNlaWwoKCh0byAtIGZyb20pIC0gKGxpbmVzICogdGhpcy5saW5lTGVuZ3RoICogMC41KSkgLyB0aGlzLmxpbmVMZW5ndGgpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLmxpbmVIZWlnaHQgKiBsaW5lcztcclxuICAgIH1cclxuICAgIGhlaWdodEZvckxpbmUobGVuZ3RoKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLmxpbmVXcmFwcGluZylcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubGluZUhlaWdodDtcclxuICAgICAgICBsZXQgbGluZXMgPSAxICsgTWF0aC5tYXgoMCwgTWF0aC5jZWlsKChsZW5ndGggLSB0aGlzLmxpbmVMZW5ndGgpIC8gKHRoaXMubGluZUxlbmd0aCAtIDUpKSk7XHJcbiAgICAgICAgcmV0dXJuIGxpbmVzICogdGhpcy5saW5lSGVpZ2h0O1xyXG4gICAgfVxyXG4gICAgc2V0RG9jKGRvYykgeyB0aGlzLmRvYyA9IGRvYzsgcmV0dXJuIHRoaXM7IH1cclxuICAgIG11c3RSZWZyZXNoRm9yV3JhcHBpbmcod2hpdGVTcGFjZSkge1xyXG4gICAgICAgIHJldHVybiAod3JhcHBpbmdXaGl0ZVNwYWNlLmluZGV4T2Yod2hpdGVTcGFjZSkgPiAtMSkgIT0gdGhpcy5saW5lV3JhcHBpbmc7XHJcbiAgICB9XHJcbiAgICBtdXN0UmVmcmVzaEZvckhlaWdodHMobGluZUhlaWdodHMpIHtcclxuICAgICAgICBsZXQgbmV3SGVpZ2h0ID0gZmFsc2U7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaW5lSGVpZ2h0cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBsZXQgaCA9IGxpbmVIZWlnaHRzW2ldO1xyXG4gICAgICAgICAgICBpZiAoaCA8IDApIHtcclxuICAgICAgICAgICAgICAgIGkrKztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICghdGhpcy5oZWlnaHRTYW1wbGVzW01hdGguZmxvb3IoaCAqIDEwKV0pIHsgLy8gUm91bmQgdG8gLjEgcGl4ZWxzXHJcbiAgICAgICAgICAgICAgICBuZXdIZWlnaHQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5oZWlnaHRTYW1wbGVzW01hdGguZmxvb3IoaCAqIDEwKV0gPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBuZXdIZWlnaHQ7XHJcbiAgICB9XHJcbiAgICByZWZyZXNoKHdoaXRlU3BhY2UsIGxpbmVIZWlnaHQsIGNoYXJXaWR0aCwgbGluZUxlbmd0aCwga25vd25IZWlnaHRzKSB7XHJcbiAgICAgICAgbGV0IGxpbmVXcmFwcGluZyA9IHdyYXBwaW5nV2hpdGVTcGFjZS5pbmRleE9mKHdoaXRlU3BhY2UpID4gLTE7XHJcbiAgICAgICAgbGV0IGNoYW5nZWQgPSBNYXRoLnJvdW5kKGxpbmVIZWlnaHQpICE9IE1hdGgucm91bmQodGhpcy5saW5lSGVpZ2h0KSB8fCB0aGlzLmxpbmVXcmFwcGluZyAhPSBsaW5lV3JhcHBpbmc7XHJcbiAgICAgICAgdGhpcy5saW5lV3JhcHBpbmcgPSBsaW5lV3JhcHBpbmc7XHJcbiAgICAgICAgdGhpcy5saW5lSGVpZ2h0ID0gbGluZUhlaWdodDtcclxuICAgICAgICB0aGlzLmNoYXJXaWR0aCA9IGNoYXJXaWR0aDtcclxuICAgICAgICB0aGlzLmxpbmVMZW5ndGggPSBsaW5lTGVuZ3RoO1xyXG4gICAgICAgIGlmIChjaGFuZ2VkKSB7XHJcbiAgICAgICAgICAgIHRoaXMuaGVpZ2h0U2FtcGxlcyA9IHt9O1xyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGtub3duSGVpZ2h0cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgbGV0IGggPSBrbm93bkhlaWdodHNbaV07XHJcbiAgICAgICAgICAgICAgICBpZiAoaCA8IDApXHJcbiAgICAgICAgICAgICAgICAgICAgaSsrO1xyXG4gICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaGVpZ2h0U2FtcGxlc1tNYXRoLmZsb29yKGggKiAxMCldID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gY2hhbmdlZDtcclxuICAgIH1cclxufVxyXG4vLyBUaGlzIG9iamVjdCBpcyB1c2VkIGJ5IGB1cGRhdGVIZWlnaHRgIHRvIG1ha2UgRE9NIG1lYXN1cmVtZW50c1xyXG4vLyBhcnJpdmUgYXQgdGhlIHJpZ2h0IG5pZGVzLiBUaGUgYGhlaWdodHNgIGFycmF5IGlzIGEgc2VxdWVuY2Ugb2ZcclxuLy8gYmxvY2sgaGVpZ2h0cywgc3RhcnRpbmcgZnJvbSBwb3NpdGlvbiBgZnJvbWAuXHJcbmNsYXNzIE1lYXN1cmVkSGVpZ2h0cyB7XHJcbiAgICBjb25zdHJ1Y3Rvcihmcm9tLCBoZWlnaHRzKSB7XHJcbiAgICAgICAgdGhpcy5mcm9tID0gZnJvbTtcclxuICAgICAgICB0aGlzLmhlaWdodHMgPSBoZWlnaHRzO1xyXG4gICAgICAgIHRoaXMuaW5kZXggPSAwO1xyXG4gICAgfVxyXG4gICAgZ2V0IG1vcmUoKSB7IHJldHVybiB0aGlzLmluZGV4IDwgdGhpcy5oZWlnaHRzLmxlbmd0aDsgfVxyXG59XHJcbi8qKlxyXG5SZWNvcmQgdXNlZCB0byByZXByZXNlbnQgaW5mb3JtYXRpb24gYWJvdXQgYSBibG9jay1sZXZlbCBlbGVtZW50XHJcbmluIHRoZSBlZGl0b3Igdmlldy5cclxuKi9cclxuY2xhc3MgQmxvY2tJbmZvIHtcclxuICAgIC8qKlxyXG4gICAgQGludGVybmFsXHJcbiAgICAqL1xyXG4gICAgY29uc3RydWN0b3IoXHJcbiAgICAvKipcclxuICAgIFRoZSBzdGFydCBvZiB0aGUgZWxlbWVudCBpbiB0aGUgZG9jdW1lbnQuXHJcbiAgICAqL1xyXG4gICAgZnJvbSwgXHJcbiAgICAvKipcclxuICAgIFRoZSBsZW5ndGggb2YgdGhlIGVsZW1lbnQuXHJcbiAgICAqL1xyXG4gICAgbGVuZ3RoLCBcclxuICAgIC8qKlxyXG4gICAgVGhlIHRvcCBwb3NpdGlvbiBvZiB0aGUgZWxlbWVudCAocmVsYXRpdmUgdG8gdGhlIHRvcCBvZiB0aGVcclxuICAgIGRvY3VtZW50KS5cclxuICAgICovXHJcbiAgICB0b3AsIFxyXG4gICAgLyoqXHJcbiAgICBJdHMgaGVpZ2h0LlxyXG4gICAgKi9cclxuICAgIGhlaWdodCwgXHJcbiAgICAvKipcclxuICAgIFRoZSB0eXBlIG9mIGVsZW1lbnQgdGhpcyBpcy4gV2hlbiBxdWVyeWluZyBsaW5lcywgdGhpcyBtYXkgYmVcclxuICAgIGFuIGFycmF5IG9mIGFsbCB0aGUgYmxvY2tzIHRoYXQgbWFrZSB1cCB0aGUgbGluZS5cclxuICAgICovXHJcbiAgICB0eXBlKSB7XHJcbiAgICAgICAgdGhpcy5mcm9tID0gZnJvbTtcclxuICAgICAgICB0aGlzLmxlbmd0aCA9IGxlbmd0aDtcclxuICAgICAgICB0aGlzLnRvcCA9IHRvcDtcclxuICAgICAgICB0aGlzLmhlaWdodCA9IGhlaWdodDtcclxuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICBUaGUgZW5kIG9mIHRoZSBlbGVtZW50IGFzIGEgZG9jdW1lbnQgcG9zaXRpb24uXHJcbiAgICAqL1xyXG4gICAgZ2V0IHRvKCkgeyByZXR1cm4gdGhpcy5mcm9tICsgdGhpcy5sZW5ndGg7IH1cclxuICAgIC8qKlxyXG4gICAgVGhlIGJvdHRvbSBwb3NpdGlvbiBvZiB0aGUgZWxlbWVudC5cclxuICAgICovXHJcbiAgICBnZXQgYm90dG9tKCkgeyByZXR1cm4gdGhpcy50b3AgKyB0aGlzLmhlaWdodDsgfVxyXG4gICAgLyoqXHJcbiAgICBAaW50ZXJuYWxcclxuICAgICovXHJcbiAgICBqb2luKG90aGVyKSB7XHJcbiAgICAgICAgbGV0IGRldGFpbCA9IChBcnJheS5pc0FycmF5KHRoaXMudHlwZSkgPyB0aGlzLnR5cGUgOiBbdGhpc10pXHJcbiAgICAgICAgICAgIC5jb25jYXQoQXJyYXkuaXNBcnJheShvdGhlci50eXBlKSA/IG90aGVyLnR5cGUgOiBbb3RoZXJdKTtcclxuICAgICAgICByZXR1cm4gbmV3IEJsb2NrSW5mbyh0aGlzLmZyb20sIHRoaXMubGVuZ3RoICsgb3RoZXIubGVuZ3RoLCB0aGlzLnRvcCwgdGhpcy5oZWlnaHQgKyBvdGhlci5oZWlnaHQsIGRldGFpbCk7XHJcbiAgICB9XHJcbn1cclxudmFyIFF1ZXJ5VHlwZSA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKFF1ZXJ5VHlwZSkge1xyXG4gICAgUXVlcnlUeXBlW1F1ZXJ5VHlwZVtcIkJ5UG9zXCJdID0gMF0gPSBcIkJ5UG9zXCI7XHJcbiAgICBRdWVyeVR5cGVbUXVlcnlUeXBlW1wiQnlIZWlnaHRcIl0gPSAxXSA9IFwiQnlIZWlnaHRcIjtcclxuICAgIFF1ZXJ5VHlwZVtRdWVyeVR5cGVbXCJCeVBvc05vSGVpZ2h0XCJdID0gMl0gPSBcIkJ5UG9zTm9IZWlnaHRcIjtcclxucmV0dXJuIFF1ZXJ5VHlwZX0pKFF1ZXJ5VHlwZSB8fCAoUXVlcnlUeXBlID0ge30pKTtcclxuY29uc3QgRXBzaWxvbiA9IDFlLTM7XHJcbmNsYXNzIEhlaWdodE1hcCB7XHJcbiAgICBjb25zdHJ1Y3RvcihsZW5ndGgsIC8vIFRoZSBudW1iZXIgb2YgY2hhcmFjdGVycyBjb3ZlcmVkXHJcbiAgICBoZWlnaHQsIC8vIEhlaWdodCBvZiB0aGlzIHBhcnQgb2YgdGhlIGRvY3VtZW50XHJcbiAgICBmbGFncyA9IDIgLyogRmxhZy5PdXRkYXRlZCAqLykge1xyXG4gICAgICAgIHRoaXMubGVuZ3RoID0gbGVuZ3RoO1xyXG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xyXG4gICAgICAgIHRoaXMuZmxhZ3MgPSBmbGFncztcclxuICAgIH1cclxuICAgIGdldCBvdXRkYXRlZCgpIHsgcmV0dXJuICh0aGlzLmZsYWdzICYgMiAvKiBGbGFnLk91dGRhdGVkICovKSA+IDA7IH1cclxuICAgIHNldCBvdXRkYXRlZCh2YWx1ZSkgeyB0aGlzLmZsYWdzID0gKHZhbHVlID8gMiAvKiBGbGFnLk91dGRhdGVkICovIDogMCkgfCAodGhpcy5mbGFncyAmIH4yIC8qIEZsYWcuT3V0ZGF0ZWQgKi8pOyB9XHJcbiAgICBzZXRIZWlnaHQob3JhY2xlLCBoZWlnaHQpIHtcclxuICAgICAgICBpZiAodGhpcy5oZWlnaHQgIT0gaGVpZ2h0KSB7XHJcbiAgICAgICAgICAgIGlmIChNYXRoLmFicyh0aGlzLmhlaWdodCAtIGhlaWdodCkgPiBFcHNpbG9uKVxyXG4gICAgICAgICAgICAgICAgb3JhY2xlLmhlaWdodENoYW5nZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICB0aGlzLmhlaWdodCA9IGhlaWdodDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvLyBCYXNlIGNhc2UgaXMgdG8gcmVwbGFjZSBhIGxlYWYgbm9kZSwgd2hpY2ggc2ltcGx5IGJ1aWxkcyBhIHRyZWVcclxuICAgIC8vIGZyb20gdGhlIG5ldyBub2RlcyBhbmQgcmV0dXJucyB0aGF0IChIZWlnaHRNYXBCcmFuY2ggYW5kXHJcbiAgICAvLyBIZWlnaHRNYXBHYXAgb3ZlcnJpZGUgdGhpcyB0byBhY3R1YWxseSB1c2UgZnJvbS90bylcclxuICAgIHJlcGxhY2UoX2Zyb20sIF90bywgbm9kZXMpIHtcclxuICAgICAgICByZXR1cm4gSGVpZ2h0TWFwLm9mKG5vZGVzKTtcclxuICAgIH1cclxuICAgIC8vIEFnYWluLCB0aGVzZSBhcmUgYmFzZSBjYXNlcywgYW5kIGFyZSBvdmVycmlkZGVuIGZvciBicmFuY2ggYW5kIGdhcCBub2Rlcy5cclxuICAgIGRlY29tcG9zZUxlZnQoX3RvLCByZXN1bHQpIHsgcmVzdWx0LnB1c2godGhpcyk7IH1cclxuICAgIGRlY29tcG9zZVJpZ2h0KF9mcm9tLCByZXN1bHQpIHsgcmVzdWx0LnB1c2godGhpcyk7IH1cclxuICAgIGFwcGx5Q2hhbmdlcyhkZWNvcmF0aW9ucywgb2xkRG9jLCBvcmFjbGUsIGNoYW5nZXMpIHtcclxuICAgICAgICBsZXQgbWUgPSB0aGlzO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSBjaGFuZ2VzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XHJcbiAgICAgICAgICAgIGxldCB7IGZyb21BLCB0b0EsIGZyb21CLCB0b0IgfSA9IGNoYW5nZXNbaV07XHJcbiAgICAgICAgICAgIGxldCBzdGFydCA9IG1lLmxpbmVBdChmcm9tQSwgUXVlcnlUeXBlLkJ5UG9zTm9IZWlnaHQsIG9sZERvYywgMCwgMCk7XHJcbiAgICAgICAgICAgIGxldCBlbmQgPSBzdGFydC50byA+PSB0b0EgPyBzdGFydCA6IG1lLmxpbmVBdCh0b0EsIFF1ZXJ5VHlwZS5CeVBvc05vSGVpZ2h0LCBvbGREb2MsIDAsIDApO1xyXG4gICAgICAgICAgICB0b0IgKz0gZW5kLnRvIC0gdG9BO1xyXG4gICAgICAgICAgICB0b0EgPSBlbmQudG87XHJcbiAgICAgICAgICAgIHdoaWxlIChpID4gMCAmJiBzdGFydC5mcm9tIDw9IGNoYW5nZXNbaSAtIDFdLnRvQSkge1xyXG4gICAgICAgICAgICAgICAgZnJvbUEgPSBjaGFuZ2VzW2kgLSAxXS5mcm9tQTtcclxuICAgICAgICAgICAgICAgIGZyb21CID0gY2hhbmdlc1tpIC0gMV0uZnJvbUI7XHJcbiAgICAgICAgICAgICAgICBpLS07XHJcbiAgICAgICAgICAgICAgICBpZiAoZnJvbUEgPCBzdGFydC5mcm9tKVxyXG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0ID0gbWUubGluZUF0KGZyb21BLCBRdWVyeVR5cGUuQnlQb3NOb0hlaWdodCwgb2xkRG9jLCAwLCAwKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBmcm9tQiArPSBzdGFydC5mcm9tIC0gZnJvbUE7XHJcbiAgICAgICAgICAgIGZyb21BID0gc3RhcnQuZnJvbTtcclxuICAgICAgICAgICAgbGV0IG5vZGVzID0gTm9kZUJ1aWxkZXIuYnVpbGQob3JhY2xlLCBkZWNvcmF0aW9ucywgZnJvbUIsIHRvQik7XHJcbiAgICAgICAgICAgIG1lID0gbWUucmVwbGFjZShmcm9tQSwgdG9BLCBub2Rlcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBtZS51cGRhdGVIZWlnaHQob3JhY2xlLCAwKTtcclxuICAgIH1cclxuICAgIHN0YXRpYyBlbXB0eSgpIHsgcmV0dXJuIG5ldyBIZWlnaHRNYXBUZXh0KDAsIDApOyB9XHJcbiAgICAvLyBub2RlcyB1c2VzIG51bGwgdmFsdWVzIHRvIGluZGljYXRlIHRoZSBwb3NpdGlvbiBvZiBsaW5lIGJyZWFrcy5cclxuICAgIC8vIFRoZXJlIGFyZSBuZXZlciBsaW5lIGJyZWFrcyBhdCB0aGUgc3RhcnQgb3IgZW5kIG9mIHRoZSBhcnJheSwgb3JcclxuICAgIC8vIHR3byBsaW5lIGJyZWFrcyBuZXh0IHRvIGVhY2ggb3RoZXIsIGFuZCB0aGUgYXJyYXkgaXNuJ3QgYWxsb3dlZFxyXG4gICAgLy8gdG8gYmUgZW1wdHkgKHNhbWUgcmVzdHJpY3Rpb25zIGFzIHJldHVybiB2YWx1ZSBmcm9tIHRoZSBidWlsZGVyKS5cclxuICAgIHN0YXRpYyBvZihub2Rlcykge1xyXG4gICAgICAgIGlmIChub2Rlcy5sZW5ndGggPT0gMSlcclxuICAgICAgICAgICAgcmV0dXJuIG5vZGVzWzBdO1xyXG4gICAgICAgIGxldCBpID0gMCwgaiA9IG5vZGVzLmxlbmd0aCwgYmVmb3JlID0gMCwgYWZ0ZXIgPSAwO1xyXG4gICAgICAgIGZvciAoOzspIHtcclxuICAgICAgICAgICAgaWYgKGkgPT0gaikge1xyXG4gICAgICAgICAgICAgICAgaWYgKGJlZm9yZSA+IGFmdGVyICogMikge1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBzcGxpdCA9IG5vZGVzW2kgLSAxXTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoc3BsaXQuYnJlYWspXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGVzLnNwbGljZSgtLWksIDEsIHNwbGl0LmxlZnQsIG51bGwsIHNwbGl0LnJpZ2h0KTtcclxuICAgICAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGVzLnNwbGljZSgtLWksIDEsIHNwbGl0LmxlZnQsIHNwbGl0LnJpZ2h0KTtcclxuICAgICAgICAgICAgICAgICAgICBqICs9IDEgKyBzcGxpdC5icmVhaztcclxuICAgICAgICAgICAgICAgICAgICBiZWZvcmUgLT0gc3BsaXQuc2l6ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGFmdGVyID4gYmVmb3JlICogMikge1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBzcGxpdCA9IG5vZGVzW2pdO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChzcGxpdC5icmVhaylcclxuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZXMuc3BsaWNlKGosIDEsIHNwbGl0LmxlZnQsIG51bGwsIHNwbGl0LnJpZ2h0KTtcclxuICAgICAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGVzLnNwbGljZShqLCAxLCBzcGxpdC5sZWZ0LCBzcGxpdC5yaWdodCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaiArPSAyICsgc3BsaXQuYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgYWZ0ZXIgLT0gc3BsaXQuc2l6ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGJlZm9yZSA8IGFmdGVyKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgbmV4dCA9IG5vZGVzW2krK107XHJcbiAgICAgICAgICAgICAgICBpZiAobmV4dClcclxuICAgICAgICAgICAgICAgICAgICBiZWZvcmUgKz0gbmV4dC5zaXplO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgbGV0IG5leHQgPSBub2Rlc1stLWpdO1xyXG4gICAgICAgICAgICAgICAgaWYgKG5leHQpXHJcbiAgICAgICAgICAgICAgICAgICAgYWZ0ZXIgKz0gbmV4dC5zaXplO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCBicmsgPSAwO1xyXG4gICAgICAgIGlmIChub2Rlc1tpIC0gMV0gPT0gbnVsbCkge1xyXG4gICAgICAgICAgICBicmsgPSAxO1xyXG4gICAgICAgICAgICBpLS07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKG5vZGVzW2ldID09IG51bGwpIHtcclxuICAgICAgICAgICAgYnJrID0gMTtcclxuICAgICAgICAgICAgaisrO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbmV3IEhlaWdodE1hcEJyYW5jaChIZWlnaHRNYXAub2Yobm9kZXMuc2xpY2UoMCwgaSkpLCBicmssIEhlaWdodE1hcC5vZihub2Rlcy5zbGljZShqKSkpO1xyXG4gICAgfVxyXG59XHJcbkhlaWdodE1hcC5wcm90b3R5cGUuc2l6ZSA9IDE7XHJcbmNsYXNzIEhlaWdodE1hcEJsb2NrIGV4dGVuZHMgSGVpZ2h0TWFwIHtcclxuICAgIGNvbnN0cnVjdG9yKGxlbmd0aCwgaGVpZ2h0LCB0eXBlKSB7XHJcbiAgICAgICAgc3VwZXIobGVuZ3RoLCBoZWlnaHQpO1xyXG4gICAgICAgIHRoaXMudHlwZSA9IHR5cGU7XHJcbiAgICB9XHJcbiAgICBibG9ja0F0KF9oZWlnaHQsIF9kb2MsIHRvcCwgb2Zmc2V0KSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBCbG9ja0luZm8ob2Zmc2V0LCB0aGlzLmxlbmd0aCwgdG9wLCB0aGlzLmhlaWdodCwgdGhpcy50eXBlKTtcclxuICAgIH1cclxuICAgIGxpbmVBdChfdmFsdWUsIF90eXBlLCBkb2MsIHRvcCwgb2Zmc2V0KSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuYmxvY2tBdCgwLCBkb2MsIHRvcCwgb2Zmc2V0KTtcclxuICAgIH1cclxuICAgIGZvckVhY2hMaW5lKGZyb20sIHRvLCBkb2MsIHRvcCwgb2Zmc2V0LCBmKSB7XHJcbiAgICAgICAgaWYgKGZyb20gPD0gb2Zmc2V0ICsgdGhpcy5sZW5ndGggJiYgdG8gPj0gb2Zmc2V0KVxyXG4gICAgICAgICAgICBmKHRoaXMuYmxvY2tBdCgwLCBkb2MsIHRvcCwgb2Zmc2V0KSk7XHJcbiAgICB9XHJcbiAgICB1cGRhdGVIZWlnaHQob3JhY2xlLCBvZmZzZXQgPSAwLCBfZm9yY2UgPSBmYWxzZSwgbWVhc3VyZWQpIHtcclxuICAgICAgICBpZiAobWVhc3VyZWQgJiYgbWVhc3VyZWQuZnJvbSA8PSBvZmZzZXQgJiYgbWVhc3VyZWQubW9yZSlcclxuICAgICAgICAgICAgdGhpcy5zZXRIZWlnaHQob3JhY2xlLCBtZWFzdXJlZC5oZWlnaHRzW21lYXN1cmVkLmluZGV4KytdKTtcclxuICAgICAgICB0aGlzLm91dGRhdGVkID0gZmFsc2U7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbiAgICB0b1N0cmluZygpIHsgcmV0dXJuIGBibG9jaygke3RoaXMubGVuZ3RofSlgOyB9XHJcbn1cclxuY2xhc3MgSGVpZ2h0TWFwVGV4dCBleHRlbmRzIEhlaWdodE1hcEJsb2NrIHtcclxuICAgIGNvbnN0cnVjdG9yKGxlbmd0aCwgaGVpZ2h0KSB7XHJcbiAgICAgICAgc3VwZXIobGVuZ3RoLCBoZWlnaHQsIEJsb2NrVHlwZS5UZXh0KTtcclxuICAgICAgICB0aGlzLmNvbGxhcHNlZCA9IDA7IC8vIEFtb3VudCBvZiBjb2xsYXBzZWQgY29udGVudCBpbiB0aGUgbGluZVxyXG4gICAgICAgIHRoaXMud2lkZ2V0SGVpZ2h0ID0gMDsgLy8gTWF4aW11bSBpbmxpbmUgd2lkZ2V0IGhlaWdodFxyXG4gICAgfVxyXG4gICAgcmVwbGFjZShfZnJvbSwgX3RvLCBub2Rlcykge1xyXG4gICAgICAgIGxldCBub2RlID0gbm9kZXNbMF07XHJcbiAgICAgICAgaWYgKG5vZGVzLmxlbmd0aCA9PSAxICYmIChub2RlIGluc3RhbmNlb2YgSGVpZ2h0TWFwVGV4dCB8fCBub2RlIGluc3RhbmNlb2YgSGVpZ2h0TWFwR2FwICYmIChub2RlLmZsYWdzICYgNCAvKiBGbGFnLlNpbmdsZUxpbmUgKi8pKSAmJlxyXG4gICAgICAgICAgICBNYXRoLmFicyh0aGlzLmxlbmd0aCAtIG5vZGUubGVuZ3RoKSA8IDEwKSB7XHJcbiAgICAgICAgICAgIGlmIChub2RlIGluc3RhbmNlb2YgSGVpZ2h0TWFwR2FwKVxyXG4gICAgICAgICAgICAgICAgbm9kZSA9IG5ldyBIZWlnaHRNYXBUZXh0KG5vZGUubGVuZ3RoLCB0aGlzLmhlaWdodCk7XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgIG5vZGUuaGVpZ2h0ID0gdGhpcy5oZWlnaHQ7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5vdXRkYXRlZClcclxuICAgICAgICAgICAgICAgIG5vZGUub3V0ZGF0ZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgcmV0dXJuIG5vZGU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gSGVpZ2h0TWFwLm9mKG5vZGVzKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICB1cGRhdGVIZWlnaHQob3JhY2xlLCBvZmZzZXQgPSAwLCBmb3JjZSA9IGZhbHNlLCBtZWFzdXJlZCkge1xyXG4gICAgICAgIGlmIChtZWFzdXJlZCAmJiBtZWFzdXJlZC5mcm9tIDw9IG9mZnNldCAmJiBtZWFzdXJlZC5tb3JlKVxyXG4gICAgICAgICAgICB0aGlzLnNldEhlaWdodChvcmFjbGUsIG1lYXN1cmVkLmhlaWdodHNbbWVhc3VyZWQuaW5kZXgrK10pO1xyXG4gICAgICAgIGVsc2UgaWYgKGZvcmNlIHx8IHRoaXMub3V0ZGF0ZWQpXHJcbiAgICAgICAgICAgIHRoaXMuc2V0SGVpZ2h0KG9yYWNsZSwgTWF0aC5tYXgodGhpcy53aWRnZXRIZWlnaHQsIG9yYWNsZS5oZWlnaHRGb3JMaW5lKHRoaXMubGVuZ3RoIC0gdGhpcy5jb2xsYXBzZWQpKSk7XHJcbiAgICAgICAgdGhpcy5vdXRkYXRlZCA9IGZhbHNlO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG4gICAgdG9TdHJpbmcoKSB7XHJcbiAgICAgICAgcmV0dXJuIGBsaW5lKCR7dGhpcy5sZW5ndGh9JHt0aGlzLmNvbGxhcHNlZCA/IC10aGlzLmNvbGxhcHNlZCA6IFwiXCJ9JHt0aGlzLndpZGdldEhlaWdodCA/IFwiOlwiICsgdGhpcy53aWRnZXRIZWlnaHQgOiBcIlwifSlgO1xyXG4gICAgfVxyXG59XHJcbmNsYXNzIEhlaWdodE1hcEdhcCBleHRlbmRzIEhlaWdodE1hcCB7XHJcbiAgICBjb25zdHJ1Y3RvcihsZW5ndGgpIHsgc3VwZXIobGVuZ3RoLCAwKTsgfVxyXG4gICAgbGluZXMoZG9jLCBvZmZzZXQpIHtcclxuICAgICAgICBsZXQgZmlyc3RMaW5lID0gZG9jLmxpbmVBdChvZmZzZXQpLm51bWJlciwgbGFzdExpbmUgPSBkb2MubGluZUF0KG9mZnNldCArIHRoaXMubGVuZ3RoKS5udW1iZXI7XHJcbiAgICAgICAgcmV0dXJuIHsgZmlyc3RMaW5lLCBsYXN0TGluZSwgbGluZUhlaWdodDogdGhpcy5oZWlnaHQgLyAobGFzdExpbmUgLSBmaXJzdExpbmUgKyAxKSB9O1xyXG4gICAgfVxyXG4gICAgYmxvY2tBdChoZWlnaHQsIGRvYywgdG9wLCBvZmZzZXQpIHtcclxuICAgICAgICBsZXQgeyBmaXJzdExpbmUsIGxhc3RMaW5lLCBsaW5lSGVpZ2h0IH0gPSB0aGlzLmxpbmVzKGRvYywgb2Zmc2V0KTtcclxuICAgICAgICBsZXQgbGluZSA9IE1hdGgubWF4KDAsIE1hdGgubWluKGxhc3RMaW5lIC0gZmlyc3RMaW5lLCBNYXRoLmZsb29yKChoZWlnaHQgLSB0b3ApIC8gbGluZUhlaWdodCkpKTtcclxuICAgICAgICBsZXQgeyBmcm9tLCBsZW5ndGggfSA9IGRvYy5saW5lKGZpcnN0TGluZSArIGxpbmUpO1xyXG4gICAgICAgIHJldHVybiBuZXcgQmxvY2tJbmZvKGZyb20sIGxlbmd0aCwgdG9wICsgbGluZUhlaWdodCAqIGxpbmUsIGxpbmVIZWlnaHQsIEJsb2NrVHlwZS5UZXh0KTtcclxuICAgIH1cclxuICAgIGxpbmVBdCh2YWx1ZSwgdHlwZSwgZG9jLCB0b3AsIG9mZnNldCkge1xyXG4gICAgICAgIGlmICh0eXBlID09IFF1ZXJ5VHlwZS5CeUhlaWdodClcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYmxvY2tBdCh2YWx1ZSwgZG9jLCB0b3AsIG9mZnNldCk7XHJcbiAgICAgICAgaWYgKHR5cGUgPT0gUXVlcnlUeXBlLkJ5UG9zTm9IZWlnaHQpIHtcclxuICAgICAgICAgICAgbGV0IHsgZnJvbSwgdG8gfSA9IGRvYy5saW5lQXQodmFsdWUpO1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IEJsb2NrSW5mbyhmcm9tLCB0byAtIGZyb20sIDAsIDAsIEJsb2NrVHlwZS5UZXh0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IHsgZmlyc3RMaW5lLCBsaW5lSGVpZ2h0IH0gPSB0aGlzLmxpbmVzKGRvYywgb2Zmc2V0KTtcclxuICAgICAgICBsZXQgeyBmcm9tLCBsZW5ndGgsIG51bWJlciB9ID0gZG9jLmxpbmVBdCh2YWx1ZSk7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBCbG9ja0luZm8oZnJvbSwgbGVuZ3RoLCB0b3AgKyBsaW5lSGVpZ2h0ICogKG51bWJlciAtIGZpcnN0TGluZSksIGxpbmVIZWlnaHQsIEJsb2NrVHlwZS5UZXh0KTtcclxuICAgIH1cclxuICAgIGZvckVhY2hMaW5lKGZyb20sIHRvLCBkb2MsIHRvcCwgb2Zmc2V0LCBmKSB7XHJcbiAgICAgICAgbGV0IHsgZmlyc3RMaW5lLCBsaW5lSGVpZ2h0IH0gPSB0aGlzLmxpbmVzKGRvYywgb2Zmc2V0KTtcclxuICAgICAgICBmb3IgKGxldCBwb3MgPSBNYXRoLm1heChmcm9tLCBvZmZzZXQpLCBlbmQgPSBNYXRoLm1pbihvZmZzZXQgKyB0aGlzLmxlbmd0aCwgdG8pOyBwb3MgPD0gZW5kOykge1xyXG4gICAgICAgICAgICBsZXQgbGluZSA9IGRvYy5saW5lQXQocG9zKTtcclxuICAgICAgICAgICAgaWYgKHBvcyA9PSBmcm9tKVxyXG4gICAgICAgICAgICAgICAgdG9wICs9IGxpbmVIZWlnaHQgKiAobGluZS5udW1iZXIgLSBmaXJzdExpbmUpO1xyXG4gICAgICAgICAgICBmKG5ldyBCbG9ja0luZm8obGluZS5mcm9tLCBsaW5lLmxlbmd0aCwgdG9wLCBsaW5lSGVpZ2h0LCBCbG9ja1R5cGUuVGV4dCkpO1xyXG4gICAgICAgICAgICB0b3AgKz0gbGluZUhlaWdodDtcclxuICAgICAgICAgICAgcG9zID0gbGluZS50byArIDE7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmVwbGFjZShmcm9tLCB0bywgbm9kZXMpIHtcclxuICAgICAgICBsZXQgYWZ0ZXIgPSB0aGlzLmxlbmd0aCAtIHRvO1xyXG4gICAgICAgIGlmIChhZnRlciA+IDApIHtcclxuICAgICAgICAgICAgbGV0IGxhc3QgPSBub2Rlc1tub2Rlcy5sZW5ndGggLSAxXTtcclxuICAgICAgICAgICAgaWYgKGxhc3QgaW5zdGFuY2VvZiBIZWlnaHRNYXBHYXApXHJcbiAgICAgICAgICAgICAgICBub2Rlc1tub2Rlcy5sZW5ndGggLSAxXSA9IG5ldyBIZWlnaHRNYXBHYXAobGFzdC5sZW5ndGggKyBhZnRlcik7XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgIG5vZGVzLnB1c2gobnVsbCwgbmV3IEhlaWdodE1hcEdhcChhZnRlciAtIDEpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGZyb20gPiAwKSB7XHJcbiAgICAgICAgICAgIGxldCBmaXJzdCA9IG5vZGVzWzBdO1xyXG4gICAgICAgICAgICBpZiAoZmlyc3QgaW5zdGFuY2VvZiBIZWlnaHRNYXBHYXApXHJcbiAgICAgICAgICAgICAgICBub2Rlc1swXSA9IG5ldyBIZWlnaHRNYXBHYXAoZnJvbSArIGZpcnN0Lmxlbmd0aCk7XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgIG5vZGVzLnVuc2hpZnQobmV3IEhlaWdodE1hcEdhcChmcm9tIC0gMSksIG51bGwpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gSGVpZ2h0TWFwLm9mKG5vZGVzKTtcclxuICAgIH1cclxuICAgIGRlY29tcG9zZUxlZnQodG8sIHJlc3VsdCkge1xyXG4gICAgICAgIHJlc3VsdC5wdXNoKG5ldyBIZWlnaHRNYXBHYXAodG8gLSAxKSwgbnVsbCk7XHJcbiAgICB9XHJcbiAgICBkZWNvbXBvc2VSaWdodChmcm9tLCByZXN1bHQpIHtcclxuICAgICAgICByZXN1bHQucHVzaChudWxsLCBuZXcgSGVpZ2h0TWFwR2FwKHRoaXMubGVuZ3RoIC0gZnJvbSAtIDEpKTtcclxuICAgIH1cclxuICAgIHVwZGF0ZUhlaWdodChvcmFjbGUsIG9mZnNldCA9IDAsIGZvcmNlID0gZmFsc2UsIG1lYXN1cmVkKSB7XHJcbiAgICAgICAgbGV0IGVuZCA9IG9mZnNldCArIHRoaXMubGVuZ3RoO1xyXG4gICAgICAgIGlmIChtZWFzdXJlZCAmJiBtZWFzdXJlZC5mcm9tIDw9IG9mZnNldCArIHRoaXMubGVuZ3RoICYmIG1lYXN1cmVkLm1vcmUpIHtcclxuICAgICAgICAgICAgLy8gRmlsbCBpbiBwYXJ0IG9mIHRoaXMgZ2FwIHdpdGggbWVhc3VyZWQgbGluZXMuIFdlIGtub3cgdGhlcmVcclxuICAgICAgICAgICAgLy8gY2FuJ3QgYmUgd2lkZ2V0cyBvciBjb2xsYXBzZWQgcmFuZ2VzIGluIHRob3NlIGxpbmVzLCBiZWNhdXNlXHJcbiAgICAgICAgICAgIC8vIHRoZXkgd291bGQgYWxyZWFkeSBoYXZlIGJlZW4gYWRkZWQgdG8gdGhlIGhlaWdodG1hcCAoZ2Fwc1xyXG4gICAgICAgICAgICAvLyBvbmx5IGNvbnRhaW4gcGxhaW4gdGV4dCkuXHJcbiAgICAgICAgICAgIGxldCBub2RlcyA9IFtdLCBwb3MgPSBNYXRoLm1heChvZmZzZXQsIG1lYXN1cmVkLmZyb20pLCBzaW5nbGVIZWlnaHQgPSAtMTtcclxuICAgICAgICAgICAgbGV0IHdhc0NoYW5nZWQgPSBvcmFjbGUuaGVpZ2h0Q2hhbmdlZDtcclxuICAgICAgICAgICAgaWYgKG1lYXN1cmVkLmZyb20gPiBvZmZzZXQpXHJcbiAgICAgICAgICAgICAgICBub2Rlcy5wdXNoKG5ldyBIZWlnaHRNYXBHYXAobWVhc3VyZWQuZnJvbSAtIG9mZnNldCAtIDEpLnVwZGF0ZUhlaWdodChvcmFjbGUsIG9mZnNldCkpO1xyXG4gICAgICAgICAgICB3aGlsZSAocG9zIDw9IGVuZCAmJiBtZWFzdXJlZC5tb3JlKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgbGVuID0gb3JhY2xlLmRvYy5saW5lQXQocG9zKS5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICBpZiAobm9kZXMubGVuZ3RoKVxyXG4gICAgICAgICAgICAgICAgICAgIG5vZGVzLnB1c2gobnVsbCk7XHJcbiAgICAgICAgICAgICAgICBsZXQgaGVpZ2h0ID0gbWVhc3VyZWQuaGVpZ2h0c1ttZWFzdXJlZC5pbmRleCsrXTtcclxuICAgICAgICAgICAgICAgIGlmIChzaW5nbGVIZWlnaHQgPT0gLTEpXHJcbiAgICAgICAgICAgICAgICAgICAgc2luZ2xlSGVpZ2h0ID0gaGVpZ2h0O1xyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoTWF0aC5hYnMoaGVpZ2h0IC0gc2luZ2xlSGVpZ2h0KSA+PSBFcHNpbG9uKVxyXG4gICAgICAgICAgICAgICAgICAgIHNpbmdsZUhlaWdodCA9IC0yO1xyXG4gICAgICAgICAgICAgICAgbGV0IGxpbmUgPSBuZXcgSGVpZ2h0TWFwVGV4dChsZW4sIGhlaWdodCk7XHJcbiAgICAgICAgICAgICAgICBsaW5lLm91dGRhdGVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICBub2Rlcy5wdXNoKGxpbmUpO1xyXG4gICAgICAgICAgICAgICAgcG9zICs9IGxlbiArIDE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHBvcyA8PSBlbmQpXHJcbiAgICAgICAgICAgICAgICBub2Rlcy5wdXNoKG51bGwsIG5ldyBIZWlnaHRNYXBHYXAoZW5kIC0gcG9zKS51cGRhdGVIZWlnaHQob3JhY2xlLCBwb3MpKTtcclxuICAgICAgICAgICAgbGV0IHJlc3VsdCA9IEhlaWdodE1hcC5vZihub2Rlcyk7XHJcbiAgICAgICAgICAgIG9yYWNsZS5oZWlnaHRDaGFuZ2VkID0gd2FzQ2hhbmdlZCB8fCBzaW5nbGVIZWlnaHQgPCAwIHx8IE1hdGguYWJzKHJlc3VsdC5oZWlnaHQgLSB0aGlzLmhlaWdodCkgPj0gRXBzaWxvbiB8fFxyXG4gICAgICAgICAgICAgICAgTWF0aC5hYnMoc2luZ2xlSGVpZ2h0IC0gdGhpcy5saW5lcyhvcmFjbGUuZG9jLCBvZmZzZXQpLmxpbmVIZWlnaHQpID49IEVwc2lsb247XHJcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGZvcmNlIHx8IHRoaXMub3V0ZGF0ZWQpIHtcclxuICAgICAgICAgICAgdGhpcy5zZXRIZWlnaHQob3JhY2xlLCBvcmFjbGUuaGVpZ2h0Rm9yR2FwKG9mZnNldCwgb2Zmc2V0ICsgdGhpcy5sZW5ndGgpKTtcclxuICAgICAgICAgICAgdGhpcy5vdXRkYXRlZCA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuICAgIHRvU3RyaW5nKCkgeyByZXR1cm4gYGdhcCgke3RoaXMubGVuZ3RofSlgOyB9XHJcbn1cclxuY2xhc3MgSGVpZ2h0TWFwQnJhbmNoIGV4dGVuZHMgSGVpZ2h0TWFwIHtcclxuICAgIGNvbnN0cnVjdG9yKGxlZnQsIGJyaywgcmlnaHQpIHtcclxuICAgICAgICBzdXBlcihsZWZ0Lmxlbmd0aCArIGJyayArIHJpZ2h0Lmxlbmd0aCwgbGVmdC5oZWlnaHQgKyByaWdodC5oZWlnaHQsIGJyayB8IChsZWZ0Lm91dGRhdGVkIHx8IHJpZ2h0Lm91dGRhdGVkID8gMiAvKiBGbGFnLk91dGRhdGVkICovIDogMCkpO1xyXG4gICAgICAgIHRoaXMubGVmdCA9IGxlZnQ7XHJcbiAgICAgICAgdGhpcy5yaWdodCA9IHJpZ2h0O1xyXG4gICAgICAgIHRoaXMuc2l6ZSA9IGxlZnQuc2l6ZSArIHJpZ2h0LnNpemU7XHJcbiAgICB9XHJcbiAgICBnZXQgYnJlYWsoKSB7IHJldHVybiB0aGlzLmZsYWdzICYgMSAvKiBGbGFnLkJyZWFrICovOyB9XHJcbiAgICBibG9ja0F0KGhlaWdodCwgZG9jLCB0b3AsIG9mZnNldCkge1xyXG4gICAgICAgIGxldCBtaWQgPSB0b3AgKyB0aGlzLmxlZnQuaGVpZ2h0O1xyXG4gICAgICAgIHJldHVybiBoZWlnaHQgPCBtaWQgPyB0aGlzLmxlZnQuYmxvY2tBdChoZWlnaHQsIGRvYywgdG9wLCBvZmZzZXQpXHJcbiAgICAgICAgICAgIDogdGhpcy5yaWdodC5ibG9ja0F0KGhlaWdodCwgZG9jLCBtaWQsIG9mZnNldCArIHRoaXMubGVmdC5sZW5ndGggKyB0aGlzLmJyZWFrKTtcclxuICAgIH1cclxuICAgIGxpbmVBdCh2YWx1ZSwgdHlwZSwgZG9jLCB0b3AsIG9mZnNldCkge1xyXG4gICAgICAgIGxldCByaWdodFRvcCA9IHRvcCArIHRoaXMubGVmdC5oZWlnaHQsIHJpZ2h0T2Zmc2V0ID0gb2Zmc2V0ICsgdGhpcy5sZWZ0Lmxlbmd0aCArIHRoaXMuYnJlYWs7XHJcbiAgICAgICAgbGV0IGxlZnQgPSB0eXBlID09IFF1ZXJ5VHlwZS5CeUhlaWdodCA/IHZhbHVlIDwgcmlnaHRUb3AgOiB2YWx1ZSA8IHJpZ2h0T2Zmc2V0O1xyXG4gICAgICAgIGxldCBiYXNlID0gbGVmdCA/IHRoaXMubGVmdC5saW5lQXQodmFsdWUsIHR5cGUsIGRvYywgdG9wLCBvZmZzZXQpXHJcbiAgICAgICAgICAgIDogdGhpcy5yaWdodC5saW5lQXQodmFsdWUsIHR5cGUsIGRvYywgcmlnaHRUb3AsIHJpZ2h0T2Zmc2V0KTtcclxuICAgICAgICBpZiAodGhpcy5icmVhayB8fCAobGVmdCA/IGJhc2UudG8gPCByaWdodE9mZnNldCA6IGJhc2UuZnJvbSA+IHJpZ2h0T2Zmc2V0KSlcclxuICAgICAgICAgICAgcmV0dXJuIGJhc2U7XHJcbiAgICAgICAgbGV0IHN1YlF1ZXJ5ID0gdHlwZSA9PSBRdWVyeVR5cGUuQnlQb3NOb0hlaWdodCA/IFF1ZXJ5VHlwZS5CeVBvc05vSGVpZ2h0IDogUXVlcnlUeXBlLkJ5UG9zO1xyXG4gICAgICAgIGlmIChsZWZ0KVxyXG4gICAgICAgICAgICByZXR1cm4gYmFzZS5qb2luKHRoaXMucmlnaHQubGluZUF0KHJpZ2h0T2Zmc2V0LCBzdWJRdWVyeSwgZG9jLCByaWdodFRvcCwgcmlnaHRPZmZzZXQpKTtcclxuICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxlZnQubGluZUF0KHJpZ2h0T2Zmc2V0LCBzdWJRdWVyeSwgZG9jLCB0b3AsIG9mZnNldCkuam9pbihiYXNlKTtcclxuICAgIH1cclxuICAgIGZvckVhY2hMaW5lKGZyb20sIHRvLCBkb2MsIHRvcCwgb2Zmc2V0LCBmKSB7XHJcbiAgICAgICAgbGV0IHJpZ2h0VG9wID0gdG9wICsgdGhpcy5sZWZ0LmhlaWdodCwgcmlnaHRPZmZzZXQgPSBvZmZzZXQgKyB0aGlzLmxlZnQubGVuZ3RoICsgdGhpcy5icmVhaztcclxuICAgICAgICBpZiAodGhpcy5icmVhaykge1xyXG4gICAgICAgICAgICBpZiAoZnJvbSA8IHJpZ2h0T2Zmc2V0KVxyXG4gICAgICAgICAgICAgICAgdGhpcy5sZWZ0LmZvckVhY2hMaW5lKGZyb20sIHRvLCBkb2MsIHRvcCwgb2Zmc2V0LCBmKTtcclxuICAgICAgICAgICAgaWYgKHRvID49IHJpZ2h0T2Zmc2V0KVxyXG4gICAgICAgICAgICAgICAgdGhpcy5yaWdodC5mb3JFYWNoTGluZShmcm9tLCB0bywgZG9jLCByaWdodFRvcCwgcmlnaHRPZmZzZXQsIGYpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgbGV0IG1pZCA9IHRoaXMubGluZUF0KHJpZ2h0T2Zmc2V0LCBRdWVyeVR5cGUuQnlQb3MsIGRvYywgdG9wLCBvZmZzZXQpO1xyXG4gICAgICAgICAgICBpZiAoZnJvbSA8IG1pZC5mcm9tKVxyXG4gICAgICAgICAgICAgICAgdGhpcy5sZWZ0LmZvckVhY2hMaW5lKGZyb20sIG1pZC5mcm9tIC0gMSwgZG9jLCB0b3AsIG9mZnNldCwgZik7XHJcbiAgICAgICAgICAgIGlmIChtaWQudG8gPj0gZnJvbSAmJiBtaWQuZnJvbSA8PSB0bylcclxuICAgICAgICAgICAgICAgIGYobWlkKTtcclxuICAgICAgICAgICAgaWYgKHRvID4gbWlkLnRvKVxyXG4gICAgICAgICAgICAgICAgdGhpcy5yaWdodC5mb3JFYWNoTGluZShtaWQudG8gKyAxLCB0bywgZG9jLCByaWdodFRvcCwgcmlnaHRPZmZzZXQsIGYpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJlcGxhY2UoZnJvbSwgdG8sIG5vZGVzKSB7XHJcbiAgICAgICAgbGV0IHJpZ2h0U3RhcnQgPSB0aGlzLmxlZnQubGVuZ3RoICsgdGhpcy5icmVhaztcclxuICAgICAgICBpZiAodG8gPCByaWdodFN0YXJ0KVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5iYWxhbmNlZCh0aGlzLmxlZnQucmVwbGFjZShmcm9tLCB0bywgbm9kZXMpLCB0aGlzLnJpZ2h0KTtcclxuICAgICAgICBpZiAoZnJvbSA+IHRoaXMubGVmdC5sZW5ndGgpXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmJhbGFuY2VkKHRoaXMubGVmdCwgdGhpcy5yaWdodC5yZXBsYWNlKGZyb20gLSByaWdodFN0YXJ0LCB0byAtIHJpZ2h0U3RhcnQsIG5vZGVzKSk7XHJcbiAgICAgICAgbGV0IHJlc3VsdCA9IFtdO1xyXG4gICAgICAgIGlmIChmcm9tID4gMClcclxuICAgICAgICAgICAgdGhpcy5kZWNvbXBvc2VMZWZ0KGZyb20sIHJlc3VsdCk7XHJcbiAgICAgICAgbGV0IGxlZnQgPSByZXN1bHQubGVuZ3RoO1xyXG4gICAgICAgIGZvciAobGV0IG5vZGUgb2Ygbm9kZXMpXHJcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKG5vZGUpO1xyXG4gICAgICAgIGlmIChmcm9tID4gMClcclxuICAgICAgICAgICAgbWVyZ2VHYXBzKHJlc3VsdCwgbGVmdCAtIDEpO1xyXG4gICAgICAgIGlmICh0byA8IHRoaXMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIGxldCByaWdodCA9IHJlc3VsdC5sZW5ndGg7XHJcbiAgICAgICAgICAgIHRoaXMuZGVjb21wb3NlUmlnaHQodG8sIHJlc3VsdCk7XHJcbiAgICAgICAgICAgIG1lcmdlR2FwcyhyZXN1bHQsIHJpZ2h0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIEhlaWdodE1hcC5vZihyZXN1bHQpO1xyXG4gICAgfVxyXG4gICAgZGVjb21wb3NlTGVmdCh0bywgcmVzdWx0KSB7XHJcbiAgICAgICAgbGV0IGxlZnQgPSB0aGlzLmxlZnQubGVuZ3RoO1xyXG4gICAgICAgIGlmICh0byA8PSBsZWZ0KVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5sZWZ0LmRlY29tcG9zZUxlZnQodG8sIHJlc3VsdCk7XHJcbiAgICAgICAgcmVzdWx0LnB1c2godGhpcy5sZWZ0KTtcclxuICAgICAgICBpZiAodGhpcy5icmVhaykge1xyXG4gICAgICAgICAgICBsZWZ0Kys7XHJcbiAgICAgICAgICAgIGlmICh0byA+PSBsZWZ0KVxyXG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2gobnVsbCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0byA+IGxlZnQpXHJcbiAgICAgICAgICAgIHRoaXMucmlnaHQuZGVjb21wb3NlTGVmdCh0byAtIGxlZnQsIHJlc3VsdCk7XHJcbiAgICB9XHJcbiAgICBkZWNvbXBvc2VSaWdodChmcm9tLCByZXN1bHQpIHtcclxuICAgICAgICBsZXQgbGVmdCA9IHRoaXMubGVmdC5sZW5ndGgsIHJpZ2h0ID0gbGVmdCArIHRoaXMuYnJlYWs7XHJcbiAgICAgICAgaWYgKGZyb20gPj0gcmlnaHQpXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJpZ2h0LmRlY29tcG9zZVJpZ2h0KGZyb20gLSByaWdodCwgcmVzdWx0KTtcclxuICAgICAgICBpZiAoZnJvbSA8IGxlZnQpXHJcbiAgICAgICAgICAgIHRoaXMubGVmdC5kZWNvbXBvc2VSaWdodChmcm9tLCByZXN1bHQpO1xyXG4gICAgICAgIGlmICh0aGlzLmJyZWFrICYmIGZyb20gPCByaWdodClcclxuICAgICAgICAgICAgcmVzdWx0LnB1c2gobnVsbCk7XHJcbiAgICAgICAgcmVzdWx0LnB1c2godGhpcy5yaWdodCk7XHJcbiAgICB9XHJcbiAgICBiYWxhbmNlZChsZWZ0LCByaWdodCkge1xyXG4gICAgICAgIGlmIChsZWZ0LnNpemUgPiAyICogcmlnaHQuc2l6ZSB8fCByaWdodC5zaXplID4gMiAqIGxlZnQuc2l6ZSlcclxuICAgICAgICAgICAgcmV0dXJuIEhlaWdodE1hcC5vZih0aGlzLmJyZWFrID8gW2xlZnQsIG51bGwsIHJpZ2h0XSA6IFtsZWZ0LCByaWdodF0pO1xyXG4gICAgICAgIHRoaXMubGVmdCA9IGxlZnQ7XHJcbiAgICAgICAgdGhpcy5yaWdodCA9IHJpZ2h0O1xyXG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gbGVmdC5oZWlnaHQgKyByaWdodC5oZWlnaHQ7XHJcbiAgICAgICAgdGhpcy5vdXRkYXRlZCA9IGxlZnQub3V0ZGF0ZWQgfHwgcmlnaHQub3V0ZGF0ZWQ7XHJcbiAgICAgICAgdGhpcy5zaXplID0gbGVmdC5zaXplICsgcmlnaHQuc2l6ZTtcclxuICAgICAgICB0aGlzLmxlbmd0aCA9IGxlZnQubGVuZ3RoICsgdGhpcy5icmVhayArIHJpZ2h0Lmxlbmd0aDtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuICAgIHVwZGF0ZUhlaWdodChvcmFjbGUsIG9mZnNldCA9IDAsIGZvcmNlID0gZmFsc2UsIG1lYXN1cmVkKSB7XHJcbiAgICAgICAgbGV0IHsgbGVmdCwgcmlnaHQgfSA9IHRoaXMsIHJpZ2h0U3RhcnQgPSBvZmZzZXQgKyBsZWZ0Lmxlbmd0aCArIHRoaXMuYnJlYWssIHJlYmFsYW5jZSA9IG51bGw7XHJcbiAgICAgICAgaWYgKG1lYXN1cmVkICYmIG1lYXN1cmVkLmZyb20gPD0gb2Zmc2V0ICsgbGVmdC5sZW5ndGggJiYgbWVhc3VyZWQubW9yZSlcclxuICAgICAgICAgICAgcmViYWxhbmNlID0gbGVmdCA9IGxlZnQudXBkYXRlSGVpZ2h0KG9yYWNsZSwgb2Zmc2V0LCBmb3JjZSwgbWVhc3VyZWQpO1xyXG4gICAgICAgIGVsc2VcclxuICAgICAgICAgICAgbGVmdC51cGRhdGVIZWlnaHQob3JhY2xlLCBvZmZzZXQsIGZvcmNlKTtcclxuICAgICAgICBpZiAobWVhc3VyZWQgJiYgbWVhc3VyZWQuZnJvbSA8PSByaWdodFN0YXJ0ICsgcmlnaHQubGVuZ3RoICYmIG1lYXN1cmVkLm1vcmUpXHJcbiAgICAgICAgICAgIHJlYmFsYW5jZSA9IHJpZ2h0ID0gcmlnaHQudXBkYXRlSGVpZ2h0KG9yYWNsZSwgcmlnaHRTdGFydCwgZm9yY2UsIG1lYXN1cmVkKTtcclxuICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHJpZ2h0LnVwZGF0ZUhlaWdodChvcmFjbGUsIHJpZ2h0U3RhcnQsIGZvcmNlKTtcclxuICAgICAgICBpZiAocmViYWxhbmNlKVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5iYWxhbmNlZChsZWZ0LCByaWdodCk7XHJcbiAgICAgICAgdGhpcy5oZWlnaHQgPSB0aGlzLmxlZnQuaGVpZ2h0ICsgdGhpcy5yaWdodC5oZWlnaHQ7XHJcbiAgICAgICAgdGhpcy5vdXRkYXRlZCA9IGZhbHNlO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG4gICAgdG9TdHJpbmcoKSB7IHJldHVybiB0aGlzLmxlZnQgKyAodGhpcy5icmVhayA/IFwiIFwiIDogXCItXCIpICsgdGhpcy5yaWdodDsgfVxyXG59XHJcbmZ1bmN0aW9uIG1lcmdlR2Fwcyhub2RlcywgYXJvdW5kKSB7XHJcbiAgICBsZXQgYmVmb3JlLCBhZnRlcjtcclxuICAgIGlmIChub2Rlc1thcm91bmRdID09IG51bGwgJiZcclxuICAgICAgICAoYmVmb3JlID0gbm9kZXNbYXJvdW5kIC0gMV0pIGluc3RhbmNlb2YgSGVpZ2h0TWFwR2FwICYmXHJcbiAgICAgICAgKGFmdGVyID0gbm9kZXNbYXJvdW5kICsgMV0pIGluc3RhbmNlb2YgSGVpZ2h0TWFwR2FwKVxyXG4gICAgICAgIG5vZGVzLnNwbGljZShhcm91bmQgLSAxLCAzLCBuZXcgSGVpZ2h0TWFwR2FwKGJlZm9yZS5sZW5ndGggKyAxICsgYWZ0ZXIubGVuZ3RoKSk7XHJcbn1cclxuY29uc3QgcmVsZXZhbnRXaWRnZXRIZWlnaHQgPSA1O1xyXG5jbGFzcyBOb2RlQnVpbGRlciB7XHJcbiAgICBjb25zdHJ1Y3Rvcihwb3MsIG9yYWNsZSkge1xyXG4gICAgICAgIHRoaXMucG9zID0gcG9zO1xyXG4gICAgICAgIHRoaXMub3JhY2xlID0gb3JhY2xlO1xyXG4gICAgICAgIHRoaXMubm9kZXMgPSBbXTtcclxuICAgICAgICB0aGlzLmxpbmVTdGFydCA9IC0xO1xyXG4gICAgICAgIHRoaXMubGluZUVuZCA9IC0xO1xyXG4gICAgICAgIHRoaXMuY292ZXJpbmcgPSBudWxsO1xyXG4gICAgICAgIHRoaXMud3JpdHRlblRvID0gcG9zO1xyXG4gICAgfVxyXG4gICAgZ2V0IGlzQ292ZXJlZCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5jb3ZlcmluZyAmJiB0aGlzLm5vZGVzW3RoaXMubm9kZXMubGVuZ3RoIC0gMV0gPT0gdGhpcy5jb3ZlcmluZztcclxuICAgIH1cclxuICAgIHNwYW4oX2Zyb20sIHRvKSB7XHJcbiAgICAgICAgaWYgKHRoaXMubGluZVN0YXJ0ID4gLTEpIHtcclxuICAgICAgICAgICAgbGV0IGVuZCA9IE1hdGgubWluKHRvLCB0aGlzLmxpbmVFbmQpLCBsYXN0ID0gdGhpcy5ub2Rlc1t0aGlzLm5vZGVzLmxlbmd0aCAtIDFdO1xyXG4gICAgICAgICAgICBpZiAobGFzdCBpbnN0YW5jZW9mIEhlaWdodE1hcFRleHQpXHJcbiAgICAgICAgICAgICAgICBsYXN0Lmxlbmd0aCArPSBlbmQgLSB0aGlzLnBvcztcclxuICAgICAgICAgICAgZWxzZSBpZiAoZW5kID4gdGhpcy5wb3MgfHwgIXRoaXMuaXNDb3ZlcmVkKVxyXG4gICAgICAgICAgICAgICAgdGhpcy5ub2Rlcy5wdXNoKG5ldyBIZWlnaHRNYXBUZXh0KGVuZCAtIHRoaXMucG9zLCAtMSkpO1xyXG4gICAgICAgICAgICB0aGlzLndyaXR0ZW5UbyA9IGVuZDtcclxuICAgICAgICAgICAgaWYgKHRvID4gZW5kKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm5vZGVzLnB1c2gobnVsbCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLndyaXR0ZW5UbysrO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5saW5lU3RhcnQgPSAtMTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnBvcyA9IHRvO1xyXG4gICAgfVxyXG4gICAgcG9pbnQoZnJvbSwgdG8sIGRlY28pIHtcclxuICAgICAgICBpZiAoZnJvbSA8IHRvIHx8IGRlY28uaGVpZ2h0UmVsZXZhbnQpIHtcclxuICAgICAgICAgICAgbGV0IGhlaWdodCA9IGRlY28ud2lkZ2V0ID8gZGVjby53aWRnZXQuZXN0aW1hdGVkSGVpZ2h0IDogMDtcclxuICAgICAgICAgICAgaWYgKGhlaWdodCA8IDApXHJcbiAgICAgICAgICAgICAgICBoZWlnaHQgPSB0aGlzLm9yYWNsZS5saW5lSGVpZ2h0O1xyXG4gICAgICAgICAgICBsZXQgbGVuID0gdG8gLSBmcm9tO1xyXG4gICAgICAgICAgICBpZiAoZGVjby5ibG9jaykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5hZGRCbG9jayhuZXcgSGVpZ2h0TWFwQmxvY2sobGVuLCBoZWlnaHQsIGRlY28udHlwZSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGxlbiB8fCBoZWlnaHQgPj0gcmVsZXZhbnRXaWRnZXRIZWlnaHQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuYWRkTGluZURlY28oaGVpZ2h0LCBsZW4pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHRvID4gZnJvbSkge1xyXG4gICAgICAgICAgICB0aGlzLnNwYW4oZnJvbSwgdG8pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5saW5lRW5kID4gLTEgJiYgdGhpcy5saW5lRW5kIDwgdGhpcy5wb3MpXHJcbiAgICAgICAgICAgIHRoaXMubGluZUVuZCA9IHRoaXMub3JhY2xlLmRvYy5saW5lQXQodGhpcy5wb3MpLnRvO1xyXG4gICAgfVxyXG4gICAgZW50ZXJMaW5lKCkge1xyXG4gICAgICAgIGlmICh0aGlzLmxpbmVTdGFydCA+IC0xKVxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgbGV0IHsgZnJvbSwgdG8gfSA9IHRoaXMub3JhY2xlLmRvYy5saW5lQXQodGhpcy5wb3MpO1xyXG4gICAgICAgIHRoaXMubGluZVN0YXJ0ID0gZnJvbTtcclxuICAgICAgICB0aGlzLmxpbmVFbmQgPSB0bztcclxuICAgICAgICBpZiAodGhpcy53cml0dGVuVG8gPCBmcm9tKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLndyaXR0ZW5UbyA8IGZyb20gLSAxIHx8IHRoaXMubm9kZXNbdGhpcy5ub2Rlcy5sZW5ndGggLSAxXSA9PSBudWxsKVxyXG4gICAgICAgICAgICAgICAgdGhpcy5ub2Rlcy5wdXNoKHRoaXMuYmxhbmtDb250ZW50KHRoaXMud3JpdHRlblRvLCBmcm9tIC0gMSkpO1xyXG4gICAgICAgICAgICB0aGlzLm5vZGVzLnB1c2gobnVsbCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLnBvcyA+IGZyb20pXHJcbiAgICAgICAgICAgIHRoaXMubm9kZXMucHVzaChuZXcgSGVpZ2h0TWFwVGV4dCh0aGlzLnBvcyAtIGZyb20sIC0xKSk7XHJcbiAgICAgICAgdGhpcy53cml0dGVuVG8gPSB0aGlzLnBvcztcclxuICAgIH1cclxuICAgIGJsYW5rQ29udGVudChmcm9tLCB0bykge1xyXG4gICAgICAgIGxldCBnYXAgPSBuZXcgSGVpZ2h0TWFwR2FwKHRvIC0gZnJvbSk7XHJcbiAgICAgICAgaWYgKHRoaXMub3JhY2xlLmRvYy5saW5lQXQoZnJvbSkudG8gPT0gdG8pXHJcbiAgICAgICAgICAgIGdhcC5mbGFncyB8PSA0IC8qIEZsYWcuU2luZ2xlTGluZSAqLztcclxuICAgICAgICByZXR1cm4gZ2FwO1xyXG4gICAgfVxyXG4gICAgZW5zdXJlTGluZSgpIHtcclxuICAgICAgICB0aGlzLmVudGVyTGluZSgpO1xyXG4gICAgICAgIGxldCBsYXN0ID0gdGhpcy5ub2Rlcy5sZW5ndGggPyB0aGlzLm5vZGVzW3RoaXMubm9kZXMubGVuZ3RoIC0gMV0gOiBudWxsO1xyXG4gICAgICAgIGlmIChsYXN0IGluc3RhbmNlb2YgSGVpZ2h0TWFwVGV4dClcclxuICAgICAgICAgICAgcmV0dXJuIGxhc3Q7XHJcbiAgICAgICAgbGV0IGxpbmUgPSBuZXcgSGVpZ2h0TWFwVGV4dCgwLCAtMSk7XHJcbiAgICAgICAgdGhpcy5ub2Rlcy5wdXNoKGxpbmUpO1xyXG4gICAgICAgIHJldHVybiBsaW5lO1xyXG4gICAgfVxyXG4gICAgYWRkQmxvY2soYmxvY2spIHtcclxuICAgICAgICB0aGlzLmVudGVyTGluZSgpO1xyXG4gICAgICAgIGlmIChibG9jay50eXBlID09IEJsb2NrVHlwZS5XaWRnZXRBZnRlciAmJiAhdGhpcy5pc0NvdmVyZWQpXHJcbiAgICAgICAgICAgIHRoaXMuZW5zdXJlTGluZSgpO1xyXG4gICAgICAgIHRoaXMubm9kZXMucHVzaChibG9jayk7XHJcbiAgICAgICAgdGhpcy53cml0dGVuVG8gPSB0aGlzLnBvcyA9IHRoaXMucG9zICsgYmxvY2subGVuZ3RoO1xyXG4gICAgICAgIGlmIChibG9jay50eXBlICE9IEJsb2NrVHlwZS5XaWRnZXRCZWZvcmUpXHJcbiAgICAgICAgICAgIHRoaXMuY292ZXJpbmcgPSBibG9jaztcclxuICAgIH1cclxuICAgIGFkZExpbmVEZWNvKGhlaWdodCwgbGVuZ3RoKSB7XHJcbiAgICAgICAgbGV0IGxpbmUgPSB0aGlzLmVuc3VyZUxpbmUoKTtcclxuICAgICAgICBsaW5lLmxlbmd0aCArPSBsZW5ndGg7XHJcbiAgICAgICAgbGluZS5jb2xsYXBzZWQgKz0gbGVuZ3RoO1xyXG4gICAgICAgIGxpbmUud2lkZ2V0SGVpZ2h0ID0gTWF0aC5tYXgobGluZS53aWRnZXRIZWlnaHQsIGhlaWdodCk7XHJcbiAgICAgICAgdGhpcy53cml0dGVuVG8gPSB0aGlzLnBvcyA9IHRoaXMucG9zICsgbGVuZ3RoO1xyXG4gICAgfVxyXG4gICAgZmluaXNoKGZyb20pIHtcclxuICAgICAgICBsZXQgbGFzdCA9IHRoaXMubm9kZXMubGVuZ3RoID09IDAgPyBudWxsIDogdGhpcy5ub2Rlc1t0aGlzLm5vZGVzLmxlbmd0aCAtIDFdO1xyXG4gICAgICAgIGlmICh0aGlzLmxpbmVTdGFydCA+IC0xICYmICEobGFzdCBpbnN0YW5jZW9mIEhlaWdodE1hcFRleHQpICYmICF0aGlzLmlzQ292ZXJlZClcclxuICAgICAgICAgICAgdGhpcy5ub2Rlcy5wdXNoKG5ldyBIZWlnaHRNYXBUZXh0KDAsIC0xKSk7XHJcbiAgICAgICAgZWxzZSBpZiAodGhpcy53cml0dGVuVG8gPCB0aGlzLnBvcyB8fCBsYXN0ID09IG51bGwpXHJcbiAgICAgICAgICAgIHRoaXMubm9kZXMucHVzaCh0aGlzLmJsYW5rQ29udGVudCh0aGlzLndyaXR0ZW5UbywgdGhpcy5wb3MpKTtcclxuICAgICAgICBsZXQgcG9zID0gZnJvbTtcclxuICAgICAgICBmb3IgKGxldCBub2RlIG9mIHRoaXMubm9kZXMpIHtcclxuICAgICAgICAgICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBIZWlnaHRNYXBUZXh0KVxyXG4gICAgICAgICAgICAgICAgbm9kZS51cGRhdGVIZWlnaHQodGhpcy5vcmFjbGUsIHBvcyk7XHJcbiAgICAgICAgICAgIHBvcyArPSBub2RlID8gbm9kZS5sZW5ndGggOiAxO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5ub2RlcztcclxuICAgIH1cclxuICAgIC8vIEFsd2F5cyBjYWxsZWQgd2l0aCBhIHJlZ2lvbiB0aGF0IG9uIGJvdGggc2lkZXMgZWl0aGVyIHN0cmV0Y2hlc1xyXG4gICAgLy8gdG8gYSBsaW5lIGJyZWFrIG9yIHRoZSBlbmQgb2YgdGhlIGRvY3VtZW50LlxyXG4gICAgLy8gVGhlIHJldHVybmVkIGFycmF5IHVzZXMgbnVsbCB0byBpbmRpY2F0ZSBsaW5lIGJyZWFrcywgYnV0IG5ldmVyXHJcbiAgICAvLyBzdGFydHMgb3IgZW5kcyBpbiBhIGxpbmUgYnJlYWssIG9yIGhhcyBtdWx0aXBsZSBsaW5lIGJyZWFrcyBuZXh0XHJcbiAgICAvLyB0byBlYWNoIG90aGVyLlxyXG4gICAgc3RhdGljIGJ1aWxkKG9yYWNsZSwgZGVjb3JhdGlvbnMsIGZyb20sIHRvKSB7XHJcbiAgICAgICAgbGV0IGJ1aWxkZXIgPSBuZXcgTm9kZUJ1aWxkZXIoZnJvbSwgb3JhY2xlKTtcclxuICAgICAgICBSYW5nZVNldC5zcGFucyhkZWNvcmF0aW9ucywgZnJvbSwgdG8sIGJ1aWxkZXIsIDApO1xyXG4gICAgICAgIHJldHVybiBidWlsZGVyLmZpbmlzaChmcm9tKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBoZWlnaHRSZWxldmFudERlY29DaGFuZ2VzKGEsIGIsIGRpZmYpIHtcclxuICAgIGxldCBjb21wID0gbmV3IERlY29yYXRpb25Db21wYXJhdG9yO1xyXG4gICAgUmFuZ2VTZXQuY29tcGFyZShhLCBiLCBkaWZmLCBjb21wLCAwKTtcclxuICAgIHJldHVybiBjb21wLmNoYW5nZXM7XHJcbn1cclxuY2xhc3MgRGVjb3JhdGlvbkNvbXBhcmF0b3Ige1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgdGhpcy5jaGFuZ2VzID0gW107XHJcbiAgICB9XHJcbiAgICBjb21wYXJlUmFuZ2UoKSB7IH1cclxuICAgIGNvbXBhcmVQb2ludChmcm9tLCB0bywgYSwgYikge1xyXG4gICAgICAgIGlmIChmcm9tIDwgdG8gfHwgYSAmJiBhLmhlaWdodFJlbGV2YW50IHx8IGIgJiYgYi5oZWlnaHRSZWxldmFudClcclxuICAgICAgICAgICAgYWRkUmFuZ2UoZnJvbSwgdG8sIHRoaXMuY2hhbmdlcywgNSk7XHJcbiAgICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHZpc2libGVQaXhlbFJhbmdlKGRvbSwgcGFkZGluZ1RvcCkge1xyXG4gICAgbGV0IHJlY3QgPSBkb20uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XHJcbiAgICBsZXQgZG9jID0gZG9tLm93bmVyRG9jdW1lbnQsIHdpbiA9IGRvYy5kZWZhdWx0VmlldyB8fCB3aW5kb3c7XHJcbiAgICBsZXQgbGVmdCA9IE1hdGgubWF4KDAsIHJlY3QubGVmdCksIHJpZ2h0ID0gTWF0aC5taW4od2luLmlubmVyV2lkdGgsIHJlY3QucmlnaHQpO1xyXG4gICAgbGV0IHRvcCA9IE1hdGgubWF4KDAsIHJlY3QudG9wKSwgYm90dG9tID0gTWF0aC5taW4od2luLmlubmVySGVpZ2h0LCByZWN0LmJvdHRvbSk7XHJcbiAgICBmb3IgKGxldCBwYXJlbnQgPSBkb20ucGFyZW50Tm9kZTsgcGFyZW50ICYmIHBhcmVudCAhPSBkb2MuYm9keTspIHtcclxuICAgICAgICBpZiAocGFyZW50Lm5vZGVUeXBlID09IDEpIHtcclxuICAgICAgICAgICAgbGV0IGVsdCA9IHBhcmVudDtcclxuICAgICAgICAgICAgbGV0IHN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWx0KTtcclxuICAgICAgICAgICAgaWYgKChlbHQuc2Nyb2xsSGVpZ2h0ID4gZWx0LmNsaWVudEhlaWdodCB8fCBlbHQuc2Nyb2xsV2lkdGggPiBlbHQuY2xpZW50V2lkdGgpICYmXHJcbiAgICAgICAgICAgICAgICBzdHlsZS5vdmVyZmxvdyAhPSBcInZpc2libGVcIikge1xyXG4gICAgICAgICAgICAgICAgbGV0IHBhcmVudFJlY3QgPSBlbHQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XHJcbiAgICAgICAgICAgICAgICBsZWZ0ID0gTWF0aC5tYXgobGVmdCwgcGFyZW50UmVjdC5sZWZ0KTtcclxuICAgICAgICAgICAgICAgIHJpZ2h0ID0gTWF0aC5taW4ocmlnaHQsIHBhcmVudFJlY3QucmlnaHQpO1xyXG4gICAgICAgICAgICAgICAgdG9wID0gTWF0aC5tYXgodG9wLCBwYXJlbnRSZWN0LnRvcCk7XHJcbiAgICAgICAgICAgICAgICBib3R0b20gPSBwYXJlbnQgPT0gZG9tLnBhcmVudE5vZGUgPyBwYXJlbnRSZWN0LmJvdHRvbSA6IE1hdGgubWluKGJvdHRvbSwgcGFyZW50UmVjdC5ib3R0b20pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHBhcmVudCA9IHN0eWxlLnBvc2l0aW9uID09IFwiYWJzb2x1dGVcIiB8fCBzdHlsZS5wb3NpdGlvbiA9PSBcImZpeGVkXCIgPyBlbHQub2Zmc2V0UGFyZW50IDogZWx0LnBhcmVudE5vZGU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHBhcmVudC5ub2RlVHlwZSA9PSAxMSkgeyAvLyBTaGFkb3cgcm9vdFxyXG4gICAgICAgICAgICBwYXJlbnQgPSBwYXJlbnQuaG9zdDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiB7IGxlZnQ6IGxlZnQgLSByZWN0LmxlZnQsIHJpZ2h0OiBNYXRoLm1heChsZWZ0LCByaWdodCkgLSByZWN0LmxlZnQsXHJcbiAgICAgICAgdG9wOiB0b3AgLSAocmVjdC50b3AgKyBwYWRkaW5nVG9wKSwgYm90dG9tOiBNYXRoLm1heCh0b3AsIGJvdHRvbSkgLSAocmVjdC50b3AgKyBwYWRkaW5nVG9wKSB9O1xyXG59XHJcbmZ1bmN0aW9uIGZ1bGxQaXhlbFJhbmdlKGRvbSwgcGFkZGluZ1RvcCkge1xyXG4gICAgbGV0IHJlY3QgPSBkb20uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XHJcbiAgICByZXR1cm4geyBsZWZ0OiAwLCByaWdodDogcmVjdC5yaWdodCAtIHJlY3QubGVmdCxcclxuICAgICAgICB0b3A6IHBhZGRpbmdUb3AsIGJvdHRvbTogcmVjdC5ib3R0b20gLSAocmVjdC50b3AgKyBwYWRkaW5nVG9wKSB9O1xyXG59XHJcbi8vIExpbmUgZ2FwcyBhcmUgcGxhY2Vob2xkZXIgd2lkZ2V0cyB1c2VkIHRvIGhpZGUgcGllY2VzIG9mIG92ZXJsb25nXHJcbi8vIGxpbmVzIHdpdGhpbiB0aGUgdmlld3BvcnQsIGFzIGEga2x1ZGdlIHRvIGtlZXAgdGhlIGVkaXRvclxyXG4vLyByZXNwb25zaXZlIHdoZW4gYSByaWRpY3Vsb3VzbHkgbG9uZyBsaW5lIGlzIGxvYWRlZCBpbnRvIGl0LlxyXG5jbGFzcyBMaW5lR2FwIHtcclxuICAgIGNvbnN0cnVjdG9yKGZyb20sIHRvLCBzaXplKSB7XHJcbiAgICAgICAgdGhpcy5mcm9tID0gZnJvbTtcclxuICAgICAgICB0aGlzLnRvID0gdG87XHJcbiAgICAgICAgdGhpcy5zaXplID0gc2l6ZTtcclxuICAgIH1cclxuICAgIHN0YXRpYyBzYW1lKGEsIGIpIHtcclxuICAgICAgICBpZiAoYS5sZW5ndGggIT0gYi5sZW5ndGgpXHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGEubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgbGV0IGdBID0gYVtpXSwgZ0IgPSBiW2ldO1xyXG4gICAgICAgICAgICBpZiAoZ0EuZnJvbSAhPSBnQi5mcm9tIHx8IGdBLnRvICE9IGdCLnRvIHx8IGdBLnNpemUgIT0gZ0Iuc2l6ZSlcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgICBkcmF3KHdyYXBwaW5nKSB7XHJcbiAgICAgICAgcmV0dXJuIERlY29yYXRpb24ucmVwbGFjZSh7IHdpZGdldDogbmV3IExpbmVHYXBXaWRnZXQodGhpcy5zaXplLCB3cmFwcGluZykgfSkucmFuZ2UodGhpcy5mcm9tLCB0aGlzLnRvKTtcclxuICAgIH1cclxufVxyXG5jbGFzcyBMaW5lR2FwV2lkZ2V0IGV4dGVuZHMgV2lkZ2V0VHlwZSB7XHJcbiAgICBjb25zdHJ1Y3RvcihzaXplLCB2ZXJ0aWNhbCkge1xyXG4gICAgICAgIHN1cGVyKCk7XHJcbiAgICAgICAgdGhpcy5zaXplID0gc2l6ZTtcclxuICAgICAgICB0aGlzLnZlcnRpY2FsID0gdmVydGljYWw7XHJcbiAgICB9XHJcbiAgICBlcShvdGhlcikgeyByZXR1cm4gb3RoZXIuc2l6ZSA9PSB0aGlzLnNpemUgJiYgb3RoZXIudmVydGljYWwgPT0gdGhpcy52ZXJ0aWNhbDsgfVxyXG4gICAgdG9ET00oKSB7XHJcbiAgICAgICAgbGV0IGVsdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XHJcbiAgICAgICAgaWYgKHRoaXMudmVydGljYWwpIHtcclxuICAgICAgICAgICAgZWx0LnN0eWxlLmhlaWdodCA9IHRoaXMuc2l6ZSArIFwicHhcIjtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGVsdC5zdHlsZS53aWR0aCA9IHRoaXMuc2l6ZSArIFwicHhcIjtcclxuICAgICAgICAgICAgZWx0LnN0eWxlLmhlaWdodCA9IFwiMnB4XCI7XHJcbiAgICAgICAgICAgIGVsdC5zdHlsZS5kaXNwbGF5ID0gXCJpbmxpbmUtYmxvY2tcIjtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGVsdDtcclxuICAgIH1cclxuICAgIGdldCBlc3RpbWF0ZWRIZWlnaHQoKSB7IHJldHVybiB0aGlzLnZlcnRpY2FsID8gdGhpcy5zaXplIDogLTE7IH1cclxufVxyXG5jbGFzcyBWaWV3U3RhdGUge1xyXG4gICAgY29uc3RydWN0b3Ioc3RhdGUpIHtcclxuICAgICAgICB0aGlzLnN0YXRlID0gc3RhdGU7XHJcbiAgICAgICAgLy8gVGhlc2UgYXJlIGNvbnRlbnRET00tbG9jYWwgY29vcmRpbmF0ZXNcclxuICAgICAgICB0aGlzLnBpeGVsVmlld3BvcnQgPSB7IGxlZnQ6IDAsIHJpZ2h0OiB3aW5kb3cuaW5uZXJXaWR0aCwgdG9wOiAwLCBib3R0b206IDAgfTtcclxuICAgICAgICB0aGlzLmluVmlldyA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5wYWRkaW5nVG9wID0gMDtcclxuICAgICAgICB0aGlzLnBhZGRpbmdCb3R0b20gPSAwO1xyXG4gICAgICAgIHRoaXMuY29udGVudERPTVdpZHRoID0gMDtcclxuICAgICAgICB0aGlzLmNvbnRlbnRET01IZWlnaHQgPSAwO1xyXG4gICAgICAgIHRoaXMuZWRpdG9ySGVpZ2h0ID0gMDtcclxuICAgICAgICB0aGlzLmVkaXRvcldpZHRoID0gMDtcclxuICAgICAgICAvLyBTZWUgVlAuTWF4RE9NSGVpZ2h0XHJcbiAgICAgICAgdGhpcy5zY2FsZXIgPSBJZFNjYWxlcjtcclxuICAgICAgICB0aGlzLnNjcm9sbFRhcmdldCA9IG51bGw7XHJcbiAgICAgICAgLy8gQnJpZWZseSBzZXQgdG8gdHJ1ZSB3aGVuIHByaW50aW5nLCB0byBkaXNhYmxlIHZpZXdwb3J0IGxpbWl0aW5nXHJcbiAgICAgICAgdGhpcy5wcmludGluZyA9IGZhbHNlO1xyXG4gICAgICAgIC8vIEZsYWcgc2V0IHdoZW4gZWRpdG9yIGNvbnRlbnQgd2FzIHJlZHJhd24sIHNvIHRoYXQgdGhlIG5leHRcclxuICAgICAgICAvLyBtZWFzdXJlIHN0YWdlIGtub3dzIGl0IG11c3QgcmVhZCBET00gbGF5b3V0XHJcbiAgICAgICAgdGhpcy5tdXN0TWVhc3VyZUNvbnRlbnQgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMuZGVmYXVsdFRleHREaXJlY3Rpb24gPSBEaXJlY3Rpb24uTFRSO1xyXG4gICAgICAgIHRoaXMudmlzaWJsZVJhbmdlcyA9IFtdO1xyXG4gICAgICAgIC8vIEN1cnNvciAnYXNzb2MnIGlzIG9ubHkgc2lnbmlmaWNhbnQgd2hlbiB0aGUgY3Vyc29yIGlzIG9uIGEgbGluZVxyXG4gICAgICAgIC8vIHdyYXAgcG9pbnQsIHdoZXJlIGl0IG11c3Qgc3RpY2sgdG8gdGhlIGNoYXJhY3RlciB0aGF0IGl0IGlzXHJcbiAgICAgICAgLy8gYXNzb2NpYXRlZCB3aXRoLiBTaW5jZSBicm93c2VycyBkb24ndCBwcm92aWRlIGEgcmVhc29uYWJsZVxyXG4gICAgICAgIC8vIGludGVyZmFjZSB0byBzZXQgb3IgcXVlcnkgdGhpcywgd2hlbiBhIHNlbGVjdGlvbiBpcyBzZXQgdGhhdFxyXG4gICAgICAgIC8vIG1pZ2h0IGNhdXNlIHRoaXMgdG8gYmUgc2lnbmlmaWNhbnQsIHRoaXMgZmxhZyBpcyBzZXQuIFRoZSBuZXh0XHJcbiAgICAgICAgLy8gbWVhc3VyZSBwaGFzZSB3aWxsIGNoZWNrIHdoZXRoZXIgdGhlIGN1cnNvciBpcyBvbiBhIGxpbmUtd3JhcHBpbmdcclxuICAgICAgICAvLyBib3VuZGFyeSBhbmQsIGlmIHNvLCByZXNldCBpdCB0byBtYWtlIHN1cmUgaXQgaXMgcG9zaXRpb25lZCBpblxyXG4gICAgICAgIC8vIHRoZSByaWdodCBwbGFjZS5cclxuICAgICAgICB0aGlzLm11c3RFbmZvcmNlQ3Vyc29yQXNzb2MgPSBmYWxzZTtcclxuICAgICAgICBsZXQgZ3Vlc3NXcmFwcGluZyA9IHN0YXRlLmZhY2V0KGNvbnRlbnRBdHRyaWJ1dGVzKS5zb21lKHYgPT4gdHlwZW9mIHYgIT0gXCJmdW5jdGlvblwiICYmIHYuY2xhc3MgPT0gXCJjbS1saW5lV3JhcHBpbmdcIik7XHJcbiAgICAgICAgdGhpcy5oZWlnaHRPcmFjbGUgPSBuZXcgSGVpZ2h0T3JhY2xlKGd1ZXNzV3JhcHBpbmcpO1xyXG4gICAgICAgIHRoaXMuc3RhdGVEZWNvID0gc3RhdGUuZmFjZXQoZGVjb3JhdGlvbnMpLmZpbHRlcihkID0+IHR5cGVvZiBkICE9IFwiZnVuY3Rpb25cIik7XHJcbiAgICAgICAgdGhpcy5oZWlnaHRNYXAgPSBIZWlnaHRNYXAuZW1wdHkoKS5hcHBseUNoYW5nZXModGhpcy5zdGF0ZURlY28sIFRleHQuZW1wdHksIHRoaXMuaGVpZ2h0T3JhY2xlLnNldERvYyhzdGF0ZS5kb2MpLCBbbmV3IENoYW5nZWRSYW5nZSgwLCAwLCAwLCBzdGF0ZS5kb2MubGVuZ3RoKV0pO1xyXG4gICAgICAgIHRoaXMudmlld3BvcnQgPSB0aGlzLmdldFZpZXdwb3J0KDAsIG51bGwpO1xyXG4gICAgICAgIHRoaXMudXBkYXRlVmlld3BvcnRMaW5lcygpO1xyXG4gICAgICAgIHRoaXMudXBkYXRlRm9yVmlld3BvcnQoKTtcclxuICAgICAgICB0aGlzLmxpbmVHYXBzID0gdGhpcy5lbnN1cmVMaW5lR2FwcyhbXSk7XHJcbiAgICAgICAgdGhpcy5saW5lR2FwRGVjbyA9IERlY29yYXRpb24uc2V0KHRoaXMubGluZUdhcHMubWFwKGdhcCA9PiBnYXAuZHJhdyhmYWxzZSkpKTtcclxuICAgICAgICB0aGlzLmNvbXB1dGVWaXNpYmxlUmFuZ2VzKCk7XHJcbiAgICB9XHJcbiAgICB1cGRhdGVGb3JWaWV3cG9ydCgpIHtcclxuICAgICAgICBsZXQgdmlld3BvcnRzID0gW3RoaXMudmlld3BvcnRdLCB7IG1haW4gfSA9IHRoaXMuc3RhdGUuc2VsZWN0aW9uO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDw9IDE7IGkrKykge1xyXG4gICAgICAgICAgICBsZXQgcG9zID0gaSA/IG1haW4uaGVhZCA6IG1haW4uYW5jaG9yO1xyXG4gICAgICAgICAgICBpZiAoIXZpZXdwb3J0cy5zb21lKCh7IGZyb20sIHRvIH0pID0+IHBvcyA+PSBmcm9tICYmIHBvcyA8PSB0bykpIHtcclxuICAgICAgICAgICAgICAgIGxldCB7IGZyb20sIHRvIH0gPSB0aGlzLmxpbmVCbG9ja0F0KHBvcyk7XHJcbiAgICAgICAgICAgICAgICB2aWV3cG9ydHMucHVzaChuZXcgVmlld3BvcnQoZnJvbSwgdG8pKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnZpZXdwb3J0cyA9IHZpZXdwb3J0cy5zb3J0KChhLCBiKSA9PiBhLmZyb20gLSBiLmZyb20pO1xyXG4gICAgICAgIHRoaXMuc2NhbGVyID0gdGhpcy5oZWlnaHRNYXAuaGVpZ2h0IDw9IDcwMDAwMDAgLyogVlAuTWF4RE9NSGVpZ2h0ICovID8gSWRTY2FsZXIgOlxyXG4gICAgICAgICAgICBuZXcgQmlnU2NhbGVyKHRoaXMuaGVpZ2h0T3JhY2xlLmRvYywgdGhpcy5oZWlnaHRNYXAsIHRoaXMudmlld3BvcnRzKTtcclxuICAgIH1cclxuICAgIHVwZGF0ZVZpZXdwb3J0TGluZXMoKSB7XHJcbiAgICAgICAgdGhpcy52aWV3cG9ydExpbmVzID0gW107XHJcbiAgICAgICAgdGhpcy5oZWlnaHRNYXAuZm9yRWFjaExpbmUodGhpcy52aWV3cG9ydC5mcm9tLCB0aGlzLnZpZXdwb3J0LnRvLCB0aGlzLnN0YXRlLmRvYywgMCwgMCwgYmxvY2sgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLnZpZXdwb3J0TGluZXMucHVzaCh0aGlzLnNjYWxlci5zY2FsZSA9PSAxID8gYmxvY2sgOiBzY2FsZUJsb2NrKGJsb2NrLCB0aGlzLnNjYWxlcikpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgdXBkYXRlKHVwZGF0ZSwgc2Nyb2xsVGFyZ2V0ID0gbnVsbCkge1xyXG4gICAgICAgIHRoaXMuc3RhdGUgPSB1cGRhdGUuc3RhdGU7XHJcbiAgICAgICAgbGV0IHByZXZEZWNvID0gdGhpcy5zdGF0ZURlY287XHJcbiAgICAgICAgdGhpcy5zdGF0ZURlY28gPSB0aGlzLnN0YXRlLmZhY2V0KGRlY29yYXRpb25zKS5maWx0ZXIoZCA9PiB0eXBlb2YgZCAhPSBcImZ1bmN0aW9uXCIpO1xyXG4gICAgICAgIGxldCBjb250ZW50Q2hhbmdlcyA9IHVwZGF0ZS5jaGFuZ2VkUmFuZ2VzO1xyXG4gICAgICAgIGxldCBoZWlnaHRDaGFuZ2VzID0gQ2hhbmdlZFJhbmdlLmV4dGVuZFdpdGhSYW5nZXMoY29udGVudENoYW5nZXMsIGhlaWdodFJlbGV2YW50RGVjb0NoYW5nZXMocHJldkRlY28sIHRoaXMuc3RhdGVEZWNvLCB1cGRhdGUgPyB1cGRhdGUuY2hhbmdlcyA6IENoYW5nZVNldC5lbXB0eSh0aGlzLnN0YXRlLmRvYy5sZW5ndGgpKSk7XHJcbiAgICAgICAgbGV0IHByZXZIZWlnaHQgPSB0aGlzLmhlaWdodE1hcC5oZWlnaHQ7XHJcbiAgICAgICAgdGhpcy5oZWlnaHRNYXAgPSB0aGlzLmhlaWdodE1hcC5hcHBseUNoYW5nZXModGhpcy5zdGF0ZURlY28sIHVwZGF0ZS5zdGFydFN0YXRlLmRvYywgdGhpcy5oZWlnaHRPcmFjbGUuc2V0RG9jKHRoaXMuc3RhdGUuZG9jKSwgaGVpZ2h0Q2hhbmdlcyk7XHJcbiAgICAgICAgaWYgKHRoaXMuaGVpZ2h0TWFwLmhlaWdodCAhPSBwcmV2SGVpZ2h0KVxyXG4gICAgICAgICAgICB1cGRhdGUuZmxhZ3MgfD0gMiAvKiBVcGRhdGVGbGFnLkhlaWdodCAqLztcclxuICAgICAgICBsZXQgdmlld3BvcnQgPSBoZWlnaHRDaGFuZ2VzLmxlbmd0aCA/IHRoaXMubWFwVmlld3BvcnQodGhpcy52aWV3cG9ydCwgdXBkYXRlLmNoYW5nZXMpIDogdGhpcy52aWV3cG9ydDtcclxuICAgICAgICBpZiAoc2Nyb2xsVGFyZ2V0ICYmIChzY3JvbGxUYXJnZXQucmFuZ2UuaGVhZCA8IHZpZXdwb3J0LmZyb20gfHwgc2Nyb2xsVGFyZ2V0LnJhbmdlLmhlYWQgPiB2aWV3cG9ydC50bykgfHxcclxuICAgICAgICAgICAgIXRoaXMudmlld3BvcnRJc0FwcHJvcHJpYXRlKHZpZXdwb3J0KSlcclxuICAgICAgICAgICAgdmlld3BvcnQgPSB0aGlzLmdldFZpZXdwb3J0KDAsIHNjcm9sbFRhcmdldCk7XHJcbiAgICAgICAgbGV0IHVwZGF0ZUxpbmVzID0gIXVwZGF0ZS5jaGFuZ2VzLmVtcHR5IHx8ICh1cGRhdGUuZmxhZ3MgJiAyIC8qIFVwZGF0ZUZsYWcuSGVpZ2h0ICovKSB8fFxyXG4gICAgICAgICAgICB2aWV3cG9ydC5mcm9tICE9IHRoaXMudmlld3BvcnQuZnJvbSB8fCB2aWV3cG9ydC50byAhPSB0aGlzLnZpZXdwb3J0LnRvO1xyXG4gICAgICAgIHRoaXMudmlld3BvcnQgPSB2aWV3cG9ydDtcclxuICAgICAgICB0aGlzLnVwZGF0ZUZvclZpZXdwb3J0KCk7XHJcbiAgICAgICAgaWYgKHVwZGF0ZUxpbmVzKVxyXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVZpZXdwb3J0TGluZXMoKTtcclxuICAgICAgICBpZiAodGhpcy5saW5lR2Fwcy5sZW5ndGggfHwgdGhpcy52aWV3cG9ydC50byAtIHRoaXMudmlld3BvcnQuZnJvbSA+ICgyMDAwIC8qIExHLk1hcmdpbiAqLyA8PCAxKSlcclxuICAgICAgICAgICAgdGhpcy51cGRhdGVMaW5lR2Fwcyh0aGlzLmVuc3VyZUxpbmVHYXBzKHRoaXMubWFwTGluZUdhcHModGhpcy5saW5lR2FwcywgdXBkYXRlLmNoYW5nZXMpKSk7XHJcbiAgICAgICAgdXBkYXRlLmZsYWdzIHw9IHRoaXMuY29tcHV0ZVZpc2libGVSYW5nZXMoKTtcclxuICAgICAgICBpZiAoc2Nyb2xsVGFyZ2V0KVxyXG4gICAgICAgICAgICB0aGlzLnNjcm9sbFRhcmdldCA9IHNjcm9sbFRhcmdldDtcclxuICAgICAgICBpZiAoIXRoaXMubXVzdEVuZm9yY2VDdXJzb3JBc3NvYyAmJiB1cGRhdGUuc2VsZWN0aW9uU2V0ICYmIHVwZGF0ZS52aWV3LmxpbmVXcmFwcGluZyAmJlxyXG4gICAgICAgICAgICB1cGRhdGUuc3RhdGUuc2VsZWN0aW9uLm1haW4uZW1wdHkgJiYgdXBkYXRlLnN0YXRlLnNlbGVjdGlvbi5tYWluLmFzc29jICYmXHJcbiAgICAgICAgICAgICF1cGRhdGUuc3RhdGUuZmFjZXQobmF0aXZlU2VsZWN0aW9uSGlkZGVuKSlcclxuICAgICAgICAgICAgdGhpcy5tdXN0RW5mb3JjZUN1cnNvckFzc29jID0gdHJ1ZTtcclxuICAgIH1cclxuICAgIG1lYXN1cmUodmlldykge1xyXG4gICAgICAgIGxldCBkb20gPSB2aWV3LmNvbnRlbnRET00sIHN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZG9tKTtcclxuICAgICAgICBsZXQgb3JhY2xlID0gdGhpcy5oZWlnaHRPcmFjbGU7XHJcbiAgICAgICAgbGV0IHdoaXRlU3BhY2UgPSBzdHlsZS53aGl0ZVNwYWNlO1xyXG4gICAgICAgIHRoaXMuZGVmYXVsdFRleHREaXJlY3Rpb24gPSBzdHlsZS5kaXJlY3Rpb24gPT0gXCJydGxcIiA/IERpcmVjdGlvbi5SVEwgOiBEaXJlY3Rpb24uTFRSO1xyXG4gICAgICAgIGxldCByZWZyZXNoID0gdGhpcy5oZWlnaHRPcmFjbGUubXVzdFJlZnJlc2hGb3JXcmFwcGluZyh3aGl0ZVNwYWNlKTtcclxuICAgICAgICBsZXQgbWVhc3VyZUNvbnRlbnQgPSByZWZyZXNoIHx8IHRoaXMubXVzdE1lYXN1cmVDb250ZW50IHx8IHRoaXMuY29udGVudERPTUhlaWdodCAhPSBkb20uY2xpZW50SGVpZ2h0O1xyXG4gICAgICAgIHRoaXMuY29udGVudERPTUhlaWdodCA9IGRvbS5jbGllbnRIZWlnaHQ7XHJcbiAgICAgICAgdGhpcy5tdXN0TWVhc3VyZUNvbnRlbnQgPSBmYWxzZTtcclxuICAgICAgICBsZXQgcmVzdWx0ID0gMCwgYmlhcyA9IDA7XHJcbiAgICAgICAgLy8gVmVydGljYWwgcGFkZGluZ1xyXG4gICAgICAgIGxldCBwYWRkaW5nVG9wID0gcGFyc2VJbnQoc3R5bGUucGFkZGluZ1RvcCkgfHwgMCwgcGFkZGluZ0JvdHRvbSA9IHBhcnNlSW50KHN0eWxlLnBhZGRpbmdCb3R0b20pIHx8IDA7XHJcbiAgICAgICAgaWYgKHRoaXMucGFkZGluZ1RvcCAhPSBwYWRkaW5nVG9wIHx8IHRoaXMucGFkZGluZ0JvdHRvbSAhPSBwYWRkaW5nQm90dG9tKSB7XHJcbiAgICAgICAgICAgIHRoaXMucGFkZGluZ1RvcCA9IHBhZGRpbmdUb3A7XHJcbiAgICAgICAgICAgIHRoaXMucGFkZGluZ0JvdHRvbSA9IHBhZGRpbmdCb3R0b207XHJcbiAgICAgICAgICAgIHJlc3VsdCB8PSA4IC8qIFVwZGF0ZUZsYWcuR2VvbWV0cnkgKi8gfCAyIC8qIFVwZGF0ZUZsYWcuSGVpZ2h0ICovO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5lZGl0b3JXaWR0aCAhPSB2aWV3LnNjcm9sbERPTS5jbGllbnRXaWR0aCkge1xyXG4gICAgICAgICAgICBpZiAob3JhY2xlLmxpbmVXcmFwcGluZylcclxuICAgICAgICAgICAgICAgIG1lYXN1cmVDb250ZW50ID0gdHJ1ZTtcclxuICAgICAgICAgICAgdGhpcy5lZGl0b3JXaWR0aCA9IHZpZXcuc2Nyb2xsRE9NLmNsaWVudFdpZHRoO1xyXG4gICAgICAgICAgICByZXN1bHQgfD0gOCAvKiBVcGRhdGVGbGFnLkdlb21ldHJ5ICovO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBQaXhlbCB2aWV3cG9ydFxyXG4gICAgICAgIGxldCBwaXhlbFZpZXdwb3J0ID0gKHRoaXMucHJpbnRpbmcgPyBmdWxsUGl4ZWxSYW5nZSA6IHZpc2libGVQaXhlbFJhbmdlKShkb20sIHRoaXMucGFkZGluZ1RvcCk7XHJcbiAgICAgICAgbGV0IGRUb3AgPSBwaXhlbFZpZXdwb3J0LnRvcCAtIHRoaXMucGl4ZWxWaWV3cG9ydC50b3AsIGRCb3R0b20gPSBwaXhlbFZpZXdwb3J0LmJvdHRvbSAtIHRoaXMucGl4ZWxWaWV3cG9ydC5ib3R0b207XHJcbiAgICAgICAgdGhpcy5waXhlbFZpZXdwb3J0ID0gcGl4ZWxWaWV3cG9ydDtcclxuICAgICAgICBsZXQgaW5WaWV3ID0gdGhpcy5waXhlbFZpZXdwb3J0LmJvdHRvbSA+IHRoaXMucGl4ZWxWaWV3cG9ydC50b3AgJiYgdGhpcy5waXhlbFZpZXdwb3J0LnJpZ2h0ID4gdGhpcy5waXhlbFZpZXdwb3J0LmxlZnQ7XHJcbiAgICAgICAgaWYgKGluVmlldyAhPSB0aGlzLmluVmlldykge1xyXG4gICAgICAgICAgICB0aGlzLmluVmlldyA9IGluVmlldztcclxuICAgICAgICAgICAgaWYgKGluVmlldylcclxuICAgICAgICAgICAgICAgIG1lYXN1cmVDb250ZW50ID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCF0aGlzLmluVmlldyAmJiAhdGhpcy5zY3JvbGxUYXJnZXQpXHJcbiAgICAgICAgICAgIHJldHVybiAwO1xyXG4gICAgICAgIGxldCBjb250ZW50V2lkdGggPSBkb20uY2xpZW50V2lkdGg7XHJcbiAgICAgICAgaWYgKHRoaXMuY29udGVudERPTVdpZHRoICE9IGNvbnRlbnRXaWR0aCB8fCB0aGlzLmVkaXRvckhlaWdodCAhPSB2aWV3LnNjcm9sbERPTS5jbGllbnRIZWlnaHQpIHtcclxuICAgICAgICAgICAgdGhpcy5jb250ZW50RE9NV2lkdGggPSBjb250ZW50V2lkdGg7XHJcbiAgICAgICAgICAgIHRoaXMuZWRpdG9ySGVpZ2h0ID0gdmlldy5zY3JvbGxET00uY2xpZW50SGVpZ2h0O1xyXG4gICAgICAgICAgICByZXN1bHQgfD0gOCAvKiBVcGRhdGVGbGFnLkdlb21ldHJ5ICovO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobWVhc3VyZUNvbnRlbnQpIHtcclxuICAgICAgICAgICAgbGV0IGxpbmVIZWlnaHRzID0gdmlldy5kb2NWaWV3Lm1lYXN1cmVWaXNpYmxlTGluZUhlaWdodHModGhpcy52aWV3cG9ydCk7XHJcbiAgICAgICAgICAgIGlmIChvcmFjbGUubXVzdFJlZnJlc2hGb3JIZWlnaHRzKGxpbmVIZWlnaHRzKSlcclxuICAgICAgICAgICAgICAgIHJlZnJlc2ggPSB0cnVlO1xyXG4gICAgICAgICAgICBpZiAocmVmcmVzaCB8fCBvcmFjbGUubGluZVdyYXBwaW5nICYmIE1hdGguYWJzKGNvbnRlbnRXaWR0aCAtIHRoaXMuY29udGVudERPTVdpZHRoKSA+IG9yYWNsZS5jaGFyV2lkdGgpIHtcclxuICAgICAgICAgICAgICAgIGxldCB7IGxpbmVIZWlnaHQsIGNoYXJXaWR0aCB9ID0gdmlldy5kb2NWaWV3Lm1lYXN1cmVUZXh0U2l6ZSgpO1xyXG4gICAgICAgICAgICAgICAgcmVmcmVzaCA9IGxpbmVIZWlnaHQgPiAwICYmIG9yYWNsZS5yZWZyZXNoKHdoaXRlU3BhY2UsIGxpbmVIZWlnaHQsIGNoYXJXaWR0aCwgY29udGVudFdpZHRoIC8gY2hhcldpZHRoLCBsaW5lSGVpZ2h0cyk7XHJcbiAgICAgICAgICAgICAgICBpZiAocmVmcmVzaCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZpZXcuZG9jVmlldy5taW5XaWR0aCA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0IHw9IDggLyogVXBkYXRlRmxhZy5HZW9tZXRyeSAqLztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoZFRvcCA+IDAgJiYgZEJvdHRvbSA+IDApXHJcbiAgICAgICAgICAgICAgICBiaWFzID0gTWF0aC5tYXgoZFRvcCwgZEJvdHRvbSk7XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGRUb3AgPCAwICYmIGRCb3R0b20gPCAwKVxyXG4gICAgICAgICAgICAgICAgYmlhcyA9IE1hdGgubWluKGRUb3AsIGRCb3R0b20pO1xyXG4gICAgICAgICAgICBvcmFjbGUuaGVpZ2h0Q2hhbmdlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICBmb3IgKGxldCB2cCBvZiB0aGlzLnZpZXdwb3J0cykge1xyXG4gICAgICAgICAgICAgICAgbGV0IGhlaWdodHMgPSB2cC5mcm9tID09IHRoaXMudmlld3BvcnQuZnJvbSA/IGxpbmVIZWlnaHRzIDogdmlldy5kb2NWaWV3Lm1lYXN1cmVWaXNpYmxlTGluZUhlaWdodHModnApO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5oZWlnaHRNYXAgPSAocmVmcmVzaCA/IEhlaWdodE1hcC5lbXB0eSgpLmFwcGx5Q2hhbmdlcyh0aGlzLnN0YXRlRGVjbywgVGV4dC5lbXB0eSwgdGhpcy5oZWlnaHRPcmFjbGUsIFtuZXcgQ2hhbmdlZFJhbmdlKDAsIDAsIDAsIHZpZXcuc3RhdGUuZG9jLmxlbmd0aCldKSA6IHRoaXMuaGVpZ2h0TWFwKS51cGRhdGVIZWlnaHQob3JhY2xlLCAwLCByZWZyZXNoLCBuZXcgTWVhc3VyZWRIZWlnaHRzKHZwLmZyb20sIGhlaWdodHMpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAob3JhY2xlLmhlaWdodENoYW5nZWQpXHJcbiAgICAgICAgICAgICAgICByZXN1bHQgfD0gMiAvKiBVcGRhdGVGbGFnLkhlaWdodCAqLztcclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IHZpZXdwb3J0Q2hhbmdlID0gIXRoaXMudmlld3BvcnRJc0FwcHJvcHJpYXRlKHRoaXMudmlld3BvcnQsIGJpYXMpIHx8XHJcbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsVGFyZ2V0ICYmICh0aGlzLnNjcm9sbFRhcmdldC5yYW5nZS5oZWFkIDwgdGhpcy52aWV3cG9ydC5mcm9tIHx8IHRoaXMuc2Nyb2xsVGFyZ2V0LnJhbmdlLmhlYWQgPiB0aGlzLnZpZXdwb3J0LnRvKTtcclxuICAgICAgICBpZiAodmlld3BvcnRDaGFuZ2UpXHJcbiAgICAgICAgICAgIHRoaXMudmlld3BvcnQgPSB0aGlzLmdldFZpZXdwb3J0KGJpYXMsIHRoaXMuc2Nyb2xsVGFyZ2V0KTtcclxuICAgICAgICB0aGlzLnVwZGF0ZUZvclZpZXdwb3J0KCk7XHJcbiAgICAgICAgaWYgKChyZXN1bHQgJiAyIC8qIFVwZGF0ZUZsYWcuSGVpZ2h0ICovKSB8fCB2aWV3cG9ydENoYW5nZSlcclxuICAgICAgICAgICAgdGhpcy51cGRhdGVWaWV3cG9ydExpbmVzKCk7XHJcbiAgICAgICAgaWYgKHRoaXMubGluZUdhcHMubGVuZ3RoIHx8IHRoaXMudmlld3BvcnQudG8gLSB0aGlzLnZpZXdwb3J0LmZyb20gPiAoMjAwMCAvKiBMRy5NYXJnaW4gKi8gPDwgMSkpXHJcbiAgICAgICAgICAgIHRoaXMudXBkYXRlTGluZUdhcHModGhpcy5lbnN1cmVMaW5lR2FwcyhyZWZyZXNoID8gW10gOiB0aGlzLmxpbmVHYXBzLCB2aWV3KSk7XHJcbiAgICAgICAgcmVzdWx0IHw9IHRoaXMuY29tcHV0ZVZpc2libGVSYW5nZXMoKTtcclxuICAgICAgICBpZiAodGhpcy5tdXN0RW5mb3JjZUN1cnNvckFzc29jKSB7XHJcbiAgICAgICAgICAgIHRoaXMubXVzdEVuZm9yY2VDdXJzb3JBc3NvYyA9IGZhbHNlO1xyXG4gICAgICAgICAgICAvLyBUaGlzIGlzIGRvbmUgaW4gdGhlIHJlYWQgc3RhZ2UsIGJlY2F1c2UgbW92aW5nIHRoZSBzZWxlY3Rpb25cclxuICAgICAgICAgICAgLy8gdG8gYSBsaW5lIGVuZCBpcyBnb2luZyB0byB0cmlnZ2VyIGEgbGF5b3V0IGFueXdheSwgc28gaXRcclxuICAgICAgICAgICAgLy8gY2FuJ3QgYmUgYSBwdXJlIHdyaXRlLiBJdCBzaG91bGQgYmUgcmFyZSB0aGF0IGl0IGRvZXMgYW55XHJcbiAgICAgICAgICAgIC8vIHdyaXRpbmcuXHJcbiAgICAgICAgICAgIHZpZXcuZG9jVmlldy5lbmZvcmNlQ3Vyc29yQXNzb2MoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuICAgIGdldCB2aXNpYmxlVG9wKCkgeyByZXR1cm4gdGhpcy5zY2FsZXIuZnJvbURPTSh0aGlzLnBpeGVsVmlld3BvcnQudG9wKTsgfVxyXG4gICAgZ2V0IHZpc2libGVCb3R0b20oKSB7IHJldHVybiB0aGlzLnNjYWxlci5mcm9tRE9NKHRoaXMucGl4ZWxWaWV3cG9ydC5ib3R0b20pOyB9XHJcbiAgICBnZXRWaWV3cG9ydChiaWFzLCBzY3JvbGxUYXJnZXQpIHtcclxuICAgICAgICAvLyBUaGlzIHdpbGwgZGl2aWRlIFZQLk1hcmdpbiBiZXR3ZWVuIHRoZSB0b3AgYW5kIHRoZVxyXG4gICAgICAgIC8vIGJvdHRvbSwgZGVwZW5kaW5nIG9uIHRoZSBiaWFzICh0aGUgY2hhbmdlIGluIHZpZXdwb3J0IHBvc2l0aW9uXHJcbiAgICAgICAgLy8gc2luY2UgdGhlIGxhc3QgdXBkYXRlKS4gSXQnbGwgaG9sZCBhIG51bWJlciBiZXR3ZWVuIDAgYW5kIDFcclxuICAgICAgICBsZXQgbWFyZ2luVG9wID0gMC41IC0gTWF0aC5tYXgoLTAuNSwgTWF0aC5taW4oMC41LCBiaWFzIC8gMTAwMCAvKiBWUC5NYXJnaW4gKi8gLyAyKSk7XHJcbiAgICAgICAgbGV0IG1hcCA9IHRoaXMuaGVpZ2h0TWFwLCBkb2MgPSB0aGlzLnN0YXRlLmRvYywgeyB2aXNpYmxlVG9wLCB2aXNpYmxlQm90dG9tIH0gPSB0aGlzO1xyXG4gICAgICAgIGxldCB2aWV3cG9ydCA9IG5ldyBWaWV3cG9ydChtYXAubGluZUF0KHZpc2libGVUb3AgLSBtYXJnaW5Ub3AgKiAxMDAwIC8qIFZQLk1hcmdpbiAqLywgUXVlcnlUeXBlLkJ5SGVpZ2h0LCBkb2MsIDAsIDApLmZyb20sIG1hcC5saW5lQXQodmlzaWJsZUJvdHRvbSArICgxIC0gbWFyZ2luVG9wKSAqIDEwMDAgLyogVlAuTWFyZ2luICovLCBRdWVyeVR5cGUuQnlIZWlnaHQsIGRvYywgMCwgMCkudG8pO1xyXG4gICAgICAgIC8vIElmIHNjcm9sbFRhcmdldCBpcyBnaXZlbiwgbWFrZSBzdXJlIHRoZSB2aWV3cG9ydCBpbmNsdWRlcyB0aGF0IHBvc2l0aW9uXHJcbiAgICAgICAgaWYgKHNjcm9sbFRhcmdldCkge1xyXG4gICAgICAgICAgICBsZXQgeyBoZWFkIH0gPSBzY3JvbGxUYXJnZXQucmFuZ2U7XHJcbiAgICAgICAgICAgIGlmIChoZWFkIDwgdmlld3BvcnQuZnJvbSB8fCBoZWFkID4gdmlld3BvcnQudG8pIHtcclxuICAgICAgICAgICAgICAgIGxldCB2aWV3SGVpZ2h0ID0gTWF0aC5taW4odGhpcy5lZGl0b3JIZWlnaHQsIHRoaXMucGl4ZWxWaWV3cG9ydC5ib3R0b20gLSB0aGlzLnBpeGVsVmlld3BvcnQudG9wKTtcclxuICAgICAgICAgICAgICAgIGxldCBibG9jayA9IG1hcC5saW5lQXQoaGVhZCwgUXVlcnlUeXBlLkJ5UG9zLCBkb2MsIDAsIDApLCB0b3BQb3M7XHJcbiAgICAgICAgICAgICAgICBpZiAoc2Nyb2xsVGFyZ2V0LnkgPT0gXCJjZW50ZXJcIilcclxuICAgICAgICAgICAgICAgICAgICB0b3BQb3MgPSAoYmxvY2sudG9wICsgYmxvY2suYm90dG9tKSAvIDIgLSB2aWV3SGVpZ2h0IC8gMjtcclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHNjcm9sbFRhcmdldC55ID09IFwic3RhcnRcIiB8fCBzY3JvbGxUYXJnZXQueSA9PSBcIm5lYXJlc3RcIiAmJiBoZWFkIDwgdmlld3BvcnQuZnJvbSlcclxuICAgICAgICAgICAgICAgICAgICB0b3BQb3MgPSBibG9jay50b3A7XHJcbiAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgdG9wUG9zID0gYmxvY2suYm90dG9tIC0gdmlld0hlaWdodDtcclxuICAgICAgICAgICAgICAgIHZpZXdwb3J0ID0gbmV3IFZpZXdwb3J0KG1hcC5saW5lQXQodG9wUG9zIC0gMTAwMCAvKiBWUC5NYXJnaW4gKi8gLyAyLCBRdWVyeVR5cGUuQnlIZWlnaHQsIGRvYywgMCwgMCkuZnJvbSwgbWFwLmxpbmVBdCh0b3BQb3MgKyB2aWV3SGVpZ2h0ICsgMTAwMCAvKiBWUC5NYXJnaW4gKi8gLyAyLCBRdWVyeVR5cGUuQnlIZWlnaHQsIGRvYywgMCwgMCkudG8pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB2aWV3cG9ydDtcclxuICAgIH1cclxuICAgIG1hcFZpZXdwb3J0KHZpZXdwb3J0LCBjaGFuZ2VzKSB7XHJcbiAgICAgICAgbGV0IGZyb20gPSBjaGFuZ2VzLm1hcFBvcyh2aWV3cG9ydC5mcm9tLCAtMSksIHRvID0gY2hhbmdlcy5tYXBQb3Modmlld3BvcnQudG8sIDEpO1xyXG4gICAgICAgIHJldHVybiBuZXcgVmlld3BvcnQodGhpcy5oZWlnaHRNYXAubGluZUF0KGZyb20sIFF1ZXJ5VHlwZS5CeVBvcywgdGhpcy5zdGF0ZS5kb2MsIDAsIDApLmZyb20sIHRoaXMuaGVpZ2h0TWFwLmxpbmVBdCh0bywgUXVlcnlUeXBlLkJ5UG9zLCB0aGlzLnN0YXRlLmRvYywgMCwgMCkudG8pO1xyXG4gICAgfVxyXG4gICAgLy8gQ2hlY2tzIGlmIGEgZ2l2ZW4gdmlld3BvcnQgY292ZXJzIHRoZSB2aXNpYmxlIHBhcnQgb2YgdGhlXHJcbiAgICAvLyBkb2N1bWVudCBhbmQgbm90IHRvbyBtdWNoIGJleW9uZCB0aGF0LlxyXG4gICAgdmlld3BvcnRJc0FwcHJvcHJpYXRlKHsgZnJvbSwgdG8gfSwgYmlhcyA9IDApIHtcclxuICAgICAgICBpZiAoIXRoaXMuaW5WaWV3KVxyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICBsZXQgeyB0b3AgfSA9IHRoaXMuaGVpZ2h0TWFwLmxpbmVBdChmcm9tLCBRdWVyeVR5cGUuQnlQb3MsIHRoaXMuc3RhdGUuZG9jLCAwLCAwKTtcclxuICAgICAgICBsZXQgeyBib3R0b20gfSA9IHRoaXMuaGVpZ2h0TWFwLmxpbmVBdCh0bywgUXVlcnlUeXBlLkJ5UG9zLCB0aGlzLnN0YXRlLmRvYywgMCwgMCk7XHJcbiAgICAgICAgbGV0IHsgdmlzaWJsZVRvcCwgdmlzaWJsZUJvdHRvbSB9ID0gdGhpcztcclxuICAgICAgICByZXR1cm4gKGZyb20gPT0gMCB8fCB0b3AgPD0gdmlzaWJsZVRvcCAtIE1hdGgubWF4KDEwIC8qIFZQLk1pbkNvdmVyTWFyZ2luICovLCBNYXRoLm1pbigtYmlhcywgMjUwIC8qIFZQLk1heENvdmVyTWFyZ2luICovKSkpICYmXHJcbiAgICAgICAgICAgICh0byA9PSB0aGlzLnN0YXRlLmRvYy5sZW5ndGggfHxcclxuICAgICAgICAgICAgICAgIGJvdHRvbSA+PSB2aXNpYmxlQm90dG9tICsgTWF0aC5tYXgoMTAgLyogVlAuTWluQ292ZXJNYXJnaW4gKi8sIE1hdGgubWluKGJpYXMsIDI1MCAvKiBWUC5NYXhDb3Zlck1hcmdpbiAqLykpKSAmJlxyXG4gICAgICAgICAgICAodG9wID4gdmlzaWJsZVRvcCAtIDIgKiAxMDAwIC8qIFZQLk1hcmdpbiAqLyAmJiBib3R0b20gPCB2aXNpYmxlQm90dG9tICsgMiAqIDEwMDAgLyogVlAuTWFyZ2luICovKTtcclxuICAgIH1cclxuICAgIG1hcExpbmVHYXBzKGdhcHMsIGNoYW5nZXMpIHtcclxuICAgICAgICBpZiAoIWdhcHMubGVuZ3RoIHx8IGNoYW5nZXMuZW1wdHkpXHJcbiAgICAgICAgICAgIHJldHVybiBnYXBzO1xyXG4gICAgICAgIGxldCBtYXBwZWQgPSBbXTtcclxuICAgICAgICBmb3IgKGxldCBnYXAgb2YgZ2FwcylcclxuICAgICAgICAgICAgaWYgKCFjaGFuZ2VzLnRvdWNoZXNSYW5nZShnYXAuZnJvbSwgZ2FwLnRvKSlcclxuICAgICAgICAgICAgICAgIG1hcHBlZC5wdXNoKG5ldyBMaW5lR2FwKGNoYW5nZXMubWFwUG9zKGdhcC5mcm9tKSwgY2hhbmdlcy5tYXBQb3MoZ2FwLnRvKSwgZ2FwLnNpemUpKTtcclxuICAgICAgICByZXR1cm4gbWFwcGVkO1xyXG4gICAgfVxyXG4gICAgLy8gQ29tcHV0ZXMgcG9zaXRpb25zIGluIHRoZSB2aWV3cG9ydCB3aGVyZSB0aGUgc3RhcnQgb3IgZW5kIG9mIGFcclxuICAgIC8vIGxpbmUgc2hvdWxkIGJlIGhpZGRlbiwgdHJ5aW5nIHRvIHJldXNlIGV4aXN0aW5nIGxpbmUgZ2FwcyB3aGVuXHJcbiAgICAvLyBhcHByb3ByaWF0ZSB0byBhdm9pZCB1bm5lY2Nlc2FyeSByZWRyYXdzLlxyXG4gICAgLy8gVXNlcyBjcnVkZSBjaGFyYWN0ZXItY291bnRpbmcgZm9yIHRoZSBwb3NpdGlvbmluZyBhbmQgc2l6aW5nLFxyXG4gICAgLy8gc2luY2UgYWN0dWFsIERPTSBjb29yZGluYXRlcyBhcmVuJ3QgYWx3YXlzIGF2YWlsYWJsZSBhbmRcclxuICAgIC8vIHByZWRpY3RhYmxlLiBSZWxpZXMgb24gZ2VuZXJvdXMgbWFyZ2lucyAoc2VlIExHLk1hcmdpbikgdG8gaGlkZVxyXG4gICAgLy8gdGhlIGFydGlmYWN0cyB0aGlzIG1pZ2h0IHByb2R1Y2UgZnJvbSB0aGUgdXNlci5cclxuICAgIGVuc3VyZUxpbmVHYXBzKGN1cnJlbnQsIG1heU1lYXN1cmUpIHtcclxuICAgICAgICBsZXQgd3JhcHBpbmcgPSB0aGlzLmhlaWdodE9yYWNsZS5saW5lV3JhcHBpbmc7XHJcbiAgICAgICAgbGV0IG1hcmdpbiA9IHdyYXBwaW5nID8gMTAwMDAgLyogTEcuTWFyZ2luV3JhcCAqLyA6IDIwMDAgLyogTEcuTWFyZ2luICovLCBoYWxmTWFyZ2luID0gbWFyZ2luID4+IDEsIGRvdWJsZU1hcmdpbiA9IG1hcmdpbiA8PCAxO1xyXG4gICAgICAgIC8vIFRoZSBub24td3JhcHBpbmcgbG9naWMgd29uJ3Qgd29yayBhdCBhbGwgaW4gcHJlZG9taW5hbnRseSByaWdodC10by1sZWZ0IHRleHQuXHJcbiAgICAgICAgaWYgKHRoaXMuZGVmYXVsdFRleHREaXJlY3Rpb24gIT0gRGlyZWN0aW9uLkxUUiAmJiAhd3JhcHBpbmcpXHJcbiAgICAgICAgICAgIHJldHVybiBbXTtcclxuICAgICAgICBsZXQgZ2FwcyA9IFtdO1xyXG4gICAgICAgIGxldCBhZGRHYXAgPSAoZnJvbSwgdG8sIGxpbmUsIHN0cnVjdHVyZSkgPT4ge1xyXG4gICAgICAgICAgICBpZiAodG8gLSBmcm9tIDwgaGFsZk1hcmdpbilcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgbGV0IHNlbCA9IHRoaXMuc3RhdGUuc2VsZWN0aW9uLm1haW4sIGF2b2lkID0gW3NlbC5mcm9tXTtcclxuICAgICAgICAgICAgaWYgKCFzZWwuZW1wdHkpXHJcbiAgICAgICAgICAgICAgICBhdm9pZC5wdXNoKHNlbC50byk7XHJcbiAgICAgICAgICAgIGZvciAobGV0IHBvcyBvZiBhdm9pZCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHBvcyA+IGZyb20gJiYgcG9zIDwgdG8pIHtcclxuICAgICAgICAgICAgICAgICAgICBhZGRHYXAoZnJvbSwgcG9zIC0gMTAgLyogTEcuU2VsZWN0aW9uTWFyZ2luICovLCBsaW5lLCBzdHJ1Y3R1cmUpO1xyXG4gICAgICAgICAgICAgICAgICAgIGFkZEdhcChwb3MgKyAxMCAvKiBMRy5TZWxlY3Rpb25NYXJnaW4gKi8sIHRvLCBsaW5lLCBzdHJ1Y3R1cmUpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBsZXQgZ2FwID0gZmluZChjdXJyZW50LCBnYXAgPT4gZ2FwLmZyb20gPj0gbGluZS5mcm9tICYmIGdhcC50byA8PSBsaW5lLnRvICYmXHJcbiAgICAgICAgICAgICAgICBNYXRoLmFicyhnYXAuZnJvbSAtIGZyb20pIDwgaGFsZk1hcmdpbiAmJiBNYXRoLmFicyhnYXAudG8gLSB0bykgPCBoYWxmTWFyZ2luICYmXHJcbiAgICAgICAgICAgICAgICAhYXZvaWQuc29tZShwb3MgPT4gZ2FwLmZyb20gPCBwb3MgJiYgZ2FwLnRvID4gcG9zKSk7XHJcbiAgICAgICAgICAgIGlmICghZ2FwKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBXaGVuIHNjcm9sbGluZyBkb3duLCBzbmFwIGdhcCBlbmRzIHRvIGxpbmUgc3RhcnRzIHRvIGF2b2lkIHNoaWZ0cyBpbiB3cmFwcGluZ1xyXG4gICAgICAgICAgICAgICAgaWYgKHRvIDwgbGluZS50byAmJiBtYXlNZWFzdXJlICYmIHdyYXBwaW5nICYmXHJcbiAgICAgICAgICAgICAgICAgICAgbWF5TWVhc3VyZS52aXNpYmxlUmFuZ2VzLnNvbWUociA9PiByLmZyb20gPD0gdG8gJiYgci50byA+PSB0bykpIHtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgbGluZVN0YXJ0ID0gbWF5TWVhc3VyZS5tb3ZlVG9MaW5lQm91bmRhcnkoRWRpdG9yU2VsZWN0aW9uLmN1cnNvcih0byksIGZhbHNlLCB0cnVlKS5oZWFkO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChsaW5lU3RhcnQgPiBmcm9tKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0byA9IGxpbmVTdGFydDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGdhcCA9IG5ldyBMaW5lR2FwKGZyb20sIHRvLCB0aGlzLmdhcFNpemUobGluZSwgZnJvbSwgdG8sIHN0cnVjdHVyZSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGdhcHMucHVzaChnYXApO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgZm9yIChsZXQgbGluZSBvZiB0aGlzLnZpZXdwb3J0TGluZXMpIHtcclxuICAgICAgICAgICAgaWYgKGxpbmUubGVuZ3RoIDwgZG91YmxlTWFyZ2luKVxyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIGxldCBzdHJ1Y3R1cmUgPSBsaW5lU3RydWN0dXJlKGxpbmUuZnJvbSwgbGluZS50bywgdGhpcy5zdGF0ZURlY28pO1xyXG4gICAgICAgICAgICBpZiAoc3RydWN0dXJlLnRvdGFsIDwgZG91YmxlTWFyZ2luKVxyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIGxldCB0YXJnZXQgPSB0aGlzLnNjcm9sbFRhcmdldCA/IHRoaXMuc2Nyb2xsVGFyZ2V0LnJhbmdlLmhlYWQgOiBudWxsO1xyXG4gICAgICAgICAgICBsZXQgdmlld0Zyb20sIHZpZXdUbztcclxuICAgICAgICAgICAgaWYgKHdyYXBwaW5nKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgbWFyZ2luSGVpZ2h0ID0gKG1hcmdpbiAvIHRoaXMuaGVpZ2h0T3JhY2xlLmxpbmVMZW5ndGgpICogdGhpcy5oZWlnaHRPcmFjbGUubGluZUhlaWdodDtcclxuICAgICAgICAgICAgICAgIGxldCB0b3AsIGJvdDtcclxuICAgICAgICAgICAgICAgIGlmICh0YXJnZXQgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCB0YXJnZXRGcmFjID0gZmluZEZyYWN0aW9uKHN0cnVjdHVyZSwgdGFyZ2V0KTtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgc3BhY2VGcmFjID0gKCh0aGlzLnZpc2libGVCb3R0b20gLSB0aGlzLnZpc2libGVUb3ApIC8gMiArIG1hcmdpbkhlaWdodCkgLyBsaW5lLmhlaWdodDtcclxuICAgICAgICAgICAgICAgICAgICB0b3AgPSB0YXJnZXRGcmFjIC0gc3BhY2VGcmFjO1xyXG4gICAgICAgICAgICAgICAgICAgIGJvdCA9IHRhcmdldEZyYWMgKyBzcGFjZUZyYWM7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB0b3AgPSAodGhpcy52aXNpYmxlVG9wIC0gbGluZS50b3AgLSBtYXJnaW5IZWlnaHQpIC8gbGluZS5oZWlnaHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgYm90ID0gKHRoaXMudmlzaWJsZUJvdHRvbSAtIGxpbmUudG9wICsgbWFyZ2luSGVpZ2h0KSAvIGxpbmUuaGVpZ2h0O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdmlld0Zyb20gPSBmaW5kUG9zaXRpb24oc3RydWN0dXJlLCB0b3ApO1xyXG4gICAgICAgICAgICAgICAgdmlld1RvID0gZmluZFBvc2l0aW9uKHN0cnVjdHVyZSwgYm90KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGxldCB0b3RhbFdpZHRoID0gc3RydWN0dXJlLnRvdGFsICogdGhpcy5oZWlnaHRPcmFjbGUuY2hhcldpZHRoO1xyXG4gICAgICAgICAgICAgICAgbGV0IG1hcmdpbldpZHRoID0gbWFyZ2luICogdGhpcy5oZWlnaHRPcmFjbGUuY2hhcldpZHRoO1xyXG4gICAgICAgICAgICAgICAgbGV0IGxlZnQsIHJpZ2h0O1xyXG4gICAgICAgICAgICAgICAgaWYgKHRhcmdldCAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IHRhcmdldEZyYWMgPSBmaW5kRnJhY3Rpb24oc3RydWN0dXJlLCB0YXJnZXQpO1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBzcGFjZUZyYWMgPSAoKHRoaXMucGl4ZWxWaWV3cG9ydC5yaWdodCAtIHRoaXMucGl4ZWxWaWV3cG9ydC5sZWZ0KSAvIDIgKyBtYXJnaW5XaWR0aCkgLyB0b3RhbFdpZHRoO1xyXG4gICAgICAgICAgICAgICAgICAgIGxlZnQgPSB0YXJnZXRGcmFjIC0gc3BhY2VGcmFjO1xyXG4gICAgICAgICAgICAgICAgICAgIHJpZ2h0ID0gdGFyZ2V0RnJhYyArIHNwYWNlRnJhYztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGxlZnQgPSAodGhpcy5waXhlbFZpZXdwb3J0LmxlZnQgLSBtYXJnaW5XaWR0aCkgLyB0b3RhbFdpZHRoO1xyXG4gICAgICAgICAgICAgICAgICAgIHJpZ2h0ID0gKHRoaXMucGl4ZWxWaWV3cG9ydC5yaWdodCArIG1hcmdpbldpZHRoKSAvIHRvdGFsV2lkdGg7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB2aWV3RnJvbSA9IGZpbmRQb3NpdGlvbihzdHJ1Y3R1cmUsIGxlZnQpO1xyXG4gICAgICAgICAgICAgICAgdmlld1RvID0gZmluZFBvc2l0aW9uKHN0cnVjdHVyZSwgcmlnaHQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh2aWV3RnJvbSA+IGxpbmUuZnJvbSlcclxuICAgICAgICAgICAgICAgIGFkZEdhcChsaW5lLmZyb20sIHZpZXdGcm9tLCBsaW5lLCBzdHJ1Y3R1cmUpO1xyXG4gICAgICAgICAgICBpZiAodmlld1RvIDwgbGluZS50bylcclxuICAgICAgICAgICAgICAgIGFkZEdhcCh2aWV3VG8sIGxpbmUudG8sIGxpbmUsIHN0cnVjdHVyZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBnYXBzO1xyXG4gICAgfVxyXG4gICAgZ2FwU2l6ZShsaW5lLCBmcm9tLCB0bywgc3RydWN0dXJlKSB7XHJcbiAgICAgICAgbGV0IGZyYWN0aW9uID0gZmluZEZyYWN0aW9uKHN0cnVjdHVyZSwgdG8pIC0gZmluZEZyYWN0aW9uKHN0cnVjdHVyZSwgZnJvbSk7XHJcbiAgICAgICAgaWYgKHRoaXMuaGVpZ2h0T3JhY2xlLmxpbmVXcmFwcGluZykge1xyXG4gICAgICAgICAgICByZXR1cm4gbGluZS5oZWlnaHQgKiBmcmFjdGlvbjtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBzdHJ1Y3R1cmUudG90YWwgKiB0aGlzLmhlaWdodE9yYWNsZS5jaGFyV2lkdGggKiBmcmFjdGlvbjtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICB1cGRhdGVMaW5lR2FwcyhnYXBzKSB7XHJcbiAgICAgICAgaWYgKCFMaW5lR2FwLnNhbWUoZ2FwcywgdGhpcy5saW5lR2FwcykpIHtcclxuICAgICAgICAgICAgdGhpcy5saW5lR2FwcyA9IGdhcHM7XHJcbiAgICAgICAgICAgIHRoaXMubGluZUdhcERlY28gPSBEZWNvcmF0aW9uLnNldChnYXBzLm1hcChnYXAgPT4gZ2FwLmRyYXcodGhpcy5oZWlnaHRPcmFjbGUubGluZVdyYXBwaW5nKSkpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGNvbXB1dGVWaXNpYmxlUmFuZ2VzKCkge1xyXG4gICAgICAgIGxldCBkZWNvID0gdGhpcy5zdGF0ZURlY287XHJcbiAgICAgICAgaWYgKHRoaXMubGluZUdhcHMubGVuZ3RoKVxyXG4gICAgICAgICAgICBkZWNvID0gZGVjby5jb25jYXQodGhpcy5saW5lR2FwRGVjbyk7XHJcbiAgICAgICAgbGV0IHJhbmdlcyA9IFtdO1xyXG4gICAgICAgIFJhbmdlU2V0LnNwYW5zKGRlY28sIHRoaXMudmlld3BvcnQuZnJvbSwgdGhpcy52aWV3cG9ydC50bywge1xyXG4gICAgICAgICAgICBzcGFuKGZyb20sIHRvKSB7IHJhbmdlcy5wdXNoKHsgZnJvbSwgdG8gfSk7IH0sXHJcbiAgICAgICAgICAgIHBvaW50KCkgeyB9XHJcbiAgICAgICAgfSwgMjApO1xyXG4gICAgICAgIGxldCBjaGFuZ2VkID0gcmFuZ2VzLmxlbmd0aCAhPSB0aGlzLnZpc2libGVSYW5nZXMubGVuZ3RoIHx8XHJcbiAgICAgICAgICAgIHRoaXMudmlzaWJsZVJhbmdlcy5zb21lKChyLCBpKSA9PiByLmZyb20gIT0gcmFuZ2VzW2ldLmZyb20gfHwgci50byAhPSByYW5nZXNbaV0udG8pO1xyXG4gICAgICAgIHRoaXMudmlzaWJsZVJhbmdlcyA9IHJhbmdlcztcclxuICAgICAgICByZXR1cm4gY2hhbmdlZCA/IDQgLyogVXBkYXRlRmxhZy5WaWV3cG9ydCAqLyA6IDA7XHJcbiAgICB9XHJcbiAgICBsaW5lQmxvY2tBdChwb3MpIHtcclxuICAgICAgICByZXR1cm4gKHBvcyA+PSB0aGlzLnZpZXdwb3J0LmZyb20gJiYgcG9zIDw9IHRoaXMudmlld3BvcnQudG8gJiYgdGhpcy52aWV3cG9ydExpbmVzLmZpbmQoYiA9PiBiLmZyb20gPD0gcG9zICYmIGIudG8gPj0gcG9zKSkgfHxcclxuICAgICAgICAgICAgc2NhbGVCbG9jayh0aGlzLmhlaWdodE1hcC5saW5lQXQocG9zLCBRdWVyeVR5cGUuQnlQb3MsIHRoaXMuc3RhdGUuZG9jLCAwLCAwKSwgdGhpcy5zY2FsZXIpO1xyXG4gICAgfVxyXG4gICAgbGluZUJsb2NrQXRIZWlnaHQoaGVpZ2h0KSB7XHJcbiAgICAgICAgcmV0dXJuIHNjYWxlQmxvY2sodGhpcy5oZWlnaHRNYXAubGluZUF0KHRoaXMuc2NhbGVyLmZyb21ET00oaGVpZ2h0KSwgUXVlcnlUeXBlLkJ5SGVpZ2h0LCB0aGlzLnN0YXRlLmRvYywgMCwgMCksIHRoaXMuc2NhbGVyKTtcclxuICAgIH1cclxuICAgIGVsZW1lbnRBdEhlaWdodChoZWlnaHQpIHtcclxuICAgICAgICByZXR1cm4gc2NhbGVCbG9jayh0aGlzLmhlaWdodE1hcC5ibG9ja0F0KHRoaXMuc2NhbGVyLmZyb21ET00oaGVpZ2h0KSwgdGhpcy5zdGF0ZS5kb2MsIDAsIDApLCB0aGlzLnNjYWxlcik7XHJcbiAgICB9XHJcbiAgICBnZXQgZG9jSGVpZ2h0KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnNjYWxlci50b0RPTSh0aGlzLmhlaWdodE1hcC5oZWlnaHQpO1xyXG4gICAgfVxyXG4gICAgZ2V0IGNvbnRlbnRIZWlnaHQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZG9jSGVpZ2h0ICsgdGhpcy5wYWRkaW5nVG9wICsgdGhpcy5wYWRkaW5nQm90dG9tO1xyXG4gICAgfVxyXG59XHJcbmNsYXNzIFZpZXdwb3J0IHtcclxuICAgIGNvbnN0cnVjdG9yKGZyb20sIHRvKSB7XHJcbiAgICAgICAgdGhpcy5mcm9tID0gZnJvbTtcclxuICAgICAgICB0aGlzLnRvID0gdG87XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gbGluZVN0cnVjdHVyZShmcm9tLCB0bywgc3RhdGVEZWNvKSB7XHJcbiAgICBsZXQgcmFuZ2VzID0gW10sIHBvcyA9IGZyb20sIHRvdGFsID0gMDtcclxuICAgIFJhbmdlU2V0LnNwYW5zKHN0YXRlRGVjbywgZnJvbSwgdG8sIHtcclxuICAgICAgICBzcGFuKCkgeyB9LFxyXG4gICAgICAgIHBvaW50KGZyb20sIHRvKSB7XHJcbiAgICAgICAgICAgIGlmIChmcm9tID4gcG9zKSB7XHJcbiAgICAgICAgICAgICAgICByYW5nZXMucHVzaCh7IGZyb206IHBvcywgdG86IGZyb20gfSk7XHJcbiAgICAgICAgICAgICAgICB0b3RhbCArPSBmcm9tIC0gcG9zO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHBvcyA9IHRvO1xyXG4gICAgICAgIH1cclxuICAgIH0sIDIwKTsgLy8gV2UncmUgb25seSBpbnRlcmVzdGVkIGluIGNvbGxhcHNlZCByYW5nZXMgb2YgYSBzaWduaWZpY2FudCBzaXplXHJcbiAgICBpZiAocG9zIDwgdG8pIHtcclxuICAgICAgICByYW5nZXMucHVzaCh7IGZyb206IHBvcywgdG8gfSk7XHJcbiAgICAgICAgdG90YWwgKz0gdG8gLSBwb3M7XHJcbiAgICB9XHJcbiAgICByZXR1cm4geyB0b3RhbCwgcmFuZ2VzIH07XHJcbn1cclxuZnVuY3Rpb24gZmluZFBvc2l0aW9uKHsgdG90YWwsIHJhbmdlcyB9LCByYXRpbykge1xyXG4gICAgaWYgKHJhdGlvIDw9IDApXHJcbiAgICAgICAgcmV0dXJuIHJhbmdlc1swXS5mcm9tO1xyXG4gICAgaWYgKHJhdGlvID49IDEpXHJcbiAgICAgICAgcmV0dXJuIHJhbmdlc1tyYW5nZXMubGVuZ3RoIC0gMV0udG87XHJcbiAgICBsZXQgZGlzdCA9IE1hdGguZmxvb3IodG90YWwgKiByYXRpbyk7XHJcbiAgICBmb3IgKGxldCBpID0gMDs7IGkrKykge1xyXG4gICAgICAgIGxldCB7IGZyb20sIHRvIH0gPSByYW5nZXNbaV0sIHNpemUgPSB0byAtIGZyb207XHJcbiAgICAgICAgaWYgKGRpc3QgPD0gc2l6ZSlcclxuICAgICAgICAgICAgcmV0dXJuIGZyb20gKyBkaXN0O1xyXG4gICAgICAgIGRpc3QgLT0gc2l6ZTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBmaW5kRnJhY3Rpb24oc3RydWN0dXJlLCBwb3MpIHtcclxuICAgIGxldCBjb3VudGVkID0gMDtcclxuICAgIGZvciAobGV0IHsgZnJvbSwgdG8gfSBvZiBzdHJ1Y3R1cmUucmFuZ2VzKSB7XHJcbiAgICAgICAgaWYgKHBvcyA8PSB0bykge1xyXG4gICAgICAgICAgICBjb3VudGVkICs9IHBvcyAtIGZyb207XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb3VudGVkICs9IHRvIC0gZnJvbTtcclxuICAgIH1cclxuICAgIHJldHVybiBjb3VudGVkIC8gc3RydWN0dXJlLnRvdGFsO1xyXG59XHJcbmZ1bmN0aW9uIGZpbmQoYXJyYXksIGYpIHtcclxuICAgIGZvciAobGV0IHZhbCBvZiBhcnJheSlcclxuICAgICAgICBpZiAoZih2YWwpKVxyXG4gICAgICAgICAgICByZXR1cm4gdmFsO1xyXG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcclxufVxyXG4vLyBEb24ndCBzY2FsZSB3aGVuIHRoZSBkb2N1bWVudCBoZWlnaHQgaXMgd2l0aGluIHRoZSByYW5nZSBvZiB3aGF0XHJcbi8vIHRoZSBET00gY2FuIGhhbmRsZS5cclxuY29uc3QgSWRTY2FsZXIgPSB7XHJcbiAgICB0b0RPTShuKSB7IHJldHVybiBuOyB9LFxyXG4gICAgZnJvbURPTShuKSB7IHJldHVybiBuOyB9LFxyXG4gICAgc2NhbGU6IDFcclxufTtcclxuLy8gV2hlbiB0aGUgaGVpZ2h0IGlzIHRvbyBiaWcgKD4gVlAuTWF4RE9NSGVpZ2h0KSwgc2NhbGUgZG93biB0aGVcclxuLy8gcmVnaW9ucyBvdXRzaWRlIHRoZSB2aWV3cG9ydHMgc28gdGhhdCB0aGUgdG90YWwgaGVpZ2h0IGlzXHJcbi8vIFZQLk1heERPTUhlaWdodC5cclxuY2xhc3MgQmlnU2NhbGVyIHtcclxuICAgIGNvbnN0cnVjdG9yKGRvYywgaGVpZ2h0TWFwLCB2aWV3cG9ydHMpIHtcclxuICAgICAgICBsZXQgdnBIZWlnaHQgPSAwLCBiYXNlID0gMCwgZG9tQmFzZSA9IDA7XHJcbiAgICAgICAgdGhpcy52aWV3cG9ydHMgPSB2aWV3cG9ydHMubWFwKCh7IGZyb20sIHRvIH0pID0+IHtcclxuICAgICAgICAgICAgbGV0IHRvcCA9IGhlaWdodE1hcC5saW5lQXQoZnJvbSwgUXVlcnlUeXBlLkJ5UG9zLCBkb2MsIDAsIDApLnRvcDtcclxuICAgICAgICAgICAgbGV0IGJvdHRvbSA9IGhlaWdodE1hcC5saW5lQXQodG8sIFF1ZXJ5VHlwZS5CeVBvcywgZG9jLCAwLCAwKS5ib3R0b207XHJcbiAgICAgICAgICAgIHZwSGVpZ2h0ICs9IGJvdHRvbSAtIHRvcDtcclxuICAgICAgICAgICAgcmV0dXJuIHsgZnJvbSwgdG8sIHRvcCwgYm90dG9tLCBkb21Ub3A6IDAsIGRvbUJvdHRvbTogMCB9O1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMuc2NhbGUgPSAoNzAwMDAwMCAvKiBWUC5NYXhET01IZWlnaHQgKi8gLSB2cEhlaWdodCkgLyAoaGVpZ2h0TWFwLmhlaWdodCAtIHZwSGVpZ2h0KTtcclxuICAgICAgICBmb3IgKGxldCBvYmogb2YgdGhpcy52aWV3cG9ydHMpIHtcclxuICAgICAgICAgICAgb2JqLmRvbVRvcCA9IGRvbUJhc2UgKyAob2JqLnRvcCAtIGJhc2UpICogdGhpcy5zY2FsZTtcclxuICAgICAgICAgICAgZG9tQmFzZSA9IG9iai5kb21Cb3R0b20gPSBvYmouZG9tVG9wICsgKG9iai5ib3R0b20gLSBvYmoudG9wKTtcclxuICAgICAgICAgICAgYmFzZSA9IG9iai5ib3R0b207XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgdG9ET00obikge1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBiYXNlID0gMCwgZG9tQmFzZSA9IDA7OyBpKyspIHtcclxuICAgICAgICAgICAgbGV0IHZwID0gaSA8IHRoaXMudmlld3BvcnRzLmxlbmd0aCA/IHRoaXMudmlld3BvcnRzW2ldIDogbnVsbDtcclxuICAgICAgICAgICAgaWYgKCF2cCB8fCBuIDwgdnAudG9wKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGRvbUJhc2UgKyAobiAtIGJhc2UpICogdGhpcy5zY2FsZTtcclxuICAgICAgICAgICAgaWYgKG4gPD0gdnAuYm90dG9tKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHZwLmRvbVRvcCArIChuIC0gdnAudG9wKTtcclxuICAgICAgICAgICAgYmFzZSA9IHZwLmJvdHRvbTtcclxuICAgICAgICAgICAgZG9tQmFzZSA9IHZwLmRvbUJvdHRvbTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBmcm9tRE9NKG4pIHtcclxuICAgICAgICBmb3IgKGxldCBpID0gMCwgYmFzZSA9IDAsIGRvbUJhc2UgPSAwOzsgaSsrKSB7XHJcbiAgICAgICAgICAgIGxldCB2cCA9IGkgPCB0aGlzLnZpZXdwb3J0cy5sZW5ndGggPyB0aGlzLnZpZXdwb3J0c1tpXSA6IG51bGw7XHJcbiAgICAgICAgICAgIGlmICghdnAgfHwgbiA8IHZwLmRvbVRvcClcclxuICAgICAgICAgICAgICAgIHJldHVybiBiYXNlICsgKG4gLSBkb21CYXNlKSAvIHRoaXMuc2NhbGU7XHJcbiAgICAgICAgICAgIGlmIChuIDw9IHZwLmRvbUJvdHRvbSlcclxuICAgICAgICAgICAgICAgIHJldHVybiB2cC50b3AgKyAobiAtIHZwLmRvbVRvcCk7XHJcbiAgICAgICAgICAgIGJhc2UgPSB2cC5ib3R0b207XHJcbiAgICAgICAgICAgIGRvbUJhc2UgPSB2cC5kb21Cb3R0b207XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIHNjYWxlQmxvY2soYmxvY2ssIHNjYWxlcikge1xyXG4gICAgaWYgKHNjYWxlci5zY2FsZSA9PSAxKVxyXG4gICAgICAgIHJldHVybiBibG9jaztcclxuICAgIGxldCBiVG9wID0gc2NhbGVyLnRvRE9NKGJsb2NrLnRvcCksIGJCb3R0b20gPSBzY2FsZXIudG9ET00oYmxvY2suYm90dG9tKTtcclxuICAgIHJldHVybiBuZXcgQmxvY2tJbmZvKGJsb2NrLmZyb20sIGJsb2NrLmxlbmd0aCwgYlRvcCwgYkJvdHRvbSAtIGJUb3AsIEFycmF5LmlzQXJyYXkoYmxvY2sudHlwZSkgPyBibG9jay50eXBlLm1hcChiID0+IHNjYWxlQmxvY2soYiwgc2NhbGVyKSkgOiBibG9jay50eXBlKTtcclxufVxyXG5cclxuY29uc3QgdGhlbWUgPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKHsgY29tYmluZTogc3RycyA9PiBzdHJzLmpvaW4oXCIgXCIpIH0pO1xyXG5jb25zdCBkYXJrVGhlbWUgPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKHsgY29tYmluZTogdmFsdWVzID0+IHZhbHVlcy5pbmRleE9mKHRydWUpID4gLTEgfSk7XHJcbmNvbnN0IGJhc2VUaGVtZUlEID0gLypAX19QVVJFX18qL1N0eWxlTW9kdWxlLm5ld05hbWUoKSwgYmFzZUxpZ2h0SUQgPSAvKkBfX1BVUkVfXyovU3R5bGVNb2R1bGUubmV3TmFtZSgpLCBiYXNlRGFya0lEID0gLypAX19QVVJFX18qL1N0eWxlTW9kdWxlLm5ld05hbWUoKTtcclxuY29uc3QgbGlnaHREYXJrSURzID0geyBcIiZsaWdodFwiOiBcIi5cIiArIGJhc2VMaWdodElELCBcIiZkYXJrXCI6IFwiLlwiICsgYmFzZURhcmtJRCB9O1xyXG5mdW5jdGlvbiBidWlsZFRoZW1lKG1haW4sIHNwZWMsIHNjb3Blcykge1xyXG4gICAgcmV0dXJuIG5ldyBTdHlsZU1vZHVsZShzcGVjLCB7XHJcbiAgICAgICAgZmluaXNoKHNlbCkge1xyXG4gICAgICAgICAgICByZXR1cm4gLyYvLnRlc3Qoc2VsKSA/IHNlbC5yZXBsYWNlKC8mXFx3Ki8sIG0gPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKG0gPT0gXCImXCIpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1haW47XHJcbiAgICAgICAgICAgICAgICBpZiAoIXNjb3BlcyB8fCAhc2NvcGVzW21dKVxyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGBVbnN1cHBvcnRlZCBzZWxlY3RvcjogJHttfWApO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNjb3Blc1ttXTtcclxuICAgICAgICAgICAgfSkgOiBtYWluICsgXCIgXCIgKyBzZWw7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbn1cclxuY29uc3QgYmFzZVRoZW1lJDEgPSAvKkBfX1BVUkVfXyovYnVpbGRUaGVtZShcIi5cIiArIGJhc2VUaGVtZUlELCB7XHJcbiAgICBcIiZcIjoge1xyXG4gICAgICAgIHBvc2l0aW9uOiBcInJlbGF0aXZlICFpbXBvcnRhbnRcIixcclxuICAgICAgICBib3hTaXppbmc6IFwiYm9yZGVyLWJveFwiLFxyXG4gICAgICAgIFwiJi5jbS1mb2N1c2VkXCI6IHtcclxuICAgICAgICAgICAgLy8gUHJvdmlkZSBhIHNpbXBsZSBkZWZhdWx0IG91dGxpbmUgdG8gbWFrZSBzdXJlIGEgZm9jdXNlZFxyXG4gICAgICAgICAgICAvLyBlZGl0b3IgaXMgdmlzdWFsbHkgZGlzdGluY3QuIENhbid0IGxlYXZlIHRoZSBkZWZhdWx0IGJlaGF2aW9yXHJcbiAgICAgICAgICAgIC8vIGJlY2F1c2UgdGhhdCB3aWxsIGFwcGx5IHRvIHRoZSBjb250ZW50IGVsZW1lbnQsIHdoaWNoIGlzXHJcbiAgICAgICAgICAgIC8vIGluc2lkZSB0aGUgc2Nyb2xsYWJsZSBjb250YWluZXIgYW5kIGRvZXNuJ3QgaW5jbHVkZSB0aGVcclxuICAgICAgICAgICAgLy8gZ3V0dGVycy4gV2UgYWxzbyBjYW4ndCB1c2UgYW4gJ2F1dG8nIG91dGxpbmUsIHNpbmNlIHRob3NlXHJcbiAgICAgICAgICAgIC8vIGFyZSwgZm9yIHNvbWUgcmVhc29uLCBkcmF3biBiZWhpbmQgdGhlIGVsZW1lbnQgY29udGVudCwgd2hpY2hcclxuICAgICAgICAgICAgLy8gd2lsbCBjYXVzZSB0aGluZ3MgbGlrZSB0aGUgYWN0aXZlIGxpbmUgYmFja2dyb3VuZCB0byBjb3ZlclxyXG4gICAgICAgICAgICAvLyB0aGUgb3V0bGluZSAoIzI5NykuXHJcbiAgICAgICAgICAgIG91dGxpbmU6IFwiMXB4IGRvdHRlZCAjMjEyMTIxXCJcclxuICAgICAgICB9LFxyXG4gICAgICAgIGRpc3BsYXk6IFwiZmxleCAhaW1wb3J0YW50XCIsXHJcbiAgICAgICAgZmxleERpcmVjdGlvbjogXCJjb2x1bW5cIlxyXG4gICAgfSxcclxuICAgIFwiLmNtLXNjcm9sbGVyXCI6IHtcclxuICAgICAgICBkaXNwbGF5OiBcImZsZXggIWltcG9ydGFudFwiLFxyXG4gICAgICAgIGFsaWduSXRlbXM6IFwiZmxleC1zdGFydCAhaW1wb3J0YW50XCIsXHJcbiAgICAgICAgZm9udEZhbWlseTogXCJtb25vc3BhY2VcIixcclxuICAgICAgICBsaW5lSGVpZ2h0OiAxLjQsXHJcbiAgICAgICAgaGVpZ2h0OiBcIjEwMCVcIixcclxuICAgICAgICBvdmVyZmxvd1g6IFwiYXV0b1wiLFxyXG4gICAgICAgIHBvc2l0aW9uOiBcInJlbGF0aXZlXCIsXHJcbiAgICAgICAgekluZGV4OiAwXHJcbiAgICB9LFxyXG4gICAgXCIuY20tY29udGVudFwiOiB7XHJcbiAgICAgICAgbWFyZ2luOiAwLFxyXG4gICAgICAgIGZsZXhHcm93OiAyLFxyXG4gICAgICAgIGZsZXhTaHJpbms6IDAsXHJcbiAgICAgICAgZGlzcGxheTogXCJibG9ja1wiLFxyXG4gICAgICAgIHdoaXRlU3BhY2U6IFwicHJlXCIsXHJcbiAgICAgICAgd29yZFdyYXA6IFwibm9ybWFsXCIsXHJcbiAgICAgICAgYm94U2l6aW5nOiBcImJvcmRlci1ib3hcIixcclxuICAgICAgICBwYWRkaW5nOiBcIjRweCAwXCIsXHJcbiAgICAgICAgb3V0bGluZTogXCJub25lXCIsXHJcbiAgICAgICAgXCImW2NvbnRlbnRlZGl0YWJsZT10cnVlXVwiOiB7XHJcbiAgICAgICAgICAgIFdlYmtpdFVzZXJNb2RpZnk6IFwicmVhZC13cml0ZS1wbGFpbnRleHQtb25seVwiLFxyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICBcIi5jbS1saW5lV3JhcHBpbmdcIjoge1xyXG4gICAgICAgIHdoaXRlU3BhY2VfZmFsbGJhY2s6IFwicHJlLXdyYXBcIixcclxuICAgICAgICB3aGl0ZVNwYWNlOiBcImJyZWFrLXNwYWNlc1wiLFxyXG4gICAgICAgIHdvcmRCcmVhazogXCJicmVhay13b3JkXCIsXHJcbiAgICAgICAgb3ZlcmZsb3dXcmFwOiBcImFueXdoZXJlXCIsXHJcbiAgICAgICAgZmxleFNocmluazogMVxyXG4gICAgfSxcclxuICAgIFwiJmxpZ2h0IC5jbS1jb250ZW50XCI6IHsgY2FyZXRDb2xvcjogXCJibGFja1wiIH0sXHJcbiAgICBcIiZkYXJrIC5jbS1jb250ZW50XCI6IHsgY2FyZXRDb2xvcjogXCJ3aGl0ZVwiIH0sXHJcbiAgICBcIi5jbS1saW5lXCI6IHtcclxuICAgICAgICBkaXNwbGF5OiBcImJsb2NrXCIsXHJcbiAgICAgICAgcGFkZGluZzogXCIwIDJweCAwIDZweFwiXHJcbiAgICB9LFxyXG4gICAgXCIuY20tbGF5ZXJcIjoge1xyXG4gICAgICAgIGNvbnRhaW46IFwic2l6ZSBzdHlsZVwiLFxyXG4gICAgICAgIFwiJiA+ICpcIjoge1xyXG4gICAgICAgICAgICBwb3NpdGlvbjogXCJhYnNvbHV0ZVwiXHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIFwiJmxpZ2h0IC5jbS1zZWxlY3Rpb25CYWNrZ3JvdW5kXCI6IHtcclxuICAgICAgICBiYWNrZ3JvdW5kOiBcIiNkOWQ5ZDlcIlxyXG4gICAgfSxcclxuICAgIFwiJmRhcmsgLmNtLXNlbGVjdGlvbkJhY2tncm91bmRcIjoge1xyXG4gICAgICAgIGJhY2tncm91bmQ6IFwiIzIyMlwiXHJcbiAgICB9LFxyXG4gICAgXCImbGlnaHQuY20tZm9jdXNlZCAuY20tc2VsZWN0aW9uQmFja2dyb3VuZFwiOiB7XHJcbiAgICAgICAgYmFja2dyb3VuZDogXCIjZDdkNGYwXCJcclxuICAgIH0sXHJcbiAgICBcIiZkYXJrLmNtLWZvY3VzZWQgLmNtLXNlbGVjdGlvbkJhY2tncm91bmRcIjoge1xyXG4gICAgICAgIGJhY2tncm91bmQ6IFwiIzIzM1wiXHJcbiAgICB9LFxyXG4gICAgXCIuY20tY3Vyc29yTGF5ZXJcIjoge1xyXG4gICAgICAgIHBvaW50ZXJFdmVudHM6IFwibm9uZVwiXHJcbiAgICB9LFxyXG4gICAgXCImLmNtLWZvY3VzZWQgLmNtLWN1cnNvckxheWVyXCI6IHtcclxuICAgICAgICBhbmltYXRpb246IFwic3RlcHMoMSkgY20tYmxpbmsgMS4ycyBpbmZpbml0ZVwiXHJcbiAgICB9LFxyXG4gICAgLy8gVHdvIGFuaW1hdGlvbnMgZGVmaW5lZCBzbyB0aGF0IHdlIGNhbiBzd2l0Y2ggYmV0d2VlbiB0aGVtIHRvXHJcbiAgICAvLyByZXN0YXJ0IHRoZSBhbmltYXRpb24gd2l0aG91dCBmb3JjaW5nIGFub3RoZXIgc3R5bGVcclxuICAgIC8vIHJlY29tcHV0YXRpb24uXHJcbiAgICBcIkBrZXlmcmFtZXMgY20tYmxpbmtcIjogeyBcIjAlXCI6IHt9LCBcIjUwJVwiOiB7IG9wYWNpdHk6IDAgfSwgXCIxMDAlXCI6IHt9IH0sXHJcbiAgICBcIkBrZXlmcmFtZXMgY20tYmxpbmsyXCI6IHsgXCIwJVwiOiB7fSwgXCI1MCVcIjogeyBvcGFjaXR5OiAwIH0sIFwiMTAwJVwiOiB7fSB9LFxyXG4gICAgXCIuY20tY3Vyc29yLCAuY20tZHJvcEN1cnNvclwiOiB7XHJcbiAgICAgICAgYm9yZGVyTGVmdDogXCIxLjJweCBzb2xpZCBibGFja1wiLFxyXG4gICAgICAgIG1hcmdpbkxlZnQ6IFwiLTAuNnB4XCIsXHJcbiAgICAgICAgcG9pbnRlckV2ZW50czogXCJub25lXCIsXHJcbiAgICB9LFxyXG4gICAgXCIuY20tY3Vyc29yXCI6IHtcclxuICAgICAgICBkaXNwbGF5OiBcIm5vbmVcIlxyXG4gICAgfSxcclxuICAgIFwiJmRhcmsgLmNtLWN1cnNvclwiOiB7XHJcbiAgICAgICAgYm9yZGVyTGVmdENvbG9yOiBcIiM0NDRcIlxyXG4gICAgfSxcclxuICAgIFwiJi5jbS1mb2N1c2VkIC5jbS1jdXJzb3JcIjoge1xyXG4gICAgICAgIGRpc3BsYXk6IFwiYmxvY2tcIlxyXG4gICAgfSxcclxuICAgIFwiJmxpZ2h0IC5jbS1hY3RpdmVMaW5lXCI6IHsgYmFja2dyb3VuZENvbG9yOiBcIiNjY2VlZmY0NFwiIH0sXHJcbiAgICBcIiZkYXJrIC5jbS1hY3RpdmVMaW5lXCI6IHsgYmFja2dyb3VuZENvbG9yOiBcIiM5OWVlZmYzM1wiIH0sXHJcbiAgICBcIiZsaWdodCAuY20tc3BlY2lhbENoYXJcIjogeyBjb2xvcjogXCJyZWRcIiB9LFxyXG4gICAgXCImZGFyayAuY20tc3BlY2lhbENoYXJcIjogeyBjb2xvcjogXCIjZjc4XCIgfSxcclxuICAgIFwiLmNtLWd1dHRlcnNcIjoge1xyXG4gICAgICAgIGZsZXhTaHJpbms6IDAsXHJcbiAgICAgICAgZGlzcGxheTogXCJmbGV4XCIsXHJcbiAgICAgICAgaGVpZ2h0OiBcIjEwMCVcIixcclxuICAgICAgICBib3hTaXppbmc6IFwiYm9yZGVyLWJveFwiLFxyXG4gICAgICAgIGxlZnQ6IDAsXHJcbiAgICAgICAgekluZGV4OiAyMDBcclxuICAgIH0sXHJcbiAgICBcIiZsaWdodCAuY20tZ3V0dGVyc1wiOiB7XHJcbiAgICAgICAgYmFja2dyb3VuZENvbG9yOiBcIiNmNWY1ZjVcIixcclxuICAgICAgICBjb2xvcjogXCIjNmM2YzZjXCIsXHJcbiAgICAgICAgYm9yZGVyUmlnaHQ6IFwiMXB4IHNvbGlkICNkZGRcIlxyXG4gICAgfSxcclxuICAgIFwiJmRhcmsgLmNtLWd1dHRlcnNcIjoge1xyXG4gICAgICAgIGJhY2tncm91bmRDb2xvcjogXCIjMzMzMzM4XCIsXHJcbiAgICAgICAgY29sb3I6IFwiI2NjY1wiXHJcbiAgICB9LFxyXG4gICAgXCIuY20tZ3V0dGVyXCI6IHtcclxuICAgICAgICBkaXNwbGF5OiBcImZsZXggIWltcG9ydGFudFwiLFxyXG4gICAgICAgIGZsZXhEaXJlY3Rpb246IFwiY29sdW1uXCIsXHJcbiAgICAgICAgZmxleFNocmluazogMCxcclxuICAgICAgICBib3hTaXppbmc6IFwiYm9yZGVyLWJveFwiLFxyXG4gICAgICAgIG1pbkhlaWdodDogXCIxMDAlXCIsXHJcbiAgICAgICAgb3ZlcmZsb3c6IFwiaGlkZGVuXCJcclxuICAgIH0sXHJcbiAgICBcIi5jbS1ndXR0ZXJFbGVtZW50XCI6IHtcclxuICAgICAgICBib3hTaXppbmc6IFwiYm9yZGVyLWJveFwiXHJcbiAgICB9LFxyXG4gICAgXCIuY20tbGluZU51bWJlcnMgLmNtLWd1dHRlckVsZW1lbnRcIjoge1xyXG4gICAgICAgIHBhZGRpbmc6IFwiMCAzcHggMCA1cHhcIixcclxuICAgICAgICBtaW5XaWR0aDogXCIyMHB4XCIsXHJcbiAgICAgICAgdGV4dEFsaWduOiBcInJpZ2h0XCIsXHJcbiAgICAgICAgd2hpdGVTcGFjZTogXCJub3dyYXBcIlxyXG4gICAgfSxcclxuICAgIFwiJmxpZ2h0IC5jbS1hY3RpdmVMaW5lR3V0dGVyXCI6IHtcclxuICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IFwiI2UyZjJmZlwiXHJcbiAgICB9LFxyXG4gICAgXCImZGFyayAuY20tYWN0aXZlTGluZUd1dHRlclwiOiB7XHJcbiAgICAgICAgYmFja2dyb3VuZENvbG9yOiBcIiMyMjIyMjdcIlxyXG4gICAgfSxcclxuICAgIFwiLmNtLXBhbmVsc1wiOiB7XHJcbiAgICAgICAgYm94U2l6aW5nOiBcImJvcmRlci1ib3hcIixcclxuICAgICAgICBwb3NpdGlvbjogXCJzdGlja3lcIixcclxuICAgICAgICBsZWZ0OiAwLFxyXG4gICAgICAgIHJpZ2h0OiAwXHJcbiAgICB9LFxyXG4gICAgXCImbGlnaHQgLmNtLXBhbmVsc1wiOiB7XHJcbiAgICAgICAgYmFja2dyb3VuZENvbG9yOiBcIiNmNWY1ZjVcIixcclxuICAgICAgICBjb2xvcjogXCJibGFja1wiXHJcbiAgICB9LFxyXG4gICAgXCImbGlnaHQgLmNtLXBhbmVscy10b3BcIjoge1xyXG4gICAgICAgIGJvcmRlckJvdHRvbTogXCIxcHggc29saWQgI2RkZFwiXHJcbiAgICB9LFxyXG4gICAgXCImbGlnaHQgLmNtLXBhbmVscy1ib3R0b21cIjoge1xyXG4gICAgICAgIGJvcmRlclRvcDogXCIxcHggc29saWQgI2RkZFwiXHJcbiAgICB9LFxyXG4gICAgXCImZGFyayAuY20tcGFuZWxzXCI6IHtcclxuICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IFwiIzMzMzMzOFwiLFxyXG4gICAgICAgIGNvbG9yOiBcIndoaXRlXCJcclxuICAgIH0sXHJcbiAgICBcIi5jbS10YWJcIjoge1xyXG4gICAgICAgIGRpc3BsYXk6IFwiaW5saW5lLWJsb2NrXCIsXHJcbiAgICAgICAgb3ZlcmZsb3c6IFwiaGlkZGVuXCIsXHJcbiAgICAgICAgdmVydGljYWxBbGlnbjogXCJib3R0b21cIlxyXG4gICAgfSxcclxuICAgIFwiLmNtLXdpZGdldEJ1ZmZlclwiOiB7XHJcbiAgICAgICAgdmVydGljYWxBbGlnbjogXCJ0ZXh0LXRvcFwiLFxyXG4gICAgICAgIGhlaWdodDogXCIxZW1cIixcclxuICAgICAgICB3aWR0aDogMCxcclxuICAgICAgICBkaXNwbGF5OiBcImlubGluZVwiXHJcbiAgICB9LFxyXG4gICAgXCIuY20tcGxhY2Vob2xkZXJcIjoge1xyXG4gICAgICAgIGNvbG9yOiBcIiM4ODhcIixcclxuICAgICAgICBkaXNwbGF5OiBcImlubGluZS1ibG9ja1wiLFxyXG4gICAgICAgIHZlcnRpY2FsQWxpZ246IFwidG9wXCIsXHJcbiAgICB9LFxyXG4gICAgXCIuY20taGlnaGxpZ2h0U3BhY2U6YmVmb3JlXCI6IHtcclxuICAgICAgICBjb250ZW50OiBcImF0dHIoZGF0YS1kaXNwbGF5KVwiLFxyXG4gICAgICAgIHBvc2l0aW9uOiBcImFic29sdXRlXCIsXHJcbiAgICAgICAgcG9pbnRlckV2ZW50czogXCJub25lXCIsXHJcbiAgICAgICAgY29sb3I6IFwiIzg4OFwiXHJcbiAgICB9LFxyXG4gICAgXCIuY20taGlnaGxpZ2h0VGFiXCI6IHtcclxuICAgICAgICBiYWNrZ3JvdW5kSW1hZ2U6IGB1cmwoJ2RhdGE6aW1hZ2Uvc3ZnK3htbCw8c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiB3aWR0aD1cIjIwMFwiIGhlaWdodD1cIjIwXCI+PHBhdGggc3Ryb2tlPVwiJTIzODg4XCIgc3Ryb2tlLXdpZHRoPVwiMVwiIGZpbGw9XCJub25lXCIgZD1cIk0xIDEwSDE5NkwxOTAgNU0xOTAgMTVMMTk2IDEwTTE5NyA0TDE5NyAxNlwiLz48L3N2Zz4nKWAsXHJcbiAgICAgICAgYmFja2dyb3VuZFNpemU6IFwiYXV0byAxMDAlXCIsXHJcbiAgICAgICAgYmFja2dyb3VuZFBvc2l0aW9uOiBcInJpZ2h0IDkwJVwiLFxyXG4gICAgICAgIGJhY2tncm91bmRSZXBlYXQ6IFwibm8tcmVwZWF0XCJcclxuICAgIH0sXHJcbiAgICBcIi5jbS10cmFpbGluZ1NwYWNlXCI6IHtcclxuICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IFwiI2ZmMzMyMjU1XCJcclxuICAgIH0sXHJcbiAgICBcIi5jbS1idXR0b25cIjoge1xyXG4gICAgICAgIHZlcnRpY2FsQWxpZ246IFwibWlkZGxlXCIsXHJcbiAgICAgICAgY29sb3I6IFwiaW5oZXJpdFwiLFxyXG4gICAgICAgIGZvbnRTaXplOiBcIjcwJVwiLFxyXG4gICAgICAgIHBhZGRpbmc6IFwiLjJlbSAxZW1cIixcclxuICAgICAgICBib3JkZXJSYWRpdXM6IFwiMXB4XCJcclxuICAgIH0sXHJcbiAgICBcIiZsaWdodCAuY20tYnV0dG9uXCI6IHtcclxuICAgICAgICBiYWNrZ3JvdW5kSW1hZ2U6IFwibGluZWFyLWdyYWRpZW50KCNlZmYxZjUsICNkOWQ5ZGYpXCIsXHJcbiAgICAgICAgYm9yZGVyOiBcIjFweCBzb2xpZCAjODg4XCIsXHJcbiAgICAgICAgXCImOmFjdGl2ZVwiOiB7XHJcbiAgICAgICAgICAgIGJhY2tncm91bmRJbWFnZTogXCJsaW5lYXItZ3JhZGllbnQoI2I0YjRiNCwgI2QwZDNkNilcIlxyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICBcIiZkYXJrIC5jbS1idXR0b25cIjoge1xyXG4gICAgICAgIGJhY2tncm91bmRJbWFnZTogXCJsaW5lYXItZ3JhZGllbnQoIzM5MzkzOSwgIzExMSlcIixcclxuICAgICAgICBib3JkZXI6IFwiMXB4IHNvbGlkICM4ODhcIixcclxuICAgICAgICBcIiY6YWN0aXZlXCI6IHtcclxuICAgICAgICAgICAgYmFja2dyb3VuZEltYWdlOiBcImxpbmVhci1ncmFkaWVudCgjMTExLCAjMzMzKVwiXHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIFwiLmNtLXRleHRmaWVsZFwiOiB7XHJcbiAgICAgICAgdmVydGljYWxBbGlnbjogXCJtaWRkbGVcIixcclxuICAgICAgICBjb2xvcjogXCJpbmhlcml0XCIsXHJcbiAgICAgICAgZm9udFNpemU6IFwiNzAlXCIsXHJcbiAgICAgICAgYm9yZGVyOiBcIjFweCBzb2xpZCBzaWx2ZXJcIixcclxuICAgICAgICBwYWRkaW5nOiBcIi4yZW0gLjVlbVwiXHJcbiAgICB9LFxyXG4gICAgXCImbGlnaHQgLmNtLXRleHRmaWVsZFwiOiB7XHJcbiAgICAgICAgYmFja2dyb3VuZENvbG9yOiBcIndoaXRlXCJcclxuICAgIH0sXHJcbiAgICBcIiZkYXJrIC5jbS10ZXh0ZmllbGRcIjoge1xyXG4gICAgICAgIGJvcmRlcjogXCIxcHggc29saWQgIzU1NVwiLFxyXG4gICAgICAgIGJhY2tncm91bmRDb2xvcjogXCJpbmhlcml0XCJcclxuICAgIH1cclxufSwgbGlnaHREYXJrSURzKTtcclxuXHJcbmNsYXNzIERPTUNoYW5nZSB7XHJcbiAgICBjb25zdHJ1Y3Rvcih2aWV3LCBzdGFydCwgZW5kLCB0eXBlT3Zlcikge1xyXG4gICAgICAgIHRoaXMudHlwZU92ZXIgPSB0eXBlT3ZlcjtcclxuICAgICAgICB0aGlzLmJvdW5kcyA9IG51bGw7XHJcbiAgICAgICAgdGhpcy50ZXh0ID0gXCJcIjtcclxuICAgICAgICBsZXQgeyBpbXByZWNpc2VIZWFkOiBpSGVhZCwgaW1wcmVjaXNlQW5jaG9yOiBpQW5jaG9yIH0gPSB2aWV3LmRvY1ZpZXc7XHJcbiAgICAgICAgaWYgKHZpZXcuc3RhdGUucmVhZE9ubHkgJiYgc3RhcnQgPiAtMSkge1xyXG4gICAgICAgICAgICAvLyBJZ25vcmUgY2hhbmdlcyB3aGVuIHRoZSBlZGl0b3IgaXMgcmVhZC1vbmx5XHJcbiAgICAgICAgICAgIHRoaXMubmV3U2VsID0gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoc3RhcnQgPiAtMSAmJiAodGhpcy5ib3VuZHMgPSB2aWV3LmRvY1ZpZXcuZG9tQm91bmRzQXJvdW5kKHN0YXJ0LCBlbmQsIDApKSkge1xyXG4gICAgICAgICAgICBsZXQgc2VsUG9pbnRzID0gaUhlYWQgfHwgaUFuY2hvciA/IFtdIDogc2VsZWN0aW9uUG9pbnRzKHZpZXcpO1xyXG4gICAgICAgICAgICBsZXQgcmVhZGVyID0gbmV3IERPTVJlYWRlcihzZWxQb2ludHMsIHZpZXcuc3RhdGUpO1xyXG4gICAgICAgICAgICByZWFkZXIucmVhZFJhbmdlKHRoaXMuYm91bmRzLnN0YXJ0RE9NLCB0aGlzLmJvdW5kcy5lbmRET00pO1xyXG4gICAgICAgICAgICB0aGlzLnRleHQgPSByZWFkZXIudGV4dDtcclxuICAgICAgICAgICAgdGhpcy5uZXdTZWwgPSBzZWxlY3Rpb25Gcm9tUG9pbnRzKHNlbFBvaW50cywgdGhpcy5ib3VuZHMuZnJvbSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBsZXQgZG9tU2VsID0gdmlldy5vYnNlcnZlci5zZWxlY3Rpb25SYW5nZTtcclxuICAgICAgICAgICAgbGV0IGhlYWQgPSBpSGVhZCAmJiBpSGVhZC5ub2RlID09IGRvbVNlbC5mb2N1c05vZGUgJiYgaUhlYWQub2Zmc2V0ID09IGRvbVNlbC5mb2N1c09mZnNldCB8fFxyXG4gICAgICAgICAgICAgICAgIWNvbnRhaW5zKHZpZXcuY29udGVudERPTSwgZG9tU2VsLmZvY3VzTm9kZSlcclxuICAgICAgICAgICAgICAgID8gdmlldy5zdGF0ZS5zZWxlY3Rpb24ubWFpbi5oZWFkXHJcbiAgICAgICAgICAgICAgICA6IHZpZXcuZG9jVmlldy5wb3NGcm9tRE9NKGRvbVNlbC5mb2N1c05vZGUsIGRvbVNlbC5mb2N1c09mZnNldCk7XHJcbiAgICAgICAgICAgIGxldCBhbmNob3IgPSBpQW5jaG9yICYmIGlBbmNob3Iubm9kZSA9PSBkb21TZWwuYW5jaG9yTm9kZSAmJiBpQW5jaG9yLm9mZnNldCA9PSBkb21TZWwuYW5jaG9yT2Zmc2V0IHx8XHJcbiAgICAgICAgICAgICAgICAhY29udGFpbnModmlldy5jb250ZW50RE9NLCBkb21TZWwuYW5jaG9yTm9kZSlcclxuICAgICAgICAgICAgICAgID8gdmlldy5zdGF0ZS5zZWxlY3Rpb24ubWFpbi5hbmNob3JcclxuICAgICAgICAgICAgICAgIDogdmlldy5kb2NWaWV3LnBvc0Zyb21ET00oZG9tU2VsLmFuY2hvck5vZGUsIGRvbVNlbC5hbmNob3JPZmZzZXQpO1xyXG4gICAgICAgICAgICB0aGlzLm5ld1NlbCA9IEVkaXRvclNlbGVjdGlvbi5zaW5nbGUoYW5jaG9yLCBoZWFkKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gYXBwbHlET01DaGFuZ2UodmlldywgZG9tQ2hhbmdlKSB7XHJcbiAgICBsZXQgY2hhbmdlO1xyXG4gICAgbGV0IHsgbmV3U2VsIH0gPSBkb21DaGFuZ2UsIHNlbCA9IHZpZXcuc3RhdGUuc2VsZWN0aW9uLm1haW47XHJcbiAgICBpZiAoZG9tQ2hhbmdlLmJvdW5kcykge1xyXG4gICAgICAgIGxldCB7IGZyb20sIHRvIH0gPSBkb21DaGFuZ2UuYm91bmRzO1xyXG4gICAgICAgIGxldCBwcmVmZXJyZWRQb3MgPSBzZWwuZnJvbSwgcHJlZmVycmVkU2lkZSA9IG51bGw7XHJcbiAgICAgICAgLy8gUHJlZmVyIGFuY2hvcmluZyB0byBlbmQgd2hlbiBCYWNrc3BhY2UgaXMgcHJlc3NlZCAob3IsIG9uXHJcbiAgICAgICAgLy8gQW5kcm9pZCwgd2hlbiBzb21ldGhpbmcgd2FzIGRlbGV0ZWQpXHJcbiAgICAgICAgaWYgKHZpZXcuaW5wdXRTdGF0ZS5sYXN0S2V5Q29kZSA9PT0gOCAmJiB2aWV3LmlucHV0U3RhdGUubGFzdEtleVRpbWUgPiBEYXRlLm5vdygpIC0gMTAwIHx8XHJcbiAgICAgICAgICAgIGJyb3dzZXIuYW5kcm9pZCAmJiBkb21DaGFuZ2UudGV4dC5sZW5ndGggPCB0byAtIGZyb20pIHtcclxuICAgICAgICAgICAgcHJlZmVycmVkUG9zID0gc2VsLnRvO1xyXG4gICAgICAgICAgICBwcmVmZXJyZWRTaWRlID0gXCJlbmRcIjtcclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IGRpZmYgPSBmaW5kRGlmZih2aWV3LnN0YXRlLmRvYy5zbGljZVN0cmluZyhmcm9tLCB0bywgTGluZUJyZWFrUGxhY2Vob2xkZXIpLCBkb21DaGFuZ2UudGV4dCwgcHJlZmVycmVkUG9zIC0gZnJvbSwgcHJlZmVycmVkU2lkZSk7XHJcbiAgICAgICAgaWYgKGRpZmYpIHtcclxuICAgICAgICAgICAgLy8gQ2hyb21lIGluc2VydHMgdHdvIG5ld2xpbmVzIHdoZW4gcHJlc3Npbmcgc2hpZnQtZW50ZXIgYXQgdGhlXHJcbiAgICAgICAgICAgIC8vIGVuZCBvZiBhIGxpbmUuIERvbUNoYW5nZSBkcm9wcyBvbmUgb2YgdGhvc2UuXHJcbiAgICAgICAgICAgIGlmIChicm93c2VyLmNocm9tZSAmJiB2aWV3LmlucHV0U3RhdGUubGFzdEtleUNvZGUgPT0gMTMgJiZcclxuICAgICAgICAgICAgICAgIGRpZmYudG9CID09IGRpZmYuZnJvbSArIDIgJiYgZG9tQ2hhbmdlLnRleHQuc2xpY2UoZGlmZi5mcm9tLCBkaWZmLnRvQikgPT0gTGluZUJyZWFrUGxhY2Vob2xkZXIgKyBMaW5lQnJlYWtQbGFjZWhvbGRlcilcclxuICAgICAgICAgICAgICAgIGRpZmYudG9CLS07XHJcbiAgICAgICAgICAgIGNoYW5nZSA9IHsgZnJvbTogZnJvbSArIGRpZmYuZnJvbSwgdG86IGZyb20gKyBkaWZmLnRvQSxcclxuICAgICAgICAgICAgICAgIGluc2VydDogVGV4dC5vZihkb21DaGFuZ2UudGV4dC5zbGljZShkaWZmLmZyb20sIGRpZmYudG9CKS5zcGxpdChMaW5lQnJlYWtQbGFjZWhvbGRlcikpIH07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAobmV3U2VsICYmICghdmlldy5oYXNGb2N1cyAmJiB2aWV3LnN0YXRlLmZhY2V0KGVkaXRhYmxlKSB8fCBuZXdTZWwubWFpbi5lcShzZWwpKSkge1xyXG4gICAgICAgIG5ld1NlbCA9IG51bGw7XHJcbiAgICB9XHJcbiAgICBpZiAoIWNoYW5nZSAmJiAhbmV3U2VsKVxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIGlmICghY2hhbmdlICYmIGRvbUNoYW5nZS50eXBlT3ZlciAmJiAhc2VsLmVtcHR5ICYmIG5ld1NlbCAmJiBuZXdTZWwubWFpbi5lbXB0eSkge1xyXG4gICAgICAgIC8vIEhldXJpc3RpYyB0byBub3RpY2UgdHlwaW5nIG92ZXIgYSBzZWxlY3RlZCBjaGFyYWN0ZXJcclxuICAgICAgICBjaGFuZ2UgPSB7IGZyb206IHNlbC5mcm9tLCB0bzogc2VsLnRvLCBpbnNlcnQ6IHZpZXcuc3RhdGUuZG9jLnNsaWNlKHNlbC5mcm9tLCBzZWwudG8pIH07XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChjaGFuZ2UgJiYgY2hhbmdlLmZyb20gPj0gc2VsLmZyb20gJiYgY2hhbmdlLnRvIDw9IHNlbC50byAmJlxyXG4gICAgICAgIChjaGFuZ2UuZnJvbSAhPSBzZWwuZnJvbSB8fCBjaGFuZ2UudG8gIT0gc2VsLnRvKSAmJlxyXG4gICAgICAgIChzZWwudG8gLSBzZWwuZnJvbSkgLSAoY2hhbmdlLnRvIC0gY2hhbmdlLmZyb20pIDw9IDQpIHtcclxuICAgICAgICAvLyBJZiB0aGUgY2hhbmdlIGlzIGluc2lkZSB0aGUgc2VsZWN0aW9uIGFuZCBjb3ZlcnMgbW9zdCBvZiBpdCxcclxuICAgICAgICAvLyBhc3N1bWUgaXQgaXMgYSBzZWxlY3Rpb24gcmVwbGFjZSAod2l0aCBpZGVudGljYWwgY2hhcmFjdGVycyBhdFxyXG4gICAgICAgIC8vIHRoZSBzdGFydC9lbmQgbm90IGluY2x1ZGVkIGluIHRoZSBkaWZmKVxyXG4gICAgICAgIGNoYW5nZSA9IHtcclxuICAgICAgICAgICAgZnJvbTogc2VsLmZyb20sIHRvOiBzZWwudG8sXHJcbiAgICAgICAgICAgIGluc2VydDogdmlldy5zdGF0ZS5kb2Muc2xpY2Uoc2VsLmZyb20sIGNoYW5nZS5mcm9tKS5hcHBlbmQoY2hhbmdlLmluc2VydCkuYXBwZW5kKHZpZXcuc3RhdGUuZG9jLnNsaWNlKGNoYW5nZS50bywgc2VsLnRvKSlcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoKGJyb3dzZXIubWFjIHx8IGJyb3dzZXIuYW5kcm9pZCkgJiYgY2hhbmdlICYmIGNoYW5nZS5mcm9tID09IGNoYW5nZS50byAmJiBjaGFuZ2UuZnJvbSA9PSBzZWwuaGVhZCAtIDEgJiZcclxuICAgICAgICAvXlxcLiA/JC8udGVzdChjaGFuZ2UuaW5zZXJ0LnRvU3RyaW5nKCkpKSB7XHJcbiAgICAgICAgLy8gRGV0ZWN0IGluc2VydC1wZXJpb2Qtb24tZG91YmxlLXNwYWNlIE1hYyBhbmQgQW5kcm9pZCBiZWhhdmlvcixcclxuICAgICAgICAvLyBhbmQgdHJhbnNmb3JtIGl0IGludG8gYSByZWd1bGFyIHNwYWNlIGluc2VydC5cclxuICAgICAgICBpZiAobmV3U2VsICYmIGNoYW5nZS5pbnNlcnQubGVuZ3RoID09IDIpXHJcbiAgICAgICAgICAgIG5ld1NlbCA9IEVkaXRvclNlbGVjdGlvbi5zaW5nbGUobmV3U2VsLm1haW4uYW5jaG9yIC0gMSwgbmV3U2VsLm1haW4uaGVhZCAtIDEpO1xyXG4gICAgICAgIGNoYW5nZSA9IHsgZnJvbTogc2VsLmZyb20sIHRvOiBzZWwudG8sIGluc2VydDogVGV4dC5vZihbXCIgXCJdKSB9O1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoYnJvd3Nlci5jaHJvbWUgJiYgY2hhbmdlICYmIGNoYW5nZS5mcm9tID09IGNoYW5nZS50byAmJiBjaGFuZ2UuZnJvbSA9PSBzZWwuaGVhZCAmJlxyXG4gICAgICAgIGNoYW5nZS5pbnNlcnQudG9TdHJpbmcoKSA9PSBcIlxcbiBcIiAmJiB2aWV3LmxpbmVXcmFwcGluZykge1xyXG4gICAgICAgIC8vIEluIENocm9tZSwgaWYgeW91IGluc2VydCBhIHNwYWNlIGF0IHRoZSBzdGFydCBvZiBhIHdyYXBwZWRcclxuICAgICAgICAvLyBsaW5lLCBpdCB3aWxsIGFjdHVhbGx5IGluc2VydCBhIG5ld2xpbmUgYW5kIGEgc3BhY2UsIGNhdXNpbmcgYVxyXG4gICAgICAgIC8vIGJvZ3VzIG5ldyBsaW5lIHRvIGJlIGNyZWF0ZWQgaW4gQ29kZU1pcnJvciAoIzk2OClcclxuICAgICAgICBpZiAobmV3U2VsKVxyXG4gICAgICAgICAgICBuZXdTZWwgPSBFZGl0b3JTZWxlY3Rpb24uc2luZ2xlKG5ld1NlbC5tYWluLmFuY2hvciAtIDEsIG5ld1NlbC5tYWluLmhlYWQgLSAxKTtcclxuICAgICAgICBjaGFuZ2UgPSB7IGZyb206IHNlbC5mcm9tLCB0bzogc2VsLnRvLCBpbnNlcnQ6IFRleHQub2YoW1wiIFwiXSkgfTtcclxuICAgIH1cclxuICAgIGlmIChjaGFuZ2UpIHtcclxuICAgICAgICBsZXQgc3RhcnRTdGF0ZSA9IHZpZXcuc3RhdGU7XHJcbiAgICAgICAgaWYgKGJyb3dzZXIuaW9zICYmIHZpZXcuaW5wdXRTdGF0ZS5mbHVzaElPU0tleSh2aWV3KSlcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgLy8gQW5kcm9pZCBicm93c2VycyBkb24ndCBmaXJlIHJlYXNvbmFibGUga2V5IGV2ZW50cyBmb3IgZW50ZXIsXHJcbiAgICAgICAgLy8gYmFja3NwYWNlLCBvciBkZWxldGUuIFNvIHRoaXMgZGV0ZWN0cyBjaGFuZ2VzIHRoYXQgbG9vayBsaWtlXHJcbiAgICAgICAgLy8gdGhleSdyZSBjYXVzZWQgYnkgdGhvc2Uga2V5cywgYW5kIHJlaW50ZXJwcmV0cyB0aGVtIGFzIGtleVxyXG4gICAgICAgIC8vIGV2ZW50cy4gKFNvbWUgb2YgdGhlc2Uga2V5cyBhcmUgYWxzbyBoYW5kbGVkIGJ5IGJlZm9yZWlucHV0XHJcbiAgICAgICAgLy8gZXZlbnRzIGFuZCB0aGUgcGVuZGluZ0FuZHJvaWRLZXkgbWVjaGFuaXNtLCBidXQgdGhhdCdzIG5vdFxyXG4gICAgICAgIC8vIHJlbGlhYmxlIGluIGFsbCBzaXR1YXRpb25zLilcclxuICAgICAgICBpZiAoYnJvd3Nlci5hbmRyb2lkICYmXHJcbiAgICAgICAgICAgICgoY2hhbmdlLmZyb20gPT0gc2VsLmZyb20gJiYgY2hhbmdlLnRvID09IHNlbC50byAmJlxyXG4gICAgICAgICAgICAgICAgY2hhbmdlLmluc2VydC5sZW5ndGggPT0gMSAmJiBjaGFuZ2UuaW5zZXJ0LmxpbmVzID09IDIgJiZcclxuICAgICAgICAgICAgICAgIGRpc3BhdGNoS2V5KHZpZXcuY29udGVudERPTSwgXCJFbnRlclwiLCAxMykpIHx8XHJcbiAgICAgICAgICAgICAgICAoY2hhbmdlLmZyb20gPT0gc2VsLmZyb20gLSAxICYmIGNoYW5nZS50byA9PSBzZWwudG8gJiYgY2hhbmdlLmluc2VydC5sZW5ndGggPT0gMCAmJlxyXG4gICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoS2V5KHZpZXcuY29udGVudERPTSwgXCJCYWNrc3BhY2VcIiwgOCkpIHx8XHJcbiAgICAgICAgICAgICAgICAoY2hhbmdlLmZyb20gPT0gc2VsLmZyb20gJiYgY2hhbmdlLnRvID09IHNlbC50byArIDEgJiYgY2hhbmdlLmluc2VydC5sZW5ndGggPT0gMCAmJlxyXG4gICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoS2V5KHZpZXcuY29udGVudERPTSwgXCJEZWxldGVcIiwgNDYpKSkpXHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIGxldCB0ZXh0ID0gY2hhbmdlLmluc2VydC50b1N0cmluZygpO1xyXG4gICAgICAgIGlmICh2aWV3LnN0YXRlLmZhY2V0KGlucHV0SGFuZGxlcikuc29tZShoID0+IGgodmlldywgY2hhbmdlLmZyb20sIGNoYW5nZS50bywgdGV4dCkpKVxyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICBpZiAodmlldy5pbnB1dFN0YXRlLmNvbXBvc2luZyA+PSAwKVxyXG4gICAgICAgICAgICB2aWV3LmlucHV0U3RhdGUuY29tcG9zaW5nKys7XHJcbiAgICAgICAgbGV0IHRyO1xyXG4gICAgICAgIGlmIChjaGFuZ2UuZnJvbSA+PSBzZWwuZnJvbSAmJiBjaGFuZ2UudG8gPD0gc2VsLnRvICYmIGNoYW5nZS50byAtIGNoYW5nZS5mcm9tID49IChzZWwudG8gLSBzZWwuZnJvbSkgLyAzICYmXHJcbiAgICAgICAgICAgICghbmV3U2VsIHx8IG5ld1NlbC5tYWluLmVtcHR5ICYmIG5ld1NlbC5tYWluLmZyb20gPT0gY2hhbmdlLmZyb20gKyBjaGFuZ2UuaW5zZXJ0Lmxlbmd0aCkgJiZcclxuICAgICAgICAgICAgdmlldy5pbnB1dFN0YXRlLmNvbXBvc2luZyA8IDApIHtcclxuICAgICAgICAgICAgbGV0IGJlZm9yZSA9IHNlbC5mcm9tIDwgY2hhbmdlLmZyb20gPyBzdGFydFN0YXRlLnNsaWNlRG9jKHNlbC5mcm9tLCBjaGFuZ2UuZnJvbSkgOiBcIlwiO1xyXG4gICAgICAgICAgICBsZXQgYWZ0ZXIgPSBzZWwudG8gPiBjaGFuZ2UudG8gPyBzdGFydFN0YXRlLnNsaWNlRG9jKGNoYW5nZS50bywgc2VsLnRvKSA6IFwiXCI7XHJcbiAgICAgICAgICAgIHRyID0gc3RhcnRTdGF0ZS5yZXBsYWNlU2VsZWN0aW9uKHZpZXcuc3RhdGUudG9UZXh0KGJlZm9yZSArIGNoYW5nZS5pbnNlcnQuc2xpY2VTdHJpbmcoMCwgdW5kZWZpbmVkLCB2aWV3LnN0YXRlLmxpbmVCcmVhaykgKyBhZnRlcikpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgbGV0IGNoYW5nZXMgPSBzdGFydFN0YXRlLmNoYW5nZXMoY2hhbmdlKTtcclxuICAgICAgICAgICAgbGV0IG1haW5TZWwgPSBuZXdTZWwgJiYgIXN0YXJ0U3RhdGUuc2VsZWN0aW9uLm1haW4uZXEobmV3U2VsLm1haW4pICYmIG5ld1NlbC5tYWluLnRvIDw9IGNoYW5nZXMubmV3TGVuZ3RoXHJcbiAgICAgICAgICAgICAgICA/IG5ld1NlbC5tYWluIDogdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICAvLyBUcnkgdG8gYXBwbHkgYSBjb21wb3NpdGlvbiBjaGFuZ2UgdG8gYWxsIGN1cnNvcnNcclxuICAgICAgICAgICAgaWYgKHN0YXJ0U3RhdGUuc2VsZWN0aW9uLnJhbmdlcy5sZW5ndGggPiAxICYmIHZpZXcuaW5wdXRTdGF0ZS5jb21wb3NpbmcgPj0gMCAmJlxyXG4gICAgICAgICAgICAgICAgY2hhbmdlLnRvIDw9IHNlbC50byAmJiBjaGFuZ2UudG8gPj0gc2VsLnRvIC0gMTApIHtcclxuICAgICAgICAgICAgICAgIGxldCByZXBsYWNlZCA9IHZpZXcuc3RhdGUuc2xpY2VEb2MoY2hhbmdlLmZyb20sIGNoYW5nZS50byk7XHJcbiAgICAgICAgICAgICAgICBsZXQgY29tcG9zaXRpb25SYW5nZSA9IGNvbXBvc2l0aW9uU3Vycm91bmRpbmdOb2RlKHZpZXcpIHx8IHZpZXcuc3RhdGUuZG9jLmxpbmVBdChzZWwuaGVhZCk7XHJcbiAgICAgICAgICAgICAgICBsZXQgb2Zmc2V0ID0gc2VsLnRvIC0gY2hhbmdlLnRvLCBzaXplID0gc2VsLnRvIC0gc2VsLmZyb207XHJcbiAgICAgICAgICAgICAgICB0ciA9IHN0YXJ0U3RhdGUuY2hhbmdlQnlSYW5nZShyYW5nZSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJhbmdlLmZyb20gPT0gc2VsLmZyb20gJiYgcmFuZ2UudG8gPT0gc2VsLnRvKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBjaGFuZ2VzLCByYW5nZTogbWFpblNlbCB8fCByYW5nZS5tYXAoY2hhbmdlcykgfTtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgdG8gPSByYW5nZS50byAtIG9mZnNldCwgZnJvbSA9IHRvIC0gcmVwbGFjZWQubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChyYW5nZS50byAtIHJhbmdlLmZyb20gIT0gc2l6ZSB8fCB2aWV3LnN0YXRlLnNsaWNlRG9jKGZyb20sIHRvKSAhPSByZXBsYWNlZCB8fFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBVbmZvcnR1bmF0ZWx5LCB0aGVyZSdzIG5vIHdheSB0byBtYWtlIG11bHRpcGxlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNoYW5nZXMgaW4gdGhlIHNhbWUgbm9kZSB3b3JrIHdpdGhvdXQgYWJvcnRpbmdcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY29tcG9zaXRpb24sIHNvIGN1cnNvcnMgaW4gdGhlIGNvbXBvc2l0aW9uIHJhbmdlIGFyZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpZ25vcmVkLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb21wb3NpdGlvblJhbmdlICYmIHJhbmdlLnRvID49IGNvbXBvc2l0aW9uUmFuZ2UuZnJvbSAmJiByYW5nZS5mcm9tIDw9IGNvbXBvc2l0aW9uUmFuZ2UudG8pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHJhbmdlIH07XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IHJhbmdlQ2hhbmdlcyA9IHN0YXJ0U3RhdGUuY2hhbmdlcyh7IGZyb20sIHRvLCBpbnNlcnQ6IGNoYW5nZS5pbnNlcnQgfSksIHNlbE9mZiA9IHJhbmdlLnRvIC0gc2VsLnRvO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoYW5nZXM6IHJhbmdlQ2hhbmdlcyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmFuZ2U6ICFtYWluU2VsID8gcmFuZ2UubWFwKHJhbmdlQ2hhbmdlcykgOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgRWRpdG9yU2VsZWN0aW9uLnJhbmdlKE1hdGgubWF4KDAsIG1haW5TZWwuYW5jaG9yICsgc2VsT2ZmKSwgTWF0aC5tYXgoMCwgbWFpblNlbC5oZWFkICsgc2VsT2ZmKSlcclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0ciA9IHtcclxuICAgICAgICAgICAgICAgICAgICBjaGFuZ2VzLFxyXG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdGlvbjogbWFpblNlbCAmJiBzdGFydFN0YXRlLnNlbGVjdGlvbi5yZXBsYWNlUmFuZ2UobWFpblNlbClcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IHVzZXJFdmVudCA9IFwiaW5wdXQudHlwZVwiO1xyXG4gICAgICAgIGlmICh2aWV3LmNvbXBvc2luZykge1xyXG4gICAgICAgICAgICB1c2VyRXZlbnQgKz0gXCIuY29tcG9zZVwiO1xyXG4gICAgICAgICAgICBpZiAodmlldy5pbnB1dFN0YXRlLmNvbXBvc2l0aW9uRmlyc3RDaGFuZ2UpIHtcclxuICAgICAgICAgICAgICAgIHVzZXJFdmVudCArPSBcIi5zdGFydFwiO1xyXG4gICAgICAgICAgICAgICAgdmlldy5pbnB1dFN0YXRlLmNvbXBvc2l0aW9uRmlyc3RDaGFuZ2UgPSBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB2aWV3LmRpc3BhdGNoKHRyLCB7IHNjcm9sbEludG9WaWV3OiB0cnVlLCB1c2VyRXZlbnQgfSk7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChuZXdTZWwgJiYgIW5ld1NlbC5tYWluLmVxKHNlbCkpIHtcclxuICAgICAgICBsZXQgc2Nyb2xsSW50b1ZpZXcgPSBmYWxzZSwgdXNlckV2ZW50ID0gXCJzZWxlY3RcIjtcclxuICAgICAgICBpZiAodmlldy5pbnB1dFN0YXRlLmxhc3RTZWxlY3Rpb25UaW1lID4gRGF0ZS5ub3coKSAtIDUwKSB7XHJcbiAgICAgICAgICAgIGlmICh2aWV3LmlucHV0U3RhdGUubGFzdFNlbGVjdGlvbk9yaWdpbiA9PSBcInNlbGVjdFwiKVxyXG4gICAgICAgICAgICAgICAgc2Nyb2xsSW50b1ZpZXcgPSB0cnVlO1xyXG4gICAgICAgICAgICB1c2VyRXZlbnQgPSB2aWV3LmlucHV0U3RhdGUubGFzdFNlbGVjdGlvbk9yaWdpbjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmlldy5kaXNwYXRjaCh7IHNlbGVjdGlvbjogbmV3U2VsLCBzY3JvbGxJbnRvVmlldywgdXNlckV2ZW50IH0pO1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGZpbmREaWZmKGEsIGIsIHByZWZlcnJlZFBvcywgcHJlZmVycmVkU2lkZSkge1xyXG4gICAgbGV0IG1pbkxlbiA9IE1hdGgubWluKGEubGVuZ3RoLCBiLmxlbmd0aCk7XHJcbiAgICBsZXQgZnJvbSA9IDA7XHJcbiAgICB3aGlsZSAoZnJvbSA8IG1pbkxlbiAmJiBhLmNoYXJDb2RlQXQoZnJvbSkgPT0gYi5jaGFyQ29kZUF0KGZyb20pKVxyXG4gICAgICAgIGZyb20rKztcclxuICAgIGlmIChmcm9tID09IG1pbkxlbiAmJiBhLmxlbmd0aCA9PSBiLmxlbmd0aClcclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIGxldCB0b0EgPSBhLmxlbmd0aCwgdG9CID0gYi5sZW5ndGg7XHJcbiAgICB3aGlsZSAodG9BID4gMCAmJiB0b0IgPiAwICYmIGEuY2hhckNvZGVBdCh0b0EgLSAxKSA9PSBiLmNoYXJDb2RlQXQodG9CIC0gMSkpIHtcclxuICAgICAgICB0b0EtLTtcclxuICAgICAgICB0b0ItLTtcclxuICAgIH1cclxuICAgIGlmIChwcmVmZXJyZWRTaWRlID09IFwiZW5kXCIpIHtcclxuICAgICAgICBsZXQgYWRqdXN0ID0gTWF0aC5tYXgoMCwgZnJvbSAtIE1hdGgubWluKHRvQSwgdG9CKSk7XHJcbiAgICAgICAgcHJlZmVycmVkUG9zIC09IHRvQSArIGFkanVzdCAtIGZyb207XHJcbiAgICB9XHJcbiAgICBpZiAodG9BIDwgZnJvbSAmJiBhLmxlbmd0aCA8IGIubGVuZ3RoKSB7XHJcbiAgICAgICAgbGV0IG1vdmUgPSBwcmVmZXJyZWRQb3MgPD0gZnJvbSAmJiBwcmVmZXJyZWRQb3MgPj0gdG9BID8gZnJvbSAtIHByZWZlcnJlZFBvcyA6IDA7XHJcbiAgICAgICAgZnJvbSAtPSBtb3ZlO1xyXG4gICAgICAgIHRvQiA9IGZyb20gKyAodG9CIC0gdG9BKTtcclxuICAgICAgICB0b0EgPSBmcm9tO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAodG9CIDwgZnJvbSkge1xyXG4gICAgICAgIGxldCBtb3ZlID0gcHJlZmVycmVkUG9zIDw9IGZyb20gJiYgcHJlZmVycmVkUG9zID49IHRvQiA/IGZyb20gLSBwcmVmZXJyZWRQb3MgOiAwO1xyXG4gICAgICAgIGZyb20gLT0gbW92ZTtcclxuICAgICAgICB0b0EgPSBmcm9tICsgKHRvQSAtIHRvQik7XHJcbiAgICAgICAgdG9CID0gZnJvbTtcclxuICAgIH1cclxuICAgIHJldHVybiB7IGZyb20sIHRvQSwgdG9CIH07XHJcbn1cclxuZnVuY3Rpb24gc2VsZWN0aW9uUG9pbnRzKHZpZXcpIHtcclxuICAgIGxldCByZXN1bHQgPSBbXTtcclxuICAgIGlmICh2aWV3LnJvb3QuYWN0aXZlRWxlbWVudCAhPSB2aWV3LmNvbnRlbnRET00pXHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIGxldCB7IGFuY2hvck5vZGUsIGFuY2hvck9mZnNldCwgZm9jdXNOb2RlLCBmb2N1c09mZnNldCB9ID0gdmlldy5vYnNlcnZlci5zZWxlY3Rpb25SYW5nZTtcclxuICAgIGlmIChhbmNob3JOb2RlKSB7XHJcbiAgICAgICAgcmVzdWx0LnB1c2gobmV3IERPTVBvaW50KGFuY2hvck5vZGUsIGFuY2hvck9mZnNldCkpO1xyXG4gICAgICAgIGlmIChmb2N1c05vZGUgIT0gYW5jaG9yTm9kZSB8fCBmb2N1c09mZnNldCAhPSBhbmNob3JPZmZzZXQpXHJcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKG5ldyBET01Qb2ludChmb2N1c05vZGUsIGZvY3VzT2Zmc2V0KSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59XHJcbmZ1bmN0aW9uIHNlbGVjdGlvbkZyb21Qb2ludHMocG9pbnRzLCBiYXNlKSB7XHJcbiAgICBpZiAocG9pbnRzLmxlbmd0aCA9PSAwKVxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgbGV0IGFuY2hvciA9IHBvaW50c1swXS5wb3MsIGhlYWQgPSBwb2ludHMubGVuZ3RoID09IDIgPyBwb2ludHNbMV0ucG9zIDogYW5jaG9yO1xyXG4gICAgcmV0dXJuIGFuY2hvciA+IC0xICYmIGhlYWQgPiAtMSA/IEVkaXRvclNlbGVjdGlvbi5zaW5nbGUoYW5jaG9yICsgYmFzZSwgaGVhZCArIGJhc2UpIDogbnVsbDtcclxufVxyXG5cclxuY29uc3Qgb2JzZXJ2ZU9wdGlvbnMgPSB7XHJcbiAgICBjaGlsZExpc3Q6IHRydWUsXHJcbiAgICBjaGFyYWN0ZXJEYXRhOiB0cnVlLFxyXG4gICAgc3VidHJlZTogdHJ1ZSxcclxuICAgIGF0dHJpYnV0ZXM6IHRydWUsXHJcbiAgICBjaGFyYWN0ZXJEYXRhT2xkVmFsdWU6IHRydWVcclxufTtcclxuLy8gSUUxMSBoYXMgdmVyeSBicm9rZW4gbXV0YXRpb24gb2JzZXJ2ZXJzLCBzbyB3ZSBhbHNvIGxpc3RlbiB0b1xyXG4vLyBET01DaGFyYWN0ZXJEYXRhTW9kaWZpZWQgdGhlcmVcclxuY29uc3QgdXNlQ2hhckRhdGEgPSBicm93c2VyLmllICYmIGJyb3dzZXIuaWVfdmVyc2lvbiA8PSAxMTtcclxuY2xhc3MgRE9NT2JzZXJ2ZXIge1xyXG4gICAgY29uc3RydWN0b3Iodmlldykge1xyXG4gICAgICAgIHRoaXMudmlldyA9IHZpZXc7XHJcbiAgICAgICAgdGhpcy5hY3RpdmUgPSBmYWxzZTtcclxuICAgICAgICAvLyBUaGUga25vd24gc2VsZWN0aW9uLiBLZXB0IGluIG91ciBvd24gb2JqZWN0LCBhcyBvcHBvc2VkIHRvIGp1c3RcclxuICAgICAgICAvLyBkaXJlY3RseSBhY2Nlc3NpbmcgdGhlIHNlbGVjdGlvbiBiZWNhdXNlOlxyXG4gICAgICAgIC8vICAtIFNhZmFyaSBkb2Vzbid0IHJlcG9ydCB0aGUgcmlnaHQgc2VsZWN0aW9uIGluIHNoYWRvdyBET01cclxuICAgICAgICAvLyAgLSBSZWFkaW5nIGZyb20gdGhlIHNlbGVjdGlvbiBmb3JjZXMgYSBET00gbGF5b3V0XHJcbiAgICAgICAgLy8gIC0gVGhpcyB3YXksIHdlIGNhbiBpZ25vcmUgc2VsZWN0aW9uY2hhbmdlIGV2ZW50cyBpZiB3ZSBoYXZlXHJcbiAgICAgICAgLy8gICAgYWxyZWFkeSBzZWVuIHRoZSAnbmV3JyBzZWxlY3Rpb25cclxuICAgICAgICB0aGlzLnNlbGVjdGlvblJhbmdlID0gbmV3IERPTVNlbGVjdGlvblN0YXRlO1xyXG4gICAgICAgIC8vIFNldCB3aGVuIGEgc2VsZWN0aW9uIGNoYW5nZSBpcyBkZXRlY3RlZCwgY2xlYXJlZCBvbiBmbHVzaFxyXG4gICAgICAgIHRoaXMuc2VsZWN0aW9uQ2hhbmdlZCA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuZGVsYXllZEZsdXNoID0gLTE7XHJcbiAgICAgICAgdGhpcy5yZXNpemVUaW1lb3V0ID0gLTE7XHJcbiAgICAgICAgdGhpcy5xdWV1ZSA9IFtdO1xyXG4gICAgICAgIHRoaXMuZGVsYXllZEFuZHJvaWRLZXkgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuZmx1c2hpbmdBbmRyb2lkS2V5ID0gLTE7XHJcbiAgICAgICAgdGhpcy5sYXN0Q2hhbmdlID0gMDtcclxuICAgICAgICB0aGlzLnNjcm9sbFRhcmdldHMgPSBbXTtcclxuICAgICAgICB0aGlzLmludGVyc2VjdGlvbiA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5yZXNpemVTY3JvbGwgPSBudWxsO1xyXG4gICAgICAgIHRoaXMucmVzaXplQ29udGVudCA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5pbnRlcnNlY3RpbmcgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLmdhcEludGVyc2VjdGlvbiA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5nYXBzID0gW107XHJcbiAgICAgICAgLy8gVGltZW91dCBmb3Igc2NoZWR1bGluZyBjaGVjayBvZiB0aGUgcGFyZW50cyB0aGF0IG5lZWQgc2Nyb2xsIGhhbmRsZXJzXHJcbiAgICAgICAgdGhpcy5wYXJlbnRDaGVjayA9IC0xO1xyXG4gICAgICAgIHRoaXMuZG9tID0gdmlldy5jb250ZW50RE9NO1xyXG4gICAgICAgIHRoaXMub2JzZXJ2ZXIgPSBuZXcgTXV0YXRpb25PYnNlcnZlcihtdXRhdGlvbnMgPT4ge1xyXG4gICAgICAgICAgICBmb3IgKGxldCBtdXQgb2YgbXV0YXRpb25zKVxyXG4gICAgICAgICAgICAgICAgdGhpcy5xdWV1ZS5wdXNoKG11dCk7XHJcbiAgICAgICAgICAgIC8vIElFMTEgd2lsbCBzb21ldGltZXMgKG9uIHR5cGluZyBvdmVyIGEgc2VsZWN0aW9uIG9yXHJcbiAgICAgICAgICAgIC8vIGJhY2tzcGFjaW5nIG91dCBhIHNpbmdsZSBjaGFyYWN0ZXIgdGV4dCBub2RlKSBjYWxsIHRoZVxyXG4gICAgICAgICAgICAvLyBvYnNlcnZlciBjYWxsYmFjayBiZWZvcmUgYWN0dWFsbHkgdXBkYXRpbmcgdGhlIERPTS5cclxuICAgICAgICAgICAgLy9cclxuICAgICAgICAgICAgLy8gVW5yZWxhdGVkbHksIGlPUyBTYWZhcmkgd2lsbCwgd2hlbiBlbmRpbmcgYSBjb21wb3NpdGlvbixcclxuICAgICAgICAgICAgLy8gc29tZXRpbWVzIGZpcnN0IGNsZWFyIGl0LCBkZWxpdmVyIHRoZSBtdXRhdGlvbnMsIGFuZCB0aGVuXHJcbiAgICAgICAgICAgIC8vIHJlaW5zZXJ0IHRoZSBmaW5pc2hlZCB0ZXh0LiBDb2RlTWlycm9yJ3MgaGFuZGxpbmcgb2YgdGhlXHJcbiAgICAgICAgICAgIC8vIGRlbGV0aW9uIHdpbGwgcHJldmVudCB0aGUgcmVpbnNlcnRpb24gZnJvbSBoYXBwZW5pbmcsXHJcbiAgICAgICAgICAgIC8vIGJyZWFraW5nIGNvbXBvc2l0aW9uLlxyXG4gICAgICAgICAgICBpZiAoKGJyb3dzZXIuaWUgJiYgYnJvd3Nlci5pZV92ZXJzaW9uIDw9IDExIHx8IGJyb3dzZXIuaW9zICYmIHZpZXcuY29tcG9zaW5nKSAmJlxyXG4gICAgICAgICAgICAgICAgbXV0YXRpb25zLnNvbWUobSA9PiBtLnR5cGUgPT0gXCJjaGlsZExpc3RcIiAmJiBtLnJlbW92ZWROb2Rlcy5sZW5ndGggfHxcclxuICAgICAgICAgICAgICAgICAgICBtLnR5cGUgPT0gXCJjaGFyYWN0ZXJEYXRhXCIgJiYgbS5vbGRWYWx1ZS5sZW5ndGggPiBtLnRhcmdldC5ub2RlVmFsdWUubGVuZ3RoKSlcclxuICAgICAgICAgICAgICAgIHRoaXMuZmx1c2hTb29uKCk7XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgIHRoaXMuZmx1c2goKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICBpZiAodXNlQ2hhckRhdGEpXHJcbiAgICAgICAgICAgIHRoaXMub25DaGFyRGF0YSA9IChldmVudCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5xdWV1ZS5wdXNoKHsgdGFyZ2V0OiBldmVudC50YXJnZXQsXHJcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJjaGFyYWN0ZXJEYXRhXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgb2xkVmFsdWU6IGV2ZW50LnByZXZWYWx1ZSB9KTtcclxuICAgICAgICAgICAgICAgIHRoaXMuZmx1c2hTb29uKCk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgdGhpcy5vblNlbGVjdGlvbkNoYW5nZSA9IHRoaXMub25TZWxlY3Rpb25DaGFuZ2UuYmluZCh0aGlzKTtcclxuICAgICAgICB0aGlzLm9uUmVzaXplID0gdGhpcy5vblJlc2l6ZS5iaW5kKHRoaXMpO1xyXG4gICAgICAgIHRoaXMub25QcmludCA9IHRoaXMub25QcmludC5iaW5kKHRoaXMpO1xyXG4gICAgICAgIHRoaXMub25TY3JvbGwgPSB0aGlzLm9uU2Nyb2xsLmJpbmQodGhpcyk7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBSZXNpemVPYnNlcnZlciA9PSBcImZ1bmN0aW9uXCIpIHtcclxuICAgICAgICAgICAgdGhpcy5yZXNpemVTY3JvbGwgPSBuZXcgUmVzaXplT2JzZXJ2ZXIoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgICAgICAgICAgaWYgKCgoX2EgPSB0aGlzLnZpZXcuZG9jVmlldykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmxhc3RVcGRhdGUpIDwgRGF0ZS5ub3coKSAtIDc1KVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMub25SZXNpemUoKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHRoaXMucmVzaXplU2Nyb2xsLm9ic2VydmUodmlldy5zY3JvbGxET00pO1xyXG4gICAgICAgICAgICB0aGlzLnJlc2l6ZUNvbnRlbnQgPSBuZXcgUmVzaXplT2JzZXJ2ZXIoKCkgPT4gdGhpcy52aWV3LnJlcXVlc3RNZWFzdXJlKCkpO1xyXG4gICAgICAgICAgICB0aGlzLnJlc2l6ZUNvbnRlbnQub2JzZXJ2ZSh2aWV3LmNvbnRlbnRET00pO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmFkZFdpbmRvd0xpc3RlbmVycyh0aGlzLndpbiA9IHZpZXcud2luKTtcclxuICAgICAgICB0aGlzLnN0YXJ0KCk7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBJbnRlcnNlY3Rpb25PYnNlcnZlciA9PSBcImZ1bmN0aW9uXCIpIHtcclxuICAgICAgICAgICAgdGhpcy5pbnRlcnNlY3Rpb24gPSBuZXcgSW50ZXJzZWN0aW9uT2JzZXJ2ZXIoZW50cmllcyA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5wYXJlbnRDaGVjayA8IDApXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wYXJlbnRDaGVjayA9IHNldFRpbWVvdXQodGhpcy5saXN0ZW5Gb3JTY3JvbGwuYmluZCh0aGlzKSwgMTAwMCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoZW50cmllcy5sZW5ndGggPiAwICYmIChlbnRyaWVzW2VudHJpZXMubGVuZ3RoIC0gMV0uaW50ZXJzZWN0aW9uUmF0aW8gPiAwKSAhPSB0aGlzLmludGVyc2VjdGluZykge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaW50ZXJzZWN0aW5nID0gIXRoaXMuaW50ZXJzZWN0aW5nO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmludGVyc2VjdGluZyAhPSB0aGlzLnZpZXcuaW5WaWV3KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm9uU2Nyb2xsQ2hhbmdlZChkb2N1bWVudC5jcmVhdGVFdmVudChcIkV2ZW50XCIpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSwge30pO1xyXG4gICAgICAgICAgICB0aGlzLmludGVyc2VjdGlvbi5vYnNlcnZlKHRoaXMuZG9tKTtcclxuICAgICAgICAgICAgdGhpcy5nYXBJbnRlcnNlY3Rpb24gPSBuZXcgSW50ZXJzZWN0aW9uT2JzZXJ2ZXIoZW50cmllcyA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZW50cmllcy5sZW5ndGggPiAwICYmIGVudHJpZXNbZW50cmllcy5sZW5ndGggLSAxXS5pbnRlcnNlY3Rpb25SYXRpbyA+IDApXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vblNjcm9sbENoYW5nZWQoZG9jdW1lbnQuY3JlYXRlRXZlbnQoXCJFdmVudFwiKSk7XHJcbiAgICAgICAgICAgIH0sIHt9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5saXN0ZW5Gb3JTY3JvbGwoKTtcclxuICAgICAgICB0aGlzLnJlYWRTZWxlY3Rpb25SYW5nZSgpO1xyXG4gICAgfVxyXG4gICAgb25TY3JvbGxDaGFuZ2VkKGUpIHtcclxuICAgICAgICB0aGlzLnZpZXcuaW5wdXRTdGF0ZS5ydW5TY3JvbGxIYW5kbGVycyh0aGlzLnZpZXcsIGUpO1xyXG4gICAgICAgIGlmICh0aGlzLmludGVyc2VjdGluZylcclxuICAgICAgICAgICAgdGhpcy52aWV3Lm1lYXN1cmUoKTtcclxuICAgIH1cclxuICAgIG9uU2Nyb2xsKGUpIHtcclxuICAgICAgICBpZiAodGhpcy5pbnRlcnNlY3RpbmcpXHJcbiAgICAgICAgICAgIHRoaXMuZmx1c2goZmFsc2UpO1xyXG4gICAgICAgIHRoaXMub25TY3JvbGxDaGFuZ2VkKGUpO1xyXG4gICAgfVxyXG4gICAgb25SZXNpemUoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMucmVzaXplVGltZW91dCA8IDApXHJcbiAgICAgICAgICAgIHRoaXMucmVzaXplVGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5yZXNpemVUaW1lb3V0ID0gLTE7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnZpZXcucmVxdWVzdE1lYXN1cmUoKTtcclxuICAgICAgICAgICAgfSwgNTApO1xyXG4gICAgfVxyXG4gICAgb25QcmludCgpIHtcclxuICAgICAgICB0aGlzLnZpZXcudmlld1N0YXRlLnByaW50aW5nID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLnZpZXcubWVhc3VyZSgpO1xyXG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLnZpZXcudmlld1N0YXRlLnByaW50aW5nID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHRoaXMudmlldy5yZXF1ZXN0TWVhc3VyZSgpO1xyXG4gICAgICAgIH0sIDUwMCk7XHJcbiAgICB9XHJcbiAgICB1cGRhdGVHYXBzKGdhcHMpIHtcclxuICAgICAgICBpZiAodGhpcy5nYXBJbnRlcnNlY3Rpb24gJiYgKGdhcHMubGVuZ3RoICE9IHRoaXMuZ2Fwcy5sZW5ndGggfHwgdGhpcy5nYXBzLnNvbWUoKGcsIGkpID0+IGcgIT0gZ2Fwc1tpXSkpKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZ2FwSW50ZXJzZWN0aW9uLmRpc2Nvbm5lY3QoKTtcclxuICAgICAgICAgICAgZm9yIChsZXQgZ2FwIG9mIGdhcHMpXHJcbiAgICAgICAgICAgICAgICB0aGlzLmdhcEludGVyc2VjdGlvbi5vYnNlcnZlKGdhcCk7XHJcbiAgICAgICAgICAgIHRoaXMuZ2FwcyA9IGdhcHM7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgb25TZWxlY3Rpb25DaGFuZ2UoZXZlbnQpIHtcclxuICAgICAgICBsZXQgd2FzQ2hhbmdlZCA9IHRoaXMuc2VsZWN0aW9uQ2hhbmdlZDtcclxuICAgICAgICBpZiAoIXRoaXMucmVhZFNlbGVjdGlvblJhbmdlKCkgfHwgdGhpcy5kZWxheWVkQW5kcm9pZEtleSlcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIGxldCB7IHZpZXcgfSA9IHRoaXMsIHNlbCA9IHRoaXMuc2VsZWN0aW9uUmFuZ2U7XHJcbiAgICAgICAgaWYgKHZpZXcuc3RhdGUuZmFjZXQoZWRpdGFibGUpID8gdmlldy5yb290LmFjdGl2ZUVsZW1lbnQgIT0gdGhpcy5kb20gOiAhaGFzU2VsZWN0aW9uKHZpZXcuZG9tLCBzZWwpKVxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgbGV0IGNvbnRleHQgPSBzZWwuYW5jaG9yTm9kZSAmJiB2aWV3LmRvY1ZpZXcubmVhcmVzdChzZWwuYW5jaG9yTm9kZSk7XHJcbiAgICAgICAgaWYgKGNvbnRleHQgJiYgY29udGV4dC5pZ25vcmVFdmVudChldmVudCkpIHtcclxuICAgICAgICAgICAgaWYgKCF3YXNDaGFuZ2VkKVxyXG4gICAgICAgICAgICAgICAgdGhpcy5zZWxlY3Rpb25DaGFuZ2VkID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gRGVsZXRpb25zIG9uIElFMTEgZmlyZSB0aGVpciBldmVudHMgaW4gdGhlIHdyb25nIG9yZGVyLCBnaXZpbmdcclxuICAgICAgICAvLyB1cyBhIHNlbGVjdGlvbiBjaGFuZ2UgZXZlbnQgYmVmb3JlIHRoZSBET00gY2hhbmdlcyBhcmVcclxuICAgICAgICAvLyByZXBvcnRlZC5cclxuICAgICAgICAvLyBDaHJvbWUgQW5kcm9pZCBoYXMgYSBzaW1pbGFyIGlzc3VlIHdoZW4gYmFja3NwYWNpbmcgb3V0IGFcclxuICAgICAgICAvLyBzZWxlY3Rpb24gKCM2NDUpLlxyXG4gICAgICAgIGlmICgoYnJvd3Nlci5pZSAmJiBicm93c2VyLmllX3ZlcnNpb24gPD0gMTEgfHwgYnJvd3Nlci5hbmRyb2lkICYmIGJyb3dzZXIuY2hyb21lKSAmJiAhdmlldy5zdGF0ZS5zZWxlY3Rpb24ubWFpbi5lbXB0eSAmJlxyXG4gICAgICAgICAgICAvLyAoU2VsZWN0aW9uLmlzQ29sbGFwc2VkIGlzbid0IHJlbGlhYmxlIG9uIElFKVxyXG4gICAgICAgICAgICBzZWwuZm9jdXNOb2RlICYmIGlzRXF1aXZhbGVudFBvc2l0aW9uKHNlbC5mb2N1c05vZGUsIHNlbC5mb2N1c09mZnNldCwgc2VsLmFuY2hvck5vZGUsIHNlbC5hbmNob3JPZmZzZXQpKVxyXG4gICAgICAgICAgICB0aGlzLmZsdXNoU29vbigpO1xyXG4gICAgICAgIGVsc2VcclxuICAgICAgICAgICAgdGhpcy5mbHVzaChmYWxzZSk7XHJcbiAgICB9XHJcbiAgICByZWFkU2VsZWN0aW9uUmFuZ2UoKSB7XHJcbiAgICAgICAgbGV0IHsgdmlldyB9ID0gdGhpcztcclxuICAgICAgICAvLyBUaGUgU2VsZWN0aW9uIG9iamVjdCBpcyBicm9rZW4gaW4gc2hhZG93IHJvb3RzIGluIFNhZmFyaS4gU2VlXHJcbiAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2NvZGVtaXJyb3IvZGV2L2lzc3Vlcy80MTRcclxuICAgICAgICBsZXQgcmFuZ2UgPSBicm93c2VyLnNhZmFyaSAmJiB2aWV3LnJvb3Qubm9kZVR5cGUgPT0gMTEgJiZcclxuICAgICAgICAgICAgZGVlcEFjdGl2ZUVsZW1lbnQodGhpcy5kb20ub3duZXJEb2N1bWVudCkgPT0gdGhpcy5kb20gJiZcclxuICAgICAgICAgICAgc2FmYXJpU2VsZWN0aW9uUmFuZ2VIYWNrKHRoaXMudmlldykgfHwgZ2V0U2VsZWN0aW9uKHZpZXcucm9vdCk7XHJcbiAgICAgICAgaWYgKCFyYW5nZSB8fCB0aGlzLnNlbGVjdGlvblJhbmdlLmVxKHJhbmdlKSlcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIGxldCBsb2NhbCA9IGhhc1NlbGVjdGlvbih0aGlzLmRvbSwgcmFuZ2UpO1xyXG4gICAgICAgIC8vIERldGVjdCB0aGUgc2l0dWF0aW9uIHdoZXJlIHRoZSBicm93c2VyIGhhcywgb24gZm9jdXMsIG1vdmVkIHRoZVxyXG4gICAgICAgIC8vIHNlbGVjdGlvbiB0byB0aGUgc3RhcnQgb2YgdGhlIGNvbnRlbnQgZWxlbWVudC4gUmVzZXQgaXQgdG8gdGhlXHJcbiAgICAgICAgLy8gcG9zaXRpb24gZnJvbSB0aGUgZWRpdG9yIHN0YXRlLlxyXG4gICAgICAgIGlmIChsb2NhbCAmJiAhdGhpcy5zZWxlY3Rpb25DaGFuZ2VkICYmXHJcbiAgICAgICAgICAgIHZpZXcuaW5wdXRTdGF0ZS5sYXN0Rm9jdXNUaW1lID4gRGF0ZS5ub3coKSAtIDIwMCAmJlxyXG4gICAgICAgICAgICB2aWV3LmlucHV0U3RhdGUubGFzdFRvdWNoVGltZSA8IERhdGUubm93KCkgLSAzMDAgJiZcclxuICAgICAgICAgICAgYXRFbGVtZW50U3RhcnQodGhpcy5kb20sIHJhbmdlKSkge1xyXG4gICAgICAgICAgICB0aGlzLnZpZXcuaW5wdXRTdGF0ZS5sYXN0Rm9jdXNUaW1lID0gMDtcclxuICAgICAgICAgICAgdmlldy5kb2NWaWV3LnVwZGF0ZVNlbGVjdGlvbigpO1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuc2VsZWN0aW9uUmFuZ2Uuc2V0UmFuZ2UocmFuZ2UpO1xyXG4gICAgICAgIGlmIChsb2NhbClcclxuICAgICAgICAgICAgdGhpcy5zZWxlY3Rpb25DaGFuZ2VkID0gdHJ1ZTtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICAgIHNldFNlbGVjdGlvblJhbmdlKGFuY2hvciwgaGVhZCkge1xyXG4gICAgICAgIHRoaXMuc2VsZWN0aW9uUmFuZ2Uuc2V0KGFuY2hvci5ub2RlLCBhbmNob3Iub2Zmc2V0LCBoZWFkLm5vZGUsIGhlYWQub2Zmc2V0KTtcclxuICAgICAgICB0aGlzLnNlbGVjdGlvbkNoYW5nZWQgPSBmYWxzZTtcclxuICAgIH1cclxuICAgIGNsZWFyU2VsZWN0aW9uUmFuZ2UoKSB7XHJcbiAgICAgICAgdGhpcy5zZWxlY3Rpb25SYW5nZS5zZXQobnVsbCwgMCwgbnVsbCwgMCk7XHJcbiAgICB9XHJcbiAgICBsaXN0ZW5Gb3JTY3JvbGwoKSB7XHJcbiAgICAgICAgdGhpcy5wYXJlbnRDaGVjayA9IC0xO1xyXG4gICAgICAgIGxldCBpID0gMCwgY2hhbmdlZCA9IG51bGw7XHJcbiAgICAgICAgZm9yIChsZXQgZG9tID0gdGhpcy5kb207IGRvbTspIHtcclxuICAgICAgICAgICAgaWYgKGRvbS5ub2RlVHlwZSA9PSAxKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWNoYW5nZWQgJiYgaSA8IHRoaXMuc2Nyb2xsVGFyZ2V0cy5sZW5ndGggJiYgdGhpcy5zY3JvbGxUYXJnZXRzW2ldID09IGRvbSlcclxuICAgICAgICAgICAgICAgICAgICBpKys7XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmICghY2hhbmdlZClcclxuICAgICAgICAgICAgICAgICAgICBjaGFuZ2VkID0gdGhpcy5zY3JvbGxUYXJnZXRzLnNsaWNlKDAsIGkpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGNoYW5nZWQpXHJcbiAgICAgICAgICAgICAgICAgICAgY2hhbmdlZC5wdXNoKGRvbSk7XHJcbiAgICAgICAgICAgICAgICBkb20gPSBkb20uYXNzaWduZWRTbG90IHx8IGRvbS5wYXJlbnROb2RlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGRvbS5ub2RlVHlwZSA9PSAxMSkgeyAvLyBTaGFkb3cgcm9vdFxyXG4gICAgICAgICAgICAgICAgZG9tID0gZG9tLmhvc3Q7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoaSA8IHRoaXMuc2Nyb2xsVGFyZ2V0cy5sZW5ndGggJiYgIWNoYW5nZWQpXHJcbiAgICAgICAgICAgIGNoYW5nZWQgPSB0aGlzLnNjcm9sbFRhcmdldHMuc2xpY2UoMCwgaSk7XHJcbiAgICAgICAgaWYgKGNoYW5nZWQpIHtcclxuICAgICAgICAgICAgZm9yIChsZXQgZG9tIG9mIHRoaXMuc2Nyb2xsVGFyZ2V0cylcclxuICAgICAgICAgICAgICAgIGRvbS5yZW1vdmVFdmVudExpc3RlbmVyKFwic2Nyb2xsXCIsIHRoaXMub25TY3JvbGwpO1xyXG4gICAgICAgICAgICBmb3IgKGxldCBkb20gb2YgdGhpcy5zY3JvbGxUYXJnZXRzID0gY2hhbmdlZClcclxuICAgICAgICAgICAgICAgIGRvbS5hZGRFdmVudExpc3RlbmVyKFwic2Nyb2xsXCIsIHRoaXMub25TY3JvbGwpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGlnbm9yZShmKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLmFjdGl2ZSlcclxuICAgICAgICAgICAgcmV0dXJuIGYoKTtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICB0aGlzLnN0b3AoKTtcclxuICAgICAgICAgICAgcmV0dXJuIGYoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZmluYWxseSB7XHJcbiAgICAgICAgICAgIHRoaXMuc3RhcnQoKTtcclxuICAgICAgICAgICAgdGhpcy5jbGVhcigpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHN0YXJ0KCkge1xyXG4gICAgICAgIGlmICh0aGlzLmFjdGl2ZSlcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIHRoaXMub2JzZXJ2ZXIub2JzZXJ2ZSh0aGlzLmRvbSwgb2JzZXJ2ZU9wdGlvbnMpO1xyXG4gICAgICAgIGlmICh1c2VDaGFyRGF0YSlcclxuICAgICAgICAgICAgdGhpcy5kb20uYWRkRXZlbnRMaXN0ZW5lcihcIkRPTUNoYXJhY3RlckRhdGFNb2RpZmllZFwiLCB0aGlzLm9uQ2hhckRhdGEpO1xyXG4gICAgICAgIHRoaXMuYWN0aXZlID0gdHJ1ZTtcclxuICAgIH1cclxuICAgIHN0b3AoKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLmFjdGl2ZSlcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIHRoaXMuYWN0aXZlID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5vYnNlcnZlci5kaXNjb25uZWN0KCk7XHJcbiAgICAgICAgaWYgKHVzZUNoYXJEYXRhKVxyXG4gICAgICAgICAgICB0aGlzLmRvbS5yZW1vdmVFdmVudExpc3RlbmVyKFwiRE9NQ2hhcmFjdGVyRGF0YU1vZGlmaWVkXCIsIHRoaXMub25DaGFyRGF0YSk7XHJcbiAgICB9XHJcbiAgICAvLyBUaHJvdyBhd2F5IGFueSBwZW5kaW5nIGNoYW5nZXNcclxuICAgIGNsZWFyKCkge1xyXG4gICAgICAgIHRoaXMucHJvY2Vzc1JlY29yZHMoKTtcclxuICAgICAgICB0aGlzLnF1ZXVlLmxlbmd0aCA9IDA7XHJcbiAgICAgICAgdGhpcy5zZWxlY3Rpb25DaGFuZ2VkID0gZmFsc2U7XHJcbiAgICB9XHJcbiAgICAvLyBDaHJvbWUgQW5kcm9pZCwgZXNwZWNpYWxseSBpbiBjb21iaW5hdGlvbiB3aXRoIEdCb2FyZCwgbm90IG9ubHlcclxuICAgIC8vIGRvZXNuJ3QgcmVsaWFibHkgZmlyZSByZWd1bGFyIGtleSBldmVudHMsIGJ1dCBhbHNvIG9mdGVuXHJcbiAgICAvLyBzdXJyb3VuZHMgdGhlIGVmZmVjdCBvZiBlbnRlciBvciBiYWNrc3BhY2Ugd2l0aCBhIGJ1bmNoIG9mXHJcbiAgICAvLyBjb21wb3NpdGlvbiBldmVudHMgdGhhdCwgd2hlbiBpbnRlcnJ1cHRlZCwgY2F1c2UgdGV4dCBkdXBsaWNhdGlvblxyXG4gICAgLy8gb3Igb3RoZXIga2luZHMgb2YgY29ycnVwdGlvbi4gVGhpcyBoYWNrIG1ha2VzIHRoZSBlZGl0b3IgYmFjayBvZmZcclxuICAgIC8vIGZyb20gaGFuZGxpbmcgRE9NIGNoYW5nZXMgZm9yIGEgbW9tZW50IHdoZW4gc3VjaCBhIGtleSBpc1xyXG4gICAgLy8gZGV0ZWN0ZWQgKHZpYSBiZWZvcmVpbnB1dCBvciBrZXlkb3duKSwgYW5kIHRoZW4gdHJpZXMgdG8gZmx1c2hcclxuICAgIC8vIHRoZW0gb3IsIGlmIHRoYXQgaGFzIG5vIGVmZmVjdCwgZGlzcGF0Y2hlcyB0aGUgZ2l2ZW4ga2V5LlxyXG4gICAgZGVsYXlBbmRyb2lkS2V5KGtleSwga2V5Q29kZSkge1xyXG4gICAgICAgIHZhciBfYTtcclxuICAgICAgICBpZiAoIXRoaXMuZGVsYXllZEFuZHJvaWRLZXkpIHtcclxuICAgICAgICAgICAgbGV0IGZsdXNoID0gKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgbGV0IGtleSA9IHRoaXMuZGVsYXllZEFuZHJvaWRLZXk7XHJcbiAgICAgICAgICAgICAgICBpZiAoa2V5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jbGVhckRlbGF5ZWRBbmRyb2lkS2V5KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLmZsdXNoKCkgJiYga2V5LmZvcmNlKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBkaXNwYXRjaEtleSh0aGlzLmRvbSwga2V5LmtleSwga2V5LmtleUNvZGUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB0aGlzLmZsdXNoaW5nQW5kcm9pZEtleSA9IHRoaXMudmlldy53aW4ucmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZsdXNoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gU2luY2UgYmFja3NwYWNlIGJlZm9yZWlucHV0IGlzIHNvbWV0aW1lcyBzaWduYWxsZWQgc3B1cmlvdXNseSxcclxuICAgICAgICAvLyBFbnRlciBhbHdheXMgdGFrZXMgcHJlY2VkZW5jZS5cclxuICAgICAgICBpZiAoIXRoaXMuZGVsYXllZEFuZHJvaWRLZXkgfHwga2V5ID09IFwiRW50ZXJcIilcclxuICAgICAgICAgICAgdGhpcy5kZWxheWVkQW5kcm9pZEtleSA9IHtcclxuICAgICAgICAgICAgICAgIGtleSwga2V5Q29kZSxcclxuICAgICAgICAgICAgICAgIC8vIE9ubHkgcnVuIHRoZSBrZXkgaGFuZGxlciB3aGVuIG5vIGNoYW5nZXMgYXJlIGRldGVjdGVkIGlmXHJcbiAgICAgICAgICAgICAgICAvLyB0aGlzIGlzbid0IGNvbWluZyByaWdodCBhZnRlciBhbm90aGVyIGNoYW5nZSwgaW4gd2hpY2ggY2FzZVxyXG4gICAgICAgICAgICAgICAgLy8gaXQgaXMgcHJvYmFibHkgcGFydCBvZiBhIHdlaXJkIGNoYWluIG9mIHVwZGF0ZXMsIGFuZCBzaG91bGRcclxuICAgICAgICAgICAgICAgIC8vIGJlIGlnbm9yZWQgaWYgaXQgcmV0dXJucyB0aGUgRE9NIHRvIGl0cyBwcmV2aW91cyBzdGF0ZS5cclxuICAgICAgICAgICAgICAgIGZvcmNlOiB0aGlzLmxhc3RDaGFuZ2UgPCBEYXRlLm5vdygpIC0gNTAgfHwgISEoKF9hID0gdGhpcy5kZWxheWVkQW5kcm9pZEtleSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmZvcmNlKVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgY2xlYXJEZWxheWVkQW5kcm9pZEtleSgpIHtcclxuICAgICAgICB0aGlzLndpbi5jYW5jZWxBbmltYXRpb25GcmFtZSh0aGlzLmZsdXNoaW5nQW5kcm9pZEtleSk7XHJcbiAgICAgICAgdGhpcy5kZWxheWVkQW5kcm9pZEtleSA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5mbHVzaGluZ0FuZHJvaWRLZXkgPSAtMTtcclxuICAgIH1cclxuICAgIGZsdXNoU29vbigpIHtcclxuICAgICAgICBpZiAodGhpcy5kZWxheWVkRmx1c2ggPCAwKVxyXG4gICAgICAgICAgICB0aGlzLmRlbGF5ZWRGbHVzaCA9IHRoaXMudmlldy53aW4ucmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHsgdGhpcy5kZWxheWVkRmx1c2ggPSAtMTsgdGhpcy5mbHVzaCgpOyB9KTtcclxuICAgIH1cclxuICAgIGZvcmNlRmx1c2goKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuZGVsYXllZEZsdXNoID49IDApIHtcclxuICAgICAgICAgICAgdGhpcy52aWV3Lndpbi5jYW5jZWxBbmltYXRpb25GcmFtZSh0aGlzLmRlbGF5ZWRGbHVzaCk7XHJcbiAgICAgICAgICAgIHRoaXMuZGVsYXllZEZsdXNoID0gLTE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuZmx1c2goKTtcclxuICAgIH1cclxuICAgIHByb2Nlc3NSZWNvcmRzKCkge1xyXG4gICAgICAgIGxldCByZWNvcmRzID0gdGhpcy5xdWV1ZTtcclxuICAgICAgICBmb3IgKGxldCBtdXQgb2YgdGhpcy5vYnNlcnZlci50YWtlUmVjb3JkcygpKVxyXG4gICAgICAgICAgICByZWNvcmRzLnB1c2gobXV0KTtcclxuICAgICAgICBpZiAocmVjb3Jkcy5sZW5ndGgpXHJcbiAgICAgICAgICAgIHRoaXMucXVldWUgPSBbXTtcclxuICAgICAgICBsZXQgZnJvbSA9IC0xLCB0byA9IC0xLCB0eXBlT3ZlciA9IGZhbHNlO1xyXG4gICAgICAgIGZvciAobGV0IHJlY29yZCBvZiByZWNvcmRzKSB7XHJcbiAgICAgICAgICAgIGxldCByYW5nZSA9IHRoaXMucmVhZE11dGF0aW9uKHJlY29yZCk7XHJcbiAgICAgICAgICAgIGlmICghcmFuZ2UpXHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgaWYgKHJhbmdlLnR5cGVPdmVyKVxyXG4gICAgICAgICAgICAgICAgdHlwZU92ZXIgPSB0cnVlO1xyXG4gICAgICAgICAgICBpZiAoZnJvbSA9PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgKHsgZnJvbSwgdG8gfSA9IHJhbmdlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGZyb20gPSBNYXRoLm1pbihyYW5nZS5mcm9tLCBmcm9tKTtcclxuICAgICAgICAgICAgICAgIHRvID0gTWF0aC5tYXgocmFuZ2UudG8sIHRvKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4geyBmcm9tLCB0bywgdHlwZU92ZXIgfTtcclxuICAgIH1cclxuICAgIHJlYWRDaGFuZ2UoKSB7XHJcbiAgICAgICAgbGV0IHsgZnJvbSwgdG8sIHR5cGVPdmVyIH0gPSB0aGlzLnByb2Nlc3NSZWNvcmRzKCk7XHJcbiAgICAgICAgbGV0IG5ld1NlbCA9IHRoaXMuc2VsZWN0aW9uQ2hhbmdlZCAmJiBoYXNTZWxlY3Rpb24odGhpcy5kb20sIHRoaXMuc2VsZWN0aW9uUmFuZ2UpO1xyXG4gICAgICAgIGlmIChmcm9tIDwgMCAmJiAhbmV3U2VsKVxyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICBpZiAoZnJvbSA+IC0xKVxyXG4gICAgICAgICAgICB0aGlzLmxhc3RDaGFuZ2UgPSBEYXRlLm5vdygpO1xyXG4gICAgICAgIHRoaXMudmlldy5pbnB1dFN0YXRlLmxhc3RGb2N1c1RpbWUgPSAwO1xyXG4gICAgICAgIHRoaXMuc2VsZWN0aW9uQ2hhbmdlZCA9IGZhbHNlO1xyXG4gICAgICAgIHJldHVybiBuZXcgRE9NQ2hhbmdlKHRoaXMudmlldywgZnJvbSwgdG8sIHR5cGVPdmVyKTtcclxuICAgIH1cclxuICAgIC8vIEFwcGx5IHBlbmRpbmcgY2hhbmdlcywgaWYgYW55XHJcbiAgICBmbHVzaChyZWFkU2VsZWN0aW9uID0gdHJ1ZSkge1xyXG4gICAgICAgIC8vIENvbXBsZXRlbHkgaG9sZCBvZmYgZmx1c2hpbmcgd2hlbiBwZW5kaW5nIGtleXMgYXJlIHNldOKAlHRoZSBjb2RlXHJcbiAgICAgICAgLy8gbWFuYWdpbmcgdGhvc2Ugd2lsbCBtYWtlIHN1cmUgcHJvY2Vzc1JlY29yZHMgaXMgY2FsbGVkIGFuZCB0aGVcclxuICAgICAgICAvLyB2aWV3IGlzIHJlc3luY2hyb25pemVkIGFmdGVyXHJcbiAgICAgICAgaWYgKHRoaXMuZGVsYXllZEZsdXNoID49IDAgfHwgdGhpcy5kZWxheWVkQW5kcm9pZEtleSlcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIGlmIChyZWFkU2VsZWN0aW9uKVxyXG4gICAgICAgICAgICB0aGlzLnJlYWRTZWxlY3Rpb25SYW5nZSgpO1xyXG4gICAgICAgIGxldCBkb21DaGFuZ2UgPSB0aGlzLnJlYWRDaGFuZ2UoKTtcclxuICAgICAgICBpZiAoIWRvbUNoYW5nZSlcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIGxldCBzdGFydFN0YXRlID0gdGhpcy52aWV3LnN0YXRlO1xyXG4gICAgICAgIGxldCBoYW5kbGVkID0gYXBwbHlET01DaGFuZ2UodGhpcy52aWV3LCBkb21DaGFuZ2UpO1xyXG4gICAgICAgIC8vIFRoZSB2aWV3IHdhc24ndCB1cGRhdGVkXHJcbiAgICAgICAgaWYgKHRoaXMudmlldy5zdGF0ZSA9PSBzdGFydFN0YXRlKVxyXG4gICAgICAgICAgICB0aGlzLnZpZXcudXBkYXRlKFtdKTtcclxuICAgICAgICByZXR1cm4gaGFuZGxlZDtcclxuICAgIH1cclxuICAgIHJlYWRNdXRhdGlvbihyZWMpIHtcclxuICAgICAgICBsZXQgY1ZpZXcgPSB0aGlzLnZpZXcuZG9jVmlldy5uZWFyZXN0KHJlYy50YXJnZXQpO1xyXG4gICAgICAgIGlmICghY1ZpZXcgfHwgY1ZpZXcuaWdub3JlTXV0YXRpb24ocmVjKSlcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgY1ZpZXcubWFya0RpcnR5KHJlYy50eXBlID09IFwiYXR0cmlidXRlc1wiKTtcclxuICAgICAgICBpZiAocmVjLnR5cGUgPT0gXCJhdHRyaWJ1dGVzXCIpXHJcbiAgICAgICAgICAgIGNWaWV3LmRpcnR5IHw9IDQgLyogRGlydHkuQXR0cnMgKi87XHJcbiAgICAgICAgaWYgKHJlYy50eXBlID09IFwiY2hpbGRMaXN0XCIpIHtcclxuICAgICAgICAgICAgbGV0IGNoaWxkQmVmb3JlID0gZmluZENoaWxkKGNWaWV3LCByZWMucHJldmlvdXNTaWJsaW5nIHx8IHJlYy50YXJnZXQucHJldmlvdXNTaWJsaW5nLCAtMSk7XHJcbiAgICAgICAgICAgIGxldCBjaGlsZEFmdGVyID0gZmluZENoaWxkKGNWaWV3LCByZWMubmV4dFNpYmxpbmcgfHwgcmVjLnRhcmdldC5uZXh0U2libGluZywgMSk7XHJcbiAgICAgICAgICAgIHJldHVybiB7IGZyb206IGNoaWxkQmVmb3JlID8gY1ZpZXcucG9zQWZ0ZXIoY2hpbGRCZWZvcmUpIDogY1ZpZXcucG9zQXRTdGFydCxcclxuICAgICAgICAgICAgICAgIHRvOiBjaGlsZEFmdGVyID8gY1ZpZXcucG9zQmVmb3JlKGNoaWxkQWZ0ZXIpIDogY1ZpZXcucG9zQXRFbmQsIHR5cGVPdmVyOiBmYWxzZSB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChyZWMudHlwZSA9PSBcImNoYXJhY3RlckRhdGFcIikge1xyXG4gICAgICAgICAgICByZXR1cm4geyBmcm9tOiBjVmlldy5wb3NBdFN0YXJ0LCB0bzogY1ZpZXcucG9zQXRFbmQsIHR5cGVPdmVyOiByZWMudGFyZ2V0Lm5vZGVWYWx1ZSA9PSByZWMub2xkVmFsdWUgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHNldFdpbmRvdyh3aW4pIHtcclxuICAgICAgICBpZiAod2luICE9IHRoaXMud2luKSB7XHJcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlV2luZG93TGlzdGVuZXJzKHRoaXMud2luKTtcclxuICAgICAgICAgICAgdGhpcy53aW4gPSB3aW47XHJcbiAgICAgICAgICAgIHRoaXMuYWRkV2luZG93TGlzdGVuZXJzKHRoaXMud2luKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBhZGRXaW5kb3dMaXN0ZW5lcnMod2luKSB7XHJcbiAgICAgICAgd2luLmFkZEV2ZW50TGlzdGVuZXIoXCJyZXNpemVcIiwgdGhpcy5vblJlc2l6ZSk7XHJcbiAgICAgICAgd2luLmFkZEV2ZW50TGlzdGVuZXIoXCJiZWZvcmVwcmludFwiLCB0aGlzLm9uUHJpbnQpO1xyXG4gICAgICAgIHdpbi5hZGRFdmVudExpc3RlbmVyKFwic2Nyb2xsXCIsIHRoaXMub25TY3JvbGwpO1xyXG4gICAgICAgIHdpbi5kb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwic2VsZWN0aW9uY2hhbmdlXCIsIHRoaXMub25TZWxlY3Rpb25DaGFuZ2UpO1xyXG4gICAgfVxyXG4gICAgcmVtb3ZlV2luZG93TGlzdGVuZXJzKHdpbikge1xyXG4gICAgICAgIHdpbi5yZW1vdmVFdmVudExpc3RlbmVyKFwic2Nyb2xsXCIsIHRoaXMub25TY3JvbGwpO1xyXG4gICAgICAgIHdpbi5yZW1vdmVFdmVudExpc3RlbmVyKFwicmVzaXplXCIsIHRoaXMub25SZXNpemUpO1xyXG4gICAgICAgIHdpbi5yZW1vdmVFdmVudExpc3RlbmVyKFwiYmVmb3JlcHJpbnRcIiwgdGhpcy5vblByaW50KTtcclxuICAgICAgICB3aW4uZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInNlbGVjdGlvbmNoYW5nZVwiLCB0aGlzLm9uU2VsZWN0aW9uQ2hhbmdlKTtcclxuICAgIH1cclxuICAgIGRlc3Ryb3koKSB7XHJcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xyXG4gICAgICAgIHRoaXMuc3RvcCgpO1xyXG4gICAgICAgIChfYSA9IHRoaXMuaW50ZXJzZWN0aW9uKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZGlzY29ubmVjdCgpO1xyXG4gICAgICAgIChfYiA9IHRoaXMuZ2FwSW50ZXJzZWN0aW9uKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuZGlzY29ubmVjdCgpO1xyXG4gICAgICAgIChfYyA9IHRoaXMucmVzaXplU2Nyb2xsKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuZGlzY29ubmVjdCgpO1xyXG4gICAgICAgIChfZCA9IHRoaXMucmVzaXplQ29udGVudCkgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLmRpc2Nvbm5lY3QoKTtcclxuICAgICAgICBmb3IgKGxldCBkb20gb2YgdGhpcy5zY3JvbGxUYXJnZXRzKVxyXG4gICAgICAgICAgICBkb20ucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInNjcm9sbFwiLCB0aGlzLm9uU2Nyb2xsKTtcclxuICAgICAgICB0aGlzLnJlbW92ZVdpbmRvd0xpc3RlbmVycyh0aGlzLndpbik7XHJcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMucGFyZW50Q2hlY2spO1xyXG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnJlc2l6ZVRpbWVvdXQpO1xyXG4gICAgICAgIHRoaXMud2luLmNhbmNlbEFuaW1hdGlvbkZyYW1lKHRoaXMuZGVsYXllZEZsdXNoKTtcclxuICAgICAgICB0aGlzLndpbi5jYW5jZWxBbmltYXRpb25GcmFtZSh0aGlzLmZsdXNoaW5nQW5kcm9pZEtleSk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gZmluZENoaWxkKGNWaWV3LCBkb20sIGRpcikge1xyXG4gICAgd2hpbGUgKGRvbSkge1xyXG4gICAgICAgIGxldCBjdXJWaWV3ID0gQ29udGVudFZpZXcuZ2V0KGRvbSk7XHJcbiAgICAgICAgaWYgKGN1clZpZXcgJiYgY3VyVmlldy5wYXJlbnQgPT0gY1ZpZXcpXHJcbiAgICAgICAgICAgIHJldHVybiBjdXJWaWV3O1xyXG4gICAgICAgIGxldCBwYXJlbnQgPSBkb20ucGFyZW50Tm9kZTtcclxuICAgICAgICBkb20gPSBwYXJlbnQgIT0gY1ZpZXcuZG9tID8gcGFyZW50IDogZGlyID4gMCA/IGRvbS5uZXh0U2libGluZyA6IGRvbS5wcmV2aW91c1NpYmxpbmc7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbnVsbDtcclxufVxyXG4vLyBVc2VkIHRvIHdvcmsgYXJvdW5kIGEgU2FmYXJpIFNlbGVjdGlvbi9zaGFkb3cgRE9NIGJ1ZyAoIzQxNClcclxuZnVuY3Rpb24gc2FmYXJpU2VsZWN0aW9uUmFuZ2VIYWNrKHZpZXcpIHtcclxuICAgIGxldCBmb3VuZCA9IG51bGw7XHJcbiAgICAvLyBCZWNhdXNlIFNhZmFyaSAoYXQgbGVhc3QgaW4gMjAxOC0yMDIxKSBkb2Vzbid0IHByb3ZpZGUgcmVndWxhclxyXG4gICAgLy8gYWNjZXNzIHRvIHRoZSBzZWxlY3Rpb24gaW5zaWRlIGEgc2hhZG93cm9vdCwgd2UgaGF2ZSB0byBwZXJmb3JtIGFcclxuICAgIC8vIHJpZGljdWxvdXMgaGFjayB0byBnZXQgYXQgaXTigJR1c2luZyBgZXhlY0NvbW1hbmRgIHRvIHRyaWdnZXIgYVxyXG4gICAgLy8gYGJlZm9yZUlucHV0YCBldmVudCBzbyB0aGF0IHdlIGNhbiByZWFkIHRoZSB0YXJnZXQgcmFuZ2UgZnJvbSB0aGVcclxuICAgIC8vIGV2ZW50LlxyXG4gICAgZnVuY3Rpb24gcmVhZChldmVudCkge1xyXG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgZXZlbnQuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XHJcbiAgICAgICAgZm91bmQgPSBldmVudC5nZXRUYXJnZXRSYW5nZXMoKVswXTtcclxuICAgIH1cclxuICAgIHZpZXcuY29udGVudERPTS5hZGRFdmVudExpc3RlbmVyKFwiYmVmb3JlaW5wdXRcIiwgcmVhZCwgdHJ1ZSk7XHJcbiAgICB2aWV3LmRvbS5vd25lckRvY3VtZW50LmV4ZWNDb21tYW5kKFwiaW5kZW50XCIpO1xyXG4gICAgdmlldy5jb250ZW50RE9NLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJiZWZvcmVpbnB1dFwiLCByZWFkLCB0cnVlKTtcclxuICAgIGlmICghZm91bmQpXHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICBsZXQgYW5jaG9yTm9kZSA9IGZvdW5kLnN0YXJ0Q29udGFpbmVyLCBhbmNob3JPZmZzZXQgPSBmb3VuZC5zdGFydE9mZnNldDtcclxuICAgIGxldCBmb2N1c05vZGUgPSBmb3VuZC5lbmRDb250YWluZXIsIGZvY3VzT2Zmc2V0ID0gZm91bmQuZW5kT2Zmc2V0O1xyXG4gICAgbGV0IGN1ckFuY2hvciA9IHZpZXcuZG9jVmlldy5kb21BdFBvcyh2aWV3LnN0YXRlLnNlbGVjdGlvbi5tYWluLmFuY2hvcik7XHJcbiAgICAvLyBTaW5jZSBzdWNoIGEgcmFuZ2UgZG9lc24ndCBkaXN0aW5ndWlzaCBiZXR3ZWVuIGFuY2hvciBhbmQgaGVhZCxcclxuICAgIC8vIHVzZSBhIGhldXJpc3RpYyB0aGF0IGZsaXBzIGl0IGFyb3VuZCBpZiBpdHMgZW5kIG1hdGNoZXMgdGhlXHJcbiAgICAvLyBjdXJyZW50IGFuY2hvci5cclxuICAgIGlmIChpc0VxdWl2YWxlbnRQb3NpdGlvbihjdXJBbmNob3Iubm9kZSwgY3VyQW5jaG9yLm9mZnNldCwgZm9jdXNOb2RlLCBmb2N1c09mZnNldCkpXHJcbiAgICAgICAgW2FuY2hvck5vZGUsIGFuY2hvck9mZnNldCwgZm9jdXNOb2RlLCBmb2N1c09mZnNldF0gPSBbZm9jdXNOb2RlLCBmb2N1c09mZnNldCwgYW5jaG9yTm9kZSwgYW5jaG9yT2Zmc2V0XTtcclxuICAgIHJldHVybiB7IGFuY2hvck5vZGUsIGFuY2hvck9mZnNldCwgZm9jdXNOb2RlLCBmb2N1c09mZnNldCB9O1xyXG59XHJcblxyXG4vLyBUaGUgZWRpdG9yJ3MgdXBkYXRlIHN0YXRlIG1hY2hpbmUgbG9va3Mgc29tZXRoaW5nIGxpa2UgdGhpczpcclxuLy9cclxuLy8gICAgIElkbGUg4oaSIFVwZGF0aW5nIOKHhiBJZGxlICh1bmNoZWNrZWQpIOKGkiBNZWFzdXJpbmcg4oaSIElkbGVcclxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIOKGkSAgICAgIOKGk1xyXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgVXBkYXRpbmcgKG1lYXN1cmUpXHJcbi8vXHJcbi8vIFRoZSBkaWZmZXJlbmNlIGJldHdlZW4gJ0lkbGUnIGFuZCAnSWRsZSAodW5jaGVja2VkKScgbGllcyBpblxyXG4vLyB3aGV0aGVyIGEgbGF5b3V0IGNoZWNrIGhhcyBiZWVuIHNjaGVkdWxlZC4gQSByZWd1bGFyIHVwZGF0ZSB0aHJvdWdoXHJcbi8vIHRoZSBgdXBkYXRlYCBtZXRob2QgdXBkYXRlcyB0aGUgRE9NIGluIGEgd3JpdGUtb25seSBmYXNoaW9uLCBhbmRcclxuLy8gcmVsaWVzIG9uIGEgY2hlY2sgKHNjaGVkdWxlZCB3aXRoIGByZXF1ZXN0QW5pbWF0aW9uRnJhbWVgKSB0byBtYWtlXHJcbi8vIHN1cmUgZXZlcnl0aGluZyBpcyB3aGVyZSBpdCBzaG91bGQgYmUgYW5kIHRoZSB2aWV3cG9ydCBjb3ZlcnMgdGhlXHJcbi8vIHZpc2libGUgY29kZS4gVGhhdCBjaGVjayBjb250aW51ZXMgdG8gbWVhc3VyZSBhbmQgdGhlbiBvcHRpb25hbGx5XHJcbi8vIHVwZGF0ZSB1bnRpbCBpdCByZWFjaGVzIGEgY29oZXJlbnQgc3RhdGUuXHJcbi8qKlxyXG5BbiBlZGl0b3IgdmlldyByZXByZXNlbnRzIHRoZSBlZGl0b3IncyB1c2VyIGludGVyZmFjZS4gSXQgaG9sZHNcclxudGhlIGVkaXRhYmxlIERPTSBzdXJmYWNlLCBhbmQgcG9zc2libHkgb3RoZXIgZWxlbWVudHMgc3VjaCBhcyB0aGVcclxubGluZSBudW1iZXIgZ3V0dGVyLiBJdCBoYW5kbGVzIGV2ZW50cyBhbmQgZGlzcGF0Y2hlcyBzdGF0ZVxyXG50cmFuc2FjdGlvbnMgZm9yIGVkaXRpbmcgYWN0aW9ucy5cclxuKi9cclxuY2xhc3MgRWRpdG9yVmlldyB7XHJcbiAgICAvKipcclxuICAgIENvbnN0cnVjdCBhIG5ldyB2aWV3LiBZb3UnbGwgd2FudCB0byBlaXRoZXIgcHJvdmlkZSBhIGBwYXJlbnRgXHJcbiAgICBvcHRpb24sIG9yIHB1dCBgdmlldy5kb21gIGludG8geW91ciBkb2N1bWVudCBhZnRlciBjcmVhdGluZyBhXHJcbiAgICB2aWV3LCBzbyB0aGF0IHRoZSB1c2VyIGNhbiBzZWUgdGhlIGVkaXRvci5cclxuICAgICovXHJcbiAgICBjb25zdHJ1Y3Rvcihjb25maWcgPSB7fSkge1xyXG4gICAgICAgIHRoaXMucGx1Z2lucyA9IFtdO1xyXG4gICAgICAgIHRoaXMucGx1Z2luTWFwID0gbmV3IE1hcDtcclxuICAgICAgICB0aGlzLmVkaXRvckF0dHJzID0ge307XHJcbiAgICAgICAgdGhpcy5jb250ZW50QXR0cnMgPSB7fTtcclxuICAgICAgICB0aGlzLmJpZGlDYWNoZSA9IFtdO1xyXG4gICAgICAgIHRoaXMuZGVzdHJveWVkID0gZmFsc2U7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgQGludGVybmFsXHJcbiAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnVwZGF0ZVN0YXRlID0gMiAvKiBVcGRhdGVTdGF0ZS5VcGRhdGluZyAqLztcclxuICAgICAgICAvKipcclxuICAgICAgICBAaW50ZXJuYWxcclxuICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMubWVhc3VyZVNjaGVkdWxlZCA9IC0xO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgIEBpbnRlcm5hbFxyXG4gICAgICAgICovXHJcbiAgICAgICAgdGhpcy5tZWFzdXJlUmVxdWVzdHMgPSBbXTtcclxuICAgICAgICB0aGlzLmNvbnRlbnRET00gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xyXG4gICAgICAgIHRoaXMuc2Nyb2xsRE9NID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcclxuICAgICAgICB0aGlzLnNjcm9sbERPTS50YWJJbmRleCA9IC0xO1xyXG4gICAgICAgIHRoaXMuc2Nyb2xsRE9NLmNsYXNzTmFtZSA9IFwiY20tc2Nyb2xsZXJcIjtcclxuICAgICAgICB0aGlzLnNjcm9sbERPTS5hcHBlbmRDaGlsZCh0aGlzLmNvbnRlbnRET00pO1xyXG4gICAgICAgIHRoaXMuYW5ub3VuY2VET00gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xyXG4gICAgICAgIHRoaXMuYW5ub3VuY2VET00uc3R5bGUuY3NzVGV4dCA9IFwicG9zaXRpb246IGZpeGVkOyB0b3A6IC0xMDAwMHB4XCI7XHJcbiAgICAgICAgdGhpcy5hbm5vdW5jZURPTS5zZXRBdHRyaWJ1dGUoXCJhcmlhLWxpdmVcIiwgXCJwb2xpdGVcIik7XHJcbiAgICAgICAgdGhpcy5kb20gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xyXG4gICAgICAgIHRoaXMuZG9tLmFwcGVuZENoaWxkKHRoaXMuYW5ub3VuY2VET00pO1xyXG4gICAgICAgIHRoaXMuZG9tLmFwcGVuZENoaWxkKHRoaXMuc2Nyb2xsRE9NKTtcclxuICAgICAgICB0aGlzLl9kaXNwYXRjaCA9IGNvbmZpZy5kaXNwYXRjaCB8fCAoKHRyKSA9PiB0aGlzLnVwZGF0ZShbdHJdKSk7XHJcbiAgICAgICAgdGhpcy5kaXNwYXRjaCA9IHRoaXMuZGlzcGF0Y2guYmluZCh0aGlzKTtcclxuICAgICAgICB0aGlzLl9yb290ID0gKGNvbmZpZy5yb290IHx8IGdldFJvb3QoY29uZmlnLnBhcmVudCkgfHwgZG9jdW1lbnQpO1xyXG4gICAgICAgIHRoaXMudmlld1N0YXRlID0gbmV3IFZpZXdTdGF0ZShjb25maWcuc3RhdGUgfHwgRWRpdG9yU3RhdGUuY3JlYXRlKGNvbmZpZykpO1xyXG4gICAgICAgIHRoaXMucGx1Z2lucyA9IHRoaXMuc3RhdGUuZmFjZXQodmlld1BsdWdpbikubWFwKHNwZWMgPT4gbmV3IFBsdWdpbkluc3RhbmNlKHNwZWMpKTtcclxuICAgICAgICBmb3IgKGxldCBwbHVnaW4gb2YgdGhpcy5wbHVnaW5zKVxyXG4gICAgICAgICAgICBwbHVnaW4udXBkYXRlKHRoaXMpO1xyXG4gICAgICAgIHRoaXMub2JzZXJ2ZXIgPSBuZXcgRE9NT2JzZXJ2ZXIodGhpcyk7XHJcbiAgICAgICAgdGhpcy5pbnB1dFN0YXRlID0gbmV3IElucHV0U3RhdGUodGhpcyk7XHJcbiAgICAgICAgdGhpcy5pbnB1dFN0YXRlLmVuc3VyZUhhbmRsZXJzKHRoaXMsIHRoaXMucGx1Z2lucyk7XHJcbiAgICAgICAgdGhpcy5kb2NWaWV3ID0gbmV3IERvY1ZpZXcodGhpcyk7XHJcbiAgICAgICAgdGhpcy5tb3VudFN0eWxlcygpO1xyXG4gICAgICAgIHRoaXMudXBkYXRlQXR0cnMoKTtcclxuICAgICAgICB0aGlzLnVwZGF0ZVN0YXRlID0gMCAvKiBVcGRhdGVTdGF0ZS5JZGxlICovO1xyXG4gICAgICAgIHRoaXMucmVxdWVzdE1lYXN1cmUoKTtcclxuICAgICAgICBpZiAoY29uZmlnLnBhcmVudClcclxuICAgICAgICAgICAgY29uZmlnLnBhcmVudC5hcHBlbmRDaGlsZCh0aGlzLmRvbSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgIFRoZSBjdXJyZW50IGVkaXRvciBzdGF0ZS5cclxuICAgICovXHJcbiAgICBnZXQgc3RhdGUoKSB7IHJldHVybiB0aGlzLnZpZXdTdGF0ZS5zdGF0ZTsgfVxyXG4gICAgLyoqXHJcbiAgICBUbyBiZSBhYmxlIHRvIGRpc3BsYXkgbGFyZ2UgZG9jdW1lbnRzIHdpdGhvdXQgY29uc3VtaW5nIHRvbyBtdWNoXHJcbiAgICBtZW1vcnkgb3Igb3ZlcmxvYWRpbmcgdGhlIGJyb3dzZXIsIENvZGVNaXJyb3Igb25seSBkcmF3cyB0aGVcclxuICAgIGNvZGUgdGhhdCBpcyB2aXNpYmxlIChwbHVzIGEgbWFyZ2luIGFyb3VuZCBpdCkgdG8gdGhlIERPTS4gVGhpc1xyXG4gICAgcHJvcGVydHkgdGVsbHMgeW91IHRoZSBleHRlbnQgb2YgdGhlIGN1cnJlbnQgZHJhd24gdmlld3BvcnQsIGluXHJcbiAgICBkb2N1bWVudCBwb3NpdGlvbnMuXHJcbiAgICAqL1xyXG4gICAgZ2V0IHZpZXdwb3J0KCkgeyByZXR1cm4gdGhpcy52aWV3U3RhdGUudmlld3BvcnQ7IH1cclxuICAgIC8qKlxyXG4gICAgV2hlbiB0aGVyZSBhcmUsIGZvciBleGFtcGxlLCBsYXJnZSBjb2xsYXBzZWQgcmFuZ2VzIGluIHRoZVxyXG4gICAgdmlld3BvcnQsIGl0cyBzaXplIGNhbiBiZSBhIGxvdCBiaWdnZXIgdGhhbiB0aGUgYWN0dWFsIHZpc2libGVcclxuICAgIGNvbnRlbnQuIFRodXMsIGlmIHlvdSBhcmUgZG9pbmcgc29tZXRoaW5nIGxpa2Ugc3R5bGluZyB0aGVcclxuICAgIGNvbnRlbnQgaW4gdGhlIHZpZXdwb3J0LCBpdCBpcyBwcmVmZXJhYmxlIHRvIG9ubHkgZG8gc28gZm9yXHJcbiAgICB0aGVzZSByYW5nZXMsIHdoaWNoIGFyZSB0aGUgc3Vic2V0IG9mIHRoZSB2aWV3cG9ydCB0aGF0IGlzXHJcbiAgICBhY3R1YWxseSBkcmF3bi5cclxuICAgICovXHJcbiAgICBnZXQgdmlzaWJsZVJhbmdlcygpIHsgcmV0dXJuIHRoaXMudmlld1N0YXRlLnZpc2libGVSYW5nZXM7IH1cclxuICAgIC8qKlxyXG4gICAgUmV0dXJucyBmYWxzZSB3aGVuIHRoZSBlZGl0b3IgaXMgZW50aXJlbHkgc2Nyb2xsZWQgb3V0IG9mIHZpZXdcclxuICAgIG9yIG90aGVyd2lzZSBoaWRkZW4uXHJcbiAgICAqL1xyXG4gICAgZ2V0IGluVmlldygpIHsgcmV0dXJuIHRoaXMudmlld1N0YXRlLmluVmlldzsgfVxyXG4gICAgLyoqXHJcbiAgICBJbmRpY2F0ZXMgd2hldGhlciB0aGUgdXNlciBpcyBjdXJyZW50bHkgY29tcG9zaW5nIHRleHQgdmlhXHJcbiAgICBbSU1FXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9JbnB1dF9tZXRob2QpLCBhbmQgYXQgbGVhc3RcclxuICAgIG9uZSBjaGFuZ2UgaGFzIGJlZW4gbWFkZSBpbiB0aGUgY3VycmVudCBjb21wb3NpdGlvbi5cclxuICAgICovXHJcbiAgICBnZXQgY29tcG9zaW5nKCkgeyByZXR1cm4gdGhpcy5pbnB1dFN0YXRlLmNvbXBvc2luZyA+IDA7IH1cclxuICAgIC8qKlxyXG4gICAgSW5kaWNhdGVzIHdoZXRoZXIgdGhlIHVzZXIgaXMgY3VycmVudGx5IGluIGNvbXBvc2luZyBzdGF0ZS4gTm90ZVxyXG4gICAgdGhhdCBvbiBzb21lIHBsYXRmb3JtcywgbGlrZSBBbmRyb2lkLCB0aGlzIHdpbGwgYmUgdGhlIGNhc2UgYVxyXG4gICAgbG90LCBzaW5jZSBqdXN0IHB1dHRpbmcgdGhlIGN1cnNvciBvbiBhIHdvcmQgc3RhcnRzIGFcclxuICAgIGNvbXBvc2l0aW9uIHRoZXJlLlxyXG4gICAgKi9cclxuICAgIGdldCBjb21wb3NpdGlvblN0YXJ0ZWQoKSB7IHJldHVybiB0aGlzLmlucHV0U3RhdGUuY29tcG9zaW5nID49IDA7IH1cclxuICAgIC8qKlxyXG4gICAgVGhlIGRvY3VtZW50IG9yIHNoYWRvdyByb290IHRoYXQgdGhlIHZpZXcgbGl2ZXMgaW4uXHJcbiAgICAqL1xyXG4gICAgZ2V0IHJvb3QoKSB7IHJldHVybiB0aGlzLl9yb290OyB9XHJcbiAgICAvKipcclxuICAgIEBpbnRlcm5hbFxyXG4gICAgKi9cclxuICAgIGdldCB3aW4oKSB7IHJldHVybiB0aGlzLmRvbS5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3IHx8IHdpbmRvdzsgfVxyXG4gICAgZGlzcGF0Y2goLi4uaW5wdXQpIHtcclxuICAgICAgICB0aGlzLl9kaXNwYXRjaChpbnB1dC5sZW5ndGggPT0gMSAmJiBpbnB1dFswXSBpbnN0YW5jZW9mIFRyYW5zYWN0aW9uID8gaW5wdXRbMF1cclxuICAgICAgICAgICAgOiB0aGlzLnN0YXRlLnVwZGF0ZSguLi5pbnB1dCkpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICBVcGRhdGUgdGhlIHZpZXcgZm9yIHRoZSBnaXZlbiBhcnJheSBvZiB0cmFuc2FjdGlvbnMuIFRoaXMgd2lsbFxyXG4gICAgdXBkYXRlIHRoZSB2aXNpYmxlIGRvY3VtZW50IGFuZCBzZWxlY3Rpb24gdG8gbWF0Y2ggdGhlIHN0YXRlXHJcbiAgICBwcm9kdWNlZCBieSB0aGUgdHJhbnNhY3Rpb25zLCBhbmQgbm90aWZ5IHZpZXcgcGx1Z2lucyBvZiB0aGVcclxuICAgIGNoYW5nZS4gWW91IHNob3VsZCB1c3VhbGx5IGNhbGxcclxuICAgIFtgZGlzcGF0Y2hgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuRWRpdG9yVmlldy5kaXNwYXRjaCkgaW5zdGVhZCwgd2hpY2ggdXNlcyB0aGlzXHJcbiAgICBhcyBhIHByaW1pdGl2ZS5cclxuICAgICovXHJcbiAgICB1cGRhdGUodHJhbnNhY3Rpb25zKSB7XHJcbiAgICAgICAgaWYgKHRoaXMudXBkYXRlU3RhdGUgIT0gMCAvKiBVcGRhdGVTdGF0ZS5JZGxlICovKVxyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYWxscyB0byBFZGl0b3JWaWV3LnVwZGF0ZSBhcmUgbm90IGFsbG93ZWQgd2hpbGUgYW4gdXBkYXRlIGlzIGluIHByb2dyZXNzXCIpO1xyXG4gICAgICAgIGxldCByZWRyYXduID0gZmFsc2UsIGF0dHJzQ2hhbmdlZCA9IGZhbHNlLCB1cGRhdGU7XHJcbiAgICAgICAgbGV0IHN0YXRlID0gdGhpcy5zdGF0ZTtcclxuICAgICAgICBmb3IgKGxldCB0ciBvZiB0cmFuc2FjdGlvbnMpIHtcclxuICAgICAgICAgICAgaWYgKHRyLnN0YXJ0U3RhdGUgIT0gc3RhdGUpXHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIlRyeWluZyB0byB1cGRhdGUgc3RhdGUgd2l0aCBhIHRyYW5zYWN0aW9uIHRoYXQgZG9lc24ndCBzdGFydCBmcm9tIHRoZSBwcmV2aW91cyBzdGF0ZS5cIik7XHJcbiAgICAgICAgICAgIHN0YXRlID0gdHIuc3RhdGU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLmRlc3Ryb3llZCkge1xyXG4gICAgICAgICAgICB0aGlzLnZpZXdTdGF0ZS5zdGF0ZSA9IHN0YXRlO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIElmIHRoZXJlIHdhcyBhIHBlbmRpbmcgRE9NIGNoYW5nZSwgZWFnZXJseSByZWFkIGl0IGFuZCB0cnkgdG9cclxuICAgICAgICAvLyBhcHBseSBpdCBhZnRlciB0aGUgZ2l2ZW4gdHJhbnNhY3Rpb25zLlxyXG4gICAgICAgIGxldCBwZW5kaW5nS2V5ID0gdGhpcy5vYnNlcnZlci5kZWxheWVkQW5kcm9pZEtleSwgZG9tQ2hhbmdlID0gbnVsbDtcclxuICAgICAgICBpZiAocGVuZGluZ0tleSkge1xyXG4gICAgICAgICAgICB0aGlzLm9ic2VydmVyLmNsZWFyRGVsYXllZEFuZHJvaWRLZXkoKTtcclxuICAgICAgICAgICAgZG9tQ2hhbmdlID0gdGhpcy5vYnNlcnZlci5yZWFkQ2hhbmdlKCk7XHJcbiAgICAgICAgICAgIC8vIE9ubHkgdHJ5IHRvIGFwcGx5IERPTSBjaGFuZ2VzIGlmIHRoZSB0cmFuc2FjdGlvbnMgZGlkbid0XHJcbiAgICAgICAgICAgIC8vIGNoYW5nZSB0aGUgZG9jIG9yIHNlbGVjdGlvbi5cclxuICAgICAgICAgICAgaWYgKGRvbUNoYW5nZSAmJiAhdGhpcy5zdGF0ZS5kb2MuZXEoc3RhdGUuZG9jKSB8fCAhdGhpcy5zdGF0ZS5zZWxlY3Rpb24uZXEoc3RhdGUuc2VsZWN0aW9uKSlcclxuICAgICAgICAgICAgICAgIGRvbUNoYW5nZSA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLm9ic2VydmVyLmNsZWFyKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFdoZW4gdGhlIHBocmFzZXMgY2hhbmdlLCByZWRyYXcgdGhlIGVkaXRvclxyXG4gICAgICAgIGlmIChzdGF0ZS5mYWNldChFZGl0b3JTdGF0ZS5waHJhc2VzKSAhPSB0aGlzLnN0YXRlLmZhY2V0KEVkaXRvclN0YXRlLnBocmFzZXMpKVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zZXRTdGF0ZShzdGF0ZSk7XHJcbiAgICAgICAgdXBkYXRlID0gVmlld1VwZGF0ZS5jcmVhdGUodGhpcywgc3RhdGUsIHRyYW5zYWN0aW9ucyk7XHJcbiAgICAgICAgbGV0IHNjcm9sbFRhcmdldCA9IHRoaXMudmlld1N0YXRlLnNjcm9sbFRhcmdldDtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVN0YXRlID0gMiAvKiBVcGRhdGVTdGF0ZS5VcGRhdGluZyAqLztcclxuICAgICAgICAgICAgZm9yIChsZXQgdHIgb2YgdHJhbnNhY3Rpb25zKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoc2Nyb2xsVGFyZ2V0KVxyXG4gICAgICAgICAgICAgICAgICAgIHNjcm9sbFRhcmdldCA9IHNjcm9sbFRhcmdldC5tYXAodHIuY2hhbmdlcyk7XHJcbiAgICAgICAgICAgICAgICBpZiAodHIuc2Nyb2xsSW50b1ZpZXcpIHtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgeyBtYWluIH0gPSB0ci5zdGF0ZS5zZWxlY3Rpb247XHJcbiAgICAgICAgICAgICAgICAgICAgc2Nyb2xsVGFyZ2V0ID0gbmV3IFNjcm9sbFRhcmdldChtYWluLmVtcHR5ID8gbWFpbiA6IEVkaXRvclNlbGVjdGlvbi5jdXJzb3IobWFpbi5oZWFkLCBtYWluLmhlYWQgPiBtYWluLmFuY2hvciA/IC0xIDogMSkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgZSBvZiB0ci5lZmZlY3RzKVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChlLmlzKHNjcm9sbEludG9WaWV3KSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2Nyb2xsVGFyZ2V0ID0gZS52YWx1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLnZpZXdTdGF0ZS51cGRhdGUodXBkYXRlLCBzY3JvbGxUYXJnZXQpO1xyXG4gICAgICAgICAgICB0aGlzLmJpZGlDYWNoZSA9IENhY2hlZE9yZGVyLnVwZGF0ZSh0aGlzLmJpZGlDYWNoZSwgdXBkYXRlLmNoYW5nZXMpO1xyXG4gICAgICAgICAgICBpZiAoIXVwZGF0ZS5lbXB0eSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVQbHVnaW5zKHVwZGF0ZSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmlucHV0U3RhdGUudXBkYXRlKHVwZGF0ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmVkcmF3biA9IHRoaXMuZG9jVmlldy51cGRhdGUodXBkYXRlKTtcclxuICAgICAgICAgICAgaWYgKHRoaXMuc3RhdGUuZmFjZXQoc3R5bGVNb2R1bGUpICE9IHRoaXMuc3R5bGVNb2R1bGVzKVxyXG4gICAgICAgICAgICAgICAgdGhpcy5tb3VudFN0eWxlcygpO1xyXG4gICAgICAgICAgICBhdHRyc0NoYW5nZWQgPSB0aGlzLnVwZGF0ZUF0dHJzKCk7XHJcbiAgICAgICAgICAgIHRoaXMuc2hvd0Fubm91bmNlbWVudHModHJhbnNhY3Rpb25zKTtcclxuICAgICAgICAgICAgdGhpcy5kb2NWaWV3LnVwZGF0ZVNlbGVjdGlvbihyZWRyYXduLCB0cmFuc2FjdGlvbnMuc29tZSh0ciA9PiB0ci5pc1VzZXJFdmVudChcInNlbGVjdC5wb2ludGVyXCIpKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZpbmFsbHkge1xyXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVN0YXRlID0gMCAvKiBVcGRhdGVTdGF0ZS5JZGxlICovO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodXBkYXRlLnN0YXJ0U3RhdGUuZmFjZXQodGhlbWUpICE9IHVwZGF0ZS5zdGF0ZS5mYWNldCh0aGVtZSkpXHJcbiAgICAgICAgICAgIHRoaXMudmlld1N0YXRlLm11c3RNZWFzdXJlQ29udGVudCA9IHRydWU7XHJcbiAgICAgICAgaWYgKHJlZHJhd24gfHwgYXR0cnNDaGFuZ2VkIHx8IHNjcm9sbFRhcmdldCB8fCB0aGlzLnZpZXdTdGF0ZS5tdXN0RW5mb3JjZUN1cnNvckFzc29jIHx8IHRoaXMudmlld1N0YXRlLm11c3RNZWFzdXJlQ29udGVudClcclxuICAgICAgICAgICAgdGhpcy5yZXF1ZXN0TWVhc3VyZSgpO1xyXG4gICAgICAgIGlmICghdXBkYXRlLmVtcHR5KVxyXG4gICAgICAgICAgICBmb3IgKGxldCBsaXN0ZW5lciBvZiB0aGlzLnN0YXRlLmZhY2V0KHVwZGF0ZUxpc3RlbmVyKSlcclxuICAgICAgICAgICAgICAgIGxpc3RlbmVyKHVwZGF0ZSk7XHJcbiAgICAgICAgaWYgKGRvbUNoYW5nZSkge1xyXG4gICAgICAgICAgICBpZiAoIWFwcGx5RE9NQ2hhbmdlKHRoaXMsIGRvbUNoYW5nZSkgJiYgcGVuZGluZ0tleS5mb3JjZSlcclxuICAgICAgICAgICAgICAgIGRpc3BhdGNoS2V5KHRoaXMuY29udGVudERPTSwgcGVuZGluZ0tleS5rZXksIHBlbmRpbmdLZXkua2V5Q29kZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICBSZXNldCB0aGUgdmlldyB0byB0aGUgZ2l2ZW4gc3RhdGUuIChUaGlzIHdpbGwgY2F1c2UgdGhlIGVudGlyZVxyXG4gICAgZG9jdW1lbnQgdG8gYmUgcmVkcmF3biBhbmQgYWxsIHZpZXcgcGx1Z2lucyB0byBiZSByZWluaXRpYWxpemVkLFxyXG4gICAgc28geW91IHNob3VsZCBwcm9iYWJseSBvbmx5IHVzZSBpdCB3aGVuIHRoZSBuZXcgc3RhdGUgaXNuJ3RcclxuICAgIGRlcml2ZWQgZnJvbSB0aGUgb2xkIHN0YXRlLiBPdGhlcndpc2UsIHVzZVxyXG4gICAgW2BkaXNwYXRjaGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5FZGl0b3JWaWV3LmRpc3BhdGNoKSBpbnN0ZWFkLilcclxuICAgICovXHJcbiAgICBzZXRTdGF0ZShuZXdTdGF0ZSkge1xyXG4gICAgICAgIGlmICh0aGlzLnVwZGF0ZVN0YXRlICE9IDAgLyogVXBkYXRlU3RhdGUuSWRsZSAqLylcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2FsbHMgdG8gRWRpdG9yVmlldy5zZXRTdGF0ZSBhcmUgbm90IGFsbG93ZWQgd2hpbGUgYW4gdXBkYXRlIGlzIGluIHByb2dyZXNzXCIpO1xyXG4gICAgICAgIGlmICh0aGlzLmRlc3Ryb3llZCkge1xyXG4gICAgICAgICAgICB0aGlzLnZpZXdTdGF0ZS5zdGF0ZSA9IG5ld1N0YXRlO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMudXBkYXRlU3RhdGUgPSAyIC8qIFVwZGF0ZVN0YXRlLlVwZGF0aW5nICovO1xyXG4gICAgICAgIGxldCBoYWRGb2N1cyA9IHRoaXMuaGFzRm9jdXM7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgZm9yIChsZXQgcGx1Z2luIG9mIHRoaXMucGx1Z2lucylcclxuICAgICAgICAgICAgICAgIHBsdWdpbi5kZXN0cm95KHRoaXMpO1xyXG4gICAgICAgICAgICB0aGlzLnZpZXdTdGF0ZSA9IG5ldyBWaWV3U3RhdGUobmV3U3RhdGUpO1xyXG4gICAgICAgICAgICB0aGlzLnBsdWdpbnMgPSBuZXdTdGF0ZS5mYWNldCh2aWV3UGx1Z2luKS5tYXAoc3BlYyA9PiBuZXcgUGx1Z2luSW5zdGFuY2Uoc3BlYykpO1xyXG4gICAgICAgICAgICB0aGlzLnBsdWdpbk1hcC5jbGVhcigpO1xyXG4gICAgICAgICAgICBmb3IgKGxldCBwbHVnaW4gb2YgdGhpcy5wbHVnaW5zKVxyXG4gICAgICAgICAgICAgICAgcGx1Z2luLnVwZGF0ZSh0aGlzKTtcclxuICAgICAgICAgICAgdGhpcy5kb2NWaWV3ID0gbmV3IERvY1ZpZXcodGhpcyk7XHJcbiAgICAgICAgICAgIHRoaXMuaW5wdXRTdGF0ZS5lbnN1cmVIYW5kbGVycyh0aGlzLCB0aGlzLnBsdWdpbnMpO1xyXG4gICAgICAgICAgICB0aGlzLm1vdW50U3R5bGVzKCk7XHJcbiAgICAgICAgICAgIHRoaXMudXBkYXRlQXR0cnMoKTtcclxuICAgICAgICAgICAgdGhpcy5iaWRpQ2FjaGUgPSBbXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZmluYWxseSB7XHJcbiAgICAgICAgICAgIHRoaXMudXBkYXRlU3RhdGUgPSAwIC8qIFVwZGF0ZVN0YXRlLklkbGUgKi87XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChoYWRGb2N1cylcclxuICAgICAgICAgICAgdGhpcy5mb2N1cygpO1xyXG4gICAgICAgIHRoaXMucmVxdWVzdE1lYXN1cmUoKTtcclxuICAgIH1cclxuICAgIHVwZGF0ZVBsdWdpbnModXBkYXRlKSB7XHJcbiAgICAgICAgbGV0IHByZXZTcGVjcyA9IHVwZGF0ZS5zdGFydFN0YXRlLmZhY2V0KHZpZXdQbHVnaW4pLCBzcGVjcyA9IHVwZGF0ZS5zdGF0ZS5mYWNldCh2aWV3UGx1Z2luKTtcclxuICAgICAgICBpZiAocHJldlNwZWNzICE9IHNwZWNzKSB7XHJcbiAgICAgICAgICAgIGxldCBuZXdQbHVnaW5zID0gW107XHJcbiAgICAgICAgICAgIGZvciAobGV0IHNwZWMgb2Ygc3BlY3MpIHtcclxuICAgICAgICAgICAgICAgIGxldCBmb3VuZCA9IHByZXZTcGVjcy5pbmRleE9mKHNwZWMpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGZvdW5kIDwgMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIG5ld1BsdWdpbnMucHVzaChuZXcgUGx1Z2luSW5zdGFuY2Uoc3BlYykpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IHBsdWdpbiA9IHRoaXMucGx1Z2luc1tmb3VuZF07XHJcbiAgICAgICAgICAgICAgICAgICAgcGx1Z2luLm11c3RVcGRhdGUgPSB1cGRhdGU7XHJcbiAgICAgICAgICAgICAgICAgICAgbmV3UGx1Z2lucy5wdXNoKHBsdWdpbik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZm9yIChsZXQgcGx1Z2luIG9mIHRoaXMucGx1Z2lucylcclxuICAgICAgICAgICAgICAgIGlmIChwbHVnaW4ubXVzdFVwZGF0ZSAhPSB1cGRhdGUpXHJcbiAgICAgICAgICAgICAgICAgICAgcGx1Z2luLmRlc3Ryb3kodGhpcyk7XHJcbiAgICAgICAgICAgIHRoaXMucGx1Z2lucyA9IG5ld1BsdWdpbnM7XHJcbiAgICAgICAgICAgIHRoaXMucGx1Z2luTWFwLmNsZWFyKCk7XHJcbiAgICAgICAgICAgIHRoaXMuaW5wdXRTdGF0ZS5lbnN1cmVIYW5kbGVycyh0aGlzLCB0aGlzLnBsdWdpbnMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgZm9yIChsZXQgcCBvZiB0aGlzLnBsdWdpbnMpXHJcbiAgICAgICAgICAgICAgICBwLm11c3RVcGRhdGUgPSB1cGRhdGU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5wbHVnaW5zLmxlbmd0aDsgaSsrKVxyXG4gICAgICAgICAgICB0aGlzLnBsdWdpbnNbaV0udXBkYXRlKHRoaXMpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICBAaW50ZXJuYWxcclxuICAgICovXHJcbiAgICBtZWFzdXJlKGZsdXNoID0gdHJ1ZSkge1xyXG4gICAgICAgIGlmICh0aGlzLmRlc3Ryb3llZClcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIGlmICh0aGlzLm1lYXN1cmVTY2hlZHVsZWQgPiAtMSlcclxuICAgICAgICAgICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUodGhpcy5tZWFzdXJlU2NoZWR1bGVkKTtcclxuICAgICAgICB0aGlzLm1lYXN1cmVTY2hlZHVsZWQgPSAwOyAvLyBQcmV2ZW50IHJlcXVlc3RNZWFzdXJlIGNhbGxzIGZyb20gc2NoZWR1bGluZyBhbm90aGVyIGFuaW1hdGlvbiBmcmFtZVxyXG4gICAgICAgIGlmIChmbHVzaClcclxuICAgICAgICAgICAgdGhpcy5vYnNlcnZlci5mb3JjZUZsdXNoKCk7XHJcbiAgICAgICAgbGV0IHVwZGF0ZWQgPSBudWxsO1xyXG4gICAgICAgIGxldCB7IHNjcm9sbEhlaWdodCwgc2Nyb2xsVG9wLCBjbGllbnRIZWlnaHQgfSA9IHRoaXMuc2Nyb2xsRE9NO1xyXG4gICAgICAgIGxldCByZWZIZWlnaHQgPSBzY3JvbGxUb3AgPiBzY3JvbGxIZWlnaHQgLSBjbGllbnRIZWlnaHQgLSA0ID8gc2Nyb2xsSGVpZ2h0IDogc2Nyb2xsVG9wO1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOzsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZVN0YXRlID0gMSAvKiBVcGRhdGVTdGF0ZS5NZWFzdXJpbmcgKi87XHJcbiAgICAgICAgICAgICAgICBsZXQgb2xkVmlld3BvcnQgPSB0aGlzLnZpZXdwb3J0O1xyXG4gICAgICAgICAgICAgICAgbGV0IHJlZkJsb2NrID0gdGhpcy52aWV3U3RhdGUubGluZUJsb2NrQXRIZWlnaHQocmVmSGVpZ2h0KTtcclxuICAgICAgICAgICAgICAgIGxldCBjaGFuZ2VkID0gdGhpcy52aWV3U3RhdGUubWVhc3VyZSh0aGlzKTtcclxuICAgICAgICAgICAgICAgIGlmICghY2hhbmdlZCAmJiAhdGhpcy5tZWFzdXJlUmVxdWVzdHMubGVuZ3RoICYmIHRoaXMudmlld1N0YXRlLnNjcm9sbFRhcmdldCA9PSBudWxsKVxyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgaWYgKGkgPiA1KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKHRoaXMubWVhc3VyZVJlcXVlc3RzLmxlbmd0aFxyXG4gICAgICAgICAgICAgICAgICAgICAgICA/IFwiTWVhc3VyZSBsb29wIHJlc3RhcnRlZCBtb3JlIHRoYW4gNSB0aW1lc1wiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDogXCJWaWV3cG9ydCBmYWlsZWQgdG8gc3RhYmlsaXplXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgbGV0IG1lYXN1cmluZyA9IFtdO1xyXG4gICAgICAgICAgICAgICAgLy8gT25seSBydW4gbWVhc3VyZSByZXF1ZXN0cyBpbiB0aGlzIGN5Y2xlIHdoZW4gdGhlIHZpZXdwb3J0IGRpZG4ndCBjaGFuZ2VcclxuICAgICAgICAgICAgICAgIGlmICghKGNoYW5nZWQgJiA0IC8qIFVwZGF0ZUZsYWcuVmlld3BvcnQgKi8pKVxyXG4gICAgICAgICAgICAgICAgICAgIFt0aGlzLm1lYXN1cmVSZXF1ZXN0cywgbWVhc3VyaW5nXSA9IFttZWFzdXJpbmcsIHRoaXMubWVhc3VyZVJlcXVlc3RzXTtcclxuICAgICAgICAgICAgICAgIGxldCBtZWFzdXJlZCA9IG1lYXN1cmluZy5tYXAobSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG0ucmVhZCh0aGlzKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbG9nRXhjZXB0aW9uKHRoaXMuc3RhdGUsIGUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gQmFkTWVhc3VyZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIGxldCB1cGRhdGUgPSBWaWV3VXBkYXRlLmNyZWF0ZSh0aGlzLCB0aGlzLnN0YXRlLCBbXSksIHJlZHJhd24gPSBmYWxzZSwgc2Nyb2xsZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIHVwZGF0ZS5mbGFncyB8PSBjaGFuZ2VkO1xyXG4gICAgICAgICAgICAgICAgaWYgKCF1cGRhdGVkKVxyXG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZWQgPSB1cGRhdGU7XHJcbiAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlZC5mbGFncyB8PSBjaGFuZ2VkO1xyXG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVTdGF0ZSA9IDIgLyogVXBkYXRlU3RhdGUuVXBkYXRpbmcgKi87XHJcbiAgICAgICAgICAgICAgICBpZiAoIXVwZGF0ZS5lbXB0eSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlUGx1Z2lucyh1cGRhdGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaW5wdXRTdGF0ZS51cGRhdGUodXBkYXRlKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZUF0dHJzKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVkcmF3biA9IHRoaXMuZG9jVmlldy51cGRhdGUodXBkYXRlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWVhc3VyaW5nLmxlbmd0aDsgaSsrKVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChtZWFzdXJlZFtpXSAhPSBCYWRNZWFzdXJlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgbSA9IG1lYXN1cmluZ1tpXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtLndyaXRlKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG0ud3JpdGUobWVhc3VyZWRbaV0sIHRoaXMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2dFeGNlcHRpb24odGhpcy5zdGF0ZSwgZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy52aWV3U3RhdGUuZWRpdG9ySGVpZ2h0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMudmlld1N0YXRlLnNjcm9sbFRhcmdldCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRvY1ZpZXcuc2Nyb2xsSW50b1ZpZXcodGhpcy52aWV3U3RhdGUuc2Nyb2xsVGFyZ2V0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy52aWV3U3RhdGUuc2Nyb2xsVGFyZ2V0ID0gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2Nyb2xsZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGRpZmYgPSB0aGlzLnZpZXdTdGF0ZS5saW5lQmxvY2tBdChyZWZCbG9jay5mcm9tKS50b3AgLSByZWZCbG9jay50b3A7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkaWZmID4gMSB8fCBkaWZmIDwgLTEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2Nyb2xsRE9NLnNjcm9sbFRvcCArPSBkaWZmO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2Nyb2xsZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKHJlZHJhd24pXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kb2NWaWV3LnVwZGF0ZVNlbGVjdGlvbih0cnVlKTtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnZpZXdwb3J0LmZyb20gPT0gb2xkVmlld3BvcnQuZnJvbSAmJiB0aGlzLnZpZXdwb3J0LnRvID09IG9sZFZpZXdwb3J0LnRvICYmXHJcbiAgICAgICAgICAgICAgICAgICAgIXNjcm9sbGVkICYmIHRoaXMubWVhc3VyZVJlcXVlc3RzLmxlbmd0aCA9PSAwKVxyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZpbmFsbHkge1xyXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVN0YXRlID0gMCAvKiBVcGRhdGVTdGF0ZS5JZGxlICovO1xyXG4gICAgICAgICAgICB0aGlzLm1lYXN1cmVTY2hlZHVsZWQgPSAtMTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHVwZGF0ZWQgJiYgIXVwZGF0ZWQuZW1wdHkpXHJcbiAgICAgICAgICAgIGZvciAobGV0IGxpc3RlbmVyIG9mIHRoaXMuc3RhdGUuZmFjZXQodXBkYXRlTGlzdGVuZXIpKVxyXG4gICAgICAgICAgICAgICAgbGlzdGVuZXIodXBkYXRlZCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgIEdldCB0aGUgQ1NTIGNsYXNzZXMgZm9yIHRoZSBjdXJyZW50bHkgYWN0aXZlIGVkaXRvciB0aGVtZXMuXHJcbiAgICAqL1xyXG4gICAgZ2V0IHRoZW1lQ2xhc3NlcygpIHtcclxuICAgICAgICByZXR1cm4gYmFzZVRoZW1lSUQgKyBcIiBcIiArXHJcbiAgICAgICAgICAgICh0aGlzLnN0YXRlLmZhY2V0KGRhcmtUaGVtZSkgPyBiYXNlRGFya0lEIDogYmFzZUxpZ2h0SUQpICsgXCIgXCIgK1xyXG4gICAgICAgICAgICB0aGlzLnN0YXRlLmZhY2V0KHRoZW1lKTtcclxuICAgIH1cclxuICAgIHVwZGF0ZUF0dHJzKCkge1xyXG4gICAgICAgIGxldCBlZGl0b3JBdHRycyA9IGF0dHJzRnJvbUZhY2V0KHRoaXMsIGVkaXRvckF0dHJpYnV0ZXMsIHtcclxuICAgICAgICAgICAgY2xhc3M6IFwiY20tZWRpdG9yXCIgKyAodGhpcy5oYXNGb2N1cyA/IFwiIGNtLWZvY3VzZWQgXCIgOiBcIiBcIikgKyB0aGlzLnRoZW1lQ2xhc3Nlc1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGxldCBjb250ZW50QXR0cnMgPSB7XHJcbiAgICAgICAgICAgIHNwZWxsY2hlY2s6IFwiZmFsc2VcIixcclxuICAgICAgICAgICAgYXV0b2NvcnJlY3Q6IFwib2ZmXCIsXHJcbiAgICAgICAgICAgIGF1dG9jYXBpdGFsaXplOiBcIm9mZlwiLFxyXG4gICAgICAgICAgICB0cmFuc2xhdGU6IFwibm9cIixcclxuICAgICAgICAgICAgY29udGVudGVkaXRhYmxlOiAhdGhpcy5zdGF0ZS5mYWNldChlZGl0YWJsZSkgPyBcImZhbHNlXCIgOiBcInRydWVcIixcclxuICAgICAgICAgICAgY2xhc3M6IFwiY20tY29udGVudFwiLFxyXG4gICAgICAgICAgICBzdHlsZTogYCR7YnJvd3Nlci50YWJTaXplfTogJHt0aGlzLnN0YXRlLnRhYlNpemV9YCxcclxuICAgICAgICAgICAgcm9sZTogXCJ0ZXh0Ym94XCIsXHJcbiAgICAgICAgICAgIFwiYXJpYS1tdWx0aWxpbmVcIjogXCJ0cnVlXCJcclxuICAgICAgICB9O1xyXG4gICAgICAgIGlmICh0aGlzLnN0YXRlLnJlYWRPbmx5KVxyXG4gICAgICAgICAgICBjb250ZW50QXR0cnNbXCJhcmlhLXJlYWRvbmx5XCJdID0gXCJ0cnVlXCI7XHJcbiAgICAgICAgYXR0cnNGcm9tRmFjZXQodGhpcywgY29udGVudEF0dHJpYnV0ZXMsIGNvbnRlbnRBdHRycyk7XHJcbiAgICAgICAgbGV0IGNoYW5nZWQgPSB0aGlzLm9ic2VydmVyLmlnbm9yZSgoKSA9PiB7XHJcbiAgICAgICAgICAgIGxldCBjaGFuZ2VkQ29udGVudCA9IHVwZGF0ZUF0dHJzKHRoaXMuY29udGVudERPTSwgdGhpcy5jb250ZW50QXR0cnMsIGNvbnRlbnRBdHRycyk7XHJcbiAgICAgICAgICAgIGxldCBjaGFuZ2VkRWRpdG9yID0gdXBkYXRlQXR0cnModGhpcy5kb20sIHRoaXMuZWRpdG9yQXR0cnMsIGVkaXRvckF0dHJzKTtcclxuICAgICAgICAgICAgcmV0dXJuIGNoYW5nZWRDb250ZW50IHx8IGNoYW5nZWRFZGl0b3I7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5lZGl0b3JBdHRycyA9IGVkaXRvckF0dHJzO1xyXG4gICAgICAgIHRoaXMuY29udGVudEF0dHJzID0gY29udGVudEF0dHJzO1xyXG4gICAgICAgIHJldHVybiBjaGFuZ2VkO1xyXG4gICAgfVxyXG4gICAgc2hvd0Fubm91bmNlbWVudHModHJzKSB7XHJcbiAgICAgICAgbGV0IGZpcnN0ID0gdHJ1ZTtcclxuICAgICAgICBmb3IgKGxldCB0ciBvZiB0cnMpXHJcbiAgICAgICAgICAgIGZvciAobGV0IGVmZmVjdCBvZiB0ci5lZmZlY3RzKVxyXG4gICAgICAgICAgICAgICAgaWYgKGVmZmVjdC5pcyhFZGl0b3JWaWV3LmFubm91bmNlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChmaXJzdClcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hbm5vdW5jZURPTS50ZXh0Q29udGVudCA9IFwiXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgZmlyc3QgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgZGl2ID0gdGhpcy5hbm5vdW5jZURPTS5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpKTtcclxuICAgICAgICAgICAgICAgICAgICBkaXYudGV4dENvbnRlbnQgPSBlZmZlY3QudmFsdWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBtb3VudFN0eWxlcygpIHtcclxuICAgICAgICB0aGlzLnN0eWxlTW9kdWxlcyA9IHRoaXMuc3RhdGUuZmFjZXQoc3R5bGVNb2R1bGUpO1xyXG4gICAgICAgIFN0eWxlTW9kdWxlLm1vdW50KHRoaXMucm9vdCwgdGhpcy5zdHlsZU1vZHVsZXMuY29uY2F0KGJhc2VUaGVtZSQxKS5yZXZlcnNlKCkpO1xyXG4gICAgfVxyXG4gICAgcmVhZE1lYXN1cmVkKCkge1xyXG4gICAgICAgIGlmICh0aGlzLnVwZGF0ZVN0YXRlID09IDIgLyogVXBkYXRlU3RhdGUuVXBkYXRpbmcgKi8pXHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlJlYWRpbmcgdGhlIGVkaXRvciBsYXlvdXQgaXNuJ3QgYWxsb3dlZCBkdXJpbmcgYW4gdXBkYXRlXCIpO1xyXG4gICAgICAgIGlmICh0aGlzLnVwZGF0ZVN0YXRlID09IDAgLyogVXBkYXRlU3RhdGUuSWRsZSAqLyAmJiB0aGlzLm1lYXN1cmVTY2hlZHVsZWQgPiAtMSlcclxuICAgICAgICAgICAgdGhpcy5tZWFzdXJlKGZhbHNlKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgU2NoZWR1bGUgYSBsYXlvdXQgbWVhc3VyZW1lbnQsIG9wdGlvbmFsbHkgcHJvdmlkaW5nIGNhbGxiYWNrcyB0b1xyXG4gICAgZG8gY3VzdG9tIERPTSBtZWFzdXJpbmcgZm9sbG93ZWQgYnkgYSBET00gd3JpdGUgcGhhc2UuIFVzaW5nXHJcbiAgICB0aGlzIGlzIHByZWZlcmFibGUgcmVhZGluZyBET00gbGF5b3V0IGRpcmVjdGx5IGZyb20sIGZvclxyXG4gICAgZXhhbXBsZSwgYW4gZXZlbnQgaGFuZGxlciwgYmVjYXVzZSBpdCdsbCBtYWtlIHN1cmUgbWVhc3VyaW5nIGFuZFxyXG4gICAgZHJhd2luZyBkb25lIGJ5IG90aGVyIGNvbXBvbmVudHMgaXMgc3luY2hyb25pemVkLCBhdm9pZGluZ1xyXG4gICAgdW5uZWNlc3NhcnkgRE9NIGxheW91dCBjb21wdXRhdGlvbnMuXHJcbiAgICAqL1xyXG4gICAgcmVxdWVzdE1lYXN1cmUocmVxdWVzdCkge1xyXG4gICAgICAgIGlmICh0aGlzLm1lYXN1cmVTY2hlZHVsZWQgPCAwKVxyXG4gICAgICAgICAgICB0aGlzLm1lYXN1cmVTY2hlZHVsZWQgPSB0aGlzLndpbi5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4gdGhpcy5tZWFzdXJlKCkpO1xyXG4gICAgICAgIGlmIChyZXF1ZXN0KSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLm1lYXN1cmVSZXF1ZXN0cy5pbmRleE9mKHJlcXVlc3QpID4gLTEpXHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0LmtleSAhPSBudWxsKVxyXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLm1lYXN1cmVSZXF1ZXN0cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLm1lYXN1cmVSZXF1ZXN0c1tpXS5rZXkgPT09IHJlcXVlc3Qua2V5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubWVhc3VyZVJlcXVlc3RzW2ldID0gcmVxdWVzdDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5tZWFzdXJlUmVxdWVzdHMucHVzaChyZXF1ZXN0KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgIEdldCB0aGUgdmFsdWUgb2YgYSBzcGVjaWZpYyBwbHVnaW4sIGlmIHByZXNlbnQuIE5vdGUgdGhhdFxyXG4gICAgcGx1Z2lucyB0aGF0IGNyYXNoIGNhbiBiZSBkcm9wcGVkIGZyb20gYSB2aWV3LCBzbyBldmVuIHdoZW4geW91XHJcbiAgICBrbm93IHlvdSByZWdpc3RlcmVkIGEgZ2l2ZW4gcGx1Z2luLCBpdCBpcyByZWNvbW1lbmRlZCB0byBjaGVja1xyXG4gICAgdGhlIHJldHVybiB2YWx1ZSBvZiB0aGlzIG1ldGhvZC5cclxuICAgICovXHJcbiAgICBwbHVnaW4ocGx1Z2luKSB7XHJcbiAgICAgICAgbGV0IGtub3duID0gdGhpcy5wbHVnaW5NYXAuZ2V0KHBsdWdpbik7XHJcbiAgICAgICAgaWYgKGtub3duID09PSB1bmRlZmluZWQgfHwga25vd24gJiYga25vd24uc3BlYyAhPSBwbHVnaW4pXHJcbiAgICAgICAgICAgIHRoaXMucGx1Z2luTWFwLnNldChwbHVnaW4sIGtub3duID0gdGhpcy5wbHVnaW5zLmZpbmQocCA9PiBwLnNwZWMgPT0gcGx1Z2luKSB8fCBudWxsKTtcclxuICAgICAgICByZXR1cm4ga25vd24gJiYga25vd24udXBkYXRlKHRoaXMpLnZhbHVlO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICBUaGUgdG9wIHBvc2l0aW9uIG9mIHRoZSBkb2N1bWVudCwgaW4gc2NyZWVuIGNvb3JkaW5hdGVzLiBUaGlzXHJcbiAgICBtYXkgYmUgbmVnYXRpdmUgd2hlbiB0aGUgZWRpdG9yIGlzIHNjcm9sbGVkIGRvd24uIFBvaW50c1xyXG4gICAgZGlyZWN0bHkgdG8gdGhlIHRvcCBvZiB0aGUgZmlyc3QgbGluZSwgbm90IGFib3ZlIHRoZSBwYWRkaW5nLlxyXG4gICAgKi9cclxuICAgIGdldCBkb2N1bWVudFRvcCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5jb250ZW50RE9NLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLnRvcCArIHRoaXMudmlld1N0YXRlLnBhZGRpbmdUb3A7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgIFJlcG9ydHMgdGhlIHBhZGRpbmcgYWJvdmUgYW5kIGJlbG93IHRoZSBkb2N1bWVudC5cclxuICAgICovXHJcbiAgICBnZXQgZG9jdW1lbnRQYWRkaW5nKCkge1xyXG4gICAgICAgIHJldHVybiB7IHRvcDogdGhpcy52aWV3U3RhdGUucGFkZGluZ1RvcCwgYm90dG9tOiB0aGlzLnZpZXdTdGF0ZS5wYWRkaW5nQm90dG9tIH07XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgIEZpbmQgdGhlIHRleHQgbGluZSBvciBibG9jayB3aWRnZXQgYXQgdGhlIGdpdmVuIHZlcnRpY2FsXHJcbiAgICBwb3NpdGlvbiAod2hpY2ggaXMgaW50ZXJwcmV0ZWQgYXMgcmVsYXRpdmUgdG8gdGhlIFt0b3Agb2YgdGhlXHJcbiAgICBkb2N1bWVudF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LkVkaXRvclZpZXcuZG9jdW1lbnRUb3ApKS5cclxuICAgICovXHJcbiAgICBlbGVtZW50QXRIZWlnaHQoaGVpZ2h0KSB7XHJcbiAgICAgICAgdGhpcy5yZWFkTWVhc3VyZWQoKTtcclxuICAgICAgICByZXR1cm4gdGhpcy52aWV3U3RhdGUuZWxlbWVudEF0SGVpZ2h0KGhlaWdodCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgIEZpbmQgdGhlIGxpbmUgYmxvY2sgKHNlZVxyXG4gICAgW2BsaW5lQmxvY2tBdGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5FZGl0b3JWaWV3LmxpbmVCbG9ja0F0KSBhdCB0aGUgZ2l2ZW5cclxuICAgIGhlaWdodCwgYWdhaW4gaW50ZXJwcmV0ZWQgcmVsYXRpdmUgdG8gdGhlIFt0b3Agb2YgdGhlXHJcbiAgICBkb2N1bWVudF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LkVkaXRvclZpZXcuZG9jdW1lbnRUb3ApLlxyXG4gICAgKi9cclxuICAgIGxpbmVCbG9ja0F0SGVpZ2h0KGhlaWdodCkge1xyXG4gICAgICAgIHRoaXMucmVhZE1lYXN1cmVkKCk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudmlld1N0YXRlLmxpbmVCbG9ja0F0SGVpZ2h0KGhlaWdodCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgIEdldCB0aGUgZXh0ZW50IGFuZCB2ZXJ0aWNhbCBwb3NpdGlvbiBvZiBhbGwgW2xpbmVcclxuICAgIGJsb2Nrc10oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LkVkaXRvclZpZXcubGluZUJsb2NrQXQpIGluIHRoZSB2aWV3cG9ydC4gUG9zaXRpb25zXHJcbiAgICBhcmUgcmVsYXRpdmUgdG8gdGhlIFt0b3Agb2YgdGhlXHJcbiAgICBkb2N1bWVudF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LkVkaXRvclZpZXcuZG9jdW1lbnRUb3ApO1xyXG4gICAgKi9cclxuICAgIGdldCB2aWV3cG9ydExpbmVCbG9ja3MoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudmlld1N0YXRlLnZpZXdwb3J0TGluZXM7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgIEZpbmQgdGhlIGxpbmUgYmxvY2sgYXJvdW5kIHRoZSBnaXZlbiBkb2N1bWVudCBwb3NpdGlvbi4gQSBsaW5lXHJcbiAgICBibG9jayBpcyBhIHJhbmdlIGRlbGltaXRlZCBvbiBib3RoIHNpZGVzIGJ5IGVpdGhlciBhXHJcbiAgICBub24tW2hpZGRlbl0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LkRlY29yYXRpb25ecmVwbGFjZSkgbGluZSBicmVha3MsIG9yIHRoZVxyXG4gICAgc3RhcnQvZW5kIG9mIHRoZSBkb2N1bWVudC4gSXQgd2lsbCB1c3VhbGx5IGp1c3QgaG9sZCBhIGxpbmUgb2ZcclxuICAgIHRleHQsIGJ1dCBtYXkgYmUgYnJva2VuIGludG8gbXVsdGlwbGUgdGV4dGJsb2NrcyBieSBibG9ja1xyXG4gICAgd2lkZ2V0cy5cclxuICAgICovXHJcbiAgICBsaW5lQmxvY2tBdChwb3MpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy52aWV3U3RhdGUubGluZUJsb2NrQXQocG9zKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgVGhlIGVkaXRvcidzIHRvdGFsIGNvbnRlbnQgaGVpZ2h0LlxyXG4gICAgKi9cclxuICAgIGdldCBjb250ZW50SGVpZ2h0KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnZpZXdTdGF0ZS5jb250ZW50SGVpZ2h0O1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICBNb3ZlIGEgY3Vyc29yIHBvc2l0aW9uIGJ5IFtncmFwaGVtZVxyXG4gICAgY2x1c3Rlcl0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5maW5kQ2x1c3RlckJyZWFrKS4gYGZvcndhcmRgIGRldGVybWluZXMgd2hldGhlclxyXG4gICAgdGhlIG1vdGlvbiBpcyBhd2F5IGZyb20gdGhlIGxpbmUgc3RhcnQsIG9yIHRvd2FyZHMgaXQuIEluXHJcbiAgICBiaWRpcmVjdGlvbmFsIHRleHQsIHRoZSBsaW5lIGlzIHRyYXZlcnNlZCBpbiB2aXN1YWwgb3JkZXIsIHVzaW5nXHJcbiAgICB0aGUgZWRpdG9yJ3MgW3RleHQgZGlyZWN0aW9uXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuRWRpdG9yVmlldy50ZXh0RGlyZWN0aW9uKS5cclxuICAgIFdoZW4gdGhlIHN0YXJ0IHBvc2l0aW9uIHdhcyB0aGUgbGFzdCBvbmUgb24gdGhlIGxpbmUsIHRoZVxyXG4gICAgcmV0dXJuZWQgcG9zaXRpb24gd2lsbCBiZSBhY3Jvc3MgdGhlIGxpbmUgYnJlYWsuIElmIHRoZXJlIGlzIG5vXHJcbiAgICBmdXJ0aGVyIGxpbmUsIHRoZSBvcmlnaW5hbCBwb3NpdGlvbiBpcyByZXR1cm5lZC5cclxuICAgIFxyXG4gICAgQnkgZGVmYXVsdCwgdGhpcyBtZXRob2QgbW92ZXMgb3ZlciBhIHNpbmdsZSBjbHVzdGVyLiBUaGVcclxuICAgIG9wdGlvbmFsIGBieWAgYXJndW1lbnQgY2FuIGJlIHVzZWQgdG8gbW92ZSBhY3Jvc3MgbW9yZS4gSXQgd2lsbFxyXG4gICAgYmUgY2FsbGVkIHdpdGggdGhlIGZpcnN0IGNsdXN0ZXIgYXMgYXJndW1lbnQsIGFuZCBzaG91bGQgcmV0dXJuXHJcbiAgICBhIHByZWRpY2F0ZSB0aGF0IGRldGVybWluZXMsIGZvciBlYWNoIHN1YnNlcXVlbnQgY2x1c3RlcixcclxuICAgIHdoZXRoZXIgaXQgc2hvdWxkIGFsc28gYmUgbW92ZWQgb3Zlci5cclxuICAgICovXHJcbiAgICBtb3ZlQnlDaGFyKHN0YXJ0LCBmb3J3YXJkLCBieSkge1xyXG4gICAgICAgIHJldHVybiBza2lwQXRvbXModGhpcywgc3RhcnQsIG1vdmVCeUNoYXIodGhpcywgc3RhcnQsIGZvcndhcmQsIGJ5KSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgIE1vdmUgYSBjdXJzb3IgcG9zaXRpb24gYWNyb3NzIHRoZSBuZXh0IGdyb3VwIG9mIGVpdGhlclxyXG4gICAgW2xldHRlcnNdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuRWRpdG9yU3RhdGUuY2hhckNhdGVnb3JpemVyKSBvciBub24tbGV0dGVyXHJcbiAgICBub24td2hpdGVzcGFjZSBjaGFyYWN0ZXJzLlxyXG4gICAgKi9cclxuICAgIG1vdmVCeUdyb3VwKHN0YXJ0LCBmb3J3YXJkKSB7XHJcbiAgICAgICAgcmV0dXJuIHNraXBBdG9tcyh0aGlzLCBzdGFydCwgbW92ZUJ5Q2hhcih0aGlzLCBzdGFydCwgZm9yd2FyZCwgaW5pdGlhbCA9PiBieUdyb3VwKHRoaXMsIHN0YXJ0LmhlYWQsIGluaXRpYWwpKSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgIE1vdmUgdG8gdGhlIG5leHQgbGluZSBib3VuZGFyeSBpbiB0aGUgZ2l2ZW4gZGlyZWN0aW9uLiBJZlxyXG4gICAgYGluY2x1ZGVXcmFwYCBpcyB0cnVlLCBsaW5lIHdyYXBwaW5nIGlzIG9uLCBhbmQgdGhlcmUgaXMgYVxyXG4gICAgZnVydGhlciB3cmFwIHBvaW50IG9uIHRoZSBjdXJyZW50IGxpbmUsIHRoZSB3cmFwIHBvaW50IHdpbGwgYmVcclxuICAgIHJldHVybmVkLiBPdGhlcndpc2UgdGhpcyBmdW5jdGlvbiB3aWxsIHJldHVybiB0aGUgc3RhcnQgb3IgZW5kXHJcbiAgICBvZiB0aGUgbGluZS5cclxuICAgICovXHJcbiAgICBtb3ZlVG9MaW5lQm91bmRhcnkoc3RhcnQsIGZvcndhcmQsIGluY2x1ZGVXcmFwID0gdHJ1ZSkge1xyXG4gICAgICAgIHJldHVybiBtb3ZlVG9MaW5lQm91bmRhcnkodGhpcywgc3RhcnQsIGZvcndhcmQsIGluY2x1ZGVXcmFwKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgTW92ZSBhIGN1cnNvciBwb3NpdGlvbiB2ZXJ0aWNhbGx5LiBXaGVuIGBkaXN0YW5jZWAgaXNuJ3QgZ2l2ZW4sXHJcbiAgICBpdCBkZWZhdWx0cyB0byBtb3ZpbmcgdG8gdGhlIG5leHQgbGluZSAoaW5jbHVkaW5nIHdyYXBwZWRcclxuICAgIGxpbmVzKS4gT3RoZXJ3aXNlLCBgZGlzdGFuY2VgIHNob3VsZCBwcm92aWRlIGEgcG9zaXRpdmUgZGlzdGFuY2VcclxuICAgIGluIHBpeGVscy5cclxuICAgIFxyXG4gICAgV2hlbiBgc3RhcnRgIGhhcyBhXHJcbiAgICBbYGdvYWxDb2x1bW5gXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlNlbGVjdGlvblJhbmdlLmdvYWxDb2x1bW4pLCB0aGUgdmVydGljYWxcclxuICAgIG1vdGlvbiB3aWxsIHVzZSB0aGF0IGFzIGEgdGFyZ2V0IGhvcml6b250YWwgcG9zaXRpb24uIE90aGVyd2lzZSxcclxuICAgIHRoZSBjdXJzb3IncyBvd24gaG9yaXpvbnRhbCBwb3NpdGlvbiBpcyB1c2VkLiBUaGUgcmV0dXJuZWRcclxuICAgIGN1cnNvciB3aWxsIGhhdmUgaXRzIGdvYWwgY29sdW1uIHNldCB0byB3aGljaGV2ZXIgY29sdW1uIHdhc1xyXG4gICAgdXNlZC5cclxuICAgICovXHJcbiAgICBtb3ZlVmVydGljYWxseShzdGFydCwgZm9yd2FyZCwgZGlzdGFuY2UpIHtcclxuICAgICAgICByZXR1cm4gc2tpcEF0b21zKHRoaXMsIHN0YXJ0LCBtb3ZlVmVydGljYWxseSh0aGlzLCBzdGFydCwgZm9yd2FyZCwgZGlzdGFuY2UpKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgRmluZCB0aGUgRE9NIHBhcmVudCBub2RlIGFuZCBvZmZzZXQgKGNoaWxkIG9mZnNldCBpZiBgbm9kZWAgaXNcclxuICAgIGFuIGVsZW1lbnQsIGNoYXJhY3RlciBvZmZzZXQgd2hlbiBpdCBpcyBhIHRleHQgbm9kZSkgYXQgdGhlXHJcbiAgICBnaXZlbiBkb2N1bWVudCBwb3NpdGlvbi5cclxuICAgIFxyXG4gICAgTm90ZSB0aGF0IGZvciBwb3NpdGlvbnMgdGhhdCBhcmVuJ3QgY3VycmVudGx5IGluXHJcbiAgICBgdmlzaWJsZVJhbmdlc2AsIHRoZSByZXN1bHRpbmcgRE9NIHBvc2l0aW9uIGlzbid0IG5lY2Vzc2FyaWx5XHJcbiAgICBtZWFuaW5nZnVsIChpdCBtYXkganVzdCBwb2ludCBiZWZvcmUgb3IgYWZ0ZXIgYSBwbGFjZWhvbGRlclxyXG4gICAgZWxlbWVudCkuXHJcbiAgICAqL1xyXG4gICAgZG9tQXRQb3MocG9zKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZG9jVmlldy5kb21BdFBvcyhwb3MpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICBGaW5kIHRoZSBkb2N1bWVudCBwb3NpdGlvbiBhdCB0aGUgZ2l2ZW4gRE9NIG5vZGUuIENhbiBiZSB1c2VmdWxcclxuICAgIGZvciBhc3NvY2lhdGluZyBwb3NpdGlvbnMgd2l0aCBET00gZXZlbnRzLiBXaWxsIHJhaXNlIGFuIGVycm9yXHJcbiAgICB3aGVuIGBub2RlYCBpc24ndCBwYXJ0IG9mIHRoZSBlZGl0b3IgY29udGVudC5cclxuICAgICovXHJcbiAgICBwb3NBdERPTShub2RlLCBvZmZzZXQgPSAwKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZG9jVmlldy5wb3NGcm9tRE9NKG5vZGUsIG9mZnNldCk7XHJcbiAgICB9XHJcbiAgICBwb3NBdENvb3Jkcyhjb29yZHMsIHByZWNpc2UgPSB0cnVlKSB7XHJcbiAgICAgICAgdGhpcy5yZWFkTWVhc3VyZWQoKTtcclxuICAgICAgICByZXR1cm4gcG9zQXRDb29yZHModGhpcywgY29vcmRzLCBwcmVjaXNlKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgR2V0IHRoZSBzY3JlZW4gY29vcmRpbmF0ZXMgYXQgdGhlIGdpdmVuIGRvY3VtZW50IHBvc2l0aW9uLlxyXG4gICAgYHNpZGVgIGRldGVybWluZXMgd2hldGhlciB0aGUgY29vcmRpbmF0ZXMgYXJlIGJhc2VkIG9uIHRoZVxyXG4gICAgZWxlbWVudCBiZWZvcmUgKC0xKSBvciBhZnRlciAoMSkgdGhlIHBvc2l0aW9uIChpZiBubyBlbGVtZW50IGlzXHJcbiAgICBhdmFpbGFibGUgb24gdGhlIGdpdmVuIHNpZGUsIHRoZSBtZXRob2Qgd2lsbCB0cmFuc3BhcmVudGx5IHVzZVxyXG4gICAgYW5vdGhlciBzdHJhdGVneSB0byBnZXQgcmVhc29uYWJsZSBjb29yZGluYXRlcykuXHJcbiAgICAqL1xyXG4gICAgY29vcmRzQXRQb3MocG9zLCBzaWRlID0gMSkge1xyXG4gICAgICAgIHRoaXMucmVhZE1lYXN1cmVkKCk7XHJcbiAgICAgICAgbGV0IHJlY3QgPSB0aGlzLmRvY1ZpZXcuY29vcmRzQXQocG9zLCBzaWRlKTtcclxuICAgICAgICBpZiAoIXJlY3QgfHwgcmVjdC5sZWZ0ID09IHJlY3QucmlnaHQpXHJcbiAgICAgICAgICAgIHJldHVybiByZWN0O1xyXG4gICAgICAgIGxldCBsaW5lID0gdGhpcy5zdGF0ZS5kb2MubGluZUF0KHBvcyksIG9yZGVyID0gdGhpcy5iaWRpU3BhbnMobGluZSk7XHJcbiAgICAgICAgbGV0IHNwYW4gPSBvcmRlcltCaWRpU3Bhbi5maW5kKG9yZGVyLCBwb3MgLSBsaW5lLmZyb20sIC0xLCBzaWRlKV07XHJcbiAgICAgICAgcmV0dXJuIGZsYXR0ZW5SZWN0KHJlY3QsIChzcGFuLmRpciA9PSBEaXJlY3Rpb24uTFRSKSA9PSAoc2lkZSA+IDApKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgVGhlIGRlZmF1bHQgd2lkdGggb2YgYSBjaGFyYWN0ZXIgaW4gdGhlIGVkaXRvci4gTWF5IG5vdFxyXG4gICAgYWNjdXJhdGVseSByZWZsZWN0IHRoZSB3aWR0aCBvZiBhbGwgY2hhcmFjdGVycyAoZ2l2ZW4gdmFyaWFibGVcclxuICAgIHdpZHRoIGZvbnRzIG9yIHN0eWxpbmcgb2YgaW52aWRpZHVhbCByYW5nZXMpLlxyXG4gICAgKi9cclxuICAgIGdldCBkZWZhdWx0Q2hhcmFjdGVyV2lkdGgoKSB7IHJldHVybiB0aGlzLnZpZXdTdGF0ZS5oZWlnaHRPcmFjbGUuY2hhcldpZHRoOyB9XHJcbiAgICAvKipcclxuICAgIFRoZSBkZWZhdWx0IGhlaWdodCBvZiBhIGxpbmUgaW4gdGhlIGVkaXRvci4gTWF5IG5vdCBiZSBhY2N1cmF0ZVxyXG4gICAgZm9yIGFsbCBsaW5lcy5cclxuICAgICovXHJcbiAgICBnZXQgZGVmYXVsdExpbmVIZWlnaHQoKSB7IHJldHVybiB0aGlzLnZpZXdTdGF0ZS5oZWlnaHRPcmFjbGUubGluZUhlaWdodDsgfVxyXG4gICAgLyoqXHJcbiAgICBUaGUgdGV4dCBkaXJlY3Rpb25cclxuICAgIChbYGRpcmVjdGlvbmBdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0NTUy9kaXJlY3Rpb24pXHJcbiAgICBDU1MgcHJvcGVydHkpIG9mIHRoZSBlZGl0b3IncyBjb250ZW50IGVsZW1lbnQuXHJcbiAgICAqL1xyXG4gICAgZ2V0IHRleHREaXJlY3Rpb24oKSB7IHJldHVybiB0aGlzLnZpZXdTdGF0ZS5kZWZhdWx0VGV4dERpcmVjdGlvbjsgfVxyXG4gICAgLyoqXHJcbiAgICBGaW5kIHRoZSB0ZXh0IGRpcmVjdGlvbiBvZiB0aGUgYmxvY2sgYXQgdGhlIGdpdmVuIHBvc2l0aW9uLCBhc1xyXG4gICAgYXNzaWduZWQgYnkgQ1NTLiBJZlxyXG4gICAgW2BwZXJMaW5lVGV4dERpcmVjdGlvbmBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5FZGl0b3JWaWV3XnBlckxpbmVUZXh0RGlyZWN0aW9uKVxyXG4gICAgaXNuJ3QgZW5hYmxlZCwgb3IgdGhlIGdpdmVuIHBvc2l0aW9uIGlzIG91dHNpZGUgb2YgdGhlIHZpZXdwb3J0LFxyXG4gICAgdGhpcyB3aWxsIGFsd2F5cyByZXR1cm4gdGhlIHNhbWUgYXNcclxuICAgIFtgdGV4dERpcmVjdGlvbmBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5FZGl0b3JWaWV3LnRleHREaXJlY3Rpb24pLiBOb3RlIHRoYXRcclxuICAgIHRoaXMgbWF5IHRyaWdnZXIgYSBET00gbGF5b3V0LlxyXG4gICAgKi9cclxuICAgIHRleHREaXJlY3Rpb25BdChwb3MpIHtcclxuICAgICAgICBsZXQgcGVyTGluZSA9IHRoaXMuc3RhdGUuZmFjZXQocGVyTGluZVRleHREaXJlY3Rpb24pO1xyXG4gICAgICAgIGlmICghcGVyTGluZSB8fCBwb3MgPCB0aGlzLnZpZXdwb3J0LmZyb20gfHwgcG9zID4gdGhpcy52aWV3cG9ydC50bylcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMudGV4dERpcmVjdGlvbjtcclxuICAgICAgICB0aGlzLnJlYWRNZWFzdXJlZCgpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLmRvY1ZpZXcudGV4dERpcmVjdGlvbkF0KHBvcyk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgIFdoZXRoZXIgdGhpcyBlZGl0b3IgW3dyYXBzIGxpbmVzXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuRWRpdG9yVmlldy5saW5lV3JhcHBpbmcpXHJcbiAgICAoYXMgZGV0ZXJtaW5lZCBieSB0aGVcclxuICAgIFtgd2hpdGUtc3BhY2VgXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9DU1Mvd2hpdGUtc3BhY2UpXHJcbiAgICBDU1MgcHJvcGVydHkgb2YgaXRzIGNvbnRlbnQgZWxlbWVudCkuXHJcbiAgICAqL1xyXG4gICAgZ2V0IGxpbmVXcmFwcGluZygpIHsgcmV0dXJuIHRoaXMudmlld1N0YXRlLmhlaWdodE9yYWNsZS5saW5lV3JhcHBpbmc7IH1cclxuICAgIC8qKlxyXG4gICAgUmV0dXJucyB0aGUgYmlkaXJlY3Rpb25hbCB0ZXh0IHN0cnVjdHVyZSBvZiB0aGUgZ2l2ZW4gbGluZVxyXG4gICAgKHdoaWNoIHNob3VsZCBiZSBpbiB0aGUgY3VycmVudCBkb2N1bWVudCkgYXMgYW4gYXJyYXkgb2Ygc3BhblxyXG4gICAgb2JqZWN0cy4gVGhlIG9yZGVyIG9mIHRoZXNlIHNwYW5zIG1hdGNoZXMgdGhlIFt0ZXh0XHJcbiAgICBkaXJlY3Rpb25dKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5FZGl0b3JWaWV3LnRleHREaXJlY3Rpb24p4oCUaWYgdGhhdCBpc1xyXG4gICAgbGVmdC10by1yaWdodCwgdGhlIGxlZnRtb3N0IHNwYW5zIGNvbWUgZmlyc3QsIG90aGVyd2lzZSB0aGVcclxuICAgIHJpZ2h0bW9zdCBzcGFucyBjb21lIGZpcnN0LlxyXG4gICAgKi9cclxuICAgIGJpZGlTcGFucyhsaW5lKSB7XHJcbiAgICAgICAgaWYgKGxpbmUubGVuZ3RoID4gTWF4QmlkaUxpbmUpXHJcbiAgICAgICAgICAgIHJldHVybiB0cml2aWFsT3JkZXIobGluZS5sZW5ndGgpO1xyXG4gICAgICAgIGxldCBkaXIgPSB0aGlzLnRleHREaXJlY3Rpb25BdChsaW5lLmZyb20pO1xyXG4gICAgICAgIGZvciAobGV0IGVudHJ5IG9mIHRoaXMuYmlkaUNhY2hlKVxyXG4gICAgICAgICAgICBpZiAoZW50cnkuZnJvbSA9PSBsaW5lLmZyb20gJiYgZW50cnkuZGlyID09IGRpcilcclxuICAgICAgICAgICAgICAgIHJldHVybiBlbnRyeS5vcmRlcjtcclxuICAgICAgICBsZXQgb3JkZXIgPSBjb21wdXRlT3JkZXIobGluZS50ZXh0LCBkaXIpO1xyXG4gICAgICAgIHRoaXMuYmlkaUNhY2hlLnB1c2gobmV3IENhY2hlZE9yZGVyKGxpbmUuZnJvbSwgbGluZS50bywgZGlyLCBvcmRlcikpO1xyXG4gICAgICAgIHJldHVybiBvcmRlcjtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgQ2hlY2sgd2hldGhlciB0aGUgZWRpdG9yIGhhcyBmb2N1cy5cclxuICAgICovXHJcbiAgICBnZXQgaGFzRm9jdXMoKSB7XHJcbiAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgIC8vIFNhZmFyaSByZXR1cm4gZmFsc2UgZm9yIGhhc0ZvY3VzIHdoZW4gdGhlIGNvbnRleHQgbWVudSBpcyBvcGVuXHJcbiAgICAgICAgLy8gb3IgY2xvc2luZywgd2hpY2ggbGVhZHMgdXMgdG8gaWdub3JlIHNlbGVjdGlvbiBjaGFuZ2VzIGZyb20gdGhlXHJcbiAgICAgICAgLy8gY29udGV4dCBtZW51IGJlY2F1c2UgaXQgbG9va3MgbGlrZSB0aGUgZWRpdG9yIGlzbid0IGZvY3VzZWQuXHJcbiAgICAgICAgLy8gVGhpcyBrbHVkZ2VzIGFyb3VuZCB0aGF0LlxyXG4gICAgICAgIHJldHVybiAodGhpcy5kb20ub3duZXJEb2N1bWVudC5oYXNGb2N1cygpIHx8IGJyb3dzZXIuc2FmYXJpICYmICgoX2EgPSB0aGlzLmlucHV0U3RhdGUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5sYXN0Q29udGV4dE1lbnUpID4gRGF0ZS5ub3coKSAtIDNlNCkgJiZcclxuICAgICAgICAgICAgdGhpcy5yb290LmFjdGl2ZUVsZW1lbnQgPT0gdGhpcy5jb250ZW50RE9NO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICBQdXQgZm9jdXMgb24gdGhlIGVkaXRvci5cclxuICAgICovXHJcbiAgICBmb2N1cygpIHtcclxuICAgICAgICB0aGlzLm9ic2VydmVyLmlnbm9yZSgoKSA9PiB7XHJcbiAgICAgICAgICAgIGZvY3VzUHJldmVudFNjcm9sbCh0aGlzLmNvbnRlbnRET00pO1xyXG4gICAgICAgICAgICB0aGlzLmRvY1ZpZXcudXBkYXRlU2VsZWN0aW9uKCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgIFVwZGF0ZSB0aGUgW3Jvb3RdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jI3ZpZXcuRWRpdG9yVmlld0NvbmZpZy5yb290KSBpbiB3aGljaCB0aGUgZWRpdG9yIGxpdmVzLiBUaGlzIGlzIG9ubHlcclxuICAgIG5lY2Vzc2FyeSB3aGVuIG1vdmluZyB0aGUgZWRpdG9yJ3MgZXhpc3RpbmcgRE9NIHRvIGEgbmV3IHdpbmRvdyBvciBzaGFkb3cgcm9vdC5cclxuICAgICovXHJcbiAgICBzZXRSb290KHJvb3QpIHtcclxuICAgICAgICBpZiAodGhpcy5fcm9vdCAhPSByb290KSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3Jvb3QgPSByb290O1xyXG4gICAgICAgICAgICB0aGlzLm9ic2VydmVyLnNldFdpbmRvdygocm9vdC5ub2RlVHlwZSA9PSA5ID8gcm9vdCA6IHJvb3Qub3duZXJEb2N1bWVudCkuZGVmYXVsdFZpZXcgfHwgd2luZG93KTtcclxuICAgICAgICAgICAgdGhpcy5tb3VudFN0eWxlcygpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgQ2xlYW4gdXAgdGhpcyBlZGl0b3IgdmlldywgcmVtb3ZpbmcgaXRzIGVsZW1lbnQgZnJvbSB0aGVcclxuICAgIGRvY3VtZW50LCB1bnJlZ2lzdGVyaW5nIGV2ZW50IGhhbmRsZXJzLCBhbmQgbm90aWZ5aW5nXHJcbiAgICBwbHVnaW5zLiBUaGUgdmlldyBpbnN0YW5jZSBjYW4gbm8gbG9uZ2VyIGJlIHVzZWQgYWZ0ZXJcclxuICAgIGNhbGxpbmcgdGhpcy5cclxuICAgICovXHJcbiAgICBkZXN0cm95KCkge1xyXG4gICAgICAgIGZvciAobGV0IHBsdWdpbiBvZiB0aGlzLnBsdWdpbnMpXHJcbiAgICAgICAgICAgIHBsdWdpbi5kZXN0cm95KHRoaXMpO1xyXG4gICAgICAgIHRoaXMucGx1Z2lucyA9IFtdO1xyXG4gICAgICAgIHRoaXMuaW5wdXRTdGF0ZS5kZXN0cm95KCk7XHJcbiAgICAgICAgdGhpcy5kb20ucmVtb3ZlKCk7XHJcbiAgICAgICAgdGhpcy5vYnNlcnZlci5kZXN0cm95KCk7XHJcbiAgICAgICAgaWYgKHRoaXMubWVhc3VyZVNjaGVkdWxlZCA+IC0xKVxyXG4gICAgICAgICAgICBjYW5jZWxBbmltYXRpb25GcmFtZSh0aGlzLm1lYXN1cmVTY2hlZHVsZWQpO1xyXG4gICAgICAgIHRoaXMuZGVzdHJveWVkID0gdHJ1ZTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgUmV0dXJucyBhbiBlZmZlY3QgdGhhdCBjYW4gYmVcclxuICAgIFthZGRlZF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5UcmFuc2FjdGlvblNwZWMuZWZmZWN0cykgdG8gYSB0cmFuc2FjdGlvbiB0b1xyXG4gICAgY2F1c2UgaXQgdG8gc2Nyb2xsIHRoZSBnaXZlbiBwb3NpdGlvbiBvciByYW5nZSBpbnRvIHZpZXcuXHJcbiAgICAqL1xyXG4gICAgc3RhdGljIHNjcm9sbEludG9WaWV3KHBvcywgb3B0aW9ucyA9IHt9KSB7XHJcbiAgICAgICAgcmV0dXJuIHNjcm9sbEludG9WaWV3Lm9mKG5ldyBTY3JvbGxUYXJnZXQodHlwZW9mIHBvcyA9PSBcIm51bWJlclwiID8gRWRpdG9yU2VsZWN0aW9uLmN1cnNvcihwb3MpIDogcG9zLCBvcHRpb25zLnksIG9wdGlvbnMueCwgb3B0aW9ucy55TWFyZ2luLCBvcHRpb25zLnhNYXJnaW4pKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgUmV0dXJucyBhbiBleHRlbnNpb24gdGhhdCBjYW4gYmUgdXNlZCB0byBhZGQgRE9NIGV2ZW50IGhhbmRsZXJzLlxyXG4gICAgVGhlIHZhbHVlIHNob3VsZCBiZSBhbiBvYmplY3QgbWFwcGluZyBldmVudCBuYW1lcyB0byBoYW5kbGVyXHJcbiAgICBmdW5jdGlvbnMuIEZvciBhbnkgZ2l2ZW4gZXZlbnQsIHN1Y2ggZnVuY3Rpb25zIGFyZSBvcmRlcmVkIGJ5XHJcbiAgICBleHRlbnNpb24gcHJlY2VkZW5jZSwgYW5kIHRoZSBmaXJzdCBoYW5kbGVyIHRvIHJldHVybiB0cnVlIHdpbGxcclxuICAgIGJlIGFzc3VtZWQgdG8gaGF2ZSBoYW5kbGVkIHRoYXQgZXZlbnQsIGFuZCBubyBvdGhlciBoYW5kbGVycyBvclxyXG4gICAgYnVpbHQtaW4gYmVoYXZpb3Igd2lsbCBiZSBhY3RpdmF0ZWQgZm9yIGl0LiBUaGVzZSBhcmUgcmVnaXN0ZXJlZFxyXG4gICAgb24gdGhlIFtjb250ZW50IGVsZW1lbnRdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5FZGl0b3JWaWV3LmNvbnRlbnRET00pLCBleGNlcHRcclxuICAgIGZvciBgc2Nyb2xsYCBoYW5kbGVycywgd2hpY2ggd2lsbCBiZSBjYWxsZWQgYW55IHRpbWUgdGhlXHJcbiAgICBlZGl0b3IncyBbc2Nyb2xsIGVsZW1lbnRdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5FZGl0b3JWaWV3LnNjcm9sbERPTSkgb3Igb25lIG9mXHJcbiAgICBpdHMgcGFyZW50IG5vZGVzIGlzIHNjcm9sbGVkLlxyXG4gICAgKi9cclxuICAgIHN0YXRpYyBkb21FdmVudEhhbmRsZXJzKGhhbmRsZXJzKSB7XHJcbiAgICAgICAgcmV0dXJuIFZpZXdQbHVnaW4uZGVmaW5lKCgpID0+ICh7fSksIHsgZXZlbnRIYW5kbGVyczogaGFuZGxlcnMgfSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgIENyZWF0ZSBhIHRoZW1lIGV4dGVuc2lvbi4gVGhlIGZpcnN0IGFyZ3VtZW50IGNhbiBiZSBhXHJcbiAgICBbYHN0eWxlLW1vZGBdKGh0dHBzOi8vZ2l0aHViLmNvbS9tYXJpam5oL3N0eWxlLW1vZCNkb2N1bWVudGF0aW9uKVxyXG4gICAgc3R5bGUgc3BlYyBwcm92aWRpbmcgdGhlIHN0eWxlcyBmb3IgdGhlIHRoZW1lLiBUaGVzZSB3aWxsIGJlXHJcbiAgICBwcmVmaXhlZCB3aXRoIGEgZ2VuZXJhdGVkIGNsYXNzIGZvciB0aGUgc3R5bGUuXHJcbiAgICBcclxuICAgIEJlY2F1c2UgdGhlIHNlbGVjdG9ycyB3aWxsIGJlIHByZWZpeGVkIHdpdGggYSBzY29wZSBjbGFzcywgcnVsZVxyXG4gICAgdGhhdCBkaXJlY3RseSBtYXRjaCB0aGUgZWRpdG9yJ3MgW3dyYXBwZXJcclxuICAgIGVsZW1lbnRdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5FZGl0b3JWaWV3LmRvbSnigJR0byB3aGljaCB0aGUgc2NvcGUgY2xhc3Mgd2lsbCBiZVxyXG4gICAgYWRkZWTigJRuZWVkIHRvIGJlIGV4cGxpY2l0bHkgZGlmZmVyZW50aWF0ZWQgYnkgYWRkaW5nIGFuIGAmYCB0b1xyXG4gICAgdGhlIHNlbGVjdG9yIGZvciB0aGF0IGVsZW1lbnTigJRmb3IgZXhhbXBsZVxyXG4gICAgYCYuY20tZm9jdXNlZGAuXHJcbiAgICBcclxuICAgIFdoZW4gYGRhcmtgIGlzIHNldCB0byB0cnVlLCB0aGUgdGhlbWUgd2lsbCBiZSBtYXJrZWQgYXMgZGFyayxcclxuICAgIHdoaWNoIHdpbGwgY2F1c2UgdGhlIGAmZGFya2AgcnVsZXMgZnJvbSBbYmFzZVxyXG4gICAgdGhlbWVzXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuRWRpdG9yVmlld15iYXNlVGhlbWUpIHRvIGJlIHVzZWQgKGFzIG9wcG9zZWQgdG9cclxuICAgIGAmbGlnaHRgIHdoZW4gYSBsaWdodCB0aGVtZSBpcyBhY3RpdmUpLlxyXG4gICAgKi9cclxuICAgIHN0YXRpYyB0aGVtZShzcGVjLCBvcHRpb25zKSB7XHJcbiAgICAgICAgbGV0IHByZWZpeCA9IFN0eWxlTW9kdWxlLm5ld05hbWUoKTtcclxuICAgICAgICBsZXQgcmVzdWx0ID0gW3RoZW1lLm9mKHByZWZpeCksIHN0eWxlTW9kdWxlLm9mKGJ1aWxkVGhlbWUoYC4ke3ByZWZpeH1gLCBzcGVjKSldO1xyXG4gICAgICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMuZGFyaylcclxuICAgICAgICAgICAgcmVzdWx0LnB1c2goZGFya1RoZW1lLm9mKHRydWUpKTtcclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICBDcmVhdGUgYW4gZXh0ZW5zaW9uIHRoYXQgYWRkcyBzdHlsZXMgdG8gdGhlIGJhc2UgdGhlbWUuIExpa2VcclxuICAgIHdpdGggW2B0aGVtZWBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5FZGl0b3JWaWV3XnRoZW1lKSwgdXNlIGAmYCB0byBpbmRpY2F0ZSB0aGVcclxuICAgIHBsYWNlIG9mIHRoZSBlZGl0b3Igd3JhcHBlciBlbGVtZW50IHdoZW4gZGlyZWN0bHkgdGFyZ2V0aW5nXHJcbiAgICB0aGF0LiBZb3UgY2FuIGFsc28gdXNlIGAmZGFya2Agb3IgYCZsaWdodGAgaW5zdGVhZCB0byBvbmx5XHJcbiAgICB0YXJnZXQgZWRpdG9ycyB3aXRoIGEgZGFyayBvciBsaWdodCB0aGVtZS5cclxuICAgICovXHJcbiAgICBzdGF0aWMgYmFzZVRoZW1lKHNwZWMpIHtcclxuICAgICAgICByZXR1cm4gUHJlYy5sb3dlc3Qoc3R5bGVNb2R1bGUub2YoYnVpbGRUaGVtZShcIi5cIiArIGJhc2VUaGVtZUlELCBzcGVjLCBsaWdodERhcmtJRHMpKSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgIFJldHJpZXZlIGFuIGVkaXRvciB2aWV3IGluc3RhbmNlIGZyb20gdGhlIHZpZXcncyBET01cclxuICAgIHJlcHJlc2VudGF0aW9uLlxyXG4gICAgKi9cclxuICAgIHN0YXRpYyBmaW5kRnJvbURPTShkb20pIHtcclxuICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgbGV0IGNvbnRlbnQgPSBkb20ucXVlcnlTZWxlY3RvcihcIi5jbS1jb250ZW50XCIpO1xyXG4gICAgICAgIGxldCBjVmlldyA9IGNvbnRlbnQgJiYgQ29udGVudFZpZXcuZ2V0KGNvbnRlbnQpIHx8IENvbnRlbnRWaWV3LmdldChkb20pO1xyXG4gICAgICAgIHJldHVybiAoKF9hID0gY1ZpZXcgPT09IG51bGwgfHwgY1ZpZXcgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNWaWV3LnJvb3RWaWV3KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EudmlldykgfHwgbnVsbDtcclxuICAgIH1cclxufVxyXG4vKipcclxuRmFjZXQgdG8gYWRkIGEgW3N0eWxlXHJcbm1vZHVsZV0oaHR0cHM6Ly9naXRodWIuY29tL21hcmlqbmgvc3R5bGUtbW9kI2RvY3VtZW50YXRpb24pIHRvXHJcbmFuIGVkaXRvciB2aWV3LiBUaGUgdmlldyB3aWxsIGVuc3VyZSB0aGF0IHRoZSBtb2R1bGUgaXNcclxubW91bnRlZCBpbiBpdHMgW2RvY3VtZW50XHJcbnJvb3RdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5FZGl0b3JWaWV3LmNvbnN0cnVjdG9yXmNvbmZpZy5yb290KS5cclxuKi9cclxuRWRpdG9yVmlldy5zdHlsZU1vZHVsZSA9IHN0eWxlTW9kdWxlO1xyXG4vKipcclxuQW4gaW5wdXQgaGFuZGxlciBjYW4gb3ZlcnJpZGUgdGhlIHdheSBjaGFuZ2VzIHRvIHRoZSBlZGl0YWJsZVxyXG5ET00gY29udGVudCBhcmUgaGFuZGxlZC4gSGFuZGxlcnMgYXJlIHBhc3NlZCB0aGUgZG9jdW1lbnRcclxucG9zaXRpb25zIGJldHdlZW4gd2hpY2ggdGhlIGNoYW5nZSB3YXMgZm91bmQsIGFuZCB0aGUgbmV3XHJcbmNvbnRlbnQuIFdoZW4gb25lIHJldHVybnMgdHJ1ZSwgbm8gZnVydGhlciBpbnB1dCBoYW5kbGVycyBhcmVcclxuY2FsbGVkIGFuZCB0aGUgZGVmYXVsdCBiZWhhdmlvciBpcyBwcmV2ZW50ZWQuXHJcbiovXHJcbkVkaXRvclZpZXcuaW5wdXRIYW5kbGVyID0gaW5wdXRIYW5kbGVyO1xyXG4vKipcclxuQnkgZGVmYXVsdCwgdGhlIGVkaXRvciBhc3N1bWVzIGFsbCBpdHMgY29udGVudCBoYXMgdGhlIHNhbWVcclxuW3RleHQgZGlyZWN0aW9uXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuRGlyZWN0aW9uKS4gQ29uZmlndXJlIHRoaXMgd2l0aCBhIGB0cnVlYFxyXG52YWx1ZSB0byBtYWtlIGl0IHJlYWQgdGhlIHRleHQgZGlyZWN0aW9uIG9mIGV2ZXJ5IChyZW5kZXJlZClcclxubGluZSBzZXBhcmF0ZWx5LlxyXG4qL1xyXG5FZGl0b3JWaWV3LnBlckxpbmVUZXh0RGlyZWN0aW9uID0gcGVyTGluZVRleHREaXJlY3Rpb247XHJcbi8qKlxyXG5BbGxvd3MgeW91IHRvIHByb3ZpZGUgYSBmdW5jdGlvbiB0aGF0IHNob3VsZCBiZSBjYWxsZWQgd2hlbiB0aGVcclxubGlicmFyeSBjYXRjaGVzIGFuIGV4Y2VwdGlvbiBmcm9tIGFuIGV4dGVuc2lvbiAobW9zdGx5IGZyb20gdmlld1xyXG5wbHVnaW5zLCBidXQgbWF5IGJlIHVzZWQgYnkgb3RoZXIgZXh0ZW5zaW9ucyB0byByb3V0ZSBleGNlcHRpb25zXHJcbmZyb20gdXNlci1jb2RlLXByb3ZpZGVkIGNhbGxiYWNrcykuIFRoaXMgaXMgbW9zdGx5IHVzZWZ1bCBmb3JcclxuZGVidWdnaW5nIGFuZCBsb2dnaW5nLiBTZWUgW2Bsb2dFeGNlcHRpb25gXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcubG9nRXhjZXB0aW9uKS5cclxuKi9cclxuRWRpdG9yVmlldy5leGNlcHRpb25TaW5rID0gZXhjZXB0aW9uU2luaztcclxuLyoqXHJcbkEgZmFjZXQgdGhhdCBjYW4gYmUgdXNlZCB0byByZWdpc3RlciBhIGZ1bmN0aW9uIHRvIGJlIGNhbGxlZFxyXG5ldmVyeSB0aW1lIHRoZSB2aWV3IHVwZGF0ZXMuXHJcbiovXHJcbkVkaXRvclZpZXcudXBkYXRlTGlzdGVuZXIgPSB1cGRhdGVMaXN0ZW5lcjtcclxuLyoqXHJcbkZhY2V0IHRoYXQgY29udHJvbHMgd2hldGhlciB0aGUgZWRpdG9yIGNvbnRlbnQgRE9NIGlzIGVkaXRhYmxlLlxyXG5XaGVuIGl0cyBoaWdoZXN0LXByZWNlZGVuY2UgdmFsdWUgaXMgYGZhbHNlYCwgdGhlIGVsZW1lbnQgd2lsbFxyXG5ub3QgaGF2ZSBpdHMgYGNvbnRlbnRlZGl0YWJsZWAgYXR0cmlidXRlIHNldC4gKE5vdGUgdGhhdCB0aGlzXHJcbmRvZXNuJ3QgYWZmZWN0IEFQSSBjYWxscyB0aGF0IGNoYW5nZSB0aGUgZWRpdG9yIGNvbnRlbnQsIGV2ZW5cclxud2hlbiB0aG9zZSBhcmUgYm91bmQgdG8ga2V5cyBvciBidXR0b25zLiBTZWUgdGhlXHJcbltgcmVhZE9ubHlgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkVkaXRvclN0YXRlLnJlYWRPbmx5KSBmYWNldCBmb3IgdGhhdC4pXHJcbiovXHJcbkVkaXRvclZpZXcuZWRpdGFibGUgPSBlZGl0YWJsZTtcclxuLyoqXHJcbkFsbG93cyB5b3UgdG8gaW5mbHVlbmNlIHRoZSB3YXkgbW91c2Ugc2VsZWN0aW9uIGhhcHBlbnMuIFRoZVxyXG5mdW5jdGlvbnMgaW4gdGhpcyBmYWNldCB3aWxsIGJlIGNhbGxlZCBmb3IgYSBgbW91c2Vkb3duYCBldmVudFxyXG5vbiB0aGUgZWRpdG9yLCBhbmQgY2FuIHJldHVybiBhbiBvYmplY3QgdGhhdCBvdmVycmlkZXMgdGhlIHdheSBhXHJcbnNlbGVjdGlvbiBpcyBjb21wdXRlZCBmcm9tIHRoYXQgbW91c2UgY2xpY2sgb3IgZHJhZy5cclxuKi9cclxuRWRpdG9yVmlldy5tb3VzZVNlbGVjdGlvblN0eWxlID0gbW91c2VTZWxlY3Rpb25TdHlsZTtcclxuLyoqXHJcbkZhY2V0IHVzZWQgdG8gY29uZmlndXJlIHdoZXRoZXIgYSBnaXZlbiBzZWxlY3Rpb24gZHJhZyBldmVudFxyXG5zaG91bGQgbW92ZSBvciBjb3B5IHRoZSBzZWxlY3Rpb24uIFRoZSBnaXZlbiBwcmVkaWNhdGUgd2lsbCBiZVxyXG5jYWxsZWQgd2l0aCB0aGUgYG1vdXNlZG93bmAgZXZlbnQsIGFuZCBjYW4gcmV0dXJuIGB0cnVlYCB3aGVuXHJcbnRoZSBkcmFnIHNob3VsZCBtb3ZlIHRoZSBjb250ZW50LlxyXG4qL1xyXG5FZGl0b3JWaWV3LmRyYWdNb3Zlc1NlbGVjdGlvbiA9IGRyYWdNb3Zlc1NlbGVjdGlvbiQxO1xyXG4vKipcclxuRmFjZXQgdXNlZCB0byBjb25maWd1cmUgd2hldGhlciBhIGdpdmVuIHNlbGVjdGluZyBjbGljayBhZGRzIGFcclxubmV3IHJhbmdlIHRvIHRoZSBleGlzdGluZyBzZWxlY3Rpb24gb3IgcmVwbGFjZXMgaXQgZW50aXJlbHkuIFRoZVxyXG5kZWZhdWx0IGJlaGF2aW9yIGlzIHRvIGNoZWNrIGBldmVudC5tZXRhS2V5YCBvbiBtYWNPUywgYW5kXHJcbmBldmVudC5jdHJsS2V5YCBlbHNld2hlcmUuXHJcbiovXHJcbkVkaXRvclZpZXcuY2xpY2tBZGRzU2VsZWN0aW9uUmFuZ2UgPSBjbGlja0FkZHNTZWxlY3Rpb25SYW5nZTtcclxuLyoqXHJcbkEgZmFjZXQgdGhhdCBkZXRlcm1pbmVzIHdoaWNoIFtkZWNvcmF0aW9uc10oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LkRlY29yYXRpb24pXHJcbmFyZSBzaG93biBpbiB0aGUgdmlldy4gRGVjb3JhdGlvbnMgY2FuIGJlIHByb3ZpZGVkIGluIHR3b1xyXG53YXlz4oCUZGlyZWN0bHksIG9yIHZpYSBhIGZ1bmN0aW9uIHRoYXQgdGFrZXMgYW4gZWRpdG9yIHZpZXcuXHJcblxyXG5Pbmx5IGRlY29yYXRpb24gc2V0cyBwcm92aWRlZCBkaXJlY3RseSBhcmUgYWxsb3dlZCB0byBpbmZsdWVuY2VcclxudGhlIGVkaXRvcidzIHZlcnRpY2FsIGxheW91dCBzdHJ1Y3R1cmUuIFRoZSBvbmVzIHByb3ZpZGVkIGFzXHJcbmZ1bmN0aW9ucyBhcmUgY2FsbGVkIF9hZnRlcl8gdGhlIG5ldyB2aWV3cG9ydCBoYXMgYmVlbiBjb21wdXRlZCxcclxuYW5kIHRodXMgKiptdXN0IG5vdCoqIGludHJvZHVjZSBibG9jayB3aWRnZXRzIG9yIHJlcGxhY2luZ1xyXG5kZWNvcmF0aW9ucyB0aGF0IGNvdmVyIGxpbmUgYnJlYWtzLlxyXG5cclxuSWYgeW91IHdhbnQgZGVjb3JhdGVkIHJhbmdlcyB0byBiZWhhdmUgbGlrZSBhdG9taWMgdW5pdHMgZm9yXHJcbmN1cnNvciBtb3Rpb24gYW5kIGRlbGV0aW9uIHB1cnBvc2VzLCBhbHNvIHByb3ZpZGUgdGhlIHJhbmdlIHNldFxyXG5jb250YWluaW5nIHRoZSBkZWNvcmF0aW9ucyB0b1xyXG5bYEVkaXRvclZpZXcuYXRvbWljUmFuZ2VzYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LkVkaXRvclZpZXdeYXRvbWljUmFuZ2VzKS5cclxuKi9cclxuRWRpdG9yVmlldy5kZWNvcmF0aW9ucyA9IGRlY29yYXRpb25zO1xyXG4vKipcclxuVXNlZCB0byBwcm92aWRlIHJhbmdlcyB0aGF0IHNob3VsZCBiZSB0cmVhdGVkIGFzIGF0b21zIGFzIGZhciBhc1xyXG5jdXJzb3IgbW90aW9uIGlzIGNvbmNlcm5lZC4gVGhpcyBjYXVzZXMgbWV0aG9kcyBsaWtlXHJcbltgbW92ZUJ5Q2hhcmBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5FZGl0b3JWaWV3Lm1vdmVCeUNoYXIpIGFuZFxyXG5bYG1vdmVWZXJ0aWNhbGx5YF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LkVkaXRvclZpZXcubW92ZVZlcnRpY2FsbHkpIChhbmQgdGhlXHJcbmNvbW1hbmRzIGJ1aWx0IG9uIHRvcCBvZiB0aGVtKSB0byBza2lwIGFjcm9zcyBzdWNoIHJlZ2lvbnMgd2hlblxyXG5hIHNlbGVjdGlvbiBlbmRwb2ludCB3b3VsZCBlbnRlciB0aGVtLiBUaGlzIGRvZXMgX25vdF8gcHJldmVudFxyXG5kaXJlY3QgcHJvZ3JhbW1hdGljIFtzZWxlY3Rpb25cclxudXBkYXRlc10oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5UcmFuc2FjdGlvblNwZWMuc2VsZWN0aW9uKSBmcm9tIG1vdmluZyBpbnRvIHN1Y2hcclxucmVnaW9ucy5cclxuKi9cclxuRWRpdG9yVmlldy5hdG9taWNSYW5nZXMgPSBhdG9taWNSYW5nZXM7XHJcbi8qKlxyXG5GYWNldCB0aGF0IGFsbG93cyBleHRlbnNpb25zIHRvIHByb3ZpZGUgYWRkaXRpb25hbCBzY3JvbGxcclxubWFyZ2lucyAoc3BhY2UgYXJvdW5kIHRoZSBzaWRlcyBvZiB0aGUgc2Nyb2xsaW5nIGVsZW1lbnQgdGhhdFxyXG5zaG91bGQgYmUgY29uc2lkZXJlZCBpbnZpc2libGUpLiBUaGlzIGNhbiBiZSB1c2VmdWwgd2hlbiB0aGVcclxucGx1Z2luIGludHJvZHVjZXMgZWxlbWVudHMgdGhhdCBjb3ZlciBwYXJ0IG9mIHRoYXQgZWxlbWVudCAoZm9yXHJcbmV4YW1wbGUgYSBob3Jpem9udGFsbHkgZml4ZWQgZ3V0dGVyKS5cclxuKi9cclxuRWRpdG9yVmlldy5zY3JvbGxNYXJnaW5zID0gc2Nyb2xsTWFyZ2lucztcclxuLyoqXHJcblRoaXMgZmFjZXQgcmVjb3JkcyB3aGV0aGVyIGEgZGFyayB0aGVtZSBpcyBhY3RpdmUuIFRoZSBleHRlbnNpb25cclxucmV0dXJuZWQgYnkgW2B0aGVtZWBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5FZGl0b3JWaWV3XnRoZW1lKSBhdXRvbWF0aWNhbGx5XHJcbmluY2x1ZGVzIGFuIGluc3RhbmNlIG9mIHRoaXMgd2hlbiB0aGUgYGRhcmtgIG9wdGlvbiBpcyBzZXQgdG9cclxudHJ1ZS5cclxuKi9cclxuRWRpdG9yVmlldy5kYXJrVGhlbWUgPSBkYXJrVGhlbWU7XHJcbi8qKlxyXG5GYWNldCB0aGF0IHByb3ZpZGVzIGFkZGl0aW9uYWwgRE9NIGF0dHJpYnV0ZXMgZm9yIHRoZSBlZGl0b3Inc1xyXG5lZGl0YWJsZSBET00gZWxlbWVudC5cclxuKi9cclxuRWRpdG9yVmlldy5jb250ZW50QXR0cmlidXRlcyA9IGNvbnRlbnRBdHRyaWJ1dGVzO1xyXG4vKipcclxuRmFjZXQgdGhhdCBwcm92aWRlcyBET00gYXR0cmlidXRlcyBmb3IgdGhlIGVkaXRvcidzIG91dGVyXHJcbmVsZW1lbnQuXHJcbiovXHJcbkVkaXRvclZpZXcuZWRpdG9yQXR0cmlidXRlcyA9IGVkaXRvckF0dHJpYnV0ZXM7XHJcbi8qKlxyXG5BbiBleHRlbnNpb24gdGhhdCBlbmFibGVzIGxpbmUgd3JhcHBpbmcgaW4gdGhlIGVkaXRvciAoYnlcclxuc2V0dGluZyBDU1MgYHdoaXRlLXNwYWNlYCB0byBgcHJlLXdyYXBgIGluIHRoZSBjb250ZW50KS5cclxuKi9cclxuRWRpdG9yVmlldy5saW5lV3JhcHBpbmcgPSAvKkBfX1BVUkVfXyovRWRpdG9yVmlldy5jb250ZW50QXR0cmlidXRlcy5vZih7IFwiY2xhc3NcIjogXCJjbS1saW5lV3JhcHBpbmdcIiB9KTtcclxuLyoqXHJcblN0YXRlIGVmZmVjdCB1c2VkIHRvIGluY2x1ZGUgc2NyZWVuIHJlYWRlciBhbm5vdW5jZW1lbnRzIGluIGFcclxudHJhbnNhY3Rpb24uIFRoZXNlIHdpbGwgYmUgYWRkZWQgdG8gdGhlIERPTSBpbiBhIHZpc3VhbGx5IGhpZGRlblxyXG5lbGVtZW50IHdpdGggYGFyaWEtbGl2ZT1cInBvbGl0ZVwiYCBzZXQsIGFuZCBzaG91bGQgYmUgdXNlZCB0b1xyXG5kZXNjcmliZSBlZmZlY3RzIHRoYXQgYXJlIHZpc3VhbGx5IG9idmlvdXMgYnV0IG1heSBub3QgYmVcclxubm90aWNlZCBieSBzY3JlZW4gcmVhZGVyIHVzZXJzIChzdWNoIGFzIG1vdmluZyB0byB0aGUgbmV4dFxyXG5zZWFyY2ggbWF0Y2gpLlxyXG4qL1xyXG5FZGl0b3JWaWV3LmFubm91bmNlID0gLypAX19QVVJFX18qL1N0YXRlRWZmZWN0LmRlZmluZSgpO1xyXG4vLyBNYXhpbXVtIGxpbmUgbGVuZ3RoIGZvciB3aGljaCB3ZSBjb21wdXRlIGFjY3VyYXRlIGJpZGkgaW5mb1xyXG5jb25zdCBNYXhCaWRpTGluZSA9IDQwOTY7XHJcbmNvbnN0IEJhZE1lYXN1cmUgPSB7fTtcclxuY2xhc3MgQ2FjaGVkT3JkZXIge1xyXG4gICAgY29uc3RydWN0b3IoZnJvbSwgdG8sIGRpciwgb3JkZXIpIHtcclxuICAgICAgICB0aGlzLmZyb20gPSBmcm9tO1xyXG4gICAgICAgIHRoaXMudG8gPSB0bztcclxuICAgICAgICB0aGlzLmRpciA9IGRpcjtcclxuICAgICAgICB0aGlzLm9yZGVyID0gb3JkZXI7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgdXBkYXRlKGNhY2hlLCBjaGFuZ2VzKSB7XHJcbiAgICAgICAgaWYgKGNoYW5nZXMuZW1wdHkpXHJcbiAgICAgICAgICAgIHJldHVybiBjYWNoZTtcclxuICAgICAgICBsZXQgcmVzdWx0ID0gW10sIGxhc3REaXIgPSBjYWNoZS5sZW5ndGggPyBjYWNoZVtjYWNoZS5sZW5ndGggLSAxXS5kaXIgOiBEaXJlY3Rpb24uTFRSO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSBNYXRoLm1heCgwLCBjYWNoZS5sZW5ndGggLSAxMCk7IGkgPCBjYWNoZS5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBsZXQgZW50cnkgPSBjYWNoZVtpXTtcclxuICAgICAgICAgICAgaWYgKGVudHJ5LmRpciA9PSBsYXN0RGlyICYmICFjaGFuZ2VzLnRvdWNoZXNSYW5nZShlbnRyeS5mcm9tLCBlbnRyeS50bykpXHJcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChuZXcgQ2FjaGVkT3JkZXIoY2hhbmdlcy5tYXBQb3MoZW50cnkuZnJvbSwgMSksIGNoYW5nZXMubWFwUG9zKGVudHJ5LnRvLCAtMSksIGVudHJ5LmRpciwgZW50cnkub3JkZXIpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBhdHRyc0Zyb21GYWNldCh2aWV3LCBmYWNldCwgYmFzZSkge1xyXG4gICAgZm9yIChsZXQgc291cmNlcyA9IHZpZXcuc3RhdGUuZmFjZXQoZmFjZXQpLCBpID0gc291cmNlcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xyXG4gICAgICAgIGxldCBzb3VyY2UgPSBzb3VyY2VzW2ldLCB2YWx1ZSA9IHR5cGVvZiBzb3VyY2UgPT0gXCJmdW5jdGlvblwiID8gc291cmNlKHZpZXcpIDogc291cmNlO1xyXG4gICAgICAgIGlmICh2YWx1ZSlcclxuICAgICAgICAgICAgY29tYmluZUF0dHJzKHZhbHVlLCBiYXNlKTtcclxuICAgIH1cclxuICAgIHJldHVybiBiYXNlO1xyXG59XHJcblxyXG5jb25zdCBjdXJyZW50UGxhdGZvcm0gPSBicm93c2VyLm1hYyA/IFwibWFjXCIgOiBicm93c2VyLndpbmRvd3MgPyBcIndpblwiIDogYnJvd3Nlci5saW51eCA/IFwibGludXhcIiA6IFwia2V5XCI7XHJcbmZ1bmN0aW9uIG5vcm1hbGl6ZUtleU5hbWUobmFtZSwgcGxhdGZvcm0pIHtcclxuICAgIGNvbnN0IHBhcnRzID0gbmFtZS5zcGxpdCgvLSg/ISQpLyk7XHJcbiAgICBsZXQgcmVzdWx0ID0gcGFydHNbcGFydHMubGVuZ3RoIC0gMV07XHJcbiAgICBpZiAocmVzdWx0ID09IFwiU3BhY2VcIilcclxuICAgICAgICByZXN1bHQgPSBcIiBcIjtcclxuICAgIGxldCBhbHQsIGN0cmwsIHNoaWZ0LCBtZXRhO1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXJ0cy5sZW5ndGggLSAxOyArK2kpIHtcclxuICAgICAgICBjb25zdCBtb2QgPSBwYXJ0c1tpXTtcclxuICAgICAgICBpZiAoL14oY21kfG1ldGF8bSkkL2kudGVzdChtb2QpKVxyXG4gICAgICAgICAgICBtZXRhID0gdHJ1ZTtcclxuICAgICAgICBlbHNlIGlmICgvXmEobHQpPyQvaS50ZXN0KG1vZCkpXHJcbiAgICAgICAgICAgIGFsdCA9IHRydWU7XHJcbiAgICAgICAgZWxzZSBpZiAoL14oY3xjdHJsfGNvbnRyb2wpJC9pLnRlc3QobW9kKSlcclxuICAgICAgICAgICAgY3RybCA9IHRydWU7XHJcbiAgICAgICAgZWxzZSBpZiAoL15zKGhpZnQpPyQvaS50ZXN0KG1vZCkpXHJcbiAgICAgICAgICAgIHNoaWZ0ID0gdHJ1ZTtcclxuICAgICAgICBlbHNlIGlmICgvXm1vZCQvaS50ZXN0KG1vZCkpIHtcclxuICAgICAgICAgICAgaWYgKHBsYXRmb3JtID09IFwibWFjXCIpXHJcbiAgICAgICAgICAgICAgICBtZXRhID0gdHJ1ZTtcclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgY3RybCA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2VcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5yZWNvZ25pemVkIG1vZGlmaWVyIG5hbWU6IFwiICsgbW9kKTtcclxuICAgIH1cclxuICAgIGlmIChhbHQpXHJcbiAgICAgICAgcmVzdWx0ID0gXCJBbHQtXCIgKyByZXN1bHQ7XHJcbiAgICBpZiAoY3RybClcclxuICAgICAgICByZXN1bHQgPSBcIkN0cmwtXCIgKyByZXN1bHQ7XHJcbiAgICBpZiAobWV0YSlcclxuICAgICAgICByZXN1bHQgPSBcIk1ldGEtXCIgKyByZXN1bHQ7XHJcbiAgICBpZiAoc2hpZnQpXHJcbiAgICAgICAgcmVzdWx0ID0gXCJTaGlmdC1cIiArIHJlc3VsdDtcclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn1cclxuZnVuY3Rpb24gbW9kaWZpZXJzKG5hbWUsIGV2ZW50LCBzaGlmdCkge1xyXG4gICAgaWYgKGV2ZW50LmFsdEtleSlcclxuICAgICAgICBuYW1lID0gXCJBbHQtXCIgKyBuYW1lO1xyXG4gICAgaWYgKGV2ZW50LmN0cmxLZXkpXHJcbiAgICAgICAgbmFtZSA9IFwiQ3RybC1cIiArIG5hbWU7XHJcbiAgICBpZiAoZXZlbnQubWV0YUtleSlcclxuICAgICAgICBuYW1lID0gXCJNZXRhLVwiICsgbmFtZTtcclxuICAgIGlmIChzaGlmdCAhPT0gZmFsc2UgJiYgZXZlbnQuc2hpZnRLZXkpXHJcbiAgICAgICAgbmFtZSA9IFwiU2hpZnQtXCIgKyBuYW1lO1xyXG4gICAgcmV0dXJuIG5hbWU7XHJcbn1cclxuY29uc3QgaGFuZGxlS2V5RXZlbnRzID0gLypAX19QVVJFX18qL1ByZWMuZGVmYXVsdCgvKkBfX1BVUkVfXyovRWRpdG9yVmlldy5kb21FdmVudEhhbmRsZXJzKHtcclxuICAgIGtleWRvd24oZXZlbnQsIHZpZXcpIHtcclxuICAgICAgICByZXR1cm4gcnVuSGFuZGxlcnMoZ2V0S2V5bWFwKHZpZXcuc3RhdGUpLCBldmVudCwgdmlldywgXCJlZGl0b3JcIik7XHJcbiAgICB9XHJcbn0pKTtcclxuLyoqXHJcbkZhY2V0IHVzZWQgZm9yIHJlZ2lzdGVyaW5nIGtleW1hcHMuXHJcblxyXG5Zb3UgY2FuIGFkZCBtdWx0aXBsZSBrZXltYXBzIHRvIGFuIGVkaXRvci4gVGhlaXIgcHJpb3JpdGllc1xyXG5kZXRlcm1pbmUgdGhlaXIgcHJlY2VkZW5jZSAodGhlIG9uZXMgc3BlY2lmaWVkIGVhcmx5IG9yIHdpdGggaGlnaFxyXG5wcmlvcml0eSBnZXQgY2hlY2tlZCBmaXJzdCkuIFdoZW4gYSBoYW5kbGVyIGhhcyByZXR1cm5lZCBgdHJ1ZWBcclxuZm9yIGEgZ2l2ZW4ga2V5LCBubyBmdXJ0aGVyIGhhbmRsZXJzIGFyZSBjYWxsZWQuXHJcbiovXHJcbmNvbnN0IGtleW1hcCA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoeyBlbmFibGVzOiBoYW5kbGVLZXlFdmVudHMgfSk7XHJcbmNvbnN0IEtleW1hcHMgPSAvKkBfX1BVUkVfXyovbmV3IFdlYWtNYXAoKTtcclxuLy8gVGhpcyBpcyBoaWRkZW4gYmVoaW5kIGFuIGluZGlyZWN0aW9uLCByYXRoZXIgdGhhbiBkaXJlY3RseSBjb21wdXRlZFxyXG4vLyBieSB0aGUgZmFjZXQsIHRvIGtlZXAgaW50ZXJuYWwgdHlwZXMgb3V0IG9mIHRoZSBmYWNldCdzIHR5cGUuXHJcbmZ1bmN0aW9uIGdldEtleW1hcChzdGF0ZSkge1xyXG4gICAgbGV0IGJpbmRpbmdzID0gc3RhdGUuZmFjZXQoa2V5bWFwKTtcclxuICAgIGxldCBtYXAgPSBLZXltYXBzLmdldChiaW5kaW5ncyk7XHJcbiAgICBpZiAoIW1hcClcclxuICAgICAgICBLZXltYXBzLnNldChiaW5kaW5ncywgbWFwID0gYnVpbGRLZXltYXAoYmluZGluZ3MucmVkdWNlKChhLCBiKSA9PiBhLmNvbmNhdChiKSwgW10pKSk7XHJcbiAgICByZXR1cm4gbWFwO1xyXG59XHJcbi8qKlxyXG5SdW4gdGhlIGtleSBoYW5kbGVycyByZWdpc3RlcmVkIGZvciBhIGdpdmVuIHNjb3BlLiBUaGUgZXZlbnRcclxub2JqZWN0IHNob3VsZCBiZSBhIGBcImtleWRvd25cImAgZXZlbnQuIFJldHVybnMgdHJ1ZSBpZiBhbnkgb2YgdGhlXHJcbmhhbmRsZXJzIGhhbmRsZWQgaXQuXHJcbiovXHJcbmZ1bmN0aW9uIHJ1blNjb3BlSGFuZGxlcnModmlldywgZXZlbnQsIHNjb3BlKSB7XHJcbiAgICByZXR1cm4gcnVuSGFuZGxlcnMoZ2V0S2V5bWFwKHZpZXcuc3RhdGUpLCBldmVudCwgdmlldywgc2NvcGUpO1xyXG59XHJcbmxldCBzdG9yZWRQcmVmaXggPSBudWxsO1xyXG5jb25zdCBQcmVmaXhUaW1lb3V0ID0gNDAwMDtcclxuZnVuY3Rpb24gYnVpbGRLZXltYXAoYmluZGluZ3MsIHBsYXRmb3JtID0gY3VycmVudFBsYXRmb3JtKSB7XHJcbiAgICBsZXQgYm91bmQgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xyXG4gICAgbGV0IGlzUHJlZml4ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcclxuICAgIGxldCBjaGVja1ByZWZpeCA9IChuYW1lLCBpcykgPT4ge1xyXG4gICAgICAgIGxldCBjdXJyZW50ID0gaXNQcmVmaXhbbmFtZV07XHJcbiAgICAgICAgaWYgKGN1cnJlbnQgPT0gbnVsbClcclxuICAgICAgICAgICAgaXNQcmVmaXhbbmFtZV0gPSBpcztcclxuICAgICAgICBlbHNlIGlmIChjdXJyZW50ICE9IGlzKVxyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJLZXkgYmluZGluZyBcIiArIG5hbWUgKyBcIiBpcyB1c2VkIGJvdGggYXMgYSByZWd1bGFyIGJpbmRpbmcgYW5kIGFzIGEgbXVsdGktc3Ryb2tlIHByZWZpeFwiKTtcclxuICAgIH07XHJcbiAgICBsZXQgYWRkID0gKHNjb3BlLCBrZXksIGNvbW1hbmQsIHByZXZlbnREZWZhdWx0KSA9PiB7XHJcbiAgICAgICAgdmFyIF9hLCBfYjtcclxuICAgICAgICBsZXQgc2NvcGVPYmogPSBib3VuZFtzY29wZV0gfHwgKGJvdW5kW3Njb3BlXSA9IE9iamVjdC5jcmVhdGUobnVsbCkpO1xyXG4gICAgICAgIGxldCBwYXJ0cyA9IGtleS5zcGxpdCgvICg/ISQpLykubWFwKGsgPT4gbm9ybWFsaXplS2V5TmFtZShrLCBwbGF0Zm9ybSkpO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgcGFydHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgbGV0IHByZWZpeCA9IHBhcnRzLnNsaWNlKDAsIGkpLmpvaW4oXCIgXCIpO1xyXG4gICAgICAgICAgICBjaGVja1ByZWZpeChwcmVmaXgsIHRydWUpO1xyXG4gICAgICAgICAgICBpZiAoIXNjb3BlT2JqW3ByZWZpeF0pXHJcbiAgICAgICAgICAgICAgICBzY29wZU9ialtwcmVmaXhdID0ge1xyXG4gICAgICAgICAgICAgICAgICAgIHByZXZlbnREZWZhdWx0OiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgICAgIHJ1bjogWyh2aWV3KSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgb3VyT2JqID0gc3RvcmVkUHJlZml4ID0geyB2aWV3LCBwcmVmaXgsIHNjb3BlIH07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHsgaWYgKHN0b3JlZFByZWZpeCA9PSBvdXJPYmopXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RvcmVkUHJlZml4ID0gbnVsbDsgfSwgUHJlZml4VGltZW91dCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfV1cclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCBmdWxsID0gcGFydHMuam9pbihcIiBcIik7XHJcbiAgICAgICAgY2hlY2tQcmVmaXgoZnVsbCwgZmFsc2UpO1xyXG4gICAgICAgIGxldCBiaW5kaW5nID0gc2NvcGVPYmpbZnVsbF0gfHwgKHNjb3BlT2JqW2Z1bGxdID0geyBwcmV2ZW50RGVmYXVsdDogZmFsc2UsIHJ1bjogKChfYiA9IChfYSA9IHNjb3BlT2JqLl9hbnkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5ydW4pID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5zbGljZSgpKSB8fCBbXSB9KTtcclxuICAgICAgICBpZiAoY29tbWFuZClcclxuICAgICAgICAgICAgYmluZGluZy5ydW4ucHVzaChjb21tYW5kKTtcclxuICAgICAgICBpZiAocHJldmVudERlZmF1bHQpXHJcbiAgICAgICAgICAgIGJpbmRpbmcucHJldmVudERlZmF1bHQgPSB0cnVlO1xyXG4gICAgfTtcclxuICAgIGZvciAobGV0IGIgb2YgYmluZGluZ3MpIHtcclxuICAgICAgICBsZXQgc2NvcGVzID0gYi5zY29wZSA/IGIuc2NvcGUuc3BsaXQoXCIgXCIpIDogW1wiZWRpdG9yXCJdO1xyXG4gICAgICAgIGlmIChiLmFueSlcclxuICAgICAgICAgICAgZm9yIChsZXQgc2NvcGUgb2Ygc2NvcGVzKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgc2NvcGVPYmogPSBib3VuZFtzY29wZV0gfHwgKGJvdW5kW3Njb3BlXSA9IE9iamVjdC5jcmVhdGUobnVsbCkpO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFzY29wZU9iai5fYW55KVxyXG4gICAgICAgICAgICAgICAgICAgIHNjb3BlT2JqLl9hbnkgPSB7IHByZXZlbnREZWZhdWx0OiBmYWxzZSwgcnVuOiBbXSB9O1xyXG4gICAgICAgICAgICAgICAgZm9yIChsZXQga2V5IGluIHNjb3BlT2JqKVxyXG4gICAgICAgICAgICAgICAgICAgIHNjb3BlT2JqW2tleV0ucnVuLnB1c2goYi5hbnkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgbGV0IG5hbWUgPSBiW3BsYXRmb3JtXSB8fCBiLmtleTtcclxuICAgICAgICBpZiAoIW5hbWUpXHJcbiAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgIGZvciAobGV0IHNjb3BlIG9mIHNjb3Blcykge1xyXG4gICAgICAgICAgICBhZGQoc2NvcGUsIG5hbWUsIGIucnVuLCBiLnByZXZlbnREZWZhdWx0KTtcclxuICAgICAgICAgICAgaWYgKGIuc2hpZnQpXHJcbiAgICAgICAgICAgICAgICBhZGQoc2NvcGUsIFwiU2hpZnQtXCIgKyBuYW1lLCBiLnNoaWZ0LCBiLnByZXZlbnREZWZhdWx0KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gYm91bmQ7XHJcbn1cclxuZnVuY3Rpb24gcnVuSGFuZGxlcnMobWFwLCBldmVudCwgdmlldywgc2NvcGUpIHtcclxuICAgIGxldCBuYW1lID0ga2V5TmFtZShldmVudCk7XHJcbiAgICBsZXQgY2hhckNvZGUgPSBjb2RlUG9pbnRBdChuYW1lLCAwKSwgaXNDaGFyID0gY29kZVBvaW50U2l6ZShjaGFyQ29kZSkgPT0gbmFtZS5sZW5ndGggJiYgbmFtZSAhPSBcIiBcIjtcclxuICAgIGxldCBwcmVmaXggPSBcIlwiLCBmYWxsdGhyb3VnaCA9IGZhbHNlO1xyXG4gICAgaWYgKHN0b3JlZFByZWZpeCAmJiBzdG9yZWRQcmVmaXgudmlldyA9PSB2aWV3ICYmIHN0b3JlZFByZWZpeC5zY29wZSA9PSBzY29wZSkge1xyXG4gICAgICAgIHByZWZpeCA9IHN0b3JlZFByZWZpeC5wcmVmaXggKyBcIiBcIjtcclxuICAgICAgICBpZiAoZmFsbHRocm91Z2ggPSBtb2RpZmllckNvZGVzLmluZGV4T2YoZXZlbnQua2V5Q29kZSkgPCAwKVxyXG4gICAgICAgICAgICBzdG9yZWRQcmVmaXggPSBudWxsO1xyXG4gICAgfVxyXG4gICAgbGV0IHJhbiA9IG5ldyBTZXQ7XHJcbiAgICBsZXQgcnVuRm9yID0gKGJpbmRpbmcpID0+IHtcclxuICAgICAgICBpZiAoYmluZGluZykge1xyXG4gICAgICAgICAgICBmb3IgKGxldCBjbWQgb2YgYmluZGluZy5ydW4pXHJcbiAgICAgICAgICAgICAgICBpZiAoIXJhbi5oYXMoY21kKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJhbi5hZGQoY21kKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoY21kKHZpZXcsIGV2ZW50KSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChiaW5kaW5nLnByZXZlbnREZWZhdWx0KVxyXG4gICAgICAgICAgICAgICAgZmFsbHRocm91Z2ggPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9O1xyXG4gICAgbGV0IHNjb3BlT2JqID0gbWFwW3Njb3BlXSwgYmFzZU5hbWUsIHNoaWZ0TmFtZTtcclxuICAgIGlmIChzY29wZU9iaikge1xyXG4gICAgICAgIGlmIChydW5Gb3Ioc2NvcGVPYmpbcHJlZml4ICsgbW9kaWZpZXJzKG5hbWUsIGV2ZW50LCAhaXNDaGFyKV0pKVxyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICBpZiAoaXNDaGFyICYmIChldmVudC5hbHRLZXkgfHwgZXZlbnQubWV0YUtleSB8fCBldmVudC5jdHJsS2V5KSAmJlxyXG4gICAgICAgICAgICAvLyBDdHJsLUFsdCBtYXkgYmUgdXNlZCBmb3IgQWx0R3Igb24gV2luZG93c1xyXG4gICAgICAgICAgICAhKGJyb3dzZXIud2luZG93cyAmJiBldmVudC5jdHJsS2V5ICYmIGV2ZW50LmFsdEtleSkgJiZcclxuICAgICAgICAgICAgKGJhc2VOYW1lID0gYmFzZVtldmVudC5rZXlDb2RlXSkgJiYgYmFzZU5hbWUgIT0gbmFtZSkge1xyXG4gICAgICAgICAgICBpZiAocnVuRm9yKHNjb3BlT2JqW3ByZWZpeCArIG1vZGlmaWVycyhiYXNlTmFtZSwgZXZlbnQsIHRydWUpXSkpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgZWxzZSBpZiAoZXZlbnQuc2hpZnRLZXkgJiYgKHNoaWZ0TmFtZSA9IHNoaWZ0W2V2ZW50LmtleUNvZGVdKSAhPSBuYW1lICYmIHNoaWZ0TmFtZSAhPSBiYXNlTmFtZSAmJlxyXG4gICAgICAgICAgICAgICAgcnVuRm9yKHNjb3BlT2JqW3ByZWZpeCArIG1vZGlmaWVycyhzaGlmdE5hbWUsIGV2ZW50LCBmYWxzZSldKSlcclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChpc0NoYXIgJiYgZXZlbnQuc2hpZnRLZXkpIHtcclxuICAgICAgICAgICAgaWYgKHJ1bkZvcihzY29wZU9ialtwcmVmaXggKyBtb2RpZmllcnMobmFtZSwgZXZlbnQsIHRydWUpXSkpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHJ1bkZvcihzY29wZU9iai5fYW55KSlcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZmFsbHRocm91Z2g7XHJcbn1cclxuXHJcbi8qKlxyXG5JbXBsZW1lbnRhdGlvbiBvZiBbYExheWVyTWFya2VyYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LkxheWVyTWFya2VyKSB0aGF0IGNyZWF0ZXNcclxuYSByZWN0YW5nbGUgYXQgYSBnaXZlbiBzZXQgb2YgY29vcmRpbmF0ZXMuXHJcbiovXHJcbmNsYXNzIFJlY3RhbmdsZU1hcmtlciB7XHJcbiAgICAvKipcclxuICAgIENyZWF0ZSBhIG1hcmtlciB3aXRoIHRoZSBnaXZlbiBjbGFzcyBhbmQgZGltZW5zaW9ucy4gSWYgYHdpZHRoYFxyXG4gICAgaXMgbnVsbCwgdGhlIERPTSBlbGVtZW50IHdpbGwgZ2V0IG5vIHdpZHRoIHN0eWxlLlxyXG4gICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKGNsYXNzTmFtZSwgbGVmdCwgdG9wLCB3aWR0aCwgaGVpZ2h0KSB7XHJcbiAgICAgICAgdGhpcy5jbGFzc05hbWUgPSBjbGFzc05hbWU7XHJcbiAgICAgICAgdGhpcy5sZWZ0ID0gbGVmdDtcclxuICAgICAgICB0aGlzLnRvcCA9IHRvcDtcclxuICAgICAgICB0aGlzLndpZHRoID0gd2lkdGg7XHJcbiAgICAgICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XHJcbiAgICB9XHJcbiAgICBkcmF3KCkge1xyXG4gICAgICAgIGxldCBlbHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xyXG4gICAgICAgIGVsdC5jbGFzc05hbWUgPSB0aGlzLmNsYXNzTmFtZTtcclxuICAgICAgICB0aGlzLmFkanVzdChlbHQpO1xyXG4gICAgICAgIHJldHVybiBlbHQ7XHJcbiAgICB9XHJcbiAgICB1cGRhdGUoZWx0LCBwcmV2KSB7XHJcbiAgICAgICAgaWYgKHByZXYuY2xhc3NOYW1lICE9IHRoaXMuY2xhc3NOYW1lKVxyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5hZGp1c3QoZWx0KTtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICAgIGFkanVzdChlbHQpIHtcclxuICAgICAgICBlbHQuc3R5bGUubGVmdCA9IHRoaXMubGVmdCArIFwicHhcIjtcclxuICAgICAgICBlbHQuc3R5bGUudG9wID0gdGhpcy50b3AgKyBcInB4XCI7XHJcbiAgICAgICAgaWYgKHRoaXMud2lkdGggIT0gbnVsbClcclxuICAgICAgICAgICAgZWx0LnN0eWxlLndpZHRoID0gdGhpcy53aWR0aCArIFwicHhcIjtcclxuICAgICAgICBlbHQuc3R5bGUuaGVpZ2h0ID0gdGhpcy5oZWlnaHQgKyBcInB4XCI7XHJcbiAgICB9XHJcbiAgICBlcShwKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubGVmdCA9PSBwLmxlZnQgJiYgdGhpcy50b3AgPT0gcC50b3AgJiYgdGhpcy53aWR0aCA9PSBwLndpZHRoICYmIHRoaXMuaGVpZ2h0ID09IHAuaGVpZ2h0ICYmXHJcbiAgICAgICAgICAgIHRoaXMuY2xhc3NOYW1lID09IHAuY2xhc3NOYW1lO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICBDcmVhdGUgYSBzZXQgb2YgcmVjdGFuZ2xlcyBmb3IgdGhlIGdpdmVuIHNlbGVjdGlvbiByYW5nZSxcclxuICAgIGFzc2lnbmluZyB0aGVtIHRoZWNsYXNzYGNsYXNzTmFtZWAuIFdpbGwgY3JlYXRlIGEgc2luZ2xlXHJcbiAgICByZWN0YW5nbGUgZm9yIGVtcHR5IHJhbmdlcywgYW5kIGEgc2V0IG9mIHNlbGVjdGlvbi1zdHlsZVxyXG4gICAgcmVjdGFuZ2xlcyBjb3ZlcmluZyB0aGUgcmFuZ2UncyBjb250ZW50IChpbiBhIGJpZGktYXdhcmVcclxuICAgIHdheSkgZm9yIG5vbi1lbXB0eSBvbmVzLlxyXG4gICAgKi9cclxuICAgIHN0YXRpYyBmb3JSYW5nZSh2aWV3LCBjbGFzc05hbWUsIHJhbmdlKSB7XHJcbiAgICAgICAgaWYgKHJhbmdlLmVtcHR5KSB7XHJcbiAgICAgICAgICAgIGxldCBwb3MgPSB2aWV3LmNvb3Jkc0F0UG9zKHJhbmdlLmhlYWQsIHJhbmdlLmFzc29jIHx8IDEpO1xyXG4gICAgICAgICAgICBpZiAoIXBvcylcclxuICAgICAgICAgICAgICAgIHJldHVybiBbXTtcclxuICAgICAgICAgICAgbGV0IGJhc2UgPSBnZXRCYXNlKHZpZXcpO1xyXG4gICAgICAgICAgICByZXR1cm4gW25ldyBSZWN0YW5nbGVNYXJrZXIoY2xhc3NOYW1lLCBwb3MubGVmdCAtIGJhc2UubGVmdCwgcG9zLnRvcCAtIGJhc2UudG9wLCBudWxsLCBwb3MuYm90dG9tIC0gcG9zLnRvcCldO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIHJlY3RhbmdsZXNGb3JSYW5nZSh2aWV3LCBjbGFzc05hbWUsIHJhbmdlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gZ2V0QmFzZSh2aWV3KSB7XHJcbiAgICBsZXQgcmVjdCA9IHZpZXcuc2Nyb2xsRE9NLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xyXG4gICAgbGV0IGxlZnQgPSB2aWV3LnRleHREaXJlY3Rpb24gPT0gRGlyZWN0aW9uLkxUUiA/IHJlY3QubGVmdCA6IHJlY3QucmlnaHQgLSB2aWV3LnNjcm9sbERPTS5jbGllbnRXaWR0aDtcclxuICAgIHJldHVybiB7IGxlZnQ6IGxlZnQgLSB2aWV3LnNjcm9sbERPTS5zY3JvbGxMZWZ0LCB0b3A6IHJlY3QudG9wIC0gdmlldy5zY3JvbGxET00uc2Nyb2xsVG9wIH07XHJcbn1cclxuZnVuY3Rpb24gd3JhcHBlZExpbmUodmlldywgcG9zLCBpbnNpZGUpIHtcclxuICAgIGxldCByYW5nZSA9IEVkaXRvclNlbGVjdGlvbi5jdXJzb3IocG9zKTtcclxuICAgIHJldHVybiB7IGZyb206IE1hdGgubWF4KGluc2lkZS5mcm9tLCB2aWV3Lm1vdmVUb0xpbmVCb3VuZGFyeShyYW5nZSwgZmFsc2UsIHRydWUpLmZyb20pLFxyXG4gICAgICAgIHRvOiBNYXRoLm1pbihpbnNpZGUudG8sIHZpZXcubW92ZVRvTGluZUJvdW5kYXJ5KHJhbmdlLCB0cnVlLCB0cnVlKS5mcm9tKSxcclxuICAgICAgICB0eXBlOiBCbG9ja1R5cGUuVGV4dCB9O1xyXG59XHJcbmZ1bmN0aW9uIGJsb2NrQXQodmlldywgcG9zKSB7XHJcbiAgICBsZXQgbGluZSA9IHZpZXcubGluZUJsb2NrQXQocG9zKTtcclxuICAgIGlmIChBcnJheS5pc0FycmF5KGxpbmUudHlwZSkpXHJcbiAgICAgICAgZm9yIChsZXQgbCBvZiBsaW5lLnR5cGUpIHtcclxuICAgICAgICAgICAgaWYgKGwudG8gPiBwb3MgfHwgbC50byA9PSBwb3MgJiYgKGwudG8gPT0gbGluZS50byB8fCBsLnR5cGUgPT0gQmxvY2tUeXBlLlRleHQpKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGw7XHJcbiAgICAgICAgfVxyXG4gICAgcmV0dXJuIGxpbmU7XHJcbn1cclxuZnVuY3Rpb24gcmVjdGFuZ2xlc0ZvclJhbmdlKHZpZXcsIGNsYXNzTmFtZSwgcmFuZ2UpIHtcclxuICAgIGlmIChyYW5nZS50byA8PSB2aWV3LnZpZXdwb3J0LmZyb20gfHwgcmFuZ2UuZnJvbSA+PSB2aWV3LnZpZXdwb3J0LnRvKVxyXG4gICAgICAgIHJldHVybiBbXTtcclxuICAgIGxldCBmcm9tID0gTWF0aC5tYXgocmFuZ2UuZnJvbSwgdmlldy52aWV3cG9ydC5mcm9tKSwgdG8gPSBNYXRoLm1pbihyYW5nZS50bywgdmlldy52aWV3cG9ydC50byk7XHJcbiAgICBsZXQgbHRyID0gdmlldy50ZXh0RGlyZWN0aW9uID09IERpcmVjdGlvbi5MVFI7XHJcbiAgICBsZXQgY29udGVudCA9IHZpZXcuY29udGVudERPTSwgY29udGVudFJlY3QgPSBjb250ZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLCBiYXNlID0gZ2V0QmFzZSh2aWV3KTtcclxuICAgIGxldCBsaW5lU3R5bGUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShjb250ZW50LmZpcnN0Q2hpbGQpO1xyXG4gICAgbGV0IGxlZnRTaWRlID0gY29udGVudFJlY3QubGVmdCArIHBhcnNlSW50KGxpbmVTdHlsZS5wYWRkaW5nTGVmdCkgKyBNYXRoLm1pbigwLCBwYXJzZUludChsaW5lU3R5bGUudGV4dEluZGVudCkpO1xyXG4gICAgbGV0IHJpZ2h0U2lkZSA9IGNvbnRlbnRSZWN0LnJpZ2h0IC0gcGFyc2VJbnQobGluZVN0eWxlLnBhZGRpbmdSaWdodCk7XHJcbiAgICBsZXQgc3RhcnRCbG9jayA9IGJsb2NrQXQodmlldywgZnJvbSksIGVuZEJsb2NrID0gYmxvY2tBdCh2aWV3LCB0byk7XHJcbiAgICBsZXQgdmlzdWFsU3RhcnQgPSBzdGFydEJsb2NrLnR5cGUgPT0gQmxvY2tUeXBlLlRleHQgPyBzdGFydEJsb2NrIDogbnVsbDtcclxuICAgIGxldCB2aXN1YWxFbmQgPSBlbmRCbG9jay50eXBlID09IEJsb2NrVHlwZS5UZXh0ID8gZW5kQmxvY2sgOiBudWxsO1xyXG4gICAgaWYgKHZpZXcubGluZVdyYXBwaW5nKSB7XHJcbiAgICAgICAgaWYgKHZpc3VhbFN0YXJ0KVxyXG4gICAgICAgICAgICB2aXN1YWxTdGFydCA9IHdyYXBwZWRMaW5lKHZpZXcsIGZyb20sIHZpc3VhbFN0YXJ0KTtcclxuICAgICAgICBpZiAodmlzdWFsRW5kKVxyXG4gICAgICAgICAgICB2aXN1YWxFbmQgPSB3cmFwcGVkTGluZSh2aWV3LCB0bywgdmlzdWFsRW5kKTtcclxuICAgIH1cclxuICAgIGlmICh2aXN1YWxTdGFydCAmJiB2aXN1YWxFbmQgJiYgdmlzdWFsU3RhcnQuZnJvbSA9PSB2aXN1YWxFbmQuZnJvbSkge1xyXG4gICAgICAgIHJldHVybiBwaWVjZXMoZHJhd0ZvckxpbmUocmFuZ2UuZnJvbSwgcmFuZ2UudG8sIHZpc3VhbFN0YXJ0KSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBsZXQgdG9wID0gdmlzdWFsU3RhcnQgPyBkcmF3Rm9yTGluZShyYW5nZS5mcm9tLCBudWxsLCB2aXN1YWxTdGFydCkgOiBkcmF3Rm9yV2lkZ2V0KHN0YXJ0QmxvY2ssIGZhbHNlKTtcclxuICAgICAgICBsZXQgYm90dG9tID0gdmlzdWFsRW5kID8gZHJhd0ZvckxpbmUobnVsbCwgcmFuZ2UudG8sIHZpc3VhbEVuZCkgOiBkcmF3Rm9yV2lkZ2V0KGVuZEJsb2NrLCB0cnVlKTtcclxuICAgICAgICBsZXQgYmV0d2VlbiA9IFtdO1xyXG4gICAgICAgIGlmICgodmlzdWFsU3RhcnQgfHwgc3RhcnRCbG9jaykudG8gPCAodmlzdWFsRW5kIHx8IGVuZEJsb2NrKS5mcm9tIC0gMSlcclxuICAgICAgICAgICAgYmV0d2Vlbi5wdXNoKHBpZWNlKGxlZnRTaWRlLCB0b3AuYm90dG9tLCByaWdodFNpZGUsIGJvdHRvbS50b3ApKTtcclxuICAgICAgICBlbHNlIGlmICh0b3AuYm90dG9tIDwgYm90dG9tLnRvcCAmJiB2aWV3LmVsZW1lbnRBdEhlaWdodCgodG9wLmJvdHRvbSArIGJvdHRvbS50b3ApIC8gMikudHlwZSA9PSBCbG9ja1R5cGUuVGV4dClcclxuICAgICAgICAgICAgdG9wLmJvdHRvbSA9IGJvdHRvbS50b3AgPSAodG9wLmJvdHRvbSArIGJvdHRvbS50b3ApIC8gMjtcclxuICAgICAgICByZXR1cm4gcGllY2VzKHRvcCkuY29uY2F0KGJldHdlZW4pLmNvbmNhdChwaWVjZXMoYm90dG9tKSk7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBwaWVjZShsZWZ0LCB0b3AsIHJpZ2h0LCBib3R0b20pIHtcclxuICAgICAgICByZXR1cm4gbmV3IFJlY3RhbmdsZU1hcmtlcihjbGFzc05hbWUsIGxlZnQgLSBiYXNlLmxlZnQsIHRvcCAtIGJhc2UudG9wIC0gMC4wMSAvKiBDLkVwc2lsb24gKi8sIHJpZ2h0IC0gbGVmdCwgYm90dG9tIC0gdG9wICsgMC4wMSAvKiBDLkVwc2lsb24gKi8pO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gcGllY2VzKHsgdG9wLCBib3R0b20sIGhvcml6b250YWwgfSkge1xyXG4gICAgICAgIGxldCBwaWVjZXMgPSBbXTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGhvcml6b250YWwubGVuZ3RoOyBpICs9IDIpXHJcbiAgICAgICAgICAgIHBpZWNlcy5wdXNoKHBpZWNlKGhvcml6b250YWxbaV0sIHRvcCwgaG9yaXpvbnRhbFtpICsgMV0sIGJvdHRvbSkpO1xyXG4gICAgICAgIHJldHVybiBwaWVjZXM7XHJcbiAgICB9XHJcbiAgICAvLyBHZXRzIHBhc3NlZCBmcm9tL3RvIGluIGxpbmUtbG9jYWwgcG9zaXRpb25zXHJcbiAgICBmdW5jdGlvbiBkcmF3Rm9yTGluZShmcm9tLCB0bywgbGluZSkge1xyXG4gICAgICAgIGxldCB0b3AgPSAxZTksIGJvdHRvbSA9IC0xZTksIGhvcml6b250YWwgPSBbXTtcclxuICAgICAgICBmdW5jdGlvbiBhZGRTcGFuKGZyb20sIGZyb21PcGVuLCB0bywgdG9PcGVuLCBkaXIpIHtcclxuICAgICAgICAgICAgLy8gUGFzc2luZyAyLy0yIGlzIGEga2x1ZGdlIHRvIGZvcmNlIHRoZSB2aWV3IHRvIHJldHVyblxyXG4gICAgICAgICAgICAvLyBjb29yZGluYXRlcyBvbiB0aGUgcHJvcGVyIHNpZGUgb2YgYmxvY2sgd2lkZ2V0cywgc2luY2VcclxuICAgICAgICAgICAgLy8gbm9ybWFsaXppbmcgdGhlIHNpZGUgdGhlcmUsIHRob3VnaCBhcHByb3ByaWF0ZSBmb3IgbW9zdFxyXG4gICAgICAgICAgICAvLyBjb29yZHNBdFBvcyBxdWVyaWVzLCB3b3VsZCBicmVhayBzZWxlY3Rpb24gZHJhd2luZy5cclxuICAgICAgICAgICAgbGV0IGZyb21Db29yZHMgPSB2aWV3LmNvb3Jkc0F0UG9zKGZyb20sIChmcm9tID09IGxpbmUudG8gPyAtMiA6IDIpKTtcclxuICAgICAgICAgICAgbGV0IHRvQ29vcmRzID0gdmlldy5jb29yZHNBdFBvcyh0bywgKHRvID09IGxpbmUuZnJvbSA/IDIgOiAtMikpO1xyXG4gICAgICAgICAgICB0b3AgPSBNYXRoLm1pbihmcm9tQ29vcmRzLnRvcCwgdG9Db29yZHMudG9wLCB0b3ApO1xyXG4gICAgICAgICAgICBib3R0b20gPSBNYXRoLm1heChmcm9tQ29vcmRzLmJvdHRvbSwgdG9Db29yZHMuYm90dG9tLCBib3R0b20pO1xyXG4gICAgICAgICAgICBpZiAoZGlyID09IERpcmVjdGlvbi5MVFIpXHJcbiAgICAgICAgICAgICAgICBob3Jpem9udGFsLnB1c2gobHRyICYmIGZyb21PcGVuID8gbGVmdFNpZGUgOiBmcm9tQ29vcmRzLmxlZnQsIGx0ciAmJiB0b09wZW4gPyByaWdodFNpZGUgOiB0b0Nvb3Jkcy5yaWdodCk7XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgIGhvcml6b250YWwucHVzaCghbHRyICYmIHRvT3BlbiA/IGxlZnRTaWRlIDogdG9Db29yZHMubGVmdCwgIWx0ciAmJiBmcm9tT3BlbiA/IHJpZ2h0U2lkZSA6IGZyb21Db29yZHMucmlnaHQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgc3RhcnQgPSBmcm9tICE9PSBudWxsICYmIGZyb20gIT09IHZvaWQgMCA/IGZyb20gOiBsaW5lLmZyb20sIGVuZCA9IHRvICE9PSBudWxsICYmIHRvICE9PSB2b2lkIDAgPyB0byA6IGxpbmUudG87XHJcbiAgICAgICAgLy8gU3BsaXQgdGhlIHJhbmdlIGJ5IHZpc2libGUgcmFuZ2UgYW5kIGRvY3VtZW50IGxpbmVcclxuICAgICAgICBmb3IgKGxldCByIG9mIHZpZXcudmlzaWJsZVJhbmdlcylcclxuICAgICAgICAgICAgaWYgKHIudG8gPiBzdGFydCAmJiByLmZyb20gPCBlbmQpIHtcclxuICAgICAgICAgICAgICAgIGZvciAobGV0IHBvcyA9IE1hdGgubWF4KHIuZnJvbSwgc3RhcnQpLCBlbmRQb3MgPSBNYXRoLm1pbihyLnRvLCBlbmQpOzspIHtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgZG9jTGluZSA9IHZpZXcuc3RhdGUuZG9jLmxpbmVBdChwb3MpO1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IHNwYW4gb2Ygdmlldy5iaWRpU3BhbnMoZG9jTGluZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHNwYW5Gcm9tID0gc3Bhbi5mcm9tICsgZG9jTGluZS5mcm9tLCBzcGFuVG8gPSBzcGFuLnRvICsgZG9jTGluZS5mcm9tO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3BhbkZyb20gPj0gZW5kUG9zKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzcGFuVG8gPiBwb3MpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZGRTcGFuKE1hdGgubWF4KHNwYW5Gcm9tLCBwb3MpLCBmcm9tID09IG51bGwgJiYgc3BhbkZyb20gPD0gc3RhcnQsIE1hdGgubWluKHNwYW5UbywgZW5kUG9zKSwgdG8gPT0gbnVsbCAmJiBzcGFuVG8gPj0gZW5kLCBzcGFuLmRpcik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHBvcyA9IGRvY0xpbmUudG8gKyAxO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChwb3MgPj0gZW5kUG9zKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIGlmIChob3Jpem9udGFsLmxlbmd0aCA9PSAwKVxyXG4gICAgICAgICAgICBhZGRTcGFuKHN0YXJ0LCBmcm9tID09IG51bGwsIGVuZCwgdG8gPT0gbnVsbCwgdmlldy50ZXh0RGlyZWN0aW9uKTtcclxuICAgICAgICByZXR1cm4geyB0b3AsIGJvdHRvbSwgaG9yaXpvbnRhbCB9O1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gZHJhd0ZvcldpZGdldChibG9jaywgdG9wKSB7XHJcbiAgICAgICAgbGV0IHkgPSBjb250ZW50UmVjdC50b3AgKyAodG9wID8gYmxvY2sudG9wIDogYmxvY2suYm90dG9tKTtcclxuICAgICAgICByZXR1cm4geyB0b3A6IHksIGJvdHRvbTogeSwgaG9yaXpvbnRhbDogW10gfTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBzYW1lTWFya2VyKGEsIGIpIHtcclxuICAgIHJldHVybiBhLmNvbnN0cnVjdG9yID09IGIuY29uc3RydWN0b3IgJiYgYS5lcShiKTtcclxufVxyXG5jbGFzcyBMYXllclZpZXcge1xyXG4gICAgY29uc3RydWN0b3IodmlldywgbGF5ZXIpIHtcclxuICAgICAgICB0aGlzLnZpZXcgPSB2aWV3O1xyXG4gICAgICAgIHRoaXMubGF5ZXIgPSBsYXllcjtcclxuICAgICAgICB0aGlzLmRyYXduID0gW107XHJcbiAgICAgICAgdGhpcy5tZWFzdXJlUmVxID0geyByZWFkOiB0aGlzLm1lYXN1cmUuYmluZCh0aGlzKSwgd3JpdGU6IHRoaXMuZHJhdy5iaW5kKHRoaXMpIH07XHJcbiAgICAgICAgdGhpcy5kb20gPSB2aWV3LnNjcm9sbERPTS5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpKTtcclxuICAgICAgICB0aGlzLmRvbS5jbGFzc0xpc3QuYWRkKFwiY20tbGF5ZXJcIik7XHJcbiAgICAgICAgaWYgKGxheWVyLmFib3ZlKVxyXG4gICAgICAgICAgICB0aGlzLmRvbS5jbGFzc0xpc3QuYWRkKFwiY20tbGF5ZXItYWJvdmVcIik7XHJcbiAgICAgICAgaWYgKGxheWVyLmNsYXNzKVxyXG4gICAgICAgICAgICB0aGlzLmRvbS5jbGFzc0xpc3QuYWRkKGxheWVyLmNsYXNzKTtcclxuICAgICAgICB0aGlzLmRvbS5zZXRBdHRyaWJ1dGUoXCJhcmlhLWhpZGRlblwiLCBcInRydWVcIik7XHJcbiAgICAgICAgdGhpcy5zZXRPcmRlcih2aWV3LnN0YXRlKTtcclxuICAgICAgICB2aWV3LnJlcXVlc3RNZWFzdXJlKHRoaXMubWVhc3VyZVJlcSk7XHJcbiAgICAgICAgaWYgKGxheWVyLm1vdW50KVxyXG4gICAgICAgICAgICBsYXllci5tb3VudCh0aGlzLmRvbSwgdmlldyk7XHJcbiAgICB9XHJcbiAgICB1cGRhdGUodXBkYXRlKSB7XHJcbiAgICAgICAgaWYgKHVwZGF0ZS5zdGFydFN0YXRlLmZhY2V0KGxheWVyT3JkZXIpICE9IHVwZGF0ZS5zdGF0ZS5mYWNldChsYXllck9yZGVyKSlcclxuICAgICAgICAgICAgdGhpcy5zZXRPcmRlcih1cGRhdGUuc3RhdGUpO1xyXG4gICAgICAgIGlmICh0aGlzLmxheWVyLnVwZGF0ZSh1cGRhdGUsIHRoaXMuZG9tKSB8fCB1cGRhdGUuZ2VvbWV0cnlDaGFuZ2VkKVxyXG4gICAgICAgICAgICB1cGRhdGUudmlldy5yZXF1ZXN0TWVhc3VyZSh0aGlzLm1lYXN1cmVSZXEpO1xyXG4gICAgfVxyXG4gICAgc2V0T3JkZXIoc3RhdGUpIHtcclxuICAgICAgICBsZXQgcG9zID0gMCwgb3JkZXIgPSBzdGF0ZS5mYWNldChsYXllck9yZGVyKTtcclxuICAgICAgICB3aGlsZSAocG9zIDwgb3JkZXIubGVuZ3RoICYmIG9yZGVyW3Bvc10gIT0gdGhpcy5sYXllcilcclxuICAgICAgICAgICAgcG9zKys7XHJcbiAgICAgICAgdGhpcy5kb20uc3R5bGUuekluZGV4ID0gU3RyaW5nKCh0aGlzLmxheWVyLmFib3ZlID8gMTUwIDogLTEpIC0gcG9zKTtcclxuICAgIH1cclxuICAgIG1lYXN1cmUoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubGF5ZXIubWFya2Vycyh0aGlzLnZpZXcpO1xyXG4gICAgfVxyXG4gICAgZHJhdyhtYXJrZXJzKSB7XHJcbiAgICAgICAgaWYgKG1hcmtlcnMubGVuZ3RoICE9IHRoaXMuZHJhd24ubGVuZ3RoIHx8IG1hcmtlcnMuc29tZSgocCwgaSkgPT4gIXNhbWVNYXJrZXIocCwgdGhpcy5kcmF3bltpXSkpKSB7XHJcbiAgICAgICAgICAgIGxldCBvbGQgPSB0aGlzLmRvbS5maXJzdENoaWxkLCBvbGRJID0gMDtcclxuICAgICAgICAgICAgZm9yIChsZXQgbWFya2VyIG9mIG1hcmtlcnMpIHtcclxuICAgICAgICAgICAgICAgIGlmIChtYXJrZXIudXBkYXRlICYmIG9sZCAmJiBtYXJrZXIuY29uc3RydWN0b3IgJiYgdGhpcy5kcmF3bltvbGRJXS5jb25zdHJ1Y3RvciAmJlxyXG4gICAgICAgICAgICAgICAgICAgIG1hcmtlci51cGRhdGUob2xkLCB0aGlzLmRyYXduW29sZEldKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIG9sZCA9IG9sZC5uZXh0U2libGluZztcclxuICAgICAgICAgICAgICAgICAgICBvbGRJKys7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRvbS5pbnNlcnRCZWZvcmUobWFya2VyLmRyYXcoKSwgb2xkKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB3aGlsZSAob2xkKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgbmV4dCA9IG9sZC5uZXh0U2libGluZztcclxuICAgICAgICAgICAgICAgIG9sZC5yZW1vdmUoKTtcclxuICAgICAgICAgICAgICAgIG9sZCA9IG5leHQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5kcmF3biA9IG1hcmtlcnM7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZGVzdHJveSgpIHtcclxuICAgICAgICBpZiAodGhpcy5sYXllci5kZXN0cm95KVxyXG4gICAgICAgICAgICB0aGlzLmxheWVyLmRlc3Ryb3kodGhpcy5kb20sIHRoaXMudmlldyk7XHJcbiAgICAgICAgdGhpcy5kb20ucmVtb3ZlKCk7XHJcbiAgICB9XHJcbn1cclxuY29uc3QgbGF5ZXJPcmRlciA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoKTtcclxuLyoqXHJcbkRlZmluZSBhIGxheWVyLlxyXG4qL1xyXG5mdW5jdGlvbiBsYXllcihjb25maWcpIHtcclxuICAgIHJldHVybiBbXHJcbiAgICAgICAgVmlld1BsdWdpbi5kZWZpbmUodiA9PiBuZXcgTGF5ZXJWaWV3KHYsIGNvbmZpZykpLFxyXG4gICAgICAgIGxheWVyT3JkZXIub2YoY29uZmlnKVxyXG4gICAgXTtcclxufVxyXG5cclxuY29uc3QgQ2FuSGlkZVByaW1hcnkgPSAhYnJvd3Nlci5pb3M7IC8vIEZJWE1FIHRlc3QgSUVcclxuY29uc3Qgc2VsZWN0aW9uQ29uZmlnID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSh7XHJcbiAgICBjb21iaW5lKGNvbmZpZ3MpIHtcclxuICAgICAgICByZXR1cm4gY29tYmluZUNvbmZpZyhjb25maWdzLCB7XHJcbiAgICAgICAgICAgIGN1cnNvckJsaW5rUmF0ZTogMTIwMCxcclxuICAgICAgICAgICAgZHJhd1JhbmdlQ3Vyc29yOiB0cnVlXHJcbiAgICAgICAgfSwge1xyXG4gICAgICAgICAgICBjdXJzb3JCbGlua1JhdGU6IChhLCBiKSA9PiBNYXRoLm1pbihhLCBiKSxcclxuICAgICAgICAgICAgZHJhd1JhbmdlQ3Vyc29yOiAoYSwgYikgPT4gYSB8fCBiXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbn0pO1xyXG4vKipcclxuUmV0dXJucyBhbiBleHRlbnNpb24gdGhhdCBoaWRlcyB0aGUgYnJvd3NlcidzIG5hdGl2ZSBzZWxlY3Rpb24gYW5kXHJcbmN1cnNvciwgcmVwbGFjaW5nIHRoZSBzZWxlY3Rpb24gd2l0aCBhIGJhY2tncm91bmQgYmVoaW5kIHRoZSB0ZXh0XHJcbih3aXRoIHRoZSBgY20tc2VsZWN0aW9uQmFja2dyb3VuZGAgY2xhc3MpLCBhbmQgdGhlXHJcbmN1cnNvcnMgd2l0aCBlbGVtZW50cyBvdmVybGFpZCBvdmVyIHRoZSBjb2RlICh1c2luZ1xyXG5gY20tY3Vyc29yLXByaW1hcnlgIGFuZCBgY20tY3Vyc29yLXNlY29uZGFyeWApLlxyXG5cclxuVGhpcyBhbGxvd3MgdGhlIGVkaXRvciB0byBkaXNwbGF5IHNlY29uZGFyeSBzZWxlY3Rpb24gcmFuZ2VzLCBhbmRcclxudGVuZHMgdG8gcHJvZHVjZSBhIHR5cGUgb2Ygc2VsZWN0aW9uIG1vcmUgaW4gbGluZSB3aXRoIHRoYXQgdXNlcnNcclxuZXhwZWN0IGluIGEgdGV4dCBlZGl0b3IgKHRoZSBuYXRpdmUgc2VsZWN0aW9uIHN0eWxpbmcgd2lsbCBvZnRlblxyXG5sZWF2ZSBnYXBzIGJldHdlZW4gbGluZXMgYW5kIHdvbid0IGZpbGwgdGhlIGhvcml6b250YWwgc3BhY2UgYWZ0ZXJcclxuYSBsaW5lIHdoZW4gdGhlIHNlbGVjdGlvbiBjb250aW51ZXMgcGFzdCBpdCkuXHJcblxyXG5JdCBkb2VzIGhhdmUgYSBwZXJmb3JtYW5jZSBjb3N0LCBpbiB0aGF0IGl0IHJlcXVpcmVzIGFuIGV4dHJhIERPTVxyXG5sYXlvdXQgY3ljbGUgZm9yIG1hbnkgdXBkYXRlcyAodGhlIHNlbGVjdGlvbiBpcyBkcmF3biBiYXNlZCBvbiBET01cclxubGF5b3V0IGluZm9ybWF0aW9uIHRoYXQncyBvbmx5IGF2YWlsYWJsZSBhZnRlciBsYXlpbmcgb3V0IHRoZVxyXG5jb250ZW50KS5cclxuKi9cclxuZnVuY3Rpb24gZHJhd1NlbGVjdGlvbihjb25maWcgPSB7fSkge1xyXG4gICAgcmV0dXJuIFtcclxuICAgICAgICBzZWxlY3Rpb25Db25maWcub2YoY29uZmlnKSxcclxuICAgICAgICBjdXJzb3JMYXllcixcclxuICAgICAgICBzZWxlY3Rpb25MYXllcixcclxuICAgICAgICBoaWRlTmF0aXZlU2VsZWN0aW9uLFxyXG4gICAgICAgIG5hdGl2ZVNlbGVjdGlvbkhpZGRlbi5vZih0cnVlKVxyXG4gICAgXTtcclxufVxyXG5mdW5jdGlvbiBjb25maWdDaGFuZ2VkKHVwZGF0ZSkge1xyXG4gICAgcmV0dXJuIHVwZGF0ZS5zdGFydFN0YXRlLmZhY2V0KHNlbGVjdGlvbkNvbmZpZykgIT0gdXBkYXRlLnN0YXRlLmZhY2V0KHNlbGVjdGlvbkNvbmZpZyk7XHJcbn1cclxuY29uc3QgY3Vyc29yTGF5ZXIgPSAvKkBfX1BVUkVfXyovbGF5ZXIoe1xyXG4gICAgYWJvdmU6IHRydWUsXHJcbiAgICBtYXJrZXJzKHZpZXcpIHtcclxuICAgICAgICBsZXQgeyBzdGF0ZSB9ID0gdmlldywgY29uZiA9IHN0YXRlLmZhY2V0KHNlbGVjdGlvbkNvbmZpZyk7XHJcbiAgICAgICAgbGV0IGN1cnNvcnMgPSBbXTtcclxuICAgICAgICBmb3IgKGxldCByIG9mIHN0YXRlLnNlbGVjdGlvbi5yYW5nZXMpIHtcclxuICAgICAgICAgICAgbGV0IHByaW0gPSByID09IHN0YXRlLnNlbGVjdGlvbi5tYWluO1xyXG4gICAgICAgICAgICBpZiAoci5lbXB0eSA/ICFwcmltIHx8IENhbkhpZGVQcmltYXJ5IDogY29uZi5kcmF3UmFuZ2VDdXJzb3IpIHtcclxuICAgICAgICAgICAgICAgIGxldCBjbGFzc05hbWUgPSBwcmltID8gXCJjbS1jdXJzb3IgY20tY3Vyc29yLXByaW1hcnlcIiA6IFwiY20tY3Vyc29yIGNtLWN1cnNvci1zZWNvbmRhcnlcIjtcclxuICAgICAgICAgICAgICAgIGxldCBjdXJzb3IgPSByLmVtcHR5ID8gciA6IEVkaXRvclNlbGVjdGlvbi5jdXJzb3Ioci5oZWFkLCByLmhlYWQgPiByLmFuY2hvciA/IC0xIDogMSk7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBwaWVjZSBvZiBSZWN0YW5nbGVNYXJrZXIuZm9yUmFuZ2UodmlldywgY2xhc3NOYW1lLCBjdXJzb3IpKVxyXG4gICAgICAgICAgICAgICAgICAgIGN1cnNvcnMucHVzaChwaWVjZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGN1cnNvcnM7XHJcbiAgICB9LFxyXG4gICAgdXBkYXRlKHVwZGF0ZSwgZG9tKSB7XHJcbiAgICAgICAgaWYgKHVwZGF0ZS50cmFuc2FjdGlvbnMuc29tZSh0ciA9PiB0ci5zZWxlY3Rpb24pKVxyXG4gICAgICAgICAgICBkb20uc3R5bGUuYW5pbWF0aW9uTmFtZSA9IGRvbS5zdHlsZS5hbmltYXRpb25OYW1lID09IFwiY20tYmxpbmtcIiA/IFwiY20tYmxpbmsyXCIgOiBcImNtLWJsaW5rXCI7XHJcbiAgICAgICAgbGV0IGNvbmZDaGFuZ2UgPSBjb25maWdDaGFuZ2VkKHVwZGF0ZSk7XHJcbiAgICAgICAgaWYgKGNvbmZDaGFuZ2UpXHJcbiAgICAgICAgICAgIHNldEJsaW5rUmF0ZSh1cGRhdGUuc3RhdGUsIGRvbSk7XHJcbiAgICAgICAgcmV0dXJuIHVwZGF0ZS5kb2NDaGFuZ2VkIHx8IHVwZGF0ZS5zZWxlY3Rpb25TZXQgfHwgY29uZkNoYW5nZTtcclxuICAgIH0sXHJcbiAgICBtb3VudChkb20sIHZpZXcpIHtcclxuICAgICAgICBzZXRCbGlua1JhdGUodmlldy5zdGF0ZSwgZG9tKTtcclxuICAgIH0sXHJcbiAgICBjbGFzczogXCJjbS1jdXJzb3JMYXllclwiXHJcbn0pO1xyXG5mdW5jdGlvbiBzZXRCbGlua1JhdGUoc3RhdGUsIGRvbSkge1xyXG4gICAgZG9tLnN0eWxlLmFuaW1hdGlvbkR1cmF0aW9uID0gc3RhdGUuZmFjZXQoc2VsZWN0aW9uQ29uZmlnKS5jdXJzb3JCbGlua1JhdGUgKyBcIm1zXCI7XHJcbn1cclxuY29uc3Qgc2VsZWN0aW9uTGF5ZXIgPSAvKkBfX1BVUkVfXyovbGF5ZXIoe1xyXG4gICAgYWJvdmU6IGZhbHNlLFxyXG4gICAgbWFya2Vycyh2aWV3KSB7XHJcbiAgICAgICAgcmV0dXJuIHZpZXcuc3RhdGUuc2VsZWN0aW9uLnJhbmdlcy5tYXAociA9PiByLmVtcHR5ID8gW10gOiBSZWN0YW5nbGVNYXJrZXIuZm9yUmFuZ2UodmlldywgXCJjbS1zZWxlY3Rpb25CYWNrZ3JvdW5kXCIsIHIpKVxyXG4gICAgICAgICAgICAucmVkdWNlKChhLCBiKSA9PiBhLmNvbmNhdChiKSk7XHJcbiAgICB9LFxyXG4gICAgdXBkYXRlKHVwZGF0ZSwgZG9tKSB7XHJcbiAgICAgICAgcmV0dXJuIHVwZGF0ZS5kb2NDaGFuZ2VkIHx8IHVwZGF0ZS5zZWxlY3Rpb25TZXQgfHwgdXBkYXRlLnZpZXdwb3J0Q2hhbmdlZCB8fCBjb25maWdDaGFuZ2VkKHVwZGF0ZSk7XHJcbiAgICB9LFxyXG4gICAgY2xhc3M6IFwiY20tc2VsZWN0aW9uTGF5ZXJcIlxyXG59KTtcclxuY29uc3QgdGhlbWVTcGVjID0ge1xyXG4gICAgXCIuY20tbGluZVwiOiB7XHJcbiAgICAgICAgXCImIDo6c2VsZWN0aW9uXCI6IHsgYmFja2dyb3VuZENvbG9yOiBcInRyYW5zcGFyZW50ICFpbXBvcnRhbnRcIiB9LFxyXG4gICAgICAgIFwiJjo6c2VsZWN0aW9uXCI6IHsgYmFja2dyb3VuZENvbG9yOiBcInRyYW5zcGFyZW50ICFpbXBvcnRhbnRcIiB9XHJcbiAgICB9XHJcbn07XHJcbmlmIChDYW5IaWRlUHJpbWFyeSlcclxuICAgIHRoZW1lU3BlY1tcIi5jbS1saW5lXCJdLmNhcmV0Q29sb3IgPSBcInRyYW5zcGFyZW50ICFpbXBvcnRhbnRcIjtcclxuY29uc3QgaGlkZU5hdGl2ZVNlbGVjdGlvbiA9IC8qQF9fUFVSRV9fKi9QcmVjLmhpZ2hlc3QoLypAX19QVVJFX18qL0VkaXRvclZpZXcudGhlbWUodGhlbWVTcGVjKSk7XHJcblxyXG5jb25zdCBzZXREcm9wQ3Vyc29yUG9zID0gLypAX19QVVJFX18qL1N0YXRlRWZmZWN0LmRlZmluZSh7XHJcbiAgICBtYXAocG9zLCBtYXBwaW5nKSB7IHJldHVybiBwb3MgPT0gbnVsbCA/IG51bGwgOiBtYXBwaW5nLm1hcFBvcyhwb3MpOyB9XHJcbn0pO1xyXG5jb25zdCBkcm9wQ3Vyc29yUG9zID0gLypAX19QVVJFX18qL1N0YXRlRmllbGQuZGVmaW5lKHtcclxuICAgIGNyZWF0ZSgpIHsgcmV0dXJuIG51bGw7IH0sXHJcbiAgICB1cGRhdGUocG9zLCB0cikge1xyXG4gICAgICAgIGlmIChwb3MgIT0gbnVsbClcclxuICAgICAgICAgICAgcG9zID0gdHIuY2hhbmdlcy5tYXBQb3MocG9zKTtcclxuICAgICAgICByZXR1cm4gdHIuZWZmZWN0cy5yZWR1Y2UoKHBvcywgZSkgPT4gZS5pcyhzZXREcm9wQ3Vyc29yUG9zKSA/IGUudmFsdWUgOiBwb3MsIHBvcyk7XHJcbiAgICB9XHJcbn0pO1xyXG5jb25zdCBkcmF3RHJvcEN1cnNvciA9IC8qQF9fUFVSRV9fKi9WaWV3UGx1Z2luLmZyb21DbGFzcyhjbGFzcyB7XHJcbiAgICBjb25zdHJ1Y3Rvcih2aWV3KSB7XHJcbiAgICAgICAgdGhpcy52aWV3ID0gdmlldztcclxuICAgICAgICB0aGlzLmN1cnNvciA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5tZWFzdXJlUmVxID0geyByZWFkOiB0aGlzLnJlYWRQb3MuYmluZCh0aGlzKSwgd3JpdGU6IHRoaXMuZHJhd0N1cnNvci5iaW5kKHRoaXMpIH07XHJcbiAgICB9XHJcbiAgICB1cGRhdGUodXBkYXRlKSB7XHJcbiAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgIGxldCBjdXJzb3JQb3MgPSB1cGRhdGUuc3RhdGUuZmllbGQoZHJvcEN1cnNvclBvcyk7XHJcbiAgICAgICAgaWYgKGN1cnNvclBvcyA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmN1cnNvciAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAoX2EgPSB0aGlzLmN1cnNvcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnJlbW92ZSgpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jdXJzb3IgPSBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMuY3Vyc29yKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnNvciA9IHRoaXMudmlldy5zY3JvbGxET00uYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnNvci5jbGFzc05hbWUgPSBcImNtLWRyb3BDdXJzb3JcIjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodXBkYXRlLnN0YXJ0U3RhdGUuZmllbGQoZHJvcEN1cnNvclBvcykgIT0gY3Vyc29yUG9zIHx8IHVwZGF0ZS5kb2NDaGFuZ2VkIHx8IHVwZGF0ZS5nZW9tZXRyeUNoYW5nZWQpXHJcbiAgICAgICAgICAgICAgICB0aGlzLnZpZXcucmVxdWVzdE1lYXN1cmUodGhpcy5tZWFzdXJlUmVxKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZWFkUG9zKCkge1xyXG4gICAgICAgIGxldCBwb3MgPSB0aGlzLnZpZXcuc3RhdGUuZmllbGQoZHJvcEN1cnNvclBvcyk7XHJcbiAgICAgICAgbGV0IHJlY3QgPSBwb3MgIT0gbnVsbCAmJiB0aGlzLnZpZXcuY29vcmRzQXRQb3MocG9zKTtcclxuICAgICAgICBpZiAoIXJlY3QpXHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIGxldCBvdXRlciA9IHRoaXMudmlldy5zY3JvbGxET00uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgbGVmdDogcmVjdC5sZWZ0IC0gb3V0ZXIubGVmdCArIHRoaXMudmlldy5zY3JvbGxET00uc2Nyb2xsTGVmdCxcclxuICAgICAgICAgICAgdG9wOiByZWN0LnRvcCAtIG91dGVyLnRvcCArIHRoaXMudmlldy5zY3JvbGxET00uc2Nyb2xsVG9wLFxyXG4gICAgICAgICAgICBoZWlnaHQ6IHJlY3QuYm90dG9tIC0gcmVjdC50b3BcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgZHJhd0N1cnNvcihwb3MpIHtcclxuICAgICAgICBpZiAodGhpcy5jdXJzb3IpIHtcclxuICAgICAgICAgICAgaWYgKHBvcykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jdXJzb3Iuc3R5bGUubGVmdCA9IHBvcy5sZWZ0ICsgXCJweFwiO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jdXJzb3Iuc3R5bGUudG9wID0gcG9zLnRvcCArIFwicHhcIjtcclxuICAgICAgICAgICAgICAgIHRoaXMuY3Vyc29yLnN0eWxlLmhlaWdodCA9IHBvcy5oZWlnaHQgKyBcInB4XCI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnNvci5zdHlsZS5sZWZ0ID0gXCItMTAwMDAwcHhcIjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGRlc3Ryb3koKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuY3Vyc29yKVxyXG4gICAgICAgICAgICB0aGlzLmN1cnNvci5yZW1vdmUoKTtcclxuICAgIH1cclxuICAgIHNldERyb3BQb3MocG9zKSB7XHJcbiAgICAgICAgaWYgKHRoaXMudmlldy5zdGF0ZS5maWVsZChkcm9wQ3Vyc29yUG9zKSAhPSBwb3MpXHJcbiAgICAgICAgICAgIHRoaXMudmlldy5kaXNwYXRjaCh7IGVmZmVjdHM6IHNldERyb3BDdXJzb3JQb3Mub2YocG9zKSB9KTtcclxuICAgIH1cclxufSwge1xyXG4gICAgZXZlbnRIYW5kbGVyczoge1xyXG4gICAgICAgIGRyYWdvdmVyKGV2ZW50KSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2V0RHJvcFBvcyh0aGlzLnZpZXcucG9zQXRDb29yZHMoeyB4OiBldmVudC5jbGllbnRYLCB5OiBldmVudC5jbGllbnRZIH0pKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGRyYWdsZWF2ZShldmVudCkge1xyXG4gICAgICAgICAgICBpZiAoZXZlbnQudGFyZ2V0ID09IHRoaXMudmlldy5jb250ZW50RE9NIHx8ICF0aGlzLnZpZXcuY29udGVudERPTS5jb250YWlucyhldmVudC5yZWxhdGVkVGFyZ2V0KSlcclxuICAgICAgICAgICAgICAgIHRoaXMuc2V0RHJvcFBvcyhudWxsKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGRyYWdlbmQoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2V0RHJvcFBvcyhudWxsKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGRyb3AoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2V0RHJvcFBvcyhudWxsKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn0pO1xyXG4vKipcclxuRHJhd3MgYSBjdXJzb3IgYXQgdGhlIGN1cnJlbnQgZHJvcCBwb3NpdGlvbiB3aGVuIHNvbWV0aGluZyBpc1xyXG5kcmFnZ2VkIG92ZXIgdGhlIGVkaXRvci5cclxuKi9cclxuZnVuY3Rpb24gZHJvcEN1cnNvcigpIHtcclxuICAgIHJldHVybiBbZHJvcEN1cnNvclBvcywgZHJhd0Ryb3BDdXJzb3JdO1xyXG59XHJcblxyXG5mdW5jdGlvbiBpdGVyTWF0Y2hlcyhkb2MsIHJlLCBmcm9tLCB0bywgZikge1xyXG4gICAgcmUubGFzdEluZGV4ID0gMDtcclxuICAgIGZvciAobGV0IGN1cnNvciA9IGRvYy5pdGVyUmFuZ2UoZnJvbSwgdG8pLCBwb3MgPSBmcm9tLCBtOyAhY3Vyc29yLm5leHQoKS5kb25lOyBwb3MgKz0gY3Vyc29yLnZhbHVlLmxlbmd0aCkge1xyXG4gICAgICAgIGlmICghY3Vyc29yLmxpbmVCcmVhaylcclxuICAgICAgICAgICAgd2hpbGUgKG0gPSByZS5leGVjKGN1cnNvci52YWx1ZSkpXHJcbiAgICAgICAgICAgICAgICBmKHBvcyArIG0uaW5kZXgsIG0pO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIG1hdGNoUmFuZ2VzKHZpZXcsIG1heExlbmd0aCkge1xyXG4gICAgbGV0IHZpc2libGUgPSB2aWV3LnZpc2libGVSYW5nZXM7XHJcbiAgICBpZiAodmlzaWJsZS5sZW5ndGggPT0gMSAmJiB2aXNpYmxlWzBdLmZyb20gPT0gdmlldy52aWV3cG9ydC5mcm9tICYmXHJcbiAgICAgICAgdmlzaWJsZVswXS50byA9PSB2aWV3LnZpZXdwb3J0LnRvKVxyXG4gICAgICAgIHJldHVybiB2aXNpYmxlO1xyXG4gICAgbGV0IHJlc3VsdCA9IFtdO1xyXG4gICAgZm9yIChsZXQgeyBmcm9tLCB0byB9IG9mIHZpc2libGUpIHtcclxuICAgICAgICBmcm9tID0gTWF0aC5tYXgodmlldy5zdGF0ZS5kb2MubGluZUF0KGZyb20pLmZyb20sIGZyb20gLSBtYXhMZW5ndGgpO1xyXG4gICAgICAgIHRvID0gTWF0aC5taW4odmlldy5zdGF0ZS5kb2MubGluZUF0KHRvKS50bywgdG8gKyBtYXhMZW5ndGgpO1xyXG4gICAgICAgIGlmIChyZXN1bHQubGVuZ3RoICYmIHJlc3VsdFtyZXN1bHQubGVuZ3RoIC0gMV0udG8gPj0gZnJvbSlcclxuICAgICAgICAgICAgcmVzdWx0W3Jlc3VsdC5sZW5ndGggLSAxXS50byA9IHRvO1xyXG4gICAgICAgIGVsc2VcclxuICAgICAgICAgICAgcmVzdWx0LnB1c2goeyBmcm9tLCB0byB9KTtcclxuICAgIH1cclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn1cclxuLyoqXHJcbkhlbHBlciBjbGFzcyB1c2VkIHRvIG1ha2UgaXQgZWFzaWVyIHRvIG1haW50YWluIGRlY29yYXRpb25zIG9uXHJcbnZpc2libGUgY29kZSB0aGF0IG1hdGNoZXMgYSBnaXZlbiByZWd1bGFyIGV4cHJlc3Npb24uIFRvIGJlIHVzZWRcclxuaW4gYSBbdmlldyBwbHVnaW5dKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5WaWV3UGx1Z2luKS4gSW5zdGFuY2VzIG9mIHRoaXMgb2JqZWN0XHJcbnJlcHJlc2VudCBhIG1hdGNoaW5nIGNvbmZpZ3VyYXRpb24uXHJcbiovXHJcbmNsYXNzIE1hdGNoRGVjb3JhdG9yIHtcclxuICAgIC8qKlxyXG4gICAgQ3JlYXRlIGEgZGVjb3JhdG9yLlxyXG4gICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKGNvbmZpZykge1xyXG4gICAgICAgIGNvbnN0IHsgcmVnZXhwLCBkZWNvcmF0aW9uLCBkZWNvcmF0ZSwgYm91bmRhcnksIG1heExlbmd0aCA9IDEwMDAgfSA9IGNvbmZpZztcclxuICAgICAgICBpZiAoIXJlZ2V4cC5nbG9iYWwpXHJcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiVGhlIHJlZ3VsYXIgZXhwcmVzc2lvbiBnaXZlbiB0byBNYXRjaERlY29yYXRvciBzaG91bGQgaGF2ZSBpdHMgJ2cnIGZsYWcgc2V0XCIpO1xyXG4gICAgICAgIHRoaXMucmVnZXhwID0gcmVnZXhwO1xyXG4gICAgICAgIGlmIChkZWNvcmF0ZSkge1xyXG4gICAgICAgICAgICB0aGlzLmFkZE1hdGNoID0gKG1hdGNoLCB2aWV3LCBmcm9tLCBhZGQpID0+IGRlY29yYXRlKGFkZCwgZnJvbSwgZnJvbSArIG1hdGNoWzBdLmxlbmd0aCwgbWF0Y2gsIHZpZXcpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgZGVjb3JhdGlvbiA9PSBcImZ1bmN0aW9uXCIpIHtcclxuICAgICAgICAgICAgdGhpcy5hZGRNYXRjaCA9IChtYXRjaCwgdmlldywgZnJvbSwgYWRkKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBsZXQgZGVjbyA9IGRlY29yYXRpb24obWF0Y2gsIHZpZXcsIGZyb20pO1xyXG4gICAgICAgICAgICAgICAgaWYgKGRlY28pXHJcbiAgICAgICAgICAgICAgICAgICAgYWRkKGZyb20sIGZyb20gKyBtYXRjaFswXS5sZW5ndGgsIGRlY28pO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChkZWNvcmF0aW9uKSB7XHJcbiAgICAgICAgICAgIHRoaXMuYWRkTWF0Y2ggPSAobWF0Y2gsIF92aWV3LCBmcm9tLCBhZGQpID0+IGFkZChmcm9tLCBmcm9tICsgbWF0Y2hbMF0ubGVuZ3RoLCBkZWNvcmF0aW9uKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiRWl0aGVyICdkZWNvcmF0ZScgb3IgJ2RlY29yYXRpb24nIHNob3VsZCBiZSBwcm92aWRlZCB0byBNYXRjaERlY29yYXRvclwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5ib3VuZGFyeSA9IGJvdW5kYXJ5O1xyXG4gICAgICAgIHRoaXMubWF4TGVuZ3RoID0gbWF4TGVuZ3RoO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICBDb21wdXRlIHRoZSBmdWxsIHNldCBvZiBkZWNvcmF0aW9ucyBmb3IgbWF0Y2hlcyBpbiB0aGUgZ2l2ZW5cclxuICAgIHZpZXcncyB2aWV3cG9ydC4gWW91J2xsIHdhbnQgdG8gY2FsbCB0aGlzIHdoZW4gaW5pdGlhbGl6aW5nIHlvdXJcclxuICAgIHBsdWdpbi5cclxuICAgICovXHJcbiAgICBjcmVhdGVEZWNvKHZpZXcpIHtcclxuICAgICAgICBsZXQgYnVpbGQgPSBuZXcgUmFuZ2VTZXRCdWlsZGVyKCksIGFkZCA9IGJ1aWxkLmFkZC5iaW5kKGJ1aWxkKTtcclxuICAgICAgICBmb3IgKGxldCB7IGZyb20sIHRvIH0gb2YgbWF0Y2hSYW5nZXModmlldywgdGhpcy5tYXhMZW5ndGgpKVxyXG4gICAgICAgICAgICBpdGVyTWF0Y2hlcyh2aWV3LnN0YXRlLmRvYywgdGhpcy5yZWdleHAsIGZyb20sIHRvLCAoZnJvbSwgbSkgPT4gdGhpcy5hZGRNYXRjaChtLCB2aWV3LCBmcm9tLCBhZGQpKTtcclxuICAgICAgICByZXR1cm4gYnVpbGQuZmluaXNoKCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgIFVwZGF0ZSBhIHNldCBvZiBkZWNvcmF0aW9ucyBmb3IgYSB2aWV3IHVwZGF0ZS4gYGRlY29gIF9tdXN0XyBiZVxyXG4gICAgdGhlIHNldCBvZiBkZWNvcmF0aW9ucyBwcm9kdWNlZCBieSBfdGhpc18gYE1hdGNoRGVjb3JhdG9yYCBmb3JcclxuICAgIHRoZSB2aWV3IHN0YXRlIGJlZm9yZSB0aGUgdXBkYXRlLlxyXG4gICAgKi9cclxuICAgIHVwZGF0ZURlY28odXBkYXRlLCBkZWNvKSB7XHJcbiAgICAgICAgbGV0IGNoYW5nZUZyb20gPSAxZTksIGNoYW5nZVRvID0gLTE7XHJcbiAgICAgICAgaWYgKHVwZGF0ZS5kb2NDaGFuZ2VkKVxyXG4gICAgICAgICAgICB1cGRhdGUuY2hhbmdlcy5pdGVyQ2hhbmdlcygoX2YsIF90LCBmcm9tLCB0bykgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRvID4gdXBkYXRlLnZpZXcudmlld3BvcnQuZnJvbSAmJiBmcm9tIDwgdXBkYXRlLnZpZXcudmlld3BvcnQudG8pIHtcclxuICAgICAgICAgICAgICAgICAgICBjaGFuZ2VGcm9tID0gTWF0aC5taW4oZnJvbSwgY2hhbmdlRnJvbSk7XHJcbiAgICAgICAgICAgICAgICAgICAgY2hhbmdlVG8gPSBNYXRoLm1heCh0bywgY2hhbmdlVG8pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICBpZiAodXBkYXRlLnZpZXdwb3J0Q2hhbmdlZCB8fCBjaGFuZ2VUbyAtIGNoYW5nZUZyb20gPiAxMDAwKVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVEZWNvKHVwZGF0ZS52aWV3KTtcclxuICAgICAgICBpZiAoY2hhbmdlVG8gPiAtMSlcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMudXBkYXRlUmFuZ2UodXBkYXRlLnZpZXcsIGRlY28ubWFwKHVwZGF0ZS5jaGFuZ2VzKSwgY2hhbmdlRnJvbSwgY2hhbmdlVG8pO1xyXG4gICAgICAgIHJldHVybiBkZWNvO1xyXG4gICAgfVxyXG4gICAgdXBkYXRlUmFuZ2UodmlldywgZGVjbywgdXBkYXRlRnJvbSwgdXBkYXRlVG8pIHtcclxuICAgICAgICBmb3IgKGxldCByIG9mIHZpZXcudmlzaWJsZVJhbmdlcykge1xyXG4gICAgICAgICAgICBsZXQgZnJvbSA9IE1hdGgubWF4KHIuZnJvbSwgdXBkYXRlRnJvbSksIHRvID0gTWF0aC5taW4oci50bywgdXBkYXRlVG8pO1xyXG4gICAgICAgICAgICBpZiAodG8gPiBmcm9tKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgZnJvbUxpbmUgPSB2aWV3LnN0YXRlLmRvYy5saW5lQXQoZnJvbSksIHRvTGluZSA9IGZyb21MaW5lLnRvIDwgdG8gPyB2aWV3LnN0YXRlLmRvYy5saW5lQXQodG8pIDogZnJvbUxpbmU7XHJcbiAgICAgICAgICAgICAgICBsZXQgc3RhcnQgPSBNYXRoLm1heChyLmZyb20sIGZyb21MaW5lLmZyb20pLCBlbmQgPSBNYXRoLm1pbihyLnRvLCB0b0xpbmUudG8pO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuYm91bmRhcnkpIHtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKDsgZnJvbSA+IGZyb21MaW5lLmZyb207IGZyb20tLSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuYm91bmRhcnkudGVzdChmcm9tTGluZS50ZXh0W2Zyb20gLSAxIC0gZnJvbUxpbmUuZnJvbV0pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFydCA9IGZyb207XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGZvciAoOyB0byA8IHRvTGluZS50bzsgdG8rKylcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuYm91bmRhcnkudGVzdCh0b0xpbmUudGV4dFt0byAtIHRvTGluZS5mcm9tXSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuZCA9IHRvO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGxldCByYW5nZXMgPSBbXSwgbTtcclxuICAgICAgICAgICAgICAgIGxldCBhZGQgPSAoZnJvbSwgdG8sIGRlY28pID0+IHJhbmdlcy5wdXNoKGRlY28ucmFuZ2UoZnJvbSwgdG8pKTtcclxuICAgICAgICAgICAgICAgIGlmIChmcm9tTGluZSA9PSB0b0xpbmUpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlZ2V4cC5sYXN0SW5kZXggPSBzdGFydCAtIGZyb21MaW5lLmZyb207XHJcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKChtID0gdGhpcy5yZWdleHAuZXhlYyhmcm9tTGluZS50ZXh0KSkgJiYgbS5pbmRleCA8IGVuZCAtIGZyb21MaW5lLmZyb20pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYWRkTWF0Y2gobSwgdmlldywgbS5pbmRleCArIGZyb21MaW5lLmZyb20sIGFkZCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBpdGVyTWF0Y2hlcyh2aWV3LnN0YXRlLmRvYywgdGhpcy5yZWdleHAsIHN0YXJ0LCBlbmQsIChmcm9tLCBtKSA9PiB0aGlzLmFkZE1hdGNoKG0sIHZpZXcsIGZyb20sIGFkZCkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZGVjbyA9IGRlY28udXBkYXRlKHsgZmlsdGVyRnJvbTogc3RhcnQsIGZpbHRlclRvOiBlbmQsIGZpbHRlcjogKGZyb20sIHRvKSA9PiBmcm9tIDwgc3RhcnQgfHwgdG8gPiBlbmQsIGFkZDogcmFuZ2VzIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBkZWNvO1xyXG4gICAgfVxyXG59XHJcblxyXG5jb25zdCBVbmljb2RlUmVnZXhwU3VwcG9ydCA9IC94Ly51bmljb2RlICE9IG51bGwgPyBcImd1XCIgOiBcImdcIjtcclxuY29uc3QgU3BlY2lhbHMgPSAvKkBfX1BVUkVfXyovbmV3IFJlZ0V4cChcIltcXHUwMDAwLVxcdTAwMDhcXHUwMDBhLVxcdTAwMWZcXHUwMDdmLVxcdTAwOWZcXHUwMGFkXFx1MDYxY1xcdTIwMGJcXHUyMDBlXFx1MjAwZlxcdTIwMjhcXHUyMDI5XFx1MjAyZFxcdTIwMmVcXHUyMDY2XFx1MjA2N1xcdTIwNjlcXHVmZWZmXFx1ZmZmOS1cXHVmZmZjXVwiLCBVbmljb2RlUmVnZXhwU3VwcG9ydCk7XHJcbmNvbnN0IE5hbWVzID0ge1xyXG4gICAgMDogXCJudWxsXCIsXHJcbiAgICA3OiBcImJlbGxcIixcclxuICAgIDg6IFwiYmFja3NwYWNlXCIsXHJcbiAgICAxMDogXCJuZXdsaW5lXCIsXHJcbiAgICAxMTogXCJ2ZXJ0aWNhbCB0YWJcIixcclxuICAgIDEzOiBcImNhcnJpYWdlIHJldHVyblwiLFxyXG4gICAgMjc6IFwiZXNjYXBlXCIsXHJcbiAgICA4MjAzOiBcInplcm8gd2lkdGggc3BhY2VcIixcclxuICAgIDgyMDQ6IFwiemVybyB3aWR0aCBub24tam9pbmVyXCIsXHJcbiAgICA4MjA1OiBcInplcm8gd2lkdGggam9pbmVyXCIsXHJcbiAgICA4MjA2OiBcImxlZnQtdG8tcmlnaHQgbWFya1wiLFxyXG4gICAgODIwNzogXCJyaWdodC10by1sZWZ0IG1hcmtcIixcclxuICAgIDgyMzI6IFwibGluZSBzZXBhcmF0b3JcIixcclxuICAgIDgyMzc6IFwibGVmdC10by1yaWdodCBvdmVycmlkZVwiLFxyXG4gICAgODIzODogXCJyaWdodC10by1sZWZ0IG92ZXJyaWRlXCIsXHJcbiAgICA4Mjk0OiBcImxlZnQtdG8tcmlnaHQgaXNvbGF0ZVwiLFxyXG4gICAgODI5NTogXCJyaWdodC10by1sZWZ0IGlzb2xhdGVcIixcclxuICAgIDgyOTc6IFwicG9wIGRpcmVjdGlvbmFsIGlzb2xhdGVcIixcclxuICAgIDgyMzM6IFwicGFyYWdyYXBoIHNlcGFyYXRvclwiLFxyXG4gICAgNjUyNzk6IFwiemVybyB3aWR0aCBuby1icmVhayBzcGFjZVwiLFxyXG4gICAgNjU1MzI6IFwib2JqZWN0IHJlcGxhY2VtZW50XCJcclxufTtcclxubGV0IF9zdXBwb3J0c1RhYlNpemUgPSBudWxsO1xyXG5mdW5jdGlvbiBzdXBwb3J0c1RhYlNpemUoKSB7XHJcbiAgICB2YXIgX2E7XHJcbiAgICBpZiAoX3N1cHBvcnRzVGFiU2l6ZSA9PSBudWxsICYmIHR5cGVvZiBkb2N1bWVudCAhPSBcInVuZGVmaW5lZFwiICYmIGRvY3VtZW50LmJvZHkpIHtcclxuICAgICAgICBsZXQgc3R5bGVzID0gZG9jdW1lbnQuYm9keS5zdHlsZTtcclxuICAgICAgICBfc3VwcG9ydHNUYWJTaXplID0gKChfYSA9IHN0eWxlcy50YWJTaXplKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBzdHlsZXMuTW96VGFiU2l6ZSkgIT0gbnVsbDtcclxuICAgIH1cclxuICAgIHJldHVybiBfc3VwcG9ydHNUYWJTaXplIHx8IGZhbHNlO1xyXG59XHJcbmNvbnN0IHNwZWNpYWxDaGFyQ29uZmlnID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSh7XHJcbiAgICBjb21iaW5lKGNvbmZpZ3MpIHtcclxuICAgICAgICBsZXQgY29uZmlnID0gY29tYmluZUNvbmZpZyhjb25maWdzLCB7XHJcbiAgICAgICAgICAgIHJlbmRlcjogbnVsbCxcclxuICAgICAgICAgICAgc3BlY2lhbENoYXJzOiBTcGVjaWFscyxcclxuICAgICAgICAgICAgYWRkU3BlY2lhbENoYXJzOiBudWxsXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgaWYgKGNvbmZpZy5yZXBsYWNlVGFicyA9ICFzdXBwb3J0c1RhYlNpemUoKSlcclxuICAgICAgICAgICAgY29uZmlnLnNwZWNpYWxDaGFycyA9IG5ldyBSZWdFeHAoXCJcXHR8XCIgKyBjb25maWcuc3BlY2lhbENoYXJzLnNvdXJjZSwgVW5pY29kZVJlZ2V4cFN1cHBvcnQpO1xyXG4gICAgICAgIGlmIChjb25maWcuYWRkU3BlY2lhbENoYXJzKVxyXG4gICAgICAgICAgICBjb25maWcuc3BlY2lhbENoYXJzID0gbmV3IFJlZ0V4cChjb25maWcuc3BlY2lhbENoYXJzLnNvdXJjZSArIFwifFwiICsgY29uZmlnLmFkZFNwZWNpYWxDaGFycy5zb3VyY2UsIFVuaWNvZGVSZWdleHBTdXBwb3J0KTtcclxuICAgICAgICByZXR1cm4gY29uZmlnO1xyXG4gICAgfVxyXG59KTtcclxuLyoqXHJcblJldHVybnMgYW4gZXh0ZW5zaW9uIHRoYXQgaW5zdGFsbHMgaGlnaGxpZ2h0aW5nIG9mIHNwZWNpYWxcclxuY2hhcmFjdGVycy5cclxuKi9cclxuZnVuY3Rpb24gaGlnaGxpZ2h0U3BlY2lhbENoYXJzKFxyXG4vKipcclxuQ29uZmlndXJhdGlvbiBvcHRpb25zLlxyXG4qL1xyXG5jb25maWcgPSB7fSkge1xyXG4gICAgcmV0dXJuIFtzcGVjaWFsQ2hhckNvbmZpZy5vZihjb25maWcpLCBzcGVjaWFsQ2hhclBsdWdpbigpXTtcclxufVxyXG5sZXQgX3BsdWdpbiA9IG51bGw7XHJcbmZ1bmN0aW9uIHNwZWNpYWxDaGFyUGx1Z2luKCkge1xyXG4gICAgcmV0dXJuIF9wbHVnaW4gfHwgKF9wbHVnaW4gPSBWaWV3UGx1Z2luLmZyb21DbGFzcyhjbGFzcyB7XHJcbiAgICAgICAgY29uc3RydWN0b3Iodmlldykge1xyXG4gICAgICAgICAgICB0aGlzLnZpZXcgPSB2aWV3O1xyXG4gICAgICAgICAgICB0aGlzLmRlY29yYXRpb25zID0gRGVjb3JhdGlvbi5ub25lO1xyXG4gICAgICAgICAgICB0aGlzLmRlY29yYXRpb25DYWNoZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XHJcbiAgICAgICAgICAgIHRoaXMuZGVjb3JhdG9yID0gdGhpcy5tYWtlRGVjb3JhdG9yKHZpZXcuc3RhdGUuZmFjZXQoc3BlY2lhbENoYXJDb25maWcpKTtcclxuICAgICAgICAgICAgdGhpcy5kZWNvcmF0aW9ucyA9IHRoaXMuZGVjb3JhdG9yLmNyZWF0ZURlY28odmlldyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIG1ha2VEZWNvcmF0b3IoY29uZikge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IE1hdGNoRGVjb3JhdG9yKHtcclxuICAgICAgICAgICAgICAgIHJlZ2V4cDogY29uZi5zcGVjaWFsQ2hhcnMsXHJcbiAgICAgICAgICAgICAgICBkZWNvcmF0aW9uOiAobSwgdmlldywgcG9zKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IHsgZG9jIH0gPSB2aWV3LnN0YXRlO1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBjb2RlID0gY29kZVBvaW50QXQobVswXSwgMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvZGUgPT0gOSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgbGluZSA9IGRvYy5saW5lQXQocG9zKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHNpemUgPSB2aWV3LnN0YXRlLnRhYlNpemUsIGNvbCA9IGNvdW50Q29sdW1uKGxpbmUudGV4dCwgc2l6ZSwgcG9zIC0gbGluZS5mcm9tKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIERlY29yYXRpb24ucmVwbGFjZSh7IHdpZGdldDogbmV3IFRhYldpZGdldCgoc2l6ZSAtIChjb2wgJSBzaXplKSkgKiB0aGlzLnZpZXcuZGVmYXVsdENoYXJhY3RlcldpZHRoKSB9KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGVjb3JhdGlvbkNhY2hlW2NvZGVdIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICh0aGlzLmRlY29yYXRpb25DYWNoZVtjb2RlXSA9IERlY29yYXRpb24ucmVwbGFjZSh7IHdpZGdldDogbmV3IFNwZWNpYWxDaGFyV2lkZ2V0KGNvbmYsIGNvZGUpIH0pKTtcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBib3VuZGFyeTogY29uZi5yZXBsYWNlVGFicyA/IHVuZGVmaW5lZCA6IC9bXl0vXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICB1cGRhdGUodXBkYXRlKSB7XHJcbiAgICAgICAgICAgIGxldCBjb25mID0gdXBkYXRlLnN0YXRlLmZhY2V0KHNwZWNpYWxDaGFyQ29uZmlnKTtcclxuICAgICAgICAgICAgaWYgKHVwZGF0ZS5zdGFydFN0YXRlLmZhY2V0KHNwZWNpYWxDaGFyQ29uZmlnKSAhPSBjb25mKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmRlY29yYXRvciA9IHRoaXMubWFrZURlY29yYXRvcihjb25mKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuZGVjb3JhdGlvbnMgPSB0aGlzLmRlY29yYXRvci5jcmVhdGVEZWNvKHVwZGF0ZS52aWV3KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZGVjb3JhdGlvbnMgPSB0aGlzLmRlY29yYXRvci51cGRhdGVEZWNvKHVwZGF0ZSwgdGhpcy5kZWNvcmF0aW9ucyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9LCB7XHJcbiAgICAgICAgZGVjb3JhdGlvbnM6IHYgPT4gdi5kZWNvcmF0aW9uc1xyXG4gICAgfSkpO1xyXG59XHJcbmNvbnN0IERlZmF1bHRQbGFjZWhvbGRlciA9IFwiXFx1MjAyMlwiO1xyXG4vLyBBc3NpZ25zIHBsYWNlaG9sZGVyIGNoYXJhY3RlcnMgZnJvbSB0aGUgQ29udHJvbCBQaWN0dXJlcyBibG9jayB0b1xyXG4vLyBBU0NJSSBjb250cm9sIGNoYXJhY3RlcnNcclxuZnVuY3Rpb24gcGxhY2Vob2xkZXIkMShjb2RlKSB7XHJcbiAgICBpZiAoY29kZSA+PSAzMilcclxuICAgICAgICByZXR1cm4gRGVmYXVsdFBsYWNlaG9sZGVyO1xyXG4gICAgaWYgKGNvZGUgPT0gMTApXHJcbiAgICAgICAgcmV0dXJuIFwiXFx1MjQyNFwiO1xyXG4gICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoOTIxNiArIGNvZGUpO1xyXG59XHJcbmNsYXNzIFNwZWNpYWxDaGFyV2lkZ2V0IGV4dGVuZHMgV2lkZ2V0VHlwZSB7XHJcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zLCBjb2RlKSB7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xyXG4gICAgICAgIHRoaXMuY29kZSA9IGNvZGU7XHJcbiAgICB9XHJcbiAgICBlcShvdGhlcikgeyByZXR1cm4gb3RoZXIuY29kZSA9PSB0aGlzLmNvZGU7IH1cclxuICAgIHRvRE9NKHZpZXcpIHtcclxuICAgICAgICBsZXQgcGggPSBwbGFjZWhvbGRlciQxKHRoaXMuY29kZSk7XHJcbiAgICAgICAgbGV0IGRlc2MgPSB2aWV3LnN0YXRlLnBocmFzZShcIkNvbnRyb2wgY2hhcmFjdGVyXCIpICsgXCIgXCIgKyAoTmFtZXNbdGhpcy5jb2RlXSB8fCBcIjB4XCIgKyB0aGlzLmNvZGUudG9TdHJpbmcoMTYpKTtcclxuICAgICAgICBsZXQgY3VzdG9tID0gdGhpcy5vcHRpb25zLnJlbmRlciAmJiB0aGlzLm9wdGlvbnMucmVuZGVyKHRoaXMuY29kZSwgZGVzYywgcGgpO1xyXG4gICAgICAgIGlmIChjdXN0b20pXHJcbiAgICAgICAgICAgIHJldHVybiBjdXN0b207XHJcbiAgICAgICAgbGV0IHNwYW4gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3BhblwiKTtcclxuICAgICAgICBzcGFuLnRleHRDb250ZW50ID0gcGg7XHJcbiAgICAgICAgc3Bhbi50aXRsZSA9IGRlc2M7XHJcbiAgICAgICAgc3Bhbi5zZXRBdHRyaWJ1dGUoXCJhcmlhLWxhYmVsXCIsIGRlc2MpO1xyXG4gICAgICAgIHNwYW4uY2xhc3NOYW1lID0gXCJjbS1zcGVjaWFsQ2hhclwiO1xyXG4gICAgICAgIHJldHVybiBzcGFuO1xyXG4gICAgfVxyXG4gICAgaWdub3JlRXZlbnQoKSB7IHJldHVybiBmYWxzZTsgfVxyXG59XHJcbmNsYXNzIFRhYldpZGdldCBleHRlbmRzIFdpZGdldFR5cGUge1xyXG4gICAgY29uc3RydWN0b3Iod2lkdGgpIHtcclxuICAgICAgICBzdXBlcigpO1xyXG4gICAgICAgIHRoaXMud2lkdGggPSB3aWR0aDtcclxuICAgIH1cclxuICAgIGVxKG90aGVyKSB7IHJldHVybiBvdGhlci53aWR0aCA9PSB0aGlzLndpZHRoOyB9XHJcbiAgICB0b0RPTSgpIHtcclxuICAgICAgICBsZXQgc3BhbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpO1xyXG4gICAgICAgIHNwYW4udGV4dENvbnRlbnQgPSBcIlxcdFwiO1xyXG4gICAgICAgIHNwYW4uY2xhc3NOYW1lID0gXCJjbS10YWJcIjtcclxuICAgICAgICBzcGFuLnN0eWxlLndpZHRoID0gdGhpcy53aWR0aCArIFwicHhcIjtcclxuICAgICAgICByZXR1cm4gc3BhbjtcclxuICAgIH1cclxuICAgIGlnbm9yZUV2ZW50KCkgeyByZXR1cm4gZmFsc2U7IH1cclxufVxyXG5cclxuY29uc3QgcGx1Z2luID0gLypAX19QVVJFX18qL1ZpZXdQbHVnaW4uZnJvbUNsYXNzKGNsYXNzIHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gMTAwMDtcclxuICAgICAgICB0aGlzLmF0dHJzID0geyBzdHlsZTogXCJwYWRkaW5nLWJvdHRvbTogMTAwMHB4XCIgfTtcclxuICAgIH1cclxuICAgIHVwZGF0ZSh1cGRhdGUpIHtcclxuICAgICAgICBsZXQgeyB2aWV3IH0gPSB1cGRhdGU7XHJcbiAgICAgICAgbGV0IGhlaWdodCA9IHZpZXcudmlld1N0YXRlLmVkaXRvckhlaWdodCAtIHZpZXcuZGVmYXVsdExpbmVIZWlnaHQgLSB2aWV3LmRvY3VtZW50UGFkZGluZy50b3AgLSAwLjU7XHJcbiAgICAgICAgaWYgKGhlaWdodCAhPSB0aGlzLmhlaWdodCkge1xyXG4gICAgICAgICAgICB0aGlzLmhlaWdodCA9IGhlaWdodDtcclxuICAgICAgICAgICAgdGhpcy5hdHRycyA9IHsgc3R5bGU6IGBwYWRkaW5nLWJvdHRvbTogJHtoZWlnaHR9cHhgIH07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59KTtcclxuLyoqXHJcblJldHVybnMgYW4gZXh0ZW5zaW9uIHRoYXQgbWFrZXMgc3VyZSB0aGUgY29udGVudCBoYXMgYSBib3R0b21cclxubWFyZ2luIGVxdWl2YWxlbnQgdG8gdGhlIGhlaWdodCBvZiB0aGUgZWRpdG9yLCBtaW51cyBvbmUgbGluZVxyXG5oZWlnaHQsIHNvIHRoYXQgZXZlcnkgbGluZSBpbiB0aGUgZG9jdW1lbnQgY2FuIGJlIHNjcm9sbGVkIHRvIHRoZVxyXG50b3Agb2YgdGhlIGVkaXRvci5cclxuXHJcblRoaXMgaXMgb25seSBtZWFuaW5nZnVsIHdoZW4gdGhlIGVkaXRvciBpcyBzY3JvbGxhYmxlLCBhbmQgc2hvdWxkXHJcbm5vdCBiZSBlbmFibGVkIGluIGVkaXRvcnMgdGhhdCB0YWtlIHRoZSBzaXplIG9mIHRoZWlyIGNvbnRlbnQuXHJcbiovXHJcbmZ1bmN0aW9uIHNjcm9sbFBhc3RFbmQoKSB7XHJcbiAgICByZXR1cm4gW3BsdWdpbiwgY29udGVudEF0dHJpYnV0ZXMub2YodmlldyA9PiB7IHZhciBfYTsgcmV0dXJuICgoX2EgPSB2aWV3LnBsdWdpbihwbHVnaW4pKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuYXR0cnMpIHx8IG51bGw7IH0pXTtcclxufVxyXG5cclxuLyoqXHJcbk1hcmsgbGluZXMgdGhhdCBoYXZlIGEgY3Vyc29yIG9uIHRoZW0gd2l0aCB0aGUgYFwiY20tYWN0aXZlTGluZVwiYFxyXG5ET00gY2xhc3MuXHJcbiovXHJcbmZ1bmN0aW9uIGhpZ2hsaWdodEFjdGl2ZUxpbmUoKSB7XHJcbiAgICByZXR1cm4gYWN0aXZlTGluZUhpZ2hsaWdodGVyO1xyXG59XHJcbmNvbnN0IGxpbmVEZWNvID0gLypAX19QVVJFX18qL0RlY29yYXRpb24ubGluZSh7IGNsYXNzOiBcImNtLWFjdGl2ZUxpbmVcIiB9KTtcclxuY29uc3QgYWN0aXZlTGluZUhpZ2hsaWdodGVyID0gLypAX19QVVJFX18qL1ZpZXdQbHVnaW4uZnJvbUNsYXNzKGNsYXNzIHtcclxuICAgIGNvbnN0cnVjdG9yKHZpZXcpIHtcclxuICAgICAgICB0aGlzLmRlY29yYXRpb25zID0gdGhpcy5nZXREZWNvKHZpZXcpO1xyXG4gICAgfVxyXG4gICAgdXBkYXRlKHVwZGF0ZSkge1xyXG4gICAgICAgIGlmICh1cGRhdGUuZG9jQ2hhbmdlZCB8fCB1cGRhdGUuc2VsZWN0aW9uU2V0KVxyXG4gICAgICAgICAgICB0aGlzLmRlY29yYXRpb25zID0gdGhpcy5nZXREZWNvKHVwZGF0ZS52aWV3KTtcclxuICAgIH1cclxuICAgIGdldERlY28odmlldykge1xyXG4gICAgICAgIGxldCBsYXN0TGluZVN0YXJ0ID0gLTEsIGRlY28gPSBbXTtcclxuICAgICAgICBmb3IgKGxldCByIG9mIHZpZXcuc3RhdGUuc2VsZWN0aW9uLnJhbmdlcykge1xyXG4gICAgICAgICAgICBsZXQgbGluZSA9IHZpZXcubGluZUJsb2NrQXQoci5oZWFkKTtcclxuICAgICAgICAgICAgaWYgKGxpbmUuZnJvbSA+IGxhc3RMaW5lU3RhcnQpIHtcclxuICAgICAgICAgICAgICAgIGRlY28ucHVzaChsaW5lRGVjby5yYW5nZShsaW5lLmZyb20pKTtcclxuICAgICAgICAgICAgICAgIGxhc3RMaW5lU3RhcnQgPSBsaW5lLmZyb207XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIERlY29yYXRpb24uc2V0KGRlY28pO1xyXG4gICAgfVxyXG59LCB7XHJcbiAgICBkZWNvcmF0aW9uczogdiA9PiB2LmRlY29yYXRpb25zXHJcbn0pO1xyXG5cclxuY2xhc3MgUGxhY2Vob2xkZXIgZXh0ZW5kcyBXaWRnZXRUeXBlIHtcclxuICAgIGNvbnN0cnVjdG9yKGNvbnRlbnQpIHtcclxuICAgICAgICBzdXBlcigpO1xyXG4gICAgICAgIHRoaXMuY29udGVudCA9IGNvbnRlbnQ7XHJcbiAgICB9XHJcbiAgICB0b0RPTSgpIHtcclxuICAgICAgICBsZXQgd3JhcCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpO1xyXG4gICAgICAgIHdyYXAuY2xhc3NOYW1lID0gXCJjbS1wbGFjZWhvbGRlclwiO1xyXG4gICAgICAgIHdyYXAuc3R5bGUucG9pbnRlckV2ZW50cyA9IFwibm9uZVwiO1xyXG4gICAgICAgIHdyYXAuYXBwZW5kQ2hpbGQodHlwZW9mIHRoaXMuY29udGVudCA9PSBcInN0cmluZ1wiID8gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUodGhpcy5jb250ZW50KSA6IHRoaXMuY29udGVudCk7XHJcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLmNvbnRlbnQgPT0gXCJzdHJpbmdcIilcclxuICAgICAgICAgICAgd3JhcC5zZXRBdHRyaWJ1dGUoXCJhcmlhLWxhYmVsXCIsIFwicGxhY2Vob2xkZXIgXCIgKyB0aGlzLmNvbnRlbnQpO1xyXG4gICAgICAgIGVsc2VcclxuICAgICAgICAgICAgd3JhcC5zZXRBdHRyaWJ1dGUoXCJhcmlhLWhpZGRlblwiLCBcInRydWVcIik7XHJcbiAgICAgICAgcmV0dXJuIHdyYXA7XHJcbiAgICB9XHJcbiAgICBpZ25vcmVFdmVudCgpIHsgcmV0dXJuIGZhbHNlOyB9XHJcbn1cclxuLyoqXHJcbkV4dGVuc2lvbiB0aGF0IGVuYWJsZXMgYSBwbGFjZWhvbGRlcuKAlGEgcGllY2Ugb2YgZXhhbXBsZSBjb250ZW50XHJcbnRvIHNob3cgd2hlbiB0aGUgZWRpdG9yIGlzIGVtcHR5LlxyXG4qL1xyXG5mdW5jdGlvbiBwbGFjZWhvbGRlcihjb250ZW50KSB7XHJcbiAgICByZXR1cm4gVmlld1BsdWdpbi5mcm9tQ2xhc3MoY2xhc3Mge1xyXG4gICAgICAgIGNvbnN0cnVjdG9yKHZpZXcpIHtcclxuICAgICAgICAgICAgdGhpcy52aWV3ID0gdmlldztcclxuICAgICAgICAgICAgdGhpcy5wbGFjZWhvbGRlciA9IERlY29yYXRpb24uc2V0KFtEZWNvcmF0aW9uLndpZGdldCh7IHdpZGdldDogbmV3IFBsYWNlaG9sZGVyKGNvbnRlbnQpLCBzaWRlOiAxIH0pLnJhbmdlKDApXSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGdldCBkZWNvcmF0aW9ucygpIHsgcmV0dXJuIHRoaXMudmlldy5zdGF0ZS5kb2MubGVuZ3RoID8gRGVjb3JhdGlvbi5ub25lIDogdGhpcy5wbGFjZWhvbGRlcjsgfVxyXG4gICAgfSwgeyBkZWNvcmF0aW9uczogdiA9PiB2LmRlY29yYXRpb25zIH0pO1xyXG59XHJcblxyXG4vLyBEb24ndCBjb21wdXRlIHByZWNpc2UgY29sdW1uIHBvc2l0aW9ucyBmb3IgbGluZSBvZmZzZXRzIGFib3ZlIHRoaXNcclxuLy8gKHNpbmNlIGl0IGNvdWxkIGdldCBleHBlbnNpdmUpLiBBc3N1bWUgb2Zmc2V0PT1jb2x1bW4gZm9yIHRoZW0uXHJcbmNvbnN0IE1heE9mZiA9IDIwMDA7XHJcbmZ1bmN0aW9uIHJlY3RhbmdsZUZvcihzdGF0ZSwgYSwgYikge1xyXG4gICAgbGV0IHN0YXJ0TGluZSA9IE1hdGgubWluKGEubGluZSwgYi5saW5lKSwgZW5kTGluZSA9IE1hdGgubWF4KGEubGluZSwgYi5saW5lKTtcclxuICAgIGxldCByYW5nZXMgPSBbXTtcclxuICAgIGlmIChhLm9mZiA+IE1heE9mZiB8fCBiLm9mZiA+IE1heE9mZiB8fCBhLmNvbCA8IDAgfHwgYi5jb2wgPCAwKSB7XHJcbiAgICAgICAgbGV0IHN0YXJ0T2ZmID0gTWF0aC5taW4oYS5vZmYsIGIub2ZmKSwgZW5kT2ZmID0gTWF0aC5tYXgoYS5vZmYsIGIub2ZmKTtcclxuICAgICAgICBmb3IgKGxldCBpID0gc3RhcnRMaW5lOyBpIDw9IGVuZExpbmU7IGkrKykge1xyXG4gICAgICAgICAgICBsZXQgbGluZSA9IHN0YXRlLmRvYy5saW5lKGkpO1xyXG4gICAgICAgICAgICBpZiAobGluZS5sZW5ndGggPD0gZW5kT2ZmKVxyXG4gICAgICAgICAgICAgICAgcmFuZ2VzLnB1c2goRWRpdG9yU2VsZWN0aW9uLnJhbmdlKGxpbmUuZnJvbSArIHN0YXJ0T2ZmLCBsaW5lLnRvICsgZW5kT2ZmKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgbGV0IHN0YXJ0Q29sID0gTWF0aC5taW4oYS5jb2wsIGIuY29sKSwgZW5kQ29sID0gTWF0aC5tYXgoYS5jb2wsIGIuY29sKTtcclxuICAgICAgICBmb3IgKGxldCBpID0gc3RhcnRMaW5lOyBpIDw9IGVuZExpbmU7IGkrKykge1xyXG4gICAgICAgICAgICBsZXQgbGluZSA9IHN0YXRlLmRvYy5saW5lKGkpO1xyXG4gICAgICAgICAgICBsZXQgc3RhcnQgPSBmaW5kQ29sdW1uKGxpbmUudGV4dCwgc3RhcnRDb2wsIHN0YXRlLnRhYlNpemUsIHRydWUpO1xyXG4gICAgICAgICAgICBpZiAoc3RhcnQgPCAwKSB7XHJcbiAgICAgICAgICAgICAgICByYW5nZXMucHVzaChFZGl0b3JTZWxlY3Rpb24uY3Vyc29yKGxpbmUudG8pKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGxldCBlbmQgPSBmaW5kQ29sdW1uKGxpbmUudGV4dCwgZW5kQ29sLCBzdGF0ZS50YWJTaXplKTtcclxuICAgICAgICAgICAgICAgIHJhbmdlcy5wdXNoKEVkaXRvclNlbGVjdGlvbi5yYW5nZShsaW5lLmZyb20gKyBzdGFydCwgbGluZS5mcm9tICsgZW5kKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmFuZ2VzO1xyXG59XHJcbmZ1bmN0aW9uIGFic29sdXRlQ29sdW1uKHZpZXcsIHgpIHtcclxuICAgIGxldCByZWYgPSB2aWV3LmNvb3Jkc0F0UG9zKHZpZXcudmlld3BvcnQuZnJvbSk7XHJcbiAgICByZXR1cm4gcmVmID8gTWF0aC5yb3VuZChNYXRoLmFicygocmVmLmxlZnQgLSB4KSAvIHZpZXcuZGVmYXVsdENoYXJhY3RlcldpZHRoKSkgOiAtMTtcclxufVxyXG5mdW5jdGlvbiBnZXRQb3ModmlldywgZXZlbnQpIHtcclxuICAgIGxldCBvZmZzZXQgPSB2aWV3LnBvc0F0Q29vcmRzKHsgeDogZXZlbnQuY2xpZW50WCwgeTogZXZlbnQuY2xpZW50WSB9LCBmYWxzZSk7XHJcbiAgICBsZXQgbGluZSA9IHZpZXcuc3RhdGUuZG9jLmxpbmVBdChvZmZzZXQpLCBvZmYgPSBvZmZzZXQgLSBsaW5lLmZyb207XHJcbiAgICBsZXQgY29sID0gb2ZmID4gTWF4T2ZmID8gLTFcclxuICAgICAgICA6IG9mZiA9PSBsaW5lLmxlbmd0aCA/IGFic29sdXRlQ29sdW1uKHZpZXcsIGV2ZW50LmNsaWVudFgpXHJcbiAgICAgICAgICAgIDogY291bnRDb2x1bW4obGluZS50ZXh0LCB2aWV3LnN0YXRlLnRhYlNpemUsIG9mZnNldCAtIGxpbmUuZnJvbSk7XHJcbiAgICByZXR1cm4geyBsaW5lOiBsaW5lLm51bWJlciwgY29sLCBvZmYgfTtcclxufVxyXG5mdW5jdGlvbiByZWN0YW5nbGVTZWxlY3Rpb25TdHlsZSh2aWV3LCBldmVudCkge1xyXG4gICAgbGV0IHN0YXJ0ID0gZ2V0UG9zKHZpZXcsIGV2ZW50KSwgc3RhcnRTZWwgPSB2aWV3LnN0YXRlLnNlbGVjdGlvbjtcclxuICAgIGlmICghc3RhcnQpXHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHVwZGF0ZSh1cGRhdGUpIHtcclxuICAgICAgICAgICAgaWYgKHVwZGF0ZS5kb2NDaGFuZ2VkKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgbmV3U3RhcnQgPSB1cGRhdGUuY2hhbmdlcy5tYXBQb3ModXBkYXRlLnN0YXJ0U3RhdGUuZG9jLmxpbmUoc3RhcnQubGluZSkuZnJvbSk7XHJcbiAgICAgICAgICAgICAgICBsZXQgbmV3TGluZSA9IHVwZGF0ZS5zdGF0ZS5kb2MubGluZUF0KG5ld1N0YXJ0KTtcclxuICAgICAgICAgICAgICAgIHN0YXJ0ID0geyBsaW5lOiBuZXdMaW5lLm51bWJlciwgY29sOiBzdGFydC5jb2wsIG9mZjogTWF0aC5taW4oc3RhcnQub2ZmLCBuZXdMaW5lLmxlbmd0aCkgfTtcclxuICAgICAgICAgICAgICAgIHN0YXJ0U2VsID0gc3RhcnRTZWwubWFwKHVwZGF0ZS5jaGFuZ2VzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZ2V0KGV2ZW50LCBfZXh0ZW5kLCBtdWx0aXBsZSkge1xyXG4gICAgICAgICAgICBsZXQgY3VyID0gZ2V0UG9zKHZpZXcsIGV2ZW50KTtcclxuICAgICAgICAgICAgaWYgKCFjdXIpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RhcnRTZWw7XHJcbiAgICAgICAgICAgIGxldCByYW5nZXMgPSByZWN0YW5nbGVGb3Iodmlldy5zdGF0ZSwgc3RhcnQsIGN1cik7XHJcbiAgICAgICAgICAgIGlmICghcmFuZ2VzLmxlbmd0aClcclxuICAgICAgICAgICAgICAgIHJldHVybiBzdGFydFNlbDtcclxuICAgICAgICAgICAgaWYgKG11bHRpcGxlKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIEVkaXRvclNlbGVjdGlvbi5jcmVhdGUocmFuZ2VzLmNvbmNhdChzdGFydFNlbC5yYW5nZXMpKTtcclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIEVkaXRvclNlbGVjdGlvbi5jcmVhdGUocmFuZ2VzKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG59XHJcbi8qKlxyXG5DcmVhdGUgYW4gZXh0ZW5zaW9uIHRoYXQgZW5hYmxlcyByZWN0YW5ndWxhciBzZWxlY3Rpb25zLiBCeVxyXG5kZWZhdWx0LCBpdCB3aWxsIHJlYWN0IHRvIGxlZnQgbW91c2UgZHJhZyB3aXRoIHRoZSBBbHQga2V5IGhlbGRcclxuZG93bi4gV2hlbiBzdWNoIGEgc2VsZWN0aW9uIG9jY3VycywgdGhlIHRleHQgd2l0aGluIHRoZSByZWN0YW5nbGVcclxudGhhdCB3YXMgZHJhZ2dlZCBvdmVyIHdpbGwgYmUgc2VsZWN0ZWQsIGFzIG9uZSBzZWxlY3Rpb25cclxuW3JhbmdlXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlNlbGVjdGlvblJhbmdlKSBwZXIgbGluZS5cclxuKi9cclxuZnVuY3Rpb24gcmVjdGFuZ3VsYXJTZWxlY3Rpb24ob3B0aW9ucykge1xyXG4gICAgbGV0IGZpbHRlciA9IChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuZXZlbnRGaWx0ZXIpIHx8IChlID0+IGUuYWx0S2V5ICYmIGUuYnV0dG9uID09IDApO1xyXG4gICAgcmV0dXJuIEVkaXRvclZpZXcubW91c2VTZWxlY3Rpb25TdHlsZS5vZigodmlldywgZXZlbnQpID0+IGZpbHRlcihldmVudCkgPyByZWN0YW5nbGVTZWxlY3Rpb25TdHlsZSh2aWV3LCBldmVudCkgOiBudWxsKTtcclxufVxyXG5jb25zdCBrZXlzID0ge1xyXG4gICAgQWx0OiBbMTgsIGUgPT4gZS5hbHRLZXldLFxyXG4gICAgQ29udHJvbDogWzE3LCBlID0+IGUuY3RybEtleV0sXHJcbiAgICBTaGlmdDogWzE2LCBlID0+IGUuc2hpZnRLZXldLFxyXG4gICAgTWV0YTogWzkxLCBlID0+IGUubWV0YUtleV1cclxufTtcclxuY29uc3Qgc2hvd0Nyb3NzaGFpciA9IHsgc3R5bGU6IFwiY3Vyc29yOiBjcm9zc2hhaXJcIiB9O1xyXG4vKipcclxuUmV0dXJucyBhbiBleHRlbnNpb24gdGhhdCB0dXJucyB0aGUgcG9pbnRlciBjdXJzb3IgaW50byBhXHJcbmNyb3NzaGFpciB3aGVuIGEgZ2l2ZW4gbW9kaWZpZXIga2V5LCBkZWZhdWx0aW5nIHRvIEFsdCwgaXMgaGVsZFxyXG5kb3duLiBDYW4gc2VydmUgYXMgYSB2aXN1YWwgaGludCB0aGF0IHJlY3Rhbmd1bGFyIHNlbGVjdGlvbiBpc1xyXG5nb2luZyB0byBoYXBwZW4gd2hlbiBwYWlyZWQgd2l0aFxyXG5bYHJlY3Rhbmd1bGFyU2VsZWN0aW9uYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LnJlY3Rhbmd1bGFyU2VsZWN0aW9uKS5cclxuKi9cclxuZnVuY3Rpb24gY3Jvc3NoYWlyQ3Vyc29yKG9wdGlvbnMgPSB7fSkge1xyXG4gICAgbGV0IFtjb2RlLCBnZXR0ZXJdID0ga2V5c1tvcHRpb25zLmtleSB8fCBcIkFsdFwiXTtcclxuICAgIGxldCBwbHVnaW4gPSBWaWV3UGx1Z2luLmZyb21DbGFzcyhjbGFzcyB7XHJcbiAgICAgICAgY29uc3RydWN0b3Iodmlldykge1xyXG4gICAgICAgICAgICB0aGlzLnZpZXcgPSB2aWV3O1xyXG4gICAgICAgICAgICB0aGlzLmlzRG93biA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBzZXQoaXNEb3duKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmlzRG93biAhPSBpc0Rvd24pIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuaXNEb3duID0gaXNEb3duO1xyXG4gICAgICAgICAgICAgICAgdGhpcy52aWV3LnVwZGF0ZShbXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9LCB7XHJcbiAgICAgICAgZXZlbnRIYW5kbGVyczoge1xyXG4gICAgICAgICAgICBrZXlkb3duKGUpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2V0KGUua2V5Q29kZSA9PSBjb2RlIHx8IGdldHRlcihlKSk7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGtleXVwKGUpIHtcclxuICAgICAgICAgICAgICAgIGlmIChlLmtleUNvZGUgPT0gY29kZSB8fCAhZ2V0dGVyKGUpKVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0KGZhbHNlKTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgbW91c2Vtb3ZlKGUpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2V0KGdldHRlcihlKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuICAgIHJldHVybiBbXHJcbiAgICAgICAgcGx1Z2luLFxyXG4gICAgICAgIEVkaXRvclZpZXcuY29udGVudEF0dHJpYnV0ZXMub2YodmlldyA9PiB7IHZhciBfYTsgcmV0dXJuICgoX2EgPSB2aWV3LnBsdWdpbihwbHVnaW4pKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaXNEb3duKSA/IHNob3dDcm9zc2hhaXIgOiBudWxsOyB9KVxyXG4gICAgXTtcclxufVxyXG5cclxuY29uc3QgT3V0c2lkZSA9IFwiLTEwMDAwcHhcIjtcclxuY2xhc3MgVG9vbHRpcFZpZXdNYW5hZ2VyIHtcclxuICAgIGNvbnN0cnVjdG9yKHZpZXcsIGZhY2V0LCBjcmVhdGVUb29sdGlwVmlldykge1xyXG4gICAgICAgIHRoaXMuZmFjZXQgPSBmYWNldDtcclxuICAgICAgICB0aGlzLmNyZWF0ZVRvb2x0aXBWaWV3ID0gY3JlYXRlVG9vbHRpcFZpZXc7XHJcbiAgICAgICAgdGhpcy5pbnB1dCA9IHZpZXcuc3RhdGUuZmFjZXQoZmFjZXQpO1xyXG4gICAgICAgIHRoaXMudG9vbHRpcHMgPSB0aGlzLmlucHV0LmZpbHRlcih0ID0+IHQpO1xyXG4gICAgICAgIHRoaXMudG9vbHRpcFZpZXdzID0gdGhpcy50b29sdGlwcy5tYXAoY3JlYXRlVG9vbHRpcFZpZXcpO1xyXG4gICAgfVxyXG4gICAgdXBkYXRlKHVwZGF0ZSkge1xyXG4gICAgICAgIHZhciBfYTtcclxuICAgICAgICBsZXQgaW5wdXQgPSB1cGRhdGUuc3RhdGUuZmFjZXQodGhpcy5mYWNldCk7XHJcbiAgICAgICAgbGV0IHRvb2x0aXBzID0gaW5wdXQuZmlsdGVyKHggPT4geCk7XHJcbiAgICAgICAgaWYgKGlucHV0ID09PSB0aGlzLmlucHV0KSB7XHJcbiAgICAgICAgICAgIGZvciAobGV0IHQgb2YgdGhpcy50b29sdGlwVmlld3MpXHJcbiAgICAgICAgICAgICAgICBpZiAodC51cGRhdGUpXHJcbiAgICAgICAgICAgICAgICAgICAgdC51cGRhdGUodXBkYXRlKTtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgdG9vbHRpcFZpZXdzID0gW107XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0b29sdGlwcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBsZXQgdGlwID0gdG9vbHRpcHNbaV0sIGtub3duID0gLTE7XHJcbiAgICAgICAgICAgIGlmICghdGlwKVxyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy50b29sdGlwcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgbGV0IG90aGVyID0gdGhpcy50b29sdGlwc1tpXTtcclxuICAgICAgICAgICAgICAgIGlmIChvdGhlciAmJiBvdGhlci5jcmVhdGUgPT0gdGlwLmNyZWF0ZSlcclxuICAgICAgICAgICAgICAgICAgICBrbm93biA9IGk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGtub3duIDwgMCkge1xyXG4gICAgICAgICAgICAgICAgdG9vbHRpcFZpZXdzW2ldID0gdGhpcy5jcmVhdGVUb29sdGlwVmlldyh0aXApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgbGV0IHRvb2x0aXBWaWV3ID0gdG9vbHRpcFZpZXdzW2ldID0gdGhpcy50b29sdGlwVmlld3Nba25vd25dO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRvb2x0aXBWaWV3LnVwZGF0ZSlcclxuICAgICAgICAgICAgICAgICAgICB0b29sdGlwVmlldy51cGRhdGUodXBkYXRlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBmb3IgKGxldCB0IG9mIHRoaXMudG9vbHRpcFZpZXdzKVxyXG4gICAgICAgICAgICBpZiAodG9vbHRpcFZpZXdzLmluZGV4T2YodCkgPCAwKSB7XHJcbiAgICAgICAgICAgICAgICB0LmRvbS5yZW1vdmUoKTtcclxuICAgICAgICAgICAgICAgIChfYSA9IHQuZGVzdHJveSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwodCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB0aGlzLmlucHV0ID0gaW5wdXQ7XHJcbiAgICAgICAgdGhpcy50b29sdGlwcyA9IHRvb2x0aXBzO1xyXG4gICAgICAgIHRoaXMudG9vbHRpcFZpZXdzID0gdG9vbHRpcFZpZXdzO1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG5DcmVhdGVzIGFuIGV4dGVuc2lvbiB0aGF0IGNvbmZpZ3VyZXMgdG9vbHRpcCBiZWhhdmlvci5cclxuKi9cclxuZnVuY3Rpb24gdG9vbHRpcHMoY29uZmlnID0ge30pIHtcclxuICAgIHJldHVybiB0b29sdGlwQ29uZmlnLm9mKGNvbmZpZyk7XHJcbn1cclxuZnVuY3Rpb24gd2luZG93U3BhY2Uodmlldykge1xyXG4gICAgbGV0IHsgd2luIH0gPSB2aWV3O1xyXG4gICAgcmV0dXJuIHsgdG9wOiAwLCBsZWZ0OiAwLCBib3R0b206IHdpbi5pbm5lckhlaWdodCwgcmlnaHQ6IHdpbi5pbm5lcldpZHRoIH07XHJcbn1cclxuY29uc3QgdG9vbHRpcENvbmZpZyA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoe1xyXG4gICAgY29tYmluZTogdmFsdWVzID0+IHtcclxuICAgICAgICB2YXIgX2EsIF9iLCBfYztcclxuICAgICAgICByZXR1cm4gKHtcclxuICAgICAgICAgICAgcG9zaXRpb246IGJyb3dzZXIuaW9zID8gXCJhYnNvbHV0ZVwiIDogKChfYSA9IHZhbHVlcy5maW5kKGNvbmYgPT4gY29uZi5wb3NpdGlvbikpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5wb3NpdGlvbikgfHwgXCJmaXhlZFwiLFxyXG4gICAgICAgICAgICBwYXJlbnQ6ICgoX2IgPSB2YWx1ZXMuZmluZChjb25mID0+IGNvbmYucGFyZW50KSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnBhcmVudCkgfHwgbnVsbCxcclxuICAgICAgICAgICAgdG9vbHRpcFNwYWNlOiAoKF9jID0gdmFsdWVzLmZpbmQoY29uZiA9PiBjb25mLnRvb2x0aXBTcGFjZSkpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy50b29sdGlwU3BhY2UpIHx8IHdpbmRvd1NwYWNlLFxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG59KTtcclxuY29uc3QgdG9vbHRpcFBsdWdpbiA9IC8qQF9fUFVSRV9fKi9WaWV3UGx1Z2luLmZyb21DbGFzcyhjbGFzcyB7XHJcbiAgICBjb25zdHJ1Y3Rvcih2aWV3KSB7XHJcbiAgICAgICAgdGhpcy52aWV3ID0gdmlldztcclxuICAgICAgICB0aGlzLmluVmlldyA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5sYXN0VHJhbnNhY3Rpb24gPSAwO1xyXG4gICAgICAgIHRoaXMubWVhc3VyZVRpbWVvdXQgPSAtMTtcclxuICAgICAgICBsZXQgY29uZmlnID0gdmlldy5zdGF0ZS5mYWNldCh0b29sdGlwQ29uZmlnKTtcclxuICAgICAgICB0aGlzLnBvc2l0aW9uID0gY29uZmlnLnBvc2l0aW9uO1xyXG4gICAgICAgIHRoaXMucGFyZW50ID0gY29uZmlnLnBhcmVudDtcclxuICAgICAgICB0aGlzLmNsYXNzZXMgPSB2aWV3LnRoZW1lQ2xhc3NlcztcclxuICAgICAgICB0aGlzLmNyZWF0ZUNvbnRhaW5lcigpO1xyXG4gICAgICAgIHRoaXMubWVhc3VyZVJlcSA9IHsgcmVhZDogdGhpcy5yZWFkTWVhc3VyZS5iaW5kKHRoaXMpLCB3cml0ZTogdGhpcy53cml0ZU1lYXN1cmUuYmluZCh0aGlzKSwga2V5OiB0aGlzIH07XHJcbiAgICAgICAgdGhpcy5tYW5hZ2VyID0gbmV3IFRvb2x0aXBWaWV3TWFuYWdlcih2aWV3LCBzaG93VG9vbHRpcCwgdCA9PiB0aGlzLmNyZWF0ZVRvb2x0aXAodCkpO1xyXG4gICAgICAgIHRoaXMuaW50ZXJzZWN0aW9uT2JzZXJ2ZXIgPSB0eXBlb2YgSW50ZXJzZWN0aW9uT2JzZXJ2ZXIgPT0gXCJmdW5jdGlvblwiID8gbmV3IEludGVyc2VjdGlvbk9ic2VydmVyKGVudHJpZXMgPT4ge1xyXG4gICAgICAgICAgICBpZiAoRGF0ZS5ub3coKSA+IHRoaXMubGFzdFRyYW5zYWN0aW9uIC0gNTAgJiZcclxuICAgICAgICAgICAgICAgIGVudHJpZXMubGVuZ3RoID4gMCAmJiBlbnRyaWVzW2VudHJpZXMubGVuZ3RoIC0gMV0uaW50ZXJzZWN0aW9uUmF0aW8gPCAxKVxyXG4gICAgICAgICAgICAgICAgdGhpcy5tZWFzdXJlU29vbigpO1xyXG4gICAgICAgIH0sIHsgdGhyZXNob2xkOiBbMV0gfSkgOiBudWxsO1xyXG4gICAgICAgIHRoaXMub2JzZXJ2ZUludGVyc2VjdGlvbigpO1xyXG4gICAgICAgIHZpZXcud2luLmFkZEV2ZW50TGlzdGVuZXIoXCJyZXNpemVcIiwgdGhpcy5tZWFzdXJlU29vbiA9IHRoaXMubWVhc3VyZVNvb24uYmluZCh0aGlzKSk7XHJcbiAgICAgICAgdGhpcy5tYXliZU1lYXN1cmUoKTtcclxuICAgIH1cclxuICAgIGNyZWF0ZUNvbnRhaW5lcigpIHtcclxuICAgICAgICBpZiAodGhpcy5wYXJlbnQpIHtcclxuICAgICAgICAgICAgdGhpcy5jb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xyXG4gICAgICAgICAgICB0aGlzLmNvbnRhaW5lci5zdHlsZS5wb3NpdGlvbiA9IFwicmVsYXRpdmVcIjtcclxuICAgICAgICAgICAgdGhpcy5jb250YWluZXIuY2xhc3NOYW1lID0gdGhpcy52aWV3LnRoZW1lQ2xhc3NlcztcclxuICAgICAgICAgICAgdGhpcy5wYXJlbnQuYXBwZW5kQ2hpbGQodGhpcy5jb250YWluZXIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5jb250YWluZXIgPSB0aGlzLnZpZXcuZG9tO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIG9ic2VydmVJbnRlcnNlY3Rpb24oKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuaW50ZXJzZWN0aW9uT2JzZXJ2ZXIpIHtcclxuICAgICAgICAgICAgdGhpcy5pbnRlcnNlY3Rpb25PYnNlcnZlci5kaXNjb25uZWN0KCk7XHJcbiAgICAgICAgICAgIGZvciAobGV0IHRvb2x0aXAgb2YgdGhpcy5tYW5hZ2VyLnRvb2x0aXBWaWV3cylcclxuICAgICAgICAgICAgICAgIHRoaXMuaW50ZXJzZWN0aW9uT2JzZXJ2ZXIub2JzZXJ2ZSh0b29sdGlwLmRvbSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgbWVhc3VyZVNvb24oKSB7XHJcbiAgICAgICAgaWYgKHRoaXMubWVhc3VyZVRpbWVvdXQgPCAwKVxyXG4gICAgICAgICAgICB0aGlzLm1lYXN1cmVUaW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm1lYXN1cmVUaW1lb3V0ID0gLTE7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm1heWJlTWVhc3VyZSgpO1xyXG4gICAgICAgICAgICB9LCA1MCk7XHJcbiAgICB9XHJcbiAgICB1cGRhdGUodXBkYXRlKSB7XHJcbiAgICAgICAgaWYgKHVwZGF0ZS50cmFuc2FjdGlvbnMubGVuZ3RoKVxyXG4gICAgICAgICAgICB0aGlzLmxhc3RUcmFuc2FjdGlvbiA9IERhdGUubm93KCk7XHJcbiAgICAgICAgbGV0IHVwZGF0ZWQgPSB0aGlzLm1hbmFnZXIudXBkYXRlKHVwZGF0ZSk7XHJcbiAgICAgICAgaWYgKHVwZGF0ZWQpXHJcbiAgICAgICAgICAgIHRoaXMub2JzZXJ2ZUludGVyc2VjdGlvbigpO1xyXG4gICAgICAgIGxldCBzaG91bGRNZWFzdXJlID0gdXBkYXRlZCB8fCB1cGRhdGUuZ2VvbWV0cnlDaGFuZ2VkO1xyXG4gICAgICAgIGxldCBuZXdDb25maWcgPSB1cGRhdGUuc3RhdGUuZmFjZXQodG9vbHRpcENvbmZpZyk7XHJcbiAgICAgICAgaWYgKG5ld0NvbmZpZy5wb3NpdGlvbiAhPSB0aGlzLnBvc2l0aW9uKSB7XHJcbiAgICAgICAgICAgIHRoaXMucG9zaXRpb24gPSBuZXdDb25maWcucG9zaXRpb247XHJcbiAgICAgICAgICAgIGZvciAobGV0IHQgb2YgdGhpcy5tYW5hZ2VyLnRvb2x0aXBWaWV3cylcclxuICAgICAgICAgICAgICAgIHQuZG9tLnN0eWxlLnBvc2l0aW9uID0gdGhpcy5wb3NpdGlvbjtcclxuICAgICAgICAgICAgc2hvdWxkTWVhc3VyZSA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChuZXdDb25maWcucGFyZW50ICE9IHRoaXMucGFyZW50KSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnBhcmVudClcclxuICAgICAgICAgICAgICAgIHRoaXMuY29udGFpbmVyLnJlbW92ZSgpO1xyXG4gICAgICAgICAgICB0aGlzLnBhcmVudCA9IG5ld0NvbmZpZy5wYXJlbnQ7XHJcbiAgICAgICAgICAgIHRoaXMuY3JlYXRlQ29udGFpbmVyKCk7XHJcbiAgICAgICAgICAgIGZvciAobGV0IHQgb2YgdGhpcy5tYW5hZ2VyLnRvb2x0aXBWaWV3cylcclxuICAgICAgICAgICAgICAgIHRoaXMuY29udGFpbmVyLmFwcGVuZENoaWxkKHQuZG9tKTtcclxuICAgICAgICAgICAgc2hvdWxkTWVhc3VyZSA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHRoaXMucGFyZW50ICYmIHRoaXMudmlldy50aGVtZUNsYXNzZXMgIT0gdGhpcy5jbGFzc2VzKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY2xhc3NlcyA9IHRoaXMuY29udGFpbmVyLmNsYXNzTmFtZSA9IHRoaXMudmlldy50aGVtZUNsYXNzZXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChzaG91bGRNZWFzdXJlKVxyXG4gICAgICAgICAgICB0aGlzLm1heWJlTWVhc3VyZSgpO1xyXG4gICAgfVxyXG4gICAgY3JlYXRlVG9vbHRpcCh0b29sdGlwKSB7XHJcbiAgICAgICAgbGV0IHRvb2x0aXBWaWV3ID0gdG9vbHRpcC5jcmVhdGUodGhpcy52aWV3KTtcclxuICAgICAgICB0b29sdGlwVmlldy5kb20uY2xhc3NMaXN0LmFkZChcImNtLXRvb2x0aXBcIik7XHJcbiAgICAgICAgaWYgKHRvb2x0aXAuYXJyb3cgJiYgIXRvb2x0aXBWaWV3LmRvbS5xdWVyeVNlbGVjdG9yKFwiLmNtLXRvb2x0aXAgPiAuY20tdG9vbHRpcC1hcnJvd1wiKSkge1xyXG4gICAgICAgICAgICBsZXQgYXJyb3cgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xyXG4gICAgICAgICAgICBhcnJvdy5jbGFzc05hbWUgPSBcImNtLXRvb2x0aXAtYXJyb3dcIjtcclxuICAgICAgICAgICAgdG9vbHRpcFZpZXcuZG9tLmFwcGVuZENoaWxkKGFycm93KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdG9vbHRpcFZpZXcuZG9tLnN0eWxlLnBvc2l0aW9uID0gdGhpcy5wb3NpdGlvbjtcclxuICAgICAgICB0b29sdGlwVmlldy5kb20uc3R5bGUudG9wID0gT3V0c2lkZTtcclxuICAgICAgICB0aGlzLmNvbnRhaW5lci5hcHBlbmRDaGlsZCh0b29sdGlwVmlldy5kb20pO1xyXG4gICAgICAgIGlmICh0b29sdGlwVmlldy5tb3VudClcclxuICAgICAgICAgICAgdG9vbHRpcFZpZXcubW91bnQodGhpcy52aWV3KTtcclxuICAgICAgICByZXR1cm4gdG9vbHRpcFZpZXc7XHJcbiAgICB9XHJcbiAgICBkZXN0cm95KCkge1xyXG4gICAgICAgIHZhciBfYSwgX2I7XHJcbiAgICAgICAgdGhpcy52aWV3Lndpbi5yZW1vdmVFdmVudExpc3RlbmVyKFwicmVzaXplXCIsIHRoaXMubWVhc3VyZVNvb24pO1xyXG4gICAgICAgIGZvciAobGV0IHRvb2x0aXBWaWV3IG9mIHRoaXMubWFuYWdlci50b29sdGlwVmlld3MpIHtcclxuICAgICAgICAgICAgdG9vbHRpcFZpZXcuZG9tLnJlbW92ZSgpO1xyXG4gICAgICAgICAgICAoX2EgPSB0b29sdGlwVmlldy5kZXN0cm95KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbCh0b29sdGlwVmlldyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIChfYiA9IHRoaXMuaW50ZXJzZWN0aW9uT2JzZXJ2ZXIpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5kaXNjb25uZWN0KCk7XHJcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMubWVhc3VyZVRpbWVvdXQpO1xyXG4gICAgfVxyXG4gICAgcmVhZE1lYXN1cmUoKSB7XHJcbiAgICAgICAgbGV0IGVkaXRvciA9IHRoaXMudmlldy5kb20uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgZWRpdG9yLFxyXG4gICAgICAgICAgICBwYXJlbnQ6IHRoaXMucGFyZW50ID8gdGhpcy5jb250YWluZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkgOiBlZGl0b3IsXHJcbiAgICAgICAgICAgIHBvczogdGhpcy5tYW5hZ2VyLnRvb2x0aXBzLm1hcCgodCwgaSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgbGV0IHR2ID0gdGhpcy5tYW5hZ2VyLnRvb2x0aXBWaWV3c1tpXTtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0di5nZXRDb29yZHMgPyB0di5nZXRDb29yZHModC5wb3MpIDogdGhpcy52aWV3LmNvb3Jkc0F0UG9zKHQucG9zKTtcclxuICAgICAgICAgICAgfSksXHJcbiAgICAgICAgICAgIHNpemU6IHRoaXMubWFuYWdlci50b29sdGlwVmlld3MubWFwKCh7IGRvbSB9KSA9PiBkb20uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkpLFxyXG4gICAgICAgICAgICBzcGFjZTogdGhpcy52aWV3LnN0YXRlLmZhY2V0KHRvb2x0aXBDb25maWcpLnRvb2x0aXBTcGFjZSh0aGlzLnZpZXcpLFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICB3cml0ZU1lYXN1cmUobWVhc3VyZWQpIHtcclxuICAgICAgICBsZXQgeyBlZGl0b3IsIHNwYWNlIH0gPSBtZWFzdXJlZDtcclxuICAgICAgICBsZXQgb3RoZXJzID0gW107XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLm1hbmFnZXIudG9vbHRpcHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgbGV0IHRvb2x0aXAgPSB0aGlzLm1hbmFnZXIudG9vbHRpcHNbaV0sIHRWaWV3ID0gdGhpcy5tYW5hZ2VyLnRvb2x0aXBWaWV3c1tpXSwgeyBkb20gfSA9IHRWaWV3O1xyXG4gICAgICAgICAgICBsZXQgcG9zID0gbWVhc3VyZWQucG9zW2ldLCBzaXplID0gbWVhc3VyZWQuc2l6ZVtpXTtcclxuICAgICAgICAgICAgLy8gSGlkZSB0b29sdGlwcyB0aGF0IGFyZSBvdXRzaWRlIG9mIHRoZSBlZGl0b3IuXHJcbiAgICAgICAgICAgIGlmICghcG9zIHx8IHBvcy5ib3R0b20gPD0gTWF0aC5tYXgoZWRpdG9yLnRvcCwgc3BhY2UudG9wKSB8fFxyXG4gICAgICAgICAgICAgICAgcG9zLnRvcCA+PSBNYXRoLm1pbihlZGl0b3IuYm90dG9tLCBzcGFjZS5ib3R0b20pIHx8XHJcbiAgICAgICAgICAgICAgICBwb3MucmlnaHQgPCBNYXRoLm1heChlZGl0b3IubGVmdCwgc3BhY2UubGVmdCkgLSAuMSB8fFxyXG4gICAgICAgICAgICAgICAgcG9zLmxlZnQgPiBNYXRoLm1pbihlZGl0b3IucmlnaHQsIHNwYWNlLnJpZ2h0KSArIC4xKSB7XHJcbiAgICAgICAgICAgICAgICBkb20uc3R5bGUudG9wID0gT3V0c2lkZTtcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGxldCBhcnJvdyA9IHRvb2x0aXAuYXJyb3cgPyB0Vmlldy5kb20ucXVlcnlTZWxlY3RvcihcIi5jbS10b29sdGlwLWFycm93XCIpIDogbnVsbDtcclxuICAgICAgICAgICAgbGV0IGFycm93SGVpZ2h0ID0gYXJyb3cgPyA3IC8qIEFycm93LlNpemUgKi8gOiAwO1xyXG4gICAgICAgICAgICBsZXQgd2lkdGggPSBzaXplLnJpZ2h0IC0gc2l6ZS5sZWZ0LCBoZWlnaHQgPSBzaXplLmJvdHRvbSAtIHNpemUudG9wO1xyXG4gICAgICAgICAgICBsZXQgb2Zmc2V0ID0gdFZpZXcub2Zmc2V0IHx8IG5vT2Zmc2V0LCBsdHIgPSB0aGlzLnZpZXcudGV4dERpcmVjdGlvbiA9PSBEaXJlY3Rpb24uTFRSO1xyXG4gICAgICAgICAgICBsZXQgbGVmdCA9IHNpemUud2lkdGggPiBzcGFjZS5yaWdodCAtIHNwYWNlLmxlZnQgPyAobHRyID8gc3BhY2UubGVmdCA6IHNwYWNlLnJpZ2h0IC0gc2l6ZS53aWR0aClcclxuICAgICAgICAgICAgICAgIDogbHRyID8gTWF0aC5taW4ocG9zLmxlZnQgLSAoYXJyb3cgPyAxNCAvKiBBcnJvdy5PZmZzZXQgKi8gOiAwKSArIG9mZnNldC54LCBzcGFjZS5yaWdodCAtIHdpZHRoKVxyXG4gICAgICAgICAgICAgICAgICAgIDogTWF0aC5tYXgoc3BhY2UubGVmdCwgcG9zLmxlZnQgLSB3aWR0aCArIChhcnJvdyA/IDE0IC8qIEFycm93Lk9mZnNldCAqLyA6IDApIC0gb2Zmc2V0LngpO1xyXG4gICAgICAgICAgICBsZXQgYWJvdmUgPSAhIXRvb2x0aXAuYWJvdmU7XHJcbiAgICAgICAgICAgIGlmICghdG9vbHRpcC5zdHJpY3RTaWRlICYmIChhYm92ZVxyXG4gICAgICAgICAgICAgICAgPyBwb3MudG9wIC0gKHNpemUuYm90dG9tIC0gc2l6ZS50b3ApIC0gb2Zmc2V0LnkgPCBzcGFjZS50b3BcclxuICAgICAgICAgICAgICAgIDogcG9zLmJvdHRvbSArIChzaXplLmJvdHRvbSAtIHNpemUudG9wKSArIG9mZnNldC55ID4gc3BhY2UuYm90dG9tKSAmJlxyXG4gICAgICAgICAgICAgICAgYWJvdmUgPT0gKHNwYWNlLmJvdHRvbSAtIHBvcy5ib3R0b20gPiBwb3MudG9wIC0gc3BhY2UudG9wKSlcclxuICAgICAgICAgICAgICAgIGFib3ZlID0gIWFib3ZlO1xyXG4gICAgICAgICAgICBsZXQgc3BhY2VWZXJ0ID0gKGFib3ZlID8gcG9zLnRvcCAtIHNwYWNlLnRvcCA6IHNwYWNlLmJvdHRvbSAtIHBvcy5ib3R0b20pIC0gYXJyb3dIZWlnaHQ7XHJcbiAgICAgICAgICAgIGlmIChzcGFjZVZlcnQgPCBoZWlnaHQgJiYgdFZpZXcucmVzaXplICE9PSBmYWxzZSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHNwYWNlVmVydCA8IHRoaXMudmlldy5kZWZhdWx0TGluZUhlaWdodCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGRvbS5zdHlsZS50b3AgPSBPdXRzaWRlO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZG9tLnN0eWxlLmhlaWdodCA9IChoZWlnaHQgPSBzcGFjZVZlcnQpICsgXCJweFwiO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGRvbS5zdHlsZS5oZWlnaHQpIHtcclxuICAgICAgICAgICAgICAgIGRvbS5zdHlsZS5oZWlnaHQgPSBcIlwiO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGxldCB0b3AgPSBhYm92ZSA/IHBvcy50b3AgLSBoZWlnaHQgLSBhcnJvd0hlaWdodCAtIG9mZnNldC55IDogcG9zLmJvdHRvbSArIGFycm93SGVpZ2h0ICsgb2Zmc2V0Lnk7XHJcbiAgICAgICAgICAgIGxldCByaWdodCA9IGxlZnQgKyB3aWR0aDtcclxuICAgICAgICAgICAgaWYgKHRWaWV3Lm92ZXJsYXAgIT09IHRydWUpXHJcbiAgICAgICAgICAgICAgICBmb3IgKGxldCByIG9mIG90aGVycylcclxuICAgICAgICAgICAgICAgICAgICBpZiAoci5sZWZ0IDwgcmlnaHQgJiYgci5yaWdodCA+IGxlZnQgJiYgci50b3AgPCB0b3AgKyBoZWlnaHQgJiYgci5ib3R0b20gPiB0b3ApXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvcCA9IGFib3ZlID8gci50b3AgLSBoZWlnaHQgLSAyIC0gYXJyb3dIZWlnaHQgOiByLmJvdHRvbSArIGFycm93SGVpZ2h0ICsgMjtcclxuICAgICAgICAgICAgaWYgKHRoaXMucG9zaXRpb24gPT0gXCJhYnNvbHV0ZVwiKSB7XHJcbiAgICAgICAgICAgICAgICBkb20uc3R5bGUudG9wID0gKHRvcCAtIG1lYXN1cmVkLnBhcmVudC50b3ApICsgXCJweFwiO1xyXG4gICAgICAgICAgICAgICAgZG9tLnN0eWxlLmxlZnQgPSAobGVmdCAtIG1lYXN1cmVkLnBhcmVudC5sZWZ0KSArIFwicHhcIjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGRvbS5zdHlsZS50b3AgPSB0b3AgKyBcInB4XCI7XHJcbiAgICAgICAgICAgICAgICBkb20uc3R5bGUubGVmdCA9IGxlZnQgKyBcInB4XCI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGFycm93KVxyXG4gICAgICAgICAgICAgICAgYXJyb3cuc3R5bGUubGVmdCA9IGAke3Bvcy5sZWZ0ICsgKGx0ciA/IG9mZnNldC54IDogLW9mZnNldC54KSAtIChsZWZ0ICsgMTQgLyogQXJyb3cuT2Zmc2V0ICovIC0gNyAvKiBBcnJvdy5TaXplICovKX1weGA7XHJcbiAgICAgICAgICAgIGlmICh0Vmlldy5vdmVybGFwICE9PSB0cnVlKVxyXG4gICAgICAgICAgICAgICAgb3RoZXJzLnB1c2goeyBsZWZ0LCB0b3AsIHJpZ2h0LCBib3R0b206IHRvcCArIGhlaWdodCB9KTtcclxuICAgICAgICAgICAgZG9tLmNsYXNzTGlzdC50b2dnbGUoXCJjbS10b29sdGlwLWFib3ZlXCIsIGFib3ZlKTtcclxuICAgICAgICAgICAgZG9tLmNsYXNzTGlzdC50b2dnbGUoXCJjbS10b29sdGlwLWJlbG93XCIsICFhYm92ZSk7XHJcbiAgICAgICAgICAgIGlmICh0Vmlldy5wb3NpdGlvbmVkKVxyXG4gICAgICAgICAgICAgICAgdFZpZXcucG9zaXRpb25lZChtZWFzdXJlZC5zcGFjZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgbWF5YmVNZWFzdXJlKCkge1xyXG4gICAgICAgIGlmICh0aGlzLm1hbmFnZXIudG9vbHRpcHMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnZpZXcuaW5WaWV3KVxyXG4gICAgICAgICAgICAgICAgdGhpcy52aWV3LnJlcXVlc3RNZWFzdXJlKHRoaXMubWVhc3VyZVJlcSk7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmluVmlldyAhPSB0aGlzLnZpZXcuaW5WaWV3KSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmluVmlldyA9IHRoaXMudmlldy5pblZpZXc7XHJcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuaW5WaWV3KVxyXG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IHR2IG9mIHRoaXMubWFuYWdlci50b29sdGlwVmlld3MpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHR2LmRvbS5zdHlsZS50b3AgPSBPdXRzaWRlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59LCB7XHJcbiAgICBldmVudEhhbmRsZXJzOiB7XHJcbiAgICAgICAgc2Nyb2xsKCkgeyB0aGlzLm1heWJlTWVhc3VyZSgpOyB9XHJcbiAgICB9XHJcbn0pO1xyXG5jb25zdCBiYXNlVGhlbWUgPSAvKkBfX1BVUkVfXyovRWRpdG9yVmlldy5iYXNlVGhlbWUoe1xyXG4gICAgXCIuY20tdG9vbHRpcFwiOiB7XHJcbiAgICAgICAgekluZGV4OiAxMDAsXHJcbiAgICAgICAgYm94U2l6aW5nOiBcImJvcmRlci1ib3hcIlxyXG4gICAgfSxcclxuICAgIFwiJmxpZ2h0IC5jbS10b29sdGlwXCI6IHtcclxuICAgICAgICBib3JkZXI6IFwiMXB4IHNvbGlkICNiYmJcIixcclxuICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IFwiI2Y1ZjVmNVwiXHJcbiAgICB9LFxyXG4gICAgXCImbGlnaHQgLmNtLXRvb2x0aXAtc2VjdGlvbjpub3QoOmZpcnN0LWNoaWxkKVwiOiB7XHJcbiAgICAgICAgYm9yZGVyVG9wOiBcIjFweCBzb2xpZCAjYmJiXCIsXHJcbiAgICB9LFxyXG4gICAgXCImZGFyayAuY20tdG9vbHRpcFwiOiB7XHJcbiAgICAgICAgYmFja2dyb3VuZENvbG9yOiBcIiMzMzMzMzhcIixcclxuICAgICAgICBjb2xvcjogXCJ3aGl0ZVwiXHJcbiAgICB9LFxyXG4gICAgXCIuY20tdG9vbHRpcC1hcnJvd1wiOiB7XHJcbiAgICAgICAgaGVpZ2h0OiBgJHs3IC8qIEFycm93LlNpemUgKi99cHhgLFxyXG4gICAgICAgIHdpZHRoOiBgJHs3IC8qIEFycm93LlNpemUgKi8gKiAyfXB4YCxcclxuICAgICAgICBwb3NpdGlvbjogXCJhYnNvbHV0ZVwiLFxyXG4gICAgICAgIHpJbmRleDogLTEsXHJcbiAgICAgICAgb3ZlcmZsb3c6IFwiaGlkZGVuXCIsXHJcbiAgICAgICAgXCImOmJlZm9yZSwgJjphZnRlclwiOiB7XHJcbiAgICAgICAgICAgIGNvbnRlbnQ6IFwiJydcIixcclxuICAgICAgICAgICAgcG9zaXRpb246IFwiYWJzb2x1dGVcIixcclxuICAgICAgICAgICAgd2lkdGg6IDAsXHJcbiAgICAgICAgICAgIGhlaWdodDogMCxcclxuICAgICAgICAgICAgYm9yZGVyTGVmdDogYCR7NyAvKiBBcnJvdy5TaXplICovfXB4IHNvbGlkIHRyYW5zcGFyZW50YCxcclxuICAgICAgICAgICAgYm9yZGVyUmlnaHQ6IGAkezcgLyogQXJyb3cuU2l6ZSAqL31weCBzb2xpZCB0cmFuc3BhcmVudGAsXHJcbiAgICAgICAgfSxcclxuICAgICAgICBcIi5jbS10b29sdGlwLWFib3ZlICZcIjoge1xyXG4gICAgICAgICAgICBib3R0b206IGAtJHs3IC8qIEFycm93LlNpemUgKi99cHhgLFxyXG4gICAgICAgICAgICBcIiY6YmVmb3JlXCI6IHtcclxuICAgICAgICAgICAgICAgIGJvcmRlclRvcDogYCR7NyAvKiBBcnJvdy5TaXplICovfXB4IHNvbGlkICNiYmJgLFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBcIiY6YWZ0ZXJcIjoge1xyXG4gICAgICAgICAgICAgICAgYm9yZGVyVG9wOiBgJHs3IC8qIEFycm93LlNpemUgKi99cHggc29saWQgI2Y1ZjVmNWAsXHJcbiAgICAgICAgICAgICAgICBib3R0b206IFwiMXB4XCJcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgXCIuY20tdG9vbHRpcC1iZWxvdyAmXCI6IHtcclxuICAgICAgICAgICAgdG9wOiBgLSR7NyAvKiBBcnJvdy5TaXplICovfXB4YCxcclxuICAgICAgICAgICAgXCImOmJlZm9yZVwiOiB7XHJcbiAgICAgICAgICAgICAgICBib3JkZXJCb3R0b206IGAkezcgLyogQXJyb3cuU2l6ZSAqL31weCBzb2xpZCAjYmJiYCxcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgXCImOmFmdGVyXCI6IHtcclxuICAgICAgICAgICAgICAgIGJvcmRlckJvdHRvbTogYCR7NyAvKiBBcnJvdy5TaXplICovfXB4IHNvbGlkICNmNWY1ZjVgLFxyXG4gICAgICAgICAgICAgICAgdG9wOiBcIjFweFwiXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgfSxcclxuICAgIFwiJmRhcmsgLmNtLXRvb2x0aXAgLmNtLXRvb2x0aXAtYXJyb3dcIjoge1xyXG4gICAgICAgIFwiJjpiZWZvcmVcIjoge1xyXG4gICAgICAgICAgICBib3JkZXJUb3BDb2xvcjogXCIjMzMzMzM4XCIsXHJcbiAgICAgICAgICAgIGJvcmRlckJvdHRvbUNvbG9yOiBcIiMzMzMzMzhcIlxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgXCImOmFmdGVyXCI6IHtcclxuICAgICAgICAgICAgYm9yZGVyVG9wQ29sb3I6IFwidHJhbnNwYXJlbnRcIixcclxuICAgICAgICAgICAgYm9yZGVyQm90dG9tQ29sb3I6IFwidHJhbnNwYXJlbnRcIlxyXG4gICAgICAgIH1cclxuICAgIH1cclxufSk7XHJcbmNvbnN0IG5vT2Zmc2V0ID0geyB4OiAwLCB5OiAwIH07XHJcbi8qKlxyXG5GYWNldCB0byB3aGljaCBhbiBleHRlbnNpb24gY2FuIGFkZCBhIHZhbHVlIHRvIHNob3cgYSB0b29sdGlwLlxyXG4qL1xyXG5jb25zdCBzaG93VG9vbHRpcCA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoe1xyXG4gICAgZW5hYmxlczogW3Rvb2x0aXBQbHVnaW4sIGJhc2VUaGVtZV1cclxufSk7XHJcbmNvbnN0IHNob3dIb3ZlclRvb2x0aXAgPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKCk7XHJcbmNsYXNzIEhvdmVyVG9vbHRpcEhvc3Qge1xyXG4gICAgY29uc3RydWN0b3Iodmlldykge1xyXG4gICAgICAgIHRoaXMudmlldyA9IHZpZXc7XHJcbiAgICAgICAgdGhpcy5tb3VudGVkID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5kb20gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xyXG4gICAgICAgIHRoaXMuZG9tLmNsYXNzTGlzdC5hZGQoXCJjbS10b29sdGlwLWhvdmVyXCIpO1xyXG4gICAgICAgIHRoaXMubWFuYWdlciA9IG5ldyBUb29sdGlwVmlld01hbmFnZXIodmlldywgc2hvd0hvdmVyVG9vbHRpcCwgdCA9PiB0aGlzLmNyZWF0ZUhvc3RlZFZpZXcodCkpO1xyXG4gICAgfVxyXG4gICAgLy8gTmVlZHMgdG8gYmUgc3RhdGljIHNvIHRoYXQgaG9zdCB0b29sdGlwIGluc3RhbmNlcyBhbHdheXMgbWF0Y2hcclxuICAgIHN0YXRpYyBjcmVhdGUodmlldykge1xyXG4gICAgICAgIHJldHVybiBuZXcgSG92ZXJUb29sdGlwSG9zdCh2aWV3KTtcclxuICAgIH1cclxuICAgIGNyZWF0ZUhvc3RlZFZpZXcodG9vbHRpcCkge1xyXG4gICAgICAgIGxldCBob3N0ZWRWaWV3ID0gdG9vbHRpcC5jcmVhdGUodGhpcy52aWV3KTtcclxuICAgICAgICBob3N0ZWRWaWV3LmRvbS5jbGFzc0xpc3QuYWRkKFwiY20tdG9vbHRpcC1zZWN0aW9uXCIpO1xyXG4gICAgICAgIHRoaXMuZG9tLmFwcGVuZENoaWxkKGhvc3RlZFZpZXcuZG9tKTtcclxuICAgICAgICBpZiAodGhpcy5tb3VudGVkICYmIGhvc3RlZFZpZXcubW91bnQpXHJcbiAgICAgICAgICAgIGhvc3RlZFZpZXcubW91bnQodGhpcy52aWV3KTtcclxuICAgICAgICByZXR1cm4gaG9zdGVkVmlldztcclxuICAgIH1cclxuICAgIG1vdW50KHZpZXcpIHtcclxuICAgICAgICBmb3IgKGxldCBob3N0ZWRWaWV3IG9mIHRoaXMubWFuYWdlci50b29sdGlwVmlld3MpIHtcclxuICAgICAgICAgICAgaWYgKGhvc3RlZFZpZXcubW91bnQpXHJcbiAgICAgICAgICAgICAgICBob3N0ZWRWaWV3Lm1vdW50KHZpZXcpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLm1vdW50ZWQgPSB0cnVlO1xyXG4gICAgfVxyXG4gICAgcG9zaXRpb25lZChzcGFjZSkge1xyXG4gICAgICAgIGZvciAobGV0IGhvc3RlZFZpZXcgb2YgdGhpcy5tYW5hZ2VyLnRvb2x0aXBWaWV3cykge1xyXG4gICAgICAgICAgICBpZiAoaG9zdGVkVmlldy5wb3NpdGlvbmVkKVxyXG4gICAgICAgICAgICAgICAgaG9zdGVkVmlldy5wb3NpdGlvbmVkKHNwYWNlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICB1cGRhdGUodXBkYXRlKSB7XHJcbiAgICAgICAgdGhpcy5tYW5hZ2VyLnVwZGF0ZSh1cGRhdGUpO1xyXG4gICAgfVxyXG59XHJcbmNvbnN0IHNob3dIb3ZlclRvb2x0aXBIb3N0ID0gLypAX19QVVJFX18qL3Nob3dUb29sdGlwLmNvbXB1dGUoW3Nob3dIb3ZlclRvb2x0aXBdLCBzdGF0ZSA9PiB7XHJcbiAgICBsZXQgdG9vbHRpcHMgPSBzdGF0ZS5mYWNldChzaG93SG92ZXJUb29sdGlwKS5maWx0ZXIodCA9PiB0KTtcclxuICAgIGlmICh0b29sdGlwcy5sZW5ndGggPT09IDApXHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHBvczogTWF0aC5taW4oLi4udG9vbHRpcHMubWFwKHQgPT4gdC5wb3MpKSxcclxuICAgICAgICBlbmQ6IE1hdGgubWF4KC4uLnRvb2x0aXBzLmZpbHRlcih0ID0+IHQuZW5kICE9IG51bGwpLm1hcCh0ID0+IHQuZW5kKSksXHJcbiAgICAgICAgY3JlYXRlOiBIb3ZlclRvb2x0aXBIb3N0LmNyZWF0ZSxcclxuICAgICAgICBhYm92ZTogdG9vbHRpcHNbMF0uYWJvdmUsXHJcbiAgICAgICAgYXJyb3c6IHRvb2x0aXBzLnNvbWUodCA9PiB0LmFycm93KSxcclxuICAgIH07XHJcbn0pO1xyXG5jbGFzcyBIb3ZlclBsdWdpbiB7XHJcbiAgICBjb25zdHJ1Y3Rvcih2aWV3LCBzb3VyY2UsIGZpZWxkLCBzZXRIb3ZlciwgaG92ZXJUaW1lKSB7XHJcbiAgICAgICAgdGhpcy52aWV3ID0gdmlldztcclxuICAgICAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcclxuICAgICAgICB0aGlzLmZpZWxkID0gZmllbGQ7XHJcbiAgICAgICAgdGhpcy5zZXRIb3ZlciA9IHNldEhvdmVyO1xyXG4gICAgICAgIHRoaXMuaG92ZXJUaW1lID0gaG92ZXJUaW1lO1xyXG4gICAgICAgIHRoaXMuaG92ZXJUaW1lb3V0ID0gLTE7XHJcbiAgICAgICAgdGhpcy5yZXN0YXJ0VGltZW91dCA9IC0xO1xyXG4gICAgICAgIHRoaXMucGVuZGluZyA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5sYXN0TW92ZSA9IHsgeDogMCwgeTogMCwgdGFyZ2V0OiB2aWV3LmRvbSwgdGltZTogMCB9O1xyXG4gICAgICAgIHRoaXMuY2hlY2tIb3ZlciA9IHRoaXMuY2hlY2tIb3Zlci5iaW5kKHRoaXMpO1xyXG4gICAgICAgIHZpZXcuZG9tLmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZWxlYXZlXCIsIHRoaXMubW91c2VsZWF2ZSA9IHRoaXMubW91c2VsZWF2ZS5iaW5kKHRoaXMpKTtcclxuICAgICAgICB2aWV3LmRvbS5hZGRFdmVudExpc3RlbmVyKFwibW91c2Vtb3ZlXCIsIHRoaXMubW91c2Vtb3ZlID0gdGhpcy5tb3VzZW1vdmUuYmluZCh0aGlzKSk7XHJcbiAgICB9XHJcbiAgICB1cGRhdGUoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMucGVuZGluZykge1xyXG4gICAgICAgICAgICB0aGlzLnBlbmRpbmcgPSBudWxsO1xyXG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5yZXN0YXJ0VGltZW91dCk7XHJcbiAgICAgICAgICAgIHRoaXMucmVzdGFydFRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHRoaXMuc3RhcnRIb3ZlcigpLCAyMCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZ2V0IGFjdGl2ZSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy52aWV3LnN0YXRlLmZpZWxkKHRoaXMuZmllbGQpO1xyXG4gICAgfVxyXG4gICAgY2hlY2tIb3ZlcigpIHtcclxuICAgICAgICB0aGlzLmhvdmVyVGltZW91dCA9IC0xO1xyXG4gICAgICAgIGlmICh0aGlzLmFjdGl2ZSlcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIGxldCBob3ZlcmVkID0gRGF0ZS5ub3coKSAtIHRoaXMubGFzdE1vdmUudGltZTtcclxuICAgICAgICBpZiAoaG92ZXJlZCA8IHRoaXMuaG92ZXJUaW1lKVxyXG4gICAgICAgICAgICB0aGlzLmhvdmVyVGltZW91dCA9IHNldFRpbWVvdXQodGhpcy5jaGVja0hvdmVyLCB0aGlzLmhvdmVyVGltZSAtIGhvdmVyZWQpO1xyXG4gICAgICAgIGVsc2VcclxuICAgICAgICAgICAgdGhpcy5zdGFydEhvdmVyKCk7XHJcbiAgICB9XHJcbiAgICBzdGFydEhvdmVyKCkge1xyXG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnJlc3RhcnRUaW1lb3V0KTtcclxuICAgICAgICBsZXQgeyBsYXN0TW92ZSB9ID0gdGhpcztcclxuICAgICAgICBsZXQgcG9zID0gdGhpcy52aWV3LmNvbnRlbnRET00uY29udGFpbnMobGFzdE1vdmUudGFyZ2V0KSA/IHRoaXMudmlldy5wb3NBdENvb3JkcyhsYXN0TW92ZSkgOiBudWxsO1xyXG4gICAgICAgIGlmIChwb3MgPT0gbnVsbClcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIGxldCBwb3NDb29yZHMgPSB0aGlzLnZpZXcuY29vcmRzQXRQb3MocG9zKTtcclxuICAgICAgICBpZiAocG9zQ29vcmRzID09IG51bGwgfHwgbGFzdE1vdmUueSA8IHBvc0Nvb3Jkcy50b3AgfHwgbGFzdE1vdmUueSA+IHBvc0Nvb3Jkcy5ib3R0b20gfHxcclxuICAgICAgICAgICAgbGFzdE1vdmUueCA8IHBvc0Nvb3Jkcy5sZWZ0IC0gdGhpcy52aWV3LmRlZmF1bHRDaGFyYWN0ZXJXaWR0aCB8fFxyXG4gICAgICAgICAgICBsYXN0TW92ZS54ID4gcG9zQ29vcmRzLnJpZ2h0ICsgdGhpcy52aWV3LmRlZmF1bHRDaGFyYWN0ZXJXaWR0aClcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIGxldCBiaWRpID0gdGhpcy52aWV3LmJpZGlTcGFucyh0aGlzLnZpZXcuc3RhdGUuZG9jLmxpbmVBdChwb3MpKS5maW5kKHMgPT4gcy5mcm9tIDw9IHBvcyAmJiBzLnRvID49IHBvcyk7XHJcbiAgICAgICAgbGV0IHJ0bCA9IGJpZGkgJiYgYmlkaS5kaXIgPT0gRGlyZWN0aW9uLlJUTCA/IC0xIDogMTtcclxuICAgICAgICBsZXQgb3BlbiA9IHRoaXMuc291cmNlKHRoaXMudmlldywgcG9zLCAobGFzdE1vdmUueCA8IHBvc0Nvb3Jkcy5sZWZ0ID8gLXJ0bCA6IHJ0bCkpO1xyXG4gICAgICAgIGlmIChvcGVuID09PSBudWxsIHx8IG9wZW4gPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wZW4udGhlbikge1xyXG4gICAgICAgICAgICBsZXQgcGVuZGluZyA9IHRoaXMucGVuZGluZyA9IHsgcG9zIH07XHJcbiAgICAgICAgICAgIG9wZW4udGhlbihyZXN1bHQgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucGVuZGluZyA9PSBwZW5kaW5nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wZW5kaW5nID0gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnZpZXcuZGlzcGF0Y2goeyBlZmZlY3RzOiB0aGlzLnNldEhvdmVyLm9mKHJlc3VsdCkgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sIGUgPT4gbG9nRXhjZXB0aW9uKHRoaXMudmlldy5zdGF0ZSwgZSwgXCJob3ZlciB0b29sdGlwXCIpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAob3Blbikge1xyXG4gICAgICAgICAgICB0aGlzLnZpZXcuZGlzcGF0Y2goeyBlZmZlY3RzOiB0aGlzLnNldEhvdmVyLm9mKG9wZW4pIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIG1vdXNlbW92ZShldmVudCkge1xyXG4gICAgICAgIHZhciBfYTtcclxuICAgICAgICB0aGlzLmxhc3RNb3ZlID0geyB4OiBldmVudC5jbGllbnRYLCB5OiBldmVudC5jbGllbnRZLCB0YXJnZXQ6IGV2ZW50LnRhcmdldCwgdGltZTogRGF0ZS5ub3coKSB9O1xyXG4gICAgICAgIGlmICh0aGlzLmhvdmVyVGltZW91dCA8IDApXHJcbiAgICAgICAgICAgIHRoaXMuaG92ZXJUaW1lb3V0ID0gc2V0VGltZW91dCh0aGlzLmNoZWNrSG92ZXIsIHRoaXMuaG92ZXJUaW1lKTtcclxuICAgICAgICBsZXQgdG9vbHRpcCA9IHRoaXMuYWN0aXZlO1xyXG4gICAgICAgIGlmICh0b29sdGlwICYmICFpc0luVG9vbHRpcCh0aGlzLmxhc3RNb3ZlLnRhcmdldCkgfHwgdGhpcy5wZW5kaW5nKSB7XHJcbiAgICAgICAgICAgIGxldCB7IHBvcyB9ID0gdG9vbHRpcCB8fCB0aGlzLnBlbmRpbmcsIGVuZCA9IChfYSA9IHRvb2x0aXAgPT09IG51bGwgfHwgdG9vbHRpcCA9PT0gdm9pZCAwID8gdm9pZCAwIDogdG9vbHRpcC5lbmQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHBvcztcclxuICAgICAgICAgICAgaWYgKChwb3MgPT0gZW5kID8gdGhpcy52aWV3LnBvc0F0Q29vcmRzKHRoaXMubGFzdE1vdmUpICE9IHBvc1xyXG4gICAgICAgICAgICAgICAgOiAhaXNPdmVyUmFuZ2UodGhpcy52aWV3LCBwb3MsIGVuZCwgZXZlbnQuY2xpZW50WCwgZXZlbnQuY2xpZW50WSwgNiAvKiBIb3Zlci5NYXhEaXN0ICovKSkpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMudmlldy5kaXNwYXRjaCh7IGVmZmVjdHM6IHRoaXMuc2V0SG92ZXIub2YobnVsbCkgfSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnBlbmRpbmcgPSBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgbW91c2VsZWF2ZShlKSB7XHJcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuaG92ZXJUaW1lb3V0KTtcclxuICAgICAgICB0aGlzLmhvdmVyVGltZW91dCA9IC0xO1xyXG4gICAgICAgIGlmICh0aGlzLmFjdGl2ZSAmJiAhaXNJblRvb2x0aXAoZS5yZWxhdGVkVGFyZ2V0KSlcclxuICAgICAgICAgICAgdGhpcy52aWV3LmRpc3BhdGNoKHsgZWZmZWN0czogdGhpcy5zZXRIb3Zlci5vZihudWxsKSB9KTtcclxuICAgIH1cclxuICAgIGRlc3Ryb3koKSB7XHJcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuaG92ZXJUaW1lb3V0KTtcclxuICAgICAgICB0aGlzLnZpZXcuZG9tLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZWxlYXZlXCIsIHRoaXMubW91c2VsZWF2ZSk7XHJcbiAgICAgICAgdGhpcy52aWV3LmRvbS5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2Vtb3ZlXCIsIHRoaXMubW91c2Vtb3ZlKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBpc0luVG9vbHRpcChlbHQpIHtcclxuICAgIGZvciAobGV0IGN1ciA9IGVsdDsgY3VyOyBjdXIgPSBjdXIucGFyZW50Tm9kZSlcclxuICAgICAgICBpZiAoY3VyLm5vZGVUeXBlID09IDEgJiYgY3VyLmNsYXNzTGlzdC5jb250YWlucyhcImNtLXRvb2x0aXBcIikpXHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG59XHJcbmZ1bmN0aW9uIGlzT3ZlclJhbmdlKHZpZXcsIGZyb20sIHRvLCB4LCB5LCBtYXJnaW4pIHtcclxuICAgIGxldCByYW5nZSA9IGRvY3VtZW50LmNyZWF0ZVJhbmdlKCk7XHJcbiAgICBsZXQgZnJvbURPTSA9IHZpZXcuZG9tQXRQb3MoZnJvbSksIHRvRE9NID0gdmlldy5kb21BdFBvcyh0byk7XHJcbiAgICByYW5nZS5zZXRFbmQodG9ET00ubm9kZSwgdG9ET00ub2Zmc2V0KTtcclxuICAgIHJhbmdlLnNldFN0YXJ0KGZyb21ET00ubm9kZSwgZnJvbURPTS5vZmZzZXQpO1xyXG4gICAgbGV0IHJlY3RzID0gcmFuZ2UuZ2V0Q2xpZW50UmVjdHMoKTtcclxuICAgIHJhbmdlLmRldGFjaCgpO1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCByZWN0cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGxldCByZWN0ID0gcmVjdHNbaV07XHJcbiAgICAgICAgbGV0IGRpc3QgPSBNYXRoLm1heChyZWN0LnRvcCAtIHksIHkgLSByZWN0LmJvdHRvbSwgcmVjdC5sZWZ0IC0geCwgeCAtIHJlY3QucmlnaHQpO1xyXG4gICAgICAgIGlmIChkaXN0IDw9IG1hcmdpbilcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbn1cclxuLyoqXHJcblNldCB1cCBhIGhvdmVyIHRvb2x0aXAsIHdoaWNoIHNob3dzIHVwIHdoZW4gdGhlIHBvaW50ZXIgaG92ZXJzXHJcbm92ZXIgcmFuZ2VzIG9mIHRleHQuIFRoZSBjYWxsYmFjayBpcyBjYWxsZWQgd2hlbiB0aGUgbW91c2UgaG92ZXJzXHJcbm92ZXIgdGhlIGRvY3VtZW50IHRleHQuIEl0IHNob3VsZCwgaWYgdGhlcmUgaXMgYSB0b29sdGlwXHJcbmFzc29jaWF0ZWQgd2l0aCBwb3NpdGlvbiBgcG9zYCwgcmV0dXJuIHRoZSB0b29sdGlwIGRlc2NyaXB0aW9uXHJcbihlaXRoZXIgZGlyZWN0bHkgb3IgaW4gYSBwcm9taXNlKS4gVGhlIGBzaWRlYCBhcmd1bWVudCBpbmRpY2F0ZXNcclxub24gd2hpY2ggc2lkZSBvZiB0aGUgcG9zaXRpb24gdGhlIHBvaW50ZXIgaXPigJRpdCB3aWxsIGJlIC0xIGlmIHRoZVxyXG5wb2ludGVyIGlzIGJlZm9yZSB0aGUgcG9zaXRpb24sIDEgaWYgYWZ0ZXIgdGhlIHBvc2l0aW9uLlxyXG5cclxuTm90ZSB0aGF0IGFsbCBob3ZlciB0b29sdGlwcyBhcmUgaG9zdGVkIHdpdGhpbiBhIHNpbmdsZSB0b29sdGlwXHJcbmNvbnRhaW5lciBlbGVtZW50LiBUaGlzIGFsbG93cyBtdWx0aXBsZSB0b29sdGlwcyBvdmVyIHRoZSBzYW1lXHJcbnJhbmdlIHRvIGJlIFwibWVyZ2VkXCIgdG9nZXRoZXIgd2l0aG91dCBvdmVybGFwcGluZy5cclxuKi9cclxuZnVuY3Rpb24gaG92ZXJUb29sdGlwKHNvdXJjZSwgb3B0aW9ucyA9IHt9KSB7XHJcbiAgICBsZXQgc2V0SG92ZXIgPSBTdGF0ZUVmZmVjdC5kZWZpbmUoKTtcclxuICAgIGxldCBob3ZlclN0YXRlID0gU3RhdGVGaWVsZC5kZWZpbmUoe1xyXG4gICAgICAgIGNyZWF0ZSgpIHsgcmV0dXJuIG51bGw7IH0sXHJcbiAgICAgICAgdXBkYXRlKHZhbHVlLCB0cikge1xyXG4gICAgICAgICAgICBpZiAodmFsdWUgJiYgKG9wdGlvbnMuaGlkZU9uQ2hhbmdlICYmICh0ci5kb2NDaGFuZ2VkIHx8IHRyLnNlbGVjdGlvbikgfHxcclxuICAgICAgICAgICAgICAgIG9wdGlvbnMuaGlkZU9uICYmIG9wdGlvbnMuaGlkZU9uKHRyLCB2YWx1ZSkpKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgIGlmICh2YWx1ZSAmJiB0ci5kb2NDaGFuZ2VkKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgbmV3UG9zID0gdHIuY2hhbmdlcy5tYXBQb3ModmFsdWUucG9zLCAtMSwgTWFwTW9kZS5UcmFja0RlbCk7XHJcbiAgICAgICAgICAgICAgICBpZiAobmV3UG9zID09IG51bGwpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgICAgICBsZXQgY29weSA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmNyZWF0ZShudWxsKSwgdmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgY29weS5wb3MgPSBuZXdQb3M7XHJcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUuZW5kICE9IG51bGwpXHJcbiAgICAgICAgICAgICAgICAgICAgY29weS5lbmQgPSB0ci5jaGFuZ2VzLm1hcFBvcyh2YWx1ZS5lbmQpO1xyXG4gICAgICAgICAgICAgICAgdmFsdWUgPSBjb3B5O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGZvciAobGV0IGVmZmVjdCBvZiB0ci5lZmZlY3RzKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZWZmZWN0LmlzKHNldEhvdmVyKSlcclxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGVmZmVjdC52YWx1ZTtcclxuICAgICAgICAgICAgICAgIGlmIChlZmZlY3QuaXMoY2xvc2VIb3ZlclRvb2x0aXBFZmZlY3QpKVxyXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBwcm92aWRlOiBmID0+IHNob3dIb3ZlclRvb2x0aXAuZnJvbShmKVxyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gW1xyXG4gICAgICAgIGhvdmVyU3RhdGUsXHJcbiAgICAgICAgVmlld1BsdWdpbi5kZWZpbmUodmlldyA9PiBuZXcgSG92ZXJQbHVnaW4odmlldywgc291cmNlLCBob3ZlclN0YXRlLCBzZXRIb3Zlciwgb3B0aW9ucy5ob3ZlclRpbWUgfHwgMzAwIC8qIEhvdmVyLlRpbWUgKi8pKSxcclxuICAgICAgICBzaG93SG92ZXJUb29sdGlwSG9zdFxyXG4gICAgXTtcclxufVxyXG4vKipcclxuR2V0IHRoZSBhY3RpdmUgdG9vbHRpcCB2aWV3IGZvciBhIGdpdmVuIHRvb2x0aXAsIGlmIGF2YWlsYWJsZS5cclxuKi9cclxuZnVuY3Rpb24gZ2V0VG9vbHRpcCh2aWV3LCB0b29sdGlwKSB7XHJcbiAgICBsZXQgcGx1Z2luID0gdmlldy5wbHVnaW4odG9vbHRpcFBsdWdpbik7XHJcbiAgICBpZiAoIXBsdWdpbilcclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIGxldCBmb3VuZCA9IHBsdWdpbi5tYW5hZ2VyLnRvb2x0aXBzLmluZGV4T2YodG9vbHRpcCk7XHJcbiAgICByZXR1cm4gZm91bmQgPCAwID8gbnVsbCA6IHBsdWdpbi5tYW5hZ2VyLnRvb2x0aXBWaWV3c1tmb3VuZF07XHJcbn1cclxuLyoqXHJcblJldHVybnMgdHJ1ZSBpZiBhbnkgaG92ZXIgdG9vbHRpcHMgYXJlIGN1cnJlbnRseSBhY3RpdmUuXHJcbiovXHJcbmZ1bmN0aW9uIGhhc0hvdmVyVG9vbHRpcHMoc3RhdGUpIHtcclxuICAgIHJldHVybiBzdGF0ZS5mYWNldChzaG93SG92ZXJUb29sdGlwKS5zb21lKHggPT4geCk7XHJcbn1cclxuY29uc3QgY2xvc2VIb3ZlclRvb2x0aXBFZmZlY3QgPSAvKkBfX1BVUkVfXyovU3RhdGVFZmZlY3QuZGVmaW5lKCk7XHJcbi8qKlxyXG5UcmFuc2FjdGlvbiBlZmZlY3QgdGhhdCBjbG9zZXMgYWxsIGhvdmVyIHRvb2x0aXBzLlxyXG4qL1xyXG5jb25zdCBjbG9zZUhvdmVyVG9vbHRpcHMgPSAvKkBfX1BVUkVfXyovY2xvc2VIb3ZlclRvb2x0aXBFZmZlY3Qub2YobnVsbCk7XHJcbi8qKlxyXG5UZWxsIHRoZSB0b29sdGlwIGV4dGVuc2lvbiB0byByZWNvbXB1dGUgdGhlIHBvc2l0aW9uIG9mIHRoZSBhY3RpdmVcclxudG9vbHRpcHMuIFRoaXMgY2FuIGJlIHVzZWZ1bCB3aGVuIHNvbWV0aGluZyBoYXBwZW5zIChzdWNoIGFzIGFcclxucmUtcG9zaXRpb25pbmcgb3IgQ1NTIGNoYW5nZSBhZmZlY3RpbmcgdGhlIGVkaXRvcikgdGhhdCBjb3VsZFxyXG5pbnZhbGlkYXRlIHRoZSBleGlzdGluZyB0b29sdGlwIHBvc2l0aW9ucy5cclxuKi9cclxuZnVuY3Rpb24gcmVwb3NpdGlvblRvb2x0aXBzKHZpZXcpIHtcclxuICAgIHZhciBfYTtcclxuICAgIChfYSA9IHZpZXcucGx1Z2luKHRvb2x0aXBQbHVnaW4pKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubWF5YmVNZWFzdXJlKCk7XHJcbn1cclxuXHJcbmNvbnN0IHBhbmVsQ29uZmlnID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSh7XHJcbiAgICBjb21iaW5lKGNvbmZpZ3MpIHtcclxuICAgICAgICBsZXQgdG9wQ29udGFpbmVyLCBib3R0b21Db250YWluZXI7XHJcbiAgICAgICAgZm9yIChsZXQgYyBvZiBjb25maWdzKSB7XHJcbiAgICAgICAgICAgIHRvcENvbnRhaW5lciA9IHRvcENvbnRhaW5lciB8fCBjLnRvcENvbnRhaW5lcjtcclxuICAgICAgICAgICAgYm90dG9tQ29udGFpbmVyID0gYm90dG9tQ29udGFpbmVyIHx8IGMuYm90dG9tQ29udGFpbmVyO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4geyB0b3BDb250YWluZXIsIGJvdHRvbUNvbnRhaW5lciB9O1xyXG4gICAgfVxyXG59KTtcclxuLyoqXHJcbkNvbmZpZ3VyZXMgdGhlIHBhbmVsLW1hbmFnaW5nIGV4dGVuc2lvbi5cclxuKi9cclxuZnVuY3Rpb24gcGFuZWxzKGNvbmZpZykge1xyXG4gICAgcmV0dXJuIGNvbmZpZyA/IFtwYW5lbENvbmZpZy5vZihjb25maWcpXSA6IFtdO1xyXG59XHJcbi8qKlxyXG5HZXQgdGhlIGFjdGl2ZSBwYW5lbCBjcmVhdGVkIGJ5IHRoZSBnaXZlbiBjb25zdHJ1Y3RvciwgaWYgYW55LlxyXG5UaGlzIGNhbiBiZSB1c2VmdWwgd2hlbiB5b3UgbmVlZCBhY2Nlc3MgdG8geW91ciBwYW5lbHMnIERPTVxyXG5zdHJ1Y3R1cmUuXHJcbiovXHJcbmZ1bmN0aW9uIGdldFBhbmVsKHZpZXcsIHBhbmVsKSB7XHJcbiAgICBsZXQgcGx1Z2luID0gdmlldy5wbHVnaW4ocGFuZWxQbHVnaW4pO1xyXG4gICAgbGV0IGluZGV4ID0gcGx1Z2luID8gcGx1Z2luLnNwZWNzLmluZGV4T2YocGFuZWwpIDogLTE7XHJcbiAgICByZXR1cm4gaW5kZXggPiAtMSA/IHBsdWdpbi5wYW5lbHNbaW5kZXhdIDogbnVsbDtcclxufVxyXG5jb25zdCBwYW5lbFBsdWdpbiA9IC8qQF9fUFVSRV9fKi9WaWV3UGx1Z2luLmZyb21DbGFzcyhjbGFzcyB7XHJcbiAgICBjb25zdHJ1Y3Rvcih2aWV3KSB7XHJcbiAgICAgICAgdGhpcy5pbnB1dCA9IHZpZXcuc3RhdGUuZmFjZXQoc2hvd1BhbmVsKTtcclxuICAgICAgICB0aGlzLnNwZWNzID0gdGhpcy5pbnB1dC5maWx0ZXIocyA9PiBzKTtcclxuICAgICAgICB0aGlzLnBhbmVscyA9IHRoaXMuc3BlY3MubWFwKHNwZWMgPT4gc3BlYyh2aWV3KSk7XHJcbiAgICAgICAgbGV0IGNvbmYgPSB2aWV3LnN0YXRlLmZhY2V0KHBhbmVsQ29uZmlnKTtcclxuICAgICAgICB0aGlzLnRvcCA9IG5ldyBQYW5lbEdyb3VwKHZpZXcsIHRydWUsIGNvbmYudG9wQ29udGFpbmVyKTtcclxuICAgICAgICB0aGlzLmJvdHRvbSA9IG5ldyBQYW5lbEdyb3VwKHZpZXcsIGZhbHNlLCBjb25mLmJvdHRvbUNvbnRhaW5lcik7XHJcbiAgICAgICAgdGhpcy50b3Auc3luYyh0aGlzLnBhbmVscy5maWx0ZXIocCA9PiBwLnRvcCkpO1xyXG4gICAgICAgIHRoaXMuYm90dG9tLnN5bmModGhpcy5wYW5lbHMuZmlsdGVyKHAgPT4gIXAudG9wKSk7XHJcbiAgICAgICAgZm9yIChsZXQgcCBvZiB0aGlzLnBhbmVscykge1xyXG4gICAgICAgICAgICBwLmRvbS5jbGFzc0xpc3QuYWRkKFwiY20tcGFuZWxcIik7XHJcbiAgICAgICAgICAgIGlmIChwLm1vdW50KVxyXG4gICAgICAgICAgICAgICAgcC5tb3VudCgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHVwZGF0ZSh1cGRhdGUpIHtcclxuICAgICAgICBsZXQgY29uZiA9IHVwZGF0ZS5zdGF0ZS5mYWNldChwYW5lbENvbmZpZyk7XHJcbiAgICAgICAgaWYgKHRoaXMudG9wLmNvbnRhaW5lciAhPSBjb25mLnRvcENvbnRhaW5lcikge1xyXG4gICAgICAgICAgICB0aGlzLnRvcC5zeW5jKFtdKTtcclxuICAgICAgICAgICAgdGhpcy50b3AgPSBuZXcgUGFuZWxHcm91cCh1cGRhdGUudmlldywgdHJ1ZSwgY29uZi50b3BDb250YWluZXIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5ib3R0b20uY29udGFpbmVyICE9IGNvbmYuYm90dG9tQ29udGFpbmVyKSB7XHJcbiAgICAgICAgICAgIHRoaXMuYm90dG9tLnN5bmMoW10pO1xyXG4gICAgICAgICAgICB0aGlzLmJvdHRvbSA9IG5ldyBQYW5lbEdyb3VwKHVwZGF0ZS52aWV3LCBmYWxzZSwgY29uZi5ib3R0b21Db250YWluZXIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnRvcC5zeW5jQ2xhc3NlcygpO1xyXG4gICAgICAgIHRoaXMuYm90dG9tLnN5bmNDbGFzc2VzKCk7XHJcbiAgICAgICAgbGV0IGlucHV0ID0gdXBkYXRlLnN0YXRlLmZhY2V0KHNob3dQYW5lbCk7XHJcbiAgICAgICAgaWYgKGlucHV0ICE9IHRoaXMuaW5wdXQpIHtcclxuICAgICAgICAgICAgbGV0IHNwZWNzID0gaW5wdXQuZmlsdGVyKHggPT4geCk7XHJcbiAgICAgICAgICAgIGxldCBwYW5lbHMgPSBbXSwgdG9wID0gW10sIGJvdHRvbSA9IFtdLCBtb3VudCA9IFtdO1xyXG4gICAgICAgICAgICBmb3IgKGxldCBzcGVjIG9mIHNwZWNzKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQga25vd24gPSB0aGlzLnNwZWNzLmluZGV4T2Yoc3BlYyksIHBhbmVsO1xyXG4gICAgICAgICAgICAgICAgaWYgKGtub3duIDwgMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHBhbmVsID0gc3BlYyh1cGRhdGUudmlldyk7XHJcbiAgICAgICAgICAgICAgICAgICAgbW91bnQucHVzaChwYW5lbCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBwYW5lbCA9IHRoaXMucGFuZWxzW2tub3duXTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAocGFuZWwudXBkYXRlKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBwYW5lbC51cGRhdGUodXBkYXRlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHBhbmVscy5wdXNoKHBhbmVsKTtcclxuICAgICAgICAgICAgICAgIChwYW5lbC50b3AgPyB0b3AgOiBib3R0b20pLnB1c2gocGFuZWwpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuc3BlY3MgPSBzcGVjcztcclxuICAgICAgICAgICAgdGhpcy5wYW5lbHMgPSBwYW5lbHM7XHJcbiAgICAgICAgICAgIHRoaXMudG9wLnN5bmModG9wKTtcclxuICAgICAgICAgICAgdGhpcy5ib3R0b20uc3luYyhib3R0b20pO1xyXG4gICAgICAgICAgICBmb3IgKGxldCBwIG9mIG1vdW50KSB7XHJcbiAgICAgICAgICAgICAgICBwLmRvbS5jbGFzc0xpc3QuYWRkKFwiY20tcGFuZWxcIik7XHJcbiAgICAgICAgICAgICAgICBpZiAocC5tb3VudClcclxuICAgICAgICAgICAgICAgICAgICBwLm1vdW50KCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGZvciAobGV0IHAgb2YgdGhpcy5wYW5lbHMpXHJcbiAgICAgICAgICAgICAgICBpZiAocC51cGRhdGUpXHJcbiAgICAgICAgICAgICAgICAgICAgcC51cGRhdGUodXBkYXRlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBkZXN0cm95KCkge1xyXG4gICAgICAgIHRoaXMudG9wLnN5bmMoW10pO1xyXG4gICAgICAgIHRoaXMuYm90dG9tLnN5bmMoW10pO1xyXG4gICAgfVxyXG59LCB7XHJcbiAgICBwcm92aWRlOiBwbHVnaW4gPT4gRWRpdG9yVmlldy5zY3JvbGxNYXJnaW5zLm9mKHZpZXcgPT4ge1xyXG4gICAgICAgIGxldCB2YWx1ZSA9IHZpZXcucGx1Z2luKHBsdWdpbik7XHJcbiAgICAgICAgcmV0dXJuIHZhbHVlICYmIHsgdG9wOiB2YWx1ZS50b3Auc2Nyb2xsTWFyZ2luKCksIGJvdHRvbTogdmFsdWUuYm90dG9tLnNjcm9sbE1hcmdpbigpIH07XHJcbiAgICB9KVxyXG59KTtcclxuY2xhc3MgUGFuZWxHcm91cCB7XHJcbiAgICBjb25zdHJ1Y3Rvcih2aWV3LCB0b3AsIGNvbnRhaW5lcikge1xyXG4gICAgICAgIHRoaXMudmlldyA9IHZpZXc7XHJcbiAgICAgICAgdGhpcy50b3AgPSB0b3A7XHJcbiAgICAgICAgdGhpcy5jb250YWluZXIgPSBjb250YWluZXI7XHJcbiAgICAgICAgdGhpcy5kb20gPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgdGhpcy5jbGFzc2VzID0gXCJcIjtcclxuICAgICAgICB0aGlzLnBhbmVscyA9IFtdO1xyXG4gICAgICAgIHRoaXMuc3luY0NsYXNzZXMoKTtcclxuICAgIH1cclxuICAgIHN5bmMocGFuZWxzKSB7XHJcbiAgICAgICAgZm9yIChsZXQgcCBvZiB0aGlzLnBhbmVscylcclxuICAgICAgICAgICAgaWYgKHAuZGVzdHJveSAmJiBwYW5lbHMuaW5kZXhPZihwKSA8IDApXHJcbiAgICAgICAgICAgICAgICBwLmRlc3Ryb3koKTtcclxuICAgICAgICB0aGlzLnBhbmVscyA9IHBhbmVscztcclxuICAgICAgICB0aGlzLnN5bmNET00oKTtcclxuICAgIH1cclxuICAgIHN5bmNET00oKSB7XHJcbiAgICAgICAgaWYgKHRoaXMucGFuZWxzLmxlbmd0aCA9PSAwKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmRvbSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5kb20ucmVtb3ZlKCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmRvbSA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghdGhpcy5kb20pIHtcclxuICAgICAgICAgICAgdGhpcy5kb20gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xyXG4gICAgICAgICAgICB0aGlzLmRvbS5jbGFzc05hbWUgPSB0aGlzLnRvcCA/IFwiY20tcGFuZWxzIGNtLXBhbmVscy10b3BcIiA6IFwiY20tcGFuZWxzIGNtLXBhbmVscy1ib3R0b21cIjtcclxuICAgICAgICAgICAgdGhpcy5kb20uc3R5bGVbdGhpcy50b3AgPyBcInRvcFwiIDogXCJib3R0b21cIl0gPSBcIjBcIjtcclxuICAgICAgICAgICAgbGV0IHBhcmVudCA9IHRoaXMuY29udGFpbmVyIHx8IHRoaXMudmlldy5kb207XHJcbiAgICAgICAgICAgIHBhcmVudC5pbnNlcnRCZWZvcmUodGhpcy5kb20sIHRoaXMudG9wID8gcGFyZW50LmZpcnN0Q2hpbGQgOiBudWxsKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IGN1ckRPTSA9IHRoaXMuZG9tLmZpcnN0Q2hpbGQ7XHJcbiAgICAgICAgZm9yIChsZXQgcGFuZWwgb2YgdGhpcy5wYW5lbHMpIHtcclxuICAgICAgICAgICAgaWYgKHBhbmVsLmRvbS5wYXJlbnROb2RlID09IHRoaXMuZG9tKSB7XHJcbiAgICAgICAgICAgICAgICB3aGlsZSAoY3VyRE9NICE9IHBhbmVsLmRvbSlcclxuICAgICAgICAgICAgICAgICAgICBjdXJET00gPSBybShjdXJET00pO1xyXG4gICAgICAgICAgICAgICAgY3VyRE9NID0gY3VyRE9NLm5leHRTaWJsaW5nO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5kb20uaW5zZXJ0QmVmb3JlKHBhbmVsLmRvbSwgY3VyRE9NKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB3aGlsZSAoY3VyRE9NKVxyXG4gICAgICAgICAgICBjdXJET00gPSBybShjdXJET00pO1xyXG4gICAgfVxyXG4gICAgc2Nyb2xsTWFyZ2luKCkge1xyXG4gICAgICAgIHJldHVybiAhdGhpcy5kb20gfHwgdGhpcy5jb250YWluZXIgPyAwXHJcbiAgICAgICAgICAgIDogTWF0aC5tYXgoMCwgdGhpcy50b3AgP1xyXG4gICAgICAgICAgICAgICAgdGhpcy5kb20uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkuYm90dG9tIC0gTWF0aC5tYXgoMCwgdGhpcy52aWV3LnNjcm9sbERPTS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS50b3ApIDpcclxuICAgICAgICAgICAgICAgIE1hdGgubWluKGlubmVySGVpZ2h0LCB0aGlzLnZpZXcuc2Nyb2xsRE9NLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmJvdHRvbSkgLSB0aGlzLmRvbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS50b3ApO1xyXG4gICAgfVxyXG4gICAgc3luY0NsYXNzZXMoKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLmNvbnRhaW5lciB8fCB0aGlzLmNsYXNzZXMgPT0gdGhpcy52aWV3LnRoZW1lQ2xhc3NlcylcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIGZvciAobGV0IGNscyBvZiB0aGlzLmNsYXNzZXMuc3BsaXQoXCIgXCIpKVxyXG4gICAgICAgICAgICBpZiAoY2xzKVxyXG4gICAgICAgICAgICAgICAgdGhpcy5jb250YWluZXIuY2xhc3NMaXN0LnJlbW92ZShjbHMpO1xyXG4gICAgICAgIGZvciAobGV0IGNscyBvZiAodGhpcy5jbGFzc2VzID0gdGhpcy52aWV3LnRoZW1lQ2xhc3Nlcykuc3BsaXQoXCIgXCIpKVxyXG4gICAgICAgICAgICBpZiAoY2xzKVxyXG4gICAgICAgICAgICAgICAgdGhpcy5jb250YWluZXIuY2xhc3NMaXN0LmFkZChjbHMpO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIHJtKG5vZGUpIHtcclxuICAgIGxldCBuZXh0ID0gbm9kZS5uZXh0U2libGluZztcclxuICAgIG5vZGUucmVtb3ZlKCk7XHJcbiAgICByZXR1cm4gbmV4dDtcclxufVxyXG4vKipcclxuT3BlbmluZyBhIHBhbmVsIGlzIGRvbmUgYnkgcHJvdmlkaW5nIGEgY29uc3RydWN0b3IgZnVuY3Rpb24gZm9yXHJcbnRoZSBwYW5lbCB0aHJvdWdoIHRoaXMgZmFjZXQuIChUaGUgcGFuZWwgaXMgY2xvc2VkIGFnYWluIHdoZW4gaXRzXHJcbmNvbnN0cnVjdG9yIGlzIG5vIGxvbmdlciBwcm92aWRlZC4pIFZhbHVlcyBvZiBgbnVsbGAgYXJlIGlnbm9yZWQuXHJcbiovXHJcbmNvbnN0IHNob3dQYW5lbCA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoe1xyXG4gICAgZW5hYmxlczogcGFuZWxQbHVnaW5cclxufSk7XHJcblxyXG4vKipcclxuQSBndXR0ZXIgbWFya2VyIHJlcHJlc2VudHMgYSBiaXQgb2YgaW5mb3JtYXRpb24gYXR0YWNoZWQgdG8gYSBsaW5lXHJcbmluIGEgc3BlY2lmaWMgZ3V0dGVyLiBZb3VyIG93biBjdXN0b20gbWFya2VycyBoYXZlIHRvIGV4dGVuZCB0aGlzXHJcbmNsYXNzLlxyXG4qL1xyXG5jbGFzcyBHdXR0ZXJNYXJrZXIgZXh0ZW5kcyBSYW5nZVZhbHVlIHtcclxuICAgIC8qKlxyXG4gICAgQGludGVybmFsXHJcbiAgICAqL1xyXG4gICAgY29tcGFyZShvdGhlcikge1xyXG4gICAgICAgIHJldHVybiB0aGlzID09IG90aGVyIHx8IHRoaXMuY29uc3RydWN0b3IgPT0gb3RoZXIuY29uc3RydWN0b3IgJiYgdGhpcy5lcShvdGhlcik7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgIENvbXBhcmUgdGhpcyBtYXJrZXIgdG8gYW5vdGhlciBtYXJrZXIgb2YgdGhlIHNhbWUgdHlwZS5cclxuICAgICovXHJcbiAgICBlcShvdGhlcikgeyByZXR1cm4gZmFsc2U7IH1cclxuICAgIC8qKlxyXG4gICAgQ2FsbGVkIGlmIHRoZSBtYXJrZXIgaGFzIGEgYHRvRE9NYCBtZXRob2QgYW5kIGl0cyByZXByZXNlbnRhdGlvblxyXG4gICAgd2FzIHJlbW92ZWQgZnJvbSBhIGd1dHRlci5cclxuICAgICovXHJcbiAgICBkZXN0cm95KGRvbSkgeyB9XHJcbn1cclxuR3V0dGVyTWFya2VyLnByb3RvdHlwZS5lbGVtZW50Q2xhc3MgPSBcIlwiO1xyXG5HdXR0ZXJNYXJrZXIucHJvdG90eXBlLnRvRE9NID0gdW5kZWZpbmVkO1xyXG5HdXR0ZXJNYXJrZXIucHJvdG90eXBlLm1hcE1vZGUgPSBNYXBNb2RlLlRyYWNrQmVmb3JlO1xyXG5HdXR0ZXJNYXJrZXIucHJvdG90eXBlLnN0YXJ0U2lkZSA9IEd1dHRlck1hcmtlci5wcm90b3R5cGUuZW5kU2lkZSA9IC0xO1xyXG5HdXR0ZXJNYXJrZXIucHJvdG90eXBlLnBvaW50ID0gdHJ1ZTtcclxuLyoqXHJcbkZhY2V0IHVzZWQgdG8gYWRkIGEgY2xhc3MgdG8gYWxsIGd1dHRlciBlbGVtZW50cyBmb3IgYSBnaXZlbiBsaW5lLlxyXG5NYXJrZXJzIGdpdmVuIHRvIHRoaXMgZmFjZXQgc2hvdWxkIF9vbmx5XyBkZWZpbmUgYW5cclxuW2BlbGVtZW50Y2xhc3NgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuR3V0dGVyTWFya2VyLmVsZW1lbnRDbGFzcyksIG5vdCBhXHJcbltgdG9ET01gXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuR3V0dGVyTWFya2VyLnRvRE9NKSAob3IgdGhlIG1hcmtlciB3aWxsIGFwcGVhclxyXG5pbiBhbGwgZ3V0dGVycyBmb3IgdGhlIGxpbmUpLlxyXG4qL1xyXG5jb25zdCBndXR0ZXJMaW5lQ2xhc3MgPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKCk7XHJcbmNvbnN0IGRlZmF1bHRzID0ge1xyXG4gICAgY2xhc3M6IFwiXCIsXHJcbiAgICByZW5kZXJFbXB0eUVsZW1lbnRzOiBmYWxzZSxcclxuICAgIGVsZW1lbnRTdHlsZTogXCJcIixcclxuICAgIG1hcmtlcnM6ICgpID0+IFJhbmdlU2V0LmVtcHR5LFxyXG4gICAgbGluZU1hcmtlcjogKCkgPT4gbnVsbCxcclxuICAgIGxpbmVNYXJrZXJDaGFuZ2U6IG51bGwsXHJcbiAgICBpbml0aWFsU3BhY2VyOiBudWxsLFxyXG4gICAgdXBkYXRlU3BhY2VyOiBudWxsLFxyXG4gICAgZG9tRXZlbnRIYW5kbGVyczoge31cclxufTtcclxuY29uc3QgYWN0aXZlR3V0dGVycyA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoKTtcclxuLyoqXHJcbkRlZmluZSBhbiBlZGl0b3IgZ3V0dGVyLiBUaGUgb3JkZXIgaW4gd2hpY2ggdGhlIGd1dHRlcnMgYXBwZWFyIGlzXHJcbmRldGVybWluZWQgYnkgdGhlaXIgZXh0ZW5zaW9uIHByaW9yaXR5LlxyXG4qL1xyXG5mdW5jdGlvbiBndXR0ZXIoY29uZmlnKSB7XHJcbiAgICByZXR1cm4gW2d1dHRlcnMoKSwgYWN0aXZlR3V0dGVycy5vZihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGRlZmF1bHRzKSwgY29uZmlnKSldO1xyXG59XHJcbmNvbnN0IHVuZml4R3V0dGVycyA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoe1xyXG4gICAgY29tYmluZTogdmFsdWVzID0+IHZhbHVlcy5zb21lKHggPT4geClcclxufSk7XHJcbi8qKlxyXG5UaGUgZ3V0dGVyLWRyYXdpbmcgcGx1Z2luIGlzIGF1dG9tYXRpY2FsbHkgZW5hYmxlZCB3aGVuIHlvdSBhZGQgYVxyXG5ndXR0ZXIsIGJ1dCB5b3UgY2FuIHVzZSB0aGlzIGZ1bmN0aW9uIHRvIGV4cGxpY2l0bHkgY29uZmlndXJlIGl0LlxyXG5cclxuVW5sZXNzIGBmaXhlZGAgaXMgZXhwbGljaXRseSBzZXQgdG8gYGZhbHNlYCwgdGhlIGd1dHRlcnMgYXJlXHJcbmZpeGVkLCBtZWFuaW5nIHRoZXkgZG9uJ3Qgc2Nyb2xsIGFsb25nIHdpdGggdGhlIGNvbnRlbnRcclxuaG9yaXpvbnRhbGx5IChleGNlcHQgb24gSW50ZXJuZXQgRXhwbG9yZXIsIHdoaWNoIGRvZXNuJ3Qgc3VwcG9ydFxyXG5DU1MgW2Bwb3NpdGlvbjpcclxuc3RpY2t5YF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQ1NTL3Bvc2l0aW9uI3N0aWNreSkpLlxyXG4qL1xyXG5mdW5jdGlvbiBndXR0ZXJzKGNvbmZpZykge1xyXG4gICAgbGV0IHJlc3VsdCA9IFtcclxuICAgICAgICBndXR0ZXJWaWV3LFxyXG4gICAgXTtcclxuICAgIGlmIChjb25maWcgJiYgY29uZmlnLmZpeGVkID09PSBmYWxzZSlcclxuICAgICAgICByZXN1bHQucHVzaCh1bmZpeEd1dHRlcnMub2YodHJ1ZSkpO1xyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufVxyXG5jb25zdCBndXR0ZXJWaWV3ID0gLypAX19QVVJFX18qL1ZpZXdQbHVnaW4uZnJvbUNsYXNzKGNsYXNzIHtcclxuICAgIGNvbnN0cnVjdG9yKHZpZXcpIHtcclxuICAgICAgICB0aGlzLnZpZXcgPSB2aWV3O1xyXG4gICAgICAgIHRoaXMucHJldlZpZXdwb3J0ID0gdmlldy52aWV3cG9ydDtcclxuICAgICAgICB0aGlzLmRvbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XHJcbiAgICAgICAgdGhpcy5kb20uY2xhc3NOYW1lID0gXCJjbS1ndXR0ZXJzXCI7XHJcbiAgICAgICAgdGhpcy5kb20uc2V0QXR0cmlidXRlKFwiYXJpYS1oaWRkZW5cIiwgXCJ0cnVlXCIpO1xyXG4gICAgICAgIHRoaXMuZG9tLnN0eWxlLm1pbkhlaWdodCA9IHRoaXMudmlldy5jb250ZW50SGVpZ2h0ICsgXCJweFwiO1xyXG4gICAgICAgIHRoaXMuZ3V0dGVycyA9IHZpZXcuc3RhdGUuZmFjZXQoYWN0aXZlR3V0dGVycykubWFwKGNvbmYgPT4gbmV3IFNpbmdsZUd1dHRlclZpZXcodmlldywgY29uZikpO1xyXG4gICAgICAgIGZvciAobGV0IGd1dHRlciBvZiB0aGlzLmd1dHRlcnMpXHJcbiAgICAgICAgICAgIHRoaXMuZG9tLmFwcGVuZENoaWxkKGd1dHRlci5kb20pO1xyXG4gICAgICAgIHRoaXMuZml4ZWQgPSAhdmlldy5zdGF0ZS5mYWNldCh1bmZpeEd1dHRlcnMpO1xyXG4gICAgICAgIGlmICh0aGlzLmZpeGVkKSB7XHJcbiAgICAgICAgICAgIC8vIEZJWE1FIElFMTEgZmFsbGJhY2ssIHdoaWNoIGRvZXNuJ3Qgc3VwcG9ydCBwb3NpdGlvbjogc3RpY2t5LFxyXG4gICAgICAgICAgICAvLyBieSB1c2luZyBwb3NpdGlvbjogcmVsYXRpdmUgKyBldmVudCBoYW5kbGVycyB0aGF0IHJlYWxpZ24gdGhlXHJcbiAgICAgICAgICAgIC8vIGd1dHRlciAob3IganVzdCBmb3JjZSBmaXhlZD1mYWxzZSBvbiBJRTExPylcclxuICAgICAgICAgICAgdGhpcy5kb20uc3R5bGUucG9zaXRpb24gPSBcInN0aWNreVwiO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnN5bmNHdXR0ZXJzKGZhbHNlKTtcclxuICAgICAgICB2aWV3LnNjcm9sbERPTS5pbnNlcnRCZWZvcmUodGhpcy5kb20sIHZpZXcuY29udGVudERPTSk7XHJcbiAgICB9XHJcbiAgICB1cGRhdGUodXBkYXRlKSB7XHJcbiAgICAgICAgaWYgKHRoaXMudXBkYXRlR3V0dGVycyh1cGRhdGUpKSB7XHJcbiAgICAgICAgICAgIC8vIERldGFjaCBkdXJpbmcgc3luYyB3aGVuIHRoZSB2aWV3cG9ydCBjaGFuZ2VkIHNpZ25pZmljYW50bHlcclxuICAgICAgICAgICAgLy8gKHN1Y2ggYXMgZHVyaW5nIHNjcm9sbGluZyksIHNpbmNlIGZvciBsYXJnZSB1cGRhdGVzIHRoYXQgaXNcclxuICAgICAgICAgICAgLy8gZmFzdGVyLlxyXG4gICAgICAgICAgICBsZXQgdnBBID0gdGhpcy5wcmV2Vmlld3BvcnQsIHZwQiA9IHVwZGF0ZS52aWV3LnZpZXdwb3J0O1xyXG4gICAgICAgICAgICBsZXQgdnBPdmVybGFwID0gTWF0aC5taW4odnBBLnRvLCB2cEIudG8pIC0gTWF0aC5tYXgodnBBLmZyb20sIHZwQi5mcm9tKTtcclxuICAgICAgICAgICAgdGhpcy5zeW5jR3V0dGVycyh2cE92ZXJsYXAgPCAodnBCLnRvIC0gdnBCLmZyb20pICogMC44KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHVwZGF0ZS5nZW9tZXRyeUNoYW5nZWQpXHJcbiAgICAgICAgICAgIHRoaXMuZG9tLnN0eWxlLm1pbkhlaWdodCA9IHRoaXMudmlldy5jb250ZW50SGVpZ2h0ICsgXCJweFwiO1xyXG4gICAgICAgIGlmICh0aGlzLnZpZXcuc3RhdGUuZmFjZXQodW5maXhHdXR0ZXJzKSAhPSAhdGhpcy5maXhlZCkge1xyXG4gICAgICAgICAgICB0aGlzLmZpeGVkID0gIXRoaXMuZml4ZWQ7XHJcbiAgICAgICAgICAgIHRoaXMuZG9tLnN0eWxlLnBvc2l0aW9uID0gdGhpcy5maXhlZCA/IFwic3RpY2t5XCIgOiBcIlwiO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnByZXZWaWV3cG9ydCA9IHVwZGF0ZS52aWV3LnZpZXdwb3J0O1xyXG4gICAgfVxyXG4gICAgc3luY0d1dHRlcnMoZGV0YWNoKSB7XHJcbiAgICAgICAgbGV0IGFmdGVyID0gdGhpcy5kb20ubmV4dFNpYmxpbmc7XHJcbiAgICAgICAgaWYgKGRldGFjaClcclxuICAgICAgICAgICAgdGhpcy5kb20ucmVtb3ZlKCk7XHJcbiAgICAgICAgbGV0IGxpbmVDbGFzc2VzID0gUmFuZ2VTZXQuaXRlcih0aGlzLnZpZXcuc3RhdGUuZmFjZXQoZ3V0dGVyTGluZUNsYXNzKSwgdGhpcy52aWV3LnZpZXdwb3J0LmZyb20pO1xyXG4gICAgICAgIGxldCBjbGFzc1NldCA9IFtdO1xyXG4gICAgICAgIGxldCBjb250ZXh0cyA9IHRoaXMuZ3V0dGVycy5tYXAoZ3V0dGVyID0+IG5ldyBVcGRhdGVDb250ZXh0KGd1dHRlciwgdGhpcy52aWV3LnZpZXdwb3J0LCAtdGhpcy52aWV3LmRvY3VtZW50UGFkZGluZy50b3ApKTtcclxuICAgICAgICBmb3IgKGxldCBsaW5lIG9mIHRoaXMudmlldy52aWV3cG9ydExpbmVCbG9ja3MpIHtcclxuICAgICAgICAgICAgbGV0IHRleHQ7XHJcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGxpbmUudHlwZSkpIHtcclxuICAgICAgICAgICAgICAgIGZvciAobGV0IGIgb2YgbGluZS50eXBlKVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChiLnR5cGUgPT0gQmxvY2tUeXBlLlRleHQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dCA9IGI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRleHQgPSBsaW5lLnR5cGUgPT0gQmxvY2tUeXBlLlRleHQgPyBsaW5lIDogdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICghdGV4dClcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICBpZiAoY2xhc3NTZXQubGVuZ3RoKVxyXG4gICAgICAgICAgICAgICAgY2xhc3NTZXQgPSBbXTtcclxuICAgICAgICAgICAgYWR2YW5jZUN1cnNvcihsaW5lQ2xhc3NlcywgY2xhc3NTZXQsIGxpbmUuZnJvbSk7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGN4IG9mIGNvbnRleHRzKVxyXG4gICAgICAgICAgICAgICAgY3gubGluZSh0aGlzLnZpZXcsIHRleHQsIGNsYXNzU2V0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZm9yIChsZXQgY3ggb2YgY29udGV4dHMpXHJcbiAgICAgICAgICAgIGN4LmZpbmlzaCgpO1xyXG4gICAgICAgIGlmIChkZXRhY2gpXHJcbiAgICAgICAgICAgIHRoaXMudmlldy5zY3JvbGxET00uaW5zZXJ0QmVmb3JlKHRoaXMuZG9tLCBhZnRlcik7XHJcbiAgICB9XHJcbiAgICB1cGRhdGVHdXR0ZXJzKHVwZGF0ZSkge1xyXG4gICAgICAgIGxldCBwcmV2ID0gdXBkYXRlLnN0YXJ0U3RhdGUuZmFjZXQoYWN0aXZlR3V0dGVycyksIGN1ciA9IHVwZGF0ZS5zdGF0ZS5mYWNldChhY3RpdmVHdXR0ZXJzKTtcclxuICAgICAgICBsZXQgY2hhbmdlID0gdXBkYXRlLmRvY0NoYW5nZWQgfHwgdXBkYXRlLmhlaWdodENoYW5nZWQgfHwgdXBkYXRlLnZpZXdwb3J0Q2hhbmdlZCB8fFxyXG4gICAgICAgICAgICAhUmFuZ2VTZXQuZXEodXBkYXRlLnN0YXJ0U3RhdGUuZmFjZXQoZ3V0dGVyTGluZUNsYXNzKSwgdXBkYXRlLnN0YXRlLmZhY2V0KGd1dHRlckxpbmVDbGFzcyksIHVwZGF0ZS52aWV3LnZpZXdwb3J0LmZyb20sIHVwZGF0ZS52aWV3LnZpZXdwb3J0LnRvKTtcclxuICAgICAgICBpZiAocHJldiA9PSBjdXIpIHtcclxuICAgICAgICAgICAgZm9yIChsZXQgZ3V0dGVyIG9mIHRoaXMuZ3V0dGVycylcclxuICAgICAgICAgICAgICAgIGlmIChndXR0ZXIudXBkYXRlKHVwZGF0ZSkpXHJcbiAgICAgICAgICAgICAgICAgICAgY2hhbmdlID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGNoYW5nZSA9IHRydWU7XHJcbiAgICAgICAgICAgIGxldCBndXR0ZXJzID0gW107XHJcbiAgICAgICAgICAgIGZvciAobGV0IGNvbmYgb2YgY3VyKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQga25vd24gPSBwcmV2LmluZGV4T2YoY29uZik7XHJcbiAgICAgICAgICAgICAgICBpZiAoa25vd24gPCAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZ3V0dGVycy5wdXNoKG5ldyBTaW5nbGVHdXR0ZXJWaWV3KHRoaXMudmlldywgY29uZikpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5ndXR0ZXJzW2tub3duXS51cGRhdGUodXBkYXRlKTtcclxuICAgICAgICAgICAgICAgICAgICBndXR0ZXJzLnB1c2godGhpcy5ndXR0ZXJzW2tub3duXSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZm9yIChsZXQgZyBvZiB0aGlzLmd1dHRlcnMpIHtcclxuICAgICAgICAgICAgICAgIGcuZG9tLnJlbW92ZSgpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGd1dHRlcnMuaW5kZXhPZihnKSA8IDApXHJcbiAgICAgICAgICAgICAgICAgICAgZy5kZXN0cm95KCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZm9yIChsZXQgZyBvZiBndXR0ZXJzKVxyXG4gICAgICAgICAgICAgICAgdGhpcy5kb20uYXBwZW5kQ2hpbGQoZy5kb20pO1xyXG4gICAgICAgICAgICB0aGlzLmd1dHRlcnMgPSBndXR0ZXJzO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gY2hhbmdlO1xyXG4gICAgfVxyXG4gICAgZGVzdHJveSgpIHtcclxuICAgICAgICBmb3IgKGxldCB2aWV3IG9mIHRoaXMuZ3V0dGVycylcclxuICAgICAgICAgICAgdmlldy5kZXN0cm95KCk7XHJcbiAgICAgICAgdGhpcy5kb20ucmVtb3ZlKCk7XHJcbiAgICB9XHJcbn0sIHtcclxuICAgIHByb3ZpZGU6IHBsdWdpbiA9PiBFZGl0b3JWaWV3LnNjcm9sbE1hcmdpbnMub2YodmlldyA9PiB7XHJcbiAgICAgICAgbGV0IHZhbHVlID0gdmlldy5wbHVnaW4ocGx1Z2luKTtcclxuICAgICAgICBpZiAoIXZhbHVlIHx8IHZhbHVlLmd1dHRlcnMubGVuZ3RoID09IDAgfHwgIXZhbHVlLmZpeGVkKVxyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICByZXR1cm4gdmlldy50ZXh0RGlyZWN0aW9uID09IERpcmVjdGlvbi5MVFIgPyB7IGxlZnQ6IHZhbHVlLmRvbS5vZmZzZXRXaWR0aCB9IDogeyByaWdodDogdmFsdWUuZG9tLm9mZnNldFdpZHRoIH07XHJcbiAgICB9KVxyXG59KTtcclxuZnVuY3Rpb24gYXNBcnJheSh2YWwpIHsgcmV0dXJuIChBcnJheS5pc0FycmF5KHZhbCkgPyB2YWwgOiBbdmFsXSk7IH1cclxuZnVuY3Rpb24gYWR2YW5jZUN1cnNvcihjdXJzb3IsIGNvbGxlY3QsIHBvcykge1xyXG4gICAgd2hpbGUgKGN1cnNvci52YWx1ZSAmJiBjdXJzb3IuZnJvbSA8PSBwb3MpIHtcclxuICAgICAgICBpZiAoY3Vyc29yLmZyb20gPT0gcG9zKVxyXG4gICAgICAgICAgICBjb2xsZWN0LnB1c2goY3Vyc29yLnZhbHVlKTtcclxuICAgICAgICBjdXJzb3IubmV4dCgpO1xyXG4gICAgfVxyXG59XHJcbmNsYXNzIFVwZGF0ZUNvbnRleHQge1xyXG4gICAgY29uc3RydWN0b3IoZ3V0dGVyLCB2aWV3cG9ydCwgaGVpZ2h0KSB7XHJcbiAgICAgICAgdGhpcy5ndXR0ZXIgPSBndXR0ZXI7XHJcbiAgICAgICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XHJcbiAgICAgICAgdGhpcy5pID0gMDtcclxuICAgICAgICB0aGlzLmN1cnNvciA9IFJhbmdlU2V0Lml0ZXIoZ3V0dGVyLm1hcmtlcnMsIHZpZXdwb3J0LmZyb20pO1xyXG4gICAgfVxyXG4gICAgbGluZSh2aWV3LCBsaW5lLCBleHRyYU1hcmtlcnMpIHtcclxuICAgICAgICBsZXQgbG9jYWxNYXJrZXJzID0gW107XHJcbiAgICAgICAgYWR2YW5jZUN1cnNvcih0aGlzLmN1cnNvciwgbG9jYWxNYXJrZXJzLCBsaW5lLmZyb20pO1xyXG4gICAgICAgIGlmIChleHRyYU1hcmtlcnMubGVuZ3RoKVxyXG4gICAgICAgICAgICBsb2NhbE1hcmtlcnMgPSBsb2NhbE1hcmtlcnMuY29uY2F0KGV4dHJhTWFya2Vycyk7XHJcbiAgICAgICAgbGV0IGZvckxpbmUgPSB0aGlzLmd1dHRlci5jb25maWcubGluZU1hcmtlcih2aWV3LCBsaW5lLCBsb2NhbE1hcmtlcnMpO1xyXG4gICAgICAgIGlmIChmb3JMaW5lKVxyXG4gICAgICAgICAgICBsb2NhbE1hcmtlcnMudW5zaGlmdChmb3JMaW5lKTtcclxuICAgICAgICBsZXQgZ3V0dGVyID0gdGhpcy5ndXR0ZXI7XHJcbiAgICAgICAgaWYgKGxvY2FsTWFya2Vycy5sZW5ndGggPT0gMCAmJiAhZ3V0dGVyLmNvbmZpZy5yZW5kZXJFbXB0eUVsZW1lbnRzKVxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgbGV0IGFib3ZlID0gbGluZS50b3AgLSB0aGlzLmhlaWdodDtcclxuICAgICAgICBpZiAodGhpcy5pID09IGd1dHRlci5lbGVtZW50cy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgbGV0IG5ld0VsdCA9IG5ldyBHdXR0ZXJFbGVtZW50KHZpZXcsIGxpbmUuaGVpZ2h0LCBhYm92ZSwgbG9jYWxNYXJrZXJzKTtcclxuICAgICAgICAgICAgZ3V0dGVyLmVsZW1lbnRzLnB1c2gobmV3RWx0KTtcclxuICAgICAgICAgICAgZ3V0dGVyLmRvbS5hcHBlbmRDaGlsZChuZXdFbHQuZG9tKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGd1dHRlci5lbGVtZW50c1t0aGlzLmldLnVwZGF0ZSh2aWV3LCBsaW5lLmhlaWdodCwgYWJvdmUsIGxvY2FsTWFya2Vycyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gbGluZS5ib3R0b207XHJcbiAgICAgICAgdGhpcy5pKys7XHJcbiAgICB9XHJcbiAgICBmaW5pc2goKSB7XHJcbiAgICAgICAgbGV0IGd1dHRlciA9IHRoaXMuZ3V0dGVyO1xyXG4gICAgICAgIHdoaWxlIChndXR0ZXIuZWxlbWVudHMubGVuZ3RoID4gdGhpcy5pKSB7XHJcbiAgICAgICAgICAgIGxldCBsYXN0ID0gZ3V0dGVyLmVsZW1lbnRzLnBvcCgpO1xyXG4gICAgICAgICAgICBndXR0ZXIuZG9tLnJlbW92ZUNoaWxkKGxhc3QuZG9tKTtcclxuICAgICAgICAgICAgbGFzdC5kZXN0cm95KCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbmNsYXNzIFNpbmdsZUd1dHRlclZpZXcge1xyXG4gICAgY29uc3RydWN0b3IodmlldywgY29uZmlnKSB7XHJcbiAgICAgICAgdGhpcy52aWV3ID0gdmlldztcclxuICAgICAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZztcclxuICAgICAgICB0aGlzLmVsZW1lbnRzID0gW107XHJcbiAgICAgICAgdGhpcy5zcGFjZXIgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuZG9tID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcclxuICAgICAgICB0aGlzLmRvbS5jbGFzc05hbWUgPSBcImNtLWd1dHRlclwiICsgKHRoaXMuY29uZmlnLmNsYXNzID8gXCIgXCIgKyB0aGlzLmNvbmZpZy5jbGFzcyA6IFwiXCIpO1xyXG4gICAgICAgIGZvciAobGV0IHByb3AgaW4gY29uZmlnLmRvbUV2ZW50SGFuZGxlcnMpIHtcclxuICAgICAgICAgICAgdGhpcy5kb20uYWRkRXZlbnRMaXN0ZW5lcihwcm9wLCAoZXZlbnQpID0+IHtcclxuICAgICAgICAgICAgICAgIGxldCB0YXJnZXQgPSBldmVudC50YXJnZXQsIHk7XHJcbiAgICAgICAgICAgICAgICBpZiAodGFyZ2V0ICE9IHRoaXMuZG9tICYmIHRoaXMuZG9tLmNvbnRhaW5zKHRhcmdldCkpIHtcclxuICAgICAgICAgICAgICAgICAgICB3aGlsZSAodGFyZ2V0LnBhcmVudE5vZGUgIT0gdGhpcy5kb20pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldCA9IHRhcmdldC5wYXJlbnROb2RlO1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCByZWN0ID0gdGFyZ2V0LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHkgPSAocmVjdC50b3AgKyByZWN0LmJvdHRvbSkgLyAyO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgeSA9IGV2ZW50LmNsaWVudFk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBsZXQgbGluZSA9IHZpZXcubGluZUJsb2NrQXRIZWlnaHQoeSAtIHZpZXcuZG9jdW1lbnRUb3ApO1xyXG4gICAgICAgICAgICAgICAgaWYgKGNvbmZpZy5kb21FdmVudEhhbmRsZXJzW3Byb3BdKHZpZXcsIGxpbmUsIGV2ZW50KSlcclxuICAgICAgICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5tYXJrZXJzID0gYXNBcnJheShjb25maWcubWFya2Vycyh2aWV3KSk7XHJcbiAgICAgICAgaWYgKGNvbmZpZy5pbml0aWFsU3BhY2VyKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc3BhY2VyID0gbmV3IEd1dHRlckVsZW1lbnQodmlldywgMCwgMCwgW2NvbmZpZy5pbml0aWFsU3BhY2VyKHZpZXcpXSk7XHJcbiAgICAgICAgICAgIHRoaXMuZG9tLmFwcGVuZENoaWxkKHRoaXMuc3BhY2VyLmRvbSk7XHJcbiAgICAgICAgICAgIHRoaXMuc3BhY2VyLmRvbS5zdHlsZS5jc3NUZXh0ICs9IFwidmlzaWJpbGl0eTogaGlkZGVuOyBwb2ludGVyLWV2ZW50czogbm9uZVwiO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHVwZGF0ZSh1cGRhdGUpIHtcclxuICAgICAgICBsZXQgcHJldk1hcmtlcnMgPSB0aGlzLm1hcmtlcnM7XHJcbiAgICAgICAgdGhpcy5tYXJrZXJzID0gYXNBcnJheSh0aGlzLmNvbmZpZy5tYXJrZXJzKHVwZGF0ZS52aWV3KSk7XHJcbiAgICAgICAgaWYgKHRoaXMuc3BhY2VyICYmIHRoaXMuY29uZmlnLnVwZGF0ZVNwYWNlcikge1xyXG4gICAgICAgICAgICBsZXQgdXBkYXRlZCA9IHRoaXMuY29uZmlnLnVwZGF0ZVNwYWNlcih0aGlzLnNwYWNlci5tYXJrZXJzWzBdLCB1cGRhdGUpO1xyXG4gICAgICAgICAgICBpZiAodXBkYXRlZCAhPSB0aGlzLnNwYWNlci5tYXJrZXJzWzBdKVxyXG4gICAgICAgICAgICAgICAgdGhpcy5zcGFjZXIudXBkYXRlKHVwZGF0ZS52aWV3LCAwLCAwLCBbdXBkYXRlZF0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgdnAgPSB1cGRhdGUudmlldy52aWV3cG9ydDtcclxuICAgICAgICByZXR1cm4gIVJhbmdlU2V0LmVxKHRoaXMubWFya2VycywgcHJldk1hcmtlcnMsIHZwLmZyb20sIHZwLnRvKSB8fFxyXG4gICAgICAgICAgICAodGhpcy5jb25maWcubGluZU1hcmtlckNoYW5nZSA/IHRoaXMuY29uZmlnLmxpbmVNYXJrZXJDaGFuZ2UodXBkYXRlKSA6IGZhbHNlKTtcclxuICAgIH1cclxuICAgIGRlc3Ryb3koKSB7XHJcbiAgICAgICAgZm9yIChsZXQgZWx0IG9mIHRoaXMuZWxlbWVudHMpXHJcbiAgICAgICAgICAgIGVsdC5kZXN0cm95KCk7XHJcbiAgICB9XHJcbn1cclxuY2xhc3MgR3V0dGVyRWxlbWVudCB7XHJcbiAgICBjb25zdHJ1Y3Rvcih2aWV3LCBoZWlnaHQsIGFib3ZlLCBtYXJrZXJzKSB7XHJcbiAgICAgICAgdGhpcy5oZWlnaHQgPSAtMTtcclxuICAgICAgICB0aGlzLmFib3ZlID0gMDtcclxuICAgICAgICB0aGlzLm1hcmtlcnMgPSBbXTtcclxuICAgICAgICB0aGlzLmRvbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XHJcbiAgICAgICAgdGhpcy5kb20uY2xhc3NOYW1lID0gXCJjbS1ndXR0ZXJFbGVtZW50XCI7XHJcbiAgICAgICAgdGhpcy51cGRhdGUodmlldywgaGVpZ2h0LCBhYm92ZSwgbWFya2Vycyk7XHJcbiAgICB9XHJcbiAgICB1cGRhdGUodmlldywgaGVpZ2h0LCBhYm92ZSwgbWFya2Vycykge1xyXG4gICAgICAgIGlmICh0aGlzLmhlaWdodCAhPSBoZWlnaHQpXHJcbiAgICAgICAgICAgIHRoaXMuZG9tLnN0eWxlLmhlaWdodCA9ICh0aGlzLmhlaWdodCA9IGhlaWdodCkgKyBcInB4XCI7XHJcbiAgICAgICAgaWYgKHRoaXMuYWJvdmUgIT0gYWJvdmUpXHJcbiAgICAgICAgICAgIHRoaXMuZG9tLnN0eWxlLm1hcmdpblRvcCA9ICh0aGlzLmFib3ZlID0gYWJvdmUpID8gYWJvdmUgKyBcInB4XCIgOiBcIlwiO1xyXG4gICAgICAgIGlmICghc2FtZU1hcmtlcnModGhpcy5tYXJrZXJzLCBtYXJrZXJzKSlcclxuICAgICAgICAgICAgdGhpcy5zZXRNYXJrZXJzKHZpZXcsIG1hcmtlcnMpO1xyXG4gICAgfVxyXG4gICAgc2V0TWFya2Vycyh2aWV3LCBtYXJrZXJzKSB7XHJcbiAgICAgICAgbGV0IGNscyA9IFwiY20tZ3V0dGVyRWxlbWVudFwiLCBkb21Qb3MgPSB0aGlzLmRvbS5maXJzdENoaWxkO1xyXG4gICAgICAgIGZvciAobGV0IGlOZXcgPSAwLCBpT2xkID0gMDs7KSB7XHJcbiAgICAgICAgICAgIGxldCBza2lwVG8gPSBpT2xkLCBtYXJrZXIgPSBpTmV3IDwgbWFya2Vycy5sZW5ndGggPyBtYXJrZXJzW2lOZXcrK10gOiBudWxsLCBtYXRjaGVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgIGlmIChtYXJrZXIpIHtcclxuICAgICAgICAgICAgICAgIGxldCBjID0gbWFya2VyLmVsZW1lbnRDbGFzcztcclxuICAgICAgICAgICAgICAgIGlmIChjKVxyXG4gICAgICAgICAgICAgICAgICAgIGNscyArPSBcIiBcIiArIGM7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gaU9sZDsgaSA8IHRoaXMubWFya2Vycy5sZW5ndGg7IGkrKylcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5tYXJrZXJzW2ldLmNvbXBhcmUobWFya2VyKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBza2lwVG8gPSBpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXRjaGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgc2tpcFRvID0gdGhpcy5tYXJrZXJzLmxlbmd0aDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB3aGlsZSAoaU9sZCA8IHNraXBUbykge1xyXG4gICAgICAgICAgICAgICAgbGV0IG5leHQgPSB0aGlzLm1hcmtlcnNbaU9sZCsrXTtcclxuICAgICAgICAgICAgICAgIGlmIChuZXh0LnRvRE9NKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbmV4dC5kZXN0cm95KGRvbVBvcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IGFmdGVyID0gZG9tUG9zLm5leHRTaWJsaW5nO1xyXG4gICAgICAgICAgICAgICAgICAgIGRvbVBvcy5yZW1vdmUoKTtcclxuICAgICAgICAgICAgICAgICAgICBkb21Qb3MgPSBhZnRlcjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoIW1hcmtlcilcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBpZiAobWFya2VyLnRvRE9NKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAobWF0Y2hlZClcclxuICAgICAgICAgICAgICAgICAgICBkb21Qb3MgPSBkb21Qb3MubmV4dFNpYmxpbmc7XHJcbiAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kb20uaW5zZXJ0QmVmb3JlKG1hcmtlci50b0RPTSh2aWV3KSwgZG9tUG9zKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAobWF0Y2hlZClcclxuICAgICAgICAgICAgICAgIGlPbGQrKztcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5kb20uY2xhc3NOYW1lID0gY2xzO1xyXG4gICAgICAgIHRoaXMubWFya2VycyA9IG1hcmtlcnM7XHJcbiAgICB9XHJcbiAgICBkZXN0cm95KCkge1xyXG4gICAgICAgIHRoaXMuc2V0TWFya2VycyhudWxsLCBbXSk7IC8vIEZpcnN0IGFyZ3VtZW50IG5vdCB1c2VkIHVubGVzcyBjcmVhdGluZyBtYXJrZXJzXHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gc2FtZU1hcmtlcnMoYSwgYikge1xyXG4gICAgaWYgKGEubGVuZ3RoICE9IGIubGVuZ3RoKVxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYS5sZW5ndGg7IGkrKylcclxuICAgICAgICBpZiAoIWFbaV0uY29tcGFyZShiW2ldKSlcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgcmV0dXJuIHRydWU7XHJcbn1cclxuLyoqXHJcbkZhY2V0IHVzZWQgdG8gcHJvdmlkZSBtYXJrZXJzIHRvIHRoZSBsaW5lIG51bWJlciBndXR0ZXIuXHJcbiovXHJcbmNvbnN0IGxpbmVOdW1iZXJNYXJrZXJzID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSgpO1xyXG5jb25zdCBsaW5lTnVtYmVyQ29uZmlnID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSh7XHJcbiAgICBjb21iaW5lKHZhbHVlcykge1xyXG4gICAgICAgIHJldHVybiBjb21iaW5lQ29uZmlnKHZhbHVlcywgeyBmb3JtYXROdW1iZXI6IFN0cmluZywgZG9tRXZlbnRIYW5kbGVyczoge30gfSwge1xyXG4gICAgICAgICAgICBkb21FdmVudEhhbmRsZXJzKGEsIGIpIHtcclxuICAgICAgICAgICAgICAgIGxldCByZXN1bHQgPSBPYmplY3QuYXNzaWduKHt9LCBhKTtcclxuICAgICAgICAgICAgICAgIGZvciAobGV0IGV2ZW50IGluIGIpIHtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgZXhpc3RzID0gcmVzdWx0W2V2ZW50XSwgYWRkID0gYltldmVudF07XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0W2V2ZW50XSA9IGV4aXN0cyA/ICh2aWV3LCBsaW5lLCBldmVudCkgPT4gZXhpc3RzKHZpZXcsIGxpbmUsIGV2ZW50KSB8fCBhZGQodmlldywgbGluZSwgZXZlbnQpIDogYWRkO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG59KTtcclxuY2xhc3MgTnVtYmVyTWFya2VyIGV4dGVuZHMgR3V0dGVyTWFya2VyIHtcclxuICAgIGNvbnN0cnVjdG9yKG51bWJlcikge1xyXG4gICAgICAgIHN1cGVyKCk7XHJcbiAgICAgICAgdGhpcy5udW1iZXIgPSBudW1iZXI7XHJcbiAgICB9XHJcbiAgICBlcShvdGhlcikgeyByZXR1cm4gdGhpcy5udW1iZXIgPT0gb3RoZXIubnVtYmVyOyB9XHJcbiAgICB0b0RPTSgpIHsgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHRoaXMubnVtYmVyKTsgfVxyXG59XHJcbmZ1bmN0aW9uIGZvcm1hdE51bWJlcih2aWV3LCBudW1iZXIpIHtcclxuICAgIHJldHVybiB2aWV3LnN0YXRlLmZhY2V0KGxpbmVOdW1iZXJDb25maWcpLmZvcm1hdE51bWJlcihudW1iZXIsIHZpZXcuc3RhdGUpO1xyXG59XHJcbmNvbnN0IGxpbmVOdW1iZXJHdXR0ZXIgPSAvKkBfX1BVUkVfXyovYWN0aXZlR3V0dGVycy5jb21wdXRlKFtsaW5lTnVtYmVyQ29uZmlnXSwgc3RhdGUgPT4gKHtcclxuICAgIGNsYXNzOiBcImNtLWxpbmVOdW1iZXJzXCIsXHJcbiAgICByZW5kZXJFbXB0eUVsZW1lbnRzOiBmYWxzZSxcclxuICAgIG1hcmtlcnModmlldykgeyByZXR1cm4gdmlldy5zdGF0ZS5mYWNldChsaW5lTnVtYmVyTWFya2Vycyk7IH0sXHJcbiAgICBsaW5lTWFya2VyKHZpZXcsIGxpbmUsIG90aGVycykge1xyXG4gICAgICAgIGlmIChvdGhlcnMuc29tZShtID0+IG0udG9ET00pKVxyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICByZXR1cm4gbmV3IE51bWJlck1hcmtlcihmb3JtYXROdW1iZXIodmlldywgdmlldy5zdGF0ZS5kb2MubGluZUF0KGxpbmUuZnJvbSkubnVtYmVyKSk7XHJcbiAgICB9LFxyXG4gICAgbGluZU1hcmtlckNoYW5nZTogdXBkYXRlID0+IHVwZGF0ZS5zdGFydFN0YXRlLmZhY2V0KGxpbmVOdW1iZXJDb25maWcpICE9IHVwZGF0ZS5zdGF0ZS5mYWNldChsaW5lTnVtYmVyQ29uZmlnKSxcclxuICAgIGluaXRpYWxTcGFjZXIodmlldykge1xyXG4gICAgICAgIHJldHVybiBuZXcgTnVtYmVyTWFya2VyKGZvcm1hdE51bWJlcih2aWV3LCBtYXhMaW5lTnVtYmVyKHZpZXcuc3RhdGUuZG9jLmxpbmVzKSkpO1xyXG4gICAgfSxcclxuICAgIHVwZGF0ZVNwYWNlcihzcGFjZXIsIHVwZGF0ZSkge1xyXG4gICAgICAgIGxldCBtYXggPSBmb3JtYXROdW1iZXIodXBkYXRlLnZpZXcsIG1heExpbmVOdW1iZXIodXBkYXRlLnZpZXcuc3RhdGUuZG9jLmxpbmVzKSk7XHJcbiAgICAgICAgcmV0dXJuIG1heCA9PSBzcGFjZXIubnVtYmVyID8gc3BhY2VyIDogbmV3IE51bWJlck1hcmtlcihtYXgpO1xyXG4gICAgfSxcclxuICAgIGRvbUV2ZW50SGFuZGxlcnM6IHN0YXRlLmZhY2V0KGxpbmVOdW1iZXJDb25maWcpLmRvbUV2ZW50SGFuZGxlcnNcclxufSkpO1xyXG4vKipcclxuQ3JlYXRlIGEgbGluZSBudW1iZXIgZ3V0dGVyIGV4dGVuc2lvbi5cclxuKi9cclxuZnVuY3Rpb24gbGluZU51bWJlcnMoY29uZmlnID0ge30pIHtcclxuICAgIHJldHVybiBbXHJcbiAgICAgICAgbGluZU51bWJlckNvbmZpZy5vZihjb25maWcpLFxyXG4gICAgICAgIGd1dHRlcnMoKSxcclxuICAgICAgICBsaW5lTnVtYmVyR3V0dGVyXHJcbiAgICBdO1xyXG59XHJcbmZ1bmN0aW9uIG1heExpbmVOdW1iZXIobGluZXMpIHtcclxuICAgIGxldCBsYXN0ID0gOTtcclxuICAgIHdoaWxlIChsYXN0IDwgbGluZXMpXHJcbiAgICAgICAgbGFzdCA9IGxhc3QgKiAxMCArIDk7XHJcbiAgICByZXR1cm4gbGFzdDtcclxufVxyXG5jb25zdCBhY3RpdmVMaW5lR3V0dGVyTWFya2VyID0gLypAX19QVVJFX18qL25ldyBjbGFzcyBleHRlbmRzIEd1dHRlck1hcmtlciB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xyXG4gICAgICAgIHRoaXMuZWxlbWVudENsYXNzID0gXCJjbS1hY3RpdmVMaW5lR3V0dGVyXCI7XHJcbiAgICB9XHJcbn07XHJcbmNvbnN0IGFjdGl2ZUxpbmVHdXR0ZXJIaWdobGlnaHRlciA9IC8qQF9fUFVSRV9fKi9ndXR0ZXJMaW5lQ2xhc3MuY29tcHV0ZShbXCJzZWxlY3Rpb25cIl0sIHN0YXRlID0+IHtcclxuICAgIGxldCBtYXJrcyA9IFtdLCBsYXN0ID0gLTE7XHJcbiAgICBmb3IgKGxldCByYW5nZSBvZiBzdGF0ZS5zZWxlY3Rpb24ucmFuZ2VzKSB7XHJcbiAgICAgICAgbGV0IGxpbmVQb3MgPSBzdGF0ZS5kb2MubGluZUF0KHJhbmdlLmhlYWQpLmZyb207XHJcbiAgICAgICAgaWYgKGxpbmVQb3MgPiBsYXN0KSB7XHJcbiAgICAgICAgICAgIGxhc3QgPSBsaW5lUG9zO1xyXG4gICAgICAgICAgICBtYXJrcy5wdXNoKGFjdGl2ZUxpbmVHdXR0ZXJNYXJrZXIucmFuZ2UobGluZVBvcykpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBSYW5nZVNldC5vZihtYXJrcyk7XHJcbn0pO1xyXG4vKipcclxuUmV0dXJucyBhbiBleHRlbnNpb24gdGhhdCBhZGRzIGEgYGNtLWFjdGl2ZUxpbmVHdXR0ZXJgIGNsYXNzIHRvXHJcbmFsbCBndXR0ZXIgZWxlbWVudHMgb24gdGhlIFthY3RpdmVcclxubGluZV0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LmhpZ2hsaWdodEFjdGl2ZUxpbmUpLlxyXG4qL1xyXG5mdW5jdGlvbiBoaWdobGlnaHRBY3RpdmVMaW5lR3V0dGVyKCkge1xyXG4gICAgcmV0dXJuIGFjdGl2ZUxpbmVHdXR0ZXJIaWdobGlnaHRlcjtcclxufVxyXG5cclxuY29uc3QgV2hpdGVzcGFjZURlY28gPSAvKkBfX1BVUkVfXyovbmV3IE1hcCgpO1xyXG5mdW5jdGlvbiBnZXRXaGl0ZXNwYWNlRGVjbyhzcGFjZSkge1xyXG4gICAgbGV0IGRlY28gPSBXaGl0ZXNwYWNlRGVjby5nZXQoc3BhY2UpO1xyXG4gICAgaWYgKCFkZWNvKVxyXG4gICAgICAgIFdoaXRlc3BhY2VEZWNvLnNldChzcGFjZSwgZGVjbyA9IERlY29yYXRpb24ubWFyayh7XHJcbiAgICAgICAgICAgIGF0dHJpYnV0ZXM6IHNwYWNlID09PSBcIlxcdFwiID8ge1xyXG4gICAgICAgICAgICAgICAgY2xhc3M6IFwiY20taGlnaGxpZ2h0VGFiXCIsXHJcbiAgICAgICAgICAgIH0gOiB7XHJcbiAgICAgICAgICAgICAgICBjbGFzczogXCJjbS1oaWdobGlnaHRTcGFjZVwiLFxyXG4gICAgICAgICAgICAgICAgXCJkYXRhLWRpc3BsYXlcIjogc3BhY2UucmVwbGFjZSgvIC9nLCBcIsK3XCIpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KSk7XHJcbiAgICByZXR1cm4gZGVjbztcclxufVxyXG5mdW5jdGlvbiBtYXRjaGVyKGRlY29yYXRvcikge1xyXG4gICAgcmV0dXJuIFZpZXdQbHVnaW4uZGVmaW5lKHZpZXcgPT4gKHtcclxuICAgICAgICBkZWNvcmF0aW9uczogZGVjb3JhdG9yLmNyZWF0ZURlY28odmlldyksXHJcbiAgICAgICAgdXBkYXRlKHUpIHtcclxuICAgICAgICAgICAgdGhpcy5kZWNvcmF0aW9ucyA9IGRlY29yYXRvci51cGRhdGVEZWNvKHUsIHRoaXMuZGVjb3JhdGlvbnMpO1xyXG4gICAgICAgIH0sXHJcbiAgICB9KSwge1xyXG4gICAgICAgIGRlY29yYXRpb25zOiB2ID0+IHYuZGVjb3JhdGlvbnNcclxuICAgIH0pO1xyXG59XHJcbmNvbnN0IHdoaXRlc3BhY2VIaWdobGlnaHRlciA9IC8qQF9fUFVSRV9fKi9tYXRjaGVyKC8qQF9fUFVSRV9fKi9uZXcgTWF0Y2hEZWNvcmF0b3Ioe1xyXG4gICAgcmVnZXhwOiAvXFx0fCArL2csXHJcbiAgICBkZWNvcmF0aW9uOiBtYXRjaCA9PiBnZXRXaGl0ZXNwYWNlRGVjbyhtYXRjaFswXSksXHJcbiAgICBib3VuZGFyeTogL1xcUy8sXHJcbn0pKTtcclxuLyoqXHJcblJldHVybnMgYW4gZXh0ZW5zaW9uIHRoYXQgaGlnaGxpZ2h0cyB3aGl0ZXNwYWNlLCBhZGRpbmcgYVxyXG5gY20taGlnaGxpZ2h0U3BhY2VgIGNsYXNzIHRvIHN0cmV0Y2hlcyBvZiBzcGFjZXMsIGFuZCBhXHJcbmBjbS1oaWdobGlnaHRUYWJgIGNsYXNzIHRvIGluZGl2aWR1YWwgdGFiIGNoYXJhY3RlcnMuIEJ5IGRlZmF1bHQsXHJcbnRoZSBmb3JtZXIgYXJlIHNob3duIGFzIGZhaW50IGRvdHMsIGFuZCB0aGUgbGF0dGVyIGFzIGFycm93cy5cclxuKi9cclxuZnVuY3Rpb24gaGlnaGxpZ2h0V2hpdGVzcGFjZSgpIHtcclxuICAgIHJldHVybiB3aGl0ZXNwYWNlSGlnaGxpZ2h0ZXI7XHJcbn1cclxuY29uc3QgdHJhaWxpbmdIaWdobGlnaHRlciA9IC8qQF9fUFVSRV9fKi9tYXRjaGVyKC8qQF9fUFVSRV9fKi9uZXcgTWF0Y2hEZWNvcmF0b3Ioe1xyXG4gICAgcmVnZXhwOiAvXFxzKyQvZyxcclxuICAgIGRlY29yYXRpb246IC8qQF9fUFVSRV9fKi9EZWNvcmF0aW9uLm1hcmsoeyBjbGFzczogXCJjbS10cmFpbGluZ1NwYWNlXCIgfSksXHJcbiAgICBib3VuZGFyeTogL1xcUy8sXHJcbn0pKTtcclxuLyoqXHJcblJldHVybnMgYW4gZXh0ZW5zaW9uIHRoYXQgYWRkcyBhIGBjbS10cmFpbGluZ1NwYWNlYCBjbGFzcyB0byBhbGxcclxudHJhaWxpbmcgd2hpdGVzcGFjZS5cclxuKi9cclxuZnVuY3Rpb24gaGlnaGxpZ2h0VHJhaWxpbmdXaGl0ZXNwYWNlKCkge1xyXG4gICAgcmV0dXJuIHRyYWlsaW5nSGlnaGxpZ2h0ZXI7XHJcbn1cclxuXHJcbi8qKlxyXG5AaW50ZXJuYWxcclxuKi9cclxuY29uc3QgX190ZXN0ID0geyBIZWlnaHRNYXAsIEhlaWdodE9yYWNsZSwgTWVhc3VyZWRIZWlnaHRzLCBRdWVyeVR5cGUsIENoYW5nZWRSYW5nZSwgY29tcHV0ZU9yZGVyLCBtb3ZlVmlzdWFsbHkgfTtcclxuXHJcbmV4cG9ydCB7IEJpZGlTcGFuLCBCbG9ja0luZm8sIEJsb2NrVHlwZSwgRGVjb3JhdGlvbiwgRGlyZWN0aW9uLCBFZGl0b3JWaWV3LCBHdXR0ZXJNYXJrZXIsIE1hdGNoRGVjb3JhdG9yLCBSZWN0YW5nbGVNYXJrZXIsIFZpZXdQbHVnaW4sIFZpZXdVcGRhdGUsIFdpZGdldFR5cGUsIF9fdGVzdCwgY2xvc2VIb3ZlclRvb2x0aXBzLCBjcm9zc2hhaXJDdXJzb3IsIGRyYXdTZWxlY3Rpb24sIGRyb3BDdXJzb3IsIGdldFBhbmVsLCBnZXRUb29sdGlwLCBndXR0ZXIsIGd1dHRlckxpbmVDbGFzcywgZ3V0dGVycywgaGFzSG92ZXJUb29sdGlwcywgaGlnaGxpZ2h0QWN0aXZlTGluZSwgaGlnaGxpZ2h0QWN0aXZlTGluZUd1dHRlciwgaGlnaGxpZ2h0U3BlY2lhbENoYXJzLCBoaWdobGlnaHRUcmFpbGluZ1doaXRlc3BhY2UsIGhpZ2hsaWdodFdoaXRlc3BhY2UsIGhvdmVyVG9vbHRpcCwga2V5bWFwLCBsYXllciwgbGluZU51bWJlck1hcmtlcnMsIGxpbmVOdW1iZXJzLCBsb2dFeGNlcHRpb24sIHBhbmVscywgcGxhY2Vob2xkZXIsIHJlY3Rhbmd1bGFyU2VsZWN0aW9uLCByZXBvc2l0aW9uVG9vbHRpcHMsIHJ1blNjb3BlSGFuZGxlcnMsIHNjcm9sbFBhc3RFbmQsIHNob3dQYW5lbCwgc2hvd1Rvb2x0aXAsIHRvb2x0aXBzIH07XHJcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@codemirror/view/dist/index.js\n"));

/***/ }),

/***/ "./node_modules/@lezer/common/dist/index.js":
/*!**************************************************!*\
  !*** ./node_modules/@lezer/common/dist/index.js ***!
  \**************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"DefaultBufferLength\": function() { return /* binding */ DefaultBufferLength; },\n/* harmony export */   \"IterMode\": function() { return /* binding */ IterMode; },\n/* harmony export */   \"MountedTree\": function() { return /* binding */ MountedTree; },\n/* harmony export */   \"NodeProp\": function() { return /* binding */ NodeProp; },\n/* harmony export */   \"NodeSet\": function() { return /* binding */ NodeSet; },\n/* harmony export */   \"NodeType\": function() { return /* binding */ NodeType; },\n/* harmony export */   \"NodeWeakMap\": function() { return /* binding */ NodeWeakMap; },\n/* harmony export */   \"Parser\": function() { return /* binding */ Parser; },\n/* harmony export */   \"Tree\": function() { return /* binding */ Tree; },\n/* harmony export */   \"TreeBuffer\": function() { return /* binding */ TreeBuffer; },\n/* harmony export */   \"TreeCursor\": function() { return /* binding */ TreeCursor; },\n/* harmony export */   \"TreeFragment\": function() { return /* binding */ TreeFragment; },\n/* harmony export */   \"parseMixed\": function() { return /* binding */ parseMixed; }\n/* harmony export */ });\n// FIXME profile adding a per-Tree TreeNode cache, validating it by\r\n// parent pointer\r\n/// The default maximum length of a `TreeBuffer` node.\r\nconst DefaultBufferLength = 1024;\r\nlet nextPropID = 0;\r\nclass Range {\r\n    constructor(from, to) {\r\n        this.from = from;\r\n        this.to = to;\r\n    }\r\n}\r\n/// Each [node type](#common.NodeType) or [individual tree](#common.Tree)\r\n/// can have metadata associated with it in props. Instances of this\r\n/// class represent prop names.\r\nclass NodeProp {\r\n    /// Create a new node prop type.\r\n    constructor(config = {}) {\r\n        this.id = nextPropID++;\r\n        this.perNode = !!config.perNode;\r\n        this.deserialize = config.deserialize || (() => {\r\n            throw new Error(\"This node type doesn't define a deserialize function\");\r\n        });\r\n    }\r\n    /// This is meant to be used with\r\n    /// [`NodeSet.extend`](#common.NodeSet.extend) or\r\n    /// [`LRParser.configure`](#lr.ParserConfig.props) to compute\r\n    /// prop values for each node type in the set. Takes a [match\r\n    /// object](#common.NodeType^match) or function that returns undefined\r\n    /// if the node type doesn't get this prop, and the prop's value if\r\n    /// it does.\r\n    add(match) {\r\n        if (this.perNode)\r\n            throw new RangeError(\"Can't add per-node props to node types\");\r\n        if (typeof match != \"function\")\r\n            match = NodeType.match(match);\r\n        return (type) => {\r\n            let result = match(type);\r\n            return result === undefined ? null : [this, result];\r\n        };\r\n    }\r\n}\r\n/// Prop that is used to describe matching delimiters. For opening\r\n/// delimiters, this holds an array of node names (written as a\r\n/// space-separated string when declaring this prop in a grammar)\r\n/// for the node types of closing delimiters that match it.\r\nNodeProp.closedBy = new NodeProp({ deserialize: str => str.split(\" \") });\r\n/// The inverse of [`closedBy`](#common.NodeProp^closedBy). This is\r\n/// attached to closing delimiters, holding an array of node names\r\n/// of types of matching opening delimiters.\r\nNodeProp.openedBy = new NodeProp({ deserialize: str => str.split(\" \") });\r\n/// Used to assign node types to groups (for example, all node\r\n/// types that represent an expression could be tagged with an\r\n/// `\"Expression\"` group).\r\nNodeProp.group = new NodeProp({ deserialize: str => str.split(\" \") });\r\n/// The hash of the [context](#lr.ContextTracker.constructor)\r\n/// that the node was parsed in, if any. Used to limit reuse of\r\n/// contextual nodes.\r\nNodeProp.contextHash = new NodeProp({ perNode: true });\r\n/// The distance beyond the end of the node that the tokenizer\r\n/// looked ahead for any of the tokens inside the node. (The LR\r\n/// parser only stores this when it is larger than 25, for\r\n/// efficiency reasons.)\r\nNodeProp.lookAhead = new NodeProp({ perNode: true });\r\n/// This per-node prop is used to replace a given node, or part of a\r\n/// node, with another tree. This is useful to include trees from\r\n/// different languages in mixed-language parsers.\r\nNodeProp.mounted = new NodeProp({ perNode: true });\r\n/// A mounted tree, which can be [stored](#common.NodeProp^mounted) on\r\n/// a tree node to indicate that parts of its content are\r\n/// represented by another tree.\r\nclass MountedTree {\r\n    constructor(\r\n    /// The inner tree.\r\n    tree, \r\n    /// If this is null, this tree replaces the entire node (it will\r\n    /// be included in the regular iteration instead of its host\r\n    /// node). If not, only the given ranges are considered to be\r\n    /// covered by this tree. This is used for trees that are mixed in\r\n    /// a way that isn't strictly hierarchical. Such mounted trees are\r\n    /// only entered by [`resolveInner`](#common.Tree.resolveInner)\r\n    /// and [`enter`](#common.SyntaxNode.enter).\r\n    overlay, \r\n    /// The parser used to create this subtree.\r\n    parser) {\r\n        this.tree = tree;\r\n        this.overlay = overlay;\r\n        this.parser = parser;\r\n    }\r\n}\r\nconst noProps = Object.create(null);\r\n/// Each node in a syntax tree has a node type associated with it.\r\nclass NodeType {\r\n    /// @internal\r\n    constructor(\r\n    /// The name of the node type. Not necessarily unique, but if the\r\n    /// grammar was written properly, different node types with the\r\n    /// same name within a node set should play the same semantic\r\n    /// role.\r\n    name, \r\n    /// @internal\r\n    props, \r\n    /// The id of this node in its set. Corresponds to the term ids\r\n    /// used in the parser.\r\n    id, \r\n    /// @internal\r\n    flags = 0) {\r\n        this.name = name;\r\n        this.props = props;\r\n        this.id = id;\r\n        this.flags = flags;\r\n    }\r\n    /// Define a node type.\r\n    static define(spec) {\r\n        let props = spec.props && spec.props.length ? Object.create(null) : noProps;\r\n        let flags = (spec.top ? 1 /* NodeFlag.Top */ : 0) | (spec.skipped ? 2 /* NodeFlag.Skipped */ : 0) |\r\n            (spec.error ? 4 /* NodeFlag.Error */ : 0) | (spec.name == null ? 8 /* NodeFlag.Anonymous */ : 0);\r\n        let type = new NodeType(spec.name || \"\", props, spec.id, flags);\r\n        if (spec.props)\r\n            for (let src of spec.props) {\r\n                if (!Array.isArray(src))\r\n                    src = src(type);\r\n                if (src) {\r\n                    if (src[0].perNode)\r\n                        throw new RangeError(\"Can't store a per-node prop on a node type\");\r\n                    props[src[0].id] = src[1];\r\n                }\r\n            }\r\n        return type;\r\n    }\r\n    /// Retrieves a node prop for this type. Will return `undefined` if\r\n    /// the prop isn't present on this node.\r\n    prop(prop) { return this.props[prop.id]; }\r\n    /// True when this is the top node of a grammar.\r\n    get isTop() { return (this.flags & 1 /* NodeFlag.Top */) > 0; }\r\n    /// True when this node is produced by a skip rule.\r\n    get isSkipped() { return (this.flags & 2 /* NodeFlag.Skipped */) > 0; }\r\n    /// Indicates whether this is an error node.\r\n    get isError() { return (this.flags & 4 /* NodeFlag.Error */) > 0; }\r\n    /// When true, this node type doesn't correspond to a user-declared\r\n    /// named node, for example because it is used to cache repetition.\r\n    get isAnonymous() { return (this.flags & 8 /* NodeFlag.Anonymous */) > 0; }\r\n    /// Returns true when this node's name or one of its\r\n    /// [groups](#common.NodeProp^group) matches the given string.\r\n    is(name) {\r\n        if (typeof name == 'string') {\r\n            if (this.name == name)\r\n                return true;\r\n            let group = this.prop(NodeProp.group);\r\n            return group ? group.indexOf(name) > -1 : false;\r\n        }\r\n        return this.id == name;\r\n    }\r\n    /// Create a function from node types to arbitrary values by\r\n    /// specifying an object whose property names are node or\r\n    /// [group](#common.NodeProp^group) names. Often useful with\r\n    /// [`NodeProp.add`](#common.NodeProp.add). You can put multiple\r\n    /// names, separated by spaces, in a single property name to map\r\n    /// multiple node names to a single value.\r\n    static match(map) {\r\n        let direct = Object.create(null);\r\n        for (let prop in map)\r\n            for (let name of prop.split(\" \"))\r\n                direct[name] = map[prop];\r\n        return (node) => {\r\n            for (let groups = node.prop(NodeProp.group), i = -1; i < (groups ? groups.length : 0); i++) {\r\n                let found = direct[i < 0 ? node.name : groups[i]];\r\n                if (found)\r\n                    return found;\r\n            }\r\n        };\r\n    }\r\n}\r\n/// An empty dummy node type to use when no actual type is available.\r\nNodeType.none = new NodeType(\"\", Object.create(null), 0, 8 /* NodeFlag.Anonymous */);\r\n/// A node set holds a collection of node types. It is used to\r\n/// compactly represent trees by storing their type ids, rather than a\r\n/// full pointer to the type object, in a numeric array. Each parser\r\n/// [has](#lr.LRParser.nodeSet) a node set, and [tree\r\n/// buffers](#common.TreeBuffer) can only store collections of nodes\r\n/// from the same set. A set can have a maximum of 2**16 (65536) node\r\n/// types in it, so that the ids fit into 16-bit typed array slots.\r\nclass NodeSet {\r\n    /// Create a set with the given types. The `id` property of each\r\n    /// type should correspond to its position within the array.\r\n    constructor(\r\n    /// The node types in this set, by id.\r\n    types) {\r\n        this.types = types;\r\n        for (let i = 0; i < types.length; i++)\r\n            if (types[i].id != i)\r\n                throw new RangeError(\"Node type ids should correspond to array positions when creating a node set\");\r\n    }\r\n    /// Create a copy of this set with some node properties added. The\r\n    /// arguments to this method can be created with\r\n    /// [`NodeProp.add`](#common.NodeProp.add).\r\n    extend(...props) {\r\n        let newTypes = [];\r\n        for (let type of this.types) {\r\n            let newProps = null;\r\n            for (let source of props) {\r\n                let add = source(type);\r\n                if (add) {\r\n                    if (!newProps)\r\n                        newProps = Object.assign({}, type.props);\r\n                    newProps[add[0].id] = add[1];\r\n                }\r\n            }\r\n            newTypes.push(newProps ? new NodeType(type.name, newProps, type.id, type.flags) : type);\r\n        }\r\n        return new NodeSet(newTypes);\r\n    }\r\n}\r\nconst CachedNode = new WeakMap(), CachedInnerNode = new WeakMap();\r\n/// Options that control iteration. Can be combined with the `|`\r\n/// operator to enable multiple ones.\r\nvar IterMode;\r\n(function (IterMode) {\r\n    /// When enabled, iteration will only visit [`Tree`](#common.Tree)\r\n    /// objects, not nodes packed into\r\n    /// [`TreeBuffer`](#common.TreeBuffer)s.\r\n    IterMode[IterMode[\"ExcludeBuffers\"] = 1] = \"ExcludeBuffers\";\r\n    /// Enable this to make iteration include anonymous nodes (such as\r\n    /// the nodes that wrap repeated grammar constructs into a balanced\r\n    /// tree).\r\n    IterMode[IterMode[\"IncludeAnonymous\"] = 2] = \"IncludeAnonymous\";\r\n    /// By default, regular [mounted](#common.NodeProp^mounted) nodes\r\n    /// replace their base node in iteration. Enable this to ignore them\r\n    /// instead.\r\n    IterMode[IterMode[\"IgnoreMounts\"] = 4] = \"IgnoreMounts\";\r\n    /// This option only applies in\r\n    /// [`enter`](#common.SyntaxNode.enter)-style methods. It tells the\r\n    /// library to not enter mounted overlays if one covers the given\r\n    /// position.\r\n    IterMode[IterMode[\"IgnoreOverlays\"] = 8] = \"IgnoreOverlays\";\r\n})(IterMode || (IterMode = {}));\r\n/// A piece of syntax tree. There are two ways to approach these\r\n/// trees: the way they are actually stored in memory, and the\r\n/// convenient way.\r\n///\r\n/// Syntax trees are stored as a tree of `Tree` and `TreeBuffer`\r\n/// objects. By packing detail information into `TreeBuffer` leaf\r\n/// nodes, the representation is made a lot more memory-efficient.\r\n///\r\n/// However, when you want to actually work with tree nodes, this\r\n/// representation is very awkward, so most client code will want to\r\n/// use the [`TreeCursor`](#common.TreeCursor) or\r\n/// [`SyntaxNode`](#common.SyntaxNode) interface instead, which provides\r\n/// a view on some part of this data structure, and can be used to\r\n/// move around to adjacent nodes.\r\nclass Tree {\r\n    /// Construct a new tree. See also [`Tree.build`](#common.Tree^build).\r\n    constructor(\r\n    /// The type of the top node.\r\n    type, \r\n    /// This node's child nodes.\r\n    children, \r\n    /// The positions (offsets relative to the start of this tree) of\r\n    /// the children.\r\n    positions, \r\n    /// The total length of this tree\r\n    length, \r\n    /// Per-node [node props](#common.NodeProp) to associate with this node.\r\n    props) {\r\n        this.type = type;\r\n        this.children = children;\r\n        this.positions = positions;\r\n        this.length = length;\r\n        /// @internal\r\n        this.props = null;\r\n        if (props && props.length) {\r\n            this.props = Object.create(null);\r\n            for (let [prop, value] of props)\r\n                this.props[typeof prop == \"number\" ? prop : prop.id] = value;\r\n        }\r\n    }\r\n    /// @internal\r\n    toString() {\r\n        let mounted = this.prop(NodeProp.mounted);\r\n        if (mounted && !mounted.overlay)\r\n            return mounted.tree.toString();\r\n        let children = \"\";\r\n        for (let ch of this.children) {\r\n            let str = ch.toString();\r\n            if (str) {\r\n                if (children)\r\n                    children += \",\";\r\n                children += str;\r\n            }\r\n        }\r\n        return !this.type.name ? children :\r\n            (/\\W/.test(this.type.name) && !this.type.isError ? JSON.stringify(this.type.name) : this.type.name) +\r\n                (children.length ? \"(\" + children + \")\" : \"\");\r\n    }\r\n    /// Get a [tree cursor](#common.TreeCursor) positioned at the top of\r\n    /// the tree. Mode can be used to [control](#common.IterMode) which\r\n    /// nodes the cursor visits.\r\n    cursor(mode = 0) {\r\n        return new TreeCursor(this.topNode, mode);\r\n    }\r\n    /// Get a [tree cursor](#common.TreeCursor) pointing into this tree\r\n    /// at the given position and side (see\r\n    /// [`moveTo`](#common.TreeCursor.moveTo).\r\n    cursorAt(pos, side = 0, mode = 0) {\r\n        let scope = CachedNode.get(this) || this.topNode;\r\n        let cursor = new TreeCursor(scope);\r\n        cursor.moveTo(pos, side);\r\n        CachedNode.set(this, cursor._tree);\r\n        return cursor;\r\n    }\r\n    /// Get a [syntax node](#common.SyntaxNode) object for the top of the\r\n    /// tree.\r\n    get topNode() {\r\n        return new TreeNode(this, 0, 0, null);\r\n    }\r\n    /// Get the [syntax node](#common.SyntaxNode) at the given position.\r\n    /// If `side` is -1, this will move into nodes that end at the\r\n    /// position. If 1, it'll move into nodes that start at the\r\n    /// position. With 0, it'll only enter nodes that cover the position\r\n    /// from both sides.\r\n    ///\r\n    /// Note that this will not enter\r\n    /// [overlays](#common.MountedTree.overlay), and you often want\r\n    /// [`resolveInner`](#common.Tree.resolveInner) instead.\r\n    resolve(pos, side = 0) {\r\n        let node = resolveNode(CachedNode.get(this) || this.topNode, pos, side, false);\r\n        CachedNode.set(this, node);\r\n        return node;\r\n    }\r\n    /// Like [`resolve`](#common.Tree.resolve), but will enter\r\n    /// [overlaid](#common.MountedTree.overlay) nodes, producing a syntax node\r\n    /// pointing into the innermost overlaid tree at the given position\r\n    /// (with parent links going through all parent structure, including\r\n    /// the host trees).\r\n    resolveInner(pos, side = 0) {\r\n        let node = resolveNode(CachedInnerNode.get(this) || this.topNode, pos, side, true);\r\n        CachedInnerNode.set(this, node);\r\n        return node;\r\n    }\r\n    /// Iterate over the tree and its children, calling `enter` for any\r\n    /// node that touches the `from`/`to` region (if given) before\r\n    /// running over such a node's children, and `leave` (if given) when\r\n    /// leaving the node. When `enter` returns `false`, that node will\r\n    /// not have its children iterated over (or `leave` called).\r\n    iterate(spec) {\r\n        let { enter, leave, from = 0, to = this.length } = spec;\r\n        for (let c = this.cursor((spec.mode || 0) | IterMode.IncludeAnonymous);;) {\r\n            let entered = false;\r\n            if (c.from <= to && c.to >= from && (c.type.isAnonymous || enter(c) !== false)) {\r\n                if (c.firstChild())\r\n                    continue;\r\n                entered = true;\r\n            }\r\n            for (;;) {\r\n                if (entered && leave && !c.type.isAnonymous)\r\n                    leave(c);\r\n                if (c.nextSibling())\r\n                    break;\r\n                if (!c.parent())\r\n                    return;\r\n                entered = true;\r\n            }\r\n        }\r\n    }\r\n    /// Get the value of the given [node prop](#common.NodeProp) for this\r\n    /// node. Works with both per-node and per-type props.\r\n    prop(prop) {\r\n        return !prop.perNode ? this.type.prop(prop) : this.props ? this.props[prop.id] : undefined;\r\n    }\r\n    /// Returns the node's [per-node props](#common.NodeProp.perNode) in a\r\n    /// format that can be passed to the [`Tree`](#common.Tree)\r\n    /// constructor.\r\n    get propValues() {\r\n        let result = [];\r\n        if (this.props)\r\n            for (let id in this.props)\r\n                result.push([+id, this.props[id]]);\r\n        return result;\r\n    }\r\n    /// Balance the direct children of this tree, producing a copy of\r\n    /// which may have children grouped into subtrees with type\r\n    /// [`NodeType.none`](#common.NodeType^none).\r\n    balance(config = {}) {\r\n        return this.children.length <= 8 /* Balance.BranchFactor */ ? this :\r\n            balanceRange(NodeType.none, this.children, this.positions, 0, this.children.length, 0, this.length, (children, positions, length) => new Tree(this.type, children, positions, length, this.propValues), config.makeTree || ((children, positions, length) => new Tree(NodeType.none, children, positions, length)));\r\n    }\r\n    /// Build a tree from a postfix-ordered buffer of node information,\r\n    /// or a cursor over such a buffer.\r\n    static build(data) { return buildTree(data); }\r\n}\r\n/// The empty tree\r\nTree.empty = new Tree(NodeType.none, [], [], 0);\r\nclass FlatBufferCursor {\r\n    constructor(buffer, index) {\r\n        this.buffer = buffer;\r\n        this.index = index;\r\n    }\r\n    get id() { return this.buffer[this.index - 4]; }\r\n    get start() { return this.buffer[this.index - 3]; }\r\n    get end() { return this.buffer[this.index - 2]; }\r\n    get size() { return this.buffer[this.index - 1]; }\r\n    get pos() { return this.index; }\r\n    next() { this.index -= 4; }\r\n    fork() { return new FlatBufferCursor(this.buffer, this.index); }\r\n}\r\n/// Tree buffers contain (type, start, end, endIndex) quads for each\r\n/// node. In such a buffer, nodes are stored in prefix order (parents\r\n/// before children, with the endIndex of the parent indicating which\r\n/// children belong to it).\r\nclass TreeBuffer {\r\n    /// Create a tree buffer.\r\n    constructor(\r\n    /// The buffer's content.\r\n    buffer, \r\n    /// The total length of the group of nodes in the buffer.\r\n    length, \r\n    /// The node set used in this buffer.\r\n    set) {\r\n        this.buffer = buffer;\r\n        this.length = length;\r\n        this.set = set;\r\n    }\r\n    /// @internal\r\n    get type() { return NodeType.none; }\r\n    /// @internal\r\n    toString() {\r\n        let result = [];\r\n        for (let index = 0; index < this.buffer.length;) {\r\n            result.push(this.childString(index));\r\n            index = this.buffer[index + 3];\r\n        }\r\n        return result.join(\",\");\r\n    }\r\n    /// @internal\r\n    childString(index) {\r\n        let id = this.buffer[index], endIndex = this.buffer[index + 3];\r\n        let type = this.set.types[id], result = type.name;\r\n        if (/\\W/.test(result) && !type.isError)\r\n            result = JSON.stringify(result);\r\n        index += 4;\r\n        if (endIndex == index)\r\n            return result;\r\n        let children = [];\r\n        while (index < endIndex) {\r\n            children.push(this.childString(index));\r\n            index = this.buffer[index + 3];\r\n        }\r\n        return result + \"(\" + children.join(\",\") + \")\";\r\n    }\r\n    /// @internal\r\n    findChild(startIndex, endIndex, dir, pos, side) {\r\n        let { buffer } = this, pick = -1;\r\n        for (let i = startIndex; i != endIndex; i = buffer[i + 3]) {\r\n            if (checkSide(side, pos, buffer[i + 1], buffer[i + 2])) {\r\n                pick = i;\r\n                if (dir > 0)\r\n                    break;\r\n            }\r\n        }\r\n        return pick;\r\n    }\r\n    /// @internal\r\n    slice(startI, endI, from) {\r\n        let b = this.buffer;\r\n        let copy = new Uint16Array(endI - startI), len = 0;\r\n        for (let i = startI, j = 0; i < endI;) {\r\n            copy[j++] = b[i++];\r\n            copy[j++] = b[i++] - from;\r\n            let to = copy[j++] = b[i++] - from;\r\n            copy[j++] = b[i++] - startI;\r\n            len = Math.max(len, to);\r\n        }\r\n        return new TreeBuffer(copy, len, this.set);\r\n    }\r\n}\r\nfunction checkSide(side, pos, from, to) {\r\n    switch (side) {\r\n        case -2 /* Side.Before */: return from < pos;\r\n        case -1 /* Side.AtOrBefore */: return to >= pos && from < pos;\r\n        case 0 /* Side.Around */: return from < pos && to > pos;\r\n        case 1 /* Side.AtOrAfter */: return from <= pos && to > pos;\r\n        case 2 /* Side.After */: return to > pos;\r\n        case 4 /* Side.DontCare */: return true;\r\n    }\r\n}\r\nfunction enterUnfinishedNodesBefore(node, pos) {\r\n    let scan = node.childBefore(pos);\r\n    while (scan) {\r\n        let last = scan.lastChild;\r\n        if (!last || last.to != scan.to)\r\n            break;\r\n        if (last.type.isError && last.from == last.to) {\r\n            node = scan;\r\n            scan = last.prevSibling;\r\n        }\r\n        else {\r\n            scan = last;\r\n        }\r\n    }\r\n    return node;\r\n}\r\nfunction resolveNode(node, pos, side, overlays) {\r\n    var _a;\r\n    // Move up to a node that actually holds the position, if possible\r\n    while (node.from == node.to ||\r\n        (side < 1 ? node.from >= pos : node.from > pos) ||\r\n        (side > -1 ? node.to <= pos : node.to < pos)) {\r\n        let parent = !overlays && node instanceof TreeNode && node.index < 0 ? null : node.parent;\r\n        if (!parent)\r\n            return node;\r\n        node = parent;\r\n    }\r\n    let mode = overlays ? 0 : IterMode.IgnoreOverlays;\r\n    // Must go up out of overlays when those do not overlap with pos\r\n    if (overlays)\r\n        for (let scan = node, parent = scan.parent; parent; scan = parent, parent = scan.parent) {\r\n            if (scan instanceof TreeNode && scan.index < 0 && ((_a = parent.enter(pos, side, mode)) === null || _a === void 0 ? void 0 : _a.from) != scan.from)\r\n                node = parent;\r\n        }\r\n    for (;;) {\r\n        let inner = node.enter(pos, side, mode);\r\n        if (!inner)\r\n            return node;\r\n        node = inner;\r\n    }\r\n}\r\nclass TreeNode {\r\n    constructor(_tree, from, \r\n    // Index in parent node, set to -1 if the node is not a direct child of _parent.node (overlay)\r\n    index, _parent) {\r\n        this._tree = _tree;\r\n        this.from = from;\r\n        this.index = index;\r\n        this._parent = _parent;\r\n    }\r\n    get type() { return this._tree.type; }\r\n    get name() { return this._tree.type.name; }\r\n    get to() { return this.from + this._tree.length; }\r\n    nextChild(i, dir, pos, side, mode = 0) {\r\n        for (let parent = this;;) {\r\n            for (let { children, positions } = parent._tree, e = dir > 0 ? children.length : -1; i != e; i += dir) {\r\n                let next = children[i], start = positions[i] + parent.from;\r\n                if (!checkSide(side, pos, start, start + next.length))\r\n                    continue;\r\n                if (next instanceof TreeBuffer) {\r\n                    if (mode & IterMode.ExcludeBuffers)\r\n                        continue;\r\n                    let index = next.findChild(0, next.buffer.length, dir, pos - start, side);\r\n                    if (index > -1)\r\n                        return new BufferNode(new BufferContext(parent, next, i, start), null, index);\r\n                }\r\n                else if ((mode & IterMode.IncludeAnonymous) || (!next.type.isAnonymous || hasChild(next))) {\r\n                    let mounted;\r\n                    if (!(mode & IterMode.IgnoreMounts) &&\r\n                        next.props && (mounted = next.prop(NodeProp.mounted)) && !mounted.overlay)\r\n                        return new TreeNode(mounted.tree, start, i, parent);\r\n                    let inner = new TreeNode(next, start, i, parent);\r\n                    return (mode & IterMode.IncludeAnonymous) || !inner.type.isAnonymous ? inner\r\n                        : inner.nextChild(dir < 0 ? next.children.length - 1 : 0, dir, pos, side);\r\n                }\r\n            }\r\n            if ((mode & IterMode.IncludeAnonymous) || !parent.type.isAnonymous)\r\n                return null;\r\n            if (parent.index >= 0)\r\n                i = parent.index + dir;\r\n            else\r\n                i = dir < 0 ? -1 : parent._parent._tree.children.length;\r\n            parent = parent._parent;\r\n            if (!parent)\r\n                return null;\r\n        }\r\n    }\r\n    get firstChild() { return this.nextChild(0, 1, 0, 4 /* Side.DontCare */); }\r\n    get lastChild() { return this.nextChild(this._tree.children.length - 1, -1, 0, 4 /* Side.DontCare */); }\r\n    childAfter(pos) { return this.nextChild(0, 1, pos, 2 /* Side.After */); }\r\n    childBefore(pos) { return this.nextChild(this._tree.children.length - 1, -1, pos, -2 /* Side.Before */); }\r\n    enter(pos, side, mode = 0) {\r\n        let mounted;\r\n        if (!(mode & IterMode.IgnoreOverlays) && (mounted = this._tree.prop(NodeProp.mounted)) && mounted.overlay) {\r\n            let rPos = pos - this.from;\r\n            for (let { from, to } of mounted.overlay) {\r\n                if ((side > 0 ? from <= rPos : from < rPos) &&\r\n                    (side < 0 ? to >= rPos : to > rPos))\r\n                    return new TreeNode(mounted.tree, mounted.overlay[0].from + this.from, -1, this);\r\n            }\r\n        }\r\n        return this.nextChild(0, 1, pos, side, mode);\r\n    }\r\n    nextSignificantParent() {\r\n        let val = this;\r\n        while (val.type.isAnonymous && val._parent)\r\n            val = val._parent;\r\n        return val;\r\n    }\r\n    get parent() {\r\n        return this._parent ? this._parent.nextSignificantParent() : null;\r\n    }\r\n    get nextSibling() {\r\n        return this._parent && this.index >= 0 ? this._parent.nextChild(this.index + 1, 1, 0, 4 /* Side.DontCare */) : null;\r\n    }\r\n    get prevSibling() {\r\n        return this._parent && this.index >= 0 ? this._parent.nextChild(this.index - 1, -1, 0, 4 /* Side.DontCare */) : null;\r\n    }\r\n    cursor(mode = 0) { return new TreeCursor(this, mode); }\r\n    get tree() { return this._tree; }\r\n    toTree() { return this._tree; }\r\n    resolve(pos, side = 0) {\r\n        return resolveNode(this, pos, side, false);\r\n    }\r\n    resolveInner(pos, side = 0) {\r\n        return resolveNode(this, pos, side, true);\r\n    }\r\n    enterUnfinishedNodesBefore(pos) { return enterUnfinishedNodesBefore(this, pos); }\r\n    getChild(type, before = null, after = null) {\r\n        let r = getChildren(this, type, before, after);\r\n        return r.length ? r[0] : null;\r\n    }\r\n    getChildren(type, before = null, after = null) {\r\n        return getChildren(this, type, before, after);\r\n    }\r\n    /// @internal\r\n    toString() { return this._tree.toString(); }\r\n    get node() { return this; }\r\n    matchContext(context) { return matchNodeContext(this, context); }\r\n}\r\nfunction getChildren(node, type, before, after) {\r\n    let cur = node.cursor(), result = [];\r\n    if (!cur.firstChild())\r\n        return result;\r\n    if (before != null)\r\n        while (!cur.type.is(before))\r\n            if (!cur.nextSibling())\r\n                return result;\r\n    for (;;) {\r\n        if (after != null && cur.type.is(after))\r\n            return result;\r\n        if (cur.type.is(type))\r\n            result.push(cur.node);\r\n        if (!cur.nextSibling())\r\n            return after == null ? result : [];\r\n    }\r\n}\r\nfunction matchNodeContext(node, context, i = context.length - 1) {\r\n    for (let p = node.parent; i >= 0; p = p.parent) {\r\n        if (!p)\r\n            return false;\r\n        if (!p.type.isAnonymous) {\r\n            if (context[i] && context[i] != p.name)\r\n                return false;\r\n            i--;\r\n        }\r\n    }\r\n    return true;\r\n}\r\nclass BufferContext {\r\n    constructor(parent, buffer, index, start) {\r\n        this.parent = parent;\r\n        this.buffer = buffer;\r\n        this.index = index;\r\n        this.start = start;\r\n    }\r\n}\r\nclass BufferNode {\r\n    get name() { return this.type.name; }\r\n    get from() { return this.context.start + this.context.buffer.buffer[this.index + 1]; }\r\n    get to() { return this.context.start + this.context.buffer.buffer[this.index + 2]; }\r\n    constructor(context, _parent, index) {\r\n        this.context = context;\r\n        this._parent = _parent;\r\n        this.index = index;\r\n        this.type = context.buffer.set.types[context.buffer.buffer[index]];\r\n    }\r\n    child(dir, pos, side) {\r\n        let { buffer } = this.context;\r\n        let index = buffer.findChild(this.index + 4, buffer.buffer[this.index + 3], dir, pos - this.context.start, side);\r\n        return index < 0 ? null : new BufferNode(this.context, this, index);\r\n    }\r\n    get firstChild() { return this.child(1, 0, 4 /* Side.DontCare */); }\r\n    get lastChild() { return this.child(-1, 0, 4 /* Side.DontCare */); }\r\n    childAfter(pos) { return this.child(1, pos, 2 /* Side.After */); }\r\n    childBefore(pos) { return this.child(-1, pos, -2 /* Side.Before */); }\r\n    enter(pos, side, mode = 0) {\r\n        if (mode & IterMode.ExcludeBuffers)\r\n            return null;\r\n        let { buffer } = this.context;\r\n        let index = buffer.findChild(this.index + 4, buffer.buffer[this.index + 3], side > 0 ? 1 : -1, pos - this.context.start, side);\r\n        return index < 0 ? null : new BufferNode(this.context, this, index);\r\n    }\r\n    get parent() {\r\n        return this._parent || this.context.parent.nextSignificantParent();\r\n    }\r\n    externalSibling(dir) {\r\n        return this._parent ? null : this.context.parent.nextChild(this.context.index + dir, dir, 0, 4 /* Side.DontCare */);\r\n    }\r\n    get nextSibling() {\r\n        let { buffer } = this.context;\r\n        let after = buffer.buffer[this.index + 3];\r\n        if (after < (this._parent ? buffer.buffer[this._parent.index + 3] : buffer.buffer.length))\r\n            return new BufferNode(this.context, this._parent, after);\r\n        return this.externalSibling(1);\r\n    }\r\n    get prevSibling() {\r\n        let { buffer } = this.context;\r\n        let parentStart = this._parent ? this._parent.index + 4 : 0;\r\n        if (this.index == parentStart)\r\n            return this.externalSibling(-1);\r\n        return new BufferNode(this.context, this._parent, buffer.findChild(parentStart, this.index, -1, 0, 4 /* Side.DontCare */));\r\n    }\r\n    cursor(mode = 0) { return new TreeCursor(this, mode); }\r\n    get tree() { return null; }\r\n    toTree() {\r\n        let children = [], positions = [];\r\n        let { buffer } = this.context;\r\n        let startI = this.index + 4, endI = buffer.buffer[this.index + 3];\r\n        if (endI > startI) {\r\n            let from = buffer.buffer[this.index + 1];\r\n            children.push(buffer.slice(startI, endI, from));\r\n            positions.push(0);\r\n        }\r\n        return new Tree(this.type, children, positions, this.to - this.from);\r\n    }\r\n    resolve(pos, side = 0) {\r\n        return resolveNode(this, pos, side, false);\r\n    }\r\n    resolveInner(pos, side = 0) {\r\n        return resolveNode(this, pos, side, true);\r\n    }\r\n    enterUnfinishedNodesBefore(pos) { return enterUnfinishedNodesBefore(this, pos); }\r\n    /// @internal\r\n    toString() { return this.context.buffer.childString(this.index); }\r\n    getChild(type, before = null, after = null) {\r\n        let r = getChildren(this, type, before, after);\r\n        return r.length ? r[0] : null;\r\n    }\r\n    getChildren(type, before = null, after = null) {\r\n        return getChildren(this, type, before, after);\r\n    }\r\n    get node() { return this; }\r\n    matchContext(context) { return matchNodeContext(this, context); }\r\n}\r\n/// A tree cursor object focuses on a given node in a syntax tree, and\r\n/// allows you to move to adjacent nodes.\r\nclass TreeCursor {\r\n    /// Shorthand for `.type.name`.\r\n    get name() { return this.type.name; }\r\n    /// @internal\r\n    constructor(node, \r\n    /// @internal\r\n    mode = 0) {\r\n        this.mode = mode;\r\n        /// @internal\r\n        this.buffer = null;\r\n        this.stack = [];\r\n        /// @internal\r\n        this.index = 0;\r\n        this.bufferNode = null;\r\n        if (node instanceof TreeNode) {\r\n            this.yieldNode(node);\r\n        }\r\n        else {\r\n            this._tree = node.context.parent;\r\n            this.buffer = node.context;\r\n            for (let n = node._parent; n; n = n._parent)\r\n                this.stack.unshift(n.index);\r\n            this.bufferNode = node;\r\n            this.yieldBuf(node.index);\r\n        }\r\n    }\r\n    yieldNode(node) {\r\n        if (!node)\r\n            return false;\r\n        this._tree = node;\r\n        this.type = node.type;\r\n        this.from = node.from;\r\n        this.to = node.to;\r\n        return true;\r\n    }\r\n    yieldBuf(index, type) {\r\n        this.index = index;\r\n        let { start, buffer } = this.buffer;\r\n        this.type = type || buffer.set.types[buffer.buffer[index]];\r\n        this.from = start + buffer.buffer[index + 1];\r\n        this.to = start + buffer.buffer[index + 2];\r\n        return true;\r\n    }\r\n    yield(node) {\r\n        if (!node)\r\n            return false;\r\n        if (node instanceof TreeNode) {\r\n            this.buffer = null;\r\n            return this.yieldNode(node);\r\n        }\r\n        this.buffer = node.context;\r\n        return this.yieldBuf(node.index, node.type);\r\n    }\r\n    /// @internal\r\n    toString() {\r\n        return this.buffer ? this.buffer.buffer.childString(this.index) : this._tree.toString();\r\n    }\r\n    /// @internal\r\n    enterChild(dir, pos, side) {\r\n        if (!this.buffer)\r\n            return this.yield(this._tree.nextChild(dir < 0 ? this._tree._tree.children.length - 1 : 0, dir, pos, side, this.mode));\r\n        let { buffer } = this.buffer;\r\n        let index = buffer.findChild(this.index + 4, buffer.buffer[this.index + 3], dir, pos - this.buffer.start, side);\r\n        if (index < 0)\r\n            return false;\r\n        this.stack.push(this.index);\r\n        return this.yieldBuf(index);\r\n    }\r\n    /// Move the cursor to this node's first child. When this returns\r\n    /// false, the node has no child, and the cursor has not been moved.\r\n    firstChild() { return this.enterChild(1, 0, 4 /* Side.DontCare */); }\r\n    /// Move the cursor to this node's last child.\r\n    lastChild() { return this.enterChild(-1, 0, 4 /* Side.DontCare */); }\r\n    /// Move the cursor to the first child that ends after `pos`.\r\n    childAfter(pos) { return this.enterChild(1, pos, 2 /* Side.After */); }\r\n    /// Move to the last child that starts before `pos`.\r\n    childBefore(pos) { return this.enterChild(-1, pos, -2 /* Side.Before */); }\r\n    /// Move the cursor to the child around `pos`. If side is -1 the\r\n    /// child may end at that position, when 1 it may start there. This\r\n    /// will also enter [overlaid](#common.MountedTree.overlay)\r\n    /// [mounted](#common.NodeProp^mounted) trees unless `overlays` is\r\n    /// set to false.\r\n    enter(pos, side, mode = this.mode) {\r\n        if (!this.buffer)\r\n            return this.yield(this._tree.enter(pos, side, mode));\r\n        return mode & IterMode.ExcludeBuffers ? false : this.enterChild(1, pos, side);\r\n    }\r\n    /// Move to the node's parent node, if this isn't the top node.\r\n    parent() {\r\n        if (!this.buffer)\r\n            return this.yieldNode((this.mode & IterMode.IncludeAnonymous) ? this._tree._parent : this._tree.parent);\r\n        if (this.stack.length)\r\n            return this.yieldBuf(this.stack.pop());\r\n        let parent = (this.mode & IterMode.IncludeAnonymous) ? this.buffer.parent : this.buffer.parent.nextSignificantParent();\r\n        this.buffer = null;\r\n        return this.yieldNode(parent);\r\n    }\r\n    /// @internal\r\n    sibling(dir) {\r\n        if (!this.buffer)\r\n            return !this._tree._parent ? false\r\n                : this.yield(this._tree.index < 0 ? null\r\n                    : this._tree._parent.nextChild(this._tree.index + dir, dir, 0, 4 /* Side.DontCare */, this.mode));\r\n        let { buffer } = this.buffer, d = this.stack.length - 1;\r\n        if (dir < 0) {\r\n            let parentStart = d < 0 ? 0 : this.stack[d] + 4;\r\n            if (this.index != parentStart)\r\n                return this.yieldBuf(buffer.findChild(parentStart, this.index, -1, 0, 4 /* Side.DontCare */));\r\n        }\r\n        else {\r\n            let after = buffer.buffer[this.index + 3];\r\n            if (after < (d < 0 ? buffer.buffer.length : buffer.buffer[this.stack[d] + 3]))\r\n                return this.yieldBuf(after);\r\n        }\r\n        return d < 0 ? this.yield(this.buffer.parent.nextChild(this.buffer.index + dir, dir, 0, 4 /* Side.DontCare */, this.mode)) : false;\r\n    }\r\n    /// Move to this node's next sibling, if any.\r\n    nextSibling() { return this.sibling(1); }\r\n    /// Move to this node's previous sibling, if any.\r\n    prevSibling() { return this.sibling(-1); }\r\n    atLastNode(dir) {\r\n        let index, parent, { buffer } = this;\r\n        if (buffer) {\r\n            if (dir > 0) {\r\n                if (this.index < buffer.buffer.buffer.length)\r\n                    return false;\r\n            }\r\n            else {\r\n                for (let i = 0; i < this.index; i++)\r\n                    if (buffer.buffer.buffer[i + 3] < this.index)\r\n                        return false;\r\n            }\r\n            ({ index, parent } = buffer);\r\n        }\r\n        else {\r\n            ({ index, _parent: parent } = this._tree);\r\n        }\r\n        for (; parent; { index, _parent: parent } = parent) {\r\n            if (index > -1)\r\n                for (let i = index + dir, e = dir < 0 ? -1 : parent._tree.children.length; i != e; i += dir) {\r\n                    let child = parent._tree.children[i];\r\n                    if ((this.mode & IterMode.IncludeAnonymous) ||\r\n                        child instanceof TreeBuffer ||\r\n                        !child.type.isAnonymous ||\r\n                        hasChild(child))\r\n                        return false;\r\n                }\r\n        }\r\n        return true;\r\n    }\r\n    move(dir, enter) {\r\n        if (enter && this.enterChild(dir, 0, 4 /* Side.DontCare */))\r\n            return true;\r\n        for (;;) {\r\n            if (this.sibling(dir))\r\n                return true;\r\n            if (this.atLastNode(dir) || !this.parent())\r\n                return false;\r\n        }\r\n    }\r\n    /// Move to the next node in a\r\n    /// [pre-order](https://en.wikipedia.org/wiki/Tree_traversal#Pre-order,_NLR)\r\n    /// traversal, going from a node to its first child or, if the\r\n    /// current node is empty or `enter` is false, its next sibling or\r\n    /// the next sibling of the first parent node that has one.\r\n    next(enter = true) { return this.move(1, enter); }\r\n    /// Move to the next node in a last-to-first pre-order traveral. A\r\n    /// node is followed by its last child or, if it has none, its\r\n    /// previous sibling or the previous sibling of the first parent\r\n    /// node that has one.\r\n    prev(enter = true) { return this.move(-1, enter); }\r\n    /// Move the cursor to the innermost node that covers `pos`. If\r\n    /// `side` is -1, it will enter nodes that end at `pos`. If it is 1,\r\n    /// it will enter nodes that start at `pos`.\r\n    moveTo(pos, side = 0) {\r\n        // Move up to a node that actually holds the position, if possible\r\n        while (this.from == this.to ||\r\n            (side < 1 ? this.from >= pos : this.from > pos) ||\r\n            (side > -1 ? this.to <= pos : this.to < pos))\r\n            if (!this.parent())\r\n                break;\r\n        // Then scan down into child nodes as far as possible\r\n        while (this.enterChild(1, pos, side)) { }\r\n        return this;\r\n    }\r\n    /// Get a [syntax node](#common.SyntaxNode) at the cursor's current\r\n    /// position.\r\n    get node() {\r\n        if (!this.buffer)\r\n            return this._tree;\r\n        let cache = this.bufferNode, result = null, depth = 0;\r\n        if (cache && cache.context == this.buffer) {\r\n            scan: for (let index = this.index, d = this.stack.length; d >= 0;) {\r\n                for (let c = cache; c; c = c._parent)\r\n                    if (c.index == index) {\r\n                        if (index == this.index)\r\n                            return c;\r\n                        result = c;\r\n                        depth = d + 1;\r\n                        break scan;\r\n                    }\r\n                index = this.stack[--d];\r\n            }\r\n        }\r\n        for (let i = depth; i < this.stack.length; i++)\r\n            result = new BufferNode(this.buffer, result, this.stack[i]);\r\n        return this.bufferNode = new BufferNode(this.buffer, result, this.index);\r\n    }\r\n    /// Get the [tree](#common.Tree) that represents the current node, if\r\n    /// any. Will return null when the node is in a [tree\r\n    /// buffer](#common.TreeBuffer).\r\n    get tree() {\r\n        return this.buffer ? null : this._tree._tree;\r\n    }\r\n    /// Iterate over the current node and all its descendants, calling\r\n    /// `enter` when entering a node and `leave`, if given, when leaving\r\n    /// one. When `enter` returns `false`, any children of that node are\r\n    /// skipped, and `leave` isn't called for it.\r\n    iterate(enter, leave) {\r\n        for (let depth = 0;;) {\r\n            let mustLeave = false;\r\n            if (this.type.isAnonymous || enter(this) !== false) {\r\n                if (this.firstChild()) {\r\n                    depth++;\r\n                    continue;\r\n                }\r\n                if (!this.type.isAnonymous)\r\n                    mustLeave = true;\r\n            }\r\n            for (;;) {\r\n                if (mustLeave && leave)\r\n                    leave(this);\r\n                mustLeave = this.type.isAnonymous;\r\n                if (this.nextSibling())\r\n                    break;\r\n                if (!depth)\r\n                    return;\r\n                this.parent();\r\n                depth--;\r\n                mustLeave = true;\r\n            }\r\n        }\r\n    }\r\n    /// Test whether the current node matches a given context—a sequence\r\n    /// of direct parent node names. Empty strings in the context array\r\n    /// are treated as wildcards.\r\n    matchContext(context) {\r\n        if (!this.buffer)\r\n            return matchNodeContext(this.node, context);\r\n        let { buffer } = this.buffer, { types } = buffer.set;\r\n        for (let i = context.length - 1, d = this.stack.length - 1; i >= 0; d--) {\r\n            if (d < 0)\r\n                return matchNodeContext(this.node, context, i);\r\n            let type = types[buffer.buffer[this.stack[d]]];\r\n            if (!type.isAnonymous) {\r\n                if (context[i] && context[i] != type.name)\r\n                    return false;\r\n                i--;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n}\r\nfunction hasChild(tree) {\r\n    return tree.children.some(ch => ch instanceof TreeBuffer || !ch.type.isAnonymous || hasChild(ch));\r\n}\r\nfunction buildTree(data) {\r\n    var _a;\r\n    let { buffer, nodeSet, maxBufferLength = DefaultBufferLength, reused = [], minRepeatType = nodeSet.types.length } = data;\r\n    let cursor = Array.isArray(buffer) ? new FlatBufferCursor(buffer, buffer.length) : buffer;\r\n    let types = nodeSet.types;\r\n    let contextHash = 0, lookAhead = 0;\r\n    function takeNode(parentStart, minPos, children, positions, inRepeat) {\r\n        let { id, start, end, size } = cursor;\r\n        let lookAheadAtStart = lookAhead;\r\n        while (size < 0) {\r\n            cursor.next();\r\n            if (size == -1 /* SpecialRecord.Reuse */) {\r\n                let node = reused[id];\r\n                children.push(node);\r\n                positions.push(start - parentStart);\r\n                return;\r\n            }\r\n            else if (size == -3 /* SpecialRecord.ContextChange */) { // Context change\r\n                contextHash = id;\r\n                return;\r\n            }\r\n            else if (size == -4 /* SpecialRecord.LookAhead */) {\r\n                lookAhead = id;\r\n                return;\r\n            }\r\n            else {\r\n                throw new RangeError(`Unrecognized record size: ${size}`);\r\n            }\r\n        }\r\n        let type = types[id], node, buffer;\r\n        let startPos = start - parentStart;\r\n        if (end - start <= maxBufferLength && (buffer = findBufferSize(cursor.pos - minPos, inRepeat))) {\r\n            // Small enough for a buffer, and no reused nodes inside\r\n            let data = new Uint16Array(buffer.size - buffer.skip);\r\n            let endPos = cursor.pos - buffer.size, index = data.length;\r\n            while (cursor.pos > endPos)\r\n                index = copyToBuffer(buffer.start, data, index);\r\n            node = new TreeBuffer(data, end - buffer.start, nodeSet);\r\n            startPos = buffer.start - parentStart;\r\n        }\r\n        else { // Make it a node\r\n            let endPos = cursor.pos - size;\r\n            cursor.next();\r\n            let localChildren = [], localPositions = [];\r\n            let localInRepeat = id >= minRepeatType ? id : -1;\r\n            let lastGroup = 0, lastEnd = end;\r\n            while (cursor.pos > endPos) {\r\n                if (localInRepeat >= 0 && cursor.id == localInRepeat && cursor.size >= 0) {\r\n                    if (cursor.end <= lastEnd - maxBufferLength) {\r\n                        makeRepeatLeaf(localChildren, localPositions, start, lastGroup, cursor.end, lastEnd, localInRepeat, lookAheadAtStart);\r\n                        lastGroup = localChildren.length;\r\n                        lastEnd = cursor.end;\r\n                    }\r\n                    cursor.next();\r\n                }\r\n                else {\r\n                    takeNode(start, endPos, localChildren, localPositions, localInRepeat);\r\n                }\r\n            }\r\n            if (localInRepeat >= 0 && lastGroup > 0 && lastGroup < localChildren.length)\r\n                makeRepeatLeaf(localChildren, localPositions, start, lastGroup, start, lastEnd, localInRepeat, lookAheadAtStart);\r\n            localChildren.reverse();\r\n            localPositions.reverse();\r\n            if (localInRepeat > -1 && lastGroup > 0) {\r\n                let make = makeBalanced(type);\r\n                node = balanceRange(type, localChildren, localPositions, 0, localChildren.length, 0, end - start, make, make);\r\n            }\r\n            else {\r\n                node = makeTree(type, localChildren, localPositions, end - start, lookAheadAtStart - end);\r\n            }\r\n        }\r\n        children.push(node);\r\n        positions.push(startPos);\r\n    }\r\n    function makeBalanced(type) {\r\n        return (children, positions, length) => {\r\n            let lookAhead = 0, lastI = children.length - 1, last, lookAheadProp;\r\n            if (lastI >= 0 && (last = children[lastI]) instanceof Tree) {\r\n                if (!lastI && last.type == type && last.length == length)\r\n                    return last;\r\n                if (lookAheadProp = last.prop(NodeProp.lookAhead))\r\n                    lookAhead = positions[lastI] + last.length + lookAheadProp;\r\n            }\r\n            return makeTree(type, children, positions, length, lookAhead);\r\n        };\r\n    }\r\n    function makeRepeatLeaf(children, positions, base, i, from, to, type, lookAhead) {\r\n        let localChildren = [], localPositions = [];\r\n        while (children.length > i) {\r\n            localChildren.push(children.pop());\r\n            localPositions.push(positions.pop() + base - from);\r\n        }\r\n        children.push(makeTree(nodeSet.types[type], localChildren, localPositions, to - from, lookAhead - to));\r\n        positions.push(from - base);\r\n    }\r\n    function makeTree(type, children, positions, length, lookAhead = 0, props) {\r\n        if (contextHash) {\r\n            let pair = [NodeProp.contextHash, contextHash];\r\n            props = props ? [pair].concat(props) : [pair];\r\n        }\r\n        if (lookAhead > 25) {\r\n            let pair = [NodeProp.lookAhead, lookAhead];\r\n            props = props ? [pair].concat(props) : [pair];\r\n        }\r\n        return new Tree(type, children, positions, length, props);\r\n    }\r\n    function findBufferSize(maxSize, inRepeat) {\r\n        // Scan through the buffer to find previous siblings that fit\r\n        // together in a TreeBuffer, and don't contain any reused nodes\r\n        // (which can't be stored in a buffer).\r\n        // If `inRepeat` is > -1, ignore node boundaries of that type for\r\n        // nesting, but make sure the end falls either at the start\r\n        // (`maxSize`) or before such a node.\r\n        let fork = cursor.fork();\r\n        let size = 0, start = 0, skip = 0, minStart = fork.end - maxBufferLength;\r\n        let result = { size: 0, start: 0, skip: 0 };\r\n        scan: for (let minPos = fork.pos - maxSize; fork.pos > minPos;) {\r\n            let nodeSize = fork.size;\r\n            // Pretend nested repeat nodes of the same type don't exist\r\n            if (fork.id == inRepeat && nodeSize >= 0) {\r\n                // Except that we store the current state as a valid return\r\n                // value.\r\n                result.size = size;\r\n                result.start = start;\r\n                result.skip = skip;\r\n                skip += 4;\r\n                size += 4;\r\n                fork.next();\r\n                continue;\r\n            }\r\n            let startPos = fork.pos - nodeSize;\r\n            if (nodeSize < 0 || startPos < minPos || fork.start < minStart)\r\n                break;\r\n            let localSkipped = fork.id >= minRepeatType ? 4 : 0;\r\n            let nodeStart = fork.start;\r\n            fork.next();\r\n            while (fork.pos > startPos) {\r\n                if (fork.size < 0) {\r\n                    if (fork.size == -3 /* SpecialRecord.ContextChange */)\r\n                        localSkipped += 4;\r\n                    else\r\n                        break scan;\r\n                }\r\n                else if (fork.id >= minRepeatType) {\r\n                    localSkipped += 4;\r\n                }\r\n                fork.next();\r\n            }\r\n            start = nodeStart;\r\n            size += nodeSize;\r\n            skip += localSkipped;\r\n        }\r\n        if (inRepeat < 0 || size == maxSize) {\r\n            result.size = size;\r\n            result.start = start;\r\n            result.skip = skip;\r\n        }\r\n        return result.size > 4 ? result : undefined;\r\n    }\r\n    function copyToBuffer(bufferStart, buffer, index) {\r\n        let { id, start, end, size } = cursor;\r\n        cursor.next();\r\n        if (size >= 0 && id < minRepeatType) {\r\n            let startIndex = index;\r\n            if (size > 4) {\r\n                let endPos = cursor.pos - (size - 4);\r\n                while (cursor.pos > endPos)\r\n                    index = copyToBuffer(bufferStart, buffer, index);\r\n            }\r\n            buffer[--index] = startIndex;\r\n            buffer[--index] = end - bufferStart;\r\n            buffer[--index] = start - bufferStart;\r\n            buffer[--index] = id;\r\n        }\r\n        else if (size == -3 /* SpecialRecord.ContextChange */) {\r\n            contextHash = id;\r\n        }\r\n        else if (size == -4 /* SpecialRecord.LookAhead */) {\r\n            lookAhead = id;\r\n        }\r\n        return index;\r\n    }\r\n    let children = [], positions = [];\r\n    while (cursor.pos > 0)\r\n        takeNode(data.start || 0, data.bufferStart || 0, children, positions, -1);\r\n    let length = (_a = data.length) !== null && _a !== void 0 ? _a : (children.length ? positions[0] + children[0].length : 0);\r\n    return new Tree(types[data.topID], children.reverse(), positions.reverse(), length);\r\n}\r\nconst nodeSizeCache = new WeakMap;\r\nfunction nodeSize(balanceType, node) {\r\n    if (!balanceType.isAnonymous || node instanceof TreeBuffer || node.type != balanceType)\r\n        return 1;\r\n    let size = nodeSizeCache.get(node);\r\n    if (size == null) {\r\n        size = 1;\r\n        for (let child of node.children) {\r\n            if (child.type != balanceType || !(child instanceof Tree)) {\r\n                size = 1;\r\n                break;\r\n            }\r\n            size += nodeSize(balanceType, child);\r\n        }\r\n        nodeSizeCache.set(node, size);\r\n    }\r\n    return size;\r\n}\r\nfunction balanceRange(\r\n// The type the balanced tree's inner nodes.\r\nbalanceType, \r\n// The direct children and their positions\r\nchildren, positions, \r\n// The index range in children/positions to use\r\nfrom, to, \r\n// The start position of the nodes, relative to their parent.\r\nstart, \r\n// Length of the outer node\r\nlength, \r\n// Function to build the top node of the balanced tree\r\nmkTop, \r\n// Function to build internal nodes for the balanced tree\r\nmkTree) {\r\n    let total = 0;\r\n    for (let i = from; i < to; i++)\r\n        total += nodeSize(balanceType, children[i]);\r\n    let maxChild = Math.ceil((total * 1.5) / 8 /* Balance.BranchFactor */);\r\n    let localChildren = [], localPositions = [];\r\n    function divide(children, positions, from, to, offset) {\r\n        for (let i = from; i < to;) {\r\n            let groupFrom = i, groupStart = positions[i], groupSize = nodeSize(balanceType, children[i]);\r\n            i++;\r\n            for (; i < to; i++) {\r\n                let nextSize = nodeSize(balanceType, children[i]);\r\n                if (groupSize + nextSize >= maxChild)\r\n                    break;\r\n                groupSize += nextSize;\r\n            }\r\n            if (i == groupFrom + 1) {\r\n                if (groupSize > maxChild) {\r\n                    let only = children[groupFrom]; // Only trees can have a size > 1\r\n                    divide(only.children, only.positions, 0, only.children.length, positions[groupFrom] + offset);\r\n                    continue;\r\n                }\r\n                localChildren.push(children[groupFrom]);\r\n            }\r\n            else {\r\n                let length = positions[i - 1] + children[i - 1].length - groupStart;\r\n                localChildren.push(balanceRange(balanceType, children, positions, groupFrom, i, groupStart, length, null, mkTree));\r\n            }\r\n            localPositions.push(groupStart + offset - start);\r\n        }\r\n    }\r\n    divide(children, positions, from, to, 0);\r\n    return (mkTop || mkTree)(localChildren, localPositions, length);\r\n}\r\n/// Provides a way to associate values with pieces of trees. As long\r\n/// as that part of the tree is reused, the associated values can be\r\n/// retrieved from an updated tree.\r\nclass NodeWeakMap {\r\n    constructor() {\r\n        this.map = new WeakMap();\r\n    }\r\n    setBuffer(buffer, index, value) {\r\n        let inner = this.map.get(buffer);\r\n        if (!inner)\r\n            this.map.set(buffer, inner = new Map);\r\n        inner.set(index, value);\r\n    }\r\n    getBuffer(buffer, index) {\r\n        let inner = this.map.get(buffer);\r\n        return inner && inner.get(index);\r\n    }\r\n    /// Set the value for this syntax node.\r\n    set(node, value) {\r\n        if (node instanceof BufferNode)\r\n            this.setBuffer(node.context.buffer, node.index, value);\r\n        else if (node instanceof TreeNode)\r\n            this.map.set(node.tree, value);\r\n    }\r\n    /// Retrieve value for this syntax node, if it exists in the map.\r\n    get(node) {\r\n        return node instanceof BufferNode ? this.getBuffer(node.context.buffer, node.index)\r\n            : node instanceof TreeNode ? this.map.get(node.tree) : undefined;\r\n    }\r\n    /// Set the value for the node that a cursor currently points to.\r\n    cursorSet(cursor, value) {\r\n        if (cursor.buffer)\r\n            this.setBuffer(cursor.buffer.buffer, cursor.index, value);\r\n        else\r\n            this.map.set(cursor.tree, value);\r\n    }\r\n    /// Retrieve the value for the node that a cursor currently points\r\n    /// to.\r\n    cursorGet(cursor) {\r\n        return cursor.buffer ? this.getBuffer(cursor.buffer.buffer, cursor.index) : this.map.get(cursor.tree);\r\n    }\r\n}\r\n\r\n/// Tree fragments are used during [incremental\r\n/// parsing](#common.Parser.startParse) to track parts of old trees\r\n/// that can be reused in a new parse. An array of fragments is used\r\n/// to track regions of an old tree whose nodes might be reused in new\r\n/// parses. Use the static\r\n/// [`applyChanges`](#common.TreeFragment^applyChanges) method to\r\n/// update fragments for document changes.\r\nclass TreeFragment {\r\n    /// Construct a tree fragment. You'll usually want to use\r\n    /// [`addTree`](#common.TreeFragment^addTree) and\r\n    /// [`applyChanges`](#common.TreeFragment^applyChanges) instead of\r\n    /// calling this directly.\r\n    constructor(\r\n    /// The start of the unchanged range pointed to by this fragment.\r\n    /// This refers to an offset in the _updated_ document (as opposed\r\n    /// to the original tree).\r\n    from, \r\n    /// The end of the unchanged range.\r\n    to, \r\n    /// The tree that this fragment is based on.\r\n    tree, \r\n    /// The offset between the fragment's tree and the document that\r\n    /// this fragment can be used against. Add this when going from\r\n    /// document to tree positions, subtract it to go from tree to\r\n    /// document positions.\r\n    offset, openStart = false, openEnd = false) {\r\n        this.from = from;\r\n        this.to = to;\r\n        this.tree = tree;\r\n        this.offset = offset;\r\n        this.open = (openStart ? 1 /* Open.Start */ : 0) | (openEnd ? 2 /* Open.End */ : 0);\r\n    }\r\n    /// Whether the start of the fragment represents the start of a\r\n    /// parse, or the end of a change. (In the second case, it may not\r\n    /// be safe to reuse some nodes at the start, depending on the\r\n    /// parsing algorithm.)\r\n    get openStart() { return (this.open & 1 /* Open.Start */) > 0; }\r\n    /// Whether the end of the fragment represents the end of a\r\n    /// full-document parse, or the start of a change.\r\n    get openEnd() { return (this.open & 2 /* Open.End */) > 0; }\r\n    /// Create a set of fragments from a freshly parsed tree, or update\r\n    /// an existing set of fragments by replacing the ones that overlap\r\n    /// with a tree with content from the new tree. When `partial` is\r\n    /// true, the parse is treated as incomplete, and the resulting\r\n    /// fragment has [`openEnd`](#common.TreeFragment.openEnd) set to\r\n    /// true.\r\n    static addTree(tree, fragments = [], partial = false) {\r\n        let result = [new TreeFragment(0, tree.length, tree, 0, false, partial)];\r\n        for (let f of fragments)\r\n            if (f.to > tree.length)\r\n                result.push(f);\r\n        return result;\r\n    }\r\n    /// Apply a set of edits to an array of fragments, removing or\r\n    /// splitting fragments as necessary to remove edited ranges, and\r\n    /// adjusting offsets for fragments that moved.\r\n    static applyChanges(fragments, changes, minGap = 128) {\r\n        if (!changes.length)\r\n            return fragments;\r\n        let result = [];\r\n        let fI = 1, nextF = fragments.length ? fragments[0] : null;\r\n        for (let cI = 0, pos = 0, off = 0;; cI++) {\r\n            let nextC = cI < changes.length ? changes[cI] : null;\r\n            let nextPos = nextC ? nextC.fromA : 1e9;\r\n            if (nextPos - pos >= minGap)\r\n                while (nextF && nextF.from < nextPos) {\r\n                    let cut = nextF;\r\n                    if (pos >= cut.from || nextPos <= cut.to || off) {\r\n                        let fFrom = Math.max(cut.from, pos) - off, fTo = Math.min(cut.to, nextPos) - off;\r\n                        cut = fFrom >= fTo ? null : new TreeFragment(fFrom, fTo, cut.tree, cut.offset + off, cI > 0, !!nextC);\r\n                    }\r\n                    if (cut)\r\n                        result.push(cut);\r\n                    if (nextF.to > nextPos)\r\n                        break;\r\n                    nextF = fI < fragments.length ? fragments[fI++] : null;\r\n                }\r\n            if (!nextC)\r\n                break;\r\n            pos = nextC.toA;\r\n            off = nextC.toA - nextC.toB;\r\n        }\r\n        return result;\r\n    }\r\n}\r\n/// A superclass that parsers should extend.\r\nclass Parser {\r\n    /// Start a parse, returning a [partial parse](#common.PartialParse)\r\n    /// object. [`fragments`](#common.TreeFragment) can be passed in to\r\n    /// make the parse incremental.\r\n    ///\r\n    /// By default, the entire input is parsed. You can pass `ranges`,\r\n    /// which should be a sorted array of non-empty, non-overlapping\r\n    /// ranges, to parse only those ranges. The tree returned in that\r\n    /// case will start at `ranges[0].from`.\r\n    startParse(input, fragments, ranges) {\r\n        if (typeof input == \"string\")\r\n            input = new StringInput(input);\r\n        ranges = !ranges ? [new Range(0, input.length)] : ranges.length ? ranges.map(r => new Range(r.from, r.to)) : [new Range(0, 0)];\r\n        return this.createParse(input, fragments || [], ranges);\r\n    }\r\n    /// Run a full parse, returning the resulting tree.\r\n    parse(input, fragments, ranges) {\r\n        let parse = this.startParse(input, fragments, ranges);\r\n        for (;;) {\r\n            let done = parse.advance();\r\n            if (done)\r\n                return done;\r\n        }\r\n    }\r\n}\r\nclass StringInput {\r\n    constructor(string) {\r\n        this.string = string;\r\n    }\r\n    get length() { return this.string.length; }\r\n    chunk(from) { return this.string.slice(from); }\r\n    get lineChunks() { return false; }\r\n    read(from, to) { return this.string.slice(from, to); }\r\n}\r\n\r\n/// Create a parse wrapper that, after the inner parse completes,\r\n/// scans its tree for mixed language regions with the `nest`\r\n/// function, runs the resulting [inner parses](#common.NestedParse),\r\n/// and then [mounts](#common.NodeProp^mounted) their results onto the\r\n/// tree.\r\nfunction parseMixed(nest) {\r\n    return (parse, input, fragments, ranges) => new MixedParse(parse, nest, input, fragments, ranges);\r\n}\r\nclass InnerParse {\r\n    constructor(parser, parse, overlay, target, ranges) {\r\n        this.parser = parser;\r\n        this.parse = parse;\r\n        this.overlay = overlay;\r\n        this.target = target;\r\n        this.ranges = ranges;\r\n    }\r\n}\r\nclass ActiveOverlay {\r\n    constructor(parser, predicate, mounts, index, start, target, prev) {\r\n        this.parser = parser;\r\n        this.predicate = predicate;\r\n        this.mounts = mounts;\r\n        this.index = index;\r\n        this.start = start;\r\n        this.target = target;\r\n        this.prev = prev;\r\n        this.depth = 0;\r\n        this.ranges = [];\r\n    }\r\n}\r\nconst stoppedInner = new NodeProp({ perNode: true });\r\nclass MixedParse {\r\n    constructor(base, nest, input, fragments, ranges) {\r\n        this.nest = nest;\r\n        this.input = input;\r\n        this.fragments = fragments;\r\n        this.ranges = ranges;\r\n        this.inner = [];\r\n        this.innerDone = 0;\r\n        this.baseTree = null;\r\n        this.stoppedAt = null;\r\n        this.baseParse = base;\r\n    }\r\n    advance() {\r\n        if (this.baseParse) {\r\n            let done = this.baseParse.advance();\r\n            if (!done)\r\n                return null;\r\n            this.baseParse = null;\r\n            this.baseTree = done;\r\n            this.startInner();\r\n            if (this.stoppedAt != null)\r\n                for (let inner of this.inner)\r\n                    inner.parse.stopAt(this.stoppedAt);\r\n        }\r\n        if (this.innerDone == this.inner.length) {\r\n            let result = this.baseTree;\r\n            if (this.stoppedAt != null)\r\n                result = new Tree(result.type, result.children, result.positions, result.length, result.propValues.concat([[stoppedInner, this.stoppedAt]]));\r\n            return result;\r\n        }\r\n        let inner = this.inner[this.innerDone], done = inner.parse.advance();\r\n        if (done) {\r\n            this.innerDone++;\r\n            // This is a somewhat dodgy but super helpful hack where we\r\n            // patch up nodes created by the inner parse (and thus\r\n            // presumably not aliased anywhere else) to hold the information\r\n            // about the inner parse.\r\n            let props = Object.assign(Object.create(null), inner.target.props);\r\n            props[NodeProp.mounted.id] = new MountedTree(done, inner.overlay, inner.parser);\r\n            inner.target.props = props;\r\n        }\r\n        return null;\r\n    }\r\n    get parsedPos() {\r\n        if (this.baseParse)\r\n            return 0;\r\n        let pos = this.input.length;\r\n        for (let i = this.innerDone; i < this.inner.length; i++) {\r\n            if (this.inner[i].ranges[0].from < pos)\r\n                pos = Math.min(pos, this.inner[i].parse.parsedPos);\r\n        }\r\n        return pos;\r\n    }\r\n    stopAt(pos) {\r\n        this.stoppedAt = pos;\r\n        if (this.baseParse)\r\n            this.baseParse.stopAt(pos);\r\n        else\r\n            for (let i = this.innerDone; i < this.inner.length; i++)\r\n                this.inner[i].parse.stopAt(pos);\r\n    }\r\n    startInner() {\r\n        let fragmentCursor = new FragmentCursor(this.fragments);\r\n        let overlay = null;\r\n        let covered = null;\r\n        let cursor = new TreeCursor(new TreeNode(this.baseTree, this.ranges[0].from, 0, null), IterMode.IncludeAnonymous | IterMode.IgnoreMounts);\r\n        scan: for (let nest, isCovered; this.stoppedAt == null || cursor.from < this.stoppedAt;) {\r\n            let enter = true, range;\r\n            if (fragmentCursor.hasNode(cursor)) {\r\n                if (overlay) {\r\n                    let match = overlay.mounts.find(m => m.frag.from <= cursor.from && m.frag.to >= cursor.to && m.mount.overlay);\r\n                    if (match)\r\n                        for (let r of match.mount.overlay) {\r\n                            let from = r.from + match.pos, to = r.to + match.pos;\r\n                            if (from >= cursor.from && to <= cursor.to && !overlay.ranges.some(r => r.from < to && r.to > from))\r\n                                overlay.ranges.push({ from, to });\r\n                        }\r\n                }\r\n                enter = false;\r\n            }\r\n            else if (covered && (isCovered = checkCover(covered.ranges, cursor.from, cursor.to))) {\r\n                enter = isCovered != 2 /* Cover.Full */;\r\n            }\r\n            else if (!cursor.type.isAnonymous && cursor.from < cursor.to && (nest = this.nest(cursor, this.input))) {\r\n                if (!cursor.tree)\r\n                    materialize(cursor);\r\n                let oldMounts = fragmentCursor.findMounts(cursor.from, nest.parser);\r\n                if (typeof nest.overlay == \"function\") {\r\n                    overlay = new ActiveOverlay(nest.parser, nest.overlay, oldMounts, this.inner.length, cursor.from, cursor.tree, overlay);\r\n                }\r\n                else {\r\n                    let ranges = punchRanges(this.ranges, nest.overlay || [new Range(cursor.from, cursor.to)]);\r\n                    if (ranges.length)\r\n                        this.inner.push(new InnerParse(nest.parser, nest.parser.startParse(this.input, enterFragments(oldMounts, ranges), ranges), nest.overlay ? nest.overlay.map(r => new Range(r.from - cursor.from, r.to - cursor.from)) : null, cursor.tree, ranges));\r\n                    if (!nest.overlay)\r\n                        enter = false;\r\n                    else if (ranges.length)\r\n                        covered = { ranges, depth: 0, prev: covered };\r\n                }\r\n            }\r\n            else if (overlay && (range = overlay.predicate(cursor))) {\r\n                if (range === true)\r\n                    range = new Range(cursor.from, cursor.to);\r\n                if (range.from < range.to)\r\n                    overlay.ranges.push(range);\r\n            }\r\n            if (enter && cursor.firstChild()) {\r\n                if (overlay)\r\n                    overlay.depth++;\r\n                if (covered)\r\n                    covered.depth++;\r\n            }\r\n            else {\r\n                for (;;) {\r\n                    if (cursor.nextSibling())\r\n                        break;\r\n                    if (!cursor.parent())\r\n                        break scan;\r\n                    if (overlay && !--overlay.depth) {\r\n                        let ranges = punchRanges(this.ranges, overlay.ranges);\r\n                        if (ranges.length)\r\n                            this.inner.splice(overlay.index, 0, new InnerParse(overlay.parser, overlay.parser.startParse(this.input, enterFragments(overlay.mounts, ranges), ranges), overlay.ranges.map(r => new Range(r.from - overlay.start, r.to - overlay.start)), overlay.target, ranges));\r\n                        overlay = overlay.prev;\r\n                    }\r\n                    if (covered && !--covered.depth)\r\n                        covered = covered.prev;\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\nfunction checkCover(covered, from, to) {\r\n    for (let range of covered) {\r\n        if (range.from >= to)\r\n            break;\r\n        if (range.to > from)\r\n            return range.from <= from && range.to >= to ? 2 /* Cover.Full */ : 1 /* Cover.Partial */;\r\n    }\r\n    return 0 /* Cover.None */;\r\n}\r\n// Take a piece of buffer and convert it into a stand-alone\r\n// TreeBuffer.\r\nfunction sliceBuf(buf, startI, endI, nodes, positions, off) {\r\n    if (startI < endI) {\r\n        let from = buf.buffer[startI + 1];\r\n        nodes.push(buf.slice(startI, endI, from));\r\n        positions.push(from - off);\r\n    }\r\n}\r\n// This function takes a node that's in a buffer, and converts it, and\r\n// its parent buffer nodes, into a Tree. This is again acting on the\r\n// assumption that the trees and buffers have been constructed by the\r\n// parse that was ran via the mix parser, and thus aren't shared with\r\n// any other code, making violations of the immutability safe.\r\nfunction materialize(cursor) {\r\n    let { node } = cursor, depth = 0;\r\n    // Scan up to the nearest tree\r\n    do {\r\n        cursor.parent();\r\n        depth++;\r\n    } while (!cursor.tree);\r\n    // Find the index of the buffer in that tree\r\n    let i = 0, base = cursor.tree, off = 0;\r\n    for (;; i++) {\r\n        off = base.positions[i] + cursor.from;\r\n        if (off <= node.from && off + base.children[i].length >= node.to)\r\n            break;\r\n    }\r\n    let buf = base.children[i], b = buf.buffer;\r\n    // Split a level in the buffer, putting the nodes before and after\r\n    // the child that contains `node` into new buffers.\r\n    function split(startI, endI, type, innerOffset, length) {\r\n        let i = startI;\r\n        while (b[i + 2] + off <= node.from)\r\n            i = b[i + 3];\r\n        let children = [], positions = [];\r\n        sliceBuf(buf, startI, i, children, positions, innerOffset);\r\n        let from = b[i + 1], to = b[i + 2];\r\n        let isTarget = from + off == node.from && to + off == node.to && b[i] == node.type.id;\r\n        children.push(isTarget ? node.toTree() : split(i + 4, b[i + 3], buf.set.types[b[i]], from, to - from));\r\n        positions.push(from - innerOffset);\r\n        sliceBuf(buf, b[i + 3], endI, children, positions, innerOffset);\r\n        return new Tree(type, children, positions, length);\r\n    }\r\n    base.children[i] = split(0, b.length, NodeType.none, 0, buf.length);\r\n    // Move the cursor back to the target node\r\n    for (let d = 0; d <= depth; d++)\r\n        cursor.childAfter(node.from);\r\n}\r\nclass StructureCursor {\r\n    constructor(root, offset) {\r\n        this.offset = offset;\r\n        this.done = false;\r\n        this.cursor = root.cursor(IterMode.IncludeAnonymous | IterMode.IgnoreMounts);\r\n    }\r\n    // Move to the first node (in pre-order) that starts at or after `pos`.\r\n    moveTo(pos) {\r\n        let { cursor } = this, p = pos - this.offset;\r\n        while (!this.done && cursor.from < p) {\r\n            if (cursor.to >= pos && cursor.enter(p, 1, IterMode.IgnoreOverlays | IterMode.ExcludeBuffers)) ;\r\n            else if (!cursor.next(false))\r\n                this.done = true;\r\n        }\r\n    }\r\n    hasNode(cursor) {\r\n        this.moveTo(cursor.from);\r\n        if (!this.done && this.cursor.from + this.offset == cursor.from && this.cursor.tree) {\r\n            for (let tree = this.cursor.tree;;) {\r\n                if (tree == cursor.tree)\r\n                    return true;\r\n                if (tree.children.length && tree.positions[0] == 0 && tree.children[0] instanceof Tree)\r\n                    tree = tree.children[0];\r\n                else\r\n                    break;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n}\r\nclass FragmentCursor {\r\n    constructor(fragments) {\r\n        var _a;\r\n        this.fragments = fragments;\r\n        this.curTo = 0;\r\n        this.fragI = 0;\r\n        if (fragments.length) {\r\n            let first = this.curFrag = fragments[0];\r\n            this.curTo = (_a = first.tree.prop(stoppedInner)) !== null && _a !== void 0 ? _a : first.to;\r\n            this.inner = new StructureCursor(first.tree, -first.offset);\r\n        }\r\n        else {\r\n            this.curFrag = this.inner = null;\r\n        }\r\n    }\r\n    hasNode(node) {\r\n        while (this.curFrag && node.from >= this.curTo)\r\n            this.nextFrag();\r\n        return this.curFrag && this.curFrag.from <= node.from && this.curTo >= node.to && this.inner.hasNode(node);\r\n    }\r\n    nextFrag() {\r\n        var _a;\r\n        this.fragI++;\r\n        if (this.fragI == this.fragments.length) {\r\n            this.curFrag = this.inner = null;\r\n        }\r\n        else {\r\n            let frag = this.curFrag = this.fragments[this.fragI];\r\n            this.curTo = (_a = frag.tree.prop(stoppedInner)) !== null && _a !== void 0 ? _a : frag.to;\r\n            this.inner = new StructureCursor(frag.tree, -frag.offset);\r\n        }\r\n    }\r\n    findMounts(pos, parser) {\r\n        var _a;\r\n        let result = [];\r\n        if (this.inner) {\r\n            this.inner.cursor.moveTo(pos, 1);\r\n            for (let pos = this.inner.cursor.node; pos; pos = pos.parent) {\r\n                let mount = (_a = pos.tree) === null || _a === void 0 ? void 0 : _a.prop(NodeProp.mounted);\r\n                if (mount && mount.parser == parser) {\r\n                    for (let i = this.fragI; i < this.fragments.length; i++) {\r\n                        let frag = this.fragments[i];\r\n                        if (frag.from >= pos.to)\r\n                            break;\r\n                        if (frag.tree == this.curFrag.tree)\r\n                            result.push({\r\n                                frag,\r\n                                pos: pos.from - frag.offset,\r\n                                mount\r\n                            });\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n}\r\nfunction punchRanges(outer, ranges) {\r\n    let copy = null, current = ranges;\r\n    for (let i = 1, j = 0; i < outer.length; i++) {\r\n        let gapFrom = outer[i - 1].to, gapTo = outer[i].from;\r\n        for (; j < current.length; j++) {\r\n            let r = current[j];\r\n            if (r.from >= gapTo)\r\n                break;\r\n            if (r.to <= gapFrom)\r\n                continue;\r\n            if (!copy)\r\n                current = copy = ranges.slice();\r\n            if (r.from < gapFrom) {\r\n                copy[j] = new Range(r.from, gapFrom);\r\n                if (r.to > gapTo)\r\n                    copy.splice(j + 1, 0, new Range(gapTo, r.to));\r\n            }\r\n            else if (r.to > gapTo) {\r\n                copy[j--] = new Range(gapTo, r.to);\r\n            }\r\n            else {\r\n                copy.splice(j--, 1);\r\n            }\r\n        }\r\n    }\r\n    return current;\r\n}\r\nfunction findCoverChanges(a, b, from, to) {\r\n    let iA = 0, iB = 0, inA = false, inB = false, pos = -1e9;\r\n    let result = [];\r\n    for (;;) {\r\n        let nextA = iA == a.length ? 1e9 : inA ? a[iA].to : a[iA].from;\r\n        let nextB = iB == b.length ? 1e9 : inB ? b[iB].to : b[iB].from;\r\n        if (inA != inB) {\r\n            let start = Math.max(pos, from), end = Math.min(nextA, nextB, to);\r\n            if (start < end)\r\n                result.push(new Range(start, end));\r\n        }\r\n        pos = Math.min(nextA, nextB);\r\n        if (pos == 1e9)\r\n            break;\r\n        if (nextA == pos) {\r\n            if (!inA)\r\n                inA = true;\r\n            else {\r\n                inA = false;\r\n                iA++;\r\n            }\r\n        }\r\n        if (nextB == pos) {\r\n            if (!inB)\r\n                inB = true;\r\n            else {\r\n                inB = false;\r\n                iB++;\r\n            }\r\n        }\r\n    }\r\n    return result;\r\n}\r\n// Given a number of fragments for the outer tree, and a set of ranges\r\n// to parse, find fragments for inner trees mounted around those\r\n// ranges, if any.\r\nfunction enterFragments(mounts, ranges) {\r\n    let result = [];\r\n    for (let { pos, mount, frag } of mounts) {\r\n        let startPos = pos + (mount.overlay ? mount.overlay[0].from : 0), endPos = startPos + mount.tree.length;\r\n        let from = Math.max(frag.from, startPos), to = Math.min(frag.to, endPos);\r\n        if (mount.overlay) {\r\n            let overlay = mount.overlay.map(r => new Range(r.from + pos, r.to + pos));\r\n            let changes = findCoverChanges(ranges, overlay, from, to);\r\n            for (let i = 0, pos = from;; i++) {\r\n                let last = i == changes.length, end = last ? to : changes[i].from;\r\n                if (end > pos)\r\n                    result.push(new TreeFragment(pos, end, mount.tree, -startPos, frag.from >= pos || frag.openStart, frag.to <= end || frag.openEnd));\r\n                if (last)\r\n                    break;\r\n                pos = changes[i].to;\r\n            }\r\n        }\r\n        else {\r\n            result.push(new TreeFragment(from, to, mount.tree, -startPos, frag.from >= startPos || frag.openStart, frag.to <= endPos || frag.openEnd));\r\n        }\r\n    }\r\n    return result;\r\n}\r\n\r\n\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGxlemVyL2NvbW1vbi9kaXN0L2luZGV4LmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLG9DQUFvQztBQUN2RTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsb0NBQW9DO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxvQ0FBb0M7QUFDcEU7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLGVBQWU7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsZUFBZTtBQUNuRDtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsZUFBZTtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBaUUsa0NBQWtDO0FBQ25HO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isa0JBQWtCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQ7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyw0QkFBNEI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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O0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkIsb0RBQW9ELGtCQUFrQjtBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsdUJBQXVCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLFFBQVE7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsT0FBTztBQUNsQztBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0Q7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsS0FBSztBQUN4RDtBQUNBO0FBQ0EsNkNBQTZDLDJCQUEyQjtBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixrQkFBa0I7QUFDN0M7QUFDQSxlQUFlLG9CQUFvQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsbUJBQW1CO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ2dLIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AbGV6ZXIvY29tbW9uL2Rpc3QvaW5kZXguanM/OTJmOSJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBGSVhNRSBwcm9maWxlIGFkZGluZyBhIHBlci1UcmVlIFRyZWVOb2RlIGNhY2hlLCB2YWxpZGF0aW5nIGl0IGJ5XHJcbi8vIHBhcmVudCBwb2ludGVyXHJcbi8vLyBUaGUgZGVmYXVsdCBtYXhpbXVtIGxlbmd0aCBvZiBhIGBUcmVlQnVmZmVyYCBub2RlLlxyXG5jb25zdCBEZWZhdWx0QnVmZmVyTGVuZ3RoID0gMTAyNDtcclxubGV0IG5leHRQcm9wSUQgPSAwO1xyXG5jbGFzcyBSYW5nZSB7XHJcbiAgICBjb25zdHJ1Y3Rvcihmcm9tLCB0bykge1xyXG4gICAgICAgIHRoaXMuZnJvbSA9IGZyb207XHJcbiAgICAgICAgdGhpcy50byA9IHRvO1xyXG4gICAgfVxyXG59XHJcbi8vLyBFYWNoIFtub2RlIHR5cGVdKCNjb21tb24uTm9kZVR5cGUpIG9yIFtpbmRpdmlkdWFsIHRyZWVdKCNjb21tb24uVHJlZSlcclxuLy8vIGNhbiBoYXZlIG1ldGFkYXRhIGFzc29jaWF0ZWQgd2l0aCBpdCBpbiBwcm9wcy4gSW5zdGFuY2VzIG9mIHRoaXNcclxuLy8vIGNsYXNzIHJlcHJlc2VudCBwcm9wIG5hbWVzLlxyXG5jbGFzcyBOb2RlUHJvcCB7XHJcbiAgICAvLy8gQ3JlYXRlIGEgbmV3IG5vZGUgcHJvcCB0eXBlLlxyXG4gICAgY29uc3RydWN0b3IoY29uZmlnID0ge30pIHtcclxuICAgICAgICB0aGlzLmlkID0gbmV4dFByb3BJRCsrO1xyXG4gICAgICAgIHRoaXMucGVyTm9kZSA9ICEhY29uZmlnLnBlck5vZGU7XHJcbiAgICAgICAgdGhpcy5kZXNlcmlhbGl6ZSA9IGNvbmZpZy5kZXNlcmlhbGl6ZSB8fCAoKCkgPT4ge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGlzIG5vZGUgdHlwZSBkb2Vzbid0IGRlZmluZSBhIGRlc2VyaWFsaXplIGZ1bmN0aW9uXCIpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgLy8vIFRoaXMgaXMgbWVhbnQgdG8gYmUgdXNlZCB3aXRoXHJcbiAgICAvLy8gW2BOb2RlU2V0LmV4dGVuZGBdKCNjb21tb24uTm9kZVNldC5leHRlbmQpIG9yXHJcbiAgICAvLy8gW2BMUlBhcnNlci5jb25maWd1cmVgXSgjbHIuUGFyc2VyQ29uZmlnLnByb3BzKSB0byBjb21wdXRlXHJcbiAgICAvLy8gcHJvcCB2YWx1ZXMgZm9yIGVhY2ggbm9kZSB0eXBlIGluIHRoZSBzZXQuIFRha2VzIGEgW21hdGNoXHJcbiAgICAvLy8gb2JqZWN0XSgjY29tbW9uLk5vZGVUeXBlXm1hdGNoKSBvciBmdW5jdGlvbiB0aGF0IHJldHVybnMgdW5kZWZpbmVkXHJcbiAgICAvLy8gaWYgdGhlIG5vZGUgdHlwZSBkb2Vzbid0IGdldCB0aGlzIHByb3AsIGFuZCB0aGUgcHJvcCdzIHZhbHVlIGlmXHJcbiAgICAvLy8gaXQgZG9lcy5cclxuICAgIGFkZChtYXRjaCkge1xyXG4gICAgICAgIGlmICh0aGlzLnBlck5vZGUpXHJcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiQ2FuJ3QgYWRkIHBlci1ub2RlIHByb3BzIHRvIG5vZGUgdHlwZXNcIik7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBtYXRjaCAhPSBcImZ1bmN0aW9uXCIpXHJcbiAgICAgICAgICAgIG1hdGNoID0gTm9kZVR5cGUubWF0Y2gobWF0Y2gpO1xyXG4gICAgICAgIHJldHVybiAodHlwZSkgPT4ge1xyXG4gICAgICAgICAgICBsZXQgcmVzdWx0ID0gbWF0Y2godHlwZSk7XHJcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQgPT09IHVuZGVmaW5lZCA/IG51bGwgOiBbdGhpcywgcmVzdWx0XTtcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG59XHJcbi8vLyBQcm9wIHRoYXQgaXMgdXNlZCB0byBkZXNjcmliZSBtYXRjaGluZyBkZWxpbWl0ZXJzLiBGb3Igb3BlbmluZ1xyXG4vLy8gZGVsaW1pdGVycywgdGhpcyBob2xkcyBhbiBhcnJheSBvZiBub2RlIG5hbWVzICh3cml0dGVuIGFzIGFcclxuLy8vIHNwYWNlLXNlcGFyYXRlZCBzdHJpbmcgd2hlbiBkZWNsYXJpbmcgdGhpcyBwcm9wIGluIGEgZ3JhbW1hcilcclxuLy8vIGZvciB0aGUgbm9kZSB0eXBlcyBvZiBjbG9zaW5nIGRlbGltaXRlcnMgdGhhdCBtYXRjaCBpdC5cclxuTm9kZVByb3AuY2xvc2VkQnkgPSBuZXcgTm9kZVByb3AoeyBkZXNlcmlhbGl6ZTogc3RyID0+IHN0ci5zcGxpdChcIiBcIikgfSk7XHJcbi8vLyBUaGUgaW52ZXJzZSBvZiBbYGNsb3NlZEJ5YF0oI2NvbW1vbi5Ob2RlUHJvcF5jbG9zZWRCeSkuIFRoaXMgaXNcclxuLy8vIGF0dGFjaGVkIHRvIGNsb3NpbmcgZGVsaW1pdGVycywgaG9sZGluZyBhbiBhcnJheSBvZiBub2RlIG5hbWVzXHJcbi8vLyBvZiB0eXBlcyBvZiBtYXRjaGluZyBvcGVuaW5nIGRlbGltaXRlcnMuXHJcbk5vZGVQcm9wLm9wZW5lZEJ5ID0gbmV3IE5vZGVQcm9wKHsgZGVzZXJpYWxpemU6IHN0ciA9PiBzdHIuc3BsaXQoXCIgXCIpIH0pO1xyXG4vLy8gVXNlZCB0byBhc3NpZ24gbm9kZSB0eXBlcyB0byBncm91cHMgKGZvciBleGFtcGxlLCBhbGwgbm9kZVxyXG4vLy8gdHlwZXMgdGhhdCByZXByZXNlbnQgYW4gZXhwcmVzc2lvbiBjb3VsZCBiZSB0YWdnZWQgd2l0aCBhblxyXG4vLy8gYFwiRXhwcmVzc2lvblwiYCBncm91cCkuXHJcbk5vZGVQcm9wLmdyb3VwID0gbmV3IE5vZGVQcm9wKHsgZGVzZXJpYWxpemU6IHN0ciA9PiBzdHIuc3BsaXQoXCIgXCIpIH0pO1xyXG4vLy8gVGhlIGhhc2ggb2YgdGhlIFtjb250ZXh0XSgjbHIuQ29udGV4dFRyYWNrZXIuY29uc3RydWN0b3IpXHJcbi8vLyB0aGF0IHRoZSBub2RlIHdhcyBwYXJzZWQgaW4sIGlmIGFueS4gVXNlZCB0byBsaW1pdCByZXVzZSBvZlxyXG4vLy8gY29udGV4dHVhbCBub2Rlcy5cclxuTm9kZVByb3AuY29udGV4dEhhc2ggPSBuZXcgTm9kZVByb3AoeyBwZXJOb2RlOiB0cnVlIH0pO1xyXG4vLy8gVGhlIGRpc3RhbmNlIGJleW9uZCB0aGUgZW5kIG9mIHRoZSBub2RlIHRoYXQgdGhlIHRva2VuaXplclxyXG4vLy8gbG9va2VkIGFoZWFkIGZvciBhbnkgb2YgdGhlIHRva2VucyBpbnNpZGUgdGhlIG5vZGUuIChUaGUgTFJcclxuLy8vIHBhcnNlciBvbmx5IHN0b3JlcyB0aGlzIHdoZW4gaXQgaXMgbGFyZ2VyIHRoYW4gMjUsIGZvclxyXG4vLy8gZWZmaWNpZW5jeSByZWFzb25zLilcclxuTm9kZVByb3AubG9va0FoZWFkID0gbmV3IE5vZGVQcm9wKHsgcGVyTm9kZTogdHJ1ZSB9KTtcclxuLy8vIFRoaXMgcGVyLW5vZGUgcHJvcCBpcyB1c2VkIHRvIHJlcGxhY2UgYSBnaXZlbiBub2RlLCBvciBwYXJ0IG9mIGFcclxuLy8vIG5vZGUsIHdpdGggYW5vdGhlciB0cmVlLiBUaGlzIGlzIHVzZWZ1bCB0byBpbmNsdWRlIHRyZWVzIGZyb21cclxuLy8vIGRpZmZlcmVudCBsYW5ndWFnZXMgaW4gbWl4ZWQtbGFuZ3VhZ2UgcGFyc2Vycy5cclxuTm9kZVByb3AubW91bnRlZCA9IG5ldyBOb2RlUHJvcCh7IHBlck5vZGU6IHRydWUgfSk7XHJcbi8vLyBBIG1vdW50ZWQgdHJlZSwgd2hpY2ggY2FuIGJlIFtzdG9yZWRdKCNjb21tb24uTm9kZVByb3BebW91bnRlZCkgb25cclxuLy8vIGEgdHJlZSBub2RlIHRvIGluZGljYXRlIHRoYXQgcGFydHMgb2YgaXRzIGNvbnRlbnQgYXJlXHJcbi8vLyByZXByZXNlbnRlZCBieSBhbm90aGVyIHRyZWUuXHJcbmNsYXNzIE1vdW50ZWRUcmVlIHtcclxuICAgIGNvbnN0cnVjdG9yKFxyXG4gICAgLy8vIFRoZSBpbm5lciB0cmVlLlxyXG4gICAgdHJlZSwgXHJcbiAgICAvLy8gSWYgdGhpcyBpcyBudWxsLCB0aGlzIHRyZWUgcmVwbGFjZXMgdGhlIGVudGlyZSBub2RlIChpdCB3aWxsXHJcbiAgICAvLy8gYmUgaW5jbHVkZWQgaW4gdGhlIHJlZ3VsYXIgaXRlcmF0aW9uIGluc3RlYWQgb2YgaXRzIGhvc3RcclxuICAgIC8vLyBub2RlKS4gSWYgbm90LCBvbmx5IHRoZSBnaXZlbiByYW5nZXMgYXJlIGNvbnNpZGVyZWQgdG8gYmVcclxuICAgIC8vLyBjb3ZlcmVkIGJ5IHRoaXMgdHJlZS4gVGhpcyBpcyB1c2VkIGZvciB0cmVlcyB0aGF0IGFyZSBtaXhlZCBpblxyXG4gICAgLy8vIGEgd2F5IHRoYXQgaXNuJ3Qgc3RyaWN0bHkgaGllcmFyY2hpY2FsLiBTdWNoIG1vdW50ZWQgdHJlZXMgYXJlXHJcbiAgICAvLy8gb25seSBlbnRlcmVkIGJ5IFtgcmVzb2x2ZUlubmVyYF0oI2NvbW1vbi5UcmVlLnJlc29sdmVJbm5lcilcclxuICAgIC8vLyBhbmQgW2BlbnRlcmBdKCNjb21tb24uU3ludGF4Tm9kZS5lbnRlcikuXHJcbiAgICBvdmVybGF5LCBcclxuICAgIC8vLyBUaGUgcGFyc2VyIHVzZWQgdG8gY3JlYXRlIHRoaXMgc3VidHJlZS5cclxuICAgIHBhcnNlcikge1xyXG4gICAgICAgIHRoaXMudHJlZSA9IHRyZWU7XHJcbiAgICAgICAgdGhpcy5vdmVybGF5ID0gb3ZlcmxheTtcclxuICAgICAgICB0aGlzLnBhcnNlciA9IHBhcnNlcjtcclxuICAgIH1cclxufVxyXG5jb25zdCBub1Byb3BzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcclxuLy8vIEVhY2ggbm9kZSBpbiBhIHN5bnRheCB0cmVlIGhhcyBhIG5vZGUgdHlwZSBhc3NvY2lhdGVkIHdpdGggaXQuXHJcbmNsYXNzIE5vZGVUeXBlIHtcclxuICAgIC8vLyBAaW50ZXJuYWxcclxuICAgIGNvbnN0cnVjdG9yKFxyXG4gICAgLy8vIFRoZSBuYW1lIG9mIHRoZSBub2RlIHR5cGUuIE5vdCBuZWNlc3NhcmlseSB1bmlxdWUsIGJ1dCBpZiB0aGVcclxuICAgIC8vLyBncmFtbWFyIHdhcyB3cml0dGVuIHByb3Blcmx5LCBkaWZmZXJlbnQgbm9kZSB0eXBlcyB3aXRoIHRoZVxyXG4gICAgLy8vIHNhbWUgbmFtZSB3aXRoaW4gYSBub2RlIHNldCBzaG91bGQgcGxheSB0aGUgc2FtZSBzZW1hbnRpY1xyXG4gICAgLy8vIHJvbGUuXHJcbiAgICBuYW1lLCBcclxuICAgIC8vLyBAaW50ZXJuYWxcclxuICAgIHByb3BzLCBcclxuICAgIC8vLyBUaGUgaWQgb2YgdGhpcyBub2RlIGluIGl0cyBzZXQuIENvcnJlc3BvbmRzIHRvIHRoZSB0ZXJtIGlkc1xyXG4gICAgLy8vIHVzZWQgaW4gdGhlIHBhcnNlci5cclxuICAgIGlkLCBcclxuICAgIC8vLyBAaW50ZXJuYWxcclxuICAgIGZsYWdzID0gMCkge1xyXG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XHJcbiAgICAgICAgdGhpcy5wcm9wcyA9IHByb3BzO1xyXG4gICAgICAgIHRoaXMuaWQgPSBpZDtcclxuICAgICAgICB0aGlzLmZsYWdzID0gZmxhZ3M7XHJcbiAgICB9XHJcbiAgICAvLy8gRGVmaW5lIGEgbm9kZSB0eXBlLlxyXG4gICAgc3RhdGljIGRlZmluZShzcGVjKSB7XHJcbiAgICAgICAgbGV0IHByb3BzID0gc3BlYy5wcm9wcyAmJiBzcGVjLnByb3BzLmxlbmd0aCA/IE9iamVjdC5jcmVhdGUobnVsbCkgOiBub1Byb3BzO1xyXG4gICAgICAgIGxldCBmbGFncyA9IChzcGVjLnRvcCA/IDEgLyogTm9kZUZsYWcuVG9wICovIDogMCkgfCAoc3BlYy5za2lwcGVkID8gMiAvKiBOb2RlRmxhZy5Ta2lwcGVkICovIDogMCkgfFxyXG4gICAgICAgICAgICAoc3BlYy5lcnJvciA/IDQgLyogTm9kZUZsYWcuRXJyb3IgKi8gOiAwKSB8IChzcGVjLm5hbWUgPT0gbnVsbCA/IDggLyogTm9kZUZsYWcuQW5vbnltb3VzICovIDogMCk7XHJcbiAgICAgICAgbGV0IHR5cGUgPSBuZXcgTm9kZVR5cGUoc3BlYy5uYW1lIHx8IFwiXCIsIHByb3BzLCBzcGVjLmlkLCBmbGFncyk7XHJcbiAgICAgICAgaWYgKHNwZWMucHJvcHMpXHJcbiAgICAgICAgICAgIGZvciAobGV0IHNyYyBvZiBzcGVjLnByb3BzKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoc3JjKSlcclxuICAgICAgICAgICAgICAgICAgICBzcmMgPSBzcmModHlwZSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoc3JjKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNyY1swXS5wZXJOb2RlKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkNhbid0IHN0b3JlIGEgcGVyLW5vZGUgcHJvcCBvbiBhIG5vZGUgdHlwZVwiKTtcclxuICAgICAgICAgICAgICAgICAgICBwcm9wc1tzcmNbMF0uaWRdID0gc3JjWzFdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHR5cGU7XHJcbiAgICB9XHJcbiAgICAvLy8gUmV0cmlldmVzIGEgbm9kZSBwcm9wIGZvciB0aGlzIHR5cGUuIFdpbGwgcmV0dXJuIGB1bmRlZmluZWRgIGlmXHJcbiAgICAvLy8gdGhlIHByb3AgaXNuJ3QgcHJlc2VudCBvbiB0aGlzIG5vZGUuXHJcbiAgICBwcm9wKHByb3ApIHsgcmV0dXJuIHRoaXMucHJvcHNbcHJvcC5pZF07IH1cclxuICAgIC8vLyBUcnVlIHdoZW4gdGhpcyBpcyB0aGUgdG9wIG5vZGUgb2YgYSBncmFtbWFyLlxyXG4gICAgZ2V0IGlzVG9wKCkgeyByZXR1cm4gKHRoaXMuZmxhZ3MgJiAxIC8qIE5vZGVGbGFnLlRvcCAqLykgPiAwOyB9XHJcbiAgICAvLy8gVHJ1ZSB3aGVuIHRoaXMgbm9kZSBpcyBwcm9kdWNlZCBieSBhIHNraXAgcnVsZS5cclxuICAgIGdldCBpc1NraXBwZWQoKSB7IHJldHVybiAodGhpcy5mbGFncyAmIDIgLyogTm9kZUZsYWcuU2tpcHBlZCAqLykgPiAwOyB9XHJcbiAgICAvLy8gSW5kaWNhdGVzIHdoZXRoZXIgdGhpcyBpcyBhbiBlcnJvciBub2RlLlxyXG4gICAgZ2V0IGlzRXJyb3IoKSB7IHJldHVybiAodGhpcy5mbGFncyAmIDQgLyogTm9kZUZsYWcuRXJyb3IgKi8pID4gMDsgfVxyXG4gICAgLy8vIFdoZW4gdHJ1ZSwgdGhpcyBub2RlIHR5cGUgZG9lc24ndCBjb3JyZXNwb25kIHRvIGEgdXNlci1kZWNsYXJlZFxyXG4gICAgLy8vIG5hbWVkIG5vZGUsIGZvciBleGFtcGxlIGJlY2F1c2UgaXQgaXMgdXNlZCB0byBjYWNoZSByZXBldGl0aW9uLlxyXG4gICAgZ2V0IGlzQW5vbnltb3VzKCkgeyByZXR1cm4gKHRoaXMuZmxhZ3MgJiA4IC8qIE5vZGVGbGFnLkFub255bW91cyAqLykgPiAwOyB9XHJcbiAgICAvLy8gUmV0dXJucyB0cnVlIHdoZW4gdGhpcyBub2RlJ3MgbmFtZSBvciBvbmUgb2YgaXRzXHJcbiAgICAvLy8gW2dyb3Vwc10oI2NvbW1vbi5Ob2RlUHJvcF5ncm91cCkgbWF0Y2hlcyB0aGUgZ2l2ZW4gc3RyaW5nLlxyXG4gICAgaXMobmFtZSkge1xyXG4gICAgICAgIGlmICh0eXBlb2YgbmFtZSA9PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5uYW1lID09IG5hbWUpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgbGV0IGdyb3VwID0gdGhpcy5wcm9wKE5vZGVQcm9wLmdyb3VwKTtcclxuICAgICAgICAgICAgcmV0dXJuIGdyb3VwID8gZ3JvdXAuaW5kZXhPZihuYW1lKSA+IC0xIDogZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLmlkID09IG5hbWU7XHJcbiAgICB9XHJcbiAgICAvLy8gQ3JlYXRlIGEgZnVuY3Rpb24gZnJvbSBub2RlIHR5cGVzIHRvIGFyYml0cmFyeSB2YWx1ZXMgYnlcclxuICAgIC8vLyBzcGVjaWZ5aW5nIGFuIG9iamVjdCB3aG9zZSBwcm9wZXJ0eSBuYW1lcyBhcmUgbm9kZSBvclxyXG4gICAgLy8vIFtncm91cF0oI2NvbW1vbi5Ob2RlUHJvcF5ncm91cCkgbmFtZXMuIE9mdGVuIHVzZWZ1bCB3aXRoXHJcbiAgICAvLy8gW2BOb2RlUHJvcC5hZGRgXSgjY29tbW9uLk5vZGVQcm9wLmFkZCkuIFlvdSBjYW4gcHV0IG11bHRpcGxlXHJcbiAgICAvLy8gbmFtZXMsIHNlcGFyYXRlZCBieSBzcGFjZXMsIGluIGEgc2luZ2xlIHByb3BlcnR5IG5hbWUgdG8gbWFwXHJcbiAgICAvLy8gbXVsdGlwbGUgbm9kZSBuYW1lcyB0byBhIHNpbmdsZSB2YWx1ZS5cclxuICAgIHN0YXRpYyBtYXRjaChtYXApIHtcclxuICAgICAgICBsZXQgZGlyZWN0ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcclxuICAgICAgICBmb3IgKGxldCBwcm9wIGluIG1hcClcclxuICAgICAgICAgICAgZm9yIChsZXQgbmFtZSBvZiBwcm9wLnNwbGl0KFwiIFwiKSlcclxuICAgICAgICAgICAgICAgIGRpcmVjdFtuYW1lXSA9IG1hcFtwcm9wXTtcclxuICAgICAgICByZXR1cm4gKG5vZGUpID0+IHtcclxuICAgICAgICAgICAgZm9yIChsZXQgZ3JvdXBzID0gbm9kZS5wcm9wKE5vZGVQcm9wLmdyb3VwKSwgaSA9IC0xOyBpIDwgKGdyb3VwcyA/IGdyb3Vwcy5sZW5ndGggOiAwKTsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgZm91bmQgPSBkaXJlY3RbaSA8IDAgPyBub2RlLm5hbWUgOiBncm91cHNbaV1dO1xyXG4gICAgICAgICAgICAgICAgaWYgKGZvdW5kKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmb3VuZDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbn1cclxuLy8vIEFuIGVtcHR5IGR1bW15IG5vZGUgdHlwZSB0byB1c2Ugd2hlbiBubyBhY3R1YWwgdHlwZSBpcyBhdmFpbGFibGUuXHJcbk5vZGVUeXBlLm5vbmUgPSBuZXcgTm9kZVR5cGUoXCJcIiwgT2JqZWN0LmNyZWF0ZShudWxsKSwgMCwgOCAvKiBOb2RlRmxhZy5Bbm9ueW1vdXMgKi8pO1xyXG4vLy8gQSBub2RlIHNldCBob2xkcyBhIGNvbGxlY3Rpb24gb2Ygbm9kZSB0eXBlcy4gSXQgaXMgdXNlZCB0b1xyXG4vLy8gY29tcGFjdGx5IHJlcHJlc2VudCB0cmVlcyBieSBzdG9yaW5nIHRoZWlyIHR5cGUgaWRzLCByYXRoZXIgdGhhbiBhXHJcbi8vLyBmdWxsIHBvaW50ZXIgdG8gdGhlIHR5cGUgb2JqZWN0LCBpbiBhIG51bWVyaWMgYXJyYXkuIEVhY2ggcGFyc2VyXHJcbi8vLyBbaGFzXSgjbHIuTFJQYXJzZXIubm9kZVNldCkgYSBub2RlIHNldCwgYW5kIFt0cmVlXHJcbi8vLyBidWZmZXJzXSgjY29tbW9uLlRyZWVCdWZmZXIpIGNhbiBvbmx5IHN0b3JlIGNvbGxlY3Rpb25zIG9mIG5vZGVzXHJcbi8vLyBmcm9tIHRoZSBzYW1lIHNldC4gQSBzZXQgY2FuIGhhdmUgYSBtYXhpbXVtIG9mIDIqKjE2ICg2NTUzNikgbm9kZVxyXG4vLy8gdHlwZXMgaW4gaXQsIHNvIHRoYXQgdGhlIGlkcyBmaXQgaW50byAxNi1iaXQgdHlwZWQgYXJyYXkgc2xvdHMuXHJcbmNsYXNzIE5vZGVTZXQge1xyXG4gICAgLy8vIENyZWF0ZSBhIHNldCB3aXRoIHRoZSBnaXZlbiB0eXBlcy4gVGhlIGBpZGAgcHJvcGVydHkgb2YgZWFjaFxyXG4gICAgLy8vIHR5cGUgc2hvdWxkIGNvcnJlc3BvbmQgdG8gaXRzIHBvc2l0aW9uIHdpdGhpbiB0aGUgYXJyYXkuXHJcbiAgICBjb25zdHJ1Y3RvcihcclxuICAgIC8vLyBUaGUgbm9kZSB0eXBlcyBpbiB0aGlzIHNldCwgYnkgaWQuXHJcbiAgICB0eXBlcykge1xyXG4gICAgICAgIHRoaXMudHlwZXMgPSB0eXBlcztcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHR5cGVzLmxlbmd0aDsgaSsrKVxyXG4gICAgICAgICAgICBpZiAodHlwZXNbaV0uaWQgIT0gaSlcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiTm9kZSB0eXBlIGlkcyBzaG91bGQgY29ycmVzcG9uZCB0byBhcnJheSBwb3NpdGlvbnMgd2hlbiBjcmVhdGluZyBhIG5vZGUgc2V0XCIpO1xyXG4gICAgfVxyXG4gICAgLy8vIENyZWF0ZSBhIGNvcHkgb2YgdGhpcyBzZXQgd2l0aCBzb21lIG5vZGUgcHJvcGVydGllcyBhZGRlZC4gVGhlXHJcbiAgICAvLy8gYXJndW1lbnRzIHRvIHRoaXMgbWV0aG9kIGNhbiBiZSBjcmVhdGVkIHdpdGhcclxuICAgIC8vLyBbYE5vZGVQcm9wLmFkZGBdKCNjb21tb24uTm9kZVByb3AuYWRkKS5cclxuICAgIGV4dGVuZCguLi5wcm9wcykge1xyXG4gICAgICAgIGxldCBuZXdUeXBlcyA9IFtdO1xyXG4gICAgICAgIGZvciAobGV0IHR5cGUgb2YgdGhpcy50eXBlcykge1xyXG4gICAgICAgICAgICBsZXQgbmV3UHJvcHMgPSBudWxsO1xyXG4gICAgICAgICAgICBmb3IgKGxldCBzb3VyY2Ugb2YgcHJvcHMpIHtcclxuICAgICAgICAgICAgICAgIGxldCBhZGQgPSBzb3VyY2UodHlwZSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoYWRkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFuZXdQcm9wcylcclxuICAgICAgICAgICAgICAgICAgICAgICAgbmV3UHJvcHMgPSBPYmplY3QuYXNzaWduKHt9LCB0eXBlLnByb3BzKTtcclxuICAgICAgICAgICAgICAgICAgICBuZXdQcm9wc1thZGRbMF0uaWRdID0gYWRkWzFdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIG5ld1R5cGVzLnB1c2gobmV3UHJvcHMgPyBuZXcgTm9kZVR5cGUodHlwZS5uYW1lLCBuZXdQcm9wcywgdHlwZS5pZCwgdHlwZS5mbGFncykgOiB0eXBlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5ldyBOb2RlU2V0KG5ld1R5cGVzKTtcclxuICAgIH1cclxufVxyXG5jb25zdCBDYWNoZWROb2RlID0gbmV3IFdlYWtNYXAoKSwgQ2FjaGVkSW5uZXJOb2RlID0gbmV3IFdlYWtNYXAoKTtcclxuLy8vIE9wdGlvbnMgdGhhdCBjb250cm9sIGl0ZXJhdGlvbi4gQ2FuIGJlIGNvbWJpbmVkIHdpdGggdGhlIGB8YFxyXG4vLy8gb3BlcmF0b3IgdG8gZW5hYmxlIG11bHRpcGxlIG9uZXMuXHJcbnZhciBJdGVyTW9kZTtcclxuKGZ1bmN0aW9uIChJdGVyTW9kZSkge1xyXG4gICAgLy8vIFdoZW4gZW5hYmxlZCwgaXRlcmF0aW9uIHdpbGwgb25seSB2aXNpdCBbYFRyZWVgXSgjY29tbW9uLlRyZWUpXHJcbiAgICAvLy8gb2JqZWN0cywgbm90IG5vZGVzIHBhY2tlZCBpbnRvXHJcbiAgICAvLy8gW2BUcmVlQnVmZmVyYF0oI2NvbW1vbi5UcmVlQnVmZmVyKXMuXHJcbiAgICBJdGVyTW9kZVtJdGVyTW9kZVtcIkV4Y2x1ZGVCdWZmZXJzXCJdID0gMV0gPSBcIkV4Y2x1ZGVCdWZmZXJzXCI7XHJcbiAgICAvLy8gRW5hYmxlIHRoaXMgdG8gbWFrZSBpdGVyYXRpb24gaW5jbHVkZSBhbm9ueW1vdXMgbm9kZXMgKHN1Y2ggYXNcclxuICAgIC8vLyB0aGUgbm9kZXMgdGhhdCB3cmFwIHJlcGVhdGVkIGdyYW1tYXIgY29uc3RydWN0cyBpbnRvIGEgYmFsYW5jZWRcclxuICAgIC8vLyB0cmVlKS5cclxuICAgIEl0ZXJNb2RlW0l0ZXJNb2RlW1wiSW5jbHVkZUFub255bW91c1wiXSA9IDJdID0gXCJJbmNsdWRlQW5vbnltb3VzXCI7XHJcbiAgICAvLy8gQnkgZGVmYXVsdCwgcmVndWxhciBbbW91bnRlZF0oI2NvbW1vbi5Ob2RlUHJvcF5tb3VudGVkKSBub2Rlc1xyXG4gICAgLy8vIHJlcGxhY2UgdGhlaXIgYmFzZSBub2RlIGluIGl0ZXJhdGlvbi4gRW5hYmxlIHRoaXMgdG8gaWdub3JlIHRoZW1cclxuICAgIC8vLyBpbnN0ZWFkLlxyXG4gICAgSXRlck1vZGVbSXRlck1vZGVbXCJJZ25vcmVNb3VudHNcIl0gPSA0XSA9IFwiSWdub3JlTW91bnRzXCI7XHJcbiAgICAvLy8gVGhpcyBvcHRpb24gb25seSBhcHBsaWVzIGluXHJcbiAgICAvLy8gW2BlbnRlcmBdKCNjb21tb24uU3ludGF4Tm9kZS5lbnRlciktc3R5bGUgbWV0aG9kcy4gSXQgdGVsbHMgdGhlXHJcbiAgICAvLy8gbGlicmFyeSB0byBub3QgZW50ZXIgbW91bnRlZCBvdmVybGF5cyBpZiBvbmUgY292ZXJzIHRoZSBnaXZlblxyXG4gICAgLy8vIHBvc2l0aW9uLlxyXG4gICAgSXRlck1vZGVbSXRlck1vZGVbXCJJZ25vcmVPdmVybGF5c1wiXSA9IDhdID0gXCJJZ25vcmVPdmVybGF5c1wiO1xyXG59KShJdGVyTW9kZSB8fCAoSXRlck1vZGUgPSB7fSkpO1xyXG4vLy8gQSBwaWVjZSBvZiBzeW50YXggdHJlZS4gVGhlcmUgYXJlIHR3byB3YXlzIHRvIGFwcHJvYWNoIHRoZXNlXHJcbi8vLyB0cmVlczogdGhlIHdheSB0aGV5IGFyZSBhY3R1YWxseSBzdG9yZWQgaW4gbWVtb3J5LCBhbmQgdGhlXHJcbi8vLyBjb252ZW5pZW50IHdheS5cclxuLy8vXHJcbi8vLyBTeW50YXggdHJlZXMgYXJlIHN0b3JlZCBhcyBhIHRyZWUgb2YgYFRyZWVgIGFuZCBgVHJlZUJ1ZmZlcmBcclxuLy8vIG9iamVjdHMuIEJ5IHBhY2tpbmcgZGV0YWlsIGluZm9ybWF0aW9uIGludG8gYFRyZWVCdWZmZXJgIGxlYWZcclxuLy8vIG5vZGVzLCB0aGUgcmVwcmVzZW50YXRpb24gaXMgbWFkZSBhIGxvdCBtb3JlIG1lbW9yeS1lZmZpY2llbnQuXHJcbi8vL1xyXG4vLy8gSG93ZXZlciwgd2hlbiB5b3Ugd2FudCB0byBhY3R1YWxseSB3b3JrIHdpdGggdHJlZSBub2RlcywgdGhpc1xyXG4vLy8gcmVwcmVzZW50YXRpb24gaXMgdmVyeSBhd2t3YXJkLCBzbyBtb3N0IGNsaWVudCBjb2RlIHdpbGwgd2FudCB0b1xyXG4vLy8gdXNlIHRoZSBbYFRyZWVDdXJzb3JgXSgjY29tbW9uLlRyZWVDdXJzb3IpIG9yXHJcbi8vLyBbYFN5bnRheE5vZGVgXSgjY29tbW9uLlN5bnRheE5vZGUpIGludGVyZmFjZSBpbnN0ZWFkLCB3aGljaCBwcm92aWRlc1xyXG4vLy8gYSB2aWV3IG9uIHNvbWUgcGFydCBvZiB0aGlzIGRhdGEgc3RydWN0dXJlLCBhbmQgY2FuIGJlIHVzZWQgdG9cclxuLy8vIG1vdmUgYXJvdW5kIHRvIGFkamFjZW50IG5vZGVzLlxyXG5jbGFzcyBUcmVlIHtcclxuICAgIC8vLyBDb25zdHJ1Y3QgYSBuZXcgdHJlZS4gU2VlIGFsc28gW2BUcmVlLmJ1aWxkYF0oI2NvbW1vbi5UcmVlXmJ1aWxkKS5cclxuICAgIGNvbnN0cnVjdG9yKFxyXG4gICAgLy8vIFRoZSB0eXBlIG9mIHRoZSB0b3Agbm9kZS5cclxuICAgIHR5cGUsIFxyXG4gICAgLy8vIFRoaXMgbm9kZSdzIGNoaWxkIG5vZGVzLlxyXG4gICAgY2hpbGRyZW4sIFxyXG4gICAgLy8vIFRoZSBwb3NpdGlvbnMgKG9mZnNldHMgcmVsYXRpdmUgdG8gdGhlIHN0YXJ0IG9mIHRoaXMgdHJlZSkgb2ZcclxuICAgIC8vLyB0aGUgY2hpbGRyZW4uXHJcbiAgICBwb3NpdGlvbnMsIFxyXG4gICAgLy8vIFRoZSB0b3RhbCBsZW5ndGggb2YgdGhpcyB0cmVlXHJcbiAgICBsZW5ndGgsIFxyXG4gICAgLy8vIFBlci1ub2RlIFtub2RlIHByb3BzXSgjY29tbW9uLk5vZGVQcm9wKSB0byBhc3NvY2lhdGUgd2l0aCB0aGlzIG5vZGUuXHJcbiAgICBwcm9wcykge1xyXG4gICAgICAgIHRoaXMudHlwZSA9IHR5cGU7XHJcbiAgICAgICAgdGhpcy5jaGlsZHJlbiA9IGNoaWxkcmVuO1xyXG4gICAgICAgIHRoaXMucG9zaXRpb25zID0gcG9zaXRpb25zO1xyXG4gICAgICAgIHRoaXMubGVuZ3RoID0gbGVuZ3RoO1xyXG4gICAgICAgIC8vLyBAaW50ZXJuYWxcclxuICAgICAgICB0aGlzLnByb3BzID0gbnVsbDtcclxuICAgICAgICBpZiAocHJvcHMgJiYgcHJvcHMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHRoaXMucHJvcHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xyXG4gICAgICAgICAgICBmb3IgKGxldCBbcHJvcCwgdmFsdWVdIG9mIHByb3BzKVxyXG4gICAgICAgICAgICAgICAgdGhpcy5wcm9wc1t0eXBlb2YgcHJvcCA9PSBcIm51bWJlclwiID8gcHJvcCA6IHByb3AuaWRdID0gdmFsdWU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLy8vIEBpbnRlcm5hbFxyXG4gICAgdG9TdHJpbmcoKSB7XHJcbiAgICAgICAgbGV0IG1vdW50ZWQgPSB0aGlzLnByb3AoTm9kZVByb3AubW91bnRlZCk7XHJcbiAgICAgICAgaWYgKG1vdW50ZWQgJiYgIW1vdW50ZWQub3ZlcmxheSlcclxuICAgICAgICAgICAgcmV0dXJuIG1vdW50ZWQudHJlZS50b1N0cmluZygpO1xyXG4gICAgICAgIGxldCBjaGlsZHJlbiA9IFwiXCI7XHJcbiAgICAgICAgZm9yIChsZXQgY2ggb2YgdGhpcy5jaGlsZHJlbikge1xyXG4gICAgICAgICAgICBsZXQgc3RyID0gY2gudG9TdHJpbmcoKTtcclxuICAgICAgICAgICAgaWYgKHN0cikge1xyXG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkcmVuKVxyXG4gICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuICs9IFwiLFwiO1xyXG4gICAgICAgICAgICAgICAgY2hpbGRyZW4gKz0gc3RyO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiAhdGhpcy50eXBlLm5hbWUgPyBjaGlsZHJlbiA6XHJcbiAgICAgICAgICAgICgvXFxXLy50ZXN0KHRoaXMudHlwZS5uYW1lKSAmJiAhdGhpcy50eXBlLmlzRXJyb3IgPyBKU09OLnN0cmluZ2lmeSh0aGlzLnR5cGUubmFtZSkgOiB0aGlzLnR5cGUubmFtZSkgK1xyXG4gICAgICAgICAgICAgICAgKGNoaWxkcmVuLmxlbmd0aCA/IFwiKFwiICsgY2hpbGRyZW4gKyBcIilcIiA6IFwiXCIpO1xyXG4gICAgfVxyXG4gICAgLy8vIEdldCBhIFt0cmVlIGN1cnNvcl0oI2NvbW1vbi5UcmVlQ3Vyc29yKSBwb3NpdGlvbmVkIGF0IHRoZSB0b3Agb2ZcclxuICAgIC8vLyB0aGUgdHJlZS4gTW9kZSBjYW4gYmUgdXNlZCB0byBbY29udHJvbF0oI2NvbW1vbi5JdGVyTW9kZSkgd2hpY2hcclxuICAgIC8vLyBub2RlcyB0aGUgY3Vyc29yIHZpc2l0cy5cclxuICAgIGN1cnNvcihtb2RlID0gMCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgVHJlZUN1cnNvcih0aGlzLnRvcE5vZGUsIG1vZGUpO1xyXG4gICAgfVxyXG4gICAgLy8vIEdldCBhIFt0cmVlIGN1cnNvcl0oI2NvbW1vbi5UcmVlQ3Vyc29yKSBwb2ludGluZyBpbnRvIHRoaXMgdHJlZVxyXG4gICAgLy8vIGF0IHRoZSBnaXZlbiBwb3NpdGlvbiBhbmQgc2lkZSAoc2VlXHJcbiAgICAvLy8gW2Btb3ZlVG9gXSgjY29tbW9uLlRyZWVDdXJzb3IubW92ZVRvKS5cclxuICAgIGN1cnNvckF0KHBvcywgc2lkZSA9IDAsIG1vZGUgPSAwKSB7XHJcbiAgICAgICAgbGV0IHNjb3BlID0gQ2FjaGVkTm9kZS5nZXQodGhpcykgfHwgdGhpcy50b3BOb2RlO1xyXG4gICAgICAgIGxldCBjdXJzb3IgPSBuZXcgVHJlZUN1cnNvcihzY29wZSk7XHJcbiAgICAgICAgY3Vyc29yLm1vdmVUbyhwb3MsIHNpZGUpO1xyXG4gICAgICAgIENhY2hlZE5vZGUuc2V0KHRoaXMsIGN1cnNvci5fdHJlZSk7XHJcbiAgICAgICAgcmV0dXJuIGN1cnNvcjtcclxuICAgIH1cclxuICAgIC8vLyBHZXQgYSBbc3ludGF4IG5vZGVdKCNjb21tb24uU3ludGF4Tm9kZSkgb2JqZWN0IGZvciB0aGUgdG9wIG9mIHRoZVxyXG4gICAgLy8vIHRyZWUuXHJcbiAgICBnZXQgdG9wTm9kZSgpIHtcclxuICAgICAgICByZXR1cm4gbmV3IFRyZWVOb2RlKHRoaXMsIDAsIDAsIG51bGwpO1xyXG4gICAgfVxyXG4gICAgLy8vIEdldCB0aGUgW3N5bnRheCBub2RlXSgjY29tbW9uLlN5bnRheE5vZGUpIGF0IHRoZSBnaXZlbiBwb3NpdGlvbi5cclxuICAgIC8vLyBJZiBgc2lkZWAgaXMgLTEsIHRoaXMgd2lsbCBtb3ZlIGludG8gbm9kZXMgdGhhdCBlbmQgYXQgdGhlXHJcbiAgICAvLy8gcG9zaXRpb24uIElmIDEsIGl0J2xsIG1vdmUgaW50byBub2RlcyB0aGF0IHN0YXJ0IGF0IHRoZVxyXG4gICAgLy8vIHBvc2l0aW9uLiBXaXRoIDAsIGl0J2xsIG9ubHkgZW50ZXIgbm9kZXMgdGhhdCBjb3ZlciB0aGUgcG9zaXRpb25cclxuICAgIC8vLyBmcm9tIGJvdGggc2lkZXMuXHJcbiAgICAvLy9cclxuICAgIC8vLyBOb3RlIHRoYXQgdGhpcyB3aWxsIG5vdCBlbnRlclxyXG4gICAgLy8vIFtvdmVybGF5c10oI2NvbW1vbi5Nb3VudGVkVHJlZS5vdmVybGF5KSwgYW5kIHlvdSBvZnRlbiB3YW50XHJcbiAgICAvLy8gW2ByZXNvbHZlSW5uZXJgXSgjY29tbW9uLlRyZWUucmVzb2x2ZUlubmVyKSBpbnN0ZWFkLlxyXG4gICAgcmVzb2x2ZShwb3MsIHNpZGUgPSAwKSB7XHJcbiAgICAgICAgbGV0IG5vZGUgPSByZXNvbHZlTm9kZShDYWNoZWROb2RlLmdldCh0aGlzKSB8fCB0aGlzLnRvcE5vZGUsIHBvcywgc2lkZSwgZmFsc2UpO1xyXG4gICAgICAgIENhY2hlZE5vZGUuc2V0KHRoaXMsIG5vZGUpO1xyXG4gICAgICAgIHJldHVybiBub2RlO1xyXG4gICAgfVxyXG4gICAgLy8vIExpa2UgW2ByZXNvbHZlYF0oI2NvbW1vbi5UcmVlLnJlc29sdmUpLCBidXQgd2lsbCBlbnRlclxyXG4gICAgLy8vIFtvdmVybGFpZF0oI2NvbW1vbi5Nb3VudGVkVHJlZS5vdmVybGF5KSBub2RlcywgcHJvZHVjaW5nIGEgc3ludGF4IG5vZGVcclxuICAgIC8vLyBwb2ludGluZyBpbnRvIHRoZSBpbm5lcm1vc3Qgb3ZlcmxhaWQgdHJlZSBhdCB0aGUgZ2l2ZW4gcG9zaXRpb25cclxuICAgIC8vLyAod2l0aCBwYXJlbnQgbGlua3MgZ29pbmcgdGhyb3VnaCBhbGwgcGFyZW50IHN0cnVjdHVyZSwgaW5jbHVkaW5nXHJcbiAgICAvLy8gdGhlIGhvc3QgdHJlZXMpLlxyXG4gICAgcmVzb2x2ZUlubmVyKHBvcywgc2lkZSA9IDApIHtcclxuICAgICAgICBsZXQgbm9kZSA9IHJlc29sdmVOb2RlKENhY2hlZElubmVyTm9kZS5nZXQodGhpcykgfHwgdGhpcy50b3BOb2RlLCBwb3MsIHNpZGUsIHRydWUpO1xyXG4gICAgICAgIENhY2hlZElubmVyTm9kZS5zZXQodGhpcywgbm9kZSk7XHJcbiAgICAgICAgcmV0dXJuIG5vZGU7XHJcbiAgICB9XHJcbiAgICAvLy8gSXRlcmF0ZSBvdmVyIHRoZSB0cmVlIGFuZCBpdHMgY2hpbGRyZW4sIGNhbGxpbmcgYGVudGVyYCBmb3IgYW55XHJcbiAgICAvLy8gbm9kZSB0aGF0IHRvdWNoZXMgdGhlIGBmcm9tYC9gdG9gIHJlZ2lvbiAoaWYgZ2l2ZW4pIGJlZm9yZVxyXG4gICAgLy8vIHJ1bm5pbmcgb3ZlciBzdWNoIGEgbm9kZSdzIGNoaWxkcmVuLCBhbmQgYGxlYXZlYCAoaWYgZ2l2ZW4pIHdoZW5cclxuICAgIC8vLyBsZWF2aW5nIHRoZSBub2RlLiBXaGVuIGBlbnRlcmAgcmV0dXJucyBgZmFsc2VgLCB0aGF0IG5vZGUgd2lsbFxyXG4gICAgLy8vIG5vdCBoYXZlIGl0cyBjaGlsZHJlbiBpdGVyYXRlZCBvdmVyIChvciBgbGVhdmVgIGNhbGxlZCkuXHJcbiAgICBpdGVyYXRlKHNwZWMpIHtcclxuICAgICAgICBsZXQgeyBlbnRlciwgbGVhdmUsIGZyb20gPSAwLCB0byA9IHRoaXMubGVuZ3RoIH0gPSBzcGVjO1xyXG4gICAgICAgIGZvciAobGV0IGMgPSB0aGlzLmN1cnNvcigoc3BlYy5tb2RlIHx8IDApIHwgSXRlck1vZGUuSW5jbHVkZUFub255bW91cyk7Oykge1xyXG4gICAgICAgICAgICBsZXQgZW50ZXJlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICBpZiAoYy5mcm9tIDw9IHRvICYmIGMudG8gPj0gZnJvbSAmJiAoYy50eXBlLmlzQW5vbnltb3VzIHx8IGVudGVyKGMpICE9PSBmYWxzZSkpIHtcclxuICAgICAgICAgICAgICAgIGlmIChjLmZpcnN0Q2hpbGQoKSlcclxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIGVudGVyZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGZvciAoOzspIHtcclxuICAgICAgICAgICAgICAgIGlmIChlbnRlcmVkICYmIGxlYXZlICYmICFjLnR5cGUuaXNBbm9ueW1vdXMpXHJcbiAgICAgICAgICAgICAgICAgICAgbGVhdmUoYyk7XHJcbiAgICAgICAgICAgICAgICBpZiAoYy5uZXh0U2libGluZygpKVxyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFjLnBhcmVudCgpKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIGVudGVyZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLy8vIEdldCB0aGUgdmFsdWUgb2YgdGhlIGdpdmVuIFtub2RlIHByb3BdKCNjb21tb24uTm9kZVByb3ApIGZvciB0aGlzXHJcbiAgICAvLy8gbm9kZS4gV29ya3Mgd2l0aCBib3RoIHBlci1ub2RlIGFuZCBwZXItdHlwZSBwcm9wcy5cclxuICAgIHByb3AocHJvcCkge1xyXG4gICAgICAgIHJldHVybiAhcHJvcC5wZXJOb2RlID8gdGhpcy50eXBlLnByb3AocHJvcCkgOiB0aGlzLnByb3BzID8gdGhpcy5wcm9wc1twcm9wLmlkXSA6IHVuZGVmaW5lZDtcclxuICAgIH1cclxuICAgIC8vLyBSZXR1cm5zIHRoZSBub2RlJ3MgW3Blci1ub2RlIHByb3BzXSgjY29tbW9uLk5vZGVQcm9wLnBlck5vZGUpIGluIGFcclxuICAgIC8vLyBmb3JtYXQgdGhhdCBjYW4gYmUgcGFzc2VkIHRvIHRoZSBbYFRyZWVgXSgjY29tbW9uLlRyZWUpXHJcbiAgICAvLy8gY29uc3RydWN0b3IuXHJcbiAgICBnZXQgcHJvcFZhbHVlcygpIHtcclxuICAgICAgICBsZXQgcmVzdWx0ID0gW107XHJcbiAgICAgICAgaWYgKHRoaXMucHJvcHMpXHJcbiAgICAgICAgICAgIGZvciAobGV0IGlkIGluIHRoaXMucHJvcHMpXHJcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChbK2lkLCB0aGlzLnByb3BzW2lkXV0pO1xyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcbiAgICAvLy8gQmFsYW5jZSB0aGUgZGlyZWN0IGNoaWxkcmVuIG9mIHRoaXMgdHJlZSwgcHJvZHVjaW5nIGEgY29weSBvZlxyXG4gICAgLy8vIHdoaWNoIG1heSBoYXZlIGNoaWxkcmVuIGdyb3VwZWQgaW50byBzdWJ0cmVlcyB3aXRoIHR5cGVcclxuICAgIC8vLyBbYE5vZGVUeXBlLm5vbmVgXSgjY29tbW9uLk5vZGVUeXBlXm5vbmUpLlxyXG4gICAgYmFsYW5jZShjb25maWcgPSB7fSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNoaWxkcmVuLmxlbmd0aCA8PSA4IC8qIEJhbGFuY2UuQnJhbmNoRmFjdG9yICovID8gdGhpcyA6XHJcbiAgICAgICAgICAgIGJhbGFuY2VSYW5nZShOb2RlVHlwZS5ub25lLCB0aGlzLmNoaWxkcmVuLCB0aGlzLnBvc2l0aW9ucywgMCwgdGhpcy5jaGlsZHJlbi5sZW5ndGgsIDAsIHRoaXMubGVuZ3RoLCAoY2hpbGRyZW4sIHBvc2l0aW9ucywgbGVuZ3RoKSA9PiBuZXcgVHJlZSh0aGlzLnR5cGUsIGNoaWxkcmVuLCBwb3NpdGlvbnMsIGxlbmd0aCwgdGhpcy5wcm9wVmFsdWVzKSwgY29uZmlnLm1ha2VUcmVlIHx8ICgoY2hpbGRyZW4sIHBvc2l0aW9ucywgbGVuZ3RoKSA9PiBuZXcgVHJlZShOb2RlVHlwZS5ub25lLCBjaGlsZHJlbiwgcG9zaXRpb25zLCBsZW5ndGgpKSk7XHJcbiAgICB9XHJcbiAgICAvLy8gQnVpbGQgYSB0cmVlIGZyb20gYSBwb3N0Zml4LW9yZGVyZWQgYnVmZmVyIG9mIG5vZGUgaW5mb3JtYXRpb24sXHJcbiAgICAvLy8gb3IgYSBjdXJzb3Igb3ZlciBzdWNoIGEgYnVmZmVyLlxyXG4gICAgc3RhdGljIGJ1aWxkKGRhdGEpIHsgcmV0dXJuIGJ1aWxkVHJlZShkYXRhKTsgfVxyXG59XHJcbi8vLyBUaGUgZW1wdHkgdHJlZVxyXG5UcmVlLmVtcHR5ID0gbmV3IFRyZWUoTm9kZVR5cGUubm9uZSwgW10sIFtdLCAwKTtcclxuY2xhc3MgRmxhdEJ1ZmZlckN1cnNvciB7XHJcbiAgICBjb25zdHJ1Y3RvcihidWZmZXIsIGluZGV4KSB7XHJcbiAgICAgICAgdGhpcy5idWZmZXIgPSBidWZmZXI7XHJcbiAgICAgICAgdGhpcy5pbmRleCA9IGluZGV4O1xyXG4gICAgfVxyXG4gICAgZ2V0IGlkKCkgeyByZXR1cm4gdGhpcy5idWZmZXJbdGhpcy5pbmRleCAtIDRdOyB9XHJcbiAgICBnZXQgc3RhcnQoKSB7IHJldHVybiB0aGlzLmJ1ZmZlclt0aGlzLmluZGV4IC0gM107IH1cclxuICAgIGdldCBlbmQoKSB7IHJldHVybiB0aGlzLmJ1ZmZlclt0aGlzLmluZGV4IC0gMl07IH1cclxuICAgIGdldCBzaXplKCkgeyByZXR1cm4gdGhpcy5idWZmZXJbdGhpcy5pbmRleCAtIDFdOyB9XHJcbiAgICBnZXQgcG9zKCkgeyByZXR1cm4gdGhpcy5pbmRleDsgfVxyXG4gICAgbmV4dCgpIHsgdGhpcy5pbmRleCAtPSA0OyB9XHJcbiAgICBmb3JrKCkgeyByZXR1cm4gbmV3IEZsYXRCdWZmZXJDdXJzb3IodGhpcy5idWZmZXIsIHRoaXMuaW5kZXgpOyB9XHJcbn1cclxuLy8vIFRyZWUgYnVmZmVycyBjb250YWluICh0eXBlLCBzdGFydCwgZW5kLCBlbmRJbmRleCkgcXVhZHMgZm9yIGVhY2hcclxuLy8vIG5vZGUuIEluIHN1Y2ggYSBidWZmZXIsIG5vZGVzIGFyZSBzdG9yZWQgaW4gcHJlZml4IG9yZGVyIChwYXJlbnRzXHJcbi8vLyBiZWZvcmUgY2hpbGRyZW4sIHdpdGggdGhlIGVuZEluZGV4IG9mIHRoZSBwYXJlbnQgaW5kaWNhdGluZyB3aGljaFxyXG4vLy8gY2hpbGRyZW4gYmVsb25nIHRvIGl0KS5cclxuY2xhc3MgVHJlZUJ1ZmZlciB7XHJcbiAgICAvLy8gQ3JlYXRlIGEgdHJlZSBidWZmZXIuXHJcbiAgICBjb25zdHJ1Y3RvcihcclxuICAgIC8vLyBUaGUgYnVmZmVyJ3MgY29udGVudC5cclxuICAgIGJ1ZmZlciwgXHJcbiAgICAvLy8gVGhlIHRvdGFsIGxlbmd0aCBvZiB0aGUgZ3JvdXAgb2Ygbm9kZXMgaW4gdGhlIGJ1ZmZlci5cclxuICAgIGxlbmd0aCwgXHJcbiAgICAvLy8gVGhlIG5vZGUgc2V0IHVzZWQgaW4gdGhpcyBidWZmZXIuXHJcbiAgICBzZXQpIHtcclxuICAgICAgICB0aGlzLmJ1ZmZlciA9IGJ1ZmZlcjtcclxuICAgICAgICB0aGlzLmxlbmd0aCA9IGxlbmd0aDtcclxuICAgICAgICB0aGlzLnNldCA9IHNldDtcclxuICAgIH1cclxuICAgIC8vLyBAaW50ZXJuYWxcclxuICAgIGdldCB0eXBlKCkgeyByZXR1cm4gTm9kZVR5cGUubm9uZTsgfVxyXG4gICAgLy8vIEBpbnRlcm5hbFxyXG4gICAgdG9TdHJpbmcoKSB7XHJcbiAgICAgICAgbGV0IHJlc3VsdCA9IFtdO1xyXG4gICAgICAgIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCB0aGlzLmJ1ZmZlci5sZW5ndGg7KSB7XHJcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKHRoaXMuY2hpbGRTdHJpbmcoaW5kZXgpKTtcclxuICAgICAgICAgICAgaW5kZXggPSB0aGlzLmJ1ZmZlcltpbmRleCArIDNdO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzdWx0LmpvaW4oXCIsXCIpO1xyXG4gICAgfVxyXG4gICAgLy8vIEBpbnRlcm5hbFxyXG4gICAgY2hpbGRTdHJpbmcoaW5kZXgpIHtcclxuICAgICAgICBsZXQgaWQgPSB0aGlzLmJ1ZmZlcltpbmRleF0sIGVuZEluZGV4ID0gdGhpcy5idWZmZXJbaW5kZXggKyAzXTtcclxuICAgICAgICBsZXQgdHlwZSA9IHRoaXMuc2V0LnR5cGVzW2lkXSwgcmVzdWx0ID0gdHlwZS5uYW1lO1xyXG4gICAgICAgIGlmICgvXFxXLy50ZXN0KHJlc3VsdCkgJiYgIXR5cGUuaXNFcnJvcilcclxuICAgICAgICAgICAgcmVzdWx0ID0gSlNPTi5zdHJpbmdpZnkocmVzdWx0KTtcclxuICAgICAgICBpbmRleCArPSA0O1xyXG4gICAgICAgIGlmIChlbmRJbmRleCA9PSBpbmRleClcclxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICBsZXQgY2hpbGRyZW4gPSBbXTtcclxuICAgICAgICB3aGlsZSAoaW5kZXggPCBlbmRJbmRleCkge1xyXG4gICAgICAgICAgICBjaGlsZHJlbi5wdXNoKHRoaXMuY2hpbGRTdHJpbmcoaW5kZXgpKTtcclxuICAgICAgICAgICAgaW5kZXggPSB0aGlzLmJ1ZmZlcltpbmRleCArIDNdO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzdWx0ICsgXCIoXCIgKyBjaGlsZHJlbi5qb2luKFwiLFwiKSArIFwiKVwiO1xyXG4gICAgfVxyXG4gICAgLy8vIEBpbnRlcm5hbFxyXG4gICAgZmluZENoaWxkKHN0YXJ0SW5kZXgsIGVuZEluZGV4LCBkaXIsIHBvcywgc2lkZSkge1xyXG4gICAgICAgIGxldCB7IGJ1ZmZlciB9ID0gdGhpcywgcGljayA9IC0xO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSBzdGFydEluZGV4OyBpICE9IGVuZEluZGV4OyBpID0gYnVmZmVyW2kgKyAzXSkge1xyXG4gICAgICAgICAgICBpZiAoY2hlY2tTaWRlKHNpZGUsIHBvcywgYnVmZmVyW2kgKyAxXSwgYnVmZmVyW2kgKyAyXSkpIHtcclxuICAgICAgICAgICAgICAgIHBpY2sgPSBpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGRpciA+IDApXHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHBpY2s7XHJcbiAgICB9XHJcbiAgICAvLy8gQGludGVybmFsXHJcbiAgICBzbGljZShzdGFydEksIGVuZEksIGZyb20pIHtcclxuICAgICAgICBsZXQgYiA9IHRoaXMuYnVmZmVyO1xyXG4gICAgICAgIGxldCBjb3B5ID0gbmV3IFVpbnQxNkFycmF5KGVuZEkgLSBzdGFydEkpLCBsZW4gPSAwO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSBzdGFydEksIGogPSAwOyBpIDwgZW5kSTspIHtcclxuICAgICAgICAgICAgY29weVtqKytdID0gYltpKytdO1xyXG4gICAgICAgICAgICBjb3B5W2orK10gPSBiW2krK10gLSBmcm9tO1xyXG4gICAgICAgICAgICBsZXQgdG8gPSBjb3B5W2orK10gPSBiW2krK10gLSBmcm9tO1xyXG4gICAgICAgICAgICBjb3B5W2orK10gPSBiW2krK10gLSBzdGFydEk7XHJcbiAgICAgICAgICAgIGxlbiA9IE1hdGgubWF4KGxlbiwgdG8pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbmV3IFRyZWVCdWZmZXIoY29weSwgbGVuLCB0aGlzLnNldCk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gY2hlY2tTaWRlKHNpZGUsIHBvcywgZnJvbSwgdG8pIHtcclxuICAgIHN3aXRjaCAoc2lkZSkge1xyXG4gICAgICAgIGNhc2UgLTIgLyogU2lkZS5CZWZvcmUgKi86IHJldHVybiBmcm9tIDwgcG9zO1xyXG4gICAgICAgIGNhc2UgLTEgLyogU2lkZS5BdE9yQmVmb3JlICovOiByZXR1cm4gdG8gPj0gcG9zICYmIGZyb20gPCBwb3M7XHJcbiAgICAgICAgY2FzZSAwIC8qIFNpZGUuQXJvdW5kICovOiByZXR1cm4gZnJvbSA8IHBvcyAmJiB0byA+IHBvcztcclxuICAgICAgICBjYXNlIDEgLyogU2lkZS5BdE9yQWZ0ZXIgKi86IHJldHVybiBmcm9tIDw9IHBvcyAmJiB0byA+IHBvcztcclxuICAgICAgICBjYXNlIDIgLyogU2lkZS5BZnRlciAqLzogcmV0dXJuIHRvID4gcG9zO1xyXG4gICAgICAgIGNhc2UgNCAvKiBTaWRlLkRvbnRDYXJlICovOiByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBlbnRlclVuZmluaXNoZWROb2Rlc0JlZm9yZShub2RlLCBwb3MpIHtcclxuICAgIGxldCBzY2FuID0gbm9kZS5jaGlsZEJlZm9yZShwb3MpO1xyXG4gICAgd2hpbGUgKHNjYW4pIHtcclxuICAgICAgICBsZXQgbGFzdCA9IHNjYW4ubGFzdENoaWxkO1xyXG4gICAgICAgIGlmICghbGFzdCB8fCBsYXN0LnRvICE9IHNjYW4udG8pXHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGlmIChsYXN0LnR5cGUuaXNFcnJvciAmJiBsYXN0LmZyb20gPT0gbGFzdC50bykge1xyXG4gICAgICAgICAgICBub2RlID0gc2NhbjtcclxuICAgICAgICAgICAgc2NhbiA9IGxhc3QucHJldlNpYmxpbmc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBzY2FuID0gbGFzdDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbm9kZTtcclxufVxyXG5mdW5jdGlvbiByZXNvbHZlTm9kZShub2RlLCBwb3MsIHNpZGUsIG92ZXJsYXlzKSB7XHJcbiAgICB2YXIgX2E7XHJcbiAgICAvLyBNb3ZlIHVwIHRvIGEgbm9kZSB0aGF0IGFjdHVhbGx5IGhvbGRzIHRoZSBwb3NpdGlvbiwgaWYgcG9zc2libGVcclxuICAgIHdoaWxlIChub2RlLmZyb20gPT0gbm9kZS50byB8fFxyXG4gICAgICAgIChzaWRlIDwgMSA/IG5vZGUuZnJvbSA+PSBwb3MgOiBub2RlLmZyb20gPiBwb3MpIHx8XHJcbiAgICAgICAgKHNpZGUgPiAtMSA/IG5vZGUudG8gPD0gcG9zIDogbm9kZS50byA8IHBvcykpIHtcclxuICAgICAgICBsZXQgcGFyZW50ID0gIW92ZXJsYXlzICYmIG5vZGUgaW5zdGFuY2VvZiBUcmVlTm9kZSAmJiBub2RlLmluZGV4IDwgMCA/IG51bGwgOiBub2RlLnBhcmVudDtcclxuICAgICAgICBpZiAoIXBhcmVudClcclxuICAgICAgICAgICAgcmV0dXJuIG5vZGU7XHJcbiAgICAgICAgbm9kZSA9IHBhcmVudDtcclxuICAgIH1cclxuICAgIGxldCBtb2RlID0gb3ZlcmxheXMgPyAwIDogSXRlck1vZGUuSWdub3JlT3ZlcmxheXM7XHJcbiAgICAvLyBNdXN0IGdvIHVwIG91dCBvZiBvdmVybGF5cyB3aGVuIHRob3NlIGRvIG5vdCBvdmVybGFwIHdpdGggcG9zXHJcbiAgICBpZiAob3ZlcmxheXMpXHJcbiAgICAgICAgZm9yIChsZXQgc2NhbiA9IG5vZGUsIHBhcmVudCA9IHNjYW4ucGFyZW50OyBwYXJlbnQ7IHNjYW4gPSBwYXJlbnQsIHBhcmVudCA9IHNjYW4ucGFyZW50KSB7XHJcbiAgICAgICAgICAgIGlmIChzY2FuIGluc3RhbmNlb2YgVHJlZU5vZGUgJiYgc2Nhbi5pbmRleCA8IDAgJiYgKChfYSA9IHBhcmVudC5lbnRlcihwb3MsIHNpZGUsIG1vZGUpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZnJvbSkgIT0gc2Nhbi5mcm9tKVxyXG4gICAgICAgICAgICAgICAgbm9kZSA9IHBhcmVudDtcclxuICAgICAgICB9XHJcbiAgICBmb3IgKDs7KSB7XHJcbiAgICAgICAgbGV0IGlubmVyID0gbm9kZS5lbnRlcihwb3MsIHNpZGUsIG1vZGUpO1xyXG4gICAgICAgIGlmICghaW5uZXIpXHJcbiAgICAgICAgICAgIHJldHVybiBub2RlO1xyXG4gICAgICAgIG5vZGUgPSBpbm5lcjtcclxuICAgIH1cclxufVxyXG5jbGFzcyBUcmVlTm9kZSB7XHJcbiAgICBjb25zdHJ1Y3RvcihfdHJlZSwgZnJvbSwgXHJcbiAgICAvLyBJbmRleCBpbiBwYXJlbnQgbm9kZSwgc2V0IHRvIC0xIGlmIHRoZSBub2RlIGlzIG5vdCBhIGRpcmVjdCBjaGlsZCBvZiBfcGFyZW50Lm5vZGUgKG92ZXJsYXkpXHJcbiAgICBpbmRleCwgX3BhcmVudCkge1xyXG4gICAgICAgIHRoaXMuX3RyZWUgPSBfdHJlZTtcclxuICAgICAgICB0aGlzLmZyb20gPSBmcm9tO1xyXG4gICAgICAgIHRoaXMuaW5kZXggPSBpbmRleDtcclxuICAgICAgICB0aGlzLl9wYXJlbnQgPSBfcGFyZW50O1xyXG4gICAgfVxyXG4gICAgZ2V0IHR5cGUoKSB7IHJldHVybiB0aGlzLl90cmVlLnR5cGU7IH1cclxuICAgIGdldCBuYW1lKCkgeyByZXR1cm4gdGhpcy5fdHJlZS50eXBlLm5hbWU7IH1cclxuICAgIGdldCB0bygpIHsgcmV0dXJuIHRoaXMuZnJvbSArIHRoaXMuX3RyZWUubGVuZ3RoOyB9XHJcbiAgICBuZXh0Q2hpbGQoaSwgZGlyLCBwb3MsIHNpZGUsIG1vZGUgPSAwKSB7XHJcbiAgICAgICAgZm9yIChsZXQgcGFyZW50ID0gdGhpczs7KSB7XHJcbiAgICAgICAgICAgIGZvciAobGV0IHsgY2hpbGRyZW4sIHBvc2l0aW9ucyB9ID0gcGFyZW50Ll90cmVlLCBlID0gZGlyID4gMCA/IGNoaWxkcmVuLmxlbmd0aCA6IC0xOyBpICE9IGU7IGkgKz0gZGlyKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgbmV4dCA9IGNoaWxkcmVuW2ldLCBzdGFydCA9IHBvc2l0aW9uc1tpXSArIHBhcmVudC5mcm9tO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFjaGVja1NpZGUoc2lkZSwgcG9zLCBzdGFydCwgc3RhcnQgKyBuZXh0Lmxlbmd0aCkpXHJcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICBpZiAobmV4dCBpbnN0YW5jZW9mIFRyZWVCdWZmZXIpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAobW9kZSAmIEl0ZXJNb2RlLkV4Y2x1ZGVCdWZmZXJzKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgaW5kZXggPSBuZXh0LmZpbmRDaGlsZCgwLCBuZXh0LmJ1ZmZlci5sZW5ndGgsIGRpciwgcG9zIC0gc3RhcnQsIHNpZGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpbmRleCA+IC0xKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEJ1ZmZlck5vZGUobmV3IEJ1ZmZlckNvbnRleHQocGFyZW50LCBuZXh0LCBpLCBzdGFydCksIG51bGwsIGluZGV4KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKChtb2RlICYgSXRlck1vZGUuSW5jbHVkZUFub255bW91cykgfHwgKCFuZXh0LnR5cGUuaXNBbm9ueW1vdXMgfHwgaGFzQ2hpbGQobmV4dCkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IG1vdW50ZWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEobW9kZSAmIEl0ZXJNb2RlLklnbm9yZU1vdW50cykgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dC5wcm9wcyAmJiAobW91bnRlZCA9IG5leHQucHJvcChOb2RlUHJvcC5tb3VudGVkKSkgJiYgIW1vdW50ZWQub3ZlcmxheSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBUcmVlTm9kZShtb3VudGVkLnRyZWUsIHN0YXJ0LCBpLCBwYXJlbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBpbm5lciA9IG5ldyBUcmVlTm9kZShuZXh0LCBzdGFydCwgaSwgcGFyZW50KTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKG1vZGUgJiBJdGVyTW9kZS5JbmNsdWRlQW5vbnltb3VzKSB8fCAhaW5uZXIudHlwZS5pc0Fub255bW91cyA/IGlubmVyXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDogaW5uZXIubmV4dENoaWxkKGRpciA8IDAgPyBuZXh0LmNoaWxkcmVuLmxlbmd0aCAtIDEgOiAwLCBkaXIsIHBvcywgc2lkZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKChtb2RlICYgSXRlck1vZGUuSW5jbHVkZUFub255bW91cykgfHwgIXBhcmVudC50eXBlLmlzQW5vbnltb3VzKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgIGlmIChwYXJlbnQuaW5kZXggPj0gMClcclxuICAgICAgICAgICAgICAgIGkgPSBwYXJlbnQuaW5kZXggKyBkaXI7XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgIGkgPSBkaXIgPCAwID8gLTEgOiBwYXJlbnQuX3BhcmVudC5fdHJlZS5jaGlsZHJlbi5sZW5ndGg7XHJcbiAgICAgICAgICAgIHBhcmVudCA9IHBhcmVudC5fcGFyZW50O1xyXG4gICAgICAgICAgICBpZiAoIXBhcmVudClcclxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGdldCBmaXJzdENoaWxkKCkgeyByZXR1cm4gdGhpcy5uZXh0Q2hpbGQoMCwgMSwgMCwgNCAvKiBTaWRlLkRvbnRDYXJlICovKTsgfVxyXG4gICAgZ2V0IGxhc3RDaGlsZCgpIHsgcmV0dXJuIHRoaXMubmV4dENoaWxkKHRoaXMuX3RyZWUuY2hpbGRyZW4ubGVuZ3RoIC0gMSwgLTEsIDAsIDQgLyogU2lkZS5Eb250Q2FyZSAqLyk7IH1cclxuICAgIGNoaWxkQWZ0ZXIocG9zKSB7IHJldHVybiB0aGlzLm5leHRDaGlsZCgwLCAxLCBwb3MsIDIgLyogU2lkZS5BZnRlciAqLyk7IH1cclxuICAgIGNoaWxkQmVmb3JlKHBvcykgeyByZXR1cm4gdGhpcy5uZXh0Q2hpbGQodGhpcy5fdHJlZS5jaGlsZHJlbi5sZW5ndGggLSAxLCAtMSwgcG9zLCAtMiAvKiBTaWRlLkJlZm9yZSAqLyk7IH1cclxuICAgIGVudGVyKHBvcywgc2lkZSwgbW9kZSA9IDApIHtcclxuICAgICAgICBsZXQgbW91bnRlZDtcclxuICAgICAgICBpZiAoIShtb2RlICYgSXRlck1vZGUuSWdub3JlT3ZlcmxheXMpICYmIChtb3VudGVkID0gdGhpcy5fdHJlZS5wcm9wKE5vZGVQcm9wLm1vdW50ZWQpKSAmJiBtb3VudGVkLm92ZXJsYXkpIHtcclxuICAgICAgICAgICAgbGV0IHJQb3MgPSBwb3MgLSB0aGlzLmZyb207XHJcbiAgICAgICAgICAgIGZvciAobGV0IHsgZnJvbSwgdG8gfSBvZiBtb3VudGVkLm92ZXJsYXkpIHtcclxuICAgICAgICAgICAgICAgIGlmICgoc2lkZSA+IDAgPyBmcm9tIDw9IHJQb3MgOiBmcm9tIDwgclBvcykgJiZcclxuICAgICAgICAgICAgICAgICAgICAoc2lkZSA8IDAgPyB0byA+PSByUG9zIDogdG8gPiByUG9zKSlcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFRyZWVOb2RlKG1vdW50ZWQudHJlZSwgbW91bnRlZC5vdmVybGF5WzBdLmZyb20gKyB0aGlzLmZyb20sIC0xLCB0aGlzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5uZXh0Q2hpbGQoMCwgMSwgcG9zLCBzaWRlLCBtb2RlKTtcclxuICAgIH1cclxuICAgIG5leHRTaWduaWZpY2FudFBhcmVudCgpIHtcclxuICAgICAgICBsZXQgdmFsID0gdGhpcztcclxuICAgICAgICB3aGlsZSAodmFsLnR5cGUuaXNBbm9ueW1vdXMgJiYgdmFsLl9wYXJlbnQpXHJcbiAgICAgICAgICAgIHZhbCA9IHZhbC5fcGFyZW50O1xyXG4gICAgICAgIHJldHVybiB2YWw7XHJcbiAgICB9XHJcbiAgICBnZXQgcGFyZW50KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9wYXJlbnQgPyB0aGlzLl9wYXJlbnQubmV4dFNpZ25pZmljYW50UGFyZW50KCkgOiBudWxsO1xyXG4gICAgfVxyXG4gICAgZ2V0IG5leHRTaWJsaW5nKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9wYXJlbnQgJiYgdGhpcy5pbmRleCA+PSAwID8gdGhpcy5fcGFyZW50Lm5leHRDaGlsZCh0aGlzLmluZGV4ICsgMSwgMSwgMCwgNCAvKiBTaWRlLkRvbnRDYXJlICovKSA6IG51bGw7XHJcbiAgICB9XHJcbiAgICBnZXQgcHJldlNpYmxpbmcoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BhcmVudCAmJiB0aGlzLmluZGV4ID49IDAgPyB0aGlzLl9wYXJlbnQubmV4dENoaWxkKHRoaXMuaW5kZXggLSAxLCAtMSwgMCwgNCAvKiBTaWRlLkRvbnRDYXJlICovKSA6IG51bGw7XHJcbiAgICB9XHJcbiAgICBjdXJzb3IobW9kZSA9IDApIHsgcmV0dXJuIG5ldyBUcmVlQ3Vyc29yKHRoaXMsIG1vZGUpOyB9XHJcbiAgICBnZXQgdHJlZSgpIHsgcmV0dXJuIHRoaXMuX3RyZWU7IH1cclxuICAgIHRvVHJlZSgpIHsgcmV0dXJuIHRoaXMuX3RyZWU7IH1cclxuICAgIHJlc29sdmUocG9zLCBzaWRlID0gMCkge1xyXG4gICAgICAgIHJldHVybiByZXNvbHZlTm9kZSh0aGlzLCBwb3MsIHNpZGUsIGZhbHNlKTtcclxuICAgIH1cclxuICAgIHJlc29sdmVJbm5lcihwb3MsIHNpZGUgPSAwKSB7XHJcbiAgICAgICAgcmV0dXJuIHJlc29sdmVOb2RlKHRoaXMsIHBvcywgc2lkZSwgdHJ1ZSk7XHJcbiAgICB9XHJcbiAgICBlbnRlclVuZmluaXNoZWROb2Rlc0JlZm9yZShwb3MpIHsgcmV0dXJuIGVudGVyVW5maW5pc2hlZE5vZGVzQmVmb3JlKHRoaXMsIHBvcyk7IH1cclxuICAgIGdldENoaWxkKHR5cGUsIGJlZm9yZSA9IG51bGwsIGFmdGVyID0gbnVsbCkge1xyXG4gICAgICAgIGxldCByID0gZ2V0Q2hpbGRyZW4odGhpcywgdHlwZSwgYmVmb3JlLCBhZnRlcik7XHJcbiAgICAgICAgcmV0dXJuIHIubGVuZ3RoID8gclswXSA6IG51bGw7XHJcbiAgICB9XHJcbiAgICBnZXRDaGlsZHJlbih0eXBlLCBiZWZvcmUgPSBudWxsLCBhZnRlciA9IG51bGwpIHtcclxuICAgICAgICByZXR1cm4gZ2V0Q2hpbGRyZW4odGhpcywgdHlwZSwgYmVmb3JlLCBhZnRlcik7XHJcbiAgICB9XHJcbiAgICAvLy8gQGludGVybmFsXHJcbiAgICB0b1N0cmluZygpIHsgcmV0dXJuIHRoaXMuX3RyZWUudG9TdHJpbmcoKTsgfVxyXG4gICAgZ2V0IG5vZGUoKSB7IHJldHVybiB0aGlzOyB9XHJcbiAgICBtYXRjaENvbnRleHQoY29udGV4dCkgeyByZXR1cm4gbWF0Y2hOb2RlQ29udGV4dCh0aGlzLCBjb250ZXh0KTsgfVxyXG59XHJcbmZ1bmN0aW9uIGdldENoaWxkcmVuKG5vZGUsIHR5cGUsIGJlZm9yZSwgYWZ0ZXIpIHtcclxuICAgIGxldCBjdXIgPSBub2RlLmN1cnNvcigpLCByZXN1bHQgPSBbXTtcclxuICAgIGlmICghY3VyLmZpcnN0Q2hpbGQoKSlcclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgaWYgKGJlZm9yZSAhPSBudWxsKVxyXG4gICAgICAgIHdoaWxlICghY3VyLnR5cGUuaXMoYmVmb3JlKSlcclxuICAgICAgICAgICAgaWYgKCFjdXIubmV4dFNpYmxpbmcoKSlcclxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICBmb3IgKDs7KSB7XHJcbiAgICAgICAgaWYgKGFmdGVyICE9IG51bGwgJiYgY3VyLnR5cGUuaXMoYWZ0ZXIpKVxyXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgIGlmIChjdXIudHlwZS5pcyh0eXBlKSlcclxuICAgICAgICAgICAgcmVzdWx0LnB1c2goY3VyLm5vZGUpO1xyXG4gICAgICAgIGlmICghY3VyLm5leHRTaWJsaW5nKCkpXHJcbiAgICAgICAgICAgIHJldHVybiBhZnRlciA9PSBudWxsID8gcmVzdWx0IDogW107XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gbWF0Y2hOb2RlQ29udGV4dChub2RlLCBjb250ZXh0LCBpID0gY29udGV4dC5sZW5ndGggLSAxKSB7XHJcbiAgICBmb3IgKGxldCBwID0gbm9kZS5wYXJlbnQ7IGkgPj0gMDsgcCA9IHAucGFyZW50KSB7XHJcbiAgICAgICAgaWYgKCFwKVxyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgaWYgKCFwLnR5cGUuaXNBbm9ueW1vdXMpIHtcclxuICAgICAgICAgICAgaWYgKGNvbnRleHRbaV0gJiYgY29udGV4dFtpXSAhPSBwLm5hbWUpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIGktLTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdHJ1ZTtcclxufVxyXG5jbGFzcyBCdWZmZXJDb250ZXh0IHtcclxuICAgIGNvbnN0cnVjdG9yKHBhcmVudCwgYnVmZmVyLCBpbmRleCwgc3RhcnQpIHtcclxuICAgICAgICB0aGlzLnBhcmVudCA9IHBhcmVudDtcclxuICAgICAgICB0aGlzLmJ1ZmZlciA9IGJ1ZmZlcjtcclxuICAgICAgICB0aGlzLmluZGV4ID0gaW5kZXg7XHJcbiAgICAgICAgdGhpcy5zdGFydCA9IHN0YXJ0O1xyXG4gICAgfVxyXG59XHJcbmNsYXNzIEJ1ZmZlck5vZGUge1xyXG4gICAgZ2V0IG5hbWUoKSB7IHJldHVybiB0aGlzLnR5cGUubmFtZTsgfVxyXG4gICAgZ2V0IGZyb20oKSB7IHJldHVybiB0aGlzLmNvbnRleHQuc3RhcnQgKyB0aGlzLmNvbnRleHQuYnVmZmVyLmJ1ZmZlclt0aGlzLmluZGV4ICsgMV07IH1cclxuICAgIGdldCB0bygpIHsgcmV0dXJuIHRoaXMuY29udGV4dC5zdGFydCArIHRoaXMuY29udGV4dC5idWZmZXIuYnVmZmVyW3RoaXMuaW5kZXggKyAyXTsgfVxyXG4gICAgY29uc3RydWN0b3IoY29udGV4dCwgX3BhcmVudCwgaW5kZXgpIHtcclxuICAgICAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xyXG4gICAgICAgIHRoaXMuX3BhcmVudCA9IF9wYXJlbnQ7XHJcbiAgICAgICAgdGhpcy5pbmRleCA9IGluZGV4O1xyXG4gICAgICAgIHRoaXMudHlwZSA9IGNvbnRleHQuYnVmZmVyLnNldC50eXBlc1tjb250ZXh0LmJ1ZmZlci5idWZmZXJbaW5kZXhdXTtcclxuICAgIH1cclxuICAgIGNoaWxkKGRpciwgcG9zLCBzaWRlKSB7XHJcbiAgICAgICAgbGV0IHsgYnVmZmVyIH0gPSB0aGlzLmNvbnRleHQ7XHJcbiAgICAgICAgbGV0IGluZGV4ID0gYnVmZmVyLmZpbmRDaGlsZCh0aGlzLmluZGV4ICsgNCwgYnVmZmVyLmJ1ZmZlclt0aGlzLmluZGV4ICsgM10sIGRpciwgcG9zIC0gdGhpcy5jb250ZXh0LnN0YXJ0LCBzaWRlKTtcclxuICAgICAgICByZXR1cm4gaW5kZXggPCAwID8gbnVsbCA6IG5ldyBCdWZmZXJOb2RlKHRoaXMuY29udGV4dCwgdGhpcywgaW5kZXgpO1xyXG4gICAgfVxyXG4gICAgZ2V0IGZpcnN0Q2hpbGQoKSB7IHJldHVybiB0aGlzLmNoaWxkKDEsIDAsIDQgLyogU2lkZS5Eb250Q2FyZSAqLyk7IH1cclxuICAgIGdldCBsYXN0Q2hpbGQoKSB7IHJldHVybiB0aGlzLmNoaWxkKC0xLCAwLCA0IC8qIFNpZGUuRG9udENhcmUgKi8pOyB9XHJcbiAgICBjaGlsZEFmdGVyKHBvcykgeyByZXR1cm4gdGhpcy5jaGlsZCgxLCBwb3MsIDIgLyogU2lkZS5BZnRlciAqLyk7IH1cclxuICAgIGNoaWxkQmVmb3JlKHBvcykgeyByZXR1cm4gdGhpcy5jaGlsZCgtMSwgcG9zLCAtMiAvKiBTaWRlLkJlZm9yZSAqLyk7IH1cclxuICAgIGVudGVyKHBvcywgc2lkZSwgbW9kZSA9IDApIHtcclxuICAgICAgICBpZiAobW9kZSAmIEl0ZXJNb2RlLkV4Y2x1ZGVCdWZmZXJzKVxyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICBsZXQgeyBidWZmZXIgfSA9IHRoaXMuY29udGV4dDtcclxuICAgICAgICBsZXQgaW5kZXggPSBidWZmZXIuZmluZENoaWxkKHRoaXMuaW5kZXggKyA0LCBidWZmZXIuYnVmZmVyW3RoaXMuaW5kZXggKyAzXSwgc2lkZSA+IDAgPyAxIDogLTEsIHBvcyAtIHRoaXMuY29udGV4dC5zdGFydCwgc2lkZSk7XHJcbiAgICAgICAgcmV0dXJuIGluZGV4IDwgMCA/IG51bGwgOiBuZXcgQnVmZmVyTm9kZSh0aGlzLmNvbnRleHQsIHRoaXMsIGluZGV4KTtcclxuICAgIH1cclxuICAgIGdldCBwYXJlbnQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BhcmVudCB8fCB0aGlzLmNvbnRleHQucGFyZW50Lm5leHRTaWduaWZpY2FudFBhcmVudCgpO1xyXG4gICAgfVxyXG4gICAgZXh0ZXJuYWxTaWJsaW5nKGRpcikge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9wYXJlbnQgPyBudWxsIDogdGhpcy5jb250ZXh0LnBhcmVudC5uZXh0Q2hpbGQodGhpcy5jb250ZXh0LmluZGV4ICsgZGlyLCBkaXIsIDAsIDQgLyogU2lkZS5Eb250Q2FyZSAqLyk7XHJcbiAgICB9XHJcbiAgICBnZXQgbmV4dFNpYmxpbmcoKSB7XHJcbiAgICAgICAgbGV0IHsgYnVmZmVyIH0gPSB0aGlzLmNvbnRleHQ7XHJcbiAgICAgICAgbGV0IGFmdGVyID0gYnVmZmVyLmJ1ZmZlclt0aGlzLmluZGV4ICsgM107XHJcbiAgICAgICAgaWYgKGFmdGVyIDwgKHRoaXMuX3BhcmVudCA/IGJ1ZmZlci5idWZmZXJbdGhpcy5fcGFyZW50LmluZGV4ICsgM10gOiBidWZmZXIuYnVmZmVyLmxlbmd0aCkpXHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgQnVmZmVyTm9kZSh0aGlzLmNvbnRleHQsIHRoaXMuX3BhcmVudCwgYWZ0ZXIpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLmV4dGVybmFsU2libGluZygxKTtcclxuICAgIH1cclxuICAgIGdldCBwcmV2U2libGluZygpIHtcclxuICAgICAgICBsZXQgeyBidWZmZXIgfSA9IHRoaXMuY29udGV4dDtcclxuICAgICAgICBsZXQgcGFyZW50U3RhcnQgPSB0aGlzLl9wYXJlbnQgPyB0aGlzLl9wYXJlbnQuaW5kZXggKyA0IDogMDtcclxuICAgICAgICBpZiAodGhpcy5pbmRleCA9PSBwYXJlbnRTdGFydClcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZXh0ZXJuYWxTaWJsaW5nKC0xKTtcclxuICAgICAgICByZXR1cm4gbmV3IEJ1ZmZlck5vZGUodGhpcy5jb250ZXh0LCB0aGlzLl9wYXJlbnQsIGJ1ZmZlci5maW5kQ2hpbGQocGFyZW50U3RhcnQsIHRoaXMuaW5kZXgsIC0xLCAwLCA0IC8qIFNpZGUuRG9udENhcmUgKi8pKTtcclxuICAgIH1cclxuICAgIGN1cnNvcihtb2RlID0gMCkgeyByZXR1cm4gbmV3IFRyZWVDdXJzb3IodGhpcywgbW9kZSk7IH1cclxuICAgIGdldCB0cmVlKCkgeyByZXR1cm4gbnVsbDsgfVxyXG4gICAgdG9UcmVlKCkge1xyXG4gICAgICAgIGxldCBjaGlsZHJlbiA9IFtdLCBwb3NpdGlvbnMgPSBbXTtcclxuICAgICAgICBsZXQgeyBidWZmZXIgfSA9IHRoaXMuY29udGV4dDtcclxuICAgICAgICBsZXQgc3RhcnRJID0gdGhpcy5pbmRleCArIDQsIGVuZEkgPSBidWZmZXIuYnVmZmVyW3RoaXMuaW5kZXggKyAzXTtcclxuICAgICAgICBpZiAoZW5kSSA+IHN0YXJ0SSkge1xyXG4gICAgICAgICAgICBsZXQgZnJvbSA9IGJ1ZmZlci5idWZmZXJbdGhpcy5pbmRleCArIDFdO1xyXG4gICAgICAgICAgICBjaGlsZHJlbi5wdXNoKGJ1ZmZlci5zbGljZShzdGFydEksIGVuZEksIGZyb20pKTtcclxuICAgICAgICAgICAgcG9zaXRpb25zLnB1c2goMCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBuZXcgVHJlZSh0aGlzLnR5cGUsIGNoaWxkcmVuLCBwb3NpdGlvbnMsIHRoaXMudG8gLSB0aGlzLmZyb20pO1xyXG4gICAgfVxyXG4gICAgcmVzb2x2ZShwb3MsIHNpZGUgPSAwKSB7XHJcbiAgICAgICAgcmV0dXJuIHJlc29sdmVOb2RlKHRoaXMsIHBvcywgc2lkZSwgZmFsc2UpO1xyXG4gICAgfVxyXG4gICAgcmVzb2x2ZUlubmVyKHBvcywgc2lkZSA9IDApIHtcclxuICAgICAgICByZXR1cm4gcmVzb2x2ZU5vZGUodGhpcywgcG9zLCBzaWRlLCB0cnVlKTtcclxuICAgIH1cclxuICAgIGVudGVyVW5maW5pc2hlZE5vZGVzQmVmb3JlKHBvcykgeyByZXR1cm4gZW50ZXJVbmZpbmlzaGVkTm9kZXNCZWZvcmUodGhpcywgcG9zKTsgfVxyXG4gICAgLy8vIEBpbnRlcm5hbFxyXG4gICAgdG9TdHJpbmcoKSB7IHJldHVybiB0aGlzLmNvbnRleHQuYnVmZmVyLmNoaWxkU3RyaW5nKHRoaXMuaW5kZXgpOyB9XHJcbiAgICBnZXRDaGlsZCh0eXBlLCBiZWZvcmUgPSBudWxsLCBhZnRlciA9IG51bGwpIHtcclxuICAgICAgICBsZXQgciA9IGdldENoaWxkcmVuKHRoaXMsIHR5cGUsIGJlZm9yZSwgYWZ0ZXIpO1xyXG4gICAgICAgIHJldHVybiByLmxlbmd0aCA/IHJbMF0gOiBudWxsO1xyXG4gICAgfVxyXG4gICAgZ2V0Q2hpbGRyZW4odHlwZSwgYmVmb3JlID0gbnVsbCwgYWZ0ZXIgPSBudWxsKSB7XHJcbiAgICAgICAgcmV0dXJuIGdldENoaWxkcmVuKHRoaXMsIHR5cGUsIGJlZm9yZSwgYWZ0ZXIpO1xyXG4gICAgfVxyXG4gICAgZ2V0IG5vZGUoKSB7IHJldHVybiB0aGlzOyB9XHJcbiAgICBtYXRjaENvbnRleHQoY29udGV4dCkgeyByZXR1cm4gbWF0Y2hOb2RlQ29udGV4dCh0aGlzLCBjb250ZXh0KTsgfVxyXG59XHJcbi8vLyBBIHRyZWUgY3Vyc29yIG9iamVjdCBmb2N1c2VzIG9uIGEgZ2l2ZW4gbm9kZSBpbiBhIHN5bnRheCB0cmVlLCBhbmRcclxuLy8vIGFsbG93cyB5b3UgdG8gbW92ZSB0byBhZGphY2VudCBub2Rlcy5cclxuY2xhc3MgVHJlZUN1cnNvciB7XHJcbiAgICAvLy8gU2hvcnRoYW5kIGZvciBgLnR5cGUubmFtZWAuXHJcbiAgICBnZXQgbmFtZSgpIHsgcmV0dXJuIHRoaXMudHlwZS5uYW1lOyB9XHJcbiAgICAvLy8gQGludGVybmFsXHJcbiAgICBjb25zdHJ1Y3Rvcihub2RlLCBcclxuICAgIC8vLyBAaW50ZXJuYWxcclxuICAgIG1vZGUgPSAwKSB7XHJcbiAgICAgICAgdGhpcy5tb2RlID0gbW9kZTtcclxuICAgICAgICAvLy8gQGludGVybmFsXHJcbiAgICAgICAgdGhpcy5idWZmZXIgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuc3RhY2sgPSBbXTtcclxuICAgICAgICAvLy8gQGludGVybmFsXHJcbiAgICAgICAgdGhpcy5pbmRleCA9IDA7XHJcbiAgICAgICAgdGhpcy5idWZmZXJOb2RlID0gbnVsbDtcclxuICAgICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIFRyZWVOb2RlKSB7XHJcbiAgICAgICAgICAgIHRoaXMueWllbGROb2RlKG5vZGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5fdHJlZSA9IG5vZGUuY29udGV4dC5wYXJlbnQ7XHJcbiAgICAgICAgICAgIHRoaXMuYnVmZmVyID0gbm9kZS5jb250ZXh0O1xyXG4gICAgICAgICAgICBmb3IgKGxldCBuID0gbm9kZS5fcGFyZW50OyBuOyBuID0gbi5fcGFyZW50KVxyXG4gICAgICAgICAgICAgICAgdGhpcy5zdGFjay51bnNoaWZ0KG4uaW5kZXgpO1xyXG4gICAgICAgICAgICB0aGlzLmJ1ZmZlck5vZGUgPSBub2RlO1xyXG4gICAgICAgICAgICB0aGlzLnlpZWxkQnVmKG5vZGUuaW5kZXgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHlpZWxkTm9kZShub2RlKSB7XHJcbiAgICAgICAgaWYgKCFub2RlKVxyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5fdHJlZSA9IG5vZGU7XHJcbiAgICAgICAgdGhpcy50eXBlID0gbm9kZS50eXBlO1xyXG4gICAgICAgIHRoaXMuZnJvbSA9IG5vZGUuZnJvbTtcclxuICAgICAgICB0aGlzLnRvID0gbm9kZS50bztcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICAgIHlpZWxkQnVmKGluZGV4LCB0eXBlKSB7XHJcbiAgICAgICAgdGhpcy5pbmRleCA9IGluZGV4O1xyXG4gICAgICAgIGxldCB7IHN0YXJ0LCBidWZmZXIgfSA9IHRoaXMuYnVmZmVyO1xyXG4gICAgICAgIHRoaXMudHlwZSA9IHR5cGUgfHwgYnVmZmVyLnNldC50eXBlc1tidWZmZXIuYnVmZmVyW2luZGV4XV07XHJcbiAgICAgICAgdGhpcy5mcm9tID0gc3RhcnQgKyBidWZmZXIuYnVmZmVyW2luZGV4ICsgMV07XHJcbiAgICAgICAgdGhpcy50byA9IHN0YXJ0ICsgYnVmZmVyLmJ1ZmZlcltpbmRleCArIDJdO1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gICAgeWllbGQobm9kZSkge1xyXG4gICAgICAgIGlmICghbm9kZSlcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIGlmIChub2RlIGluc3RhbmNlb2YgVHJlZU5vZGUpIHtcclxuICAgICAgICAgICAgdGhpcy5idWZmZXIgPSBudWxsO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy55aWVsZE5vZGUobm9kZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuYnVmZmVyID0gbm9kZS5jb250ZXh0O1xyXG4gICAgICAgIHJldHVybiB0aGlzLnlpZWxkQnVmKG5vZGUuaW5kZXgsIG5vZGUudHlwZSk7XHJcbiAgICB9XHJcbiAgICAvLy8gQGludGVybmFsXHJcbiAgICB0b1N0cmluZygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5idWZmZXIgPyB0aGlzLmJ1ZmZlci5idWZmZXIuY2hpbGRTdHJpbmcodGhpcy5pbmRleCkgOiB0aGlzLl90cmVlLnRvU3RyaW5nKCk7XHJcbiAgICB9XHJcbiAgICAvLy8gQGludGVybmFsXHJcbiAgICBlbnRlckNoaWxkKGRpciwgcG9zLCBzaWRlKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLmJ1ZmZlcilcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMueWllbGQodGhpcy5fdHJlZS5uZXh0Q2hpbGQoZGlyIDwgMCA/IHRoaXMuX3RyZWUuX3RyZWUuY2hpbGRyZW4ubGVuZ3RoIC0gMSA6IDAsIGRpciwgcG9zLCBzaWRlLCB0aGlzLm1vZGUpKTtcclxuICAgICAgICBsZXQgeyBidWZmZXIgfSA9IHRoaXMuYnVmZmVyO1xyXG4gICAgICAgIGxldCBpbmRleCA9IGJ1ZmZlci5maW5kQ2hpbGQodGhpcy5pbmRleCArIDQsIGJ1ZmZlci5idWZmZXJbdGhpcy5pbmRleCArIDNdLCBkaXIsIHBvcyAtIHRoaXMuYnVmZmVyLnN0YXJ0LCBzaWRlKTtcclxuICAgICAgICBpZiAoaW5kZXggPCAwKVxyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5zdGFjay5wdXNoKHRoaXMuaW5kZXgpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLnlpZWxkQnVmKGluZGV4KTtcclxuICAgIH1cclxuICAgIC8vLyBNb3ZlIHRoZSBjdXJzb3IgdG8gdGhpcyBub2RlJ3MgZmlyc3QgY2hpbGQuIFdoZW4gdGhpcyByZXR1cm5zXHJcbiAgICAvLy8gZmFsc2UsIHRoZSBub2RlIGhhcyBubyBjaGlsZCwgYW5kIHRoZSBjdXJzb3IgaGFzIG5vdCBiZWVuIG1vdmVkLlxyXG4gICAgZmlyc3RDaGlsZCgpIHsgcmV0dXJuIHRoaXMuZW50ZXJDaGlsZCgxLCAwLCA0IC8qIFNpZGUuRG9udENhcmUgKi8pOyB9XHJcbiAgICAvLy8gTW92ZSB0aGUgY3Vyc29yIHRvIHRoaXMgbm9kZSdzIGxhc3QgY2hpbGQuXHJcbiAgICBsYXN0Q2hpbGQoKSB7IHJldHVybiB0aGlzLmVudGVyQ2hpbGQoLTEsIDAsIDQgLyogU2lkZS5Eb250Q2FyZSAqLyk7IH1cclxuICAgIC8vLyBNb3ZlIHRoZSBjdXJzb3IgdG8gdGhlIGZpcnN0IGNoaWxkIHRoYXQgZW5kcyBhZnRlciBgcG9zYC5cclxuICAgIGNoaWxkQWZ0ZXIocG9zKSB7IHJldHVybiB0aGlzLmVudGVyQ2hpbGQoMSwgcG9zLCAyIC8qIFNpZGUuQWZ0ZXIgKi8pOyB9XHJcbiAgICAvLy8gTW92ZSB0byB0aGUgbGFzdCBjaGlsZCB0aGF0IHN0YXJ0cyBiZWZvcmUgYHBvc2AuXHJcbiAgICBjaGlsZEJlZm9yZShwb3MpIHsgcmV0dXJuIHRoaXMuZW50ZXJDaGlsZCgtMSwgcG9zLCAtMiAvKiBTaWRlLkJlZm9yZSAqLyk7IH1cclxuICAgIC8vLyBNb3ZlIHRoZSBjdXJzb3IgdG8gdGhlIGNoaWxkIGFyb3VuZCBgcG9zYC4gSWYgc2lkZSBpcyAtMSB0aGVcclxuICAgIC8vLyBjaGlsZCBtYXkgZW5kIGF0IHRoYXQgcG9zaXRpb24sIHdoZW4gMSBpdCBtYXkgc3RhcnQgdGhlcmUuIFRoaXNcclxuICAgIC8vLyB3aWxsIGFsc28gZW50ZXIgW292ZXJsYWlkXSgjY29tbW9uLk1vdW50ZWRUcmVlLm92ZXJsYXkpXHJcbiAgICAvLy8gW21vdW50ZWRdKCNjb21tb24uTm9kZVByb3BebW91bnRlZCkgdHJlZXMgdW5sZXNzIGBvdmVybGF5c2AgaXNcclxuICAgIC8vLyBzZXQgdG8gZmFsc2UuXHJcbiAgICBlbnRlcihwb3MsIHNpZGUsIG1vZGUgPSB0aGlzLm1vZGUpIHtcclxuICAgICAgICBpZiAoIXRoaXMuYnVmZmVyKVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy55aWVsZCh0aGlzLl90cmVlLmVudGVyKHBvcywgc2lkZSwgbW9kZSkpO1xyXG4gICAgICAgIHJldHVybiBtb2RlICYgSXRlck1vZGUuRXhjbHVkZUJ1ZmZlcnMgPyBmYWxzZSA6IHRoaXMuZW50ZXJDaGlsZCgxLCBwb3MsIHNpZGUpO1xyXG4gICAgfVxyXG4gICAgLy8vIE1vdmUgdG8gdGhlIG5vZGUncyBwYXJlbnQgbm9kZSwgaWYgdGhpcyBpc24ndCB0aGUgdG9wIG5vZGUuXHJcbiAgICBwYXJlbnQoKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLmJ1ZmZlcilcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMueWllbGROb2RlKCh0aGlzLm1vZGUgJiBJdGVyTW9kZS5JbmNsdWRlQW5vbnltb3VzKSA/IHRoaXMuX3RyZWUuX3BhcmVudCA6IHRoaXMuX3RyZWUucGFyZW50KTtcclxuICAgICAgICBpZiAodGhpcy5zdGFjay5sZW5ndGgpXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnlpZWxkQnVmKHRoaXMuc3RhY2sucG9wKCkpO1xyXG4gICAgICAgIGxldCBwYXJlbnQgPSAodGhpcy5tb2RlICYgSXRlck1vZGUuSW5jbHVkZUFub255bW91cykgPyB0aGlzLmJ1ZmZlci5wYXJlbnQgOiB0aGlzLmJ1ZmZlci5wYXJlbnQubmV4dFNpZ25pZmljYW50UGFyZW50KCk7XHJcbiAgICAgICAgdGhpcy5idWZmZXIgPSBudWxsO1xyXG4gICAgICAgIHJldHVybiB0aGlzLnlpZWxkTm9kZShwYXJlbnQpO1xyXG4gICAgfVxyXG4gICAgLy8vIEBpbnRlcm5hbFxyXG4gICAgc2libGluZyhkaXIpIHtcclxuICAgICAgICBpZiAoIXRoaXMuYnVmZmVyKVxyXG4gICAgICAgICAgICByZXR1cm4gIXRoaXMuX3RyZWUuX3BhcmVudCA/IGZhbHNlXHJcbiAgICAgICAgICAgICAgICA6IHRoaXMueWllbGQodGhpcy5fdHJlZS5pbmRleCA8IDAgPyBudWxsXHJcbiAgICAgICAgICAgICAgICAgICAgOiB0aGlzLl90cmVlLl9wYXJlbnQubmV4dENoaWxkKHRoaXMuX3RyZWUuaW5kZXggKyBkaXIsIGRpciwgMCwgNCAvKiBTaWRlLkRvbnRDYXJlICovLCB0aGlzLm1vZGUpKTtcclxuICAgICAgICBsZXQgeyBidWZmZXIgfSA9IHRoaXMuYnVmZmVyLCBkID0gdGhpcy5zdGFjay5sZW5ndGggLSAxO1xyXG4gICAgICAgIGlmIChkaXIgPCAwKSB7XHJcbiAgICAgICAgICAgIGxldCBwYXJlbnRTdGFydCA9IGQgPCAwID8gMCA6IHRoaXMuc3RhY2tbZF0gKyA0O1xyXG4gICAgICAgICAgICBpZiAodGhpcy5pbmRleCAhPSBwYXJlbnRTdGFydClcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnlpZWxkQnVmKGJ1ZmZlci5maW5kQ2hpbGQocGFyZW50U3RhcnQsIHRoaXMuaW5kZXgsIC0xLCAwLCA0IC8qIFNpZGUuRG9udENhcmUgKi8pKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGxldCBhZnRlciA9IGJ1ZmZlci5idWZmZXJbdGhpcy5pbmRleCArIDNdO1xyXG4gICAgICAgICAgICBpZiAoYWZ0ZXIgPCAoZCA8IDAgPyBidWZmZXIuYnVmZmVyLmxlbmd0aCA6IGJ1ZmZlci5idWZmZXJbdGhpcy5zdGFja1tkXSArIDNdKSlcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnlpZWxkQnVmKGFmdGVyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGQgPCAwID8gdGhpcy55aWVsZCh0aGlzLmJ1ZmZlci5wYXJlbnQubmV4dENoaWxkKHRoaXMuYnVmZmVyLmluZGV4ICsgZGlyLCBkaXIsIDAsIDQgLyogU2lkZS5Eb250Q2FyZSAqLywgdGhpcy5tb2RlKSkgOiBmYWxzZTtcclxuICAgIH1cclxuICAgIC8vLyBNb3ZlIHRvIHRoaXMgbm9kZSdzIG5leHQgc2libGluZywgaWYgYW55LlxyXG4gICAgbmV4dFNpYmxpbmcoKSB7IHJldHVybiB0aGlzLnNpYmxpbmcoMSk7IH1cclxuICAgIC8vLyBNb3ZlIHRvIHRoaXMgbm9kZSdzIHByZXZpb3VzIHNpYmxpbmcsIGlmIGFueS5cclxuICAgIHByZXZTaWJsaW5nKCkgeyByZXR1cm4gdGhpcy5zaWJsaW5nKC0xKTsgfVxyXG4gICAgYXRMYXN0Tm9kZShkaXIpIHtcclxuICAgICAgICBsZXQgaW5kZXgsIHBhcmVudCwgeyBidWZmZXIgfSA9IHRoaXM7XHJcbiAgICAgICAgaWYgKGJ1ZmZlcikge1xyXG4gICAgICAgICAgICBpZiAoZGlyID4gMCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaW5kZXggPCBidWZmZXIuYnVmZmVyLmJ1ZmZlci5sZW5ndGgpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmluZGV4OyBpKyspXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJ1ZmZlci5idWZmZXIuYnVmZmVyW2kgKyAzXSA8IHRoaXMuaW5kZXgpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAoeyBpbmRleCwgcGFyZW50IH0gPSBidWZmZXIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgKHsgaW5kZXgsIF9wYXJlbnQ6IHBhcmVudCB9ID0gdGhpcy5fdHJlZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAoOyBwYXJlbnQ7IHsgaW5kZXgsIF9wYXJlbnQ6IHBhcmVudCB9ID0gcGFyZW50KSB7XHJcbiAgICAgICAgICAgIGlmIChpbmRleCA+IC0xKVxyXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IGluZGV4ICsgZGlyLCBlID0gZGlyIDwgMCA/IC0xIDogcGFyZW50Ll90cmVlLmNoaWxkcmVuLmxlbmd0aDsgaSAhPSBlOyBpICs9IGRpcikge1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBjaGlsZCA9IHBhcmVudC5fdHJlZS5jaGlsZHJlbltpXTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoKHRoaXMubW9kZSAmIEl0ZXJNb2RlLkluY2x1ZGVBbm9ueW1vdXMpIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkIGluc3RhbmNlb2YgVHJlZUJ1ZmZlciB8fFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAhY2hpbGQudHlwZS5pc0Fub255bW91cyB8fFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBoYXNDaGlsZChjaGlsZCkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgICBtb3ZlKGRpciwgZW50ZXIpIHtcclxuICAgICAgICBpZiAoZW50ZXIgJiYgdGhpcy5lbnRlckNoaWxkKGRpciwgMCwgNCAvKiBTaWRlLkRvbnRDYXJlICovKSlcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgZm9yICg7Oykge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5zaWJsaW5nKGRpcikpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgaWYgKHRoaXMuYXRMYXN0Tm9kZShkaXIpIHx8ICF0aGlzLnBhcmVudCgpKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8vLyBNb3ZlIHRvIHRoZSBuZXh0IG5vZGUgaW4gYVxyXG4gICAgLy8vIFtwcmUtb3JkZXJdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1RyZWVfdHJhdmVyc2FsI1ByZS1vcmRlcixfTkxSKVxyXG4gICAgLy8vIHRyYXZlcnNhbCwgZ29pbmcgZnJvbSBhIG5vZGUgdG8gaXRzIGZpcnN0IGNoaWxkIG9yLCBpZiB0aGVcclxuICAgIC8vLyBjdXJyZW50IG5vZGUgaXMgZW1wdHkgb3IgYGVudGVyYCBpcyBmYWxzZSwgaXRzIG5leHQgc2libGluZyBvclxyXG4gICAgLy8vIHRoZSBuZXh0IHNpYmxpbmcgb2YgdGhlIGZpcnN0IHBhcmVudCBub2RlIHRoYXQgaGFzIG9uZS5cclxuICAgIG5leHQoZW50ZXIgPSB0cnVlKSB7IHJldHVybiB0aGlzLm1vdmUoMSwgZW50ZXIpOyB9XHJcbiAgICAvLy8gTW92ZSB0byB0aGUgbmV4dCBub2RlIGluIGEgbGFzdC10by1maXJzdCBwcmUtb3JkZXIgdHJhdmVyYWwuIEFcclxuICAgIC8vLyBub2RlIGlzIGZvbGxvd2VkIGJ5IGl0cyBsYXN0IGNoaWxkIG9yLCBpZiBpdCBoYXMgbm9uZSwgaXRzXHJcbiAgICAvLy8gcHJldmlvdXMgc2libGluZyBvciB0aGUgcHJldmlvdXMgc2libGluZyBvZiB0aGUgZmlyc3QgcGFyZW50XHJcbiAgICAvLy8gbm9kZSB0aGF0IGhhcyBvbmUuXHJcbiAgICBwcmV2KGVudGVyID0gdHJ1ZSkgeyByZXR1cm4gdGhpcy5tb3ZlKC0xLCBlbnRlcik7IH1cclxuICAgIC8vLyBNb3ZlIHRoZSBjdXJzb3IgdG8gdGhlIGlubmVybW9zdCBub2RlIHRoYXQgY292ZXJzIGBwb3NgLiBJZlxyXG4gICAgLy8vIGBzaWRlYCBpcyAtMSwgaXQgd2lsbCBlbnRlciBub2RlcyB0aGF0IGVuZCBhdCBgcG9zYC4gSWYgaXQgaXMgMSxcclxuICAgIC8vLyBpdCB3aWxsIGVudGVyIG5vZGVzIHRoYXQgc3RhcnQgYXQgYHBvc2AuXHJcbiAgICBtb3ZlVG8ocG9zLCBzaWRlID0gMCkge1xyXG4gICAgICAgIC8vIE1vdmUgdXAgdG8gYSBub2RlIHRoYXQgYWN0dWFsbHkgaG9sZHMgdGhlIHBvc2l0aW9uLCBpZiBwb3NzaWJsZVxyXG4gICAgICAgIHdoaWxlICh0aGlzLmZyb20gPT0gdGhpcy50byB8fFxyXG4gICAgICAgICAgICAoc2lkZSA8IDEgPyB0aGlzLmZyb20gPj0gcG9zIDogdGhpcy5mcm9tID4gcG9zKSB8fFxyXG4gICAgICAgICAgICAoc2lkZSA+IC0xID8gdGhpcy50byA8PSBwb3MgOiB0aGlzLnRvIDwgcG9zKSlcclxuICAgICAgICAgICAgaWYgKCF0aGlzLnBhcmVudCgpKVxyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgLy8gVGhlbiBzY2FuIGRvd24gaW50byBjaGlsZCBub2RlcyBhcyBmYXIgYXMgcG9zc2libGVcclxuICAgICAgICB3aGlsZSAodGhpcy5lbnRlckNoaWxkKDEsIHBvcywgc2lkZSkpIHsgfVxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG4gICAgLy8vIEdldCBhIFtzeW50YXggbm9kZV0oI2NvbW1vbi5TeW50YXhOb2RlKSBhdCB0aGUgY3Vyc29yJ3MgY3VycmVudFxyXG4gICAgLy8vIHBvc2l0aW9uLlxyXG4gICAgZ2V0IG5vZGUoKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLmJ1ZmZlcilcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3RyZWU7XHJcbiAgICAgICAgbGV0IGNhY2hlID0gdGhpcy5idWZmZXJOb2RlLCByZXN1bHQgPSBudWxsLCBkZXB0aCA9IDA7XHJcbiAgICAgICAgaWYgKGNhY2hlICYmIGNhY2hlLmNvbnRleHQgPT0gdGhpcy5idWZmZXIpIHtcclxuICAgICAgICAgICAgc2NhbjogZm9yIChsZXQgaW5kZXggPSB0aGlzLmluZGV4LCBkID0gdGhpcy5zdGFjay5sZW5ndGg7IGQgPj0gMDspIHtcclxuICAgICAgICAgICAgICAgIGZvciAobGV0IGMgPSBjYWNoZTsgYzsgYyA9IGMuX3BhcmVudClcclxuICAgICAgICAgICAgICAgICAgICBpZiAoYy5pbmRleCA9PSBpbmRleCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5kZXggPT0gdGhpcy5pbmRleClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBjO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkZXB0aCA9IGQgKyAxO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhayBzY2FuO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGluZGV4ID0gdGhpcy5zdGFja1stLWRdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAobGV0IGkgPSBkZXB0aDsgaSA8IHRoaXMuc3RhY2subGVuZ3RoOyBpKyspXHJcbiAgICAgICAgICAgIHJlc3VsdCA9IG5ldyBCdWZmZXJOb2RlKHRoaXMuYnVmZmVyLCByZXN1bHQsIHRoaXMuc3RhY2tbaV0pO1xyXG4gICAgICAgIHJldHVybiB0aGlzLmJ1ZmZlck5vZGUgPSBuZXcgQnVmZmVyTm9kZSh0aGlzLmJ1ZmZlciwgcmVzdWx0LCB0aGlzLmluZGV4KTtcclxuICAgIH1cclxuICAgIC8vLyBHZXQgdGhlIFt0cmVlXSgjY29tbW9uLlRyZWUpIHRoYXQgcmVwcmVzZW50cyB0aGUgY3VycmVudCBub2RlLCBpZlxyXG4gICAgLy8vIGFueS4gV2lsbCByZXR1cm4gbnVsbCB3aGVuIHRoZSBub2RlIGlzIGluIGEgW3RyZWVcclxuICAgIC8vLyBidWZmZXJdKCNjb21tb24uVHJlZUJ1ZmZlcikuXHJcbiAgICBnZXQgdHJlZSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5idWZmZXIgPyBudWxsIDogdGhpcy5fdHJlZS5fdHJlZTtcclxuICAgIH1cclxuICAgIC8vLyBJdGVyYXRlIG92ZXIgdGhlIGN1cnJlbnQgbm9kZSBhbmQgYWxsIGl0cyBkZXNjZW5kYW50cywgY2FsbGluZ1xyXG4gICAgLy8vIGBlbnRlcmAgd2hlbiBlbnRlcmluZyBhIG5vZGUgYW5kIGBsZWF2ZWAsIGlmIGdpdmVuLCB3aGVuIGxlYXZpbmdcclxuICAgIC8vLyBvbmUuIFdoZW4gYGVudGVyYCByZXR1cm5zIGBmYWxzZWAsIGFueSBjaGlsZHJlbiBvZiB0aGF0IG5vZGUgYXJlXHJcbiAgICAvLy8gc2tpcHBlZCwgYW5kIGBsZWF2ZWAgaXNuJ3QgY2FsbGVkIGZvciBpdC5cclxuICAgIGl0ZXJhdGUoZW50ZXIsIGxlYXZlKSB7XHJcbiAgICAgICAgZm9yIChsZXQgZGVwdGggPSAwOzspIHtcclxuICAgICAgICAgICAgbGV0IG11c3RMZWF2ZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICBpZiAodGhpcy50eXBlLmlzQW5vbnltb3VzIHx8IGVudGVyKHRoaXMpICE9PSBmYWxzZSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZmlyc3RDaGlsZCgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGVwdGgrKztcclxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICghdGhpcy50eXBlLmlzQW5vbnltb3VzKVxyXG4gICAgICAgICAgICAgICAgICAgIG11c3RMZWF2ZSA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZm9yICg7Oykge1xyXG4gICAgICAgICAgICAgICAgaWYgKG11c3RMZWF2ZSAmJiBsZWF2ZSlcclxuICAgICAgICAgICAgICAgICAgICBsZWF2ZSh0aGlzKTtcclxuICAgICAgICAgICAgICAgIG11c3RMZWF2ZSA9IHRoaXMudHlwZS5pc0Fub255bW91cztcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLm5leHRTaWJsaW5nKCkpXHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWRlcHRoKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIHRoaXMucGFyZW50KCk7XHJcbiAgICAgICAgICAgICAgICBkZXB0aC0tO1xyXG4gICAgICAgICAgICAgICAgbXVzdExlYXZlID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8vLyBUZXN0IHdoZXRoZXIgdGhlIGN1cnJlbnQgbm9kZSBtYXRjaGVzIGEgZ2l2ZW4gY29udGV4dOKAlGEgc2VxdWVuY2VcclxuICAgIC8vLyBvZiBkaXJlY3QgcGFyZW50IG5vZGUgbmFtZXMuIEVtcHR5IHN0cmluZ3MgaW4gdGhlIGNvbnRleHQgYXJyYXlcclxuICAgIC8vLyBhcmUgdHJlYXRlZCBhcyB3aWxkY2FyZHMuXHJcbiAgICBtYXRjaENvbnRleHQoY29udGV4dCkge1xyXG4gICAgICAgIGlmICghdGhpcy5idWZmZXIpXHJcbiAgICAgICAgICAgIHJldHVybiBtYXRjaE5vZGVDb250ZXh0KHRoaXMubm9kZSwgY29udGV4dCk7XHJcbiAgICAgICAgbGV0IHsgYnVmZmVyIH0gPSB0aGlzLmJ1ZmZlciwgeyB0eXBlcyB9ID0gYnVmZmVyLnNldDtcclxuICAgICAgICBmb3IgKGxldCBpID0gY29udGV4dC5sZW5ndGggLSAxLCBkID0gdGhpcy5zdGFjay5sZW5ndGggLSAxOyBpID49IDA7IGQtLSkge1xyXG4gICAgICAgICAgICBpZiAoZCA8IDApXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbWF0Y2hOb2RlQ29udGV4dCh0aGlzLm5vZGUsIGNvbnRleHQsIGkpO1xyXG4gICAgICAgICAgICBsZXQgdHlwZSA9IHR5cGVzW2J1ZmZlci5idWZmZXJbdGhpcy5zdGFja1tkXV1dO1xyXG4gICAgICAgICAgICBpZiAoIXR5cGUuaXNBbm9ueW1vdXMpIHtcclxuICAgICAgICAgICAgICAgIGlmIChjb250ZXh0W2ldICYmIGNvbnRleHRbaV0gIT0gdHlwZS5uYW1lKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICAgIGktLTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBoYXNDaGlsZCh0cmVlKSB7XHJcbiAgICByZXR1cm4gdHJlZS5jaGlsZHJlbi5zb21lKGNoID0+IGNoIGluc3RhbmNlb2YgVHJlZUJ1ZmZlciB8fCAhY2gudHlwZS5pc0Fub255bW91cyB8fCBoYXNDaGlsZChjaCkpO1xyXG59XHJcbmZ1bmN0aW9uIGJ1aWxkVHJlZShkYXRhKSB7XHJcbiAgICB2YXIgX2E7XHJcbiAgICBsZXQgeyBidWZmZXIsIG5vZGVTZXQsIG1heEJ1ZmZlckxlbmd0aCA9IERlZmF1bHRCdWZmZXJMZW5ndGgsIHJldXNlZCA9IFtdLCBtaW5SZXBlYXRUeXBlID0gbm9kZVNldC50eXBlcy5sZW5ndGggfSA9IGRhdGE7XHJcbiAgICBsZXQgY3Vyc29yID0gQXJyYXkuaXNBcnJheShidWZmZXIpID8gbmV3IEZsYXRCdWZmZXJDdXJzb3IoYnVmZmVyLCBidWZmZXIubGVuZ3RoKSA6IGJ1ZmZlcjtcclxuICAgIGxldCB0eXBlcyA9IG5vZGVTZXQudHlwZXM7XHJcbiAgICBsZXQgY29udGV4dEhhc2ggPSAwLCBsb29rQWhlYWQgPSAwO1xyXG4gICAgZnVuY3Rpb24gdGFrZU5vZGUocGFyZW50U3RhcnQsIG1pblBvcywgY2hpbGRyZW4sIHBvc2l0aW9ucywgaW5SZXBlYXQpIHtcclxuICAgICAgICBsZXQgeyBpZCwgc3RhcnQsIGVuZCwgc2l6ZSB9ID0gY3Vyc29yO1xyXG4gICAgICAgIGxldCBsb29rQWhlYWRBdFN0YXJ0ID0gbG9va0FoZWFkO1xyXG4gICAgICAgIHdoaWxlIChzaXplIDwgMCkge1xyXG4gICAgICAgICAgICBjdXJzb3IubmV4dCgpO1xyXG4gICAgICAgICAgICBpZiAoc2l6ZSA9PSAtMSAvKiBTcGVjaWFsUmVjb3JkLlJldXNlICovKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgbm9kZSA9IHJldXNlZFtpZF07XHJcbiAgICAgICAgICAgICAgICBjaGlsZHJlbi5wdXNoKG5vZGUpO1xyXG4gICAgICAgICAgICAgICAgcG9zaXRpb25zLnB1c2goc3RhcnQgLSBwYXJlbnRTdGFydCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoc2l6ZSA9PSAtMyAvKiBTcGVjaWFsUmVjb3JkLkNvbnRleHRDaGFuZ2UgKi8pIHsgLy8gQ29udGV4dCBjaGFuZ2VcclxuICAgICAgICAgICAgICAgIGNvbnRleHRIYXNoID0gaWQ7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoc2l6ZSA9PSAtNCAvKiBTcGVjaWFsUmVjb3JkLkxvb2tBaGVhZCAqLykge1xyXG4gICAgICAgICAgICAgICAgbG9va0FoZWFkID0gaWQ7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgVW5yZWNvZ25pemVkIHJlY29yZCBzaXplOiAke3NpemV9YCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IHR5cGUgPSB0eXBlc1tpZF0sIG5vZGUsIGJ1ZmZlcjtcclxuICAgICAgICBsZXQgc3RhcnRQb3MgPSBzdGFydCAtIHBhcmVudFN0YXJ0O1xyXG4gICAgICAgIGlmIChlbmQgLSBzdGFydCA8PSBtYXhCdWZmZXJMZW5ndGggJiYgKGJ1ZmZlciA9IGZpbmRCdWZmZXJTaXplKGN1cnNvci5wb3MgLSBtaW5Qb3MsIGluUmVwZWF0KSkpIHtcclxuICAgICAgICAgICAgLy8gU21hbGwgZW5vdWdoIGZvciBhIGJ1ZmZlciwgYW5kIG5vIHJldXNlZCBub2RlcyBpbnNpZGVcclxuICAgICAgICAgICAgbGV0IGRhdGEgPSBuZXcgVWludDE2QXJyYXkoYnVmZmVyLnNpemUgLSBidWZmZXIuc2tpcCk7XHJcbiAgICAgICAgICAgIGxldCBlbmRQb3MgPSBjdXJzb3IucG9zIC0gYnVmZmVyLnNpemUsIGluZGV4ID0gZGF0YS5sZW5ndGg7XHJcbiAgICAgICAgICAgIHdoaWxlIChjdXJzb3IucG9zID4gZW5kUG9zKVxyXG4gICAgICAgICAgICAgICAgaW5kZXggPSBjb3B5VG9CdWZmZXIoYnVmZmVyLnN0YXJ0LCBkYXRhLCBpbmRleCk7XHJcbiAgICAgICAgICAgIG5vZGUgPSBuZXcgVHJlZUJ1ZmZlcihkYXRhLCBlbmQgLSBidWZmZXIuc3RhcnQsIG5vZGVTZXQpO1xyXG4gICAgICAgICAgICBzdGFydFBvcyA9IGJ1ZmZlci5zdGFydCAtIHBhcmVudFN0YXJ0O1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHsgLy8gTWFrZSBpdCBhIG5vZGVcclxuICAgICAgICAgICAgbGV0IGVuZFBvcyA9IGN1cnNvci5wb3MgLSBzaXplO1xyXG4gICAgICAgICAgICBjdXJzb3IubmV4dCgpO1xyXG4gICAgICAgICAgICBsZXQgbG9jYWxDaGlsZHJlbiA9IFtdLCBsb2NhbFBvc2l0aW9ucyA9IFtdO1xyXG4gICAgICAgICAgICBsZXQgbG9jYWxJblJlcGVhdCA9IGlkID49IG1pblJlcGVhdFR5cGUgPyBpZCA6IC0xO1xyXG4gICAgICAgICAgICBsZXQgbGFzdEdyb3VwID0gMCwgbGFzdEVuZCA9IGVuZDtcclxuICAgICAgICAgICAgd2hpbGUgKGN1cnNvci5wb3MgPiBlbmRQb3MpIHtcclxuICAgICAgICAgICAgICAgIGlmIChsb2NhbEluUmVwZWF0ID49IDAgJiYgY3Vyc29yLmlkID09IGxvY2FsSW5SZXBlYXQgJiYgY3Vyc29yLnNpemUgPj0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjdXJzb3IuZW5kIDw9IGxhc3RFbmQgLSBtYXhCdWZmZXJMZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWFrZVJlcGVhdExlYWYobG9jYWxDaGlsZHJlbiwgbG9jYWxQb3NpdGlvbnMsIHN0YXJ0LCBsYXN0R3JvdXAsIGN1cnNvci5lbmQsIGxhc3RFbmQsIGxvY2FsSW5SZXBlYXQsIGxvb2tBaGVhZEF0U3RhcnQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsYXN0R3JvdXAgPSBsb2NhbENoaWxkcmVuLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGFzdEVuZCA9IGN1cnNvci5lbmQ7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGN1cnNvci5uZXh0KCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB0YWtlTm9kZShzdGFydCwgZW5kUG9zLCBsb2NhbENoaWxkcmVuLCBsb2NhbFBvc2l0aW9ucywgbG9jYWxJblJlcGVhdCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGxvY2FsSW5SZXBlYXQgPj0gMCAmJiBsYXN0R3JvdXAgPiAwICYmIGxhc3RHcm91cCA8IGxvY2FsQ2hpbGRyZW4ubGVuZ3RoKVxyXG4gICAgICAgICAgICAgICAgbWFrZVJlcGVhdExlYWYobG9jYWxDaGlsZHJlbiwgbG9jYWxQb3NpdGlvbnMsIHN0YXJ0LCBsYXN0R3JvdXAsIHN0YXJ0LCBsYXN0RW5kLCBsb2NhbEluUmVwZWF0LCBsb29rQWhlYWRBdFN0YXJ0KTtcclxuICAgICAgICAgICAgbG9jYWxDaGlsZHJlbi5yZXZlcnNlKCk7XHJcbiAgICAgICAgICAgIGxvY2FsUG9zaXRpb25zLnJldmVyc2UoKTtcclxuICAgICAgICAgICAgaWYgKGxvY2FsSW5SZXBlYXQgPiAtMSAmJiBsYXN0R3JvdXAgPiAwKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgbWFrZSA9IG1ha2VCYWxhbmNlZCh0eXBlKTtcclxuICAgICAgICAgICAgICAgIG5vZGUgPSBiYWxhbmNlUmFuZ2UodHlwZSwgbG9jYWxDaGlsZHJlbiwgbG9jYWxQb3NpdGlvbnMsIDAsIGxvY2FsQ2hpbGRyZW4ubGVuZ3RoLCAwLCBlbmQgLSBzdGFydCwgbWFrZSwgbWFrZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBub2RlID0gbWFrZVRyZWUodHlwZSwgbG9jYWxDaGlsZHJlbiwgbG9jYWxQb3NpdGlvbnMsIGVuZCAtIHN0YXJ0LCBsb29rQWhlYWRBdFN0YXJ0IC0gZW5kKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBjaGlsZHJlbi5wdXNoKG5vZGUpO1xyXG4gICAgICAgIHBvc2l0aW9ucy5wdXNoKHN0YXJ0UG9zKTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIG1ha2VCYWxhbmNlZCh0eXBlKSB7XHJcbiAgICAgICAgcmV0dXJuIChjaGlsZHJlbiwgcG9zaXRpb25zLCBsZW5ndGgpID0+IHtcclxuICAgICAgICAgICAgbGV0IGxvb2tBaGVhZCA9IDAsIGxhc3RJID0gY2hpbGRyZW4ubGVuZ3RoIC0gMSwgbGFzdCwgbG9va0FoZWFkUHJvcDtcclxuICAgICAgICAgICAgaWYgKGxhc3RJID49IDAgJiYgKGxhc3QgPSBjaGlsZHJlbltsYXN0SV0pIGluc3RhbmNlb2YgVHJlZSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFsYXN0SSAmJiBsYXN0LnR5cGUgPT0gdHlwZSAmJiBsYXN0Lmxlbmd0aCA9PSBsZW5ndGgpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGxhc3Q7XHJcbiAgICAgICAgICAgICAgICBpZiAobG9va0FoZWFkUHJvcCA9IGxhc3QucHJvcChOb2RlUHJvcC5sb29rQWhlYWQpKVxyXG4gICAgICAgICAgICAgICAgICAgIGxvb2tBaGVhZCA9IHBvc2l0aW9uc1tsYXN0SV0gKyBsYXN0Lmxlbmd0aCArIGxvb2tBaGVhZFByb3A7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIG1ha2VUcmVlKHR5cGUsIGNoaWxkcmVuLCBwb3NpdGlvbnMsIGxlbmd0aCwgbG9va0FoZWFkKTtcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gbWFrZVJlcGVhdExlYWYoY2hpbGRyZW4sIHBvc2l0aW9ucywgYmFzZSwgaSwgZnJvbSwgdG8sIHR5cGUsIGxvb2tBaGVhZCkge1xyXG4gICAgICAgIGxldCBsb2NhbENoaWxkcmVuID0gW10sIGxvY2FsUG9zaXRpb25zID0gW107XHJcbiAgICAgICAgd2hpbGUgKGNoaWxkcmVuLmxlbmd0aCA+IGkpIHtcclxuICAgICAgICAgICAgbG9jYWxDaGlsZHJlbi5wdXNoKGNoaWxkcmVuLnBvcCgpKTtcclxuICAgICAgICAgICAgbG9jYWxQb3NpdGlvbnMucHVzaChwb3NpdGlvbnMucG9wKCkgKyBiYXNlIC0gZnJvbSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNoaWxkcmVuLnB1c2gobWFrZVRyZWUobm9kZVNldC50eXBlc1t0eXBlXSwgbG9jYWxDaGlsZHJlbiwgbG9jYWxQb3NpdGlvbnMsIHRvIC0gZnJvbSwgbG9va0FoZWFkIC0gdG8pKTtcclxuICAgICAgICBwb3NpdGlvbnMucHVzaChmcm9tIC0gYmFzZSk7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBtYWtlVHJlZSh0eXBlLCBjaGlsZHJlbiwgcG9zaXRpb25zLCBsZW5ndGgsIGxvb2tBaGVhZCA9IDAsIHByb3BzKSB7XHJcbiAgICAgICAgaWYgKGNvbnRleHRIYXNoKSB7XHJcbiAgICAgICAgICAgIGxldCBwYWlyID0gW05vZGVQcm9wLmNvbnRleHRIYXNoLCBjb250ZXh0SGFzaF07XHJcbiAgICAgICAgICAgIHByb3BzID0gcHJvcHMgPyBbcGFpcl0uY29uY2F0KHByb3BzKSA6IFtwYWlyXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGxvb2tBaGVhZCA+IDI1KSB7XHJcbiAgICAgICAgICAgIGxldCBwYWlyID0gW05vZGVQcm9wLmxvb2tBaGVhZCwgbG9va0FoZWFkXTtcclxuICAgICAgICAgICAgcHJvcHMgPSBwcm9wcyA/IFtwYWlyXS5jb25jYXQocHJvcHMpIDogW3BhaXJdO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbmV3IFRyZWUodHlwZSwgY2hpbGRyZW4sIHBvc2l0aW9ucywgbGVuZ3RoLCBwcm9wcyk7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBmaW5kQnVmZmVyU2l6ZShtYXhTaXplLCBpblJlcGVhdCkge1xyXG4gICAgICAgIC8vIFNjYW4gdGhyb3VnaCB0aGUgYnVmZmVyIHRvIGZpbmQgcHJldmlvdXMgc2libGluZ3MgdGhhdCBmaXRcclxuICAgICAgICAvLyB0b2dldGhlciBpbiBhIFRyZWVCdWZmZXIsIGFuZCBkb24ndCBjb250YWluIGFueSByZXVzZWQgbm9kZXNcclxuICAgICAgICAvLyAod2hpY2ggY2FuJ3QgYmUgc3RvcmVkIGluIGEgYnVmZmVyKS5cclxuICAgICAgICAvLyBJZiBgaW5SZXBlYXRgIGlzID4gLTEsIGlnbm9yZSBub2RlIGJvdW5kYXJpZXMgb2YgdGhhdCB0eXBlIGZvclxyXG4gICAgICAgIC8vIG5lc3RpbmcsIGJ1dCBtYWtlIHN1cmUgdGhlIGVuZCBmYWxscyBlaXRoZXIgYXQgdGhlIHN0YXJ0XHJcbiAgICAgICAgLy8gKGBtYXhTaXplYCkgb3IgYmVmb3JlIHN1Y2ggYSBub2RlLlxyXG4gICAgICAgIGxldCBmb3JrID0gY3Vyc29yLmZvcmsoKTtcclxuICAgICAgICBsZXQgc2l6ZSA9IDAsIHN0YXJ0ID0gMCwgc2tpcCA9IDAsIG1pblN0YXJ0ID0gZm9yay5lbmQgLSBtYXhCdWZmZXJMZW5ndGg7XHJcbiAgICAgICAgbGV0IHJlc3VsdCA9IHsgc2l6ZTogMCwgc3RhcnQ6IDAsIHNraXA6IDAgfTtcclxuICAgICAgICBzY2FuOiBmb3IgKGxldCBtaW5Qb3MgPSBmb3JrLnBvcyAtIG1heFNpemU7IGZvcmsucG9zID4gbWluUG9zOykge1xyXG4gICAgICAgICAgICBsZXQgbm9kZVNpemUgPSBmb3JrLnNpemU7XHJcbiAgICAgICAgICAgIC8vIFByZXRlbmQgbmVzdGVkIHJlcGVhdCBub2RlcyBvZiB0aGUgc2FtZSB0eXBlIGRvbid0IGV4aXN0XHJcbiAgICAgICAgICAgIGlmIChmb3JrLmlkID09IGluUmVwZWF0ICYmIG5vZGVTaXplID49IDApIHtcclxuICAgICAgICAgICAgICAgIC8vIEV4Y2VwdCB0aGF0IHdlIHN0b3JlIHRoZSBjdXJyZW50IHN0YXRlIGFzIGEgdmFsaWQgcmV0dXJuXHJcbiAgICAgICAgICAgICAgICAvLyB2YWx1ZS5cclxuICAgICAgICAgICAgICAgIHJlc3VsdC5zaXplID0gc2l6ZTtcclxuICAgICAgICAgICAgICAgIHJlc3VsdC5zdGFydCA9IHN0YXJ0O1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0LnNraXAgPSBza2lwO1xyXG4gICAgICAgICAgICAgICAgc2tpcCArPSA0O1xyXG4gICAgICAgICAgICAgICAgc2l6ZSArPSA0O1xyXG4gICAgICAgICAgICAgICAgZm9yay5uZXh0KCk7XHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBsZXQgc3RhcnRQb3MgPSBmb3JrLnBvcyAtIG5vZGVTaXplO1xyXG4gICAgICAgICAgICBpZiAobm9kZVNpemUgPCAwIHx8IHN0YXJ0UG9zIDwgbWluUG9zIHx8IGZvcmsuc3RhcnQgPCBtaW5TdGFydClcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBsZXQgbG9jYWxTa2lwcGVkID0gZm9yay5pZCA+PSBtaW5SZXBlYXRUeXBlID8gNCA6IDA7XHJcbiAgICAgICAgICAgIGxldCBub2RlU3RhcnQgPSBmb3JrLnN0YXJ0O1xyXG4gICAgICAgICAgICBmb3JrLm5leHQoKTtcclxuICAgICAgICAgICAgd2hpbGUgKGZvcmsucG9zID4gc3RhcnRQb3MpIHtcclxuICAgICAgICAgICAgICAgIGlmIChmb3JrLnNpemUgPCAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZvcmsuc2l6ZSA9PSAtMyAvKiBTcGVjaWFsUmVjb3JkLkNvbnRleHRDaGFuZ2UgKi8pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvY2FsU2tpcHBlZCArPSA0O1xyXG4gICAgICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWsgc2NhbjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGZvcmsuaWQgPj0gbWluUmVwZWF0VHlwZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGxvY2FsU2tpcHBlZCArPSA0O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZm9yay5uZXh0KCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgc3RhcnQgPSBub2RlU3RhcnQ7XHJcbiAgICAgICAgICAgIHNpemUgKz0gbm9kZVNpemU7XHJcbiAgICAgICAgICAgIHNraXAgKz0gbG9jYWxTa2lwcGVkO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoaW5SZXBlYXQgPCAwIHx8IHNpemUgPT0gbWF4U2l6ZSkge1xyXG4gICAgICAgICAgICByZXN1bHQuc2l6ZSA9IHNpemU7XHJcbiAgICAgICAgICAgIHJlc3VsdC5zdGFydCA9IHN0YXJ0O1xyXG4gICAgICAgICAgICByZXN1bHQuc2tpcCA9IHNraXA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXN1bHQuc2l6ZSA+IDQgPyByZXN1bHQgOiB1bmRlZmluZWQ7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBjb3B5VG9CdWZmZXIoYnVmZmVyU3RhcnQsIGJ1ZmZlciwgaW5kZXgpIHtcclxuICAgICAgICBsZXQgeyBpZCwgc3RhcnQsIGVuZCwgc2l6ZSB9ID0gY3Vyc29yO1xyXG4gICAgICAgIGN1cnNvci5uZXh0KCk7XHJcbiAgICAgICAgaWYgKHNpemUgPj0gMCAmJiBpZCA8IG1pblJlcGVhdFR5cGUpIHtcclxuICAgICAgICAgICAgbGV0IHN0YXJ0SW5kZXggPSBpbmRleDtcclxuICAgICAgICAgICAgaWYgKHNpemUgPiA0KSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgZW5kUG9zID0gY3Vyc29yLnBvcyAtIChzaXplIC0gNCk7XHJcbiAgICAgICAgICAgICAgICB3aGlsZSAoY3Vyc29yLnBvcyA+IGVuZFBvcylcclxuICAgICAgICAgICAgICAgICAgICBpbmRleCA9IGNvcHlUb0J1ZmZlcihidWZmZXJTdGFydCwgYnVmZmVyLCBpbmRleCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgYnVmZmVyWy0taW5kZXhdID0gc3RhcnRJbmRleDtcclxuICAgICAgICAgICAgYnVmZmVyWy0taW5kZXhdID0gZW5kIC0gYnVmZmVyU3RhcnQ7XHJcbiAgICAgICAgICAgIGJ1ZmZlclstLWluZGV4XSA9IHN0YXJ0IC0gYnVmZmVyU3RhcnQ7XHJcbiAgICAgICAgICAgIGJ1ZmZlclstLWluZGV4XSA9IGlkO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChzaXplID09IC0zIC8qIFNwZWNpYWxSZWNvcmQuQ29udGV4dENoYW5nZSAqLykge1xyXG4gICAgICAgICAgICBjb250ZXh0SGFzaCA9IGlkO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChzaXplID09IC00IC8qIFNwZWNpYWxSZWNvcmQuTG9va0FoZWFkICovKSB7XHJcbiAgICAgICAgICAgIGxvb2tBaGVhZCA9IGlkO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gaW5kZXg7XHJcbiAgICB9XHJcbiAgICBsZXQgY2hpbGRyZW4gPSBbXSwgcG9zaXRpb25zID0gW107XHJcbiAgICB3aGlsZSAoY3Vyc29yLnBvcyA+IDApXHJcbiAgICAgICAgdGFrZU5vZGUoZGF0YS5zdGFydCB8fCAwLCBkYXRhLmJ1ZmZlclN0YXJ0IHx8IDAsIGNoaWxkcmVuLCBwb3NpdGlvbnMsIC0xKTtcclxuICAgIGxldCBsZW5ndGggPSAoX2EgPSBkYXRhLmxlbmd0aCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogKGNoaWxkcmVuLmxlbmd0aCA/IHBvc2l0aW9uc1swXSArIGNoaWxkcmVuWzBdLmxlbmd0aCA6IDApO1xyXG4gICAgcmV0dXJuIG5ldyBUcmVlKHR5cGVzW2RhdGEudG9wSURdLCBjaGlsZHJlbi5yZXZlcnNlKCksIHBvc2l0aW9ucy5yZXZlcnNlKCksIGxlbmd0aCk7XHJcbn1cclxuY29uc3Qgbm9kZVNpemVDYWNoZSA9IG5ldyBXZWFrTWFwO1xyXG5mdW5jdGlvbiBub2RlU2l6ZShiYWxhbmNlVHlwZSwgbm9kZSkge1xyXG4gICAgaWYgKCFiYWxhbmNlVHlwZS5pc0Fub255bW91cyB8fCBub2RlIGluc3RhbmNlb2YgVHJlZUJ1ZmZlciB8fCBub2RlLnR5cGUgIT0gYmFsYW5jZVR5cGUpXHJcbiAgICAgICAgcmV0dXJuIDE7XHJcbiAgICBsZXQgc2l6ZSA9IG5vZGVTaXplQ2FjaGUuZ2V0KG5vZGUpO1xyXG4gICAgaWYgKHNpemUgPT0gbnVsbCkge1xyXG4gICAgICAgIHNpemUgPSAxO1xyXG4gICAgICAgIGZvciAobGV0IGNoaWxkIG9mIG5vZGUuY2hpbGRyZW4pIHtcclxuICAgICAgICAgICAgaWYgKGNoaWxkLnR5cGUgIT0gYmFsYW5jZVR5cGUgfHwgIShjaGlsZCBpbnN0YW5jZW9mIFRyZWUpKSB7XHJcbiAgICAgICAgICAgICAgICBzaXplID0gMTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHNpemUgKz0gbm9kZVNpemUoYmFsYW5jZVR5cGUsIGNoaWxkKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbm9kZVNpemVDYWNoZS5zZXQobm9kZSwgc2l6ZSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gc2l6ZTtcclxufVxyXG5mdW5jdGlvbiBiYWxhbmNlUmFuZ2UoXHJcbi8vIFRoZSB0eXBlIHRoZSBiYWxhbmNlZCB0cmVlJ3MgaW5uZXIgbm9kZXMuXHJcbmJhbGFuY2VUeXBlLCBcclxuLy8gVGhlIGRpcmVjdCBjaGlsZHJlbiBhbmQgdGhlaXIgcG9zaXRpb25zXHJcbmNoaWxkcmVuLCBwb3NpdGlvbnMsIFxyXG4vLyBUaGUgaW5kZXggcmFuZ2UgaW4gY2hpbGRyZW4vcG9zaXRpb25zIHRvIHVzZVxyXG5mcm9tLCB0bywgXHJcbi8vIFRoZSBzdGFydCBwb3NpdGlvbiBvZiB0aGUgbm9kZXMsIHJlbGF0aXZlIHRvIHRoZWlyIHBhcmVudC5cclxuc3RhcnQsIFxyXG4vLyBMZW5ndGggb2YgdGhlIG91dGVyIG5vZGVcclxubGVuZ3RoLCBcclxuLy8gRnVuY3Rpb24gdG8gYnVpbGQgdGhlIHRvcCBub2RlIG9mIHRoZSBiYWxhbmNlZCB0cmVlXHJcbm1rVG9wLCBcclxuLy8gRnVuY3Rpb24gdG8gYnVpbGQgaW50ZXJuYWwgbm9kZXMgZm9yIHRoZSBiYWxhbmNlZCB0cmVlXHJcbm1rVHJlZSkge1xyXG4gICAgbGV0IHRvdGFsID0gMDtcclxuICAgIGZvciAobGV0IGkgPSBmcm9tOyBpIDwgdG87IGkrKylcclxuICAgICAgICB0b3RhbCArPSBub2RlU2l6ZShiYWxhbmNlVHlwZSwgY2hpbGRyZW5baV0pO1xyXG4gICAgbGV0IG1heENoaWxkID0gTWF0aC5jZWlsKCh0b3RhbCAqIDEuNSkgLyA4IC8qIEJhbGFuY2UuQnJhbmNoRmFjdG9yICovKTtcclxuICAgIGxldCBsb2NhbENoaWxkcmVuID0gW10sIGxvY2FsUG9zaXRpb25zID0gW107XHJcbiAgICBmdW5jdGlvbiBkaXZpZGUoY2hpbGRyZW4sIHBvc2l0aW9ucywgZnJvbSwgdG8sIG9mZnNldCkge1xyXG4gICAgICAgIGZvciAobGV0IGkgPSBmcm9tOyBpIDwgdG87KSB7XHJcbiAgICAgICAgICAgIGxldCBncm91cEZyb20gPSBpLCBncm91cFN0YXJ0ID0gcG9zaXRpb25zW2ldLCBncm91cFNpemUgPSBub2RlU2l6ZShiYWxhbmNlVHlwZSwgY2hpbGRyZW5baV0pO1xyXG4gICAgICAgICAgICBpKys7XHJcbiAgICAgICAgICAgIGZvciAoOyBpIDwgdG87IGkrKykge1xyXG4gICAgICAgICAgICAgICAgbGV0IG5leHRTaXplID0gbm9kZVNpemUoYmFsYW5jZVR5cGUsIGNoaWxkcmVuW2ldKTtcclxuICAgICAgICAgICAgICAgIGlmIChncm91cFNpemUgKyBuZXh0U2l6ZSA+PSBtYXhDaGlsZClcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGdyb3VwU2l6ZSArPSBuZXh0U2l6ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoaSA9PSBncm91cEZyb20gKyAxKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZ3JvdXBTaXplID4gbWF4Q2hpbGQpIHtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgb25seSA9IGNoaWxkcmVuW2dyb3VwRnJvbV07IC8vIE9ubHkgdHJlZXMgY2FuIGhhdmUgYSBzaXplID4gMVxyXG4gICAgICAgICAgICAgICAgICAgIGRpdmlkZShvbmx5LmNoaWxkcmVuLCBvbmx5LnBvc2l0aW9ucywgMCwgb25seS5jaGlsZHJlbi5sZW5ndGgsIHBvc2l0aW9uc1tncm91cEZyb21dICsgb2Zmc2V0KTtcclxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGxvY2FsQ2hpbGRyZW4ucHVzaChjaGlsZHJlbltncm91cEZyb21dKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGxldCBsZW5ndGggPSBwb3NpdGlvbnNbaSAtIDFdICsgY2hpbGRyZW5baSAtIDFdLmxlbmd0aCAtIGdyb3VwU3RhcnQ7XHJcbiAgICAgICAgICAgICAgICBsb2NhbENoaWxkcmVuLnB1c2goYmFsYW5jZVJhbmdlKGJhbGFuY2VUeXBlLCBjaGlsZHJlbiwgcG9zaXRpb25zLCBncm91cEZyb20sIGksIGdyb3VwU3RhcnQsIGxlbmd0aCwgbnVsbCwgbWtUcmVlKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbG9jYWxQb3NpdGlvbnMucHVzaChncm91cFN0YXJ0ICsgb2Zmc2V0IC0gc3RhcnQpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGRpdmlkZShjaGlsZHJlbiwgcG9zaXRpb25zLCBmcm9tLCB0bywgMCk7XHJcbiAgICByZXR1cm4gKG1rVG9wIHx8IG1rVHJlZSkobG9jYWxDaGlsZHJlbiwgbG9jYWxQb3NpdGlvbnMsIGxlbmd0aCk7XHJcbn1cclxuLy8vIFByb3ZpZGVzIGEgd2F5IHRvIGFzc29jaWF0ZSB2YWx1ZXMgd2l0aCBwaWVjZXMgb2YgdHJlZXMuIEFzIGxvbmdcclxuLy8vIGFzIHRoYXQgcGFydCBvZiB0aGUgdHJlZSBpcyByZXVzZWQsIHRoZSBhc3NvY2lhdGVkIHZhbHVlcyBjYW4gYmVcclxuLy8vIHJldHJpZXZlZCBmcm9tIGFuIHVwZGF0ZWQgdHJlZS5cclxuY2xhc3MgTm9kZVdlYWtNYXAge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgdGhpcy5tYXAgPSBuZXcgV2Vha01hcCgpO1xyXG4gICAgfVxyXG4gICAgc2V0QnVmZmVyKGJ1ZmZlciwgaW5kZXgsIHZhbHVlKSB7XHJcbiAgICAgICAgbGV0IGlubmVyID0gdGhpcy5tYXAuZ2V0KGJ1ZmZlcik7XHJcbiAgICAgICAgaWYgKCFpbm5lcilcclxuICAgICAgICAgICAgdGhpcy5tYXAuc2V0KGJ1ZmZlciwgaW5uZXIgPSBuZXcgTWFwKTtcclxuICAgICAgICBpbm5lci5zZXQoaW5kZXgsIHZhbHVlKTtcclxuICAgIH1cclxuICAgIGdldEJ1ZmZlcihidWZmZXIsIGluZGV4KSB7XHJcbiAgICAgICAgbGV0IGlubmVyID0gdGhpcy5tYXAuZ2V0KGJ1ZmZlcik7XHJcbiAgICAgICAgcmV0dXJuIGlubmVyICYmIGlubmVyLmdldChpbmRleCk7XHJcbiAgICB9XHJcbiAgICAvLy8gU2V0IHRoZSB2YWx1ZSBmb3IgdGhpcyBzeW50YXggbm9kZS5cclxuICAgIHNldChub2RlLCB2YWx1ZSkge1xyXG4gICAgICAgIGlmIChub2RlIGluc3RhbmNlb2YgQnVmZmVyTm9kZSlcclxuICAgICAgICAgICAgdGhpcy5zZXRCdWZmZXIobm9kZS5jb250ZXh0LmJ1ZmZlciwgbm9kZS5pbmRleCwgdmFsdWUpO1xyXG4gICAgICAgIGVsc2UgaWYgKG5vZGUgaW5zdGFuY2VvZiBUcmVlTm9kZSlcclxuICAgICAgICAgICAgdGhpcy5tYXAuc2V0KG5vZGUudHJlZSwgdmFsdWUpO1xyXG4gICAgfVxyXG4gICAgLy8vIFJldHJpZXZlIHZhbHVlIGZvciB0aGlzIHN5bnRheCBub2RlLCBpZiBpdCBleGlzdHMgaW4gdGhlIG1hcC5cclxuICAgIGdldChub2RlKSB7XHJcbiAgICAgICAgcmV0dXJuIG5vZGUgaW5zdGFuY2VvZiBCdWZmZXJOb2RlID8gdGhpcy5nZXRCdWZmZXIobm9kZS5jb250ZXh0LmJ1ZmZlciwgbm9kZS5pbmRleClcclxuICAgICAgICAgICAgOiBub2RlIGluc3RhbmNlb2YgVHJlZU5vZGUgPyB0aGlzLm1hcC5nZXQobm9kZS50cmVlKSA6IHVuZGVmaW5lZDtcclxuICAgIH1cclxuICAgIC8vLyBTZXQgdGhlIHZhbHVlIGZvciB0aGUgbm9kZSB0aGF0IGEgY3Vyc29yIGN1cnJlbnRseSBwb2ludHMgdG8uXHJcbiAgICBjdXJzb3JTZXQoY3Vyc29yLCB2YWx1ZSkge1xyXG4gICAgICAgIGlmIChjdXJzb3IuYnVmZmVyKVxyXG4gICAgICAgICAgICB0aGlzLnNldEJ1ZmZlcihjdXJzb3IuYnVmZmVyLmJ1ZmZlciwgY3Vyc29yLmluZGV4LCB2YWx1ZSk7XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICB0aGlzLm1hcC5zZXQoY3Vyc29yLnRyZWUsIHZhbHVlKTtcclxuICAgIH1cclxuICAgIC8vLyBSZXRyaWV2ZSB0aGUgdmFsdWUgZm9yIHRoZSBub2RlIHRoYXQgYSBjdXJzb3IgY3VycmVudGx5IHBvaW50c1xyXG4gICAgLy8vIHRvLlxyXG4gICAgY3Vyc29yR2V0KGN1cnNvcikge1xyXG4gICAgICAgIHJldHVybiBjdXJzb3IuYnVmZmVyID8gdGhpcy5nZXRCdWZmZXIoY3Vyc29yLmJ1ZmZlci5idWZmZXIsIGN1cnNvci5pbmRleCkgOiB0aGlzLm1hcC5nZXQoY3Vyc29yLnRyZWUpO1xyXG4gICAgfVxyXG59XHJcblxyXG4vLy8gVHJlZSBmcmFnbWVudHMgYXJlIHVzZWQgZHVyaW5nIFtpbmNyZW1lbnRhbFxyXG4vLy8gcGFyc2luZ10oI2NvbW1vbi5QYXJzZXIuc3RhcnRQYXJzZSkgdG8gdHJhY2sgcGFydHMgb2Ygb2xkIHRyZWVzXHJcbi8vLyB0aGF0IGNhbiBiZSByZXVzZWQgaW4gYSBuZXcgcGFyc2UuIEFuIGFycmF5IG9mIGZyYWdtZW50cyBpcyB1c2VkXHJcbi8vLyB0byB0cmFjayByZWdpb25zIG9mIGFuIG9sZCB0cmVlIHdob3NlIG5vZGVzIG1pZ2h0IGJlIHJldXNlZCBpbiBuZXdcclxuLy8vIHBhcnNlcy4gVXNlIHRoZSBzdGF0aWNcclxuLy8vIFtgYXBwbHlDaGFuZ2VzYF0oI2NvbW1vbi5UcmVlRnJhZ21lbnReYXBwbHlDaGFuZ2VzKSBtZXRob2QgdG9cclxuLy8vIHVwZGF0ZSBmcmFnbWVudHMgZm9yIGRvY3VtZW50IGNoYW5nZXMuXHJcbmNsYXNzIFRyZWVGcmFnbWVudCB7XHJcbiAgICAvLy8gQ29uc3RydWN0IGEgdHJlZSBmcmFnbWVudC4gWW91J2xsIHVzdWFsbHkgd2FudCB0byB1c2VcclxuICAgIC8vLyBbYGFkZFRyZWVgXSgjY29tbW9uLlRyZWVGcmFnbWVudF5hZGRUcmVlKSBhbmRcclxuICAgIC8vLyBbYGFwcGx5Q2hhbmdlc2BdKCNjb21tb24uVHJlZUZyYWdtZW50XmFwcGx5Q2hhbmdlcykgaW5zdGVhZCBvZlxyXG4gICAgLy8vIGNhbGxpbmcgdGhpcyBkaXJlY3RseS5cclxuICAgIGNvbnN0cnVjdG9yKFxyXG4gICAgLy8vIFRoZSBzdGFydCBvZiB0aGUgdW5jaGFuZ2VkIHJhbmdlIHBvaW50ZWQgdG8gYnkgdGhpcyBmcmFnbWVudC5cclxuICAgIC8vLyBUaGlzIHJlZmVycyB0byBhbiBvZmZzZXQgaW4gdGhlIF91cGRhdGVkXyBkb2N1bWVudCAoYXMgb3Bwb3NlZFxyXG4gICAgLy8vIHRvIHRoZSBvcmlnaW5hbCB0cmVlKS5cclxuICAgIGZyb20sIFxyXG4gICAgLy8vIFRoZSBlbmQgb2YgdGhlIHVuY2hhbmdlZCByYW5nZS5cclxuICAgIHRvLCBcclxuICAgIC8vLyBUaGUgdHJlZSB0aGF0IHRoaXMgZnJhZ21lbnQgaXMgYmFzZWQgb24uXHJcbiAgICB0cmVlLCBcclxuICAgIC8vLyBUaGUgb2Zmc2V0IGJldHdlZW4gdGhlIGZyYWdtZW50J3MgdHJlZSBhbmQgdGhlIGRvY3VtZW50IHRoYXRcclxuICAgIC8vLyB0aGlzIGZyYWdtZW50IGNhbiBiZSB1c2VkIGFnYWluc3QuIEFkZCB0aGlzIHdoZW4gZ29pbmcgZnJvbVxyXG4gICAgLy8vIGRvY3VtZW50IHRvIHRyZWUgcG9zaXRpb25zLCBzdWJ0cmFjdCBpdCB0byBnbyBmcm9tIHRyZWUgdG9cclxuICAgIC8vLyBkb2N1bWVudCBwb3NpdGlvbnMuXHJcbiAgICBvZmZzZXQsIG9wZW5TdGFydCA9IGZhbHNlLCBvcGVuRW5kID0gZmFsc2UpIHtcclxuICAgICAgICB0aGlzLmZyb20gPSBmcm9tO1xyXG4gICAgICAgIHRoaXMudG8gPSB0bztcclxuICAgICAgICB0aGlzLnRyZWUgPSB0cmVlO1xyXG4gICAgICAgIHRoaXMub2Zmc2V0ID0gb2Zmc2V0O1xyXG4gICAgICAgIHRoaXMub3BlbiA9IChvcGVuU3RhcnQgPyAxIC8qIE9wZW4uU3RhcnQgKi8gOiAwKSB8IChvcGVuRW5kID8gMiAvKiBPcGVuLkVuZCAqLyA6IDApO1xyXG4gICAgfVxyXG4gICAgLy8vIFdoZXRoZXIgdGhlIHN0YXJ0IG9mIHRoZSBmcmFnbWVudCByZXByZXNlbnRzIHRoZSBzdGFydCBvZiBhXHJcbiAgICAvLy8gcGFyc2UsIG9yIHRoZSBlbmQgb2YgYSBjaGFuZ2UuIChJbiB0aGUgc2Vjb25kIGNhc2UsIGl0IG1heSBub3RcclxuICAgIC8vLyBiZSBzYWZlIHRvIHJldXNlIHNvbWUgbm9kZXMgYXQgdGhlIHN0YXJ0LCBkZXBlbmRpbmcgb24gdGhlXHJcbiAgICAvLy8gcGFyc2luZyBhbGdvcml0aG0uKVxyXG4gICAgZ2V0IG9wZW5TdGFydCgpIHsgcmV0dXJuICh0aGlzLm9wZW4gJiAxIC8qIE9wZW4uU3RhcnQgKi8pID4gMDsgfVxyXG4gICAgLy8vIFdoZXRoZXIgdGhlIGVuZCBvZiB0aGUgZnJhZ21lbnQgcmVwcmVzZW50cyB0aGUgZW5kIG9mIGFcclxuICAgIC8vLyBmdWxsLWRvY3VtZW50IHBhcnNlLCBvciB0aGUgc3RhcnQgb2YgYSBjaGFuZ2UuXHJcbiAgICBnZXQgb3BlbkVuZCgpIHsgcmV0dXJuICh0aGlzLm9wZW4gJiAyIC8qIE9wZW4uRW5kICovKSA+IDA7IH1cclxuICAgIC8vLyBDcmVhdGUgYSBzZXQgb2YgZnJhZ21lbnRzIGZyb20gYSBmcmVzaGx5IHBhcnNlZCB0cmVlLCBvciB1cGRhdGVcclxuICAgIC8vLyBhbiBleGlzdGluZyBzZXQgb2YgZnJhZ21lbnRzIGJ5IHJlcGxhY2luZyB0aGUgb25lcyB0aGF0IG92ZXJsYXBcclxuICAgIC8vLyB3aXRoIGEgdHJlZSB3aXRoIGNvbnRlbnQgZnJvbSB0aGUgbmV3IHRyZWUuIFdoZW4gYHBhcnRpYWxgIGlzXHJcbiAgICAvLy8gdHJ1ZSwgdGhlIHBhcnNlIGlzIHRyZWF0ZWQgYXMgaW5jb21wbGV0ZSwgYW5kIHRoZSByZXN1bHRpbmdcclxuICAgIC8vLyBmcmFnbWVudCBoYXMgW2BvcGVuRW5kYF0oI2NvbW1vbi5UcmVlRnJhZ21lbnQub3BlbkVuZCkgc2V0IHRvXHJcbiAgICAvLy8gdHJ1ZS5cclxuICAgIHN0YXRpYyBhZGRUcmVlKHRyZWUsIGZyYWdtZW50cyA9IFtdLCBwYXJ0aWFsID0gZmFsc2UpIHtcclxuICAgICAgICBsZXQgcmVzdWx0ID0gW25ldyBUcmVlRnJhZ21lbnQoMCwgdHJlZS5sZW5ndGgsIHRyZWUsIDAsIGZhbHNlLCBwYXJ0aWFsKV07XHJcbiAgICAgICAgZm9yIChsZXQgZiBvZiBmcmFnbWVudHMpXHJcbiAgICAgICAgICAgIGlmIChmLnRvID4gdHJlZS5sZW5ndGgpXHJcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChmKTtcclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG4gICAgLy8vIEFwcGx5IGEgc2V0IG9mIGVkaXRzIHRvIGFuIGFycmF5IG9mIGZyYWdtZW50cywgcmVtb3Zpbmcgb3JcclxuICAgIC8vLyBzcGxpdHRpbmcgZnJhZ21lbnRzIGFzIG5lY2Vzc2FyeSB0byByZW1vdmUgZWRpdGVkIHJhbmdlcywgYW5kXHJcbiAgICAvLy8gYWRqdXN0aW5nIG9mZnNldHMgZm9yIGZyYWdtZW50cyB0aGF0IG1vdmVkLlxyXG4gICAgc3RhdGljIGFwcGx5Q2hhbmdlcyhmcmFnbWVudHMsIGNoYW5nZXMsIG1pbkdhcCA9IDEyOCkge1xyXG4gICAgICAgIGlmICghY2hhbmdlcy5sZW5ndGgpXHJcbiAgICAgICAgICAgIHJldHVybiBmcmFnbWVudHM7XHJcbiAgICAgICAgbGV0IHJlc3VsdCA9IFtdO1xyXG4gICAgICAgIGxldCBmSSA9IDEsIG5leHRGID0gZnJhZ21lbnRzLmxlbmd0aCA/IGZyYWdtZW50c1swXSA6IG51bGw7XHJcbiAgICAgICAgZm9yIChsZXQgY0kgPSAwLCBwb3MgPSAwLCBvZmYgPSAwOzsgY0krKykge1xyXG4gICAgICAgICAgICBsZXQgbmV4dEMgPSBjSSA8IGNoYW5nZXMubGVuZ3RoID8gY2hhbmdlc1tjSV0gOiBudWxsO1xyXG4gICAgICAgICAgICBsZXQgbmV4dFBvcyA9IG5leHRDID8gbmV4dEMuZnJvbUEgOiAxZTk7XHJcbiAgICAgICAgICAgIGlmIChuZXh0UG9zIC0gcG9zID49IG1pbkdhcClcclxuICAgICAgICAgICAgICAgIHdoaWxlIChuZXh0RiAmJiBuZXh0Ri5mcm9tIDwgbmV4dFBvcykge1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBjdXQgPSBuZXh0RjtcclxuICAgICAgICAgICAgICAgICAgICBpZiAocG9zID49IGN1dC5mcm9tIHx8IG5leHRQb3MgPD0gY3V0LnRvIHx8IG9mZikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgZkZyb20gPSBNYXRoLm1heChjdXQuZnJvbSwgcG9zKSAtIG9mZiwgZlRvID0gTWF0aC5taW4oY3V0LnRvLCBuZXh0UG9zKSAtIG9mZjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY3V0ID0gZkZyb20gPj0gZlRvID8gbnVsbCA6IG5ldyBUcmVlRnJhZ21lbnQoZkZyb20sIGZUbywgY3V0LnRyZWUsIGN1dC5vZmZzZXQgKyBvZmYsIGNJID4gMCwgISFuZXh0Qyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjdXQpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGN1dCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5leHRGLnRvID4gbmV4dFBvcylcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgbmV4dEYgPSBmSSA8IGZyYWdtZW50cy5sZW5ndGggPyBmcmFnbWVudHNbZkkrK10gOiBudWxsO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoIW5leHRDKVxyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIHBvcyA9IG5leHRDLnRvQTtcclxuICAgICAgICAgICAgb2ZmID0gbmV4dEMudG9BIC0gbmV4dEMudG9CO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG59XHJcbi8vLyBBIHN1cGVyY2xhc3MgdGhhdCBwYXJzZXJzIHNob3VsZCBleHRlbmQuXHJcbmNsYXNzIFBhcnNlciB7XHJcbiAgICAvLy8gU3RhcnQgYSBwYXJzZSwgcmV0dXJuaW5nIGEgW3BhcnRpYWwgcGFyc2VdKCNjb21tb24uUGFydGlhbFBhcnNlKVxyXG4gICAgLy8vIG9iamVjdC4gW2BmcmFnbWVudHNgXSgjY29tbW9uLlRyZWVGcmFnbWVudCkgY2FuIGJlIHBhc3NlZCBpbiB0b1xyXG4gICAgLy8vIG1ha2UgdGhlIHBhcnNlIGluY3JlbWVudGFsLlxyXG4gICAgLy8vXHJcbiAgICAvLy8gQnkgZGVmYXVsdCwgdGhlIGVudGlyZSBpbnB1dCBpcyBwYXJzZWQuIFlvdSBjYW4gcGFzcyBgcmFuZ2VzYCxcclxuICAgIC8vLyB3aGljaCBzaG91bGQgYmUgYSBzb3J0ZWQgYXJyYXkgb2Ygbm9uLWVtcHR5LCBub24tb3ZlcmxhcHBpbmdcclxuICAgIC8vLyByYW5nZXMsIHRvIHBhcnNlIG9ubHkgdGhvc2UgcmFuZ2VzLiBUaGUgdHJlZSByZXR1cm5lZCBpbiB0aGF0XHJcbiAgICAvLy8gY2FzZSB3aWxsIHN0YXJ0IGF0IGByYW5nZXNbMF0uZnJvbWAuXHJcbiAgICBzdGFydFBhcnNlKGlucHV0LCBmcmFnbWVudHMsIHJhbmdlcykge1xyXG4gICAgICAgIGlmICh0eXBlb2YgaW5wdXQgPT0gXCJzdHJpbmdcIilcclxuICAgICAgICAgICAgaW5wdXQgPSBuZXcgU3RyaW5nSW5wdXQoaW5wdXQpO1xyXG4gICAgICAgIHJhbmdlcyA9ICFyYW5nZXMgPyBbbmV3IFJhbmdlKDAsIGlucHV0Lmxlbmd0aCldIDogcmFuZ2VzLmxlbmd0aCA/IHJhbmdlcy5tYXAociA9PiBuZXcgUmFuZ2Uoci5mcm9tLCByLnRvKSkgOiBbbmV3IFJhbmdlKDAsIDApXTtcclxuICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVQYXJzZShpbnB1dCwgZnJhZ21lbnRzIHx8IFtdLCByYW5nZXMpO1xyXG4gICAgfVxyXG4gICAgLy8vIFJ1biBhIGZ1bGwgcGFyc2UsIHJldHVybmluZyB0aGUgcmVzdWx0aW5nIHRyZWUuXHJcbiAgICBwYXJzZShpbnB1dCwgZnJhZ21lbnRzLCByYW5nZXMpIHtcclxuICAgICAgICBsZXQgcGFyc2UgPSB0aGlzLnN0YXJ0UGFyc2UoaW5wdXQsIGZyYWdtZW50cywgcmFuZ2VzKTtcclxuICAgICAgICBmb3IgKDs7KSB7XHJcbiAgICAgICAgICAgIGxldCBkb25lID0gcGFyc2UuYWR2YW5jZSgpO1xyXG4gICAgICAgICAgICBpZiAoZG9uZSlcclxuICAgICAgICAgICAgICAgIHJldHVybiBkb25lO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5jbGFzcyBTdHJpbmdJbnB1dCB7XHJcbiAgICBjb25zdHJ1Y3RvcihzdHJpbmcpIHtcclxuICAgICAgICB0aGlzLnN0cmluZyA9IHN0cmluZztcclxuICAgIH1cclxuICAgIGdldCBsZW5ndGgoKSB7IHJldHVybiB0aGlzLnN0cmluZy5sZW5ndGg7IH1cclxuICAgIGNodW5rKGZyb20pIHsgcmV0dXJuIHRoaXMuc3RyaW5nLnNsaWNlKGZyb20pOyB9XHJcbiAgICBnZXQgbGluZUNodW5rcygpIHsgcmV0dXJuIGZhbHNlOyB9XHJcbiAgICByZWFkKGZyb20sIHRvKSB7IHJldHVybiB0aGlzLnN0cmluZy5zbGljZShmcm9tLCB0byk7IH1cclxufVxyXG5cclxuLy8vIENyZWF0ZSBhIHBhcnNlIHdyYXBwZXIgdGhhdCwgYWZ0ZXIgdGhlIGlubmVyIHBhcnNlIGNvbXBsZXRlcyxcclxuLy8vIHNjYW5zIGl0cyB0cmVlIGZvciBtaXhlZCBsYW5ndWFnZSByZWdpb25zIHdpdGggdGhlIGBuZXN0YFxyXG4vLy8gZnVuY3Rpb24sIHJ1bnMgdGhlIHJlc3VsdGluZyBbaW5uZXIgcGFyc2VzXSgjY29tbW9uLk5lc3RlZFBhcnNlKSxcclxuLy8vIGFuZCB0aGVuIFttb3VudHNdKCNjb21tb24uTm9kZVByb3BebW91bnRlZCkgdGhlaXIgcmVzdWx0cyBvbnRvIHRoZVxyXG4vLy8gdHJlZS5cclxuZnVuY3Rpb24gcGFyc2VNaXhlZChuZXN0KSB7XHJcbiAgICByZXR1cm4gKHBhcnNlLCBpbnB1dCwgZnJhZ21lbnRzLCByYW5nZXMpID0+IG5ldyBNaXhlZFBhcnNlKHBhcnNlLCBuZXN0LCBpbnB1dCwgZnJhZ21lbnRzLCByYW5nZXMpO1xyXG59XHJcbmNsYXNzIElubmVyUGFyc2Uge1xyXG4gICAgY29uc3RydWN0b3IocGFyc2VyLCBwYXJzZSwgb3ZlcmxheSwgdGFyZ2V0LCByYW5nZXMpIHtcclxuICAgICAgICB0aGlzLnBhcnNlciA9IHBhcnNlcjtcclxuICAgICAgICB0aGlzLnBhcnNlID0gcGFyc2U7XHJcbiAgICAgICAgdGhpcy5vdmVybGF5ID0gb3ZlcmxheTtcclxuICAgICAgICB0aGlzLnRhcmdldCA9IHRhcmdldDtcclxuICAgICAgICB0aGlzLnJhbmdlcyA9IHJhbmdlcztcclxuICAgIH1cclxufVxyXG5jbGFzcyBBY3RpdmVPdmVybGF5IHtcclxuICAgIGNvbnN0cnVjdG9yKHBhcnNlciwgcHJlZGljYXRlLCBtb3VudHMsIGluZGV4LCBzdGFydCwgdGFyZ2V0LCBwcmV2KSB7XHJcbiAgICAgICAgdGhpcy5wYXJzZXIgPSBwYXJzZXI7XHJcbiAgICAgICAgdGhpcy5wcmVkaWNhdGUgPSBwcmVkaWNhdGU7XHJcbiAgICAgICAgdGhpcy5tb3VudHMgPSBtb3VudHM7XHJcbiAgICAgICAgdGhpcy5pbmRleCA9IGluZGV4O1xyXG4gICAgICAgIHRoaXMuc3RhcnQgPSBzdGFydDtcclxuICAgICAgICB0aGlzLnRhcmdldCA9IHRhcmdldDtcclxuICAgICAgICB0aGlzLnByZXYgPSBwcmV2O1xyXG4gICAgICAgIHRoaXMuZGVwdGggPSAwO1xyXG4gICAgICAgIHRoaXMucmFuZ2VzID0gW107XHJcbiAgICB9XHJcbn1cclxuY29uc3Qgc3RvcHBlZElubmVyID0gbmV3IE5vZGVQcm9wKHsgcGVyTm9kZTogdHJ1ZSB9KTtcclxuY2xhc3MgTWl4ZWRQYXJzZSB7XHJcbiAgICBjb25zdHJ1Y3RvcihiYXNlLCBuZXN0LCBpbnB1dCwgZnJhZ21lbnRzLCByYW5nZXMpIHtcclxuICAgICAgICB0aGlzLm5lc3QgPSBuZXN0O1xyXG4gICAgICAgIHRoaXMuaW5wdXQgPSBpbnB1dDtcclxuICAgICAgICB0aGlzLmZyYWdtZW50cyA9IGZyYWdtZW50cztcclxuICAgICAgICB0aGlzLnJhbmdlcyA9IHJhbmdlcztcclxuICAgICAgICB0aGlzLmlubmVyID0gW107XHJcbiAgICAgICAgdGhpcy5pbm5lckRvbmUgPSAwO1xyXG4gICAgICAgIHRoaXMuYmFzZVRyZWUgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuc3RvcHBlZEF0ID0gbnVsbDtcclxuICAgICAgICB0aGlzLmJhc2VQYXJzZSA9IGJhc2U7XHJcbiAgICB9XHJcbiAgICBhZHZhbmNlKCkge1xyXG4gICAgICAgIGlmICh0aGlzLmJhc2VQYXJzZSkge1xyXG4gICAgICAgICAgICBsZXQgZG9uZSA9IHRoaXMuYmFzZVBhcnNlLmFkdmFuY2UoKTtcclxuICAgICAgICAgICAgaWYgKCFkb25lKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgIHRoaXMuYmFzZVBhcnNlID0gbnVsbDtcclxuICAgICAgICAgICAgdGhpcy5iYXNlVHJlZSA9IGRvbmU7XHJcbiAgICAgICAgICAgIHRoaXMuc3RhcnRJbm5lcigpO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5zdG9wcGVkQXQgIT0gbnVsbClcclxuICAgICAgICAgICAgICAgIGZvciAobGV0IGlubmVyIG9mIHRoaXMuaW5uZXIpXHJcbiAgICAgICAgICAgICAgICAgICAgaW5uZXIucGFyc2Uuc3RvcEF0KHRoaXMuc3RvcHBlZEF0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuaW5uZXJEb25lID09IHRoaXMuaW5uZXIubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIGxldCByZXN1bHQgPSB0aGlzLmJhc2VUcmVlO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5zdG9wcGVkQXQgIT0gbnVsbClcclxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IG5ldyBUcmVlKHJlc3VsdC50eXBlLCByZXN1bHQuY2hpbGRyZW4sIHJlc3VsdC5wb3NpdGlvbnMsIHJlc3VsdC5sZW5ndGgsIHJlc3VsdC5wcm9wVmFsdWVzLmNvbmNhdChbW3N0b3BwZWRJbm5lciwgdGhpcy5zdG9wcGVkQXRdXSkpO1xyXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgaW5uZXIgPSB0aGlzLmlubmVyW3RoaXMuaW5uZXJEb25lXSwgZG9uZSA9IGlubmVyLnBhcnNlLmFkdmFuY2UoKTtcclxuICAgICAgICBpZiAoZG9uZSkge1xyXG4gICAgICAgICAgICB0aGlzLmlubmVyRG9uZSsrO1xyXG4gICAgICAgICAgICAvLyBUaGlzIGlzIGEgc29tZXdoYXQgZG9kZ3kgYnV0IHN1cGVyIGhlbHBmdWwgaGFjayB3aGVyZSB3ZVxyXG4gICAgICAgICAgICAvLyBwYXRjaCB1cCBub2RlcyBjcmVhdGVkIGJ5IHRoZSBpbm5lciBwYXJzZSAoYW5kIHRodXNcclxuICAgICAgICAgICAgLy8gcHJlc3VtYWJseSBub3QgYWxpYXNlZCBhbnl3aGVyZSBlbHNlKSB0byBob2xkIHRoZSBpbmZvcm1hdGlvblxyXG4gICAgICAgICAgICAvLyBhYm91dCB0aGUgaW5uZXIgcGFyc2UuXHJcbiAgICAgICAgICAgIGxldCBwcm9wcyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmNyZWF0ZShudWxsKSwgaW5uZXIudGFyZ2V0LnByb3BzKTtcclxuICAgICAgICAgICAgcHJvcHNbTm9kZVByb3AubW91bnRlZC5pZF0gPSBuZXcgTW91bnRlZFRyZWUoZG9uZSwgaW5uZXIub3ZlcmxheSwgaW5uZXIucGFyc2VyKTtcclxuICAgICAgICAgICAgaW5uZXIudGFyZ2V0LnByb3BzID0gcHJvcHM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG4gICAgZ2V0IHBhcnNlZFBvcygpIHtcclxuICAgICAgICBpZiAodGhpcy5iYXNlUGFyc2UpXHJcbiAgICAgICAgICAgIHJldHVybiAwO1xyXG4gICAgICAgIGxldCBwb3MgPSB0aGlzLmlucHV0Lmxlbmd0aDtcclxuICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5pbm5lckRvbmU7IGkgPCB0aGlzLmlubmVyLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmlubmVyW2ldLnJhbmdlc1swXS5mcm9tIDwgcG9zKVxyXG4gICAgICAgICAgICAgICAgcG9zID0gTWF0aC5taW4ocG9zLCB0aGlzLmlubmVyW2ldLnBhcnNlLnBhcnNlZFBvcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBwb3M7XHJcbiAgICB9XHJcbiAgICBzdG9wQXQocG9zKSB7XHJcbiAgICAgICAgdGhpcy5zdG9wcGVkQXQgPSBwb3M7XHJcbiAgICAgICAgaWYgKHRoaXMuYmFzZVBhcnNlKVxyXG4gICAgICAgICAgICB0aGlzLmJhc2VQYXJzZS5zdG9wQXQocG9zKTtcclxuICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSB0aGlzLmlubmVyRG9uZTsgaSA8IHRoaXMuaW5uZXIubGVuZ3RoOyBpKyspXHJcbiAgICAgICAgICAgICAgICB0aGlzLmlubmVyW2ldLnBhcnNlLnN0b3BBdChwb3MpO1xyXG4gICAgfVxyXG4gICAgc3RhcnRJbm5lcigpIHtcclxuICAgICAgICBsZXQgZnJhZ21lbnRDdXJzb3IgPSBuZXcgRnJhZ21lbnRDdXJzb3IodGhpcy5mcmFnbWVudHMpO1xyXG4gICAgICAgIGxldCBvdmVybGF5ID0gbnVsbDtcclxuICAgICAgICBsZXQgY292ZXJlZCA9IG51bGw7XHJcbiAgICAgICAgbGV0IGN1cnNvciA9IG5ldyBUcmVlQ3Vyc29yKG5ldyBUcmVlTm9kZSh0aGlzLmJhc2VUcmVlLCB0aGlzLnJhbmdlc1swXS5mcm9tLCAwLCBudWxsKSwgSXRlck1vZGUuSW5jbHVkZUFub255bW91cyB8IEl0ZXJNb2RlLklnbm9yZU1vdW50cyk7XHJcbiAgICAgICAgc2NhbjogZm9yIChsZXQgbmVzdCwgaXNDb3ZlcmVkOyB0aGlzLnN0b3BwZWRBdCA9PSBudWxsIHx8IGN1cnNvci5mcm9tIDwgdGhpcy5zdG9wcGVkQXQ7KSB7XHJcbiAgICAgICAgICAgIGxldCBlbnRlciA9IHRydWUsIHJhbmdlO1xyXG4gICAgICAgICAgICBpZiAoZnJhZ21lbnRDdXJzb3IuaGFzTm9kZShjdXJzb3IpKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAob3ZlcmxheSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBtYXRjaCA9IG92ZXJsYXkubW91bnRzLmZpbmQobSA9PiBtLmZyYWcuZnJvbSA8PSBjdXJzb3IuZnJvbSAmJiBtLmZyYWcudG8gPj0gY3Vyc29yLnRvICYmIG0ubW91bnQub3ZlcmxheSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1hdGNoKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCByIG9mIG1hdGNoLm1vdW50Lm92ZXJsYXkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBmcm9tID0gci5mcm9tICsgbWF0Y2gucG9zLCB0byA9IHIudG8gKyBtYXRjaC5wb3M7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZnJvbSA+PSBjdXJzb3IuZnJvbSAmJiB0byA8PSBjdXJzb3IudG8gJiYgIW92ZXJsYXkucmFuZ2VzLnNvbWUociA9PiByLmZyb20gPCB0byAmJiByLnRvID4gZnJvbSkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3ZlcmxheS5yYW5nZXMucHVzaCh7IGZyb20sIHRvIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbnRlciA9IGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGNvdmVyZWQgJiYgKGlzQ292ZXJlZCA9IGNoZWNrQ292ZXIoY292ZXJlZC5yYW5nZXMsIGN1cnNvci5mcm9tLCBjdXJzb3IudG8pKSkge1xyXG4gICAgICAgICAgICAgICAgZW50ZXIgPSBpc0NvdmVyZWQgIT0gMiAvKiBDb3Zlci5GdWxsICovO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKCFjdXJzb3IudHlwZS5pc0Fub255bW91cyAmJiBjdXJzb3IuZnJvbSA8IGN1cnNvci50byAmJiAobmVzdCA9IHRoaXMubmVzdChjdXJzb3IsIHRoaXMuaW5wdXQpKSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFjdXJzb3IudHJlZSlcclxuICAgICAgICAgICAgICAgICAgICBtYXRlcmlhbGl6ZShjdXJzb3IpO1xyXG4gICAgICAgICAgICAgICAgbGV0IG9sZE1vdW50cyA9IGZyYWdtZW50Q3Vyc29yLmZpbmRNb3VudHMoY3Vyc29yLmZyb20sIG5lc3QucGFyc2VyKTtcclxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgbmVzdC5vdmVybGF5ID09IFwiZnVuY3Rpb25cIikge1xyXG4gICAgICAgICAgICAgICAgICAgIG92ZXJsYXkgPSBuZXcgQWN0aXZlT3ZlcmxheShuZXN0LnBhcnNlciwgbmVzdC5vdmVybGF5LCBvbGRNb3VudHMsIHRoaXMuaW5uZXIubGVuZ3RoLCBjdXJzb3IuZnJvbSwgY3Vyc29yLnRyZWUsIG92ZXJsYXkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IHJhbmdlcyA9IHB1bmNoUmFuZ2VzKHRoaXMucmFuZ2VzLCBuZXN0Lm92ZXJsYXkgfHwgW25ldyBSYW5nZShjdXJzb3IuZnJvbSwgY3Vyc29yLnRvKV0pO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChyYW5nZXMubGVuZ3RoKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmlubmVyLnB1c2gobmV3IElubmVyUGFyc2UobmVzdC5wYXJzZXIsIG5lc3QucGFyc2VyLnN0YXJ0UGFyc2UodGhpcy5pbnB1dCwgZW50ZXJGcmFnbWVudHMob2xkTW91bnRzLCByYW5nZXMpLCByYW5nZXMpLCBuZXN0Lm92ZXJsYXkgPyBuZXN0Lm92ZXJsYXkubWFwKHIgPT4gbmV3IFJhbmdlKHIuZnJvbSAtIGN1cnNvci5mcm9tLCByLnRvIC0gY3Vyc29yLmZyb20pKSA6IG51bGwsIGN1cnNvci50cmVlLCByYW5nZXMpKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIW5lc3Qub3ZlcmxheSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgZW50ZXIgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChyYW5nZXMubGVuZ3RoKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb3ZlcmVkID0geyByYW5nZXMsIGRlcHRoOiAwLCBwcmV2OiBjb3ZlcmVkIH07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAob3ZlcmxheSAmJiAocmFuZ2UgPSBvdmVybGF5LnByZWRpY2F0ZShjdXJzb3IpKSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHJhbmdlID09PSB0cnVlKVxyXG4gICAgICAgICAgICAgICAgICAgIHJhbmdlID0gbmV3IFJhbmdlKGN1cnNvci5mcm9tLCBjdXJzb3IudG8pO1xyXG4gICAgICAgICAgICAgICAgaWYgKHJhbmdlLmZyb20gPCByYW5nZS50bylcclxuICAgICAgICAgICAgICAgICAgICBvdmVybGF5LnJhbmdlcy5wdXNoKHJhbmdlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoZW50ZXIgJiYgY3Vyc29yLmZpcnN0Q2hpbGQoKSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKG92ZXJsYXkpXHJcbiAgICAgICAgICAgICAgICAgICAgb3ZlcmxheS5kZXB0aCsrO1xyXG4gICAgICAgICAgICAgICAgaWYgKGNvdmVyZWQpXHJcbiAgICAgICAgICAgICAgICAgICAgY292ZXJlZC5kZXB0aCsrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgZm9yICg7Oykge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjdXJzb3IubmV4dFNpYmxpbmcoKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjdXJzb3IucGFyZW50KCkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrIHNjYW47XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG92ZXJsYXkgJiYgIS0tb3ZlcmxheS5kZXB0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgcmFuZ2VzID0gcHVuY2hSYW5nZXModGhpcy5yYW5nZXMsIG92ZXJsYXkucmFuZ2VzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJhbmdlcy5sZW5ndGgpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmlubmVyLnNwbGljZShvdmVybGF5LmluZGV4LCAwLCBuZXcgSW5uZXJQYXJzZShvdmVybGF5LnBhcnNlciwgb3ZlcmxheS5wYXJzZXIuc3RhcnRQYXJzZSh0aGlzLmlucHV0LCBlbnRlckZyYWdtZW50cyhvdmVybGF5Lm1vdW50cywgcmFuZ2VzKSwgcmFuZ2VzKSwgb3ZlcmxheS5yYW5nZXMubWFwKHIgPT4gbmV3IFJhbmdlKHIuZnJvbSAtIG92ZXJsYXkuc3RhcnQsIHIudG8gLSBvdmVybGF5LnN0YXJ0KSksIG92ZXJsYXkudGFyZ2V0LCByYW5nZXMpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgb3ZlcmxheSA9IG92ZXJsYXkucHJldjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvdmVyZWQgJiYgIS0tY292ZXJlZC5kZXB0aClcclxuICAgICAgICAgICAgICAgICAgICAgICAgY292ZXJlZCA9IGNvdmVyZWQucHJldjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBjaGVja0NvdmVyKGNvdmVyZWQsIGZyb20sIHRvKSB7XHJcbiAgICBmb3IgKGxldCByYW5nZSBvZiBjb3ZlcmVkKSB7XHJcbiAgICAgICAgaWYgKHJhbmdlLmZyb20gPj0gdG8pXHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGlmIChyYW5nZS50byA+IGZyb20pXHJcbiAgICAgICAgICAgIHJldHVybiByYW5nZS5mcm9tIDw9IGZyb20gJiYgcmFuZ2UudG8gPj0gdG8gPyAyIC8qIENvdmVyLkZ1bGwgKi8gOiAxIC8qIENvdmVyLlBhcnRpYWwgKi87XHJcbiAgICB9XHJcbiAgICByZXR1cm4gMCAvKiBDb3Zlci5Ob25lICovO1xyXG59XHJcbi8vIFRha2UgYSBwaWVjZSBvZiBidWZmZXIgYW5kIGNvbnZlcnQgaXQgaW50byBhIHN0YW5kLWFsb25lXHJcbi8vIFRyZWVCdWZmZXIuXHJcbmZ1bmN0aW9uIHNsaWNlQnVmKGJ1Ziwgc3RhcnRJLCBlbmRJLCBub2RlcywgcG9zaXRpb25zLCBvZmYpIHtcclxuICAgIGlmIChzdGFydEkgPCBlbmRJKSB7XHJcbiAgICAgICAgbGV0IGZyb20gPSBidWYuYnVmZmVyW3N0YXJ0SSArIDFdO1xyXG4gICAgICAgIG5vZGVzLnB1c2goYnVmLnNsaWNlKHN0YXJ0SSwgZW5kSSwgZnJvbSkpO1xyXG4gICAgICAgIHBvc2l0aW9ucy5wdXNoKGZyb20gLSBvZmYpO1xyXG4gICAgfVxyXG59XHJcbi8vIFRoaXMgZnVuY3Rpb24gdGFrZXMgYSBub2RlIHRoYXQncyBpbiBhIGJ1ZmZlciwgYW5kIGNvbnZlcnRzIGl0LCBhbmRcclxuLy8gaXRzIHBhcmVudCBidWZmZXIgbm9kZXMsIGludG8gYSBUcmVlLiBUaGlzIGlzIGFnYWluIGFjdGluZyBvbiB0aGVcclxuLy8gYXNzdW1wdGlvbiB0aGF0IHRoZSB0cmVlcyBhbmQgYnVmZmVycyBoYXZlIGJlZW4gY29uc3RydWN0ZWQgYnkgdGhlXHJcbi8vIHBhcnNlIHRoYXQgd2FzIHJhbiB2aWEgdGhlIG1peCBwYXJzZXIsIGFuZCB0aHVzIGFyZW4ndCBzaGFyZWQgd2l0aFxyXG4vLyBhbnkgb3RoZXIgY29kZSwgbWFraW5nIHZpb2xhdGlvbnMgb2YgdGhlIGltbXV0YWJpbGl0eSBzYWZlLlxyXG5mdW5jdGlvbiBtYXRlcmlhbGl6ZShjdXJzb3IpIHtcclxuICAgIGxldCB7IG5vZGUgfSA9IGN1cnNvciwgZGVwdGggPSAwO1xyXG4gICAgLy8gU2NhbiB1cCB0byB0aGUgbmVhcmVzdCB0cmVlXHJcbiAgICBkbyB7XHJcbiAgICAgICAgY3Vyc29yLnBhcmVudCgpO1xyXG4gICAgICAgIGRlcHRoKys7XHJcbiAgICB9IHdoaWxlICghY3Vyc29yLnRyZWUpO1xyXG4gICAgLy8gRmluZCB0aGUgaW5kZXggb2YgdGhlIGJ1ZmZlciBpbiB0aGF0IHRyZWVcclxuICAgIGxldCBpID0gMCwgYmFzZSA9IGN1cnNvci50cmVlLCBvZmYgPSAwO1xyXG4gICAgZm9yICg7OyBpKyspIHtcclxuICAgICAgICBvZmYgPSBiYXNlLnBvc2l0aW9uc1tpXSArIGN1cnNvci5mcm9tO1xyXG4gICAgICAgIGlmIChvZmYgPD0gbm9kZS5mcm9tICYmIG9mZiArIGJhc2UuY2hpbGRyZW5baV0ubGVuZ3RoID49IG5vZGUudG8pXHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgfVxyXG4gICAgbGV0IGJ1ZiA9IGJhc2UuY2hpbGRyZW5baV0sIGIgPSBidWYuYnVmZmVyO1xyXG4gICAgLy8gU3BsaXQgYSBsZXZlbCBpbiB0aGUgYnVmZmVyLCBwdXR0aW5nIHRoZSBub2RlcyBiZWZvcmUgYW5kIGFmdGVyXHJcbiAgICAvLyB0aGUgY2hpbGQgdGhhdCBjb250YWlucyBgbm9kZWAgaW50byBuZXcgYnVmZmVycy5cclxuICAgIGZ1bmN0aW9uIHNwbGl0KHN0YXJ0SSwgZW5kSSwgdHlwZSwgaW5uZXJPZmZzZXQsIGxlbmd0aCkge1xyXG4gICAgICAgIGxldCBpID0gc3RhcnRJO1xyXG4gICAgICAgIHdoaWxlIChiW2kgKyAyXSArIG9mZiA8PSBub2RlLmZyb20pXHJcbiAgICAgICAgICAgIGkgPSBiW2kgKyAzXTtcclxuICAgICAgICBsZXQgY2hpbGRyZW4gPSBbXSwgcG9zaXRpb25zID0gW107XHJcbiAgICAgICAgc2xpY2VCdWYoYnVmLCBzdGFydEksIGksIGNoaWxkcmVuLCBwb3NpdGlvbnMsIGlubmVyT2Zmc2V0KTtcclxuICAgICAgICBsZXQgZnJvbSA9IGJbaSArIDFdLCB0byA9IGJbaSArIDJdO1xyXG4gICAgICAgIGxldCBpc1RhcmdldCA9IGZyb20gKyBvZmYgPT0gbm9kZS5mcm9tICYmIHRvICsgb2ZmID09IG5vZGUudG8gJiYgYltpXSA9PSBub2RlLnR5cGUuaWQ7XHJcbiAgICAgICAgY2hpbGRyZW4ucHVzaChpc1RhcmdldCA/IG5vZGUudG9UcmVlKCkgOiBzcGxpdChpICsgNCwgYltpICsgM10sIGJ1Zi5zZXQudHlwZXNbYltpXV0sIGZyb20sIHRvIC0gZnJvbSkpO1xyXG4gICAgICAgIHBvc2l0aW9ucy5wdXNoKGZyb20gLSBpbm5lck9mZnNldCk7XHJcbiAgICAgICAgc2xpY2VCdWYoYnVmLCBiW2kgKyAzXSwgZW5kSSwgY2hpbGRyZW4sIHBvc2l0aW9ucywgaW5uZXJPZmZzZXQpO1xyXG4gICAgICAgIHJldHVybiBuZXcgVHJlZSh0eXBlLCBjaGlsZHJlbiwgcG9zaXRpb25zLCBsZW5ndGgpO1xyXG4gICAgfVxyXG4gICAgYmFzZS5jaGlsZHJlbltpXSA9IHNwbGl0KDAsIGIubGVuZ3RoLCBOb2RlVHlwZS5ub25lLCAwLCBidWYubGVuZ3RoKTtcclxuICAgIC8vIE1vdmUgdGhlIGN1cnNvciBiYWNrIHRvIHRoZSB0YXJnZXQgbm9kZVxyXG4gICAgZm9yIChsZXQgZCA9IDA7IGQgPD0gZGVwdGg7IGQrKylcclxuICAgICAgICBjdXJzb3IuY2hpbGRBZnRlcihub2RlLmZyb20pO1xyXG59XHJcbmNsYXNzIFN0cnVjdHVyZUN1cnNvciB7XHJcbiAgICBjb25zdHJ1Y3Rvcihyb290LCBvZmZzZXQpIHtcclxuICAgICAgICB0aGlzLm9mZnNldCA9IG9mZnNldDtcclxuICAgICAgICB0aGlzLmRvbmUgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLmN1cnNvciA9IHJvb3QuY3Vyc29yKEl0ZXJNb2RlLkluY2x1ZGVBbm9ueW1vdXMgfCBJdGVyTW9kZS5JZ25vcmVNb3VudHMpO1xyXG4gICAgfVxyXG4gICAgLy8gTW92ZSB0byB0aGUgZmlyc3Qgbm9kZSAoaW4gcHJlLW9yZGVyKSB0aGF0IHN0YXJ0cyBhdCBvciBhZnRlciBgcG9zYC5cclxuICAgIG1vdmVUbyhwb3MpIHtcclxuICAgICAgICBsZXQgeyBjdXJzb3IgfSA9IHRoaXMsIHAgPSBwb3MgLSB0aGlzLm9mZnNldDtcclxuICAgICAgICB3aGlsZSAoIXRoaXMuZG9uZSAmJiBjdXJzb3IuZnJvbSA8IHApIHtcclxuICAgICAgICAgICAgaWYgKGN1cnNvci50byA+PSBwb3MgJiYgY3Vyc29yLmVudGVyKHAsIDEsIEl0ZXJNb2RlLklnbm9yZU92ZXJsYXlzIHwgSXRlck1vZGUuRXhjbHVkZUJ1ZmZlcnMpKSA7XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKCFjdXJzb3IubmV4dChmYWxzZSkpXHJcbiAgICAgICAgICAgICAgICB0aGlzLmRvbmUgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGhhc05vZGUoY3Vyc29yKSB7XHJcbiAgICAgICAgdGhpcy5tb3ZlVG8oY3Vyc29yLmZyb20pO1xyXG4gICAgICAgIGlmICghdGhpcy5kb25lICYmIHRoaXMuY3Vyc29yLmZyb20gKyB0aGlzLm9mZnNldCA9PSBjdXJzb3IuZnJvbSAmJiB0aGlzLmN1cnNvci50cmVlKSB7XHJcbiAgICAgICAgICAgIGZvciAobGV0IHRyZWUgPSB0aGlzLmN1cnNvci50cmVlOzspIHtcclxuICAgICAgICAgICAgICAgIGlmICh0cmVlID09IGN1cnNvci50cmVlKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRyZWUuY2hpbGRyZW4ubGVuZ3RoICYmIHRyZWUucG9zaXRpb25zWzBdID09IDAgJiYgdHJlZS5jaGlsZHJlblswXSBpbnN0YW5jZW9mIFRyZWUpXHJcbiAgICAgICAgICAgICAgICAgICAgdHJlZSA9IHRyZWUuY2hpbGRyZW5bMF07XHJcbiAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG59XHJcbmNsYXNzIEZyYWdtZW50Q3Vyc29yIHtcclxuICAgIGNvbnN0cnVjdG9yKGZyYWdtZW50cykge1xyXG4gICAgICAgIHZhciBfYTtcclxuICAgICAgICB0aGlzLmZyYWdtZW50cyA9IGZyYWdtZW50cztcclxuICAgICAgICB0aGlzLmN1clRvID0gMDtcclxuICAgICAgICB0aGlzLmZyYWdJID0gMDtcclxuICAgICAgICBpZiAoZnJhZ21lbnRzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICBsZXQgZmlyc3QgPSB0aGlzLmN1ckZyYWcgPSBmcmFnbWVudHNbMF07XHJcbiAgICAgICAgICAgIHRoaXMuY3VyVG8gPSAoX2EgPSBmaXJzdC50cmVlLnByb3Aoc3RvcHBlZElubmVyKSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogZmlyc3QudG87XHJcbiAgICAgICAgICAgIHRoaXMuaW5uZXIgPSBuZXcgU3RydWN0dXJlQ3Vyc29yKGZpcnN0LnRyZWUsIC1maXJzdC5vZmZzZXQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5jdXJGcmFnID0gdGhpcy5pbm5lciA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaGFzTm9kZShub2RlKSB7XHJcbiAgICAgICAgd2hpbGUgKHRoaXMuY3VyRnJhZyAmJiBub2RlLmZyb20gPj0gdGhpcy5jdXJUbylcclxuICAgICAgICAgICAgdGhpcy5uZXh0RnJhZygpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLmN1ckZyYWcgJiYgdGhpcy5jdXJGcmFnLmZyb20gPD0gbm9kZS5mcm9tICYmIHRoaXMuY3VyVG8gPj0gbm9kZS50byAmJiB0aGlzLmlubmVyLmhhc05vZGUobm9kZSk7XHJcbiAgICB9XHJcbiAgICBuZXh0RnJhZygpIHtcclxuICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgdGhpcy5mcmFnSSsrO1xyXG4gICAgICAgIGlmICh0aGlzLmZyYWdJID09IHRoaXMuZnJhZ21lbnRzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICB0aGlzLmN1ckZyYWcgPSB0aGlzLmlubmVyID0gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGxldCBmcmFnID0gdGhpcy5jdXJGcmFnID0gdGhpcy5mcmFnbWVudHNbdGhpcy5mcmFnSV07XHJcbiAgICAgICAgICAgIHRoaXMuY3VyVG8gPSAoX2EgPSBmcmFnLnRyZWUucHJvcChzdG9wcGVkSW5uZXIpKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBmcmFnLnRvO1xyXG4gICAgICAgICAgICB0aGlzLmlubmVyID0gbmV3IFN0cnVjdHVyZUN1cnNvcihmcmFnLnRyZWUsIC1mcmFnLm9mZnNldCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZmluZE1vdW50cyhwb3MsIHBhcnNlcikge1xyXG4gICAgICAgIHZhciBfYTtcclxuICAgICAgICBsZXQgcmVzdWx0ID0gW107XHJcbiAgICAgICAgaWYgKHRoaXMuaW5uZXIpIHtcclxuICAgICAgICAgICAgdGhpcy5pbm5lci5jdXJzb3IubW92ZVRvKHBvcywgMSk7XHJcbiAgICAgICAgICAgIGZvciAobGV0IHBvcyA9IHRoaXMuaW5uZXIuY3Vyc29yLm5vZGU7IHBvczsgcG9zID0gcG9zLnBhcmVudCkge1xyXG4gICAgICAgICAgICAgICAgbGV0IG1vdW50ID0gKF9hID0gcG9zLnRyZWUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5wcm9wKE5vZGVQcm9wLm1vdW50ZWQpO1xyXG4gICAgICAgICAgICAgICAgaWYgKG1vdW50ICYmIG1vdW50LnBhcnNlciA9PSBwYXJzZXIpIHtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5mcmFnSTsgaSA8IHRoaXMuZnJhZ21lbnRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBmcmFnID0gdGhpcy5mcmFnbWVudHNbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmcmFnLmZyb20gPj0gcG9zLnRvKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmcmFnLnRyZWUgPT0gdGhpcy5jdXJGcmFnLnRyZWUpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnJhZyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3M6IHBvcy5mcm9tIC0gZnJhZy5vZmZzZXQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbW91bnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIHB1bmNoUmFuZ2VzKG91dGVyLCByYW5nZXMpIHtcclxuICAgIGxldCBjb3B5ID0gbnVsbCwgY3VycmVudCA9IHJhbmdlcztcclxuICAgIGZvciAobGV0IGkgPSAxLCBqID0gMDsgaSA8IG91dGVyLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgbGV0IGdhcEZyb20gPSBvdXRlcltpIC0gMV0udG8sIGdhcFRvID0gb3V0ZXJbaV0uZnJvbTtcclxuICAgICAgICBmb3IgKDsgaiA8IGN1cnJlbnQubGVuZ3RoOyBqKyspIHtcclxuICAgICAgICAgICAgbGV0IHIgPSBjdXJyZW50W2pdO1xyXG4gICAgICAgICAgICBpZiAoci5mcm9tID49IGdhcFRvKVxyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGlmIChyLnRvIDw9IGdhcEZyb20pXHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgaWYgKCFjb3B5KVxyXG4gICAgICAgICAgICAgICAgY3VycmVudCA9IGNvcHkgPSByYW5nZXMuc2xpY2UoKTtcclxuICAgICAgICAgICAgaWYgKHIuZnJvbSA8IGdhcEZyb20pIHtcclxuICAgICAgICAgICAgICAgIGNvcHlbal0gPSBuZXcgUmFuZ2Uoci5mcm9tLCBnYXBGcm9tKTtcclxuICAgICAgICAgICAgICAgIGlmIChyLnRvID4gZ2FwVG8pXHJcbiAgICAgICAgICAgICAgICAgICAgY29weS5zcGxpY2UoaiArIDEsIDAsIG5ldyBSYW5nZShnYXBUbywgci50bykpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHIudG8gPiBnYXBUbykge1xyXG4gICAgICAgICAgICAgICAgY29weVtqLS1dID0gbmV3IFJhbmdlKGdhcFRvLCByLnRvKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGNvcHkuc3BsaWNlKGotLSwgMSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gY3VycmVudDtcclxufVxyXG5mdW5jdGlvbiBmaW5kQ292ZXJDaGFuZ2VzKGEsIGIsIGZyb20sIHRvKSB7XHJcbiAgICBsZXQgaUEgPSAwLCBpQiA9IDAsIGluQSA9IGZhbHNlLCBpbkIgPSBmYWxzZSwgcG9zID0gLTFlOTtcclxuICAgIGxldCByZXN1bHQgPSBbXTtcclxuICAgIGZvciAoOzspIHtcclxuICAgICAgICBsZXQgbmV4dEEgPSBpQSA9PSBhLmxlbmd0aCA/IDFlOSA6IGluQSA/IGFbaUFdLnRvIDogYVtpQV0uZnJvbTtcclxuICAgICAgICBsZXQgbmV4dEIgPSBpQiA9PSBiLmxlbmd0aCA/IDFlOSA6IGluQiA/IGJbaUJdLnRvIDogYltpQl0uZnJvbTtcclxuICAgICAgICBpZiAoaW5BICE9IGluQikge1xyXG4gICAgICAgICAgICBsZXQgc3RhcnQgPSBNYXRoLm1heChwb3MsIGZyb20pLCBlbmQgPSBNYXRoLm1pbihuZXh0QSwgbmV4dEIsIHRvKTtcclxuICAgICAgICAgICAgaWYgKHN0YXJ0IDwgZW5kKVxyXG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2gobmV3IFJhbmdlKHN0YXJ0LCBlbmQpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcG9zID0gTWF0aC5taW4obmV4dEEsIG5leHRCKTtcclxuICAgICAgICBpZiAocG9zID09IDFlOSlcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgaWYgKG5leHRBID09IHBvcykge1xyXG4gICAgICAgICAgICBpZiAoIWluQSlcclxuICAgICAgICAgICAgICAgIGluQSA9IHRydWU7XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgaW5BID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICBpQSsrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChuZXh0QiA9PSBwb3MpIHtcclxuICAgICAgICAgICAgaWYgKCFpbkIpXHJcbiAgICAgICAgICAgICAgICBpbkIgPSB0cnVlO1xyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGluQiA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgaUIrKztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn1cclxuLy8gR2l2ZW4gYSBudW1iZXIgb2YgZnJhZ21lbnRzIGZvciB0aGUgb3V0ZXIgdHJlZSwgYW5kIGEgc2V0IG9mIHJhbmdlc1xyXG4vLyB0byBwYXJzZSwgZmluZCBmcmFnbWVudHMgZm9yIGlubmVyIHRyZWVzIG1vdW50ZWQgYXJvdW5kIHRob3NlXHJcbi8vIHJhbmdlcywgaWYgYW55LlxyXG5mdW5jdGlvbiBlbnRlckZyYWdtZW50cyhtb3VudHMsIHJhbmdlcykge1xyXG4gICAgbGV0IHJlc3VsdCA9IFtdO1xyXG4gICAgZm9yIChsZXQgeyBwb3MsIG1vdW50LCBmcmFnIH0gb2YgbW91bnRzKSB7XHJcbiAgICAgICAgbGV0IHN0YXJ0UG9zID0gcG9zICsgKG1vdW50Lm92ZXJsYXkgPyBtb3VudC5vdmVybGF5WzBdLmZyb20gOiAwKSwgZW5kUG9zID0gc3RhcnRQb3MgKyBtb3VudC50cmVlLmxlbmd0aDtcclxuICAgICAgICBsZXQgZnJvbSA9IE1hdGgubWF4KGZyYWcuZnJvbSwgc3RhcnRQb3MpLCB0byA9IE1hdGgubWluKGZyYWcudG8sIGVuZFBvcyk7XHJcbiAgICAgICAgaWYgKG1vdW50Lm92ZXJsYXkpIHtcclxuICAgICAgICAgICAgbGV0IG92ZXJsYXkgPSBtb3VudC5vdmVybGF5Lm1hcChyID0+IG5ldyBSYW5nZShyLmZyb20gKyBwb3MsIHIudG8gKyBwb3MpKTtcclxuICAgICAgICAgICAgbGV0IGNoYW5nZXMgPSBmaW5kQ292ZXJDaGFuZ2VzKHJhbmdlcywgb3ZlcmxheSwgZnJvbSwgdG8pO1xyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMCwgcG9zID0gZnJvbTs7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgbGV0IGxhc3QgPSBpID09IGNoYW5nZXMubGVuZ3RoLCBlbmQgPSBsYXN0ID8gdG8gOiBjaGFuZ2VzW2ldLmZyb207XHJcbiAgICAgICAgICAgICAgICBpZiAoZW5kID4gcG9zKVxyXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKG5ldyBUcmVlRnJhZ21lbnQocG9zLCBlbmQsIG1vdW50LnRyZWUsIC1zdGFydFBvcywgZnJhZy5mcm9tID49IHBvcyB8fCBmcmFnLm9wZW5TdGFydCwgZnJhZy50byA8PSBlbmQgfHwgZnJhZy5vcGVuRW5kKSk7XHJcbiAgICAgICAgICAgICAgICBpZiAobGFzdClcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIHBvcyA9IGNoYW5nZXNbaV0udG87XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKG5ldyBUcmVlRnJhZ21lbnQoZnJvbSwgdG8sIG1vdW50LnRyZWUsIC1zdGFydFBvcywgZnJhZy5mcm9tID49IHN0YXJ0UG9zIHx8IGZyYWcub3BlblN0YXJ0LCBmcmFnLnRvIDw9IGVuZFBvcyB8fCBmcmFnLm9wZW5FbmQpKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59XHJcblxyXG5leHBvcnQgeyBEZWZhdWx0QnVmZmVyTGVuZ3RoLCBJdGVyTW9kZSwgTW91bnRlZFRyZWUsIE5vZGVQcm9wLCBOb2RlU2V0LCBOb2RlVHlwZSwgTm9kZVdlYWtNYXAsIFBhcnNlciwgVHJlZSwgVHJlZUJ1ZmZlciwgVHJlZUN1cnNvciwgVHJlZUZyYWdtZW50LCBwYXJzZU1peGVkIH07XHJcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@lezer/common/dist/index.js\n"));

/***/ }),

/***/ "./node_modules/@lezer/highlight/dist/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/@lezer/highlight/dist/index.js ***!
  \*****************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Tag\": function() { return /* binding */ Tag; },\n/* harmony export */   \"classHighlighter\": function() { return /* binding */ classHighlighter; },\n/* harmony export */   \"getStyleTags\": function() { return /* binding */ getStyleTags; },\n/* harmony export */   \"highlightTree\": function() { return /* binding */ highlightTree; },\n/* harmony export */   \"styleTags\": function() { return /* binding */ styleTags; },\n/* harmony export */   \"tagHighlighter\": function() { return /* binding */ tagHighlighter; },\n/* harmony export */   \"tags\": function() { return /* binding */ tags; }\n/* harmony export */ });\n/* harmony import */ var _lezer_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lezer/common */ \"./node_modules/@lezer/common/dist/index.js\");\n\r\n\r\nlet nextTagID = 0;\r\n/// Highlighting tags are markers that denote a highlighting category.\r\n/// They are [associated](#highlight.styleTags) with parts of a syntax\r\n/// tree by a language mode, and then mapped to an actual CSS style by\r\n/// a [highlighter](#highlight.Highlighter).\r\n///\r\n/// Because syntax tree node types and highlight styles have to be\r\n/// able to talk the same language, CodeMirror uses a mostly _closed_\r\n/// [vocabulary](#highlight.tags) of syntax tags (as opposed to\r\n/// traditional open string-based systems, which make it hard for\r\n/// highlighting themes to cover all the tokens produced by the\r\n/// various languages).\r\n///\r\n/// It _is_ possible to [define](#highlight.Tag^define) your own\r\n/// highlighting tags for system-internal use (where you control both\r\n/// the language package and the highlighter), but such tags will not\r\n/// be picked up by regular highlighters (though you can derive them\r\n/// from standard tags to allow highlighters to fall back to those).\r\nclass Tag {\r\n    /// @internal\r\n    constructor(\r\n    /// The set of this tag and all its parent tags, starting with\r\n    /// this one itself and sorted in order of decreasing specificity.\r\n    set, \r\n    /// The base unmodified tag that this one is based on, if it's\r\n    /// modified @internal\r\n    base, \r\n    /// The modifiers applied to this.base @internal\r\n    modified) {\r\n        this.set = set;\r\n        this.base = base;\r\n        this.modified = modified;\r\n        /// @internal\r\n        this.id = nextTagID++;\r\n    }\r\n    /// Define a new tag. If `parent` is given, the tag is treated as a\r\n    /// sub-tag of that parent, and\r\n    /// [highlighters](#highlight.tagHighlighter) that don't mention\r\n    /// this tag will try to fall back to the parent tag (or grandparent\r\n    /// tag, etc).\r\n    static define(parent) {\r\n        if (parent === null || parent === void 0 ? void 0 : parent.base)\r\n            throw new Error(\"Can not derive from a modified tag\");\r\n        let tag = new Tag([], null, []);\r\n        tag.set.push(tag);\r\n        if (parent)\r\n            for (let t of parent.set)\r\n                tag.set.push(t);\r\n        return tag;\r\n    }\r\n    /// Define a tag _modifier_, which is a function that, given a tag,\r\n    /// will return a tag that is a subtag of the original. Applying the\r\n    /// same modifier to a twice tag will return the same value (`m1(t1)\r\n    /// == m1(t1)`) and applying multiple modifiers will, regardless or\r\n    /// order, produce the same tag (`m1(m2(t1)) == m2(m1(t1))`).\r\n    ///\r\n    /// When multiple modifiers are applied to a given base tag, each\r\n    /// smaller set of modifiers is registered as a parent, so that for\r\n    /// example `m1(m2(m3(t1)))` is a subtype of `m1(m2(t1))`,\r\n    /// `m1(m3(t1)`, and so on.\r\n    static defineModifier() {\r\n        let mod = new Modifier;\r\n        return (tag) => {\r\n            if (tag.modified.indexOf(mod) > -1)\r\n                return tag;\r\n            return Modifier.get(tag.base || tag, tag.modified.concat(mod).sort((a, b) => a.id - b.id));\r\n        };\r\n    }\r\n}\r\nlet nextModifierID = 0;\r\nclass Modifier {\r\n    constructor() {\r\n        this.instances = [];\r\n        this.id = nextModifierID++;\r\n    }\r\n    static get(base, mods) {\r\n        if (!mods.length)\r\n            return base;\r\n        let exists = mods[0].instances.find(t => t.base == base && sameArray(mods, t.modified));\r\n        if (exists)\r\n            return exists;\r\n        let set = [], tag = new Tag(set, base, mods);\r\n        for (let m of mods)\r\n            m.instances.push(tag);\r\n        let configs = powerSet(mods);\r\n        for (let parent of base.set)\r\n            if (!parent.modified.length)\r\n                for (let config of configs)\r\n                    set.push(Modifier.get(parent, config));\r\n        return tag;\r\n    }\r\n}\r\nfunction sameArray(a, b) {\r\n    return a.length == b.length && a.every((x, i) => x == b[i]);\r\n}\r\nfunction powerSet(array) {\r\n    let sets = [[]];\r\n    for (let i = 0; i < array.length; i++) {\r\n        for (let j = 0, e = sets.length; j < e; j++) {\r\n            sets.push(sets[j].concat(array[i]));\r\n        }\r\n    }\r\n    return sets.sort((a, b) => b.length - a.length);\r\n}\r\n/// This function is used to add a set of tags to a language syntax\r\n/// via [`NodeSet.extend`](#common.NodeSet.extend) or\r\n/// [`LRParser.configure`](#lr.LRParser.configure).\r\n///\r\n/// The argument object maps node selectors to [highlighting\r\n/// tags](#highlight.Tag) or arrays of tags.\r\n///\r\n/// Node selectors may hold one or more (space-separated) node paths.\r\n/// Such a path can be a [node name](#common.NodeType.name), or\r\n/// multiple node names (or `*` wildcards) separated by slash\r\n/// characters, as in `\"Block/Declaration/VariableName\"`. Such a path\r\n/// matches the final node but only if its direct parent nodes are the\r\n/// other nodes mentioned. A `*` in such a path matches any parent,\r\n/// but only a single level—wildcards that match multiple parents\r\n/// aren't supported, both for efficiency reasons and because Lezer\r\n/// trees make it rather hard to reason about what they would match.)\r\n///\r\n/// A path can be ended with `/...` to indicate that the tag assigned\r\n/// to the node should also apply to all child nodes, even if they\r\n/// match their own style (by default, only the innermost style is\r\n/// used).\r\n///\r\n/// When a path ends in `!`, as in `Attribute!`, no further matching\r\n/// happens for the node's child nodes, and the entire node gets the\r\n/// given style.\r\n///\r\n/// In this notation, node names that contain `/`, `!`, `*`, or `...`\r\n/// must be quoted as JSON strings.\r\n///\r\n/// For example:\r\n///\r\n/// ```javascript\r\n/// parser.withProps(\r\n///   styleTags({\r\n///     // Style Number and BigNumber nodes\r\n///     \"Number BigNumber\": tags.number,\r\n///     // Style Escape nodes whose parent is String\r\n///     \"String/Escape\": tags.escape,\r\n///     // Style anything inside Attributes nodes\r\n///     \"Attributes!\": tags.meta,\r\n///     // Add a style to all content inside Italic nodes\r\n///     \"Italic/...\": tags.emphasis,\r\n///     // Style InvalidString nodes as both `string` and `invalid`\r\n///     \"InvalidString\": [tags.string, tags.invalid],\r\n///     // Style the node named \"/\" as punctuation\r\n///     '\"/\"': tags.punctuation\r\n///   })\r\n/// )\r\n/// ```\r\nfunction styleTags(spec) {\r\n    let byName = Object.create(null);\r\n    for (let prop in spec) {\r\n        let tags = spec[prop];\r\n        if (!Array.isArray(tags))\r\n            tags = [tags];\r\n        for (let part of prop.split(\" \"))\r\n            if (part) {\r\n                let pieces = [], mode = 2 /* Mode.Normal */, rest = part;\r\n                for (let pos = 0;;) {\r\n                    if (rest == \"...\" && pos > 0 && pos + 3 == part.length) {\r\n                        mode = 1 /* Mode.Inherit */;\r\n                        break;\r\n                    }\r\n                    let m = /^\"(?:[^\"\\\\]|\\\\.)*?\"|[^\\/!]+/.exec(rest);\r\n                    if (!m)\r\n                        throw new RangeError(\"Invalid path: \" + part);\r\n                    pieces.push(m[0] == \"*\" ? \"\" : m[0][0] == '\"' ? JSON.parse(m[0]) : m[0]);\r\n                    pos += m[0].length;\r\n                    if (pos == part.length)\r\n                        break;\r\n                    let next = part[pos++];\r\n                    if (pos == part.length && next == \"!\") {\r\n                        mode = 0 /* Mode.Opaque */;\r\n                        break;\r\n                    }\r\n                    if (next != \"/\")\r\n                        throw new RangeError(\"Invalid path: \" + part);\r\n                    rest = part.slice(pos);\r\n                }\r\n                let last = pieces.length - 1, inner = pieces[last];\r\n                if (!inner)\r\n                    throw new RangeError(\"Invalid path: \" + part);\r\n                let rule = new Rule(tags, mode, last > 0 ? pieces.slice(0, last) : null);\r\n                byName[inner] = rule.sort(byName[inner]);\r\n            }\r\n    }\r\n    return ruleNodeProp.add(byName);\r\n}\r\nconst ruleNodeProp = new _lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeProp();\r\nclass Rule {\r\n    constructor(tags, mode, context, next) {\r\n        this.tags = tags;\r\n        this.mode = mode;\r\n        this.context = context;\r\n        this.next = next;\r\n    }\r\n    get opaque() { return this.mode == 0 /* Mode.Opaque */; }\r\n    get inherit() { return this.mode == 1 /* Mode.Inherit */; }\r\n    sort(other) {\r\n        if (!other || other.depth < this.depth) {\r\n            this.next = other;\r\n            return this;\r\n        }\r\n        other.next = this.sort(other.next);\r\n        return other;\r\n    }\r\n    get depth() { return this.context ? this.context.length : 0; }\r\n}\r\nRule.empty = new Rule([], 2 /* Mode.Normal */, null);\r\n/// Define a [highlighter](#highlight.Highlighter) from an array of\r\n/// tag/class pairs. Classes associated with more specific tags will\r\n/// take precedence.\r\nfunction tagHighlighter(tags, options) {\r\n    let map = Object.create(null);\r\n    for (let style of tags) {\r\n        if (!Array.isArray(style.tag))\r\n            map[style.tag.id] = style.class;\r\n        else\r\n            for (let tag of style.tag)\r\n                map[tag.id] = style.class;\r\n    }\r\n    let { scope, all = null } = options || {};\r\n    return {\r\n        style: (tags) => {\r\n            let cls = all;\r\n            for (let tag of tags) {\r\n                for (let sub of tag.set) {\r\n                    let tagClass = map[sub.id];\r\n                    if (tagClass) {\r\n                        cls = cls ? cls + \" \" + tagClass : tagClass;\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n            return cls;\r\n        },\r\n        scope\r\n    };\r\n}\r\nfunction highlightTags(highlighters, tags) {\r\n    let result = null;\r\n    for (let highlighter of highlighters) {\r\n        let value = highlighter.style(tags);\r\n        if (value)\r\n            result = result ? result + \" \" + value : value;\r\n    }\r\n    return result;\r\n}\r\n/// Highlight the given [tree](#common.Tree) with the given\r\n/// [highlighter](#highlight.Highlighter).\r\nfunction highlightTree(tree, highlighter, \r\n/// Assign styling to a region of the text. Will be called, in order\r\n/// of position, for any ranges where more than zero classes apply.\r\n/// `classes` is a space separated string of CSS classes.\r\nputStyle, \r\n/// The start of the range to highlight.\r\nfrom = 0, \r\n/// The end of the range.\r\nto = tree.length) {\r\n    let builder = new HighlightBuilder(from, Array.isArray(highlighter) ? highlighter : [highlighter], putStyle);\r\n    builder.highlightRange(tree.cursor(), from, to, \"\", builder.highlighters);\r\n    builder.flush(to);\r\n}\r\nclass HighlightBuilder {\r\n    constructor(at, highlighters, span) {\r\n        this.at = at;\r\n        this.highlighters = highlighters;\r\n        this.span = span;\r\n        this.class = \"\";\r\n    }\r\n    startSpan(at, cls) {\r\n        if (cls != this.class) {\r\n            this.flush(at);\r\n            if (at > this.at)\r\n                this.at = at;\r\n            this.class = cls;\r\n        }\r\n    }\r\n    flush(to) {\r\n        if (to > this.at && this.class)\r\n            this.span(this.at, to, this.class);\r\n    }\r\n    highlightRange(cursor, from, to, inheritedClass, highlighters) {\r\n        let { type, from: start, to: end } = cursor;\r\n        if (start >= to || end <= from)\r\n            return;\r\n        if (type.isTop)\r\n            highlighters = this.highlighters.filter(h => !h.scope || h.scope(type));\r\n        let cls = inheritedClass;\r\n        let rule = getStyleTags(cursor) || Rule.empty;\r\n        let tagCls = highlightTags(highlighters, rule.tags);\r\n        if (tagCls) {\r\n            if (cls)\r\n                cls += \" \";\r\n            cls += tagCls;\r\n            if (rule.mode == 1 /* Mode.Inherit */)\r\n                inheritedClass += (inheritedClass ? \" \" : \"\") + tagCls;\r\n        }\r\n        this.startSpan(cursor.from, cls);\r\n        if (rule.opaque)\r\n            return;\r\n        let mounted = cursor.tree && cursor.tree.prop(_lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeProp.mounted);\r\n        if (mounted && mounted.overlay) {\r\n            let inner = cursor.node.enter(mounted.overlay[0].from + start, 1);\r\n            let innerHighlighters = this.highlighters.filter(h => !h.scope || h.scope(mounted.tree.type));\r\n            let hasChild = cursor.firstChild();\r\n            for (let i = 0, pos = start;; i++) {\r\n                let next = i < mounted.overlay.length ? mounted.overlay[i] : null;\r\n                let nextPos = next ? next.from + start : end;\r\n                let rangeFrom = Math.max(from, pos), rangeTo = Math.min(to, nextPos);\r\n                if (rangeFrom < rangeTo && hasChild) {\r\n                    while (cursor.from < rangeTo) {\r\n                        this.highlightRange(cursor, rangeFrom, rangeTo, inheritedClass, highlighters);\r\n                        this.startSpan(Math.min(rangeTo, cursor.to), cls);\r\n                        if (cursor.to >= nextPos || !cursor.nextSibling())\r\n                            break;\r\n                    }\r\n                }\r\n                if (!next || nextPos > to)\r\n                    break;\r\n                pos = next.to + start;\r\n                if (pos > from) {\r\n                    this.highlightRange(inner.cursor(), Math.max(from, next.from + start), Math.min(to, pos), inheritedClass, innerHighlighters);\r\n                    this.startSpan(pos, cls);\r\n                }\r\n            }\r\n            if (hasChild)\r\n                cursor.parent();\r\n        }\r\n        else if (cursor.firstChild()) {\r\n            do {\r\n                if (cursor.to <= from)\r\n                    continue;\r\n                if (cursor.from >= to)\r\n                    break;\r\n                this.highlightRange(cursor, from, to, inheritedClass, highlighters);\r\n                this.startSpan(Math.min(to, cursor.to), cls);\r\n            } while (cursor.nextSibling());\r\n            cursor.parent();\r\n        }\r\n    }\r\n}\r\n/// Match a syntax node's [highlight rules](#highlight.styleTags). If\r\n/// there's a match, return its set of tags, and whether it is\r\n/// opaque (uses a `!`) or applies to all child nodes (`/...`).\r\nfunction getStyleTags(node) {\r\n    let rule = node.type.prop(ruleNodeProp);\r\n    while (rule && rule.context && !node.matchContext(rule.context))\r\n        rule = rule.next;\r\n    return rule || null;\r\n}\r\nconst t = Tag.define;\r\nconst comment = t(), name = t(), typeName = t(name), propertyName = t(name), literal = t(), string = t(literal), number = t(literal), content = t(), heading = t(content), keyword = t(), operator = t(), punctuation = t(), bracket = t(punctuation), meta = t();\r\n/// The default set of highlighting [tags](#highlight.Tag).\r\n///\r\n/// This collection is heavily biased towards programming languages,\r\n/// and necessarily incomplete. A full ontology of syntactic\r\n/// constructs would fill a stack of books, and be impractical to\r\n/// write themes for. So try to make do with this set. If all else\r\n/// fails, [open an\r\n/// issue](https://github.com/codemirror/codemirror.next) to propose a\r\n/// new tag, or [define](#highlight.Tag^define) a local custom tag for\r\n/// your use case.\r\n///\r\n/// Note that it is not obligatory to always attach the most specific\r\n/// tag possible to an element—if your grammar can't easily\r\n/// distinguish a certain type of element (such as a local variable),\r\n/// it is okay to style it as its more general variant (a variable).\r\n/// \r\n/// For tags that extend some parent tag, the documentation links to\r\n/// the parent.\r\nconst tags = {\r\n    /// A comment.\r\n    comment,\r\n    /// A line [comment](#highlight.tags.comment).\r\n    lineComment: t(comment),\r\n    /// A block [comment](#highlight.tags.comment).\r\n    blockComment: t(comment),\r\n    /// A documentation [comment](#highlight.tags.comment).\r\n    docComment: t(comment),\r\n    /// Any kind of identifier.\r\n    name,\r\n    /// The [name](#highlight.tags.name) of a variable.\r\n    variableName: t(name),\r\n    /// A type [name](#highlight.tags.name).\r\n    typeName: typeName,\r\n    /// A tag name (subtag of [`typeName`](#highlight.tags.typeName)).\r\n    tagName: t(typeName),\r\n    /// A property or field [name](#highlight.tags.name).\r\n    propertyName: propertyName,\r\n    /// An attribute name (subtag of [`propertyName`](#highlight.tags.propertyName)).\r\n    attributeName: t(propertyName),\r\n    /// The [name](#highlight.tags.name) of a class.\r\n    className: t(name),\r\n    /// A label [name](#highlight.tags.name).\r\n    labelName: t(name),\r\n    /// A namespace [name](#highlight.tags.name).\r\n    namespace: t(name),\r\n    /// The [name](#highlight.tags.name) of a macro.\r\n    macroName: t(name),\r\n    /// A literal value.\r\n    literal,\r\n    /// A string [literal](#highlight.tags.literal).\r\n    string,\r\n    /// A documentation [string](#highlight.tags.string).\r\n    docString: t(string),\r\n    /// A character literal (subtag of [string](#highlight.tags.string)).\r\n    character: t(string),\r\n    /// An attribute value (subtag of [string](#highlight.tags.string)).\r\n    attributeValue: t(string),\r\n    /// A number [literal](#highlight.tags.literal).\r\n    number,\r\n    /// An integer [number](#highlight.tags.number) literal.\r\n    integer: t(number),\r\n    /// A floating-point [number](#highlight.tags.number) literal.\r\n    float: t(number),\r\n    /// A boolean [literal](#highlight.tags.literal).\r\n    bool: t(literal),\r\n    /// Regular expression [literal](#highlight.tags.literal).\r\n    regexp: t(literal),\r\n    /// An escape [literal](#highlight.tags.literal), for example a\r\n    /// backslash escape in a string.\r\n    escape: t(literal),\r\n    /// A color [literal](#highlight.tags.literal).\r\n    color: t(literal),\r\n    /// A URL [literal](#highlight.tags.literal).\r\n    url: t(literal),\r\n    /// A language keyword.\r\n    keyword,\r\n    /// The [keyword](#highlight.tags.keyword) for the self or this\r\n    /// object.\r\n    self: t(keyword),\r\n    /// The [keyword](#highlight.tags.keyword) for null.\r\n    null: t(keyword),\r\n    /// A [keyword](#highlight.tags.keyword) denoting some atomic value.\r\n    atom: t(keyword),\r\n    /// A [keyword](#highlight.tags.keyword) that represents a unit.\r\n    unit: t(keyword),\r\n    /// A modifier [keyword](#highlight.tags.keyword).\r\n    modifier: t(keyword),\r\n    /// A [keyword](#highlight.tags.keyword) that acts as an operator.\r\n    operatorKeyword: t(keyword),\r\n    /// A control-flow related [keyword](#highlight.tags.keyword).\r\n    controlKeyword: t(keyword),\r\n    /// A [keyword](#highlight.tags.keyword) that defines something.\r\n    definitionKeyword: t(keyword),\r\n    /// A [keyword](#highlight.tags.keyword) related to defining or\r\n    /// interfacing with modules.\r\n    moduleKeyword: t(keyword),\r\n    /// An operator.\r\n    operator,\r\n    /// An [operator](#highlight.tags.operator) that dereferences something.\r\n    derefOperator: t(operator),\r\n    /// Arithmetic-related [operator](#highlight.tags.operator).\r\n    arithmeticOperator: t(operator),\r\n    /// Logical [operator](#highlight.tags.operator).\r\n    logicOperator: t(operator),\r\n    /// Bit [operator](#highlight.tags.operator).\r\n    bitwiseOperator: t(operator),\r\n    /// Comparison [operator](#highlight.tags.operator).\r\n    compareOperator: t(operator),\r\n    /// [Operator](#highlight.tags.operator) that updates its operand.\r\n    updateOperator: t(operator),\r\n    /// [Operator](#highlight.tags.operator) that defines something.\r\n    definitionOperator: t(operator),\r\n    /// Type-related [operator](#highlight.tags.operator).\r\n    typeOperator: t(operator),\r\n    /// Control-flow [operator](#highlight.tags.operator).\r\n    controlOperator: t(operator),\r\n    /// Program or markup punctuation.\r\n    punctuation,\r\n    /// [Punctuation](#highlight.tags.punctuation) that separates\r\n    /// things.\r\n    separator: t(punctuation),\r\n    /// Bracket-style [punctuation](#highlight.tags.punctuation).\r\n    bracket,\r\n    /// Angle [brackets](#highlight.tags.bracket) (usually `<` and `>`\r\n    /// tokens).\r\n    angleBracket: t(bracket),\r\n    /// Square [brackets](#highlight.tags.bracket) (usually `[` and `]`\r\n    /// tokens).\r\n    squareBracket: t(bracket),\r\n    /// Parentheses (usually `(` and `)` tokens). Subtag of\r\n    /// [bracket](#highlight.tags.bracket).\r\n    paren: t(bracket),\r\n    /// Braces (usually `{` and `}` tokens). Subtag of\r\n    /// [bracket](#highlight.tags.bracket).\r\n    brace: t(bracket),\r\n    /// Content, for example plain text in XML or markup documents.\r\n    content,\r\n    /// [Content](#highlight.tags.content) that represents a heading.\r\n    heading,\r\n    /// A level 1 [heading](#highlight.tags.heading).\r\n    heading1: t(heading),\r\n    /// A level 2 [heading](#highlight.tags.heading).\r\n    heading2: t(heading),\r\n    /// A level 3 [heading](#highlight.tags.heading).\r\n    heading3: t(heading),\r\n    /// A level 4 [heading](#highlight.tags.heading).\r\n    heading4: t(heading),\r\n    /// A level 5 [heading](#highlight.tags.heading).\r\n    heading5: t(heading),\r\n    /// A level 6 [heading](#highlight.tags.heading).\r\n    heading6: t(heading),\r\n    /// A prose separator (such as a horizontal rule).\r\n    contentSeparator: t(content),\r\n    /// [Content](#highlight.tags.content) that represents a list.\r\n    list: t(content),\r\n    /// [Content](#highlight.tags.content) that represents a quote.\r\n    quote: t(content),\r\n    /// [Content](#highlight.tags.content) that is emphasized.\r\n    emphasis: t(content),\r\n    /// [Content](#highlight.tags.content) that is styled strong.\r\n    strong: t(content),\r\n    /// [Content](#highlight.tags.content) that is part of a link.\r\n    link: t(content),\r\n    /// [Content](#highlight.tags.content) that is styled as code or\r\n    /// monospace.\r\n    monospace: t(content),\r\n    /// [Content](#highlight.tags.content) that has a strike-through\r\n    /// style.\r\n    strikethrough: t(content),\r\n    /// Inserted text in a change-tracking format.\r\n    inserted: t(),\r\n    /// Deleted text.\r\n    deleted: t(),\r\n    /// Changed text.\r\n    changed: t(),\r\n    /// An invalid or unsyntactic element.\r\n    invalid: t(),\r\n    /// Metadata or meta-instruction.\r\n    meta,\r\n    /// [Metadata](#highlight.tags.meta) that applies to the entire\r\n    /// document.\r\n    documentMeta: t(meta),\r\n    /// [Metadata](#highlight.tags.meta) that annotates or adds\r\n    /// attributes to a given syntactic element.\r\n    annotation: t(meta),\r\n    /// Processing instruction or preprocessor directive. Subtag of\r\n    /// [meta](#highlight.tags.meta).\r\n    processingInstruction: t(meta),\r\n    /// [Modifier](#highlight.Tag^defineModifier) that indicates that a\r\n    /// given element is being defined. Expected to be used with the\r\n    /// various [name](#highlight.tags.name) tags.\r\n    definition: Tag.defineModifier(),\r\n    /// [Modifier](#highlight.Tag^defineModifier) that indicates that\r\n    /// something is constant. Mostly expected to be used with\r\n    /// [variable names](#highlight.tags.variableName).\r\n    constant: Tag.defineModifier(),\r\n    /// [Modifier](#highlight.Tag^defineModifier) used to indicate that\r\n    /// a [variable](#highlight.tags.variableName) or [property\r\n    /// name](#highlight.tags.propertyName) is being called or defined\r\n    /// as a function.\r\n    function: Tag.defineModifier(),\r\n    /// [Modifier](#highlight.Tag^defineModifier) that can be applied to\r\n    /// [names](#highlight.tags.name) to indicate that they belong to\r\n    /// the language's standard environment.\r\n    standard: Tag.defineModifier(),\r\n    /// [Modifier](#highlight.Tag^defineModifier) that indicates a given\r\n    /// [names](#highlight.tags.name) is local to some scope.\r\n    local: Tag.defineModifier(),\r\n    /// A generic variant [modifier](#highlight.Tag^defineModifier) that\r\n    /// can be used to tag language-specific alternative variants of\r\n    /// some common tag. It is recommended for themes to define special\r\n    /// forms of at least the [string](#highlight.tags.string) and\r\n    /// [variable name](#highlight.tags.variableName) tags, since those\r\n    /// come up a lot.\r\n    special: Tag.defineModifier()\r\n};\r\n/// This is a highlighter that adds stable, predictable classes to\r\n/// tokens, for styling with external CSS.\r\n///\r\n/// The following tags are mapped to their name prefixed with `\"tok-\"`\r\n/// (for example `\"tok-comment\"`):\r\n///\r\n/// * [`link`](#highlight.tags.link)\r\n/// * [`heading`](#highlight.tags.heading)\r\n/// * [`emphasis`](#highlight.tags.emphasis)\r\n/// * [`strong`](#highlight.tags.strong)\r\n/// * [`keyword`](#highlight.tags.keyword)\r\n/// * [`atom`](#highlight.tags.atom)\r\n/// * [`bool`](#highlight.tags.bool)\r\n/// * [`url`](#highlight.tags.url)\r\n/// * [`labelName`](#highlight.tags.labelName)\r\n/// * [`inserted`](#highlight.tags.inserted)\r\n/// * [`deleted`](#highlight.tags.deleted)\r\n/// * [`literal`](#highlight.tags.literal)\r\n/// * [`string`](#highlight.tags.string)\r\n/// * [`number`](#highlight.tags.number)\r\n/// * [`variableName`](#highlight.tags.variableName)\r\n/// * [`typeName`](#highlight.tags.typeName)\r\n/// * [`namespace`](#highlight.tags.namespace)\r\n/// * [`className`](#highlight.tags.className)\r\n/// * [`macroName`](#highlight.tags.macroName)\r\n/// * [`propertyName`](#highlight.tags.propertyName)\r\n/// * [`operator`](#highlight.tags.operator)\r\n/// * [`comment`](#highlight.tags.comment)\r\n/// * [`meta`](#highlight.tags.meta)\r\n/// * [`punctuation`](#highlight.tags.punctuation)\r\n/// * [`invalid`](#highlight.tags.invalid)\r\n///\r\n/// In addition, these mappings are provided:\r\n///\r\n/// * [`regexp`](#highlight.tags.regexp),\r\n///   [`escape`](#highlight.tags.escape), and\r\n///   [`special`](#highlight.tags.special)[`(string)`](#highlight.tags.string)\r\n///   are mapped to `\"tok-string2\"`\r\n/// * [`special`](#highlight.tags.special)[`(variableName)`](#highlight.tags.variableName)\r\n///   to `\"tok-variableName2\"`\r\n/// * [`local`](#highlight.tags.local)[`(variableName)`](#highlight.tags.variableName)\r\n///   to `\"tok-variableName tok-local\"`\r\n/// * [`definition`](#highlight.tags.definition)[`(variableName)`](#highlight.tags.variableName)\r\n///   to `\"tok-variableName tok-definition\"`\r\n/// * [`definition`](#highlight.tags.definition)[`(propertyName)`](#highlight.tags.propertyName)\r\n///   to `\"tok-propertyName tok-definition\"`\r\nconst classHighlighter = tagHighlighter([\r\n    { tag: tags.link, class: \"tok-link\" },\r\n    { tag: tags.heading, class: \"tok-heading\" },\r\n    { tag: tags.emphasis, class: \"tok-emphasis\" },\r\n    { tag: tags.strong, class: \"tok-strong\" },\r\n    { tag: tags.keyword, class: \"tok-keyword\" },\r\n    { tag: tags.atom, class: \"tok-atom\" },\r\n    { tag: tags.bool, class: \"tok-bool\" },\r\n    { tag: tags.url, class: \"tok-url\" },\r\n    { tag: tags.labelName, class: \"tok-labelName\" },\r\n    { tag: tags.inserted, class: \"tok-inserted\" },\r\n    { tag: tags.deleted, class: \"tok-deleted\" },\r\n    { tag: tags.literal, class: \"tok-literal\" },\r\n    { tag: tags.string, class: \"tok-string\" },\r\n    { tag: tags.number, class: \"tok-number\" },\r\n    { tag: [tags.regexp, tags.escape, tags.special(tags.string)], class: \"tok-string2\" },\r\n    { tag: tags.variableName, class: \"tok-variableName\" },\r\n    { tag: tags.local(tags.variableName), class: \"tok-variableName tok-local\" },\r\n    { tag: tags.definition(tags.variableName), class: \"tok-variableName tok-definition\" },\r\n    { tag: tags.special(tags.variableName), class: \"tok-variableName2\" },\r\n    { tag: tags.definition(tags.propertyName), class: \"tok-propertyName tok-definition\" },\r\n    { tag: tags.typeName, class: \"tok-typeName\" },\r\n    { tag: tags.namespace, class: \"tok-namespace\" },\r\n    { tag: tags.className, class: \"tok-className\" },\r\n    { tag: tags.macroName, class: \"tok-macroName\" },\r\n    { tag: tags.propertyName, class: \"tok-propertyName\" },\r\n    { tag: tags.operator, class: \"tok-operator\" },\r\n    { tag: tags.comment, class: \"tok-comment\" },\r\n    { tag: tags.meta, class: \"tok-meta\" },\r\n    { tag: tags.invalid, class: \"tok-invalid\" },\r\n    { tag: tags.punctuation, class: \"tok-punctuation\" }\r\n]);\r\n\r\n\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGxlemVyL2hpZ2hsaWdodC9kaXN0L2luZGV4LmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isa0JBQWtCO0FBQ3RDLHlDQUF5QyxPQUFPO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsbURBQVE7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkIsb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsb0JBQW9CO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLDZCQUE2QjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNELDJEQUFnQjtBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLFFBQVE7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLG1DQUFtQztBQUN6QyxNQUFNLHlDQUF5QztBQUMvQyxNQUFNLDJDQUEyQztBQUNqRCxNQUFNLHVDQUF1QztBQUM3QyxNQUFNLHlDQUF5QztBQUMvQyxNQUFNLG1DQUFtQztBQUN6QyxNQUFNLG1DQUFtQztBQUN6QyxNQUFNLGlDQUFpQztBQUN2QyxNQUFNLDZDQUE2QztBQUNuRCxNQUFNLDJDQUEyQztBQUNqRCxNQUFNLHlDQUF5QztBQUMvQyxNQUFNLHlDQUF5QztBQUMvQyxNQUFNLHVDQUF1QztBQUM3QyxNQUFNLHVDQUF1QztBQUM3QyxNQUFNLGtGQUFrRjtBQUN4RixNQUFNLG1EQUFtRDtBQUN6RCxNQUFNLHlFQUF5RTtBQUMvRSxNQUFNLG1GQUFtRjtBQUN6RixNQUFNLGtFQUFrRTtBQUN4RSxNQUFNLG1GQUFtRjtBQUN6RixNQUFNLDJDQUEyQztBQUNqRCxNQUFNLDZDQUE2QztBQUNuRCxNQUFNLDZDQUE2QztBQUNuRCxNQUFNLDZDQUE2QztBQUNuRCxNQUFNLG1EQUFtRDtBQUN6RCxNQUFNLDJDQUEyQztBQUNqRCxNQUFNLHlDQUF5QztBQUMvQyxNQUFNLG1DQUFtQztBQUN6QyxNQUFNLHlDQUF5QztBQUMvQyxNQUFNO0FBQ047QUFDQTtBQUMrRiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGxlemVyL2hpZ2hsaWdodC9kaXN0L2luZGV4LmpzPzQxMWEiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgTm9kZVByb3AgfSBmcm9tICdAbGV6ZXIvY29tbW9uJztcclxuXHJcbmxldCBuZXh0VGFnSUQgPSAwO1xyXG4vLy8gSGlnaGxpZ2h0aW5nIHRhZ3MgYXJlIG1hcmtlcnMgdGhhdCBkZW5vdGUgYSBoaWdobGlnaHRpbmcgY2F0ZWdvcnkuXHJcbi8vLyBUaGV5IGFyZSBbYXNzb2NpYXRlZF0oI2hpZ2hsaWdodC5zdHlsZVRhZ3MpIHdpdGggcGFydHMgb2YgYSBzeW50YXhcclxuLy8vIHRyZWUgYnkgYSBsYW5ndWFnZSBtb2RlLCBhbmQgdGhlbiBtYXBwZWQgdG8gYW4gYWN0dWFsIENTUyBzdHlsZSBieVxyXG4vLy8gYSBbaGlnaGxpZ2h0ZXJdKCNoaWdobGlnaHQuSGlnaGxpZ2h0ZXIpLlxyXG4vLy9cclxuLy8vIEJlY2F1c2Ugc3ludGF4IHRyZWUgbm9kZSB0eXBlcyBhbmQgaGlnaGxpZ2h0IHN0eWxlcyBoYXZlIHRvIGJlXHJcbi8vLyBhYmxlIHRvIHRhbGsgdGhlIHNhbWUgbGFuZ3VhZ2UsIENvZGVNaXJyb3IgdXNlcyBhIG1vc3RseSBfY2xvc2VkX1xyXG4vLy8gW3ZvY2FidWxhcnldKCNoaWdobGlnaHQudGFncykgb2Ygc3ludGF4IHRhZ3MgKGFzIG9wcG9zZWQgdG9cclxuLy8vIHRyYWRpdGlvbmFsIG9wZW4gc3RyaW5nLWJhc2VkIHN5c3RlbXMsIHdoaWNoIG1ha2UgaXQgaGFyZCBmb3JcclxuLy8vIGhpZ2hsaWdodGluZyB0aGVtZXMgdG8gY292ZXIgYWxsIHRoZSB0b2tlbnMgcHJvZHVjZWQgYnkgdGhlXHJcbi8vLyB2YXJpb3VzIGxhbmd1YWdlcykuXHJcbi8vL1xyXG4vLy8gSXQgX2lzXyBwb3NzaWJsZSB0byBbZGVmaW5lXSgjaGlnaGxpZ2h0LlRhZ15kZWZpbmUpIHlvdXIgb3duXHJcbi8vLyBoaWdobGlnaHRpbmcgdGFncyBmb3Igc3lzdGVtLWludGVybmFsIHVzZSAod2hlcmUgeW91IGNvbnRyb2wgYm90aFxyXG4vLy8gdGhlIGxhbmd1YWdlIHBhY2thZ2UgYW5kIHRoZSBoaWdobGlnaHRlciksIGJ1dCBzdWNoIHRhZ3Mgd2lsbCBub3RcclxuLy8vIGJlIHBpY2tlZCB1cCBieSByZWd1bGFyIGhpZ2hsaWdodGVycyAodGhvdWdoIHlvdSBjYW4gZGVyaXZlIHRoZW1cclxuLy8vIGZyb20gc3RhbmRhcmQgdGFncyB0byBhbGxvdyBoaWdobGlnaHRlcnMgdG8gZmFsbCBiYWNrIHRvIHRob3NlKS5cclxuY2xhc3MgVGFnIHtcclxuICAgIC8vLyBAaW50ZXJuYWxcclxuICAgIGNvbnN0cnVjdG9yKFxyXG4gICAgLy8vIFRoZSBzZXQgb2YgdGhpcyB0YWcgYW5kIGFsbCBpdHMgcGFyZW50IHRhZ3MsIHN0YXJ0aW5nIHdpdGhcclxuICAgIC8vLyB0aGlzIG9uZSBpdHNlbGYgYW5kIHNvcnRlZCBpbiBvcmRlciBvZiBkZWNyZWFzaW5nIHNwZWNpZmljaXR5LlxyXG4gICAgc2V0LCBcclxuICAgIC8vLyBUaGUgYmFzZSB1bm1vZGlmaWVkIHRhZyB0aGF0IHRoaXMgb25lIGlzIGJhc2VkIG9uLCBpZiBpdCdzXHJcbiAgICAvLy8gbW9kaWZpZWQgQGludGVybmFsXHJcbiAgICBiYXNlLCBcclxuICAgIC8vLyBUaGUgbW9kaWZpZXJzIGFwcGxpZWQgdG8gdGhpcy5iYXNlIEBpbnRlcm5hbFxyXG4gICAgbW9kaWZpZWQpIHtcclxuICAgICAgICB0aGlzLnNldCA9IHNldDtcclxuICAgICAgICB0aGlzLmJhc2UgPSBiYXNlO1xyXG4gICAgICAgIHRoaXMubW9kaWZpZWQgPSBtb2RpZmllZDtcclxuICAgICAgICAvLy8gQGludGVybmFsXHJcbiAgICAgICAgdGhpcy5pZCA9IG5leHRUYWdJRCsrO1xyXG4gICAgfVxyXG4gICAgLy8vIERlZmluZSBhIG5ldyB0YWcuIElmIGBwYXJlbnRgIGlzIGdpdmVuLCB0aGUgdGFnIGlzIHRyZWF0ZWQgYXMgYVxyXG4gICAgLy8vIHN1Yi10YWcgb2YgdGhhdCBwYXJlbnQsIGFuZFxyXG4gICAgLy8vIFtoaWdobGlnaHRlcnNdKCNoaWdobGlnaHQudGFnSGlnaGxpZ2h0ZXIpIHRoYXQgZG9uJ3QgbWVudGlvblxyXG4gICAgLy8vIHRoaXMgdGFnIHdpbGwgdHJ5IHRvIGZhbGwgYmFjayB0byB0aGUgcGFyZW50IHRhZyAob3IgZ3JhbmRwYXJlbnRcclxuICAgIC8vLyB0YWcsIGV0YykuXHJcbiAgICBzdGF0aWMgZGVmaW5lKHBhcmVudCkge1xyXG4gICAgICAgIGlmIChwYXJlbnQgPT09IG51bGwgfHwgcGFyZW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYXJlbnQuYmFzZSlcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2FuIG5vdCBkZXJpdmUgZnJvbSBhIG1vZGlmaWVkIHRhZ1wiKTtcclxuICAgICAgICBsZXQgdGFnID0gbmV3IFRhZyhbXSwgbnVsbCwgW10pO1xyXG4gICAgICAgIHRhZy5zZXQucHVzaCh0YWcpO1xyXG4gICAgICAgIGlmIChwYXJlbnQpXHJcbiAgICAgICAgICAgIGZvciAobGV0IHQgb2YgcGFyZW50LnNldClcclxuICAgICAgICAgICAgICAgIHRhZy5zZXQucHVzaCh0KTtcclxuICAgICAgICByZXR1cm4gdGFnO1xyXG4gICAgfVxyXG4gICAgLy8vIERlZmluZSBhIHRhZyBfbW9kaWZpZXJfLCB3aGljaCBpcyBhIGZ1bmN0aW9uIHRoYXQsIGdpdmVuIGEgdGFnLFxyXG4gICAgLy8vIHdpbGwgcmV0dXJuIGEgdGFnIHRoYXQgaXMgYSBzdWJ0YWcgb2YgdGhlIG9yaWdpbmFsLiBBcHBseWluZyB0aGVcclxuICAgIC8vLyBzYW1lIG1vZGlmaWVyIHRvIGEgdHdpY2UgdGFnIHdpbGwgcmV0dXJuIHRoZSBzYW1lIHZhbHVlIChgbTEodDEpXHJcbiAgICAvLy8gPT0gbTEodDEpYCkgYW5kIGFwcGx5aW5nIG11bHRpcGxlIG1vZGlmaWVycyB3aWxsLCByZWdhcmRsZXNzIG9yXHJcbiAgICAvLy8gb3JkZXIsIHByb2R1Y2UgdGhlIHNhbWUgdGFnIChgbTEobTIodDEpKSA9PSBtMihtMSh0MSkpYCkuXHJcbiAgICAvLy9cclxuICAgIC8vLyBXaGVuIG11bHRpcGxlIG1vZGlmaWVycyBhcmUgYXBwbGllZCB0byBhIGdpdmVuIGJhc2UgdGFnLCBlYWNoXHJcbiAgICAvLy8gc21hbGxlciBzZXQgb2YgbW9kaWZpZXJzIGlzIHJlZ2lzdGVyZWQgYXMgYSBwYXJlbnQsIHNvIHRoYXQgZm9yXHJcbiAgICAvLy8gZXhhbXBsZSBgbTEobTIobTModDEpKSlgIGlzIGEgc3VidHlwZSBvZiBgbTEobTIodDEpKWAsXHJcbiAgICAvLy8gYG0xKG0zKHQxKWAsIGFuZCBzbyBvbi5cclxuICAgIHN0YXRpYyBkZWZpbmVNb2RpZmllcigpIHtcclxuICAgICAgICBsZXQgbW9kID0gbmV3IE1vZGlmaWVyO1xyXG4gICAgICAgIHJldHVybiAodGFnKSA9PiB7XHJcbiAgICAgICAgICAgIGlmICh0YWcubW9kaWZpZWQuaW5kZXhPZihtb2QpID4gLTEpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGFnO1xyXG4gICAgICAgICAgICByZXR1cm4gTW9kaWZpZXIuZ2V0KHRhZy5iYXNlIHx8IHRhZywgdGFnLm1vZGlmaWVkLmNvbmNhdChtb2QpLnNvcnQoKGEsIGIpID0+IGEuaWQgLSBiLmlkKSk7XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxufVxyXG5sZXQgbmV4dE1vZGlmaWVySUQgPSAwO1xyXG5jbGFzcyBNb2RpZmllciB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICB0aGlzLmluc3RhbmNlcyA9IFtdO1xyXG4gICAgICAgIHRoaXMuaWQgPSBuZXh0TW9kaWZpZXJJRCsrO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGdldChiYXNlLCBtb2RzKSB7XHJcbiAgICAgICAgaWYgKCFtb2RzLmxlbmd0aClcclxuICAgICAgICAgICAgcmV0dXJuIGJhc2U7XHJcbiAgICAgICAgbGV0IGV4aXN0cyA9IG1vZHNbMF0uaW5zdGFuY2VzLmZpbmQodCA9PiB0LmJhc2UgPT0gYmFzZSAmJiBzYW1lQXJyYXkobW9kcywgdC5tb2RpZmllZCkpO1xyXG4gICAgICAgIGlmIChleGlzdHMpXHJcbiAgICAgICAgICAgIHJldHVybiBleGlzdHM7XHJcbiAgICAgICAgbGV0IHNldCA9IFtdLCB0YWcgPSBuZXcgVGFnKHNldCwgYmFzZSwgbW9kcyk7XHJcbiAgICAgICAgZm9yIChsZXQgbSBvZiBtb2RzKVxyXG4gICAgICAgICAgICBtLmluc3RhbmNlcy5wdXNoKHRhZyk7XHJcbiAgICAgICAgbGV0IGNvbmZpZ3MgPSBwb3dlclNldChtb2RzKTtcclxuICAgICAgICBmb3IgKGxldCBwYXJlbnQgb2YgYmFzZS5zZXQpXHJcbiAgICAgICAgICAgIGlmICghcGFyZW50Lm1vZGlmaWVkLmxlbmd0aClcclxuICAgICAgICAgICAgICAgIGZvciAobGV0IGNvbmZpZyBvZiBjb25maWdzKVxyXG4gICAgICAgICAgICAgICAgICAgIHNldC5wdXNoKE1vZGlmaWVyLmdldChwYXJlbnQsIGNvbmZpZykpO1xyXG4gICAgICAgIHJldHVybiB0YWc7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gc2FtZUFycmF5KGEsIGIpIHtcclxuICAgIHJldHVybiBhLmxlbmd0aCA9PSBiLmxlbmd0aCAmJiBhLmV2ZXJ5KCh4LCBpKSA9PiB4ID09IGJbaV0pO1xyXG59XHJcbmZ1bmN0aW9uIHBvd2VyU2V0KGFycmF5KSB7XHJcbiAgICBsZXQgc2V0cyA9IFtbXV07XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgZm9yIChsZXQgaiA9IDAsIGUgPSBzZXRzLmxlbmd0aDsgaiA8IGU7IGorKykge1xyXG4gICAgICAgICAgICBzZXRzLnB1c2goc2V0c1tqXS5jb25jYXQoYXJyYXlbaV0pKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gc2V0cy5zb3J0KChhLCBiKSA9PiBiLmxlbmd0aCAtIGEubGVuZ3RoKTtcclxufVxyXG4vLy8gVGhpcyBmdW5jdGlvbiBpcyB1c2VkIHRvIGFkZCBhIHNldCBvZiB0YWdzIHRvIGEgbGFuZ3VhZ2Ugc3ludGF4XHJcbi8vLyB2aWEgW2BOb2RlU2V0LmV4dGVuZGBdKCNjb21tb24uTm9kZVNldC5leHRlbmQpIG9yXHJcbi8vLyBbYExSUGFyc2VyLmNvbmZpZ3VyZWBdKCNsci5MUlBhcnNlci5jb25maWd1cmUpLlxyXG4vLy9cclxuLy8vIFRoZSBhcmd1bWVudCBvYmplY3QgbWFwcyBub2RlIHNlbGVjdG9ycyB0byBbaGlnaGxpZ2h0aW5nXHJcbi8vLyB0YWdzXSgjaGlnaGxpZ2h0LlRhZykgb3IgYXJyYXlzIG9mIHRhZ3MuXHJcbi8vL1xyXG4vLy8gTm9kZSBzZWxlY3RvcnMgbWF5IGhvbGQgb25lIG9yIG1vcmUgKHNwYWNlLXNlcGFyYXRlZCkgbm9kZSBwYXRocy5cclxuLy8vIFN1Y2ggYSBwYXRoIGNhbiBiZSBhIFtub2RlIG5hbWVdKCNjb21tb24uTm9kZVR5cGUubmFtZSksIG9yXHJcbi8vLyBtdWx0aXBsZSBub2RlIG5hbWVzIChvciBgKmAgd2lsZGNhcmRzKSBzZXBhcmF0ZWQgYnkgc2xhc2hcclxuLy8vIGNoYXJhY3RlcnMsIGFzIGluIGBcIkJsb2NrL0RlY2xhcmF0aW9uL1ZhcmlhYmxlTmFtZVwiYC4gU3VjaCBhIHBhdGhcclxuLy8vIG1hdGNoZXMgdGhlIGZpbmFsIG5vZGUgYnV0IG9ubHkgaWYgaXRzIGRpcmVjdCBwYXJlbnQgbm9kZXMgYXJlIHRoZVxyXG4vLy8gb3RoZXIgbm9kZXMgbWVudGlvbmVkLiBBIGAqYCBpbiBzdWNoIGEgcGF0aCBtYXRjaGVzIGFueSBwYXJlbnQsXHJcbi8vLyBidXQgb25seSBhIHNpbmdsZSBsZXZlbOKAlHdpbGRjYXJkcyB0aGF0IG1hdGNoIG11bHRpcGxlIHBhcmVudHNcclxuLy8vIGFyZW4ndCBzdXBwb3J0ZWQsIGJvdGggZm9yIGVmZmljaWVuY3kgcmVhc29ucyBhbmQgYmVjYXVzZSBMZXplclxyXG4vLy8gdHJlZXMgbWFrZSBpdCByYXRoZXIgaGFyZCB0byByZWFzb24gYWJvdXQgd2hhdCB0aGV5IHdvdWxkIG1hdGNoLilcclxuLy8vXHJcbi8vLyBBIHBhdGggY2FuIGJlIGVuZGVkIHdpdGggYC8uLi5gIHRvIGluZGljYXRlIHRoYXQgdGhlIHRhZyBhc3NpZ25lZFxyXG4vLy8gdG8gdGhlIG5vZGUgc2hvdWxkIGFsc28gYXBwbHkgdG8gYWxsIGNoaWxkIG5vZGVzLCBldmVuIGlmIHRoZXlcclxuLy8vIG1hdGNoIHRoZWlyIG93biBzdHlsZSAoYnkgZGVmYXVsdCwgb25seSB0aGUgaW5uZXJtb3N0IHN0eWxlIGlzXHJcbi8vLyB1c2VkKS5cclxuLy8vXHJcbi8vLyBXaGVuIGEgcGF0aCBlbmRzIGluIGAhYCwgYXMgaW4gYEF0dHJpYnV0ZSFgLCBubyBmdXJ0aGVyIG1hdGNoaW5nXHJcbi8vLyBoYXBwZW5zIGZvciB0aGUgbm9kZSdzIGNoaWxkIG5vZGVzLCBhbmQgdGhlIGVudGlyZSBub2RlIGdldHMgdGhlXHJcbi8vLyBnaXZlbiBzdHlsZS5cclxuLy8vXHJcbi8vLyBJbiB0aGlzIG5vdGF0aW9uLCBub2RlIG5hbWVzIHRoYXQgY29udGFpbiBgL2AsIGAhYCwgYCpgLCBvciBgLi4uYFxyXG4vLy8gbXVzdCBiZSBxdW90ZWQgYXMgSlNPTiBzdHJpbmdzLlxyXG4vLy9cclxuLy8vIEZvciBleGFtcGxlOlxyXG4vLy9cclxuLy8vIGBgYGphdmFzY3JpcHRcclxuLy8vIHBhcnNlci53aXRoUHJvcHMoXHJcbi8vLyAgIHN0eWxlVGFncyh7XHJcbi8vLyAgICAgLy8gU3R5bGUgTnVtYmVyIGFuZCBCaWdOdW1iZXIgbm9kZXNcclxuLy8vICAgICBcIk51bWJlciBCaWdOdW1iZXJcIjogdGFncy5udW1iZXIsXHJcbi8vLyAgICAgLy8gU3R5bGUgRXNjYXBlIG5vZGVzIHdob3NlIHBhcmVudCBpcyBTdHJpbmdcclxuLy8vICAgICBcIlN0cmluZy9Fc2NhcGVcIjogdGFncy5lc2NhcGUsXHJcbi8vLyAgICAgLy8gU3R5bGUgYW55dGhpbmcgaW5zaWRlIEF0dHJpYnV0ZXMgbm9kZXNcclxuLy8vICAgICBcIkF0dHJpYnV0ZXMhXCI6IHRhZ3MubWV0YSxcclxuLy8vICAgICAvLyBBZGQgYSBzdHlsZSB0byBhbGwgY29udGVudCBpbnNpZGUgSXRhbGljIG5vZGVzXHJcbi8vLyAgICAgXCJJdGFsaWMvLi4uXCI6IHRhZ3MuZW1waGFzaXMsXHJcbi8vLyAgICAgLy8gU3R5bGUgSW52YWxpZFN0cmluZyBub2RlcyBhcyBib3RoIGBzdHJpbmdgIGFuZCBgaW52YWxpZGBcclxuLy8vICAgICBcIkludmFsaWRTdHJpbmdcIjogW3RhZ3Muc3RyaW5nLCB0YWdzLmludmFsaWRdLFxyXG4vLy8gICAgIC8vIFN0eWxlIHRoZSBub2RlIG5hbWVkIFwiL1wiIGFzIHB1bmN0dWF0aW9uXHJcbi8vLyAgICAgJ1wiL1wiJzogdGFncy5wdW5jdHVhdGlvblxyXG4vLy8gICB9KVxyXG4vLy8gKVxyXG4vLy8gYGBgXHJcbmZ1bmN0aW9uIHN0eWxlVGFncyhzcGVjKSB7XHJcbiAgICBsZXQgYnlOYW1lID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcclxuICAgIGZvciAobGV0IHByb3AgaW4gc3BlYykge1xyXG4gICAgICAgIGxldCB0YWdzID0gc3BlY1twcm9wXTtcclxuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkodGFncykpXHJcbiAgICAgICAgICAgIHRhZ3MgPSBbdGFnc107XHJcbiAgICAgICAgZm9yIChsZXQgcGFydCBvZiBwcm9wLnNwbGl0KFwiIFwiKSlcclxuICAgICAgICAgICAgaWYgKHBhcnQpIHtcclxuICAgICAgICAgICAgICAgIGxldCBwaWVjZXMgPSBbXSwgbW9kZSA9IDIgLyogTW9kZS5Ob3JtYWwgKi8sIHJlc3QgPSBwYXJ0O1xyXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgcG9zID0gMDs7KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3QgPT0gXCIuLi5cIiAmJiBwb3MgPiAwICYmIHBvcyArIDMgPT0gcGFydC5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbW9kZSA9IDEgLyogTW9kZS5Jbmhlcml0ICovO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IG0gPSAvXlwiKD86W15cIlxcXFxdfFxcXFwuKSo/XCJ8W15cXC8hXSsvLmV4ZWMocmVzdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFtKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgcGF0aDogXCIgKyBwYXJ0KTtcclxuICAgICAgICAgICAgICAgICAgICBwaWVjZXMucHVzaChtWzBdID09IFwiKlwiID8gXCJcIiA6IG1bMF1bMF0gPT0gJ1wiJyA/IEpTT04ucGFyc2UobVswXSkgOiBtWzBdKTtcclxuICAgICAgICAgICAgICAgICAgICBwb3MgKz0gbVswXS5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBvcyA9PSBwYXJ0Lmxlbmd0aClcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IG5leHQgPSBwYXJ0W3BvcysrXTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAocG9zID09IHBhcnQubGVuZ3RoICYmIG5leHQgPT0gXCIhXCIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbW9kZSA9IDAgLyogTW9kZS5PcGFxdWUgKi87XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAobmV4dCAhPSBcIi9cIilcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIHBhdGg6IFwiICsgcGFydCk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzdCA9IHBhcnQuc2xpY2UocG9zKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGxldCBsYXN0ID0gcGllY2VzLmxlbmd0aCAtIDEsIGlubmVyID0gcGllY2VzW2xhc3RdO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFpbm5lcilcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgcGF0aDogXCIgKyBwYXJ0KTtcclxuICAgICAgICAgICAgICAgIGxldCBydWxlID0gbmV3IFJ1bGUodGFncywgbW9kZSwgbGFzdCA+IDAgPyBwaWVjZXMuc2xpY2UoMCwgbGFzdCkgOiBudWxsKTtcclxuICAgICAgICAgICAgICAgIGJ5TmFtZVtpbm5lcl0gPSBydWxlLnNvcnQoYnlOYW1lW2lubmVyXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBydWxlTm9kZVByb3AuYWRkKGJ5TmFtZSk7XHJcbn1cclxuY29uc3QgcnVsZU5vZGVQcm9wID0gbmV3IE5vZGVQcm9wKCk7XHJcbmNsYXNzIFJ1bGUge1xyXG4gICAgY29uc3RydWN0b3IodGFncywgbW9kZSwgY29udGV4dCwgbmV4dCkge1xyXG4gICAgICAgIHRoaXMudGFncyA9IHRhZ3M7XHJcbiAgICAgICAgdGhpcy5tb2RlID0gbW9kZTtcclxuICAgICAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xyXG4gICAgICAgIHRoaXMubmV4dCA9IG5leHQ7XHJcbiAgICB9XHJcbiAgICBnZXQgb3BhcXVlKCkgeyByZXR1cm4gdGhpcy5tb2RlID09IDAgLyogTW9kZS5PcGFxdWUgKi87IH1cclxuICAgIGdldCBpbmhlcml0KCkgeyByZXR1cm4gdGhpcy5tb2RlID09IDEgLyogTW9kZS5Jbmhlcml0ICovOyB9XHJcbiAgICBzb3J0KG90aGVyKSB7XHJcbiAgICAgICAgaWYgKCFvdGhlciB8fCBvdGhlci5kZXB0aCA8IHRoaXMuZGVwdGgpIHtcclxuICAgICAgICAgICAgdGhpcy5uZXh0ID0gb3RoZXI7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgIH1cclxuICAgICAgICBvdGhlci5uZXh0ID0gdGhpcy5zb3J0KG90aGVyLm5leHQpO1xyXG4gICAgICAgIHJldHVybiBvdGhlcjtcclxuICAgIH1cclxuICAgIGdldCBkZXB0aCgpIHsgcmV0dXJuIHRoaXMuY29udGV4dCA/IHRoaXMuY29udGV4dC5sZW5ndGggOiAwOyB9XHJcbn1cclxuUnVsZS5lbXB0eSA9IG5ldyBSdWxlKFtdLCAyIC8qIE1vZGUuTm9ybWFsICovLCBudWxsKTtcclxuLy8vIERlZmluZSBhIFtoaWdobGlnaHRlcl0oI2hpZ2hsaWdodC5IaWdobGlnaHRlcikgZnJvbSBhbiBhcnJheSBvZlxyXG4vLy8gdGFnL2NsYXNzIHBhaXJzLiBDbGFzc2VzIGFzc29jaWF0ZWQgd2l0aCBtb3JlIHNwZWNpZmljIHRhZ3Mgd2lsbFxyXG4vLy8gdGFrZSBwcmVjZWRlbmNlLlxyXG5mdW5jdGlvbiB0YWdIaWdobGlnaHRlcih0YWdzLCBvcHRpb25zKSB7XHJcbiAgICBsZXQgbWFwID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcclxuICAgIGZvciAobGV0IHN0eWxlIG9mIHRhZ3MpIHtcclxuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoc3R5bGUudGFnKSlcclxuICAgICAgICAgICAgbWFwW3N0eWxlLnRhZy5pZF0gPSBzdHlsZS5jbGFzcztcclxuICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIGZvciAobGV0IHRhZyBvZiBzdHlsZS50YWcpXHJcbiAgICAgICAgICAgICAgICBtYXBbdGFnLmlkXSA9IHN0eWxlLmNsYXNzO1xyXG4gICAgfVxyXG4gICAgbGV0IHsgc2NvcGUsIGFsbCA9IG51bGwgfSA9IG9wdGlvbnMgfHwge307XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHN0eWxlOiAodGFncykgPT4ge1xyXG4gICAgICAgICAgICBsZXQgY2xzID0gYWxsO1xyXG4gICAgICAgICAgICBmb3IgKGxldCB0YWcgb2YgdGFncykge1xyXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgc3ViIG9mIHRhZy5zZXQpIHtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgdGFnQ2xhc3MgPSBtYXBbc3ViLmlkXTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGFnQ2xhc3MpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2xzID0gY2xzID8gY2xzICsgXCIgXCIgKyB0YWdDbGFzcyA6IHRhZ0NsYXNzO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGNscztcclxuICAgICAgICB9LFxyXG4gICAgICAgIHNjb3BlXHJcbiAgICB9O1xyXG59XHJcbmZ1bmN0aW9uIGhpZ2hsaWdodFRhZ3MoaGlnaGxpZ2h0ZXJzLCB0YWdzKSB7XHJcbiAgICBsZXQgcmVzdWx0ID0gbnVsbDtcclxuICAgIGZvciAobGV0IGhpZ2hsaWdodGVyIG9mIGhpZ2hsaWdodGVycykge1xyXG4gICAgICAgIGxldCB2YWx1ZSA9IGhpZ2hsaWdodGVyLnN0eWxlKHRhZ3MpO1xyXG4gICAgICAgIGlmICh2YWx1ZSlcclxuICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0ID8gcmVzdWx0ICsgXCIgXCIgKyB2YWx1ZSA6IHZhbHVlO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufVxyXG4vLy8gSGlnaGxpZ2h0IHRoZSBnaXZlbiBbdHJlZV0oI2NvbW1vbi5UcmVlKSB3aXRoIHRoZSBnaXZlblxyXG4vLy8gW2hpZ2hsaWdodGVyXSgjaGlnaGxpZ2h0LkhpZ2hsaWdodGVyKS5cclxuZnVuY3Rpb24gaGlnaGxpZ2h0VHJlZSh0cmVlLCBoaWdobGlnaHRlciwgXHJcbi8vLyBBc3NpZ24gc3R5bGluZyB0byBhIHJlZ2lvbiBvZiB0aGUgdGV4dC4gV2lsbCBiZSBjYWxsZWQsIGluIG9yZGVyXHJcbi8vLyBvZiBwb3NpdGlvbiwgZm9yIGFueSByYW5nZXMgd2hlcmUgbW9yZSB0aGFuIHplcm8gY2xhc3NlcyBhcHBseS5cclxuLy8vIGBjbGFzc2VzYCBpcyBhIHNwYWNlIHNlcGFyYXRlZCBzdHJpbmcgb2YgQ1NTIGNsYXNzZXMuXHJcbnB1dFN0eWxlLCBcclxuLy8vIFRoZSBzdGFydCBvZiB0aGUgcmFuZ2UgdG8gaGlnaGxpZ2h0LlxyXG5mcm9tID0gMCwgXHJcbi8vLyBUaGUgZW5kIG9mIHRoZSByYW5nZS5cclxudG8gPSB0cmVlLmxlbmd0aCkge1xyXG4gICAgbGV0IGJ1aWxkZXIgPSBuZXcgSGlnaGxpZ2h0QnVpbGRlcihmcm9tLCBBcnJheS5pc0FycmF5KGhpZ2hsaWdodGVyKSA/IGhpZ2hsaWdodGVyIDogW2hpZ2hsaWdodGVyXSwgcHV0U3R5bGUpO1xyXG4gICAgYnVpbGRlci5oaWdobGlnaHRSYW5nZSh0cmVlLmN1cnNvcigpLCBmcm9tLCB0bywgXCJcIiwgYnVpbGRlci5oaWdobGlnaHRlcnMpO1xyXG4gICAgYnVpbGRlci5mbHVzaCh0byk7XHJcbn1cclxuY2xhc3MgSGlnaGxpZ2h0QnVpbGRlciB7XHJcbiAgICBjb25zdHJ1Y3RvcihhdCwgaGlnaGxpZ2h0ZXJzLCBzcGFuKSB7XHJcbiAgICAgICAgdGhpcy5hdCA9IGF0O1xyXG4gICAgICAgIHRoaXMuaGlnaGxpZ2h0ZXJzID0gaGlnaGxpZ2h0ZXJzO1xyXG4gICAgICAgIHRoaXMuc3BhbiA9IHNwYW47XHJcbiAgICAgICAgdGhpcy5jbGFzcyA9IFwiXCI7XHJcbiAgICB9XHJcbiAgICBzdGFydFNwYW4oYXQsIGNscykge1xyXG4gICAgICAgIGlmIChjbHMgIT0gdGhpcy5jbGFzcykge1xyXG4gICAgICAgICAgICB0aGlzLmZsdXNoKGF0KTtcclxuICAgICAgICAgICAgaWYgKGF0ID4gdGhpcy5hdClcclxuICAgICAgICAgICAgICAgIHRoaXMuYXQgPSBhdDtcclxuICAgICAgICAgICAgdGhpcy5jbGFzcyA9IGNscztcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBmbHVzaCh0bykge1xyXG4gICAgICAgIGlmICh0byA+IHRoaXMuYXQgJiYgdGhpcy5jbGFzcylcclxuICAgICAgICAgICAgdGhpcy5zcGFuKHRoaXMuYXQsIHRvLCB0aGlzLmNsYXNzKTtcclxuICAgIH1cclxuICAgIGhpZ2hsaWdodFJhbmdlKGN1cnNvciwgZnJvbSwgdG8sIGluaGVyaXRlZENsYXNzLCBoaWdobGlnaHRlcnMpIHtcclxuICAgICAgICBsZXQgeyB0eXBlLCBmcm9tOiBzdGFydCwgdG86IGVuZCB9ID0gY3Vyc29yO1xyXG4gICAgICAgIGlmIChzdGFydCA+PSB0byB8fCBlbmQgPD0gZnJvbSlcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIGlmICh0eXBlLmlzVG9wKVxyXG4gICAgICAgICAgICBoaWdobGlnaHRlcnMgPSB0aGlzLmhpZ2hsaWdodGVycy5maWx0ZXIoaCA9PiAhaC5zY29wZSB8fCBoLnNjb3BlKHR5cGUpKTtcclxuICAgICAgICBsZXQgY2xzID0gaW5oZXJpdGVkQ2xhc3M7XHJcbiAgICAgICAgbGV0IHJ1bGUgPSBnZXRTdHlsZVRhZ3MoY3Vyc29yKSB8fCBSdWxlLmVtcHR5O1xyXG4gICAgICAgIGxldCB0YWdDbHMgPSBoaWdobGlnaHRUYWdzKGhpZ2hsaWdodGVycywgcnVsZS50YWdzKTtcclxuICAgICAgICBpZiAodGFnQ2xzKSB7XHJcbiAgICAgICAgICAgIGlmIChjbHMpXHJcbiAgICAgICAgICAgICAgICBjbHMgKz0gXCIgXCI7XHJcbiAgICAgICAgICAgIGNscyArPSB0YWdDbHM7XHJcbiAgICAgICAgICAgIGlmIChydWxlLm1vZGUgPT0gMSAvKiBNb2RlLkluaGVyaXQgKi8pXHJcbiAgICAgICAgICAgICAgICBpbmhlcml0ZWRDbGFzcyArPSAoaW5oZXJpdGVkQ2xhc3MgPyBcIiBcIiA6IFwiXCIpICsgdGFnQ2xzO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnN0YXJ0U3BhbihjdXJzb3IuZnJvbSwgY2xzKTtcclxuICAgICAgICBpZiAocnVsZS5vcGFxdWUpXHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICBsZXQgbW91bnRlZCA9IGN1cnNvci50cmVlICYmIGN1cnNvci50cmVlLnByb3AoTm9kZVByb3AubW91bnRlZCk7XHJcbiAgICAgICAgaWYgKG1vdW50ZWQgJiYgbW91bnRlZC5vdmVybGF5KSB7XHJcbiAgICAgICAgICAgIGxldCBpbm5lciA9IGN1cnNvci5ub2RlLmVudGVyKG1vdW50ZWQub3ZlcmxheVswXS5mcm9tICsgc3RhcnQsIDEpO1xyXG4gICAgICAgICAgICBsZXQgaW5uZXJIaWdobGlnaHRlcnMgPSB0aGlzLmhpZ2hsaWdodGVycy5maWx0ZXIoaCA9PiAhaC5zY29wZSB8fCBoLnNjb3BlKG1vdW50ZWQudHJlZS50eXBlKSk7XHJcbiAgICAgICAgICAgIGxldCBoYXNDaGlsZCA9IGN1cnNvci5maXJzdENoaWxkKCk7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBwb3MgPSBzdGFydDs7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgbGV0IG5leHQgPSBpIDwgbW91bnRlZC5vdmVybGF5Lmxlbmd0aCA/IG1vdW50ZWQub3ZlcmxheVtpXSA6IG51bGw7XHJcbiAgICAgICAgICAgICAgICBsZXQgbmV4dFBvcyA9IG5leHQgPyBuZXh0LmZyb20gKyBzdGFydCA6IGVuZDtcclxuICAgICAgICAgICAgICAgIGxldCByYW5nZUZyb20gPSBNYXRoLm1heChmcm9tLCBwb3MpLCByYW5nZVRvID0gTWF0aC5taW4odG8sIG5leHRQb3MpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHJhbmdlRnJvbSA8IHJhbmdlVG8gJiYgaGFzQ2hpbGQpIHtcclxuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoY3Vyc29yLmZyb20gPCByYW5nZVRvKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaGlnaGxpZ2h0UmFuZ2UoY3Vyc29yLCByYW5nZUZyb20sIHJhbmdlVG8sIGluaGVyaXRlZENsYXNzLCBoaWdobGlnaHRlcnMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXJ0U3BhbihNYXRoLm1pbihyYW5nZVRvLCBjdXJzb3IudG8pLCBjbHMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY3Vyc29yLnRvID49IG5leHRQb3MgfHwgIWN1cnNvci5uZXh0U2libGluZygpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKCFuZXh0IHx8IG5leHRQb3MgPiB0bylcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIHBvcyA9IG5leHQudG8gKyBzdGFydDtcclxuICAgICAgICAgICAgICAgIGlmIChwb3MgPiBmcm9tKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5oaWdobGlnaHRSYW5nZShpbm5lci5jdXJzb3IoKSwgTWF0aC5tYXgoZnJvbSwgbmV4dC5mcm9tICsgc3RhcnQpLCBNYXRoLm1pbih0bywgcG9zKSwgaW5oZXJpdGVkQ2xhc3MsIGlubmVySGlnaGxpZ2h0ZXJzKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXJ0U3Bhbihwb3MsIGNscyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGhhc0NoaWxkKVxyXG4gICAgICAgICAgICAgICAgY3Vyc29yLnBhcmVudCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChjdXJzb3IuZmlyc3RDaGlsZCgpKSB7XHJcbiAgICAgICAgICAgIGRvIHtcclxuICAgICAgICAgICAgICAgIGlmIChjdXJzb3IudG8gPD0gZnJvbSlcclxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIGlmIChjdXJzb3IuZnJvbSA+PSB0bylcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIHRoaXMuaGlnaGxpZ2h0UmFuZ2UoY3Vyc29yLCBmcm9tLCB0bywgaW5oZXJpdGVkQ2xhc3MsIGhpZ2hsaWdodGVycyk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXJ0U3BhbihNYXRoLm1pbih0bywgY3Vyc29yLnRvKSwgY2xzKTtcclxuICAgICAgICAgICAgfSB3aGlsZSAoY3Vyc29yLm5leHRTaWJsaW5nKCkpO1xyXG4gICAgICAgICAgICBjdXJzb3IucGFyZW50KCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbi8vLyBNYXRjaCBhIHN5bnRheCBub2RlJ3MgW2hpZ2hsaWdodCBydWxlc10oI2hpZ2hsaWdodC5zdHlsZVRhZ3MpLiBJZlxyXG4vLy8gdGhlcmUncyBhIG1hdGNoLCByZXR1cm4gaXRzIHNldCBvZiB0YWdzLCBhbmQgd2hldGhlciBpdCBpc1xyXG4vLy8gb3BhcXVlICh1c2VzIGEgYCFgKSBvciBhcHBsaWVzIHRvIGFsbCBjaGlsZCBub2RlcyAoYC8uLi5gKS5cclxuZnVuY3Rpb24gZ2V0U3R5bGVUYWdzKG5vZGUpIHtcclxuICAgIGxldCBydWxlID0gbm9kZS50eXBlLnByb3AocnVsZU5vZGVQcm9wKTtcclxuICAgIHdoaWxlIChydWxlICYmIHJ1bGUuY29udGV4dCAmJiAhbm9kZS5tYXRjaENvbnRleHQocnVsZS5jb250ZXh0KSlcclxuICAgICAgICBydWxlID0gcnVsZS5uZXh0O1xyXG4gICAgcmV0dXJuIHJ1bGUgfHwgbnVsbDtcclxufVxyXG5jb25zdCB0ID0gVGFnLmRlZmluZTtcclxuY29uc3QgY29tbWVudCA9IHQoKSwgbmFtZSA9IHQoKSwgdHlwZU5hbWUgPSB0KG5hbWUpLCBwcm9wZXJ0eU5hbWUgPSB0KG5hbWUpLCBsaXRlcmFsID0gdCgpLCBzdHJpbmcgPSB0KGxpdGVyYWwpLCBudW1iZXIgPSB0KGxpdGVyYWwpLCBjb250ZW50ID0gdCgpLCBoZWFkaW5nID0gdChjb250ZW50KSwga2V5d29yZCA9IHQoKSwgb3BlcmF0b3IgPSB0KCksIHB1bmN0dWF0aW9uID0gdCgpLCBicmFja2V0ID0gdChwdW5jdHVhdGlvbiksIG1ldGEgPSB0KCk7XHJcbi8vLyBUaGUgZGVmYXVsdCBzZXQgb2YgaGlnaGxpZ2h0aW5nIFt0YWdzXSgjaGlnaGxpZ2h0LlRhZykuXHJcbi8vL1xyXG4vLy8gVGhpcyBjb2xsZWN0aW9uIGlzIGhlYXZpbHkgYmlhc2VkIHRvd2FyZHMgcHJvZ3JhbW1pbmcgbGFuZ3VhZ2VzLFxyXG4vLy8gYW5kIG5lY2Vzc2FyaWx5IGluY29tcGxldGUuIEEgZnVsbCBvbnRvbG9neSBvZiBzeW50YWN0aWNcclxuLy8vIGNvbnN0cnVjdHMgd291bGQgZmlsbCBhIHN0YWNrIG9mIGJvb2tzLCBhbmQgYmUgaW1wcmFjdGljYWwgdG9cclxuLy8vIHdyaXRlIHRoZW1lcyBmb3IuIFNvIHRyeSB0byBtYWtlIGRvIHdpdGggdGhpcyBzZXQuIElmIGFsbCBlbHNlXHJcbi8vLyBmYWlscywgW29wZW4gYW5cclxuLy8vIGlzc3VlXShodHRwczovL2dpdGh1Yi5jb20vY29kZW1pcnJvci9jb2RlbWlycm9yLm5leHQpIHRvIHByb3Bvc2UgYVxyXG4vLy8gbmV3IHRhZywgb3IgW2RlZmluZV0oI2hpZ2hsaWdodC5UYWdeZGVmaW5lKSBhIGxvY2FsIGN1c3RvbSB0YWcgZm9yXHJcbi8vLyB5b3VyIHVzZSBjYXNlLlxyXG4vLy9cclxuLy8vIE5vdGUgdGhhdCBpdCBpcyBub3Qgb2JsaWdhdG9yeSB0byBhbHdheXMgYXR0YWNoIHRoZSBtb3N0IHNwZWNpZmljXHJcbi8vLyB0YWcgcG9zc2libGUgdG8gYW4gZWxlbWVudOKAlGlmIHlvdXIgZ3JhbW1hciBjYW4ndCBlYXNpbHlcclxuLy8vIGRpc3Rpbmd1aXNoIGEgY2VydGFpbiB0eXBlIG9mIGVsZW1lbnQgKHN1Y2ggYXMgYSBsb2NhbCB2YXJpYWJsZSksXHJcbi8vLyBpdCBpcyBva2F5IHRvIHN0eWxlIGl0IGFzIGl0cyBtb3JlIGdlbmVyYWwgdmFyaWFudCAoYSB2YXJpYWJsZSkuXHJcbi8vLyBcclxuLy8vIEZvciB0YWdzIHRoYXQgZXh0ZW5kIHNvbWUgcGFyZW50IHRhZywgdGhlIGRvY3VtZW50YXRpb24gbGlua3MgdG9cclxuLy8vIHRoZSBwYXJlbnQuXHJcbmNvbnN0IHRhZ3MgPSB7XHJcbiAgICAvLy8gQSBjb21tZW50LlxyXG4gICAgY29tbWVudCxcclxuICAgIC8vLyBBIGxpbmUgW2NvbW1lbnRdKCNoaWdobGlnaHQudGFncy5jb21tZW50KS5cclxuICAgIGxpbmVDb21tZW50OiB0KGNvbW1lbnQpLFxyXG4gICAgLy8vIEEgYmxvY2sgW2NvbW1lbnRdKCNoaWdobGlnaHQudGFncy5jb21tZW50KS5cclxuICAgIGJsb2NrQ29tbWVudDogdChjb21tZW50KSxcclxuICAgIC8vLyBBIGRvY3VtZW50YXRpb24gW2NvbW1lbnRdKCNoaWdobGlnaHQudGFncy5jb21tZW50KS5cclxuICAgIGRvY0NvbW1lbnQ6IHQoY29tbWVudCksXHJcbiAgICAvLy8gQW55IGtpbmQgb2YgaWRlbnRpZmllci5cclxuICAgIG5hbWUsXHJcbiAgICAvLy8gVGhlIFtuYW1lXSgjaGlnaGxpZ2h0LnRhZ3MubmFtZSkgb2YgYSB2YXJpYWJsZS5cclxuICAgIHZhcmlhYmxlTmFtZTogdChuYW1lKSxcclxuICAgIC8vLyBBIHR5cGUgW25hbWVdKCNoaWdobGlnaHQudGFncy5uYW1lKS5cclxuICAgIHR5cGVOYW1lOiB0eXBlTmFtZSxcclxuICAgIC8vLyBBIHRhZyBuYW1lIChzdWJ0YWcgb2YgW2B0eXBlTmFtZWBdKCNoaWdobGlnaHQudGFncy50eXBlTmFtZSkpLlxyXG4gICAgdGFnTmFtZTogdCh0eXBlTmFtZSksXHJcbiAgICAvLy8gQSBwcm9wZXJ0eSBvciBmaWVsZCBbbmFtZV0oI2hpZ2hsaWdodC50YWdzLm5hbWUpLlxyXG4gICAgcHJvcGVydHlOYW1lOiBwcm9wZXJ0eU5hbWUsXHJcbiAgICAvLy8gQW4gYXR0cmlidXRlIG5hbWUgKHN1YnRhZyBvZiBbYHByb3BlcnR5TmFtZWBdKCNoaWdobGlnaHQudGFncy5wcm9wZXJ0eU5hbWUpKS5cclxuICAgIGF0dHJpYnV0ZU5hbWU6IHQocHJvcGVydHlOYW1lKSxcclxuICAgIC8vLyBUaGUgW25hbWVdKCNoaWdobGlnaHQudGFncy5uYW1lKSBvZiBhIGNsYXNzLlxyXG4gICAgY2xhc3NOYW1lOiB0KG5hbWUpLFxyXG4gICAgLy8vIEEgbGFiZWwgW25hbWVdKCNoaWdobGlnaHQudGFncy5uYW1lKS5cclxuICAgIGxhYmVsTmFtZTogdChuYW1lKSxcclxuICAgIC8vLyBBIG5hbWVzcGFjZSBbbmFtZV0oI2hpZ2hsaWdodC50YWdzLm5hbWUpLlxyXG4gICAgbmFtZXNwYWNlOiB0KG5hbWUpLFxyXG4gICAgLy8vIFRoZSBbbmFtZV0oI2hpZ2hsaWdodC50YWdzLm5hbWUpIG9mIGEgbWFjcm8uXHJcbiAgICBtYWNyb05hbWU6IHQobmFtZSksXHJcbiAgICAvLy8gQSBsaXRlcmFsIHZhbHVlLlxyXG4gICAgbGl0ZXJhbCxcclxuICAgIC8vLyBBIHN0cmluZyBbbGl0ZXJhbF0oI2hpZ2hsaWdodC50YWdzLmxpdGVyYWwpLlxyXG4gICAgc3RyaW5nLFxyXG4gICAgLy8vIEEgZG9jdW1lbnRhdGlvbiBbc3RyaW5nXSgjaGlnaGxpZ2h0LnRhZ3Muc3RyaW5nKS5cclxuICAgIGRvY1N0cmluZzogdChzdHJpbmcpLFxyXG4gICAgLy8vIEEgY2hhcmFjdGVyIGxpdGVyYWwgKHN1YnRhZyBvZiBbc3RyaW5nXSgjaGlnaGxpZ2h0LnRhZ3Muc3RyaW5nKSkuXHJcbiAgICBjaGFyYWN0ZXI6IHQoc3RyaW5nKSxcclxuICAgIC8vLyBBbiBhdHRyaWJ1dGUgdmFsdWUgKHN1YnRhZyBvZiBbc3RyaW5nXSgjaGlnaGxpZ2h0LnRhZ3Muc3RyaW5nKSkuXHJcbiAgICBhdHRyaWJ1dGVWYWx1ZTogdChzdHJpbmcpLFxyXG4gICAgLy8vIEEgbnVtYmVyIFtsaXRlcmFsXSgjaGlnaGxpZ2h0LnRhZ3MubGl0ZXJhbCkuXHJcbiAgICBudW1iZXIsXHJcbiAgICAvLy8gQW4gaW50ZWdlciBbbnVtYmVyXSgjaGlnaGxpZ2h0LnRhZ3MubnVtYmVyKSBsaXRlcmFsLlxyXG4gICAgaW50ZWdlcjogdChudW1iZXIpLFxyXG4gICAgLy8vIEEgZmxvYXRpbmctcG9pbnQgW251bWJlcl0oI2hpZ2hsaWdodC50YWdzLm51bWJlcikgbGl0ZXJhbC5cclxuICAgIGZsb2F0OiB0KG51bWJlciksXHJcbiAgICAvLy8gQSBib29sZWFuIFtsaXRlcmFsXSgjaGlnaGxpZ2h0LnRhZ3MubGl0ZXJhbCkuXHJcbiAgICBib29sOiB0KGxpdGVyYWwpLFxyXG4gICAgLy8vIFJlZ3VsYXIgZXhwcmVzc2lvbiBbbGl0ZXJhbF0oI2hpZ2hsaWdodC50YWdzLmxpdGVyYWwpLlxyXG4gICAgcmVnZXhwOiB0KGxpdGVyYWwpLFxyXG4gICAgLy8vIEFuIGVzY2FwZSBbbGl0ZXJhbF0oI2hpZ2hsaWdodC50YWdzLmxpdGVyYWwpLCBmb3IgZXhhbXBsZSBhXHJcbiAgICAvLy8gYmFja3NsYXNoIGVzY2FwZSBpbiBhIHN0cmluZy5cclxuICAgIGVzY2FwZTogdChsaXRlcmFsKSxcclxuICAgIC8vLyBBIGNvbG9yIFtsaXRlcmFsXSgjaGlnaGxpZ2h0LnRhZ3MubGl0ZXJhbCkuXHJcbiAgICBjb2xvcjogdChsaXRlcmFsKSxcclxuICAgIC8vLyBBIFVSTCBbbGl0ZXJhbF0oI2hpZ2hsaWdodC50YWdzLmxpdGVyYWwpLlxyXG4gICAgdXJsOiB0KGxpdGVyYWwpLFxyXG4gICAgLy8vIEEgbGFuZ3VhZ2Uga2V5d29yZC5cclxuICAgIGtleXdvcmQsXHJcbiAgICAvLy8gVGhlIFtrZXl3b3JkXSgjaGlnaGxpZ2h0LnRhZ3Mua2V5d29yZCkgZm9yIHRoZSBzZWxmIG9yIHRoaXNcclxuICAgIC8vLyBvYmplY3QuXHJcbiAgICBzZWxmOiB0KGtleXdvcmQpLFxyXG4gICAgLy8vIFRoZSBba2V5d29yZF0oI2hpZ2hsaWdodC50YWdzLmtleXdvcmQpIGZvciBudWxsLlxyXG4gICAgbnVsbDogdChrZXl3b3JkKSxcclxuICAgIC8vLyBBIFtrZXl3b3JkXSgjaGlnaGxpZ2h0LnRhZ3Mua2V5d29yZCkgZGVub3Rpbmcgc29tZSBhdG9taWMgdmFsdWUuXHJcbiAgICBhdG9tOiB0KGtleXdvcmQpLFxyXG4gICAgLy8vIEEgW2tleXdvcmRdKCNoaWdobGlnaHQudGFncy5rZXl3b3JkKSB0aGF0IHJlcHJlc2VudHMgYSB1bml0LlxyXG4gICAgdW5pdDogdChrZXl3b3JkKSxcclxuICAgIC8vLyBBIG1vZGlmaWVyIFtrZXl3b3JkXSgjaGlnaGxpZ2h0LnRhZ3Mua2V5d29yZCkuXHJcbiAgICBtb2RpZmllcjogdChrZXl3b3JkKSxcclxuICAgIC8vLyBBIFtrZXl3b3JkXSgjaGlnaGxpZ2h0LnRhZ3Mua2V5d29yZCkgdGhhdCBhY3RzIGFzIGFuIG9wZXJhdG9yLlxyXG4gICAgb3BlcmF0b3JLZXl3b3JkOiB0KGtleXdvcmQpLFxyXG4gICAgLy8vIEEgY29udHJvbC1mbG93IHJlbGF0ZWQgW2tleXdvcmRdKCNoaWdobGlnaHQudGFncy5rZXl3b3JkKS5cclxuICAgIGNvbnRyb2xLZXl3b3JkOiB0KGtleXdvcmQpLFxyXG4gICAgLy8vIEEgW2tleXdvcmRdKCNoaWdobGlnaHQudGFncy5rZXl3b3JkKSB0aGF0IGRlZmluZXMgc29tZXRoaW5nLlxyXG4gICAgZGVmaW5pdGlvbktleXdvcmQ6IHQoa2V5d29yZCksXHJcbiAgICAvLy8gQSBba2V5d29yZF0oI2hpZ2hsaWdodC50YWdzLmtleXdvcmQpIHJlbGF0ZWQgdG8gZGVmaW5pbmcgb3JcclxuICAgIC8vLyBpbnRlcmZhY2luZyB3aXRoIG1vZHVsZXMuXHJcbiAgICBtb2R1bGVLZXl3b3JkOiB0KGtleXdvcmQpLFxyXG4gICAgLy8vIEFuIG9wZXJhdG9yLlxyXG4gICAgb3BlcmF0b3IsXHJcbiAgICAvLy8gQW4gW29wZXJhdG9yXSgjaGlnaGxpZ2h0LnRhZ3Mub3BlcmF0b3IpIHRoYXQgZGVyZWZlcmVuY2VzIHNvbWV0aGluZy5cclxuICAgIGRlcmVmT3BlcmF0b3I6IHQob3BlcmF0b3IpLFxyXG4gICAgLy8vIEFyaXRobWV0aWMtcmVsYXRlZCBbb3BlcmF0b3JdKCNoaWdobGlnaHQudGFncy5vcGVyYXRvcikuXHJcbiAgICBhcml0aG1ldGljT3BlcmF0b3I6IHQob3BlcmF0b3IpLFxyXG4gICAgLy8vIExvZ2ljYWwgW29wZXJhdG9yXSgjaGlnaGxpZ2h0LnRhZ3Mub3BlcmF0b3IpLlxyXG4gICAgbG9naWNPcGVyYXRvcjogdChvcGVyYXRvciksXHJcbiAgICAvLy8gQml0IFtvcGVyYXRvcl0oI2hpZ2hsaWdodC50YWdzLm9wZXJhdG9yKS5cclxuICAgIGJpdHdpc2VPcGVyYXRvcjogdChvcGVyYXRvciksXHJcbiAgICAvLy8gQ29tcGFyaXNvbiBbb3BlcmF0b3JdKCNoaWdobGlnaHQudGFncy5vcGVyYXRvcikuXHJcbiAgICBjb21wYXJlT3BlcmF0b3I6IHQob3BlcmF0b3IpLFxyXG4gICAgLy8vIFtPcGVyYXRvcl0oI2hpZ2hsaWdodC50YWdzLm9wZXJhdG9yKSB0aGF0IHVwZGF0ZXMgaXRzIG9wZXJhbmQuXHJcbiAgICB1cGRhdGVPcGVyYXRvcjogdChvcGVyYXRvciksXHJcbiAgICAvLy8gW09wZXJhdG9yXSgjaGlnaGxpZ2h0LnRhZ3Mub3BlcmF0b3IpIHRoYXQgZGVmaW5lcyBzb21ldGhpbmcuXHJcbiAgICBkZWZpbml0aW9uT3BlcmF0b3I6IHQob3BlcmF0b3IpLFxyXG4gICAgLy8vIFR5cGUtcmVsYXRlZCBbb3BlcmF0b3JdKCNoaWdobGlnaHQudGFncy5vcGVyYXRvcikuXHJcbiAgICB0eXBlT3BlcmF0b3I6IHQob3BlcmF0b3IpLFxyXG4gICAgLy8vIENvbnRyb2wtZmxvdyBbb3BlcmF0b3JdKCNoaWdobGlnaHQudGFncy5vcGVyYXRvcikuXHJcbiAgICBjb250cm9sT3BlcmF0b3I6IHQob3BlcmF0b3IpLFxyXG4gICAgLy8vIFByb2dyYW0gb3IgbWFya3VwIHB1bmN0dWF0aW9uLlxyXG4gICAgcHVuY3R1YXRpb24sXHJcbiAgICAvLy8gW1B1bmN0dWF0aW9uXSgjaGlnaGxpZ2h0LnRhZ3MucHVuY3R1YXRpb24pIHRoYXQgc2VwYXJhdGVzXHJcbiAgICAvLy8gdGhpbmdzLlxyXG4gICAgc2VwYXJhdG9yOiB0KHB1bmN0dWF0aW9uKSxcclxuICAgIC8vLyBCcmFja2V0LXN0eWxlIFtwdW5jdHVhdGlvbl0oI2hpZ2hsaWdodC50YWdzLnB1bmN0dWF0aW9uKS5cclxuICAgIGJyYWNrZXQsXHJcbiAgICAvLy8gQW5nbGUgW2JyYWNrZXRzXSgjaGlnaGxpZ2h0LnRhZ3MuYnJhY2tldCkgKHVzdWFsbHkgYDxgIGFuZCBgPmBcclxuICAgIC8vLyB0b2tlbnMpLlxyXG4gICAgYW5nbGVCcmFja2V0OiB0KGJyYWNrZXQpLFxyXG4gICAgLy8vIFNxdWFyZSBbYnJhY2tldHNdKCNoaWdobGlnaHQudGFncy5icmFja2V0KSAodXN1YWxseSBgW2AgYW5kIGBdYFxyXG4gICAgLy8vIHRva2VucykuXHJcbiAgICBzcXVhcmVCcmFja2V0OiB0KGJyYWNrZXQpLFxyXG4gICAgLy8vIFBhcmVudGhlc2VzICh1c3VhbGx5IGAoYCBhbmQgYClgIHRva2VucykuIFN1YnRhZyBvZlxyXG4gICAgLy8vIFticmFja2V0XSgjaGlnaGxpZ2h0LnRhZ3MuYnJhY2tldCkuXHJcbiAgICBwYXJlbjogdChicmFja2V0KSxcclxuICAgIC8vLyBCcmFjZXMgKHVzdWFsbHkgYHtgIGFuZCBgfWAgdG9rZW5zKS4gU3VidGFnIG9mXHJcbiAgICAvLy8gW2JyYWNrZXRdKCNoaWdobGlnaHQudGFncy5icmFja2V0KS5cclxuICAgIGJyYWNlOiB0KGJyYWNrZXQpLFxyXG4gICAgLy8vIENvbnRlbnQsIGZvciBleGFtcGxlIHBsYWluIHRleHQgaW4gWE1MIG9yIG1hcmt1cCBkb2N1bWVudHMuXHJcbiAgICBjb250ZW50LFxyXG4gICAgLy8vIFtDb250ZW50XSgjaGlnaGxpZ2h0LnRhZ3MuY29udGVudCkgdGhhdCByZXByZXNlbnRzIGEgaGVhZGluZy5cclxuICAgIGhlYWRpbmcsXHJcbiAgICAvLy8gQSBsZXZlbCAxIFtoZWFkaW5nXSgjaGlnaGxpZ2h0LnRhZ3MuaGVhZGluZykuXHJcbiAgICBoZWFkaW5nMTogdChoZWFkaW5nKSxcclxuICAgIC8vLyBBIGxldmVsIDIgW2hlYWRpbmddKCNoaWdobGlnaHQudGFncy5oZWFkaW5nKS5cclxuICAgIGhlYWRpbmcyOiB0KGhlYWRpbmcpLFxyXG4gICAgLy8vIEEgbGV2ZWwgMyBbaGVhZGluZ10oI2hpZ2hsaWdodC50YWdzLmhlYWRpbmcpLlxyXG4gICAgaGVhZGluZzM6IHQoaGVhZGluZyksXHJcbiAgICAvLy8gQSBsZXZlbCA0IFtoZWFkaW5nXSgjaGlnaGxpZ2h0LnRhZ3MuaGVhZGluZykuXHJcbiAgICBoZWFkaW5nNDogdChoZWFkaW5nKSxcclxuICAgIC8vLyBBIGxldmVsIDUgW2hlYWRpbmddKCNoaWdobGlnaHQudGFncy5oZWFkaW5nKS5cclxuICAgIGhlYWRpbmc1OiB0KGhlYWRpbmcpLFxyXG4gICAgLy8vIEEgbGV2ZWwgNiBbaGVhZGluZ10oI2hpZ2hsaWdodC50YWdzLmhlYWRpbmcpLlxyXG4gICAgaGVhZGluZzY6IHQoaGVhZGluZyksXHJcbiAgICAvLy8gQSBwcm9zZSBzZXBhcmF0b3IgKHN1Y2ggYXMgYSBob3Jpem9udGFsIHJ1bGUpLlxyXG4gICAgY29udGVudFNlcGFyYXRvcjogdChjb250ZW50KSxcclxuICAgIC8vLyBbQ29udGVudF0oI2hpZ2hsaWdodC50YWdzLmNvbnRlbnQpIHRoYXQgcmVwcmVzZW50cyBhIGxpc3QuXHJcbiAgICBsaXN0OiB0KGNvbnRlbnQpLFxyXG4gICAgLy8vIFtDb250ZW50XSgjaGlnaGxpZ2h0LnRhZ3MuY29udGVudCkgdGhhdCByZXByZXNlbnRzIGEgcXVvdGUuXHJcbiAgICBxdW90ZTogdChjb250ZW50KSxcclxuICAgIC8vLyBbQ29udGVudF0oI2hpZ2hsaWdodC50YWdzLmNvbnRlbnQpIHRoYXQgaXMgZW1waGFzaXplZC5cclxuICAgIGVtcGhhc2lzOiB0KGNvbnRlbnQpLFxyXG4gICAgLy8vIFtDb250ZW50XSgjaGlnaGxpZ2h0LnRhZ3MuY29udGVudCkgdGhhdCBpcyBzdHlsZWQgc3Ryb25nLlxyXG4gICAgc3Ryb25nOiB0KGNvbnRlbnQpLFxyXG4gICAgLy8vIFtDb250ZW50XSgjaGlnaGxpZ2h0LnRhZ3MuY29udGVudCkgdGhhdCBpcyBwYXJ0IG9mIGEgbGluay5cclxuICAgIGxpbms6IHQoY29udGVudCksXHJcbiAgICAvLy8gW0NvbnRlbnRdKCNoaWdobGlnaHQudGFncy5jb250ZW50KSB0aGF0IGlzIHN0eWxlZCBhcyBjb2RlIG9yXHJcbiAgICAvLy8gbW9ub3NwYWNlLlxyXG4gICAgbW9ub3NwYWNlOiB0KGNvbnRlbnQpLFxyXG4gICAgLy8vIFtDb250ZW50XSgjaGlnaGxpZ2h0LnRhZ3MuY29udGVudCkgdGhhdCBoYXMgYSBzdHJpa2UtdGhyb3VnaFxyXG4gICAgLy8vIHN0eWxlLlxyXG4gICAgc3RyaWtldGhyb3VnaDogdChjb250ZW50KSxcclxuICAgIC8vLyBJbnNlcnRlZCB0ZXh0IGluIGEgY2hhbmdlLXRyYWNraW5nIGZvcm1hdC5cclxuICAgIGluc2VydGVkOiB0KCksXHJcbiAgICAvLy8gRGVsZXRlZCB0ZXh0LlxyXG4gICAgZGVsZXRlZDogdCgpLFxyXG4gICAgLy8vIENoYW5nZWQgdGV4dC5cclxuICAgIGNoYW5nZWQ6IHQoKSxcclxuICAgIC8vLyBBbiBpbnZhbGlkIG9yIHVuc3ludGFjdGljIGVsZW1lbnQuXHJcbiAgICBpbnZhbGlkOiB0KCksXHJcbiAgICAvLy8gTWV0YWRhdGEgb3IgbWV0YS1pbnN0cnVjdGlvbi5cclxuICAgIG1ldGEsXHJcbiAgICAvLy8gW01ldGFkYXRhXSgjaGlnaGxpZ2h0LnRhZ3MubWV0YSkgdGhhdCBhcHBsaWVzIHRvIHRoZSBlbnRpcmVcclxuICAgIC8vLyBkb2N1bWVudC5cclxuICAgIGRvY3VtZW50TWV0YTogdChtZXRhKSxcclxuICAgIC8vLyBbTWV0YWRhdGFdKCNoaWdobGlnaHQudGFncy5tZXRhKSB0aGF0IGFubm90YXRlcyBvciBhZGRzXHJcbiAgICAvLy8gYXR0cmlidXRlcyB0byBhIGdpdmVuIHN5bnRhY3RpYyBlbGVtZW50LlxyXG4gICAgYW5ub3RhdGlvbjogdChtZXRhKSxcclxuICAgIC8vLyBQcm9jZXNzaW5nIGluc3RydWN0aW9uIG9yIHByZXByb2Nlc3NvciBkaXJlY3RpdmUuIFN1YnRhZyBvZlxyXG4gICAgLy8vIFttZXRhXSgjaGlnaGxpZ2h0LnRhZ3MubWV0YSkuXHJcbiAgICBwcm9jZXNzaW5nSW5zdHJ1Y3Rpb246IHQobWV0YSksXHJcbiAgICAvLy8gW01vZGlmaWVyXSgjaGlnaGxpZ2h0LlRhZ15kZWZpbmVNb2RpZmllcikgdGhhdCBpbmRpY2F0ZXMgdGhhdCBhXHJcbiAgICAvLy8gZ2l2ZW4gZWxlbWVudCBpcyBiZWluZyBkZWZpbmVkLiBFeHBlY3RlZCB0byBiZSB1c2VkIHdpdGggdGhlXHJcbiAgICAvLy8gdmFyaW91cyBbbmFtZV0oI2hpZ2hsaWdodC50YWdzLm5hbWUpIHRhZ3MuXHJcbiAgICBkZWZpbml0aW9uOiBUYWcuZGVmaW5lTW9kaWZpZXIoKSxcclxuICAgIC8vLyBbTW9kaWZpZXJdKCNoaWdobGlnaHQuVGFnXmRlZmluZU1vZGlmaWVyKSB0aGF0IGluZGljYXRlcyB0aGF0XHJcbiAgICAvLy8gc29tZXRoaW5nIGlzIGNvbnN0YW50LiBNb3N0bHkgZXhwZWN0ZWQgdG8gYmUgdXNlZCB3aXRoXHJcbiAgICAvLy8gW3ZhcmlhYmxlIG5hbWVzXSgjaGlnaGxpZ2h0LnRhZ3MudmFyaWFibGVOYW1lKS5cclxuICAgIGNvbnN0YW50OiBUYWcuZGVmaW5lTW9kaWZpZXIoKSxcclxuICAgIC8vLyBbTW9kaWZpZXJdKCNoaWdobGlnaHQuVGFnXmRlZmluZU1vZGlmaWVyKSB1c2VkIHRvIGluZGljYXRlIHRoYXRcclxuICAgIC8vLyBhIFt2YXJpYWJsZV0oI2hpZ2hsaWdodC50YWdzLnZhcmlhYmxlTmFtZSkgb3IgW3Byb3BlcnR5XHJcbiAgICAvLy8gbmFtZV0oI2hpZ2hsaWdodC50YWdzLnByb3BlcnR5TmFtZSkgaXMgYmVpbmcgY2FsbGVkIG9yIGRlZmluZWRcclxuICAgIC8vLyBhcyBhIGZ1bmN0aW9uLlxyXG4gICAgZnVuY3Rpb246IFRhZy5kZWZpbmVNb2RpZmllcigpLFxyXG4gICAgLy8vIFtNb2RpZmllcl0oI2hpZ2hsaWdodC5UYWdeZGVmaW5lTW9kaWZpZXIpIHRoYXQgY2FuIGJlIGFwcGxpZWQgdG9cclxuICAgIC8vLyBbbmFtZXNdKCNoaWdobGlnaHQudGFncy5uYW1lKSB0byBpbmRpY2F0ZSB0aGF0IHRoZXkgYmVsb25nIHRvXHJcbiAgICAvLy8gdGhlIGxhbmd1YWdlJ3Mgc3RhbmRhcmQgZW52aXJvbm1lbnQuXHJcbiAgICBzdGFuZGFyZDogVGFnLmRlZmluZU1vZGlmaWVyKCksXHJcbiAgICAvLy8gW01vZGlmaWVyXSgjaGlnaGxpZ2h0LlRhZ15kZWZpbmVNb2RpZmllcikgdGhhdCBpbmRpY2F0ZXMgYSBnaXZlblxyXG4gICAgLy8vIFtuYW1lc10oI2hpZ2hsaWdodC50YWdzLm5hbWUpIGlzIGxvY2FsIHRvIHNvbWUgc2NvcGUuXHJcbiAgICBsb2NhbDogVGFnLmRlZmluZU1vZGlmaWVyKCksXHJcbiAgICAvLy8gQSBnZW5lcmljIHZhcmlhbnQgW21vZGlmaWVyXSgjaGlnaGxpZ2h0LlRhZ15kZWZpbmVNb2RpZmllcikgdGhhdFxyXG4gICAgLy8vIGNhbiBiZSB1c2VkIHRvIHRhZyBsYW5ndWFnZS1zcGVjaWZpYyBhbHRlcm5hdGl2ZSB2YXJpYW50cyBvZlxyXG4gICAgLy8vIHNvbWUgY29tbW9uIHRhZy4gSXQgaXMgcmVjb21tZW5kZWQgZm9yIHRoZW1lcyB0byBkZWZpbmUgc3BlY2lhbFxyXG4gICAgLy8vIGZvcm1zIG9mIGF0IGxlYXN0IHRoZSBbc3RyaW5nXSgjaGlnaGxpZ2h0LnRhZ3Muc3RyaW5nKSBhbmRcclxuICAgIC8vLyBbdmFyaWFibGUgbmFtZV0oI2hpZ2hsaWdodC50YWdzLnZhcmlhYmxlTmFtZSkgdGFncywgc2luY2UgdGhvc2VcclxuICAgIC8vLyBjb21lIHVwIGEgbG90LlxyXG4gICAgc3BlY2lhbDogVGFnLmRlZmluZU1vZGlmaWVyKClcclxufTtcclxuLy8vIFRoaXMgaXMgYSBoaWdobGlnaHRlciB0aGF0IGFkZHMgc3RhYmxlLCBwcmVkaWN0YWJsZSBjbGFzc2VzIHRvXHJcbi8vLyB0b2tlbnMsIGZvciBzdHlsaW5nIHdpdGggZXh0ZXJuYWwgQ1NTLlxyXG4vLy9cclxuLy8vIFRoZSBmb2xsb3dpbmcgdGFncyBhcmUgbWFwcGVkIHRvIHRoZWlyIG5hbWUgcHJlZml4ZWQgd2l0aCBgXCJ0b2stXCJgXHJcbi8vLyAoZm9yIGV4YW1wbGUgYFwidG9rLWNvbW1lbnRcImApOlxyXG4vLy9cclxuLy8vICogW2BsaW5rYF0oI2hpZ2hsaWdodC50YWdzLmxpbmspXHJcbi8vLyAqIFtgaGVhZGluZ2BdKCNoaWdobGlnaHQudGFncy5oZWFkaW5nKVxyXG4vLy8gKiBbYGVtcGhhc2lzYF0oI2hpZ2hsaWdodC50YWdzLmVtcGhhc2lzKVxyXG4vLy8gKiBbYHN0cm9uZ2BdKCNoaWdobGlnaHQudGFncy5zdHJvbmcpXHJcbi8vLyAqIFtga2V5d29yZGBdKCNoaWdobGlnaHQudGFncy5rZXl3b3JkKVxyXG4vLy8gKiBbYGF0b21gXSgjaGlnaGxpZ2h0LnRhZ3MuYXRvbSlcclxuLy8vICogW2Bib29sYF0oI2hpZ2hsaWdodC50YWdzLmJvb2wpXHJcbi8vLyAqIFtgdXJsYF0oI2hpZ2hsaWdodC50YWdzLnVybClcclxuLy8vICogW2BsYWJlbE5hbWVgXSgjaGlnaGxpZ2h0LnRhZ3MubGFiZWxOYW1lKVxyXG4vLy8gKiBbYGluc2VydGVkYF0oI2hpZ2hsaWdodC50YWdzLmluc2VydGVkKVxyXG4vLy8gKiBbYGRlbGV0ZWRgXSgjaGlnaGxpZ2h0LnRhZ3MuZGVsZXRlZClcclxuLy8vICogW2BsaXRlcmFsYF0oI2hpZ2hsaWdodC50YWdzLmxpdGVyYWwpXHJcbi8vLyAqIFtgc3RyaW5nYF0oI2hpZ2hsaWdodC50YWdzLnN0cmluZylcclxuLy8vICogW2BudW1iZXJgXSgjaGlnaGxpZ2h0LnRhZ3MubnVtYmVyKVxyXG4vLy8gKiBbYHZhcmlhYmxlTmFtZWBdKCNoaWdobGlnaHQudGFncy52YXJpYWJsZU5hbWUpXHJcbi8vLyAqIFtgdHlwZU5hbWVgXSgjaGlnaGxpZ2h0LnRhZ3MudHlwZU5hbWUpXHJcbi8vLyAqIFtgbmFtZXNwYWNlYF0oI2hpZ2hsaWdodC50YWdzLm5hbWVzcGFjZSlcclxuLy8vICogW2BjbGFzc05hbWVgXSgjaGlnaGxpZ2h0LnRhZ3MuY2xhc3NOYW1lKVxyXG4vLy8gKiBbYG1hY3JvTmFtZWBdKCNoaWdobGlnaHQudGFncy5tYWNyb05hbWUpXHJcbi8vLyAqIFtgcHJvcGVydHlOYW1lYF0oI2hpZ2hsaWdodC50YWdzLnByb3BlcnR5TmFtZSlcclxuLy8vICogW2BvcGVyYXRvcmBdKCNoaWdobGlnaHQudGFncy5vcGVyYXRvcilcclxuLy8vICogW2Bjb21tZW50YF0oI2hpZ2hsaWdodC50YWdzLmNvbW1lbnQpXHJcbi8vLyAqIFtgbWV0YWBdKCNoaWdobGlnaHQudGFncy5tZXRhKVxyXG4vLy8gKiBbYHB1bmN0dWF0aW9uYF0oI2hpZ2hsaWdodC50YWdzLnB1bmN0dWF0aW9uKVxyXG4vLy8gKiBbYGludmFsaWRgXSgjaGlnaGxpZ2h0LnRhZ3MuaW52YWxpZClcclxuLy8vXHJcbi8vLyBJbiBhZGRpdGlvbiwgdGhlc2UgbWFwcGluZ3MgYXJlIHByb3ZpZGVkOlxyXG4vLy9cclxuLy8vICogW2ByZWdleHBgXSgjaGlnaGxpZ2h0LnRhZ3MucmVnZXhwKSxcclxuLy8vICAgW2Blc2NhcGVgXSgjaGlnaGxpZ2h0LnRhZ3MuZXNjYXBlKSwgYW5kXHJcbi8vLyAgIFtgc3BlY2lhbGBdKCNoaWdobGlnaHQudGFncy5zcGVjaWFsKVtgKHN0cmluZylgXSgjaGlnaGxpZ2h0LnRhZ3Muc3RyaW5nKVxyXG4vLy8gICBhcmUgbWFwcGVkIHRvIGBcInRvay1zdHJpbmcyXCJgXHJcbi8vLyAqIFtgc3BlY2lhbGBdKCNoaWdobGlnaHQudGFncy5zcGVjaWFsKVtgKHZhcmlhYmxlTmFtZSlgXSgjaGlnaGxpZ2h0LnRhZ3MudmFyaWFibGVOYW1lKVxyXG4vLy8gICB0byBgXCJ0b2stdmFyaWFibGVOYW1lMlwiYFxyXG4vLy8gKiBbYGxvY2FsYF0oI2hpZ2hsaWdodC50YWdzLmxvY2FsKVtgKHZhcmlhYmxlTmFtZSlgXSgjaGlnaGxpZ2h0LnRhZ3MudmFyaWFibGVOYW1lKVxyXG4vLy8gICB0byBgXCJ0b2stdmFyaWFibGVOYW1lIHRvay1sb2NhbFwiYFxyXG4vLy8gKiBbYGRlZmluaXRpb25gXSgjaGlnaGxpZ2h0LnRhZ3MuZGVmaW5pdGlvbilbYCh2YXJpYWJsZU5hbWUpYF0oI2hpZ2hsaWdodC50YWdzLnZhcmlhYmxlTmFtZSlcclxuLy8vICAgdG8gYFwidG9rLXZhcmlhYmxlTmFtZSB0b2stZGVmaW5pdGlvblwiYFxyXG4vLy8gKiBbYGRlZmluaXRpb25gXSgjaGlnaGxpZ2h0LnRhZ3MuZGVmaW5pdGlvbilbYChwcm9wZXJ0eU5hbWUpYF0oI2hpZ2hsaWdodC50YWdzLnByb3BlcnR5TmFtZSlcclxuLy8vICAgdG8gYFwidG9rLXByb3BlcnR5TmFtZSB0b2stZGVmaW5pdGlvblwiYFxyXG5jb25zdCBjbGFzc0hpZ2hsaWdodGVyID0gdGFnSGlnaGxpZ2h0ZXIoW1xyXG4gICAgeyB0YWc6IHRhZ3MubGluaywgY2xhc3M6IFwidG9rLWxpbmtcIiB9LFxyXG4gICAgeyB0YWc6IHRhZ3MuaGVhZGluZywgY2xhc3M6IFwidG9rLWhlYWRpbmdcIiB9LFxyXG4gICAgeyB0YWc6IHRhZ3MuZW1waGFzaXMsIGNsYXNzOiBcInRvay1lbXBoYXNpc1wiIH0sXHJcbiAgICB7IHRhZzogdGFncy5zdHJvbmcsIGNsYXNzOiBcInRvay1zdHJvbmdcIiB9LFxyXG4gICAgeyB0YWc6IHRhZ3Mua2V5d29yZCwgY2xhc3M6IFwidG9rLWtleXdvcmRcIiB9LFxyXG4gICAgeyB0YWc6IHRhZ3MuYXRvbSwgY2xhc3M6IFwidG9rLWF0b21cIiB9LFxyXG4gICAgeyB0YWc6IHRhZ3MuYm9vbCwgY2xhc3M6IFwidG9rLWJvb2xcIiB9LFxyXG4gICAgeyB0YWc6IHRhZ3MudXJsLCBjbGFzczogXCJ0b2stdXJsXCIgfSxcclxuICAgIHsgdGFnOiB0YWdzLmxhYmVsTmFtZSwgY2xhc3M6IFwidG9rLWxhYmVsTmFtZVwiIH0sXHJcbiAgICB7IHRhZzogdGFncy5pbnNlcnRlZCwgY2xhc3M6IFwidG9rLWluc2VydGVkXCIgfSxcclxuICAgIHsgdGFnOiB0YWdzLmRlbGV0ZWQsIGNsYXNzOiBcInRvay1kZWxldGVkXCIgfSxcclxuICAgIHsgdGFnOiB0YWdzLmxpdGVyYWwsIGNsYXNzOiBcInRvay1saXRlcmFsXCIgfSxcclxuICAgIHsgdGFnOiB0YWdzLnN0cmluZywgY2xhc3M6IFwidG9rLXN0cmluZ1wiIH0sXHJcbiAgICB7IHRhZzogdGFncy5udW1iZXIsIGNsYXNzOiBcInRvay1udW1iZXJcIiB9LFxyXG4gICAgeyB0YWc6IFt0YWdzLnJlZ2V4cCwgdGFncy5lc2NhcGUsIHRhZ3Muc3BlY2lhbCh0YWdzLnN0cmluZyldLCBjbGFzczogXCJ0b2stc3RyaW5nMlwiIH0sXHJcbiAgICB7IHRhZzogdGFncy52YXJpYWJsZU5hbWUsIGNsYXNzOiBcInRvay12YXJpYWJsZU5hbWVcIiB9LFxyXG4gICAgeyB0YWc6IHRhZ3MubG9jYWwodGFncy52YXJpYWJsZU5hbWUpLCBjbGFzczogXCJ0b2stdmFyaWFibGVOYW1lIHRvay1sb2NhbFwiIH0sXHJcbiAgICB7IHRhZzogdGFncy5kZWZpbml0aW9uKHRhZ3MudmFyaWFibGVOYW1lKSwgY2xhc3M6IFwidG9rLXZhcmlhYmxlTmFtZSB0b2stZGVmaW5pdGlvblwiIH0sXHJcbiAgICB7IHRhZzogdGFncy5zcGVjaWFsKHRhZ3MudmFyaWFibGVOYW1lKSwgY2xhc3M6IFwidG9rLXZhcmlhYmxlTmFtZTJcIiB9LFxyXG4gICAgeyB0YWc6IHRhZ3MuZGVmaW5pdGlvbih0YWdzLnByb3BlcnR5TmFtZSksIGNsYXNzOiBcInRvay1wcm9wZXJ0eU5hbWUgdG9rLWRlZmluaXRpb25cIiB9LFxyXG4gICAgeyB0YWc6IHRhZ3MudHlwZU5hbWUsIGNsYXNzOiBcInRvay10eXBlTmFtZVwiIH0sXHJcbiAgICB7IHRhZzogdGFncy5uYW1lc3BhY2UsIGNsYXNzOiBcInRvay1uYW1lc3BhY2VcIiB9LFxyXG4gICAgeyB0YWc6IHRhZ3MuY2xhc3NOYW1lLCBjbGFzczogXCJ0b2stY2xhc3NOYW1lXCIgfSxcclxuICAgIHsgdGFnOiB0YWdzLm1hY3JvTmFtZSwgY2xhc3M6IFwidG9rLW1hY3JvTmFtZVwiIH0sXHJcbiAgICB7IHRhZzogdGFncy5wcm9wZXJ0eU5hbWUsIGNsYXNzOiBcInRvay1wcm9wZXJ0eU5hbWVcIiB9LFxyXG4gICAgeyB0YWc6IHRhZ3Mub3BlcmF0b3IsIGNsYXNzOiBcInRvay1vcGVyYXRvclwiIH0sXHJcbiAgICB7IHRhZzogdGFncy5jb21tZW50LCBjbGFzczogXCJ0b2stY29tbWVudFwiIH0sXHJcbiAgICB7IHRhZzogdGFncy5tZXRhLCBjbGFzczogXCJ0b2stbWV0YVwiIH0sXHJcbiAgICB7IHRhZzogdGFncy5pbnZhbGlkLCBjbGFzczogXCJ0b2staW52YWxpZFwiIH0sXHJcbiAgICB7IHRhZzogdGFncy5wdW5jdHVhdGlvbiwgY2xhc3M6IFwidG9rLXB1bmN0dWF0aW9uXCIgfVxyXG5dKTtcclxuXHJcbmV4cG9ydCB7IFRhZywgY2xhc3NIaWdobGlnaHRlciwgZ2V0U3R5bGVUYWdzLCBoaWdobGlnaHRUcmVlLCBzdHlsZVRhZ3MsIHRhZ0hpZ2hsaWdodGVyLCB0YWdzIH07XHJcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@lezer/highlight/dist/index.js\n"));

/***/ }),

/***/ "./node_modules/crelt/index.es.js":
/*!****************************************!*\
  !*** ./node_modules/crelt/index.es.js ***!
  \****************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ crelt; }\n/* harmony export */ });\nfunction crelt() {\r\n  var elt = arguments[0]\r\n  if (typeof elt == \"string\") elt = document.createElement(elt)\r\n  var i = 1, next = arguments[1]\r\n  if (next && typeof next == \"object\" && next.nodeType == null && !Array.isArray(next)) {\r\n    for (var name in next) if (Object.prototype.hasOwnProperty.call(next, name)) {\r\n      var value = next[name]\r\n      if (typeof value == \"string\") elt.setAttribute(name, value)\r\n      else if (value != null) elt[name] = value\r\n    }\r\n    i++\r\n  }\r\n  for (; i < arguments.length; i++) add(elt, arguments[i])\r\n  return elt\r\n}\r\n\r\nfunction add(elt, child) {\r\n  if (typeof child == \"string\") {\r\n    elt.appendChild(document.createTextNode(child))\r\n  } else if (child == null) {\r\n  } else if (child.nodeType != null) {\r\n    elt.appendChild(child)\r\n  } else if (Array.isArray(child)) {\r\n    for (var i = 0; i < child.length; i++) add(elt, child[i])\r\n  } else {\r\n    throw new RangeError(\"Unsupported child node: \" + child)\r\n  }\r\n}\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvY3JlbHQvaW5kZXguZXMuanMuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsc0JBQXNCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSixJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0osb0JBQW9CLGtCQUFrQjtBQUN0QyxJQUFJO0FBQ0o7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9jcmVsdC9pbmRleC5lcy5qcz84MTk4Il0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGNyZWx0KCkge1xyXG4gIHZhciBlbHQgPSBhcmd1bWVudHNbMF1cclxuICBpZiAodHlwZW9mIGVsdCA9PSBcInN0cmluZ1wiKSBlbHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KGVsdClcclxuICB2YXIgaSA9IDEsIG5leHQgPSBhcmd1bWVudHNbMV1cclxuICBpZiAobmV4dCAmJiB0eXBlb2YgbmV4dCA9PSBcIm9iamVjdFwiICYmIG5leHQubm9kZVR5cGUgPT0gbnVsbCAmJiAhQXJyYXkuaXNBcnJheShuZXh0KSkge1xyXG4gICAgZm9yICh2YXIgbmFtZSBpbiBuZXh0KSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG5leHQsIG5hbWUpKSB7XHJcbiAgICAgIHZhciB2YWx1ZSA9IG5leHRbbmFtZV1cclxuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PSBcInN0cmluZ1wiKSBlbHQuc2V0QXR0cmlidXRlKG5hbWUsIHZhbHVlKVxyXG4gICAgICBlbHNlIGlmICh2YWx1ZSAhPSBudWxsKSBlbHRbbmFtZV0gPSB2YWx1ZVxyXG4gICAgfVxyXG4gICAgaSsrXHJcbiAgfVxyXG4gIGZvciAoOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSBhZGQoZWx0LCBhcmd1bWVudHNbaV0pXHJcbiAgcmV0dXJuIGVsdFxyXG59XHJcblxyXG5mdW5jdGlvbiBhZGQoZWx0LCBjaGlsZCkge1xyXG4gIGlmICh0eXBlb2YgY2hpbGQgPT0gXCJzdHJpbmdcIikge1xyXG4gICAgZWx0LmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNoaWxkKSlcclxuICB9IGVsc2UgaWYgKGNoaWxkID09IG51bGwpIHtcclxuICB9IGVsc2UgaWYgKGNoaWxkLm5vZGVUeXBlICE9IG51bGwpIHtcclxuICAgIGVsdC5hcHBlbmRDaGlsZChjaGlsZClcclxuICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoY2hpbGQpKSB7XHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkLmxlbmd0aDsgaSsrKSBhZGQoZWx0LCBjaGlsZFtpXSlcclxuICB9IGVsc2Uge1xyXG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJVbnN1cHBvcnRlZCBjaGlsZCBub2RlOiBcIiArIGNoaWxkKVxyXG4gIH1cclxufVxyXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/crelt/index.es.js\n"));

/***/ }),

/***/ "./node_modules/style-mod/src/style-mod.js":
/*!*************************************************!*\
  !*** ./node_modules/style-mod/src/style-mod.js ***!
  \*************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"StyleModule\": function() { return /* binding */ StyleModule; }\n/* harmony export */ });\nconst C = \"\\u037c\"\r\nconst COUNT = typeof Symbol == \"undefined\" ? \"__\" + C : Symbol.for(C)\r\nconst SET = typeof Symbol == \"undefined\" ? \"__styleSet\" + Math.floor(Math.random() * 1e8) : Symbol(\"styleSet\")\r\nconst top = typeof globalThis != \"undefined\" ? globalThis : typeof window != \"undefined\" ? window : {}\r\n\r\n// :: - Style modules encapsulate a set of CSS rules defined from\r\n// JavaScript. Their definitions are only available in a given DOM\r\n// root after it has been _mounted_ there with `StyleModule.mount`.\r\n//\r\n// Style modules should be created once and stored somewhere, as\r\n// opposed to re-creating them every time you need them. The amount of\r\n// CSS rules generated for a given DOM root is bounded by the amount\r\n// of style modules that were used. So to avoid leaking rules, don't\r\n// create these dynamically, but treat them as one-time allocations.\r\nclass StyleModule {\r\n  // :: (Object<Style>, ?{finish: ?(string) → string})\r\n  // Create a style module from the given spec.\r\n  //\r\n  // When `finish` is given, it is called on regular (non-`@`)\r\n  // selectors (after `&` expansion) to compute the final selector.\r\n  constructor(spec, options) {\r\n    this.rules = []\r\n    let {finish} = options || {}\r\n\r\n    function splitSelector(selector) {\r\n      return /^@/.test(selector) ? [selector] : selector.split(/,\\s*/)\r\n    }\r\n\r\n    function render(selectors, spec, target, isKeyframes) {\r\n      let local = [], isAt = /^@(\\w+)\\b/.exec(selectors[0]), keyframes = isAt && isAt[1] == \"keyframes\"\r\n      if (isAt && spec == null) return target.push(selectors[0] + \";\")\r\n      for (let prop in spec) {\r\n        let value = spec[prop]\r\n        if (/&/.test(prop)) {\r\n          render(prop.split(/,\\s*/).map(part => selectors.map(sel => part.replace(/&/, sel))).reduce((a, b) => a.concat(b)),\r\n                 value, target)\r\n        } else if (value && typeof value == \"object\") {\r\n          if (!isAt) throw new RangeError(\"The value of a property (\" + prop + \") should be a primitive value.\")\r\n          render(splitSelector(prop), value, local, keyframes)\r\n        } else if (value != null) {\r\n          local.push(prop.replace(/_.*/, \"\").replace(/[A-Z]/g, l => \"-\" + l.toLowerCase()) + \": \" + value + \";\")\r\n        }\r\n      }\r\n      if (local.length || keyframes) {\r\n        target.push((finish && !isAt && !isKeyframes ? selectors.map(finish) : selectors).join(\", \") +\r\n                    \" {\" + local.join(\" \") + \"}\")\r\n      }\r\n    }\r\n\r\n    for (let prop in spec) render(splitSelector(prop), spec[prop], this.rules)\r\n  }\r\n\r\n  // :: () → string\r\n  // Returns a string containing the module's CSS rules.\r\n  getRules() { return this.rules.join(\"\\n\") }\r\n\r\n  // :: () → string\r\n  // Generate a new unique CSS class name.\r\n  static newName() {\r\n    let id = top[COUNT] || 1\r\n    top[COUNT] = id + 1\r\n    return C + id.toString(36)\r\n  }\r\n\r\n  // :: (union<Document, ShadowRoot>, union<[StyleModule], StyleModule>)\r\n  //\r\n  // Mount the given set of modules in the given DOM root, which ensures\r\n  // that the CSS rules defined by the module are available in that\r\n  // context.\r\n  //\r\n  // Rules are only added to the document once per root.\r\n  //\r\n  // Rule order will follow the order of the modules, so that rules from\r\n  // modules later in the array take precedence of those from earlier\r\n  // modules. If you call this function multiple times for the same root\r\n  // in a way that changes the order of already mounted modules, the old\r\n  // order will be changed.\r\n  static mount(root, modules) {\r\n    (root[SET] || new StyleSet(root)).mount(Array.isArray(modules) ? modules : [modules])\r\n  }\r\n}\r\n\r\nlet adoptedSet = null\r\n\r\nclass StyleSet {\r\n  constructor(root) {\r\n    if (!root.head && root.adoptedStyleSheets && typeof CSSStyleSheet != \"undefined\") {\r\n      if (adoptedSet) {\r\n        root.adoptedStyleSheets = [adoptedSet.sheet].concat(root.adoptedStyleSheets)\r\n        return root[SET] = adoptedSet\r\n      }\r\n      this.sheet = new CSSStyleSheet\r\n      root.adoptedStyleSheets = [this.sheet].concat(root.adoptedStyleSheets)\r\n      adoptedSet = this\r\n    } else {\r\n      this.styleTag = (root.ownerDocument || root).createElement(\"style\")\r\n      let target = root.head || root\r\n      target.insertBefore(this.styleTag, target.firstChild)\r\n    }\r\n    this.modules = []\r\n    root[SET] = this\r\n  }\r\n\r\n  mount(modules) {\r\n    let sheet = this.sheet\r\n    let pos = 0 /* Current rule offset */, j = 0 /* Index into this.modules */\r\n    for (let i = 0; i < modules.length; i++) {\r\n      let mod = modules[i], index = this.modules.indexOf(mod)\r\n      if (index < j && index > -1) { // Ordering conflict\r\n        this.modules.splice(index, 1)\r\n        j--\r\n        index = -1\r\n      }\r\n      if (index == -1) {\r\n        this.modules.splice(j++, 0, mod)\r\n        if (sheet) for (let k = 0; k < mod.rules.length; k++)\r\n          sheet.insertRule(mod.rules[k], pos++)\r\n      } else {\r\n        while (j < index) pos += this.modules[j++].rules.length\r\n        pos += mod.rules.length\r\n        j++\r\n      }\r\n    }\r\n\r\n    if (!sheet) {\r\n      let text = \"\"\r\n      for (let i = 0; i < this.modules.length; i++)\r\n        text += this.modules[i].getRules() + \"\\n\"\r\n      this.styleTag.textContent = text\r\n    }\r\n  }\r\n}\r\n\r\n// Style::Object<union<Style,string>>\r\n//\r\n// A style is an object that, in the simple case, maps CSS property\r\n// names to strings holding their values, as in `{color: \"red\",\r\n// fontWeight: \"bold\"}`. The property names can be given in\r\n// camel-case—the library will insert a dash before capital letters\r\n// when converting them to CSS.\r\n//\r\n// If you include an underscore in a property name, it and everything\r\n// after it will be removed from the output, which can be useful when\r\n// providing a property multiple times, for browser compatibility\r\n// reasons.\r\n//\r\n// A property in a style object can also be a sub-selector, which\r\n// extends the current context to add a pseudo-selector or a child\r\n// selector. Such a property should contain a `&` character, which\r\n// will be replaced by the current selector. For example `{\"&:before\":\r\n// {content: '\"hi\"'}}`. Sub-selectors and regular properties can\r\n// freely be mixed in a given object. Any property containing a `&` is\r\n// assumed to be a sub-selector.\r\n//\r\n// Finally, a property can specify an @-block to be wrapped around the\r\n// styles defined inside the object that's the property's value. For\r\n// example to create a media query you can do `{\"@media screen and\r\n// (min-width: 400px)\": {...}}`.\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvc3R5bGUtbW9kL3NyYy9zdHlsZS1tb2QuanMuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLDBCQUEwQiwyQkFBMkI7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxRQUFRO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0VBQW9FO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFVBQVU7QUFDViw4R0FBOEc7QUFDOUc7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsd0JBQXdCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isb0JBQW9CO0FBQ3hDO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxzQkFBc0I7QUFDekQ7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQix5QkFBeUI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtEO0FBQ2xELHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJEO0FBQzNELElBQUksaUJBQWlCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0Q7QUFDaEQseUJBQXlCLEtBQUsiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3N0eWxlLW1vZC9zcmMvc3R5bGUtbW9kLmpzPzZlYjciXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgQyA9IFwiXFx1MDM3Y1wiXHJcbmNvbnN0IENPVU5UID0gdHlwZW9mIFN5bWJvbCA9PSBcInVuZGVmaW5lZFwiID8gXCJfX1wiICsgQyA6IFN5bWJvbC5mb3IoQylcclxuY29uc3QgU0VUID0gdHlwZW9mIFN5bWJvbCA9PSBcInVuZGVmaW5lZFwiID8gXCJfX3N0eWxlU2V0XCIgKyBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAxZTgpIDogU3ltYm9sKFwic3R5bGVTZXRcIilcclxuY29uc3QgdG9wID0gdHlwZW9mIGdsb2JhbFRoaXMgIT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbFRoaXMgOiB0eXBlb2Ygd2luZG93ICE9IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fVxyXG5cclxuLy8gOjogLSBTdHlsZSBtb2R1bGVzIGVuY2Fwc3VsYXRlIGEgc2V0IG9mIENTUyBydWxlcyBkZWZpbmVkIGZyb21cclxuLy8gSmF2YVNjcmlwdC4gVGhlaXIgZGVmaW5pdGlvbnMgYXJlIG9ubHkgYXZhaWxhYmxlIGluIGEgZ2l2ZW4gRE9NXHJcbi8vIHJvb3QgYWZ0ZXIgaXQgaGFzIGJlZW4gX21vdW50ZWRfIHRoZXJlIHdpdGggYFN0eWxlTW9kdWxlLm1vdW50YC5cclxuLy9cclxuLy8gU3R5bGUgbW9kdWxlcyBzaG91bGQgYmUgY3JlYXRlZCBvbmNlIGFuZCBzdG9yZWQgc29tZXdoZXJlLCBhc1xyXG4vLyBvcHBvc2VkIHRvIHJlLWNyZWF0aW5nIHRoZW0gZXZlcnkgdGltZSB5b3UgbmVlZCB0aGVtLiBUaGUgYW1vdW50IG9mXHJcbi8vIENTUyBydWxlcyBnZW5lcmF0ZWQgZm9yIGEgZ2l2ZW4gRE9NIHJvb3QgaXMgYm91bmRlZCBieSB0aGUgYW1vdW50XHJcbi8vIG9mIHN0eWxlIG1vZHVsZXMgdGhhdCB3ZXJlIHVzZWQuIFNvIHRvIGF2b2lkIGxlYWtpbmcgcnVsZXMsIGRvbid0XHJcbi8vIGNyZWF0ZSB0aGVzZSBkeW5hbWljYWxseSwgYnV0IHRyZWF0IHRoZW0gYXMgb25lLXRpbWUgYWxsb2NhdGlvbnMuXHJcbmV4cG9ydCBjbGFzcyBTdHlsZU1vZHVsZSB7XHJcbiAgLy8gOjogKE9iamVjdDxTdHlsZT4sID97ZmluaXNoOiA/KHN0cmluZykg4oaSIHN0cmluZ30pXHJcbiAgLy8gQ3JlYXRlIGEgc3R5bGUgbW9kdWxlIGZyb20gdGhlIGdpdmVuIHNwZWMuXHJcbiAgLy9cclxuICAvLyBXaGVuIGBmaW5pc2hgIGlzIGdpdmVuLCBpdCBpcyBjYWxsZWQgb24gcmVndWxhciAobm9uLWBAYClcclxuICAvLyBzZWxlY3RvcnMgKGFmdGVyIGAmYCBleHBhbnNpb24pIHRvIGNvbXB1dGUgdGhlIGZpbmFsIHNlbGVjdG9yLlxyXG4gIGNvbnN0cnVjdG9yKHNwZWMsIG9wdGlvbnMpIHtcclxuICAgIHRoaXMucnVsZXMgPSBbXVxyXG4gICAgbGV0IHtmaW5pc2h9ID0gb3B0aW9ucyB8fCB7fVxyXG5cclxuICAgIGZ1bmN0aW9uIHNwbGl0U2VsZWN0b3Ioc2VsZWN0b3IpIHtcclxuICAgICAgcmV0dXJuIC9eQC8udGVzdChzZWxlY3RvcikgPyBbc2VsZWN0b3JdIDogc2VsZWN0b3Iuc3BsaXQoLyxcXHMqLylcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiByZW5kZXIoc2VsZWN0b3JzLCBzcGVjLCB0YXJnZXQsIGlzS2V5ZnJhbWVzKSB7XHJcbiAgICAgIGxldCBsb2NhbCA9IFtdLCBpc0F0ID0gL15AKFxcdyspXFxiLy5leGVjKHNlbGVjdG9yc1swXSksIGtleWZyYW1lcyA9IGlzQXQgJiYgaXNBdFsxXSA9PSBcImtleWZyYW1lc1wiXHJcbiAgICAgIGlmIChpc0F0ICYmIHNwZWMgPT0gbnVsbCkgcmV0dXJuIHRhcmdldC5wdXNoKHNlbGVjdG9yc1swXSArIFwiO1wiKVxyXG4gICAgICBmb3IgKGxldCBwcm9wIGluIHNwZWMpIHtcclxuICAgICAgICBsZXQgdmFsdWUgPSBzcGVjW3Byb3BdXHJcbiAgICAgICAgaWYgKC8mLy50ZXN0KHByb3ApKSB7XHJcbiAgICAgICAgICByZW5kZXIocHJvcC5zcGxpdCgvLFxccyovKS5tYXAocGFydCA9PiBzZWxlY3RvcnMubWFwKHNlbCA9PiBwYXJ0LnJlcGxhY2UoLyYvLCBzZWwpKSkucmVkdWNlKChhLCBiKSA9PiBhLmNvbmNhdChiKSksXHJcbiAgICAgICAgICAgICAgICAgdmFsdWUsIHRhcmdldClcclxuICAgICAgICB9IGVsc2UgaWYgKHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PSBcIm9iamVjdFwiKSB7XHJcbiAgICAgICAgICBpZiAoIWlzQXQpIHRocm93IG5ldyBSYW5nZUVycm9yKFwiVGhlIHZhbHVlIG9mIGEgcHJvcGVydHkgKFwiICsgcHJvcCArIFwiKSBzaG91bGQgYmUgYSBwcmltaXRpdmUgdmFsdWUuXCIpXHJcbiAgICAgICAgICByZW5kZXIoc3BsaXRTZWxlY3Rvcihwcm9wKSwgdmFsdWUsIGxvY2FsLCBrZXlmcmFtZXMpXHJcbiAgICAgICAgfSBlbHNlIGlmICh2YWx1ZSAhPSBudWxsKSB7XHJcbiAgICAgICAgICBsb2NhbC5wdXNoKHByb3AucmVwbGFjZSgvXy4qLywgXCJcIikucmVwbGFjZSgvW0EtWl0vZywgbCA9PiBcIi1cIiArIGwudG9Mb3dlckNhc2UoKSkgKyBcIjogXCIgKyB2YWx1ZSArIFwiO1wiKVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICBpZiAobG9jYWwubGVuZ3RoIHx8IGtleWZyYW1lcykge1xyXG4gICAgICAgIHRhcmdldC5wdXNoKChmaW5pc2ggJiYgIWlzQXQgJiYgIWlzS2V5ZnJhbWVzID8gc2VsZWN0b3JzLm1hcChmaW5pc2gpIDogc2VsZWN0b3JzKS5qb2luKFwiLCBcIikgK1xyXG4gICAgICAgICAgICAgICAgICAgIFwiIHtcIiArIGxvY2FsLmpvaW4oXCIgXCIpICsgXCJ9XCIpXHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmb3IgKGxldCBwcm9wIGluIHNwZWMpIHJlbmRlcihzcGxpdFNlbGVjdG9yKHByb3ApLCBzcGVjW3Byb3BdLCB0aGlzLnJ1bGVzKVxyXG4gIH1cclxuXHJcbiAgLy8gOjogKCkg4oaSIHN0cmluZ1xyXG4gIC8vIFJldHVybnMgYSBzdHJpbmcgY29udGFpbmluZyB0aGUgbW9kdWxlJ3MgQ1NTIHJ1bGVzLlxyXG4gIGdldFJ1bGVzKCkgeyByZXR1cm4gdGhpcy5ydWxlcy5qb2luKFwiXFxuXCIpIH1cclxuXHJcbiAgLy8gOjogKCkg4oaSIHN0cmluZ1xyXG4gIC8vIEdlbmVyYXRlIGEgbmV3IHVuaXF1ZSBDU1MgY2xhc3MgbmFtZS5cclxuICBzdGF0aWMgbmV3TmFtZSgpIHtcclxuICAgIGxldCBpZCA9IHRvcFtDT1VOVF0gfHwgMVxyXG4gICAgdG9wW0NPVU5UXSA9IGlkICsgMVxyXG4gICAgcmV0dXJuIEMgKyBpZC50b1N0cmluZygzNilcclxuICB9XHJcblxyXG4gIC8vIDo6ICh1bmlvbjxEb2N1bWVudCwgU2hhZG93Um9vdD4sIHVuaW9uPFtTdHlsZU1vZHVsZV0sIFN0eWxlTW9kdWxlPilcclxuICAvL1xyXG4gIC8vIE1vdW50IHRoZSBnaXZlbiBzZXQgb2YgbW9kdWxlcyBpbiB0aGUgZ2l2ZW4gRE9NIHJvb3QsIHdoaWNoIGVuc3VyZXNcclxuICAvLyB0aGF0IHRoZSBDU1MgcnVsZXMgZGVmaW5lZCBieSB0aGUgbW9kdWxlIGFyZSBhdmFpbGFibGUgaW4gdGhhdFxyXG4gIC8vIGNvbnRleHQuXHJcbiAgLy9cclxuICAvLyBSdWxlcyBhcmUgb25seSBhZGRlZCB0byB0aGUgZG9jdW1lbnQgb25jZSBwZXIgcm9vdC5cclxuICAvL1xyXG4gIC8vIFJ1bGUgb3JkZXIgd2lsbCBmb2xsb3cgdGhlIG9yZGVyIG9mIHRoZSBtb2R1bGVzLCBzbyB0aGF0IHJ1bGVzIGZyb21cclxuICAvLyBtb2R1bGVzIGxhdGVyIGluIHRoZSBhcnJheSB0YWtlIHByZWNlZGVuY2Ugb2YgdGhvc2UgZnJvbSBlYXJsaWVyXHJcbiAgLy8gbW9kdWxlcy4gSWYgeW91IGNhbGwgdGhpcyBmdW5jdGlvbiBtdWx0aXBsZSB0aW1lcyBmb3IgdGhlIHNhbWUgcm9vdFxyXG4gIC8vIGluIGEgd2F5IHRoYXQgY2hhbmdlcyB0aGUgb3JkZXIgb2YgYWxyZWFkeSBtb3VudGVkIG1vZHVsZXMsIHRoZSBvbGRcclxuICAvLyBvcmRlciB3aWxsIGJlIGNoYW5nZWQuXHJcbiAgc3RhdGljIG1vdW50KHJvb3QsIG1vZHVsZXMpIHtcclxuICAgIChyb290W1NFVF0gfHwgbmV3IFN0eWxlU2V0KHJvb3QpKS5tb3VudChBcnJheS5pc0FycmF5KG1vZHVsZXMpID8gbW9kdWxlcyA6IFttb2R1bGVzXSlcclxuICB9XHJcbn1cclxuXHJcbmxldCBhZG9wdGVkU2V0ID0gbnVsbFxyXG5cclxuY2xhc3MgU3R5bGVTZXQge1xyXG4gIGNvbnN0cnVjdG9yKHJvb3QpIHtcclxuICAgIGlmICghcm9vdC5oZWFkICYmIHJvb3QuYWRvcHRlZFN0eWxlU2hlZXRzICYmIHR5cGVvZiBDU1NTdHlsZVNoZWV0ICE9IFwidW5kZWZpbmVkXCIpIHtcclxuICAgICAgaWYgKGFkb3B0ZWRTZXQpIHtcclxuICAgICAgICByb290LmFkb3B0ZWRTdHlsZVNoZWV0cyA9IFthZG9wdGVkU2V0LnNoZWV0XS5jb25jYXQocm9vdC5hZG9wdGVkU3R5bGVTaGVldHMpXHJcbiAgICAgICAgcmV0dXJuIHJvb3RbU0VUXSA9IGFkb3B0ZWRTZXRcclxuICAgICAgfVxyXG4gICAgICB0aGlzLnNoZWV0ID0gbmV3IENTU1N0eWxlU2hlZXRcclxuICAgICAgcm9vdC5hZG9wdGVkU3R5bGVTaGVldHMgPSBbdGhpcy5zaGVldF0uY29uY2F0KHJvb3QuYWRvcHRlZFN0eWxlU2hlZXRzKVxyXG4gICAgICBhZG9wdGVkU2V0ID0gdGhpc1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdGhpcy5zdHlsZVRhZyA9IChyb290Lm93bmVyRG9jdW1lbnQgfHwgcm9vdCkuY3JlYXRlRWxlbWVudChcInN0eWxlXCIpXHJcbiAgICAgIGxldCB0YXJnZXQgPSByb290LmhlYWQgfHwgcm9vdFxyXG4gICAgICB0YXJnZXQuaW5zZXJ0QmVmb3JlKHRoaXMuc3R5bGVUYWcsIHRhcmdldC5maXJzdENoaWxkKVxyXG4gICAgfVxyXG4gICAgdGhpcy5tb2R1bGVzID0gW11cclxuICAgIHJvb3RbU0VUXSA9IHRoaXNcclxuICB9XHJcblxyXG4gIG1vdW50KG1vZHVsZXMpIHtcclxuICAgIGxldCBzaGVldCA9IHRoaXMuc2hlZXRcclxuICAgIGxldCBwb3MgPSAwIC8qIEN1cnJlbnQgcnVsZSBvZmZzZXQgKi8sIGogPSAwIC8qIEluZGV4IGludG8gdGhpcy5tb2R1bGVzICovXHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1vZHVsZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgbGV0IG1vZCA9IG1vZHVsZXNbaV0sIGluZGV4ID0gdGhpcy5tb2R1bGVzLmluZGV4T2YobW9kKVxyXG4gICAgICBpZiAoaW5kZXggPCBqICYmIGluZGV4ID4gLTEpIHsgLy8gT3JkZXJpbmcgY29uZmxpY3RcclxuICAgICAgICB0aGlzLm1vZHVsZXMuc3BsaWNlKGluZGV4LCAxKVxyXG4gICAgICAgIGotLVxyXG4gICAgICAgIGluZGV4ID0gLTFcclxuICAgICAgfVxyXG4gICAgICBpZiAoaW5kZXggPT0gLTEpIHtcclxuICAgICAgICB0aGlzLm1vZHVsZXMuc3BsaWNlKGorKywgMCwgbW9kKVxyXG4gICAgICAgIGlmIChzaGVldCkgZm9yIChsZXQgayA9IDA7IGsgPCBtb2QucnVsZXMubGVuZ3RoOyBrKyspXHJcbiAgICAgICAgICBzaGVldC5pbnNlcnRSdWxlKG1vZC5ydWxlc1trXSwgcG9zKyspXHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgd2hpbGUgKGogPCBpbmRleCkgcG9zICs9IHRoaXMubW9kdWxlc1tqKytdLnJ1bGVzLmxlbmd0aFxyXG4gICAgICAgIHBvcyArPSBtb2QucnVsZXMubGVuZ3RoXHJcbiAgICAgICAgaisrXHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBpZiAoIXNoZWV0KSB7XHJcbiAgICAgIGxldCB0ZXh0ID0gXCJcIlxyXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubW9kdWxlcy5sZW5ndGg7IGkrKylcclxuICAgICAgICB0ZXh0ICs9IHRoaXMubW9kdWxlc1tpXS5nZXRSdWxlcygpICsgXCJcXG5cIlxyXG4gICAgICB0aGlzLnN0eWxlVGFnLnRleHRDb250ZW50ID0gdGV4dFxyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxuLy8gU3R5bGU6Ok9iamVjdDx1bmlvbjxTdHlsZSxzdHJpbmc+PlxyXG4vL1xyXG4vLyBBIHN0eWxlIGlzIGFuIG9iamVjdCB0aGF0LCBpbiB0aGUgc2ltcGxlIGNhc2UsIG1hcHMgQ1NTIHByb3BlcnR5XHJcbi8vIG5hbWVzIHRvIHN0cmluZ3MgaG9sZGluZyB0aGVpciB2YWx1ZXMsIGFzIGluIGB7Y29sb3I6IFwicmVkXCIsXHJcbi8vIGZvbnRXZWlnaHQ6IFwiYm9sZFwifWAuIFRoZSBwcm9wZXJ0eSBuYW1lcyBjYW4gYmUgZ2l2ZW4gaW5cclxuLy8gY2FtZWwtY2FzZeKAlHRoZSBsaWJyYXJ5IHdpbGwgaW5zZXJ0IGEgZGFzaCBiZWZvcmUgY2FwaXRhbCBsZXR0ZXJzXHJcbi8vIHdoZW4gY29udmVydGluZyB0aGVtIHRvIENTUy5cclxuLy9cclxuLy8gSWYgeW91IGluY2x1ZGUgYW4gdW5kZXJzY29yZSBpbiBhIHByb3BlcnR5IG5hbWUsIGl0IGFuZCBldmVyeXRoaW5nXHJcbi8vIGFmdGVyIGl0IHdpbGwgYmUgcmVtb3ZlZCBmcm9tIHRoZSBvdXRwdXQsIHdoaWNoIGNhbiBiZSB1c2VmdWwgd2hlblxyXG4vLyBwcm92aWRpbmcgYSBwcm9wZXJ0eSBtdWx0aXBsZSB0aW1lcywgZm9yIGJyb3dzZXIgY29tcGF0aWJpbGl0eVxyXG4vLyByZWFzb25zLlxyXG4vL1xyXG4vLyBBIHByb3BlcnR5IGluIGEgc3R5bGUgb2JqZWN0IGNhbiBhbHNvIGJlIGEgc3ViLXNlbGVjdG9yLCB3aGljaFxyXG4vLyBleHRlbmRzIHRoZSBjdXJyZW50IGNvbnRleHQgdG8gYWRkIGEgcHNldWRvLXNlbGVjdG9yIG9yIGEgY2hpbGRcclxuLy8gc2VsZWN0b3IuIFN1Y2ggYSBwcm9wZXJ0eSBzaG91bGQgY29udGFpbiBhIGAmYCBjaGFyYWN0ZXIsIHdoaWNoXHJcbi8vIHdpbGwgYmUgcmVwbGFjZWQgYnkgdGhlIGN1cnJlbnQgc2VsZWN0b3IuIEZvciBleGFtcGxlIGB7XCImOmJlZm9yZVwiOlxyXG4vLyB7Y29udGVudDogJ1wiaGlcIid9fWAuIFN1Yi1zZWxlY3RvcnMgYW5kIHJlZ3VsYXIgcHJvcGVydGllcyBjYW5cclxuLy8gZnJlZWx5IGJlIG1peGVkIGluIGEgZ2l2ZW4gb2JqZWN0LiBBbnkgcHJvcGVydHkgY29udGFpbmluZyBhIGAmYCBpc1xyXG4vLyBhc3N1bWVkIHRvIGJlIGEgc3ViLXNlbGVjdG9yLlxyXG4vL1xyXG4vLyBGaW5hbGx5LCBhIHByb3BlcnR5IGNhbiBzcGVjaWZ5IGFuIEAtYmxvY2sgdG8gYmUgd3JhcHBlZCBhcm91bmQgdGhlXHJcbi8vIHN0eWxlcyBkZWZpbmVkIGluc2lkZSB0aGUgb2JqZWN0IHRoYXQncyB0aGUgcHJvcGVydHkncyB2YWx1ZS4gRm9yXHJcbi8vIGV4YW1wbGUgdG8gY3JlYXRlIGEgbWVkaWEgcXVlcnkgeW91IGNhbiBkbyBge1wiQG1lZGlhIHNjcmVlbiBhbmRcclxuLy8gKG1pbi13aWR0aDogNDAwcHgpXCI6IHsuLi59fWAuXHJcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/style-mod/src/style-mod.js\n"));

/***/ }),

/***/ "./node_modules/w3c-keyname/index.es.js":
/*!**********************************************!*\
  !*** ./node_modules/w3c-keyname/index.es.js ***!
  \**********************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"base\": function() { return /* binding */ base; },\n/* harmony export */   \"keyName\": function() { return /* binding */ keyName; },\n/* harmony export */   \"shift\": function() { return /* binding */ shift; }\n/* harmony export */ });\nvar base = {\r\n  8: \"Backspace\",\r\n  9: \"Tab\",\r\n  10: \"Enter\",\r\n  12: \"NumLock\",\r\n  13: \"Enter\",\r\n  16: \"Shift\",\r\n  17: \"Control\",\r\n  18: \"Alt\",\r\n  20: \"CapsLock\",\r\n  27: \"Escape\",\r\n  32: \" \",\r\n  33: \"PageUp\",\r\n  34: \"PageDown\",\r\n  35: \"End\",\r\n  36: \"Home\",\r\n  37: \"ArrowLeft\",\r\n  38: \"ArrowUp\",\r\n  39: \"ArrowRight\",\r\n  40: \"ArrowDown\",\r\n  44: \"PrintScreen\",\r\n  45: \"Insert\",\r\n  46: \"Delete\",\r\n  59: \";\",\r\n  61: \"=\",\r\n  91: \"Meta\",\r\n  92: \"Meta\",\r\n  106: \"*\",\r\n  107: \"+\",\r\n  108: \",\",\r\n  109: \"-\",\r\n  110: \".\",\r\n  111: \"/\",\r\n  144: \"NumLock\",\r\n  145: \"ScrollLock\",\r\n  160: \"Shift\",\r\n  161: \"Shift\",\r\n  162: \"Control\",\r\n  163: \"Control\",\r\n  164: \"Alt\",\r\n  165: \"Alt\",\r\n  173: \"-\",\r\n  186: \";\",\r\n  187: \"=\",\r\n  188: \",\",\r\n  189: \"-\",\r\n  190: \".\",\r\n  191: \"/\",\r\n  192: \"`\",\r\n  219: \"[\",\r\n  220: \"\\\\\",\r\n  221: \"]\",\r\n  222: \"'\"\r\n}\r\n\r\nvar shift = {\r\n  48: \")\",\r\n  49: \"!\",\r\n  50: \"@\",\r\n  51: \"#\",\r\n  52: \"$\",\r\n  53: \"%\",\r\n  54: \"^\",\r\n  55: \"&\",\r\n  56: \"*\",\r\n  57: \"(\",\r\n  59: \":\",\r\n  61: \"+\",\r\n  173: \"_\",\r\n  186: \":\",\r\n  187: \"+\",\r\n  188: \"<\",\r\n  189: \"_\",\r\n  190: \">\",\r\n  191: \"?\",\r\n  192: \"~\",\r\n  219: \"{\",\r\n  220: \"|\",\r\n  221: \"}\",\r\n  222: \"\\\"\"\r\n}\r\n\r\nvar chrome = typeof navigator != \"undefined\" && /Chrome\\/(\\d+)/.exec(navigator.userAgent)\r\nvar gecko = typeof navigator != \"undefined\" && /Gecko\\/\\d+/.test(navigator.userAgent)\r\nvar mac = typeof navigator != \"undefined\" && /Mac/.test(navigator.platform)\r\nvar ie = typeof navigator != \"undefined\" && /MSIE \\d|Trident\\/(?:[7-9]|\\d{2,})\\..*rv:(\\d+)/.exec(navigator.userAgent)\r\nvar brokenModifierNames = mac || chrome && +chrome[1] < 57\r\n\r\n// Fill in the digit keys\r\nfor (var i = 0; i < 10; i++) base[48 + i] = base[96 + i] = String(i)\r\n\r\n// The function keys\r\nfor (var i = 1; i <= 24; i++) base[i + 111] = \"F\" + i\r\n\r\n// And the alphabetic keys\r\nfor (var i = 65; i <= 90; i++) {\r\n  base[i] = String.fromCharCode(i + 32)\r\n  shift[i] = String.fromCharCode(i)\r\n}\r\n\r\n// For each code that doesn't have a shift-equivalent, copy the base name\r\nfor (var code in base) if (!shift.hasOwnProperty(code)) shift[code] = base[code]\r\n\r\nfunction keyName(event) {\r\n  var ignoreKey = brokenModifierNames && (event.ctrlKey || event.altKey || event.metaKey) ||\r\n    ie && event.shiftKey && event.key && event.key.length == 1 ||\r\n    event.key == \"Unidentified\"\r\n  var name = (!ignoreKey && event.key) ||\r\n    (event.shiftKey ? shift : base)[event.keyCode] ||\r\n    event.key || \"Unidentified\"\r\n  // Edge sometimes produces wrong names (Issue #3)\r\n  if (name == \"Esc\") name = \"Escape\"\r\n  if (name == \"Del\") name = \"Delete\"\r\n  // https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/8860571/\r\n  if (name == \"Left\") name = \"ArrowLeft\"\r\n  if (name == \"Up\") name = \"ArrowUp\"\r\n  if (name == \"Right\") name = \"ArrowRight\"\r\n  if (name == \"Down\") name = \"ArrowDown\"\r\n  return name\r\n}\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdzNjLWtleW5hbWUvaW5kZXguZXMuanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBFQUEwRSxHQUFHO0FBQzdFO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixRQUFRO0FBQ3hCO0FBQ0E7QUFDQSxnQkFBZ0IsU0FBUztBQUN6QjtBQUNBO0FBQ0EsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy93M2Mta2V5bmFtZS9pbmRleC5lcy5qcz82MzVhIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCB2YXIgYmFzZSA9IHtcclxuICA4OiBcIkJhY2tzcGFjZVwiLFxyXG4gIDk6IFwiVGFiXCIsXHJcbiAgMTA6IFwiRW50ZXJcIixcclxuICAxMjogXCJOdW1Mb2NrXCIsXHJcbiAgMTM6IFwiRW50ZXJcIixcclxuICAxNjogXCJTaGlmdFwiLFxyXG4gIDE3OiBcIkNvbnRyb2xcIixcclxuICAxODogXCJBbHRcIixcclxuICAyMDogXCJDYXBzTG9ja1wiLFxyXG4gIDI3OiBcIkVzY2FwZVwiLFxyXG4gIDMyOiBcIiBcIixcclxuICAzMzogXCJQYWdlVXBcIixcclxuICAzNDogXCJQYWdlRG93blwiLFxyXG4gIDM1OiBcIkVuZFwiLFxyXG4gIDM2OiBcIkhvbWVcIixcclxuICAzNzogXCJBcnJvd0xlZnRcIixcclxuICAzODogXCJBcnJvd1VwXCIsXHJcbiAgMzk6IFwiQXJyb3dSaWdodFwiLFxyXG4gIDQwOiBcIkFycm93RG93blwiLFxyXG4gIDQ0OiBcIlByaW50U2NyZWVuXCIsXHJcbiAgNDU6IFwiSW5zZXJ0XCIsXHJcbiAgNDY6IFwiRGVsZXRlXCIsXHJcbiAgNTk6IFwiO1wiLFxyXG4gIDYxOiBcIj1cIixcclxuICA5MTogXCJNZXRhXCIsXHJcbiAgOTI6IFwiTWV0YVwiLFxyXG4gIDEwNjogXCIqXCIsXHJcbiAgMTA3OiBcIitcIixcclxuICAxMDg6IFwiLFwiLFxyXG4gIDEwOTogXCItXCIsXHJcbiAgMTEwOiBcIi5cIixcclxuICAxMTE6IFwiL1wiLFxyXG4gIDE0NDogXCJOdW1Mb2NrXCIsXHJcbiAgMTQ1OiBcIlNjcm9sbExvY2tcIixcclxuICAxNjA6IFwiU2hpZnRcIixcclxuICAxNjE6IFwiU2hpZnRcIixcclxuICAxNjI6IFwiQ29udHJvbFwiLFxyXG4gIDE2MzogXCJDb250cm9sXCIsXHJcbiAgMTY0OiBcIkFsdFwiLFxyXG4gIDE2NTogXCJBbHRcIixcclxuICAxNzM6IFwiLVwiLFxyXG4gIDE4NjogXCI7XCIsXHJcbiAgMTg3OiBcIj1cIixcclxuICAxODg6IFwiLFwiLFxyXG4gIDE4OTogXCItXCIsXHJcbiAgMTkwOiBcIi5cIixcclxuICAxOTE6IFwiL1wiLFxyXG4gIDE5MjogXCJgXCIsXHJcbiAgMjE5OiBcIltcIixcclxuICAyMjA6IFwiXFxcXFwiLFxyXG4gIDIyMTogXCJdXCIsXHJcbiAgMjIyOiBcIidcIlxyXG59XHJcblxyXG5leHBvcnQgdmFyIHNoaWZ0ID0ge1xyXG4gIDQ4OiBcIilcIixcclxuICA0OTogXCIhXCIsXHJcbiAgNTA6IFwiQFwiLFxyXG4gIDUxOiBcIiNcIixcclxuICA1MjogXCIkXCIsXHJcbiAgNTM6IFwiJVwiLFxyXG4gIDU0OiBcIl5cIixcclxuICA1NTogXCImXCIsXHJcbiAgNTY6IFwiKlwiLFxyXG4gIDU3OiBcIihcIixcclxuICA1OTogXCI6XCIsXHJcbiAgNjE6IFwiK1wiLFxyXG4gIDE3MzogXCJfXCIsXHJcbiAgMTg2OiBcIjpcIixcclxuICAxODc6IFwiK1wiLFxyXG4gIDE4ODogXCI8XCIsXHJcbiAgMTg5OiBcIl9cIixcclxuICAxOTA6IFwiPlwiLFxyXG4gIDE5MTogXCI/XCIsXHJcbiAgMTkyOiBcIn5cIixcclxuICAyMTk6IFwie1wiLFxyXG4gIDIyMDogXCJ8XCIsXHJcbiAgMjIxOiBcIn1cIixcclxuICAyMjI6IFwiXFxcIlwiXHJcbn1cclxuXHJcbnZhciBjaHJvbWUgPSB0eXBlb2YgbmF2aWdhdG9yICE9IFwidW5kZWZpbmVkXCIgJiYgL0Nocm9tZVxcLyhcXGQrKS8uZXhlYyhuYXZpZ2F0b3IudXNlckFnZW50KVxyXG52YXIgZ2Vja28gPSB0eXBlb2YgbmF2aWdhdG9yICE9IFwidW5kZWZpbmVkXCIgJiYgL0dlY2tvXFwvXFxkKy8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50KVxyXG52YXIgbWFjID0gdHlwZW9mIG5hdmlnYXRvciAhPSBcInVuZGVmaW5lZFwiICYmIC9NYWMvLnRlc3QobmF2aWdhdG9yLnBsYXRmb3JtKVxyXG52YXIgaWUgPSB0eXBlb2YgbmF2aWdhdG9yICE9IFwidW5kZWZpbmVkXCIgJiYgL01TSUUgXFxkfFRyaWRlbnRcXC8oPzpbNy05XXxcXGR7Mix9KVxcLi4qcnY6KFxcZCspLy5leGVjKG5hdmlnYXRvci51c2VyQWdlbnQpXHJcbnZhciBicm9rZW5Nb2RpZmllck5hbWVzID0gbWFjIHx8IGNocm9tZSAmJiArY2hyb21lWzFdIDwgNTdcclxuXHJcbi8vIEZpbGwgaW4gdGhlIGRpZ2l0IGtleXNcclxuZm9yICh2YXIgaSA9IDA7IGkgPCAxMDsgaSsrKSBiYXNlWzQ4ICsgaV0gPSBiYXNlWzk2ICsgaV0gPSBTdHJpbmcoaSlcclxuXHJcbi8vIFRoZSBmdW5jdGlvbiBrZXlzXHJcbmZvciAodmFyIGkgPSAxOyBpIDw9IDI0OyBpKyspIGJhc2VbaSArIDExMV0gPSBcIkZcIiArIGlcclxuXHJcbi8vIEFuZCB0aGUgYWxwaGFiZXRpYyBrZXlzXHJcbmZvciAodmFyIGkgPSA2NTsgaSA8PSA5MDsgaSsrKSB7XHJcbiAgYmFzZVtpXSA9IFN0cmluZy5mcm9tQ2hhckNvZGUoaSArIDMyKVxyXG4gIHNoaWZ0W2ldID0gU3RyaW5nLmZyb21DaGFyQ29kZShpKVxyXG59XHJcblxyXG4vLyBGb3IgZWFjaCBjb2RlIHRoYXQgZG9lc24ndCBoYXZlIGEgc2hpZnQtZXF1aXZhbGVudCwgY29weSB0aGUgYmFzZSBuYW1lXHJcbmZvciAodmFyIGNvZGUgaW4gYmFzZSkgaWYgKCFzaGlmdC5oYXNPd25Qcm9wZXJ0eShjb2RlKSkgc2hpZnRbY29kZV0gPSBiYXNlW2NvZGVdXHJcblxyXG5leHBvcnQgZnVuY3Rpb24ga2V5TmFtZShldmVudCkge1xyXG4gIHZhciBpZ25vcmVLZXkgPSBicm9rZW5Nb2RpZmllck5hbWVzICYmIChldmVudC5jdHJsS2V5IHx8IGV2ZW50LmFsdEtleSB8fCBldmVudC5tZXRhS2V5KSB8fFxyXG4gICAgaWUgJiYgZXZlbnQuc2hpZnRLZXkgJiYgZXZlbnQua2V5ICYmIGV2ZW50LmtleS5sZW5ndGggPT0gMSB8fFxyXG4gICAgZXZlbnQua2V5ID09IFwiVW5pZGVudGlmaWVkXCJcclxuICB2YXIgbmFtZSA9ICghaWdub3JlS2V5ICYmIGV2ZW50LmtleSkgfHxcclxuICAgIChldmVudC5zaGlmdEtleSA/IHNoaWZ0IDogYmFzZSlbZXZlbnQua2V5Q29kZV0gfHxcclxuICAgIGV2ZW50LmtleSB8fCBcIlVuaWRlbnRpZmllZFwiXHJcbiAgLy8gRWRnZSBzb21ldGltZXMgcHJvZHVjZXMgd3JvbmcgbmFtZXMgKElzc3VlICMzKVxyXG4gIGlmIChuYW1lID09IFwiRXNjXCIpIG5hbWUgPSBcIkVzY2FwZVwiXHJcbiAgaWYgKG5hbWUgPT0gXCJEZWxcIikgbmFtZSA9IFwiRGVsZXRlXCJcclxuICAvLyBodHRwczovL2RldmVsb3Blci5taWNyb3NvZnQuY29tL2VuLXVzL21pY3Jvc29mdC1lZGdlL3BsYXRmb3JtL2lzc3Vlcy84ODYwNTcxL1xyXG4gIGlmIChuYW1lID09IFwiTGVmdFwiKSBuYW1lID0gXCJBcnJvd0xlZnRcIlxyXG4gIGlmIChuYW1lID09IFwiVXBcIikgbmFtZSA9IFwiQXJyb3dVcFwiXHJcbiAgaWYgKG5hbWUgPT0gXCJSaWdodFwiKSBuYW1lID0gXCJBcnJvd1JpZ2h0XCJcclxuICBpZiAobmFtZSA9PSBcIkRvd25cIikgbmFtZSA9IFwiQXJyb3dEb3duXCJcclxuICByZXR1cm4gbmFtZVxyXG59XHJcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/w3c-keyname/index.es.js\n"));

/***/ })

},
/******/ function(__webpack_require__) { // webpackRuntimeModules
/******/ var __webpack_exec__ = function(moduleId) { return __webpack_require__(__webpack_require__.s = moduleId); }
/******/ __webpack_require__.O(0, ["pages/_app","main"], function() { return __webpack_exec__("./node_modules/next/dist/build/webpack/loaders/next-client-pages-loader.js?absolutePagePath=C%3A%5CUsers%5CPower%5COneDrive%5CDesktop%5CDemo%20Product%5CCodeTranslate%5Copenai-quickstart-node%5Cpages%5Cindex.js&page=%2F!"); });
/******/ var __webpack_exports__ = __webpack_require__.O();
/******/ _N_E = __webpack_exports__;
/******/ }
]);